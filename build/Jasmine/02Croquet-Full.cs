'From Squeak3.6 of ''6 October 2003'' [latest update: #5429] on 5 October 2004 at 8:21:21 am'!Object subclass: #CroquetData	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'Croquet-Misc'!!CroquetData commentStamp: 'DPR 2/15/2004 16:51' prior: 0!Class holds methods for accessing data files.!CroquetData class	instanceVariableNames: ''!Object subclass: #CroquetGlobals	instanceVariableNames: ''	classVariableNames: 'FrameScale Snapshots TheTeapotMorph '	poolDictionaries: ''	category: 'Croquet-Misc'!CroquetGlobals class	instanceVariableNames: ''!Object subclass: #CroquetTools	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'Croquet-Misc'!CroquetTools class	instanceVariableNames: ''!BitBlt subclass: #OGLBlt	instanceVariableNames: 'ogl textOffset textPosition '	classVariableNames: ''	poolDictionaries: ''	category: 'Croquet-OpenGL'!OGLBlt class	instanceVariableNames: ''!Canvas subclass: #OGLCanvas	instanceVariableNames: 'ogl origin clipRect clipDepth shadowColor '	classVariableNames: ''	poolDictionaries: 'OpenGLConstants '	category: 'Croquet-OpenGL'!OGLCanvas class	instanceVariableNames: ''!Object subclass: #OGLExtManager	instanceVariableNames: 'ogl '	classVariableNames: ''	poolDictionaries: 'GLExtConstants '	category: 'Croquet-OpenGL'!!OGLExtManager commentStamp: '<historical>' prior: 0!OGLExtManager handles OpenGL extension functions for OGL. Since extensions are specific for particular renderer/drivers all extensions must be looked up dynamically. I provide the technical means to handle extensions transparently for any number of contexts.Declaring Extensions:========================Extension functions (and constants) have to be specifically declared. To declare functions and constants for an extension you need to do the following:#1: Go to the CLASS side of OGLExtManager and add a category that has the same name as listed in glGet(GL_EXTENSIONS). For example, to use the ARB imaging extension this category must be named GL_ARB_imaging (even though the extension is referred to as 'ARB imaging' glGet will tell us that the name GL_ARB_imaging so that is what you need to use).WARNING: The name must match EXACTLY, no extra spaces, watch for small and capital letters etc.#2: Add a method which initializes the constants in this extension. The method itself MUST follow the convention to begin with 'initialize' and should then use the extension name. E.g., for initializing the constants in the ARB_imaging it should be called 'initializeArbImaging'.The constants itself can be initialized by just copying them from the spec describing them and use the provided utility methods for initialization (just look over a few existing extensions). I am trying to make it easy for you to just copy those constants.Note that all constants appear ONLY in the GLExtConstants - OpenGLConstants is exclusively used for standard OpenGL constants.#3: Add the functions the extension defines. Generally, these should just be plain ffi call methods but there are three important issues:	a) NEVER provide a 'module' for these functions. Since they are looked up by opengl specific means other ways are used and you MUST NOT provide a module. The extension this particular function is contained in is defined by the category and not by the module (this is to prevent confusion about 'I have no GL_ARB_imaging.dll' or even worse the possibility that on some system any such thing even exists (!!)).	b) NEVER do anything but just the plain FFI call (optionally followed by a plain return or call to #externalCallFailed). The method you are writing will actually be run in an entirely different place - you are only providing a template for the sake of your convenience (and speed). If you need more sophisticated error handling do this in the place where you call the method or provide a helper in OGL or something similar, but NEVER EVER DO THIS HERE.	c) The calling convention is effectively ignored. Since it is platform specific it will in fact be replaced by the appropriate OS calling convention when used.#4: Evaluate 'OGLExtManager initialize' which will add the constants to GLExtConstants and compile forwarder methods in OGL.Using Extensions:====================Once you declared the extension, using it is simple. Since the constants defined by the extension are accessible through the GLExtConstants pool, you can just refer to them by name.To invoke an extension method you simply invoke it via ogl, e.g., in order to invoke the 'glUnlockArraysEXT' function you would use something like:	ogl glUnlockArraysEXTetc.IMPORTANT: You must never ever attempt to create a OGLExtManager explicitly. The OGLExtManager is transparently wrapped in OGL.Implementation details:===========================In order to implement the dynamic lookup mechanism in the most convenient way, the OGLExtManager is always created as a 'unique subclass' of OGLExtManager. That is when you ask for a new extension manager using 'OGLExtManager new' you actually get a subclass of OGLExtManager which is denoted by an asterisk in front of it so it looks as *OGLExtManager.The *OGLExtManager does not understand any of the function you have provided. When it runs into a message which it doesn't understand it performs the following functions:1: First it looks if that method is in fact an extension method you defined.2: If it is, it looks if the extension this method belongs to is present in the renderer it is bound to (e.g., the OGLExtManager's ogl inst var)3: If the extension is present it looks at the functions you declared for this extension, and for each function	- it copies the template method	- it looks up calling convention / address of the function	- it installs a new ffi call spec for that method	- it adds this method to *OGLExtManager4: Once all the function for the extension have been loaded it reinvokes the message which failed.Preloading extensions:=========================As you can see from the implementation details, there is a certain overhead involved in handling extensions. In particular, there can be a noticable speed impact when an extension is loaded 'on demand' (e.g., when a message is not understood). To compensate for this, extensions can be loaded explicitly, by using, e.g.,	ogl loadExtension: #'GL_ARB_imaging'.!OGLExtManager class	instanceVariableNames: ''!Object subclass: #OGLFontManager	instanceVariableNames: 'glx fonts charList '	classVariableNames: ''	poolDictionaries: 'OpenGLConstants '	category: 'Croquet-OpenGL'!OGLFontManager class	instanceVariableNames: ''!Object subclass: #OGLTextureHandle	instanceVariableNames: 'glID target timeStamp scaledSize bytesUsed allocated '	classVariableNames: ''	poolDictionaries: 'OpenGLConstants '	category: 'Croquet-OpenGL'!!OGLTextureHandle commentStamp: '<historical>' prior: 0!Class TextureHandle represents a texture handle for internal use by the texture manager.Instance variables:	glID			<Integer>	The 'texture name' of OpenGL associated with this texture	target		<Integer>	The OpenGL target (e.g., GLTexture2d)	frameStamp	<Integer>	The stamp for the frame when this texture was last used	scaledSize	<Point>		The ultimate size the texture needs to be scaled to (power of two)	bytesUsed	<Integer>	The number of bytes associated with this texture on the graphics hardware	allocated 	<Boolean>	True if the texture is currently allocated on the graphics hardware, false if not.!OGLTextureHandle class	instanceVariableNames: ''!Object subclass: #OGLTextureManager	instanceVariableNames: 'glx ogl textures memAvail memUsed memFrame '	classVariableNames: ''	poolDictionaries: 'OpenGLConstants GLExtConstants '	category: 'Croquet-OpenGL'!OGLTextureManager class	instanceVariableNames: ''!B3DHardwareEngine subclass: #OpenGL	instanceVariableNames: 'glExt extensions frontFace currentPortal maxPortalDepth changeTexture test timeStamp textureManager fontManager glListRegistry instance isMirror inPortal3D openDisplayList camera forceWire '	classVariableNames: 'InstalledOpenGLLibrary '	poolDictionaries: 'OpenGLConstants GLExtConstants '	category: 'Croquet-OpenGL'!!OpenGL commentStamp: '<historical>' prior: 0!This is the extended OpenGL engine. I include a number of routines that might otherwise be found in GLU and a number of other routines that allow the OGL object to maintain some global state. Examples of this are frameNumber, and testing frustum bounds.!OpenGL subclass: #OGLMacOSX	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'Croquet-OpenGL'!OGLMacOSX subclass: #OGLMacOS9	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'Croquet-OpenGL'!OpenGL subclass: #OGLUnix	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'Croquet-OpenGL'!OpenGL subclass: #OGLUnixQuartz	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'Croquet-OpenGL'!OGLUnix subclass: #OGLUnixX11BE	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'Croquet-OpenGL'!OGLUnix subclass: #OGLUnixX11LE	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'Croquet-OpenGL'!OpenGL subclass: #OGLWin32	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'Croquet-OpenGL'!OpenGL class	instanceVariableNames: ''!OGLMacOSX class	instanceVariableNames: ''!OGLMacOS9 class	instanceVariableNames: ''!OGLUnix class	instanceVariableNames: ''!OGLUnixQuartz class	instanceVariableNames: ''!OGLUnixX11BE class	instanceVariableNames: ''!OGLUnixX11LE class	instanceVariableNames: ''!OGLWin32 class	instanceVariableNames: ''!Morph subclass: #OpenGLMorph	instanceVariableNames: 'myRenderer '	classVariableNames: ''	poolDictionaries: 'OpenGLConstants '	category: 'Croquet-Morphic'!!OpenGLMorph commentStamp: '<historical>' prior: 0!This is just a simple test case I keep around to make sure I am not going crazy. Every so often, I need to check to see if OpenGL still works!!DAS!OpenGLMorph class	instanceVariableNames: ''!Exception subclass: #RequestProjectOwner	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'Croquet-Misc'!RequestProjectOwner class	instanceVariableNames: ''!AlignmentMorph subclass: #SpreadSheet	instanceVariableNames: 'numRows numColumns rows colWidth rowHeight top left selectedField tSpreadSheet '	classVariableNames: ''	poolDictionaries: ''	category: 'Croquet-Morphic-Demo'!SpreadSheet class	instanceVariableNames: ''!TextMorph subclass: #SpreadSheetField	instanceVariableNames: 'spreadSheet row column '	classVariableNames: ''	poolDictionaries: ''	category: 'Croquet-Morphic-Demo'!SpreadSheetField class	instanceVariableNames: ''!Object subclass: #TBoundSphere	instanceVariableNames: 'localPosition globalPosition radius radiusSquared children vertices frame box normal up side offset '	classVariableNames: ''	poolDictionaries: 'OpenGLConstants '	category: 'Croquet-Objects'!!TBoundSphere commentStamp: '<historical>' prior: 0!This is the main bounds test object. It is used for object culling against view planes, ray testing, and for collision detection. It is defined heirarchically for the collision detection and object picking algorithms. Things to do:	Add bidirectional boundsphere references to an octree.	!TBoundSphere class	instanceVariableNames: ''!Object subclass: #TBox	instanceVariableNames: 'minCorner maxCorner '	classVariableNames: ''	poolDictionaries: ''	category: 'Croquet-Objects'!!TBox commentStamp: '<historical>' prior: 0!TBox has a number of uses. It is an axis aligned bounding box (AABB) defined by two 3D corners. It is used by the TBoundSphere to help define the boundSphere tree. !TBox class	instanceVariableNames: ''!Morph subclass: #TButtonMorph	instanceVariableNames: 'label highlightColor oldColor oldWidth highlightWidth '	classVariableNames: ''	poolDictionaries: ''	category: 'Croquet-Morphs'!!TButtonMorph commentStamp: '<historical>' prior: 0!TButtonMorph new openInWorld!TButtonMorph class	instanceVariableNames: ''!Object subclass: #TCleanup	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'Croquet-Misc'!TCleanup class	instanceVariableNames: ''!Object subclass: #TCurveFitter3	instanceVariableNames: 'debug '	classVariableNames: ''	poolDictionaries: ''	category: 'Croquet-CAD'!TCurveFitter3 class	instanceVariableNames: ''!Object subclass: #TExportData	instanceVariableNames: 'id refClass instShape indexedSize binary data '	classVariableNames: ''	poolDictionaries: ''	category: 'Croquet-Export'!TExportData class	instanceVariableNames: ''!Object subclass: #TExporter	instanceVariableNames: 'refMap shapeMap dataStream lvl byteSize baseUrl resources '	classVariableNames: ''	poolDictionaries: ''	category: 'Croquet-Export'!TExporter class	instanceVariableNames: ''!Object subclass: #TFileOutMaker	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'Croquet-Misc'!TFileOutMaker class	instanceVariableNames: ''!Model subclass: #TGraphicsTest	instanceVariableNames: 'textPane runButton teapot '	classVariableNames: ''	poolDictionaries: ''	category: 'Croquet-Morphic'!!TGraphicsTest commentStamp: '<historical>' prior: 0!TGraphicsTest open!TGraphicsTest class	instanceVariableNames: ''!HandMorph subclass: #THandMorph	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'Croquet-Objects'!THandMorph class	instanceVariableNames: ''!Object subclass: #TImporter	instanceVariableNames: 'refMap shapeMap reshapeMap attributes resources '	classVariableNames: ''	poolDictionaries: ''	category: 'Croquet-Export'!!TImporter commentStamp: '<historical>' prior: 0!MessageTally spyOn:[TImporter importFile:'underwater.tea']!TImporter class	instanceVariableNames: ''!SmartSyntaxInterpreterPlugin subclass: #TLoad3DSMaxPlugin	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'Croquet-Misc'!TLoad3DSMaxPlugin class	instanceVariableNames: ''!TestCase subclass: #TLoad3DSMaxTest	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'Croquet-Objects'!TLoad3DSMaxTest class	instanceVariableNames: ''!AlignmentMorphBob1 subclass: #TLoginMorph	instanceVariableNames: 'theName theNameMorph thePasswordMorph actionBlock cancelBlock '	classVariableNames: ''	poolDictionaries: ''	category: 'Croquet-Morphs'!!TLoginMorph commentStamp: '<historical>' prior: 0!TLoginMorph new openInWorld!TLoginMorph class	instanceVariableNames: ''!ProtoObject subclass: #TMetaNil	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'Croquet-TObject'!!TMetaNil commentStamp: '<historical>' prior: 0!Doesn't do anything - but on purpose.!TMetaNil class	instanceVariableNames: ''!Notification subclass: #TMetaNotification	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'Croquet-TObject'!!TMetaNotification commentStamp: '<historical>' prior: 0!TMetaNotification is used to ensure that nested meta messages do not result in remote message sends. A meta message is already sent remotely, and if it in turn calls another meta message, this message will be executed multiple times. This could be bad. This class is used in the following way:[ local message send] on: TMetaNotification "send the remote message"					do: [ :ex | ex resume: true].	TMetaNotification signal ifFalse: [ "we are not currently nested in a meta message"	 message remote send here	 ] 		] ifTrue:[local message here]. "send just the local message here"!TMetaNotification class	instanceVariableNames: ''!ProtoObject subclass: #TMetaSend	instanceVariableNames: 'teaObject '	classVariableNames: ''	poolDictionaries: ''	category: 'Croquet-TObject'!!TMetaSend commentStamp: 'ar 10/4/2004 14:17' prior: 0!***** Meta *****David A. SmithThis set of classes implements "meta", which is an extension to the syntax of Croquet and the TeaTime collaboration architecture. To use it, you simply add meta (or variant) between the object and it's message. The messages of interest are:*************  meta  **************To send a message locally and remotely simply do:	tframe meta translationX: 1 y: 2 z: 3.	tframe meta setSolid: true.	tframe meta addChild: newFrame.Warning: the following (and messages like it) will NOT work.	tframe meta localTransform rotateAroundY: 32.The reason is the meta message that gets sent is #localTransform. This returns a pure B3DMatrix4x4 that knows nothing about teatime. But of course, this:	tframe meta localTransform: (tframe localTransform rotateAroundY: 32)works just fine.*************  metaSend  **************To send a message remotely only do:	tframe metaSend localTransform: trans.	tframe metaSend translation: (1@2@3).This does nothing locally.*************  metaValue *************To ensure that the return value of any meta call is also accessible as a meta teatime object, simply call:	browser _ browser metaValue openEditString: nil.	transform _ tframe metaValue localTransform.	transform meta rotationAroundY: 30.	aframe meta localTransform: transform.*************  Class meta  **************To construct local and remote objects do:	tframe := TSuburban meta initialize: glx terrain: terrain.	tframe meta translation: (self translation)+(10@0@0).	self parent meta addChild: tframe.Essentially, you replace #new with #meta.*************  Class meta:glx  **************Non-tea objects can be constructed to act as full-fledged teaObjects with this:	browser _ (Browser meta: glx) teaValue.	browser _ browser metaValue openEditString: nil.***** Meta containersNon-teatime objects can be constructed as pseudo-teatime objects. This is done by constructing a TMetaContainer which is a TObject and placing the non-teaobject into it. This allows for synchronization of any kind of object via the same #meta and #metaSend messages.We usually need to do this when we construct a number of objects and have to assemble them remotely.A meta container wrapper is generated for any primitive (non-teatime) object simply by sending the message 'meta: glx' after the class name:browser _ Browser meta: glx. The end result is that we have a TMetaContainer (of a Browser in this case) on all machines. Then, when we send any message, it is sent to all of these objects which in turn forward the message to the primitive object contained within.*****DefaultIf there is no teaParty, #meta messages simply return the base object, effectively doing nothing - except for the constructor which returns a new object of the requested class. We will probably make glx a global, so even this won't do anything if there is no current teaParty.*****ClassesThe following classes have either been modified or added to support meta:Object - added #meta: glX to support non-teatime objects.TMeta - new class to enable multiple redirection - subclass of ProtoObject.TObject - added the meta, metaSend keywords.TObject class - added the meta keyword to support construction. TMetaContainer - allows any object to be treated as a true tea object.!TMetaSend subclass: #TMeta	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'Croquet-TObject'!!TMeta commentStamp: '<historical>' prior: 0!***** Meta *****David A. SmithThis set of classes implements "meta", which is an extension to the syntax of Croquet and the TeaTime collaboration architecture. To use it, you simply add meta (or variant) between the object and it's message. The messages of interest are:*************  meta  **************To send a message locally and remotely simply do:	tframe meta translationX: 1 y: 2 z: 3.	tframe meta setSolid: true.	tframe meta addChild: newFrame.Warning: the following (and messages like it) will NOT work.	tframe meta localTransform rotateAroundY: 32.The reason is the meta message that gets sent is #localTransform. This returns a pure B3DMatrix4x4 that knows nothing about teatime. But of course, this:	tframe meta localTransform: (tframe localTransform rotateAroundY: 32)works just fine.*************  metaSend  **************To send a message remotely only do:	tframe metaSend localTransform: trans.	tframe metaSend translation: (1@2@3).This does nothing locally.*************  metaValue *************To ensure that the return value of any meta call is also accessible as a meta teatime object, simply call:	browser _ browser metaValue openEditString: nil.	transform _ tframe metaValue localTransform.	transform meta rotationAroundY: 30.	aframe meta localTransform: transform.*************  Class meta  **************To construct local and remote objects do:	tframe := TSuburban meta initialize: glx terrain: terrain.	tframe meta translation: (self translation)+(10@0@0).	self parent meta addChild: tframe.Essentially, you replace #new with #meta.*************  Class meta:glx  **************Non-tea objects can be constructed to act as full-fledged teaObjects with this:	browser _ (Browser meta: glx) teaValue.	browser _ browser metaValue openEditString: nil.***** Meta containersNon-teatime objects can be constructed as pseudo-teatime objects. This is done by constructing a TMetaContainer which is a TObject and placing the non-teaobject into it. This allows for synchronization of any kind of object via the same #meta and #metaSend messages.We usually need to do this when we construct a number of objects and have to assemble them remotely.A meta container wrapper is generated for any primitive (non-teatime) object simply by sending the message 'meta: glx' after the class name:browser _ Browser meta: glx. The end result is that we have a TMetaContainer (of a Browser in this case) on all machines. Then, when we send any message, it is sent to all of these objects which in turn forward the message to the primitive object contained within.*****DefaultIf there is no teaParty, #meta messages simply return the base object, effectively doing nothing - except for the constructor which returns a new object of the requested class. We will probably make glx a global, so even this won't do anything if there is no current teaParty.*****ClassesThe following classes have either been modified or added to support meta:Object - added #meta: glX to support non-teatime objects.TMeta - new class to enable multiple redirection - subclass of ProtoObject.TObject - added the meta, metaSend keywords.TObject class - added the meta keyword to support construction. TMetaContainer - allows any object to be treated as a true tea object.!TMetaSend class	instanceVariableNames: ''!TMeta class	instanceVariableNames: ''!Model subclass: #TModel	instanceVariableNames: 'myEventMap myScripts window '	classVariableNames: ''	poolDictionaries: ''	category: 'Croquet-Misc'!!TModel commentStamp: '<historical>' prior: 0!TModel open.!TModel subclass: #TConnectionDialog	instanceVariableNames: 'teapot forceTunnel disableInternet partyName nickName partyURL '	classVariableNames: ''	poolDictionaries: ''	category: 'Croquet-Misc'!!TConnectionDialog commentStamp: '<historical>' prior: 0!TConnectionDialog open!TModel class	instanceVariableNames: ''!TConnectionDialog class	instanceVariableNames: ''!Object subclass: #TObject	instanceVariableNames: 'teaObjectName '	classVariableNames: ''	poolDictionaries: 'OpenGLConstants '	category: 'Croquet-TObject'!!TObject commentStamp: '<historical>' prior: 0!Base class for Croquet objects. Supports the construction and message handling of the Croquet collaboration architecture.TObjects are normally referred to via references through "veils".   TObject new creates an instance of a "veil" object that holds the TObject, TObject copy creates a veiled copy, etc.The veil object's role is to handle CroquetMessage dispatching to all active replicas in a CroquetDistributor set.   As such, the veil represents "all instances" and the TObject the local instance.The instance variable "selves" refers to the veil object, and provides a way for the object to refer to its many "selves".Note that the veil object has a fast path built into it for the common case of messages that are already replicated.!TObject subclass: #TFrame	instanceVariableNames: 'myEventMap myScripts myBehaviors myPlayer objectName objectOwner localTransform globalTransform globalPosition frameParent singleParent frameChildren frameChanged timeStamp visible solid stepsOn stepperActive stepTime lastStepTime streamingSound test '	classVariableNames: ''	poolDictionaries: 'OpenGLConstants GLExtConstants '	category: 'Croquet-Objects'!!TFrame commentStamp: '<historical>' prior: 0!The TFrame class is designed as a heirarchical transformation frame. The rendering engine walks through the frame, performing the appropriate transformation associated with it, then it calls the render methods of the tObjects. Two passes are made through the frame heirarchy. The first is for non-alpha objects, the second for alpha. The base frame is owned by a TSpace object. We render from the root up because we want to minimize setting transforms." ***** This is how you rotate an object using a quaternion ball. The base position is stored in the selectedPoint and compared with the pointer selectedPoint.	pointer event2D shiftPressed ifTrue:[		pointer frame: self pickSphere: B3DVector3 new radiusSquared: selectedRadiusSquared.		spin _ self rotFromBallPoints: selectedPoint to: pointer selectedPoint.		trans _ self translation.		self translationX: 0.0 y:0.0 z:0.0.		self localTransform: (self localTransform composeWith: spin).		self translation: trans.		]"" ***** This is how you move an object relative to a specified plane. In this case, it is the plane determined by either the camera or the surface normal when the object is selected. 	- cameraNorm defines the plane perpendicular to the line of sight of the camera	- selectedNorm defines the norm of the selected surface of the object.	- slab frontNorm forces a normal to the front of the slab (for example).	ifFalse:[	(pointer frame: self pickPlane: selectedPoint normal: cameraNorm) ifTrue:[		delta _ selectedPoint - pointer selectedPoint.		self translation: (self translation - (self orientation localPointToGlobal: delta)).		^ true.].]."	^ false.!TFrame subclass: #TBody	instanceVariableNames: 'velocity tracer attractors start stepRemainder speed '	classVariableNames: ''	poolDictionaries: ''	category: 'Croquet-Demo'!!TBody commentStamp: '<historical>' prior: 0!TBody is used as the third body in the 3 body simulation described in T3Body.!TFrame subclass: #TCAD2D	instanceVariableNames: 'base baseBack grid min max matBlue matRed selected paths currentPath resolution resInverse previousPlane nextPlane via1 via2 '	classVariableNames: ''	poolDictionaries: ''	category: 'Croquet-CAD'!TFrame subclass: #TCrosshair	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'Croquet-Objects'!!TCrosshair commentStamp: '<historical>' prior: 0!This is a small crosshair in the center ofthe camera field of view.!TFrame subclass: #TDemoBot	instanceVariableNames: 'myTarget mySpace targets state stateTime '	classVariableNames: ''	poolDictionaries: ''	category: 'Croquet-Demo'!TFrame subclass: #TFlag	instanceVariableNames: 'extent segments elements velocity normals gravity kSpring texture windPeriod windPhase elapsed tackTop tackBottom tackTopLoc tackBottomLoc boundSphere lastFrameNumber counter stepsLagging '	classVariableNames: ''	poolDictionaries: 'OpenGLConstants '	category: 'Croquet-Objects'!!TFlag commentStamp: '<historical>' prior: 0!This class generates a dynamic flag object.!TFrame subclass: #TGroup	instanceVariableNames: 'doColorize '	classVariableNames: ''	poolDictionaries: ''	category: 'Croquet-Objects'!!TGroup commentStamp: '<historical>' prior: 0!TGroup is a TFrame which is always guaranteed to be invisible. It is used as a container and root object of a collection of child frames.!TGroup subclass: #T3Body	instanceVariableNames: 'earth earthFrame earthRot tilt moon moonFrame moonVelocity earthGravity moonGravity thirdBody stepRemainder speed saveVelocity savePosition '	classVariableNames: ''	poolDictionaries: ''	category: 'Croquet-Demo'!!T3Body commentStamp: '<historical>' prior: 0!T3Body is the main class used to demonstrate 3 body gravitional paths. It works in concert with the class TBody which is the 3rd body that is influenced by the gravitational sources and with TTracer which generates and maintains a path.Simply call	tframe _ T3Body new.!TGroup subclass: #TAttractor	instanceVariableNames: 'radius radiusSquared mass hard '	classVariableNames: ''	poolDictionaries: ''	category: 'Croquet-Objects'!!TAttractor commentStamp: '<historical>' prior: 0!TAttractor is a gravitational source.!TGroup subclass: #TAvatar	instanceVariableNames: 'content nickname host speaker doRender height footFrame lastDownFrame lastDownPosition forwardOnY gotoCount gotoTransform snapTrans sticky speedControl driving controlPitch currentSpace laser transparency downPointer pointer camera '	classVariableNames: ''	poolDictionaries: ''	category: 'Croquet-Objects'!!TAvatar commentStamp: '<historical>' prior: 0!TAvatar is the view the user presents of himself in a space. !TGroup subclass: #TBillboard	instanceVariableNames: 'selectedPoint cameraNorm '	classVariableNames: ''	poolDictionaries: ''	category: 'Croquet-Objects'!!TBillboard commentStamp: '<historical>' prior: 0!TBillboard always points toward the current camera allowing for such effects as a 2D billboard (if you add a textured rectangle to the frame).!TGroup subclass: #TButton	instanceVariableNames: 'enable frame frame2 action target action2 target2 animateTime color persist switch spin doSpin local deltaSpin '	classVariableNames: ''	poolDictionaries: ''	category: 'Croquet-Objects'!!TButton commentStamp: '<historical>' prior: 0!TButton is an active frame that tracks user events to initiate actions. When the user's pointer is over a child frame of a TButton it is highlighted. When it is clicked, a message can be sent to a target. TButton can have two different child frames to show a boolean state.!TGroup subclass: #TCADObject	instanceVariableNames: 'path selectedPlane surface extend extendDistance '	classVariableNames: ''	poolDictionaries: ''	category: 'Croquet-CAD'!TGroup subclass: #TCamera	instanceVariableNames: 'viewPort bounds viewAngle zNear zFar zScreen length clipPlanes clipPlanesTransform viewClip portalClip portalPlane inPortal currentSpace texture killFrame '	classVariableNames: ''	poolDictionaries: ''	category: 'Croquet-Objects'!!TCamera commentStamp: '<historical>' prior: 0!The z value of the camera matrix actually points away from the direction of view. This seems to be a standard approach for OpenGL. instance variables:viewPortTypically the underlying morph in this implementation. Any valid OpenGL buffer should work.	boundsUsually nil, which means that its actual value will be derived from the bounds of the current viewPort. bounds is the area that is rendered into. You can set this (#bounds:) to have an explicit hard value.viewAngleThis is the view angle of the camera measured top to bottom. The default is 45 degrees, which means that the angle of the top and bottom edges of the rendered image are 45 degrees apart.zNear, zFarThe near and far clipping planes in the graphics engine.zScreenThis is the z distance from the camera that the virtual screen would be. That is, when you have an x,y location on the real screen, you can add the zScreen value (x,y,zScreen) and normalize which gives you an accurate pointing vector in 3D space.lengthComputed by initClipPlanes and used to render the test camera.clipPlanes, clipPlanesTransformclipPlanes are the four frustum clip planes defined in the cameras local orientation.clipPlanesTransform are the four clipPlanes in the cameras global orientation frame. This is what is used to determine if objects are visible inside of the view frustum.viewClip This is used to test the visibility culling of the camera. It makes the clipping planes visible. This is obsolete, but it may be useful again if we ever start playing with the object clipping code again. portalClipThis is an additional clip plane defined by a portal. Objects on the near side of the portal need to be clipped away as well. This is a 4x4 transform.portalPlaneThis is a 3D vector calculated from the portalClip.inPortalA flag indicating whether we are rendering a portals contents from this camera or not. This is used to supress certain tests (such as finding floors), and to determine that the avatar should or should not be rendered.textureSimply a texture that gets added to the default rendered camera. Not used anymore unless you really need to see the default camera.killFrameA flag to indicate that the current rendered image is junk and should not be rendered. This suppresses a swapBuffers call.goToPortal, goToPortalTransformWhen a camera is moved through a portal into a new space, the new portal is set in goToPortal and the new transform inside the new space. Actually, goToPortal can be any valid frame, we are only looking for the root frame.goToTransform is the global transform that the camera is moved to in the new world. See #skidoo for actual use.lookAt, lookUpVectors that are computed from the global transform. They are the z-vector emerging from the camera in the center of the screen, and the y vector pointing straight up from the cameras view. These are useful for creating new objects directly in front of the camera.renderIntervalDefines the time between renderings in milliseconds. !TGroup subclass: #TClock	instanceVariableNames: 'face hour minute second lastPositionUpdate '	classVariableNames: ''	poolDictionaries: 'OpenGLConstants '	category: 'Croquet-Service'!!TClock commentStamp: '<historical>' prior: 0!This is a very simple component class which will be used to show how to build components in Tea.DAS!TGroup subclass: #TEditBox	instanceVariableNames: 'corners edges sides contents box edgeScale matNorm matEdge matCorner matSide matOver matHilite selectedFrame selectedPoint lastSpin scaleContents '	classVariableNames: ''	poolDictionaries: ''	category: 'Croquet-Objects'!!TEditBox commentStamp: '<historical>' prior: 0!TEditBox is used to manipulate and position a contained object in 3D space.!TGroup subclass: #TEscalator	instanceVariableNames: 'treadHeight numTreads texture speed '	classVariableNames: ''	poolDictionaries: 'OpenGLConstants '	category: 'Croquet-Service'!TGroup subclass: #TForceWire	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'Croquet-Objects'!TGroup subclass: #TLaser	instanceVariableNames: 'shaft point selected arrowLength radius length color glowMaterial glowPointMaterial spell attachment '	classVariableNames: ''	poolDictionaries: ''	category: 'Croquet-Objects'!!TLaser commentStamp: '<historical>' prior: 0!TLaser is used by the TUserCamera to show other users what this user is currently pointing at or manipulating.!TGroup subclass: #TLazySusan	instanceVariableNames: 'contents spin lastSpin matNorm matOver matDown selectedPoint tinyCube cameraNorm selectedNorm selectedRadiusSquared '	classVariableNames: ''	poolDictionaries: 'OpenGLConstants '	category: 'Croquet-Service'!TObject subclass: #TLeaf	instanceVariableNames: 'timeStamp childPrimitives parentPrimitives isStatic valid '	classVariableNames: ''	poolDictionaries: ''	category: 'Croquet-Objects'!TLeaf subclass: #TForm	instanceVariableNames: 'form fileName updateRect extent bMipmap bShrinkFit locator extension thumb memUsed '	classVariableNames: 'DefaultForm '	poolDictionaries: 'OpenGLConstants GLExtConstants '	category: 'Croquet-Objects'!!TForm commentStamp: '<historical>' prior: 0!TForm is an imaging object that maps Squeak forms into OpenGL textures. It is also intended to act as a static Croquet object type in that it will typically be kept in a universal teaparty. When it is created, it also generates a thumbnail version of itself that can be copied and stored as part of a TTexture.!TGroup subclass: #TLife	instanceVariableNames: 'matrix matrix2 cube cellX cellY texture changed '	classVariableNames: ''	poolDictionaries: ''	category: 'Croquet-Service'!!TLife commentStamp: '<historical>' prior: 0!The Game of Life was invented by John Conway (as you might have gathered). The game is played on a field of cells, each of which has eight neighbors (adjacent cells). A cell is either occupied (by an organism) or not. The rules for deriving a generation from the previous one are these: Death If an occupied cell has 0, 1, 4, 5, 6, 7, or 8 occupied neighbors, the organism dies(0, 1 neighbors: of loneliness; 4 thru 8: of overcrowding). Survival If an occupied cell has two or three neighbors, the organism survives to the next generation. Birth If an unoccupied cell has three occupied neighbors, it becomes occupied.  This uses the Matrix class.!TGroup subclass: #TLight	instanceVariableNames: 'type local position ambientColor diffuseColor specularColor spotDirection spotExponent spotCutoff renderObject distance '	classVariableNames: ''	poolDictionaries: 'OpenGLConstants '	category: 'Croquet-Objects'!!TLight commentStamp: '<historical>' prior: 0!TLight- Spaces. Each space can contain any number of lights, but only the closest eight are actually enabled, with the furthest two linearly fading depending upon distance ratios. The limit of eight lights is a hard coded issue with OpenGL. The lights and their frames are stored in an array in the TSpace object. When a TSpace is rendered, it activates the lights first.- Visibility. Lights are render objects that can be visible or not. This is to help in placing them. A visible light is represented either with a TSphere for positional, a TCylinder for spot, or two TCylinders for directional. These objects are rendered with an alpha value in the color of the light. - Locality. A light can be applied only to a frame and its children by setting local to true. Otherwise, it is global to the containing space.- Attenutation. This assumes constant attenuation for performance reasons.Things to do:	- Need to utilize material types for rendering light objects.!TGroup subclass: #TLink	instanceVariableNames: 'nextLocal selectedPoint cameraNorm gravity link mass force velocity deltaTime kSpring springLength '	classVariableNames: ''	poolDictionaries: 'OpenGLConstants '	category: 'Croquet-Service'!TFrame subclass: #TLoad3DSMax	instanceVariableNames: 'vertices tvertices faces tfaces matIndex stringLoc materialList materialRef textureList scale shadeAngle shadeAngleCos frame textureMode transform inverseTransform aheadChar filePath '	classVariableNames: 'DelimSet1 DelimSet2 DelimSet3 NumberSet WhiteSpaceSet '	poolDictionaries: 'OpenGLConstants '	category: 'Croquet-Objects'!!TLoad3DSMax commentStamp: '<historical>' prior: 0!TLoad3DSMax Notes:There are two parts to the class - the parse routines and everything else. The actual #parse: method creates a block hierarchy - essentially a kind of parse tree, from the inputs. 3DS is somewhat regular in its construction, but there are a few things to be careful about. The tree that gets constructed is made up of a field name and a field. The field names are tokenized 3DS field names and the field is the child tree or the actual text field data - not parsed into actual numbers or anything yet. One improvement on performance might be to interleave this step with the next.Once the tree exists, a second pass is made that converts the text fields and constructs the actual frame hierarchy. The field name of each node is matched and the appropriate #make****: routine is called on its contents. Once a raw mesh is set up inside the #makeGeometry: method, the #reconstruct: method is called. This does a lot of massaging and optimization of the raw vertices - including aliasing, etc. Anyway, start at:	#initialize: fileName: scale: shadeAngle: textureMode: Based upon the field names in the tree constructed in #parse: you just make the call to the next #makeXXX:.- Though we have all of the transforms for the heirarchy, the actual locations of the meshes is already transformed. If I can think of a good reason to un-transform the mesh elements and then add the transform to the actual frame, I will do it. For now, treat it as a solid body.- The texture rotations are face centered. This requires an offset of 0.5, the rotation, and then putting it back. Not sure if I really want to pre-transform the texture uv coordinates. Also, not sure if this is already done, as the meshes are.- This class will act as a template for importers, though they all seem so different that this may be easier said than done.!TFrame subclass: #TLoadMDL	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'Croquet-Objects'!!TLoadMDL commentStamp: '<historical>' prior: 0!TLoadMDL is used to load Alice models.!TFrame subclass: #TMaterial	instanceVariableNames: 'ambientColor diffuseColor specularColor emissiveColor shininess transparency renderObject cullFace flipFace fullBright texture textureMode subMaterialList uvScale uvOffset uvAngle scale boundSphere '	classVariableNames: 'DefaultAmbient DefaultDiffuse DefaultEmission DefaultShininess DefaultSpecular DefaultWhite '	poolDictionaries: 'OpenGLConstants '	category: 'Croquet-Objects'!!TMaterial commentStamp: '<historical>' prior: 0!TMaterial is used to maintain and set material properties of objects. It can also be rendered itself to aid the design of the material. It displays the canonical teapot when used this way.!TFrame subclass: #TMesh	instanceVariableNames: 'materialList vertices alias vtxNormals textureUV faceGroups alpha opaque boundsChanged boundSphere boundsDepth boundMaterial glListID glListAlphaID glListValid glListAlphaValid glListEnabled glInstance cachingEnabled cachingAlphaEnabled '	classVariableNames: ''	poolDictionaries: 'OpenGLConstants '	category: 'Croquet-Objects'!!TMesh commentStamp: '<historical>' prior: 0!das 10/7/2002 11:49TMeshAlmost all simple arrays are 0 based when indexed by other arrays. Not the materialList.materialList - this is an OrderedCollection of materials that are used in the mesh. This is what the first element of the faceGroups refers to. This must always be a list.alias - you can ignore this for now. It is important when we start doing mesh based transforms, because it tells you where the aliased vertices are.vertices - 0 index based list of 3D vertices.vtxNormals - the normal 3D vector for the given vertex.alpha - checks the materials referenced by the facegroups for alpha values. Calculated for you based upon the materialList.opaque  - same as alpha, but inverted.textureUV - the 2D u,v coordinates of the texture at the associated vertex.faceGroups - an array of materialList index (indexing starting at 1), and vertex face index arrays (index starting at 0). These are simply interleaved. boundsChanged - calculated for you at construction time. boundSphere - calculated for you.boundsDepth - part of construction and used to determine the depth of the hierarchy.boundMaterial - only used if you need to see the bound spheres or bound cubes.These are the analogs to the equivalent TPrimitives. There are two sets because a TMesh may have some materials that have alpha components and some that don't. These are rendered at different times, so they need separate display lists.glListID glListAlphaID glListValid glListAlphaValid glListEnabled!TObject subclass: #TMorphMonitor	instanceVariableNames: 'world eventsTo form hands '	classVariableNames: ''	poolDictionaries: ''	category: 'Croquet-IOMonitors'!!TMorphMonitor commentStamp: '<historical>' prior: 0!TMorphMonitor object is the object class that manages a morphic project.   It should be created in a tea party that is never replicated.   A view of the morph can be obtained via the TMorphic object.TMorphMonitor new initializeWithWorld: aProjName opaque: aBool extent:  worldExtentis used to open a TMorphMonitor on a project.Once open, remote machines can send handleEvent2D:pointer: and close messages to it.It maps pointers into hands.!TFrame subclass: #TMyCube	instanceVariableNames: 'txtr boundSphere move '	classVariableNames: ''	poolDictionaries: ''	category: 'Croquet-Demo'!!TMyCube commentStamp: '<historical>' prior: 0!TMyCube is used in the manual to describe how to create objects in Croquet.!TObject class	instanceVariableNames: ''!TFrame class	instanceVariableNames: 'scriptIcon '!TBody class	instanceVariableNames: ''!TCAD2D class	instanceVariableNames: ''!TCrosshair class	instanceVariableNames: ''!TDemoBot class	instanceVariableNames: ''!TFlag class	instanceVariableNames: ''!TGroup class	instanceVariableNames: ''!T3Body class	instanceVariableNames: ''!TAttractor class	instanceVariableNames: ''!TAvatar class	instanceVariableNames: ''!TBillboard class	instanceVariableNames: ''!TButton class	instanceVariableNames: ''!TCADObject class	instanceVariableNames: ''!TCamera class	instanceVariableNames: ''!TClock class	instanceVariableNames: ''!TEditBox class	instanceVariableNames: ''!TEscalator class	instanceVariableNames: ''!TForceWire class	instanceVariableNames: ''!TLaser class	instanceVariableNames: ''!TLazySusan class	instanceVariableNames: ''!TLeaf class	instanceVariableNames: ''!TForm class	instanceVariableNames: ''!TLife class	instanceVariableNames: ''!TLight class	instanceVariableNames: ''!TLink class	instanceVariableNames: ''!TLoad3DSMax class	instanceVariableNames: ''!TLoadMDL class	instanceVariableNames: ''!TMaterial class	instanceVariableNames: ''!TMesh class	instanceVariableNames: ''!TMorphMonitor class	instanceVariableNames: ''!TMyCube class	instanceVariableNames: ''!TObject subclass: #TOverlayButtons	instanceVariableNames: 'space camLoc snapCamera phone popup ctrl '	classVariableNames: ''	poolDictionaries: ''	category: 'Croquet-Objects'!TOverlayButtons class	instanceVariableNames: ''!TObject subclass: #TOverlayRearView	instanceVariableNames: 'bounds camera '	classVariableNames: ''	poolDictionaries: ''	category: 'Croquet-Objects'!TOverlayRearView class	instanceVariableNames: ''!TModel subclass: #TPainter	instanceVariableNames: 'leftButton rightButton editor repaintedPlayer replaceOldCostume sketchLib '	classVariableNames: ''	poolDictionaries: ''	category: 'Croquet-Misc'!!TPainter commentStamp: '<historical>' prior: 0!TPainter open!TPainter class	instanceVariableNames: ''!TFrame subclass: #TParticle	instanceVariableNames: 'size pPosition pVelocity pAcceleration pLifetime pColor pDeltaColor positionRange velocityRange accelerationRange lifetimeRange maxTime lastTime material boundsChanged boundSphere boundBox deltaTime billBoard startColor endColor tar tvr lengthArray lastGlobalPosition attrArray tpr pLastPosition globalVelocity attractors '	classVariableNames: ''	poolDictionaries: ''	category: 'Croquet-Objects'!!TParticle commentStamp: '<historical>' prior: 0!TParticleThis is a very simple particle system.size - the length or the particle array, determines max number of particles.pPosition - B3DVector3Array of particle positionspVelocity - B3DVector3Array of particle velocitiespAcceleration - B3DVector3Array of particle accelerationspLifetime - number of seconds (floating point) of life that each particle has leftpositionRange - the TBox within which new particles get created (see TBox >> #atRandom:)velocityRange - the 3D velocity range within which the new particles start life.accelerationRange - the 3D acceleration range applied to each particle on creation.lifetimeRange - the lifespan range of each particle.lastTime - for #the stepAt: method, used to determine time between this and the last cycle.material - what color are the particles.To use the particle system you do the following:	ps _ TParticle initialize: ogl size: 1000	ps setPositionRangeMin:(-0.1@-0.1@-0.1) max: (0.1@0.1@0.1).	ps setVelocityRangeMin:(-1.2@6.4@-1.2) max:(1.2@9.6@1.2).	ps setAccelerationRangeMin:(0@-10@0) max:(0@-8@0).	ps setLifetimeRange: (1500 to: 2000).These values are called inside of the initialize method, but this is how you would set your one.!TParticle class	instanceVariableNames: ''!TParticle subclass: #TParticleTxtr	instanceVariableNames: 'textures pTexture '	classVariableNames: ''	poolDictionaries: ''	category: 'Croquet-Objects'!!TParticleTxtr commentStamp: '<historical>' prior: 0!TParticleTxtr is a textured particle.!TParticleTxtr class	instanceVariableNames: ''!FloatArray variableWordSubclass: #TPatch	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'Croquet-Objects'!!TPatch commentStamp: '<historical>' prior: 0!Used to generate and maintain Bezier patches.!TPatch class	instanceVariableNames: ''!TFrame subclass: #TPath	instanceVariableNames: 'splines linkSpline resolution resInverse previousSpline thisSpline via1 via2 nextSpline gridPath vertices vHeight vLength box '	classVariableNames: ''	poolDictionaries: ''	category: 'Croquet-CAD'!TPath class	instanceVariableNames: ''!TFrame subclass: #TPhysicsEngine	instanceVariableNames: 'gravity floor t1 t2 '	classVariableNames: ''	poolDictionaries: 'OpenGLConstants '	category: 'Croquet-Objects'!!TPhysicsEngine commentStamp: '<historical>' prior: 0!Early physics engine. Much more to do.!TPhysicsEngine class	instanceVariableNames: ''!TFrame subclass: #TPortal3D	instanceVariableNames: 'toSpace inPortal scale scaleInverse angle offset clipBox boundSphere boundsChanged cube '	classVariableNames: ''	poolDictionaries: ''	category: 'Croquet-Objects'!!TPortal3D commentStamp: '<historical>' prior: 0!TPortal3D are a kind of 3D portal. They render a miniature version of a space (or a subset of it). The content of this portal can be manipulated normally.!TPortal3D class	instanceVariableNames: ''!TFrame subclass: #TPrimitive	instanceVariableNames: 'texture textureAlpha material materialAlpha boundsChanged boundSphere glListID oglInstance cachingEnabled '	classVariableNames: ''	poolDictionaries: 'OpenGLConstants '	category: 'Croquet-Objects'!!TPrimitive commentStamp: '<historical>' prior: 0!TPrimitive is the base class of a lot of the simple classes such as TCube, TSphere, TRectangle. It is primarily used to help manage graphics caching.!TPrimitive subclass: #TCube	instanceVariableNames: 'extent location vertices normals quadFaces changed txtCoords '	classVariableNames: ''	poolDictionaries: ''	category: 'Croquet-Objects'!!TCube commentStamp: '<historical>' prior: 0!TCube generates and renders a simple cube.!TPrimitive subclass: #TCylinder	instanceVariableNames: 'baseRadius topRadius height slices stacks capped '	classVariableNames: ''	poolDictionaries: ''	category: 'Croquet-Objects'!!TCylinder commentStamp: '<historical>' prior: 0!TCylinder generates an OGL generalized cylinder (cone).!TCylinder subclass: #TLinedCylinder	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'Croquet-Objects'!!TLinedCylinder commentStamp: '<historical>' prior: 0!Like TCylinder, but with its "lining" surface rendered the same as its outside surface.!TPrimitive subclass: #TManifold	instanceVariableNames: 'contents spanSize extent scale lastFrameNumber '	classVariableNames: ''	poolDictionaries: ''	category: 'Croquet-Service'!!TManifold commentStamp: '<historical>' prior: 0!A TManifold is used to render dynamic 2D matrices of values into a height map. The contents must return an array that is (size x * size y) in length, which is then rendered. Further, the contents must have a step message and a reset message.David A. Smith!TPrimitive class	instanceVariableNames: ''!TCube class	instanceVariableNames: ''!TCylinder class	instanceVariableNames: ''!TLinedCylinder class	instanceVariableNames: ''!TManifold class	instanceVariableNames: ''!TPrimitive subclass: #TPrimitiveMesh	instanceVariableNames: 'myMesh myCube '	classVariableNames: ''	poolDictionaries: ''	category: 'Croquet-Objects'!TPrimitiveMesh class	instanceVariableNames: ''!TPrimitive subclass: #TPrimitiveString	instanceVariableNames: 'string font color align '	classVariableNames: ''	poolDictionaries: ''	category: 'Croquet-Objects'!TPrimitiveString class	instanceVariableNames: ''!TPrimitive subclass: #TPrimitiveText	instanceVariableNames: 'text textStyle textColor textInset textBounds textAlign paragraph '	classVariableNames: ''	poolDictionaries: ''	category: 'Croquet-Objects'!TPrimitiveText class	instanceVariableNames: ''!TPrimitive subclass: #TQuad	instanceVariableNames: 'vertices normal '	classVariableNames: ''	poolDictionaries: ''	category: 'Croquet-Objects'!!TQuad commentStamp: '<historical>' prior: 0!TQuad is a TPrimitive used to render four sided objects.!TQuad class	instanceVariableNames: ''!TFrame subclass: #TQuadTree	instanceVariableNames: 'quadCenter quadSize quadCorner inBox outBox radius center globalCenter spheres depth qtTL qtTR qtBL qtBR boundSphere quadOn angle '	classVariableNames: ''	poolDictionaries: 'OpenGLConstants '	category: 'Croquet-Objects'!!TQuadTree commentStamp: '<historical>' prior: 0!TQuadTreeThis is a spatial "loose" quadtree. It is used for fast visibility and collision detection.A loose octree/quadtree is one where an object is contained in only one octree cell. This cell is smallest cell that can completely contain the object, and the one that contains the "center" of the object. In our case, the one that contains the center of the bound sphere. The object is allowed to overlap onto adjacent cells, thus when we test for collisions, we need to compare to the current cell and all of its adjacents. The advantage is significantly simpler and faster bookkeeping.To use the TQuadTree just use the initialize method:#initializeWithSpace: space frame: frame.This will figure out the proper size of the quadtree from the elements inside of frame and it will place the TBoundSpheres into their proper slots. Then just add the TQuadTree to another frame, usually the TSpace, and you are done.TRay tests only work if the TRay is a downRay.DAS!TQuadTree class	instanceVariableNames: ''!TFrame subclass: #TRay	instanceVariableNames: 'automatic framePointer framePosition sphereDistSquared currentFrame selection lastSelection doSelect testDistance downRay minDistance minDistanceSquared maxDistance maxDistanceSquared '	classVariableNames: 'TDownRay '	poolDictionaries: ''	category: 'Croquet-Objects'!!TRay commentStamp: '<historical>' prior: 0!TRay specifies a position and orientation, usually inherited from it's parent TFrame. Though you can modify this. It is used to determine the closest object in a particular direction and the distance to that object. This is a factored TPointer change set. The new TRay class is concerned only with picking an object, while the new TPointer class is a subclass of TRay, but includes the events model. This means that the TCamera uses a TRay for the downPointer, and it also makes it easier to use a TRay for arbitrary objects looking for the floor. I also completely rewrote the actual matrix math. Essentially, a TRay is a TFrame with the ability to pick. Now it actually uses the local and global orientation matrices to perform the test. TRay tests are fairly expensive, so be careful with them. Also, I don't think you want to use a translation with them. I think more work needs to be done to make this robust.The way a TRay works is you simply place it as a child frame, and it will automatically get called at the next render loop. You can use it directly by calling the following methods:#pointerPick: or #pointerPickFloor: with a TBoundSphere as the argument (which in turn points to a TFrame) as the argument. If the return is true, then the TRay intersected the object.You can also call one of the #frame:xxxx:xxxx: messages if you know the type of object you are attempting to select. If you wish to check a number of objects and keep only the closest, call the message #testDistance:false. Make sure you call #testDistance: true when you are done.The following variables are for internal use only:	framePointer - is the ray orientation relative to the object we are testing against.	framePosition - is the ray location relative to the object we are testing against.	sphereDistSquared - is the distance to the recently tested sphere. 	currentFrame - this is the frame we are currently testing against.	doSelect - turns the selection of the TRay on/off. This is used by the TPointer to keep the pointer from selecting other objects between a mouseDown/mouseUp.	testDistance - a boolean that allows us to ignore the current distance when testing for object intersection. It is used when the user needs to determine intersection and to a specific object.	downRay - boolean indicates whether this is a floor test ray or not.	automatic - indicates whether a ray is tested automatically during rendering.The following variables are for external use:	selectedObject - this is the object that owns the selected object. It may be the same, but doesn't have to be.	selectedFrame - this is the frame object that is selected.	selectedFramePosition - this is the ray location relative to the selected object.	selectedParent - this is the parent of the selectedFrame at the time of rendering/selection.	selectedIndex - this may be used by the selectedObject. It is usually the surface index.	selectedPoint - this is the selected point in the local selectedFrame reference.	selectedNormal - this is the surface normal at the selectedPoint.	selectedDistance - this is the distance from the ray position.	selectedDistanceSquared - this is the squared distance from the ray position.		lastSelectedObject - previously completed selectedObject	lastSelectedFrame - previously completed selectedFrame	lastSelectedPoint - previously completed selectedPoint!TRay subclass: #TPointer	instanceVariableNames: 'pseudoCamera avatar event2D pointerXY keySelectedObject isDown tool spellClass '	classVariableNames: ''	poolDictionaries: ''	category: 'Croquet-Objects'!!TPointer commentStamp: '<historical>' prior: 0!The TPointer object is the user pointer control. It is used to communicate user requests to the components. It is a subclassed TRay. The variables it uses are:camera - this is the camera that the pointer is attached to. event2d - just the morphic event being passed in if we are working with a TMorph texture.pointerXY - is the 2d location of the mouse.keySelectedObject - if we pressed a key over an object, this keeps track of sameisDown - indicates that the mouse button is currently being pressed.tool - a user tool, pretty minimal at the moment. Ultimately, the user will be able to pick up new tools and wield them.!TRay class	instanceVariableNames: ''!TPointer class	instanceVariableNames: ''!TPrimitive subclass: #TRectangle	instanceVariableNames: 'extent location flip aspect aspectFixed norm '	classVariableNames: ''	poolDictionaries: 'OpenGLConstants '	category: 'Croquet-Objects'!!TRectangle commentStamp: '<historical>' prior: 0!TRectangle is a TPrimitive used to render rectangles.!TRectangle subclass: #TButtonHolder	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: 'OpenGLConstants '	category: 'Croquet-Objects'!!TButtonHolder commentStamp: '<historical>' prior: 0!TButtonHolder contains and positions TButtons in a 2D surface.!TRectangle subclass: #TPortal	instanceVariableNames: 'toPortal outVector locVector inside lastCameraPosition blocked locator cameraDistance '	classVariableNames: ''	poolDictionaries: ''	category: 'Croquet-Objects'!!TPortal commentStamp: '<historical>' prior: 0!TPortal is used to connect and see between TSpace objects. A TPortal has a link to another TPortal which in turn is embedded in another space. If the TPortal is linked back to itself, which is the default, it is treated as a mirror.!TRectangle class	instanceVariableNames: ''!TButtonHolder class	instanceVariableNames: ''!TPortal class	instanceVariableNames: ''!Object subclass: #TRenderAlpha	instanceVariableNames: 'tObject transform distance parent '	classVariableNames: ''	poolDictionaries: ''	category: 'Croquet-Objects'!!TRenderAlpha commentStamp: '<historical>' prior: 0!This class is used to render the alpha (transparent) objects. As an alpha object is found, a TRenderAlpha object is created that includes:	- the object	- its parent frame (if needed - probably not)	- its current world transform, which is used to transform the object into world coordinates.!TRenderAlpha class	instanceVariableNames: ''!Object subclass: #TResourceLoader	instanceVariableNames: 'mutex queue msgQueue loaderProcess loader request currentUrl '	classVariableNames: ''	poolDictionaries: ''	category: 'Croquet-Export'!TResourceLoader class	instanceVariableNames: ''!TFrame subclass: #TRigidBody	instanceVariableNames: 'frame inertiaTensor inverseInertiaTensor inverseWorldInertiaTensor mass oneOverMass centerMass centerMassWorld velocity momentum force angularMomentum torque energy dampingLinear dampingAngular '	classVariableNames: ''	poolDictionaries: ''	category: 'Croquet-Objects'!!TRigidBody commentStamp: '<historical>' prior: 0!TRigidBody is the core of the rigid body physics engine. It is itself a TFrame. At initialization, it is handed another frame, which presumably is some kind of mesh that can calculate its own inertia tensor. The TRigidBody is then installed into TPhysicsEngine, a physics engine which is responsible for updating it's state. This engine is designed to be independent of object position and orientation. It uses the current state of the frame and the current velocity and angular momentum to determine how the state will change. This does mean that if the object is currently undergoing a physical transform as it is being moved, it will continue to do so. !TRigidBody class	instanceVariableNames: ''!TGroup subclass: #TRover	instanceVariableNames: 'wheelRays wheelRadius wheelAngle wheelBase axleLength wheels frontTurn rearTurn leftFrontPair rightFrontPair leftSide rightSide rot speed wheelRotSpeed deltaSpeed turn turnAngle turnSpeed v1 v2 v3 vlr trans lastFrameNumber body lastTime updateTime inControl updateRemoteTime '	classVariableNames: ''	poolDictionaries: 'OpenGLConstants '	category: 'Croquet-Demo'!!TRover commentStamp: '<historical>' prior: 0!TRover is the 3D rover that is used in the mars simulation.!TRover class	instanceVariableNames: ''!AbstractSound subclass: #TSampledSound	instanceVariableNames: 'frameTime mySound buffers mutex codec baseSamplingRate counter seconds max min '	classVariableNames: ''	poolDictionaries: ''	category: 'Croquet-Demo'!TSampledSound class	instanceVariableNames: ''!ListItemWrapper subclass: #TScriptorWrapper	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'Croquet-Misc'!TScriptorWrapper class	instanceVariableNames: ''!TGroup subclass: #TScrollBox3D	instanceVariableNames: 'sides contents box matNorm matOver matHilite matDown selectedFrame selectedPoint scaleContents basePosition baseLength baseScale lastSelected shiftPressed selectedAction matEdge changed rotateAround deferScale newScale lastSpin rotPoint rotateDirection radius boxPoint matCorner '	classVariableNames: ''	poolDictionaries: ''	category: 'Croquet-CAD'!!TScrollBox3D commentStamp: '<historical>' prior: 0!TScrollBox3DThis is used to manipulate a 3D portal, as well as acting as a base class for the 3D TEditBox.!TScrollBox3D subclass: #TEditBox3D	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'Croquet-CAD'!TScrollBox3D class	instanceVariableNames: ''!TEditBox3D class	instanceVariableNames: ''!Object subclass: #TSelection	instanceVariableNames: 'object frame framePosition parent parentTransform distance distanceSquared index normal point triangle cameraTransform '	classVariableNames: ''	poolDictionaries: ''	category: 'Croquet-Objects'!TSelection class	instanceVariableNames: ''!TFrame subclass: #TSelectionTracker	instanceVariableNames: 'frame position normal '	classVariableNames: ''	poolDictionaries: ''	category: 'Croquet-Objects'!!TSelectionTracker commentStamp: '<historical>' prior: 0!I am an example for simple selection tracking.!TSelectionTracker class	instanceVariableNames: ''!TPrimitive subclass: #TSierpinski	instanceVariableNames: 'depth scale vertices normals surface1 surface2 surface3 surface4 vIndex sIndex changed '	classVariableNames: ''	poolDictionaries: ''	category: 'Croquet-Demo'!!TSierpinski commentStamp: '<historical>' prior: 0!TSierpinski generates a Sierpinski pyramid. !TSierpinski class	instanceVariableNames: ''!TGroup subclass: #TSimpleSpin	instanceVariableNames: 'contents angle isSpinning '	classVariableNames: ''	poolDictionaries: 'OpenGLConstants '	category: 'Croquet-Service'!TSimpleSpin class	instanceVariableNames: ''!SketchMorph subclass: #TSketchButtonMorph	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'Croquet-Morphs'!TSketchButtonMorph class	instanceVariableNames: ''!Morph subclass: #TSketchEditorMorph	instanceVariableNames: 'palette paintingForm formCanvas undoBuffer teapot '	classVariableNames: ''	poolDictionaries: 'OpenGLConstants '	category: 'Croquet-Morphs'!TSketchEditorMorph class	instanceVariableNames: ''!TGroup subclass: #TSkyBox	instanceVariableNames: 'dalpha '	classVariableNames: ''	poolDictionaries: 'OpenGLConstants '	category: 'Croquet-Objects'!!TSkyBox commentStamp: '<historical>' prior: 0!TSkyBox is used to render a slowly rotating sky in the world.!TSkyBox class	instanceVariableNames: ''!SketchMorph subclass: #TSnapshot	instanceVariableNames: 'frame root thumbnail tLocation tTime croquetObjectName globalTransform '	classVariableNames: ''	poolDictionaries: ''	category: 'Croquet-Objects'!!TSnapshot commentStamp: '<historical>' prior: 0!TSnapshotThis class holds a location and orientation inside of a TSpace for later use. It also generates a thumbnail from this location. This class can be used as a far portal, particularly if there is no far frame to be attached to.!TSnapshot class	instanceVariableNames: ''!Object subclass: #TSocket	instanceVariableNames: 'semaphore socketHandle readSemaphore writeSemaphore primitiveOnlySupportsOneSemaphore signalDispatcher connectSemaphore '	classVariableNames: 'Connected DeadServer InvalidSocket OtherEndClosed Registry RegistryThreshold TCPSocketType ThisEndClosed UDPSocketType Unconnected WaitingForConnection '	poolDictionaries: ''	category: 'Croquet-Misc'!TSocket class	instanceVariableNames: ''!TGroup subclass: #TSolar	instanceVariableNames: 'earth earthFrame earthRot windButton tilt moon moonFrame earthGravity moonGravity lowPressure wind spinning wideSpread '	classVariableNames: ''	poolDictionaries: ''	category: 'Croquet-Objects'!TSolar class	instanceVariableNames: ''!TGroup subclass: #TSpace	instanceVariableNames: 'croquetPlace color lightFrames portalFrames rayFrames alphaObjects currentParent currentTransform currentCameraTransform cullBackFaces fogOn fogStart fogEnd fogDensity ambientSound locator dropInFrame testRays savedAlphaObjects viewingParticipants '	classVariableNames: ''	poolDictionaries: ''	category: 'Croquet-Objects'!!TSpace commentStamp: '<historical>' prior: 0!A TSpace object acts as the root render frame. It is the ultimate container, and is the entry point to a render tree. TSpace objects are contained in CroquetPlace objects, and can be linked via portals. croquetPlace - the CroquetPlace object that this TSpace belongs to.color - the default color of the space. This is the color you see when there are no objects to render.lightFrames - an OrderedCollection of all of the TLights in the hierarchy inside of this space.portalFrames - an OrderedCollection of all ofthe TPortals in the hierarchy inside ofthis space.rayFrames - an OrderedCollection of all of the TRays in the hierarchy inside of this space.alphaObjects - a temporay OrderedCollection of the alpha objects to be drawn in each rendered frame.currentParent - the current parent object of the frame being rendered. This is used for instanced objects.currentTransform - the current transform of the frame.cullBackFaces - this is a flag to turn this on and off for everything in the space.fogOn fogStart fogEnd fogDensity - fog state variables.ambientSound - current local sound - to be deprecated.locator - url object.dropInFrameviewingParticipants - participants currently viewing (rendering) the space, directly or	through portals they view the space from.	viewingParticipants should be members of the tea party of every object in the space	and all of the spaces visible through portals.  When a new viewingParticipant is added	we walk through all the frames in the space, telling them about the new participant.	When a new child is added, we first tell it about all of the participants that are viewing	the space containing it, so it can ensure that participant is in its tea party. !TSpace subclass: #TCausticSpace	instanceVariableNames: 'caustics counter '	classVariableNames: ''	poolDictionaries: ''	category: 'Croquet-Demo'!!TCausticSpace commentStamp: '<historical>' prior: 0!This is a sub-class of TSpace intended to show off some nice caustic effects. The problem is that in order to support alpha objects, we need to add a third rendering pass. This will get done.DAS!TSpace class	instanceVariableNames: ''!TCausticSpace class	instanceVariableNames: ''!TModel subclass: #TSpaceBrowser	instanceVariableNames: 'avatar treePane rootFrame topFrame selectedFrameWrapper '	classVariableNames: ''	poolDictionaries: ''	category: 'Croquet-Misc'!!TSpaceBrowser commentStamp: '<historical>' prior: 0!TSpaceBrowser open!TSpaceBrowser class	instanceVariableNames: ''!TPortal subclass: #TSpaceImposter	instanceVariableNames: 'space box pixWidth '	classVariableNames: ''	poolDictionaries: ''	category: 'Croquet-Objects'!!TSpaceImposter commentStamp: '<historical>' prior: 0!TSpaceImposterThis class is used as a place holder for a complete space when it is viewed through a portal. It is a portal connected to a TSpace containing only a cube where the surfaces are rendered from the position of the connected frame. This gives the portal a true 3D effect without having to transfer the entire world.!TSpaceImposter class	instanceVariableNames: ''!TGroup subclass: #TSpeaker	instanceVariableNames: 'enable frame animateTime color persist strength '	classVariableNames: ''	poolDictionaries: ''	category: 'Croquet-Objects'!!TSpeaker commentStamp: '<historical>' prior: 0!TSpeaker is used to show that an avatar has voice chat enabled and the voice speaker volume.!TSpeaker class	instanceVariableNames: ''!TButton subclass: #TSpellBox	instanceVariableNames: 'spellClass '	classVariableNames: ''	poolDictionaries: ''	category: 'Croquet-Objects'!!TSpellBox commentStamp: '<historical>' prior: 0!TSpellBox is a test object used to allow the pointer to select a tool.!TSpellBox class	instanceVariableNames: ''!TPrimitive subclass: #TSphere	instanceVariableNames: 'segments '	classVariableNames: ''	poolDictionaries: ''	category: 'Croquet-Objects'!!TSphere commentStamp: '<historical>' prior: 0!TSphere is a TPrimitive used to render a sphere.DAS!TSphere class	instanceVariableNames: ''!TCube subclass: #TSpinCube	instanceVariableNames: 'rval '	classVariableNames: ''	poolDictionaries: ''	category: 'Croquet-Demo'!TSpinCube class	instanceVariableNames: ''!TGroup subclass: #TSpinner	instanceVariableNames: 'contents spin lastSpin matNorm matOver matDown selectedPoint tinyCube cameraNorm selectedNorm selectedRadiusSquared '	classVariableNames: ''	poolDictionaries: 'OpenGLConstants '	category: 'Croquet-Service'!TSpinner class	instanceVariableNames: ''!TMorphMonitor subclass: #TSpreadSheet	instanceVariableNames: 'spreadSheet selectRect '	classVariableNames: ''	poolDictionaries: ''	category: 'Croquet-IOMonitors'!TSpreadSheet class	instanceVariableNames: ''!TGroup subclass: #TSuburban	instanceVariableNames: 'car terrain sensors wheels axles pivots steers wheelRays wheelRadius wheelAngle wheelBase axleLength wheel frontTurn rearTurn rot speed wheelRotSpeed deltaSpeed turn turnAngle turnSpeed v1 v2 vlr trans maxTrans deltaTrans lastFrameNumber updateTime lastTime inControl '	classVariableNames: ''	poolDictionaries: 'OpenGLConstants '	category: 'Croquet-Demo'!!TSuburban commentStamp: '<historical>' prior: 0!TSuburban is used to show a robotic system moving around in a scene.!TSuburban class	instanceVariableNames: ''!TGroup subclass: #TSwarm	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'Croquet-Demo'!!TSwarm commentStamp: '<historical>' prior: 0!TSwarm is used to test TRay performance.!TSwarm class	instanceVariableNames: ''!TPrimitive subclass: #TTeapot	instanceVariableNames: 'patches gridSize scale type '	classVariableNames: ''	poolDictionaries: 'OpenGLConstants '	category: 'Croquet-Objects'!!TTeapot commentStamp: '<historical>' prior: 0!Standard Utah teapot. Used primarily for testing.!TTeapot class	instanceVariableNames: ''!Object subclass: #TTensor	instanceVariableNames: 'mass density vertices faces a b c t0 t1 t2 tp centerMass tensor notDone '	classVariableNames: ''	poolDictionaries: ''	category: 'Croquet-Objects'!!TTensor commentStamp: '<historical>' prior: 0!The algorithm used by this class was first developed by Brian Mirtich as described in:Brian Mirtich. Fast and accurate computation of polyhedral mass propertiesJournal of Graphics Tools, 1(2): 31-50, 1996This class will construct an inertia tensor. There are two initialize routines, one to specify mass, the other density. The class allows you to add any number of groups of faces and then calculate and return the results. There are two main return values - the tensor (tensor), a B3DMatrix4x4 and a center of mass (centerMass), a B3DVector3. Both of these values are available after the TTensor >> result message is sent. it _ TTensor new initializeMass: mass. " or use it _ TTensor new initializeDensity: density.""Add any number of groups of faces. This allows for disjoint or complex vertex/face groups. Remember that everything added is treated as a single rigid body."it addFaces: f1 vertices: v1.it addFaces: f2 vertices: v2.it addFaces: f3 vertices: v3.inertiaTensor _ it result.inertiaTensor _ it tensor.centerofmass _ it centerMass.!TTensor class	instanceVariableNames: ''!TRectangle subclass: #TTexture	instanceVariableNames: 'tform baseScale uvScale uvOffset mode uvAngle '	classVariableNames: ''	poolDictionaries: 'OpenGLConstants '	category: 'Croquet-Objects'!!TTexture commentStamp: '<historical>' prior: 0!This is used to create a GL texture from a form, either directly or from a file.This is dependent upon the TForm class, which handles the actual bits.DAS!TTexture class	instanceVariableNames: ''!TTexture subclass: #TTextureForm	instanceVariableNames: 'mouseOver passEvents targetExtent '	classVariableNames: ''	poolDictionaries: ''	category: 'Croquet-TextureForms'!!TTextureForm commentStamp: '<historical>' prior: 0!Abstract superclass for interactive spaces that are textures.   Such classes include morphic projects and X windows.   The contents of the texture is updated from an external application, and input events are mapped and delivered to the external application.!TTextureForm subclass: #TMorphic	instanceVariableNames: 'morphMonitor '	classVariableNames: ''	poolDictionaries: ''	category: 'Croquet-TextureForms'!!TMorphic commentStamp: '<historical>' prior: 0!A TMorphic object is intended to provide a view on a legacy morphic project. To use it:	tm := TMorphic new initializeOpaque: opaque.Then set up tmm, a TMorphicMonitor object on some machine.  Then:	tmm eventsTo: tm.User input events are passed to tmm, unless tm passEvents: false is set. !TMorphic subclass: #TMonitorWorld	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'Croquet-Objects'!!TMonitorWorld commentStamp: '<historical>' prior: 0!A morphic world designed to display performance monitoring information, such as frame rate, communications statistics, etc.!TMorphic subclass: #TSpreadSheetTxtr	instanceVariableNames: 'selection '	classVariableNames: ''	poolDictionaries: ''	category: 'Croquet-TextureForms'!TTextureForm class	instanceVariableNames: ''!TMorphic class	instanceVariableNames: ''!TMonitorWorld class	instanceVariableNames: ''!TSpreadSheetTxtr class	instanceVariableNames: ''!TFrame subclass: #TTextureStress	instanceVariableNames: 'textures '	classVariableNames: ''	poolDictionaries: ''	category: 'Croquet-Demo'!TTextureStress class	instanceVariableNames: ''!TPrimitive subclass: #TTorus	instanceVariableNames: 'segments innerRadius '	classVariableNames: ''	poolDictionaries: ''	category: 'Croquet-Objects'!!TTorus commentStamp: '<historical>' prior: 0!A torus shape primitive.!TTorus class	instanceVariableNames: ''!TFrame subclass: #TTracer	instanceVariableNames: 'path maxSize bounds '	classVariableNames: ''	poolDictionaries: ''	category: 'Croquet-Demo'!!TTracer commentStamp: '<historical>' prior: 0!TTRacer is used to leave a path in 3D space as an object moves through it. It is used by the 3 body simulation in T3Body.!TTracer class	instanceVariableNames: ''!TSpinner subclass: #TTree	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'Croquet-Demo'!!TTree commentStamp: '<historical>' prior: 0!TTree is a demonstration of hierarchical objects.!TTree class	instanceVariableNames: ''!TPrimitive subclass: #TTriangle	instanceVariableNames: 'v1 v2 v3 normal '	classVariableNames: ''	poolDictionaries: ''	category: 'Croquet-Objects'!!TTriangle commentStamp: '<historical>' prior: 0!TTriangle is a TPrimitive used to render triangles.This creates and renders your simple OpenGL triangle. Usually used for testing, but you have to start somewhere...!TTriangle class	instanceVariableNames: ''!TCamera subclass: #TUserCamera	instanceVariableNames: 'pointer mouseDownTime avatar yellowButtonPressed redButtonPressed doRender rearCam phone cameraButton overlaySpace remoteControl chatObject lastRenderTime renderInterval renderEstimate overlays debugOverlay buttonsOverlay morphicOverlay thirdPerson thirdPersonDelta avatarSpace downPointer '	classVariableNames: ''	poolDictionaries: ''	category: 'Croquet-Objects'!!TUserCamera commentStamp: '<historical>' prior: 0!TUserCamera is a TCamera that is used by the user to manipulate his position in space and render same.!TUserCamera class	instanceVariableNames: ''!SoundRecorder subclass: #TVoiceRecorder	instanceVariableNames: 'frameTime teaOwner testFeedback volumeAverage volumeBuffers '	classVariableNames: ''	poolDictionaries: ''	category: 'Croquet-Demo'!!TVoiceRecorder commentStamp: '<historical>' prior: 0!TVoiceRecorder new!TVoiceRecorder class	instanceVariableNames: ''!TGroup subclass: #TWaveDemo	instanceVariableNames: 'texture image contents stepSelector myColor timeOut '	classVariableNames: 'AllowBroadcast SomeInstance '	poolDictionaries: ''	category: 'Croquet-Demo'!TWaveDemo class	instanceVariableNames: ''!TRectangle subclass: #TWaves	instanceVariableNames: 'size surface force velocity fVert fHorz fDiag1 fDiag2 normals textureUV oneOverSqrtTwo selectedPoint cameraNorm envTexture matWater countDown nSteps '	classVariableNames: ''	poolDictionaries: 'OpenGLConstants '	category: 'Croquet-Demo'!!TWaves commentStamp: '<historical>' prior: 0!TWaves illustrates a simple cellular based wave function to simulate water. It also uses environment mapping. The #texture: message sets the base texture - what shows up under the water, and the #envTexture: message sets the environment map texture.!TWaves class	instanceVariableNames: ''!TFrame subclass: #TWidget	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'Croquet-Objects'!!TWidget commentStamp: '<historical>' prior: 0!TWidget is primarily used to load meshes that may be used as frames in TButtons. It sets up a number of properties such as initial materials and texture modes.!TWidget class	instanceVariableNames: ''!TGroup subclass: #TWindow	instanceVariableNames: 'windowFrame windowButtons rectFront rectBack splitRect frameOn tinyCube alpha dalpha matNorm matOver matDown matRectNorm matRectOver matRectDown matHilite matTiny selectedPoint selectedFrame pointerXY selectedNorm selectedObject cameraNorm selectedRadiusSquared selectedRadius eventNum spin lastSpin spinTime lastTime deltaTime contents saveContents contentsOn isBrowser contents3D '	classVariableNames: ''	poolDictionaries: 'OpenGLConstants '	category: 'Croquet-Window'!!TWindow commentStamp: '<historical>' prior: 0!TWindow is the Croquet windowing system. It can handle both 2D and 3D contents. Objects that are primarily 2D can be added via #contents:. 3D objects that require the removal of the back face of the window can be added via #contents3D:.!TWindow class	instanceVariableNames: ''!TGroup subclass: #TWindowButtons	instanceVariableNames: 'extent gotoButton killButton openButton grabButton cameraButton '	classVariableNames: ''	poolDictionaries: ''	category: 'Croquet-Window'!!TWindowButtons commentStamp: '<historical>' prior: 0!TWindowButtons is a frame that creates and positions the buttons at the top of the window.!TWindowButtons class	instanceVariableNames: ''!TPrimitive subclass: #TWindowFrame	instanceVariableNames: 'segments radius extent frontNorm frameOn hilite materialHilite doInside '	classVariableNames: ''	poolDictionaries: ''	category: 'Croquet-Window'!!TWindowFrame commentStamp: '<historical>' prior: 0!TWindowFrame is the outside control frame for the TWindow class. !TWindowFrame class	instanceVariableNames: ''!Morph subclass: #TWindowFrameMorph	instanceVariableNames: 'closeButton expandButton collapseButton doItButton label alphaSlider '	classVariableNames: 'CloseButtonForm ExpandButtonForm '	poolDictionaries: ''	category: 'Croquet-Morphs'!TWindowFrameMorph class	instanceVariableNames: ''!TPortal subclass: #TWirePortal	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'Croquet-Objects'!TWirePortal class	instanceVariableNames: ''!FormCanvas subclass: #TWorldCanvas	instanceVariableNames: 'monitor '	classVariableNames: ''	poolDictionaries: ''	category: 'Croquet-Objects'!TWorldCanvas class	instanceVariableNames: ''!TObject subclass: #TXLightPipe	instanceVariableNames: 'lightPipe xtest changesTo '	classVariableNames: ''	poolDictionaries: ''	category: 'Croquet-IOMonitors'!!TXLightPipe commentStamp: '<historical>' prior: 0!TXLightPipe object is the object class that manages a local XDisplay window.   It should be created in a tea party that is never replicated.TXLightPipe new monitorXDisplay: displayName window: window eventsTo: anObjectis used to open a lightpipe on a new display (nil for window means the root window).  It responds to anObject, the first message is XMonitor: which carries the name of the new TXLightPipe object, which can then be used to send handleEvent: and close messages to it.To use this, you have to get the fake X server called Xfake and the library liblightpipe.so from freedesktop.org.Also some library dependencies:Xfake                   libXfont, libXau and libXdmcp.liblightpipe.so         libXdamage, libXcomposite, libXfixesFor now these are available as source trees via anonymous cvs:liblightpipe:        cvs -d :pserver:anoncvs@freedesktop.org:/cvs/xapps			(co lightpipe)Xfake:        cvs -d :pserver:anoncvs@freedesktop.org:/cvs/xserverxlibs:        cvs -d :pserver:anoncvs@freedesktop.org:/cvs/xlibsInstructions for building from those repositories are available at        http://xserver.freedesktop.orgOnce you have built and installed the above, you may have to link to liblightpipe.so from your Squeak plugins directory.Then you can create a fake X server by the following command line:        Xfake :1 -screen 512x512x24 -ac -nolisten tcp &where :1 can be replaced by your choice of an x display to create.Any X apps that use this as their X display (for example by setting the DISPLAY environment variable to :1 when starting them) can then be monitored by creating a TXLightPipe object and then using the monitorXDisplay:window:eventsTo: method.Thanks to Keith Packard who created the X server and lightpipe libraries.- David P. Reed!TXLightPipe class	instanceVariableNames: ''!TExporter subclass: #TXMLExporter	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'Croquet-Export'!TXMLExporter class	instanceVariableNames: ''!TTextureForm subclass: #TXWindow	instanceVariableNames: 'theTXWindow hands activeHand lastActivePosition mouseDown '	classVariableNames: ''	poolDictionaries: ''	category: 'Croquet-TextureForms'!!TXWindow commentStamp: '<historical>' prior: 0!Texture that holds an X server window.It uses Keith Packard's lightpipe library to access and retrieve the contents of windows into the form of a texture.   It maps mouse and keyboard events by sending them as X fake events to the X server to be given to the application.!TXWindow class	instanceVariableNames: ''!Morph subclass: #TeaBackingMorph	instanceVariableNames: 'texture damageRecorder '	classVariableNames: ''	poolDictionaries: 'OpenGLConstants '	category: 'Croquet-Morphs'!!TeaBackingMorph commentStamp: '<historical>' prior: 0!The sole purpose of a TeaBackingMorph is to act as a backing store for rendering overlays.!TeaBackingMorph subclass: #TWindowMorph	instanceVariableNames: 'model frame content windowColor '	classVariableNames: ''	poolDictionaries: ''	category: 'Croquet-Morphs'!!TWindowMorph commentStamp: '<historical>' prior: 0!TWindowMorph new openInWorld.!TeaBackingMorph subclass: #TZoomNavigatorMorph	instanceVariableNames: 'scroller scrollValue targetHeight focus outer snapshots tools '	classVariableNames: 'AliceForm BackButtonForm ProjectsForm SnapshotForm ToolFormLibrary ToolsForm '	poolDictionaries: ''	category: 'Croquet-Morphs'!!TZoomNavigatorMorph commentStamp: '<historical>' prior: 0!TZoomNavigatorMorph new openInWorld!TeaBackingMorph class	instanceVariableNames: ''!TWindowMorph class	instanceVariableNames: ''!TZoomNavigatorMorph class	instanceVariableNames: ''!Object subclass: #TeaHost	instanceVariableNames: 'hostAddr hostPort hostUDPPort hostID listening listenSocket listeningUDP listenUDPSocket mapNameToObj tagCounter tagDict sendTCPAlways hostNameString messagesSent bytesSent bytesReceived messagesReceived selectorHistogram tunnelSocket listeningTunnels tunnelQueue tunnelProcess '	classVariableNames: 'HostName HostNameLast Listens LocalDirs LocalHostIDCounter SendTCPAlways TObjectCounter TObjectCounterBase TObjectCounterLast TeaHosts ThisHost TunnelOpener TunnelOpening '	poolDictionaries: ''	category: 'Croquet-Communications'!!TeaHost commentStamp: '<historical>' prior: 0!Class that represents "hosts" (decoupled Tea instances). Goal is to allow multiple hosts in the same Smalltalk instance, so multiple Tea applications can coexist)  To that end, hosts don't make themselves accessible by well-known sockets, but instead use unique socket instances created when they are started.!TeaHost class	instanceVariableNames: ''!Message subclass: #TeaMessage	instanceVariableNames: 'target teaHost teaTime hostName objectCounter doConstruct myScripts '	classVariableNames: ''	poolDictionaries: ''	category: 'Croquet-Communications'!TeaMessage class	instanceVariableNames: ''!Object subclass: #TeaName	instanceVariableNames: 'teaObjectName isClass '	classVariableNames: ''	poolDictionaries: ''	category: 'Croquet-Communications'!TeaName class	instanceVariableNames: ''!Object subclass: #TeaParty	instanceVariableNames: 'nickname myHost myParty myURL mutex keepAlive teaHostSet selectorHistogram partyURLName blistener noInternet teapot '	classVariableNames: 'ForceTunnel NoInternet TranscriptOn '	poolDictionaries: ''	category: 'Croquet-Communications'!!TeaParty commentStamp: '<historical>' prior: 0!TeaParty objects represent a coordinated collection of hosts that can grow or shrink dynamically.You can broadcast messages to all of the other hosts in the collection.TeaParty creation happens typically by rendezvous at a TeaParty server URL - the server returns a set of host addresses and nicknames for those hosts upon registering.TeaParty members periodically refresh each other with messages defining their presence for a particular duration of time.  If refresh does not happen, they are eventually viewed as having dropped out.!TeaParty class	instanceVariableNames: ''!Object subclass: #TeaTime	instanceVariableNames: 'time state initialHost '	classVariableNames: 'DefaultInitialHost DeltaTweak LastT ProxyHosts TeaBase Tweaks '	poolDictionaries: ''	category: 'Croquet-Misc'!!TeaTime commentStamp: '<historical>' prior: 0!Basic TeaTime object.TeaTime is an abstract timelike sequence that is coupled to real-time.   It is expressed in milliseconds (in floating point, so fractional milliseconds provides arbitrary precision).a TeaTime represents the temporal dimension in the overall process carried out by an application.  It corresponds to real time in the following sense:   whenever input or output events couple the application to the real world, the events are carried out logically at a real time that equals the underlying TeaTime.For example: when an object's state is displayed on the screen, it is told the real time at which the display frame will be shown to the user.   Then it proceeds to calculate the pixel values that need to be set, and places them into the display buffer.   At the appropriate real time, the display buffer will be posted to the hardware for display.Another example: when an input event arrives at the system, the real time at which the event occurs is used to set the TeaTime when the effects of that event are to become visible.  Typically, this is set to (say) 100 milliseconds in the future, to give the underlying system time to fully process the input.   The event message is then sent to one or more objects, with the TeaTime value used to indicate that the message is to be executed "as if" the algorithms processing the event are executed instantly at that future time, resulting in a new state.Since the system may be concurrently executing methods for different future TeaTimes, we need to coordinate all such activities.  TeaObject class objects manage the ordering of events based on the TeaTimes associated with messages.   See TeaObject.The TeaTime dimension also manages "potentiality" - which is key to handling failure.Our failure model is simple:  a failed activity is just one that takes too long to compute.  (this idea was invented in the '70's as a way to simplify network protocol design).   We define failure as the failure to explicitly "commit" by a deadline expressed in real-time - an action that we carry out at the end of the computations needed to construct a new "state of the world".  So failure is unified as a "timeout"So we handle failure by reflecting it in one other aspect of TeaTime: its "commit" state.  TeaTime objects are created in a state called "unknown", and eventually become either "committed" or "aborted".   The state transitions are one way, and mutually exclusive.   Once committed, a TeaTime can never become aborted or unknown again.   The only way to commit a TeaTime is by the "commit" message.   There are two ways to "abort" a TeaTime.  The primary way aborting happens is that the TeaTime is not committed before its deadline.   However it is also possible to abort a TeaTime explicitly, through its abort method.  Both the "commit" method and the "abort" method are idempotent.The "deadline" of a TeaTime object is the same as the real time used for displaying it, for obvious reasons.   !TeaTime class	instanceVariableNames: ''!Morph subclass: #TeapotMorph	instanceVariableNames: 'ogl txtr activeCamera avatarPath pdaClient loader statusString myImage widgetDictionary dock myColor messenger people messageList mutex '	classVariableNames: 'Current '	poolDictionaries: 'OpenGLConstants '	category: 'Croquet-Morphic'!!TeapotMorph commentStamp: '<historical>' prior: 0!Things to do:- Lighting strategy	- Dynamic lights (8 light limit?)	- Virtual lights? (not yet)	- Static lights		- Snapshot		- Vertex based radiosity	- Light maps.	- Environment lights (like light maps, but environment mapping based).Note that certain frames must have single parent, in particular, lights, portals, and cameras. The reason for this is that these objects can not be instanced - I can't have multiple versions of the same camera in a scene. Further, I need a single path to obtain the global transform. Of course, we could just use whatever the last appended/rendered frame transform, but I would like just a little bit more control than that...- Particle systems.- Multitexturing.- Environment mapping (not critical, just fun)- Display lists for performance.- 3D Text (glyph)- Shadows- Importers- !TeapotMorph subclass: #SampleTeapotMorph	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'Croquet-Morphic'!TeapotMorph subclass: #TeaTest	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: 'OpenGLConstants '	category: 'Croquet-Morphic'!TeapotMorph class	instanceVariableNames: ''!SampleTeapotMorph class	instanceVariableNames: ''!TeaTest class	instanceVariableNames: ''!TeapotMorph subclass: #TweakTeapotMorph	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: 'OpenGLConstants '	category: 'Croquet-Morphic'!TweakTeapotMorph class	instanceVariableNames: ''!ExternalStructure subclass: #XDevice	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'Croquet-XWindow'!!XDevice commentStamp: 'DPR 6/1/2004 01:05' prior: 0!Defines the XDevice structure from XInput.h!XDevice class	instanceVariableNames: ''!Form subclass: #XForm	instanceVariableNames: 'colorMap '	classVariableNames: ''	poolDictionaries: ''	category: 'Croquet-XWindow'!!XForm commentStamp: 'DPR 6/23/2004 00:23' prior: 0!A Form that holds a copy of bits copied from an XWindows window.   The key thing is the color map.!XForm class	instanceVariableNames: ''!ExternalStructure subclass: #XImage	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'Croquet-XWindow'!XImage class	instanceVariableNames: ''!ExternalStructure subclass: #XInputClassInfo	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'Croquet-XWindow'!XInputClassInfo class	instanceVariableNames: ''!Object subclass: #XLightPipe	instanceVariableNames: 'display window keyMap ctrlKeys colorMap bpp '	classVariableNames: ''	poolDictionaries: ''	category: 'Croquet-XWindow'!!XLightPipe commentStamp: 'DPR 5/1/2004 14:29' prior: 0!Class offers interface to Keith Packard's Lightpipe library.!XLightPipe class	instanceVariableNames: ''!ExternalStructure subclass: #XLightPipeWindow	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'Croquet-XWindow'!XLightPipeWindow class	instanceVariableNames: ''!ExternalStructure subclass: #XRectangle	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'Croquet-XWindow'!XRectangle class	instanceVariableNames: ''!Object subclass: #XTest	instanceVariableNames: 'display '	classVariableNames: ''	poolDictionaries: ''	category: 'Croquet-XWindow'!!XTest commentStamp: 'DPR 5/29/2004 15:00' prior: 0!Class that manages the XTest extension for an X server, so that we can send simulated I/O events to it.!XTest class	instanceVariableNames: ''!!Object methodsFor: '*Croquet' stamp: 'ar 6/6/2002 00:05'!exportReferenceOn: byteStream classMap: classMap	byteStream nextNumber: 4 put: 0.	byteStream nextNumber: 4 put: (classMap at: self class).	self teaExportLiteralOn: byteStream.! !!Object methodsFor: '*Croquet' stamp: 'das 1/8/2003 13:52'!isTeaObject	"Overridden to return true in TObject, natch"	^ false! !!Object methodsFor: '*Croquet' stamp: 'ar 10/4/2004 13:16'!meta"This method is used to fork a message to both the local and all remote recievers.  #meta and #metaSend completely replace asyncSend:"	self teaParty ifNil:[^self].	"are we are already in a remote replicated message send?"	Processor activeProcess hostName ~= TeaHost currentHostName ifTrue:[^self].	TMetaNotification signal ifFalse: [ "we are not currently nested in a meta message"		^TMeta new teaObject: self	] ifTrue:[^ self]. "already in a local replicated message send"! !!Object methodsFor: '*Croquet' stamp: 'ar 10/4/2004 13:15'!metaSend"This method is used to send a message to all remote recievers, but not to the local guy. #meta and #metaSend completely replace asyncSend:"	self teaParty ifNil:[^TMetaNil new.].	"are we are already in a remote replicated message send?"	Processor activeProcess hostName ~= TeaHost currentHostName ifTrue:[^TMetaNil new.].	TMetaNotification signal ifFalse: [ "we are not currently nested in a meta message"		^TMetaSend new teaObject: self.	] ifTrue:[^ TMetaNil new.]. "already in a local replicated message send"! !!Object methodsFor: '*Croquet' stamp: 'ar 6/6/2002 22:36'!objectForTeaExport    "Return an object to store on an external data stream."    ^ self clone! !!Object methodsFor: '*Croquet' stamp: 'ar 6/3/2002 21:33'!postImportFrom: importer! !!Object methodsFor: '*Croquet' stamp: 'ar 6/2/2002 14:35'!prepareToExportOn: exporter! !!Object methodsFor: '*Croquet' stamp: 'ar 6/6/2002 22:33'!teaExportOn: exporter	^exporter exportObject: self! !!Object methodsFor: '*Croquet' stamp: 'das 10/7/2002 13:41'!teaName	^ self.! !!Object methodsFor: '*Croquet' stamp: 'das 10/7/2002 14:43'!teaObject: teaParty	^ self.! !!Object methodsFor: '*Croquet' stamp: 'ar 10/2/2004 10:04'!teaParty	^CroquetGlobals teaParty! !!B3DHardwareEngine methodsFor: '*Croquet-override' stamp: 'ar 10/4/2004 22:48'!restoreMorphicForeground: aRectangle above: aMorph	"If necessary upload the contents of aRectangle from the rendering target into the engine."	| backingTexture x0 y0 x1 y1 y x backingBox box texRect morphList fixBlt |	morphList _ WriteStream on: #().	aMorph morphsInFrontOverlapping: aRectangle do:[:m| morphList nextPut: m].	morphList _ morphList contents.	morphList isEmpty ifTrue:[^self].	target ifNotNil:[		"As usual, it's a lot faster and easier if we have framebuffer access"		self finish. "need to finish 3D rendering"		target getCanvas translateBy: aRectangle origin negated during:[:canvas|			morphList reverseDo:[:m|				canvas transformBy: m transformFromWorld inverseTransformation						clippingTo: aRectangle						during:[:c| c fullDrawMorph: m]]].		^self].	"Compute the backing box; e.g., the area that needs compositing"	backingBox _ nil.	morphList reverseDo:[:m|		box _ m fullBoundsInWorld intersect: aRectangle.		box area > 0 ifTrue:[			backingBox == nil 				ifTrue:[backingBox _ box]				ifFalse:[backingBox _ backingBox quickMerge: box]]].	backingBox == nil ifTrue:[^self].	backingTexture _ self allocateOrRecycleTexture: backingForm.	"@@@: Hack. Silently back out if the backing texture is nil.	Has been noted by Alan and I *think* this is just a problem	for a frame or so.	If whoever reads this thinks it's a decidedly bad idea to just	back out, then go ahead and remove that test. But try to test	for a nil return value first - this should be more than a hint	that something went wrong here."	backingTexture ifNil:[^nil].	x0 _ backingBox left truncated.	y0 _ backingBox top truncated.	x1 _ backingBox right truncated.	y1 _ backingBox bottom truncated.	fixBlt := BitBlt toForm: backingForm.	fixBlt combinationRule: 40 "fixAlpha:with:".	fixBlt fillColor: (Bitmap with: 16rFF000000).	y _ y0.	[y < y1] whileTrue:[		x _ x0.		[x < x1] whileTrue:[			"Clean up texture - in many cases we might not have to draw anything"			backingForm hasBeenModified: false.			"The current drawing rectangle"			texRect _ x@y extent: backingForm extent.			"Draw the current patch"			backingForm getCanvas translateBy: (x@y) negated during:[:canvas|				morphList reverseDo:[:m|					canvas transformBy: m transformFromWorld inverseTransformation							clippingTo: texRect							during:[:c| c fullDrawMorph: m]]].			backingForm hasBeenModified ifTrue:[				"@@@ FIXME: Fix #displayOn: to use real color map if needed"				fixBlt copyBits.				self displayForm: backingForm on: backingTexture.				self uploadTexture: backingTexture.				self compositeTexture: backingTexture at: x@y translucent: true.			].			x _ x + backingTexture width.		].		y _ y + backingTexture height.	].! !!B3DIndexedMesh methodsFor: '*Croquet' stamp: 'ar 9/30/2004 19:33'!convertToOneBasedReferences	"Convert me to zero based references. Use with caution!!"	self hasZeroBasedReferences ifFalse:[^self].	vertices := vertices copyFrom: 2 to: vertices size.	vtxNormals ifNotNil:[vtxNormals _ vtxNormals copyFrom: 2 to: vtxNormals size].	vtxColors ifNotNil:[vtxColors _ vtxColors copyFrom: 2 to: vtxColors size].	vtxTexCoords ifNotNil:[vtxTexCoords _ vtxTexCoords copyFrom: 2 to: vtxTexCoords size].! !!B3DIndexedMesh methodsFor: '*Croquet' stamp: 'ar 9/9/2002 15:16'!convertToZeroBasedReferences	"Convert me to zero based references. Use with caution!!"	self hasZeroBasedReferences ifTrue:[^self].self error:'Please don''t'.	vertices _ (B3DVector3Array new: 1), vertices.	"insert infinity vector"	vertices basicAt: 1 put: 16r7F800000.	vertices basicAt: 2 put: 16r7F800000.	vertices basicAt: 3 put: 16r7F800000.	vtxNormals ifNotNil:[vtxNormals _ (B3DVector3Array new: 1), vtxNormals].	vtxColors ifNotNil:[vtxColors _ (B3DColor4Array new: 1), vtxColors].	vtxTexCoords ifNotNil:[vtxTexCoords _ (B3DTexture2Array new: 1), vtxTexCoords].! !!B3DIndexedMesh methodsFor: '*Croquet'!hasZeroBasedReferences	"if the first vertex is infinity, then assume so"	(vertices basicAt: 1) = 16r7F800000 ifFalse:[^false].	(vertices basicAt: 2) = 16r7F800000 ifFalse:[^false].	(vertices basicAt: 3) = 16r7F800000 ifFalse:[^false].	^true! !!B3DInterpolatedMesh methodsFor: '*Croquet' stamp: 'ar 9/9/2002 15:07'!convertToOneBasedReferences	meshes do:[:m| m convertToOneBasedReferences].! !!B3DInterpolatedMesh methodsFor: '*Croquet'!convertToZeroBasedReferences	meshes do:[:m| m convertToZeroBasedReferences].! !!BitBlt methodsFor: '*Croquet' stamp: 'ar 6/7/2002 23:55'!halftoneForm: aBitmap	halftoneForm _ aBitmap.! !!Boolean methodsFor: '*Croquet' stamp: 'ar 6/5/2002 21:47'!teaExportLiteralOn: byteStream! !!Boolean methodsFor: '*Croquet' stamp: 'ar 6/6/2002 22:33'!teaExportOn: exporter	^exporter exportLiteral: self! !!Canvas methodsFor: '*Croquet' stamp: 'ar 6/21/2002 21:44'!finish: rectList	^self finish! !!ChangeSet methodsFor: '*Croquet' stamp: 'ar 6/6/2002 22:33'!teaExportOn: exporter	^self error: 'Cannot export'! !!Character methodsFor: '*Croquet' stamp: 'ar 6/6/2002 22:33'!teaExportOn: exporter	^exporter exportLiteral: self! !!ClassDescription methodsFor: '*Croquet' stamp: 'ar 10/2/2004 10:06'!teaObjectName	^self name asSymbol! !!Bezier3Segment class methodsFor: '*Croquet' stamp: 'ar 10/4/2004 22:50'!initializeFrom: controlPoints	^ self new initializeFrom: controlPoints! !!ClassOrganizer methodsFor: '*Croquet-override' stamp: 'ar 10/5/2004 08:20'!printOn: aStream 	"Refer to the comment in Object|printOn:."	| elementIndex item |	elementIndex _ 1.	1 to: categoryArray size do: 		[:i | 		aStream nextPut: $(.		(categoryArray at: i) asString printOn: aStream.		[elementIndex <= (categoryStops at: i)]			whileTrue:				[item _ elementArray at: elementIndex.				aStream space; nextPutAll: (					(Scanner isLiteralSymbol: item) 						ifTrue:[item] 						ifFalse:[item storeString]).				elementIndex _ elementIndex + 1].		aStream nextPut: $); cr]! !!Collection methodsFor: '*Croquet'!product	"Return the product of all the elements in the receiver.	Note that '(1 to: n) product = n factorial' for all n > 0, e.g.		(1 to: 1) product = 1 factorial.		(1 to: 10) product = 10 factorial.		(1 to: 100) product = 100 factorial.	BUT NOT		(1 to: 0) product = 0 factorial.	"	| product |	self isEmpty ifTrue:[^0].	product _ self inject: 1 into: [:accum :each | accum * each].	^ product! !!ArrayedCollection methodsFor: '*Croquet' stamp: 'ar 6/5/2002 20:30'!byteSize	^self class isBytes		ifTrue:[self basicSize]		ifFalse:[self basicSize*4].! !!ArrayedCollection methodsFor: '*Croquet' stamp: 'ar 6/5/2002 22:21'!bytesPerElement	^self class isBytes ifTrue:[1] ifFalse:[4]! !!ArrayedCollection methodsFor: '*Croquet' stamp: 'ar 6/6/2002 22:35'!objectForTeaExport	"Don't copy collections by default"	^self! !!ArrayedCollection methodsFor: '*Croquet' stamp: 'ar 6/5/2002 23:16'!swapEndianness	(self class isBytes or:[self class isPointers])		ifFalse:[Smalltalk swapBytesIn: self from: 1 to: self basicSize]! !!ByteArray methodsFor: '*Croquet' stamp: 'ar 3/13/2002 00:36'!unzipped	| magic1 magic2 |	magic1 _ (self at: 1).	magic2 _ (self at: 2).	(magic1 = 16r1F and:[magic2 = 16r8B]) ifFalse:[^self].	^(GZipReadStream on: self) upToEnd! !!ByteArray methodsFor: '*Croquet' stamp: 'ar 3/13/2002 00:35'!zipped	| zz |	zz := GZipWriteStream on: (WriteStream on: (ByteArray new: 200)).	zz nextPutAll: self.	zz close.	^zz encodedStream contents! !!ContextPart methodsFor: '*Croquet' stamp: 'ar 6/6/2002 22:33'!teaExportOn: exporter	^self error: 'Cannot export'! !!CroquetData class methodsFor: 'as yet unclassified' stamp: 'DPR 2/15/2004 18:00'!download: aLocator whenFinishedSend: aSelector to: anObject	| myLoader |	myLoader := TResourceLoader new.	myLoader download: aLocator whenFinishedSend: aSelector to: anObject.	[myLoader isDone] whileFalse:[myLoader step]. "for now, don't run in background"! !!CroquetData class methodsFor: 'as yet unclassified' stamp: 'DPR 2/17/2004 12:23'!findContentFileName: fName	| path file |	path := FileDirectory default fullNameFor: fName.	(FileStream isAFileNamed: path) ifTrue:[^path].	file _ FileDirectory localNameFor: path.	path := FileDirectory pathFrom: {FileDirectory default pathName. 'Content'. file}.	(FileStream isAFileNamed: path) ifTrue:[^path].	CroquetData logError: 'Error: content file not found: ', fName.	^ nil.! !!CroquetData class methodsFor: 'as yet unclassified' stamp: 'das 7/5/2004 10:35'!findTextureFileName: fName	| path dir file pn paths files |	"the following attempts to handle case issues in the various texture file names on Linux for now."	" Generate a list in paths of ways that people have spelled file and directory names.	Pending reorganization of the Contents directory!!"	pn := FileDirectory default pathName.	paths := OrderedCollection new.	path _ FileDirectory default fullNameFor: fName.	dir _ FileDirectory dirPathFor: path.	file _ FileDirectory localNameFor: path.	"three forms of the file name: FooBar, foobar and Foobar"	files _ OrderedCollection new.	files add: file.	files add: (file := file asLowercase).	files add: file capitalized.	"look in file's directory first"	paths := files collect: [ :fn |			FileDirectory pathFrom: {dir . fn}].	"look in textures subdirectory second"	#('Textures' 'textures') do: [ :casedName |		paths := paths, (files collect: [ :fn |			FileDirectory pathFrom: {dir . casedName . fn}]).		].	"if fName has no prefix, look in default Textures directories"	(FileDirectory dirPathFor: fName) isEmpty ifTrue: [		#('Textures' 'textures') do: [ :casedName |			paths := paths, (files collect: [ :fn |				FileDirectory pathFrom: {pn. casedName. fn}])].		#('Content' 'content') do: [ :casedDir |			#('Textures' 'textures') do: [ :casedName |				paths := paths, (files collect: [ :fn |					FileDirectory pathFrom: {pn. casedDir. casedName. fn}])]].		].	"Now search all the paths we constructed"	paths do: [ :filePath | (FileStream isAFileNamed: filePath) ifTrue:[^filePath] ].	^ nil."	CroquetData logError: 'Substituting default texture for missing texture file: : ', fName.	^FileDirectory pathFrom: {pn. 'Content'. 'Textures'. 'default.bmp'}."! !!CroquetData class methodsFor: 'as yet unclassified' stamp: 'ar 9/30/2004 14:33'!load3dsFile: aString	| frame mesh localName meshSphere newScale |	localName _ 'http://localhost/CRL', ((FileDirectory on: aString) localName copyUpTo: $.), '.tea'.	mesh _ CroquetData loadURL: localName.	mesh ifNil: [		mesh _ (TLoad3DSMax new initializeWithFileName: aString) frame.		mesh translationX: 0 y:0 z:0.		mesh collapse.		mesh boundsDepth: 2.		mesh initBounds.		meshSphere _ mesh calcBoundSphere.		meshSphere ifNotNil: [newScale _ 2.0 / meshSphere radius] ifNil: [1.0].		mesh scale: newScale.		TExporter export: mesh asBinary: localName.	].		frame _ TSpinner new.	frame matOver: nil.	frame matNorm: nil.	frame matDown: nil.	frame localTransform: mesh localTransform.	frame contentsNoMat: mesh.	^frame.! !!CroquetData class methodsFor: 'as yet unclassified' stamp: 'DPR 2/16/2004 12:45'!loadAliceFile: filePath	| frame teaUrl |	teaUrl := 'http://www.reed.com/TeaLand'.	2 to: filePath size do:[:i| teaUrl := teaUrl,'/', (filePath at: i)].	teaUrl := (teaUrl allButLast: 4), '.tea'.	frame := CroquetData loadURL: teaUrl reuseExisting: false.	frame ifNil:[frame := self loadAliceModel: filePath url: teaUrl].	^ frame.! !!CroquetData class methodsFor: 'as yet unclassified' stamp: 'DPR 2/16/2004 12:46'!loadAliceModel: filePath url: teaUrl	| mdl frame thumb fName |	Utilities informUserDuring:[:bar|		bar value: 'Importing ', filePath last,'...'.		fName := FileDirectory pathFrom: {FileDirectory default pathName}, filePath.		mdl := TLoadMDL new.		frame := mdl parseFileNamed: fName.		thumb := Form extent: 128@128 depth: 8.		(frame makeThumbnail: 128@128) displayOn: thumb at: 0@32 rule: Form paint.		TExporter export: frame asBinary: teaUrl withThumbnail: thumb.	].	^frame! !!CroquetData class methodsFor: 'as yet unclassified' stamp: 'das 2/20/2004 10:24'!loadAliceModels: sp	| fd mdl frame url thumb urlName imageUrl |	Utilities informUserDuring:[:bar|		bar value: 'Loading Alice library...'.		mdl := TLoadMDL new.		#('Furnishings') do:[:dir|		"#('Animals' 'Scenery' 'Vehicles') do:[:dir|"		"#('Alphabet' 'Animals' 'Furnishing' 'Logos' 'Misc' 'Scenery' 'Shapes' 'Vehicles') do:[:dir|"			fd := FileDirectory pathFrom: {FileDirectory default pathName. 'Content'. 'Alice'. dir}.			fd := FileDirectory on: fd.			url := 'http://www.reed.com/TeaLand/Alice/',dir,'/'.			(fd fileNamesMatching: '*.mdl') do:[:fName|				urlName := url, (fName copyFrom: 1 to: fName size-3), 'tea'.				imageUrl := url, (fName copyFrom: 1 to: fName size-3), 'gif'.				thumb := self loadImageUrl: imageUrl.				thumb ifNil:[					bar value: 'Initializing Alice library... (', fName,')'.					frame := mdl parseFileNamed: (fd fullNameFor: fName).					thumb := Form extent: 128@128 depth: 8.					(frame makeThumbnail: 128@128) displayOn: thumb at: 0@32 rule: Form paint.					TExporter export: frame asBinary: urlName withThumbnail: thumb.				] ifNotNil:[					bar value: 'Loading Alice library... (', fName,')'.				].			].		].	].! !!CroquetData class methodsFor: 'as yet unclassified' stamp: 'das 7/4/2004 22:40'!loadAmbientSound: soundName	| myFile mySound fd |	fd _ (FileDirectory default directoryNamed:'sounds').	(fd fileExists: soundName) ifFalse:[^nil].	myFile _ MPEGFile openFile: (fd fullNameFor: soundName).	mySound _ myFile audioPlayerForChannel: 1.	mySound repeat: true.	mySound volume: 1.0.	^mySound! !!CroquetData class methodsFor: 'as yet unclassified' stamp: 'DPR 7/22/2004 02:46'!loadFormAtPath: formPath	| formFile form fullPath |		formFile := [				fullPath := FileDirectory pathFrom: ({ FileDirectory default pathName }, formPath).				FileDirectory root readOnlyFileNamed: fullPath]		on: Error do:[:ex| self logError: ex. ex return: nil].	formFile ifNil:[^nil].	form := Form fromBinaryStream: formFile.	form mapColor: Color white to: Color transparent.	formFile close.	^form! !!CroquetData class methodsFor: 'as yet unclassified' stamp: 'DPR 2/15/2004 16:54'!loadIcon2: iconName	^self loadIcon: iconName defaultExtent: 128@128! !!CroquetData class methodsFor: 'as yet unclassified' stamp: 'DPR 2/16/2004 12:38'!loadIcon: iconName	| iconFile icon |	iconFile := [(FileDirectory default directoryNamed: 'icons') readOnlyFileNamed: iconName]		on: Error do:[:ex| self logError: ex. ex return: nil].	iconFile ifNil:[^Form extent: 11@11 depth: 8].	icon := Form fromBinaryStream: iconFile.	icon mapColor: Color white to: Color transparent.	iconFile close.	^icon! !!CroquetData class methodsFor: 'as yet unclassified' stamp: 'DPR 2/16/2004 12:38'!loadIcon: iconName defaultExtent: defaultExtent	| iconFile icon |	iconFile := [(FileDirectory default directoryNamed: 'icons') readOnlyFileNamed: iconName]		on: Error do:[:ex| self logError: ex. ex return: nil].	iconFile ifNil:[^Form extent: defaultExtent depth: 8].	icon := Form fromBinaryStream: iconFile.	iconFile close.	^icon! !!CroquetData class methodsFor: 'as yet unclassified' stamp: 'DPR 2/17/2004 12:12'!loadImageUrl: url	| loc myLoader result |	loc := ResourceLocator new urlString: url.	loc ifNil:[^ nil].	loc resourceFileSize: 0.	myLoader := TResourceLoader new.	myLoader download: loc whenFinishedSend:#value: to:[:ll| 		result := [Form fromFileNamed: loc localFileName] on: Error do:[:ex| ex return: nil].	].	[myLoader isDone] whileFalse:[myLoader step].	^result! !!CroquetData class methodsFor: 'as yet unclassified' stamp: 'DPR 2/15/2004 18:03'!loadLocator: aLocator	^self loadLocator: aLocator reuseExisting: true! !!CroquetData class methodsFor: 'as yet unclassified' stamp: 'ar 9/30/2004 16:31'!loadLocator: aLocator reuseExisting: aBool	| fs importer result resList loader |	aLocator localFileName ifNil:[Transcript cr; show: 'loadLocator localFileName is nil. '; show: aLocator urlString.  ^ nil.].	aBool ifTrue:[result := (CroquetGlobals objectNamed: aLocator urlString)].	result ifNil:[		fs := FileStream readOnlyFileNamed: aLocator localFileName.		[importer := TImporter new.		result := [importer importStream: fs] 			on: Error 			do:[:ex|				self logError: ex.				ex return: nil.			].		] ensure:[fs close].		result ifNil:[^result].		resList := importer resources.		resList size > 0 ifTrue:[ 			loader _ TResourceLoader new.			loader addAll: resList.			[loader isDone] whileFalse: [loader step].			].	].	^result! !!CroquetData class methodsFor: 'as yet unclassified' stamp: 'DPR 2/16/2004 11:52'!loadURL: urlString	^self loadURL: urlString reuseExisting: true! !!CroquetData class methodsFor: 'as yet unclassified' stamp: 'DPR 8/26/2004 21:44'!loadURL: urlString reuseExisting: aBool	| loc myLoader result |	loc := ResourceLocator new urlString: urlString.	loc ifNil:[^ nil].	loc resourceFileSize: 0.	myLoader := TResourceLoader new.	myLoader download: loc whenFinishedSend:#value: to:[:ll| 		result := self loadLocator: ll reuseExisting: aBool  "currently, flag has no effect"	].	[myLoader isDone] whileFalse:[myLoader step].	^result! !!CroquetData class methodsFor: 'as yet unclassified' stamp: 'DPR 2/17/2004 10:35'!logError: ex	"code to log the error ex"	Transcript cr; show: ex asString.! !!CroquetGlobals class methodsFor: 'as yet unclassified' stamp: 'ar 10/2/2004 16:11'!acrossWorldsStuff	^TheTeapotMorph acrossWorldsStuff! !!CroquetGlobals class methodsFor: 'as yet unclassified' stamp: 'ar 10/1/2004 09:51'!frameScale	^FrameScale ifNil:[1.0]! !!CroquetGlobals class methodsFor: 'as yet unclassified' stamp: 'ar 10/1/2004 09:51'!frameScale: amt	FrameScale := amt.! !!CroquetGlobals class methodsFor: 'as yet unclassified' stamp: 'ar 10/1/2004 09:51'!frameScaleInverse	^1.0 / self frameScale! !!CroquetGlobals class methodsFor: 'as yet unclassified' stamp: 'ar 10/1/2004 09:52'!frameScaleSquared	^self frameScale squared! !!CroquetGlobals class methodsFor: 'as yet unclassified' stamp: 'das 10/3/2004 09:22'!messageList	^TheTeapotMorph messageList! !!CroquetGlobals class methodsFor: 'as yet unclassified' stamp: 'ar 9/30/2004 16:32'!objectNamed: aName	^nil! !!CroquetGlobals class methodsFor: 'as yet unclassified' stamp: 'ar 10/2/2004 07:50'!registerTeaObject: obj	^TheTeapotMorph registerTeaObject: obj.! !!CroquetGlobals class methodsFor: 'as yet unclassified' stamp: 'ar 10/1/2004 14:36'!snapshots	^Snapshots! !!CroquetGlobals class methodsFor: 'as yet unclassified' stamp: 'ar 10/1/2004 14:37'!snapshots: oc	Snapshots := oc.! !!CroquetGlobals class methodsFor: 'as yet unclassified' stamp: 'ar 10/2/2004 08:27'!teaParty	^TheTeapotMorph teaParty! !!CroquetGlobals class methodsFor: 'as yet unclassified' stamp: 'ar 9/30/2004 16:29'!textureAt: file ifAbsentPut: aBlock	^aBlock value! !!CroquetGlobals class methodsFor: 'as yet unclassified' stamp: 'ar 10/2/2004 07:50'!theTeapotMorph	^TheTeapotMorph! !!CroquetGlobals class methodsFor: 'as yet unclassified' stamp: 'ar 10/2/2004 07:50'!theTeapotMorph: aMorph	TheTeapotMorph := aMorph! !!CroquetTools class methodsFor: 'changes' stamp: 'ar 2/5/2004 15:42'!fileOutAllChangesTo: baseDir	"Take all changes in the system and put them into the given directory"	"CroquetTools fileOutAllChangesTo: (FileDirectory default directoryNamed: 'unfiltered')"	| newClasses changedClasses commentClasses methodChanges changeTypes dir file selectors |	"Grab all the changes"	newClasses := IdentitySet new.	changedClasses := IdentitySet new.	commentClasses := IdentitySet new.	methodChanges := IdentityDictionary new.	Cursor wait showWhile:[	ChangeSet allInstancesDo:[:cs|		"Note: #changedClasses will only report classes which are still present so if a class got removed, it won't be listed."		cs changedClasses do:[:aClass|			"Check what changes we've done to the class"			changeTypes := cs classChangeAt: aClass name.			((changeTypes includes: #add) or:[changeTypes includes: #rename]) ifTrue:[				newClasses add: aClass theNonMetaClass.			] ifFalse:[				"only keep relevant information"				(changeTypes includes: #change) ifTrue:[changedClasses add: aClass].				(changeTypes includes: #comment) ifTrue:[commentClasses add: aClass].			].			"Check what methods we've changed"			changeTypes := cs methodChangesAtClass: aClass name.			changeTypes isEmpty ifFalse:[				(methodChanges at: aClass ifAbsentPut:[IdentitySet new]) addAll: changeTypes keys.			].		].	].	"Remove all of the newClasses from changedClasses, commentClasses, and methodChanges"	newClasses do:[:aClass| 		changedClasses remove: aClass ifAbsent:[].		changedClasses remove: aClass class ifAbsent:[].		commentClasses remove: aClass ifAbsent:[].		commentClasses remove: aClass class ifAbsent:[].		methodChanges removeKey: aClass ifAbsent:[].		methodChanges removeKey: aClass class ifAbsent:[].	].	].	Cursor write showWhile:[	"Now start writing out the changes"	baseDir assureExistence.	"First, the entirely new classes"	newClasses do:[:aClass|		dir := baseDir directoryNamed: aClass category.		dir assureExistence.		file := dir newFileNamed: aClass name,'.st'.		[aClass fileOutOn: file] ensure:[file close].	].	"Second, classes with shape changes"	(IdentitySet withAll: changedClasses asArray, commentClasses asArray, methodChanges keys asArray) do:[:aClass|		dir := baseDir directoryNamed: aClass theNonMetaClass category.		dir assureExistence.		file := dir newFileNamed: aClass name,'.st'.		[(changedClasses includes: aClass) 			ifTrue:[file nextChunkPut: aClass definition].		(commentClasses includes: aClass) 			ifTrue:[aClass organization putCommentOnFile: file numbered: 0 						moveSource: false forClass: aClass].		(methodChanges includesKey: aClass) ifTrue:[			selectors := methodChanges at: aClass.			aClass fileOutChangedMessages: selectors				on: file moveSource: false toFile: 0. 			(selectors reject:[:sel| aClass includesSelector: sel]) do:[:selector|				file cr; nextChunkPut: aClass name, ' removeSelector: #', selector,'.'.			].		].		] ensure:[file close].	].	].! !!CroquetTools class methodsFor: 'changes' stamp: 'ar 2/5/2004 15:26'!filterAllChangesFrom: dir1 to: dir2	"Take all changes from dir1 diff them against the current system and write the result into dir2"	"CroquetTools 		filterAllChangesFrom: (FileDirectory default directoryNamed: 'unfiltered')		to: (FileDirectory default directoryNamed: 'filtered')"	| fp srcDir dstDir file |	dir2 assureExistence.	dir1 directoryNames do:[:dirName|		srcDir := dir1 directoryNamed: dirName.		dstDir := dir2 directoryNamed: dirName.		(srcDir fileNamesMatching: '*.st') do:[:fName|			fp _ FilePackage fromFileNamed: (srcDir fullNameFor: fName).			fp classes copy do:[:theClass|				Cursor wait showWhile:[					theClass removeAllUnmodified.				].				theClass hasChanges ifFalse:[					fp removeClass: theClass.				].			].			fp classes isEmpty ifFalse:[				dstDir assureExistence.				fp removeDoIts.				file := dstDir newFileNamed: fName.				[fp fileOutOn: file] ensure:[file close].			].		].	].! !!CroquetTools class methodsFor: 'changes' stamp: 'ar 2/5/2004 16:18'!mergeAllChangesFrom: baseDir to: fileName	"Take all changes from baseDir write a single CS into fileName"	"CroquetTools 		mergeAllChangesFrom: (FileDirectory default directoryNamed: 'filtered')		to: 'merged.cs'"	| srcDir file merged |	merged _ FilePackage new.	baseDir directoryNames do:[:dirName|		srcDir := baseDir directoryNamed: dirName.		(srcDir fileNamesMatching: '*.st') do:[:fName|			file := srcDir readOnlyFileNamed: fName.			[merged fullName: file fullName.			merged fileInFrom: file] ensure:[file close].		].	].	merged removeDoIts.	merged fixClassOrder.	Cursor write showWhile:[		file := baseDir newFileNamed: fileName.		[merged fileOutOn: file] ensure:[file close].	].! !!ExternalLibraryFunction methodsFor: '*Croquet' stamp: 'ar 10/4/2004 23:14'!setModule: aString	"Private. Hack the module"	module := aString.! !!False class methodsFor: '*Croquet' stamp: 'ar 6/5/2002 21:42'!teaImportLiteralFrom: byteStream	^false! !!FileDirectory methodsFor: '*Croquet' stamp: 'bf 10/22/2002 17:05'!fileExists: filenameOrPath	"Answer true if a file of the given name exists. The given name may be either a full path name or a local file within this directory."	"FileDirectory default fileExists: Smalltalk sourcesName"	| fName dir |	FileDirectory splitName: filenameOrPath to:		[:filePath :name |			fName _ name.			filePath isEmpty				ifTrue: [dir _ self]				ifFalse: [dir _ FileDirectory on: filePath]].	(self isCaseSensitive and: [Preferences caseInsensitiveFileNames not])		ifTrue:[^dir fileNames includes: fName]		ifFalse:[^dir fileNames anySatisfy: [:name| name sameAs: fName]].	! !!FileDirectory methodsFor: '*Croquet' stamp: 'bf 10/22/2002 17:21'!primDeleteFileNamed: aFileName	"Delete the file of the given name. Return self if the primitive succeeds, nil otherwise."	<primitive: 'primitiveFileDelete' module: 'FilePlugin'>	FileDirectory withCaseInsensitiveMatchFor: aFileName		retry: [:match | ^ self primDeleteFileNamed: match].	^ nil! !!FileDirectory class methodsFor: '*Croquet' stamp: 'ar 6/7/2002 14:26'!fileSizeOf: fileName	| fs sz |	fs := FileStream readOnlyFileNamed: fileName.	sz := fs size.	fs close.	^sz! !!FileDirectory class methodsFor: '*Croquet' stamp: 'bf 3/11/2004 17:46'!pathFrom: aCollection	"Take the given collection and make it into a full path"	"		FileDirectory pathFrom: #('foo' 'bar' 'baz').		FileDirectory pathFrom: {FileDirectory default pathName. 'mumble'. 'frobler'}.	"	| skipSeparator |	^String streamContents:[:s|		"Macs are special"		(self pathNameDelimiter = $:			and: [(aCollection first beginsWith: FileDirectory default pathName) not]) ifTrue: [				s nextPutAll: FileDirectory default pathName.				s nextPut: self pathNameDelimiter].		aCollection do:[:pathPart|			s nextPutAll: pathPart.			skipSeparator := pathPart size = 0 or:[pathPart last = self pathNameDelimiter].		] separatedBy:[			skipSeparator ifFalse:[s nextPut: self pathNameDelimiter].		].	].! !!FileDirectory class methodsFor: '*Croquet' stamp: 'bf 10/22/2002 00:38'!withCaseInsensitiveMatchFor: fileName retry: aBlock	"Look for a case insensitive match for fileName. If found, evaluate aBlock with it, otherwise return nil."	| dir localName |	(Preferences caseInsensitiveFileNames and: [FileDirectory default isCaseSensitive])		ifFalse: [^ nil].	dir _ FileDirectory forFileName: fileName.	localName _ FileDirectory localNameFor: fileName.	dir fileNames do: [:actualName |		((localName sameAs: actualName)	"case-insensitive match"			and: [actualName ~= localName])				ifTrue: [^ aBlock value: dir pathName, dir slash, actualName]].	^ nil ! !!Float methodsFor: '*Croquet' stamp: 'das 7/14/2002 11:20'!arcSin	"Answer the angle in radians. Modified to clamp low-res floats -  DAS."	self <= -1.0 ifTrue:[^Halfpi negated].	self >= 1.0 ifTrue:[^Halfpi].	^ (self / (1.0 - (self * self)) sqrt) arcTan.! !!Float methodsFor: '*Croquet' stamp: 'ar 10/10/2002 15:29'!arcTan: denominator	"Answer the angle of (self / denominator) arcTan in radians."	(self = 0.0) ifTrue: [		(denominator > 0.0) ifTrue:[^0].		^Pi].	(denominator = 0.0) ifTrue: [		(self > 0.0) ifTrue: [^Halfpi].		^Halfpi negated].	(denominator > 0) 		ifTrue: [^(self / denominator) arcTan].	^((self / denominator) arcTan) + Pi! !!Float methodsFor: '*Croquet' stamp: 'ar 6/5/2002 23:22'!teaExportLiteralOn: byteStream	| lit |	lit := ByteArray new: 8.	lit unsignedLongAt: 1 put: (self basicAt: 1) bigEndian: true.	lit unsignedLongAt: 5 put: (self basicAt: 2) bigEndian: true.	byteStream nextPutAll: lit.! !!Float methodsFor: '*Croquet' stamp: 'ar 6/6/2002 22:33'!teaExportOn: exporter	^exporter exportLiteral: self! !!FloatArray methodsFor: '*Croquet' stamp: 'ar 6/23/2002 16:23'!*= anObject	<primitive: 'primitiveMulScalar' module: 'FloatArrayPlugin'>	^anObject isNumber		ifTrue:[self primMulScalar: anObject asFloat]		ifFalse:[self primMulArray: anObject]! !!FloatArray methodsFor: '*Croquet' stamp: 'ar 6/23/2002 16:22'!+= anObject	<primitive: 'primitiveAddFloatArray' module: 'FloatArrayPlugin'>	^anObject isNumber		ifTrue:[self primAddScalar: anObject asFloat]		ifFalse:[self primAddArray: anObject]! !!FloatArray methodsFor: '*Croquet' stamp: 'ar 6/23/2002 16:22'!-= anObject	<primitive: 'primitiveSubFloatArray' module: 'FloatArrayPlugin'>	^anObject isNumber		ifTrue:[self primSubScalar: anObject asFloat]		ifFalse:[self primSubArray: anObject]! !!FloatArray methodsFor: '*Croquet' stamp: 'ar 6/23/2002 16:23'!/= anObject	<primitive: 'primitiveDivScalar' module: 'FloatArrayPlugin'>	^anObject isNumber		ifTrue:[self primDivScalar: anObject asFloat]		ifFalse:[self primDivArray: anObject]! !!FloatArray methodsFor: '*Croquet' stamp: 'ar 10/4/2004 22:53'!alpha	^self size>3 ifTrue:[self at: 4] ifFalse:[1.0].! !!FloatArray methodsFor: '*Croquet' stamp: 'ar 10/4/2004 22:53'!blue	^self at: 3! !!FloatArray methodsFor: '*Croquet'!bytesPerElement	^4! !!FloatArray methodsFor: '*Croquet' stamp: 'ar 10/4/2004 22:54'!dist: p	^(self - p)length.! !!FloatArray methodsFor: '*Croquet' stamp: 'ar 6/16/2002 21:52'!dot: aFloatVector	"Primitive. Return the dot product of the receiver and the argument.	Fail if the argument is not of the same size as the receiver."	| result |	<primitive:'primitiveDotProduct' module: 'FloatArrayPlugin'>	self size = aFloatVector size ifFalse:[^self error:'Must be equal size'].	result _ 0.0.	1 to: self size do:[:i|		result _ result + ((self at: i) * (aFloatVector at: i)).	].	^result! !!FloatArray methodsFor: '*Croquet' stamp: 'ar 10/4/2004 22:54'!dotProduct: aFloatVector	"Primitive. Return the dot product of the receiver and the argument.	Fail if the argument is not of the same size as the receiver."	| result |	<primitive:'primitiveDotProduct' module: 'FloatArrayPlugin'>	self size = aFloatVector size ifFalse:[^self error:'Must be equal size'].	result _ 0.0.	1 to: self size do:[:i|		result _ result + ((self at: i) * (aFloatVector at: i)).	].	^result! !!FloatArray methodsFor: '*Croquet'!floatAt: index	<primitive: 'primitiveAt' module: 'FloatArrayPlugin'>	^Float fromIEEE32Bit: (self basicAt: index)! !!FloatArray methodsFor: '*Croquet'!floatAt: index put: value	<primitive: 'primitiveAtPut' module: 'FloatArrayPlugin'>	value isFloat 		ifTrue:[self basicAt: index put: value asIEEE32BitWord]		ifFalse:[self at: index put: value asFloat].	^value! !!FloatArray methodsFor: '*Croquet' stamp: 'ar 10/4/2004 22:54'!green	^self at: 2! !!FloatArray methodsFor: '*Croquet' stamp: 'ar 10/4/2004 22:54'!inverseSqrt	1 to: self size do:[:i| self at:i put: 1.0/((self at: i)sqrt).].! !!FloatArray methodsFor: '*Croquet' stamp: 'ar 10/4/2004 22:54'!max	| mx |	mx _ self at: 1.	2 to: self size do:[ :index | (self at: index) > mx ifTrue:[mx _ self at: index]].	^ mx.! !!FloatArray methodsFor: '*Croquet' stamp: 'ar 10/4/2004 22:54'!min	| mn |	mn _ self at: 1.	2 to: self size do:[ :index | (self at: index) < mn ifTrue:[mn _ self at: index]].	^ mn.! !!FloatArray methodsFor: '*Croquet' stamp: 'ar 10/4/2004 22:55'!negate	self*= -1! !!FloatArray methodsFor: '*Croquet' stamp: 'ar 10/4/2004 22:53'!r	"Return the length of the receiver"	^self squaredLength sqrt! !!FloatArray methodsFor: '*Croquet' stamp: 'ar 10/4/2004 22:54'!red	^self at: 1! !!FloatArray methodsFor: '*Croquet' stamp: 'ar 10/4/2004 22:55'!sqrt	1 to: self size do:[:i| self at:i put: (self at: i)sqrt.].! !!FloatArray methodsFor: '*Croquet' stamp: 'ar 10/4/2004 22:55'!sqrted	^self clone sqrt.! !!B3DMatrix4x4 methodsFor: '*Croquet' stamp: 'das 9/17/2003 13:09'!localBoxToGlobal: aTBox	^TBox min: (self localPointToGlobal: aTBox min) max: (self localPointToGlobal: aTBox max).! !!B3DMatrix4x4 methodsFor: '*Croquet' stamp: 'ar 10/1/2004 09:53'!orientation"This is used to return just the orientation part of the matrix.The translation part is 0.0."	| mat |	mat _ self clone.	mat translationX: 0.0 y: 0.0 z: 0.0.	^ mat.! !!B3DVector3Array methodsFor: '*Croquet-math functions' stamp: 'das 9/8/2003 11:02'!addVector: vec	1 to: self size do:[:i | self at: i put: (self at: i)+vec.].! !!B3DVector3Array methodsFor: '*Croquet-math functions' stamp: 'das 9/7/2003 15:25'!divideByArray: array	1 to: self size do:[:i | self at: i put: (self at: i)/(array at: i).].! !!B3DVector3Array methodsFor: '*Croquet-math functions' stamp: 'das 9/7/2003 15:22'!lengthInto: target	1 to: self size do:[:i | target at: i put: (self at: i) length.].! !!B3DVector3Array methodsFor: '*Croquet-math functions' stamp: 'das 9/7/2003 15:26'!normalize	1 to: self size do:[:i | self at: i put: (self at: i) / (self at: i)length.].! !!B3DVector3Array methodsFor: '*Croquet-math functions' stamp: 'das 9/7/2003 15:25'!scaleByArray: array	1 to: self size do:[:i | self at: i put: (self at: i)*(array at: i).].! !!B3DVector3Array methodsFor: '*Croquet-math functions' stamp: 'das 9/7/2003 15:24'!squaredLengthInto: target	1 to: self size do:[:i | target at: i put: (self at: i) squaredLength.].! !!B3DVector3Array methodsFor: '*Croquet-math functions' stamp: 'das 9/8/2003 11:02'!subtractVector: vec	1 to: self size do:[:i | self at: i put: (self at: i)-vec.].! !!Form methodsFor: '*Croquet' stamp: 'ar 6/23/2002 20:17'!asCursorWithMask	"Convert the receiver into a CursorWithMask"	| cursor maskForm bb |	maskForm := Form extent: 16@16 depth: 1.	bb := BitBlt toForm: maskForm.	bb sourceForm: self; combinationRule: 3.	bb colorMap: (Color maskingMap: self depth).	bb copyBits.	cursor := CursorWithMask extent: 16@16 depth: 1.	self displayOn: cursor.	cursor offset: 0@0.	cursor setMaskForm: maskForm.	^cursor! !!Form methodsFor: '*Croquet' stamp: 'ar 6/17/2003 00:18'!colorCount	"Answer the number of colors used"	| count |	count := 0.	self tallyPixelValues do:[:each|		each > 0 ifTrue:[count := count + 1]].	^count! !!Form methodsFor: '*Croquet' stamp: 'ar 6/26/2002 14:21'!colorKeyAlpha	"Form fromUser colorKeyAlpha displayOn: Display at: 0@0 rule: Form paint"	"Use the first color in the form as a bit mask."	| pv |	[(BitBlt toForm: self)		fillColor: (self colorAt: 0@0);		combinationRule: 39;		copyBits] on: Error do:[:ex|		pv := bits at: 1.		1 to: bits size do:[:i|			(bits at: i) = pv ifTrue:[bits at: i put: 0]].		ex return].! !!Form methodsFor: '*Croquet' stamp: 'ar 8/20/2002 13:44'!colorKeyZero	| pv |	[(BitBlt toForm: self)		fillColor: Color transparent;		combinationRule: 39;		copyBits] on: Error do:[:ex|		pv := 0.		1 to: bits size do:[:i|			(bits at: i) = pv ifTrue:[bits at: i put: 0]].		ex return].! !!Form methodsFor: '*Croquet' stamp: 'ar 8/26/2002 20:12'!displayScaledOn: aForm in: aRectangle	"Display the receiver on aForm, scaling if necessary.		Form fromUser displayScaledOn: Display.	"	self extent = aForm extent ifTrue:[^self displayOn: aForm].	(WarpBlt current toForm: aForm)		sourceForm: self destRect: aRectangle;		combinationRule: Form paint;		cellSize: 2;		warpBits.! !!Form methodsFor: '*Croquet' stamp: 'ar 6/21/2002 19:22'!flipVertically	"Flip the image along the y axis"	| rowLen row topIndex botIndex |	self unhibernate.	rowLen := bits size // height.	row := Bitmap new: rowLen.	topIndex := 1.	botIndex := bits size - rowLen + 1.	1 to: height // 2 do: [:i |		self assert:[topIndex+rowLen <= botIndex].		row replaceFrom: 1 to: rowLen with: bits startingAt: topIndex.		bits replaceFrom: topIndex to: topIndex+rowLen-1 with: bits startingAt: botIndex.		bits replaceFrom: botIndex to: botIndex+rowLen-1 with: row startingAt: 1.		topIndex := topIndex + rowLen.		botIndex := botIndex - rowLen.	].! !!Form methodsFor: '*Croquet' stamp: 'ar 10/14/2002 16:50'!safePixelAt: aPoint using: bitPeeker	"Answer the color of the receiver at aPoint but test for being inside first and answer Color transparent if not"	(aPoint x < 0 or:[aPoint y < 0]) ifTrue:[^0].	(aPoint x >= width or:[aPoint y >= height]) ifTrue:[^0].	^bitPeeker pixelAt: aPoint! !!Form methodsFor: '*Croquet' stamp: 'ar 10/14/2002 20:39'!smearFill: nPix	"Fill transparent pixels in the receiver at most nPix."	| newForm |	newForm := Form extent: self extent depth: depth.	1 to: nPix do:[:i|		self displayOn: newForm at: 0@1 rule: Form paint.		self displayOn: newForm at: 0@-1 rule: Form paint.		self displayOn: newForm at: 1@0 rule: Form paint.		self displayOn: newForm at: -1@0 rule: Form paint.		self displayOn: newForm at: 0@0 rule: Form paint.		newForm displayOn: self].	^self! !!Form methodsFor: '*Croquet' stamp: 'ar 10/14/2002 16:45'!traceOutline: refColor	^Array streamContents:[:s| self traceOutline: refColor do:[:pt| s nextPut: pt]].! !!Form methodsFor: '*Croquet' stamp: 'ar 10/14/2002 16:44'!traceOutline: refColor do: aBlock	"Trace the outline edges in the receiver and evaluate aBlock with all the pixels"	| rect x y pixelOffsets startPos lastPos pixDir nextPos refValue peeker |	peeker := BitBlt bitPeekerFromForm: self.	refValue := self pixelValueFor: refColor.	pixelOffsets := {1@0. 1@1. 0@1. -1@1. -1@0. -1@-1. 0@-1. 1@-1}.	"Find the smallest enclosing rectangle"	rect _ self rectangleEnclosingPixelsNotOfColor: refColor.	"Find a pixel which is non-transparent"	y := rect top. x := rect left.	[x < rect right] whileTrue:[		(self safePixelAt: x@y using: peeker) = refValue ifFalse:[			startPos := x@y.			x := rect right].		x := x + 1.	].	startPos ifNil:[^self]. "this image is entirely transparent"	nextPos := startPos.	pixDir := 1. "we always start pointing to the right"	[		aBlock value: nextPos.		lastPos := nextPos.		"Search for a new pixel not of refColor at lastPos.		Start with the last direction turned 90 left"		pixDir := pixDir - 3 \\ 8 + 1.		[nextPos := lastPos + (pixelOffsets at: pixDir).		(self safePixelAt: nextPos using: peeker) = refValue] whileTrue:[			"Turn left until we find something"			pixDir := pixDir + 1 \\ 8 + 1.		].	nextPos = startPos] whileFalse.! !!Form methodsFor: '*Croquet' stamp: 'ar 3/7/2003 15:00'!traceOutlines	"Answer a collection of generalized polygons generated by tracing the edges in the receiver. Each polygon's first loop is the outer boundary, all following loops are inner boundaries."	| pts outlines outer lineSet inner mask leftOver outerOffset innerOffset |	outer := Form extent: self extent + 2 depth: 1.	outer offset: self offset-1.	(BitBlt toForm: outer)		sourceForm: self;		colorMap: (Color maskingMap: self depth);		destOrigin: 1@1;		combinationRule: Form over;		copyBits.	outlines := OrderedCollection new.	[pts := outer traceOutline: Color white.	pts isEmpty] whileFalse:[		lineSet := OrderedCollection with: pts.		mask := self traceRegionMask: pts.		outerOffset := mask offset.		mask offset: 0@0.		inner := Form extent: mask extent depth: mask depth.		"copy outer region to inner region"		outer displayOn: inner at: outerOffset negated rule: Form over.		"mask out remnants"		mask displayOn: inner at: 0@0 rule: Form and.		"now flood-fill inner region so previous 'outside area' vanishes"		inner floodFill: Color black at: 0@0.		"reverse inner form so it is inside-out"		inner reverse.		"clear the processed area"		mask reverse.		mask displayOn: outer at: outerOffset rule: Form and.		"find the interior edges"		[pts := inner traceOutline: Color white.		pts isEmpty] whileFalse:[			lineSet add: pts + outerOffset.			mask := self traceRegionMask: pts.			innerOffset := mask offset.			mask offset: 0@0.			"blt the left over portion of the region back onto outer"			leftOver := Form extent: mask extent depth: mask depth.			inner displayOn: leftOver at: innerOffset negated rule: Form over.			mask displayOn: leftOver at: 0@0 rule: Form and.			leftOver floodFill: Color black at: 0@0.			leftOver reverse.			leftOver displayOn: outer at: innerOffset + outerOffset rule: 7. "bitOr"			"clear the processed area"			mask reverse.			mask displayOn: inner at: innerOffset rule: Form and.		].		outlines add: lineSet.	].	^outlines! !!Form methodsFor: '*Croquet' stamp: 'ar 3/6/2003 18:37'!traceRegionMask: points	"Create a mask for the region inside points"	| min max mask poker |	min := points min.	max := points max.	"tag all the points in the outline"	mask := Form extent: (max - min)+3 depth: 1.	mask offset: min-1.	poker := BitBlt bitPokerToForm: mask.	points do:[:pt| poker pixelAt: pt - mask offset put: 1].	"floodfill the outside area (needs border!!)"	mask floodFill: Color black at: 0@0.	"clean out the pixels already marked (do we need this???)"	points do:[:pt| poker pixelAt: pt - mask offset put: 0].	"reverse maskForm to mask out pixels not belonging to original"	mask reverse.	^mask! !!Cursor class methodsFor: '*Croquet' stamp: 'ar 6/23/2002 20:24'!fist	^((CursorWithMask		extent: 16@16		depth: 1		fromArray: #( 0 0 0 0 0 229638144 306970624 269090816 134348800 402784256 537001984 537133056 268697600 134742016 67633152 67633152)		offset: -5@-9) setMaskForm: (Form		extent: 16@16		depth: 1		fromArray: #( 0 0 0 0 0 229638144 536608768 536739840 268304384 536739840 1073610752 1073479680 536608768 267911168 133693440 133693440)		offset: 0@0))! !!Cursor class methodsFor: '*Croquet' stamp: 'ar 6/23/2002 20:25'!hand	^((CursorWithMask		extent: 16@16		depth: 1		fromArray: #( 25165824 443547648 642252800 642383872 307036160 306774016 1745420288 2550202368 2281832448 1073872896 537001984 537133056 268697600 134742016 67633152 67633152)		offset: -5@-9) setMaskForm: (Form		extent: 16@16		depth: 1		fromArray: #( 25165824 468713472 1073217536 1073348608 536805376 536805376 1878982656 4294901760 4294836224 2147352576 1073610752 1073479680 536608768 267911168 133693440 133693440)		offset: 0@0))! !!DisplayScreen methodsFor: '*Croquet' stamp: 'ar 6/6/2002 22:33'!teaExportOn: exporter	^self error: 'Cannot export'! !!HttpUrl methodsFor: '*Croquet' stamp: 'ar 6/6/2002 16:51'!retrieveContentsArgs: args	^self retrieveContentsArgs: args accept: '*/*'! !!JPEGReadWriter methodsFor: '*Croquet' stamp: 'ar 6/6/2002 22:02'!understandsImageFormat	"Answer true if the image stream format is understood by this decoder."true ifTrue:[^false].	self next = 16rFF ifFalse: [^ false].	self next = 16rD8 ifFalse: [^ false].	^ true! !!JPEGReadWriter2 methodsFor: '*Croquet' stamp: 'ar 3/22/2002 23:55'!compressImage: aForm quality: quality progressiveJPEG: progressiveFlag buffer: buffer	"Encode the given Form on my stream with the given settings. Quality goes from 0 (low) to 100 (high), where -1 means default. If progressiveFlag is true, encode as a progressive JPEG."	| sourceForm jpegCompressStruct jpegErrorMgr2Struct |	aForm unhibernate.	"odd width images of depth 16 give problems; avoid them."	sourceForm _ (aForm depth = 32) | (aForm width even & (aForm depth = 16))		ifTrue: [aForm]		ifFalse: [aForm asFormOfDepth: 32].	jpegCompressStruct _ ByteArray new: self primJPEGCompressStructSize.	jpegErrorMgr2Struct _ ByteArray new: self primJPEGErrorMgr2StructSize.	^self primJPEGWriteImage: jpegCompressStruct 		onByteArray: buffer		form: sourceForm		quality: quality		progressiveJPEG: progressiveFlag		errorMgr: jpegErrorMgr2Struct.! !!JPEGReadWriter2 class methodsFor: '*Croquet' stamp: 'ar 3/22/2002 23:55'!compressImage: aForm quality: quality progressiveJPEG: progressiveFlag buffer: buffer	^self new compressImage: aForm quality: quality progressiveJPEG: progressiveFlag buffer: buffer! !!KeyboardBuffer methodsFor: '*Croquet' stamp: 'ar 7/19/2002 17:44'!keyboardPressed	^eventUsed not! !!LargePositiveInteger methodsFor: '*Croquet' stamp: 'ar 9/6/2002 15:53'!asByteArray	^(ByteArray new: self basicSize)		replaceFrom: 1 to: self basicSize with: self startingAt: 1;		yourself! !!LayoutFrame methodsFor: '*Croquet' stamp: 'ar 10/25/2002 20:36'!minExtentFrom: minExtent	"Return the minimal extent the given bounds can be represented in"	| left right top bottom width height |	left := top := 0.0.	right := bottom := 1.0.	width := height := 0.	leftFraction ifNotNil:[left := leftFraction].	rightFraction ifNotNil:[right := rightFraction].	topFraction ifNotNil:[top := topFraction].	bottomFraction ifNotNil:[bottom := bottomFraction].	left = right ifFalse:[width := minExtent x / (right - left)].	top = bottom ifFalse:[height := minExtent y / (bottom - top)].	leftOffset ifNotNil:[width _ width + leftOffset].	rightOffset ifNotNil:[width _ width + rightOffset].	topOffset ifNotNil:[height _ height + topOffset].	bottomOffset ifNotNil:[height _ height + bottomOffset].	^width truncated @ height truncated! !!MPEGFile methodsFor: '*Croquet' stamp: 'ar 2/26/2002 16:09'!closeFile	self unregister.	self finalize.! !!MPEGFile methodsFor: '*Croquet' stamp: 'ar 6/6/2002 15:22'!doneLoading: aLocator	(self class isFileValidMPEG: aLocator localFileName) ifTrue:[		pathToFile := aLocator localFileName.	].! !!MPEGFile methodsFor: '*Croquet' stamp: 'ar 6/3/2002 23:26'!fileHandle	fileBits ifNil:[self openFile: pathToFile].	(Smalltalk externalObjects at: fileIndex ifAbsent: [^nil]) == fileBits 		ifTrue: [^fileBits]		ifFalse: [^nil].! !!MPEGFile methodsFor: '*Croquet' stamp: 'ar 6/6/2002 15:22'!isLoaded	^pathToFile notNil! !!MPEGFile methodsFor: '*Croquet' stamp: 'ar 12/1/2002 17:12'!makeAbsolutePath: relPath	"Convert the current file name into an absolute path"	| imagePath index max fullName |	imagePath := (Smalltalk imageName findTokens: FileDirectory slash) allButLast.	max := imagePath size.	index := 0.	[(relPath at: (index := index + 1)) = '..'] whileTrue:[max := max - 1].	max := max max: 0.	fullName := WriteStream on: (String new: 100).	1 to: max do:[:i|		fullName nextPutAll: (imagePath at: i); nextPutAll: FileDirectory slash.	].	index to: relPath size do:[:i|		fullName nextPutAll: (relPath at: i); nextPutAll: FileDirectory slash.	].	^fullName contents allButLast! !!MPEGFile methodsFor: '*Croquet' stamp: 'ar 12/1/2002 17:14'!makeRelativePath: fullPath	"Convert the current file name into an array containing the location relative to the image"	| myPath imagePath myName index relPath |	myPath := fullPath findTokens: FileDirectory slash.	myName := myPath last.	myPath := myPath allButLast.	imagePath := (Smalltalk imageName findTokens: FileDirectory slash) allButLast.	index := 0.	[index < myPath size 		and:[index < imagePath size 		and:[(myPath at: index+1) sameAs: (imagePath at: index+1)]]] whileTrue:[index := index+1].	relPath := Array new: (imagePath size - index).	relPath atAllPut: '..'.	^relPath, (myPath copyFrom: index+1 to: myPath size) copyWith: myName.! !!MPEGFile methodsFor: '*Croquet' stamp: 'bf 10/22/2002 17:02'!openFile: aPath	| fullName | 	pathToFile _ aPath.	fullName _ FileDirectory default fullNameFor: pathToFile.	FileDirectory withCaseInsensitiveMatchFor: fullName		retry: [:match | fullName _ pathToFile _ match].	fileBits _ self primFileOpen: fullName.	fileBits notNil ifTrue: 		[fileIndex _ Smalltalk registerExternalObject: fileBits.		self register.]	! !!MPEGFile methodsFor: '*Croquet' stamp: 'ar 6/6/2002 12:30'!postImportFrom: importer	super postImportFrom: importer.	fileBits := nil.	fileIndex := nil.	locator ifNotNil:[		importer download: locator whenFinishedSend: #doneLoading: to: self.	].! !!MPEGFile methodsFor: '*Croquet' stamp: 'ar 9/6/2002 15:47'!prepareToExportOn: exporter	super prepareToExportOn: exporter.	locator := exporter addFileResource: (FileDirectory default fullNameFor: pathToFile) locator: locator.	pathToFile := nil.	fileBits := nil.	fileIndex := nil.! !!MPEGFile methodsFor: '*Croquet' stamp: 'ar 12/1/2002 17:17'!shutDown	"System shutdown"	(pathToFile isKindOf: String) ifTrue:[pathToFile := self makeRelativePath: pathToFile].! !!MPEGFile methodsFor: '*Croquet' stamp: 'ar 12/1/2002 19:30'!startUp	"System startup"	endianness := nil.	(pathToFile isKindOf: Array) ifTrue:[pathToFile := self makeAbsolutePath: pathToFile].! !!MPEGFile class methodsFor: '*Croquet' stamp: 'ar 12/1/2002 17:17'!initialize	"MPEGFile initialize"	Smalltalk addToStartUpList: self.	Smalltalk addToShutDownList: self.! !!MPEGFile class methodsFor: '*Croquet' stamp: 'bf 10/22/2002 17:01'!isFileValidMPEG: path	| fullName | 	fullName _ FileDirectory default fullNameFor: path.	FileDirectory withCaseInsensitiveMatchFor: fullName		retry: [:match | fullName _ match].	^self primFileValidMPEG: fullName! !!MPEGFile class methodsFor: '*Croquet' stamp: 'ar 12/1/2002 17:18'!shutDown	self allInstancesDo:[:each| each shutDown].! !!MPEGFile class methodsFor: '*Croquet' stamp: 'ar 12/1/2002 17:18'!startUp: resuming	resuming ifTrue:[		"system came up on fresh; close all 'old' files"		self registry keys do:[:file| file closeFile].	].	self allInstancesDo:[:each| each startUp].! !!MatrixTransform2x3 methodsFor: '*Croquet' stamp: 'ar 6/7/2002 13:42'!swapEndianness	Smalltalk swapBytesIn: self from: 1 to: self basicSize! !!Message methodsFor: '*Croquet' stamp: 'das 10/7/2002 15:26'!arguments: anArray	"Set the arguments of the receiver."	args _ anArray! !!Message methodsFor: '*Croquet' stamp: 'ar 10/2/2004 10:50'!delayedSendTo: receiver	"answer the result of sending this message to receiver"	receiver startScript: selector withArguments: args! !!Message methodsFor: '*Croquet' stamp: 'das 10/1/2004 17:09'!doConstruct	^ false.! !!Message methodsFor: '*Croquet' stamp: 'das 1/4/2003 14:30'!lookupClass: lc	lookupClass _ lc.! !!Metaclass methodsFor: '*Croquet' stamp: 'ar 6/6/2002 22:33'!teaExportOn: exporter	^self error: 'Cannot export'! !!Morph methodsFor: '*Croquet' stamp: 'ar 8/20/2002 14:42'!addMorph: aMorph frame: relFrame	| frame |	frame _ LayoutFrame new.	frame 		leftFraction: relFrame left; 		rightFraction: relFrame right; 		topFraction: relFrame top; 		bottomFraction: relFrame bottom.	self addMorph: aMorph fullFrame: frame.! !!Morph methodsFor: '*Croquet' stamp: 'ar 10/25/2002 20:18'!addMorph: aMorph frame: relFrame offsets: offsets	| frame |	frame _ LayoutFrame new.	frame 		leftFraction: relFrame left offset: offsets left; 		rightFraction: relFrame right offset: offsets right; 		topFraction: relFrame top offset: offsets top; 		bottomFraction: relFrame bottom offset: offsets bottom.	self addMorph: aMorph fullFrame: frame.! !!Morph methodsFor: '*Croquet' stamp: 'ar 9/6/2002 16:53'!alpha	^self color alpha! !!Morph methodsFor: '*Croquet' stamp: 'ar 9/6/2002 16:53'!alpha: aNumber	self color: (self color alpha: aNumber)! !!Morph methodsFor: '*Croquet' stamp: 'ar 10/1/2004 19:47'!glRenderOn: glx	| canvas |	canvas := OGLCanvas new initialize: glx.	canvas translateBy: glx viewport origin negated during:[:cc| self fullDrawOn: cc].! !!Morph methodsFor: '*Croquet' stamp: 'ar 6/22/2002 20:15'!halo	(self world ifNil: [^nil]) haloMorphs do: [:h | h target == self ifTrue: [^ h]].	^ nil! !!Morph methodsFor: '*Croquet' stamp: 'ar 6/11/2002 19:42'!layoutNeeded	"Return true if the receiver needs to recompute its layout"	^fullBounds == nil! !!Morph methodsFor: '*Croquet' stamp: 'ar 2/16/2002 21:40'!myEventMap	^self valueOfProperty: #myEventMap! !!Morph methodsFor: '*Croquet' stamp: 'ar 5/19/2002 18:04'!myEventMap: aMap	^self setProperty: #myEventMap toValue: aMap! !!Morph methodsFor: '*Croquet' stamp: 'ar 4/24/2002 17:15'!myScripts	^self valueOfProperty: #myScripts ifAbsent:[#()]! !!Morph methodsFor: '*Croquet' stamp: 'ar 4/23/2002 21:57'!myScripts: scriptList	"Add aScript to the receiver's list of scripts (if any)"	self setProperty: #myScripts toValue: scriptList! !!Morph methodsFor: '*Croquet' stamp: 'ar 6/7/2002 14:01'!postImportFrom: importer	super postImportFrom: importer.	submorphs do:[:sm| sm privateOwner: self].! !!Morph methodsFor: '*Croquet' stamp: 'ar 9/6/2002 15:47'!prepareToExportOn: exporter	super prepareToExportOn: exporter.	owner := nil.	fullBounds := nil.! !!Morph methodsFor: '*Croquet' stamp: 'ar 9/22/2002 21:26'!removeProperty: propName	"Remove the property with the given name. Answer the previous value."	extension == nil ifTrue: [^ nil].	^extension removeProperty: propName! !!Morph methodsFor: '*Croquet' stamp: 'ar 8/22/2001 01:12'!scriptScheduler	| scheduler |	scheduler _ Processor activeProcess scheduler.	scheduler isScriptScheduler ifTrue:[^scheduler].	"These are really fallback positions"	scheduler _ self world worldScriptScheduler.	scheduler ifNotNil:[scheduler].	^ScriptScheduler activeScheduler! !!Morph methodsFor: '*Croquet' stamp: 'ar 6/6/2002 22:33'!teaExportOn: exporter	^exporter exportMorph: self.! !!FlashPlayerMorph methodsFor: '*Croquet' stamp: 'ar 9/6/2002 15:50'!postImportFrom: importer	super postImportFrom: importer.	activeMorphs := activeMorphs asSortedCollection:[:m1 :m2| m1 depth > m2 depth].! !!FlashPlayerMorph methodsFor: '*Croquet' stamp: 'ar 9/6/2002 15:49'!prepareToExportOn: exporter	super prepareToExportOn: exporter.	activeMorphs := activeMorphs asArray.! !!HandMorph methodsFor: '*Croquet' stamp: 'ar 6/22/2002 01:02'!needsToBeDrawn	"Return true if this hand must be drawn explicitely instead of being drawn via the hardware cursor. This is the case if it (a) it is a remote hand, (b) it is showing a temporary cursor, or (c) it is not empty. If using the software cursor, ensure that the hardware cursor is hidden."	"Details:  Return true if this hand has a saved patch to ensure that is is processed by the world. This saved patch will be deleted after one final display pass when it becomes possible to start using the hardware cursor again. This trick gives us one last display cycle to allow us to remove the software cursor and shadow from the display."	(savedPatch notNil or:[(submorphs size > 0) or:[temporaryCursor ~~ nil or:[self hasUserInformation]]])		ifTrue: [			"using the software cursor; hide the hardware one"			self showHardwareCursor: false.			^ true].	^ false! !!HandMorph methodsFor: '*Croquet' stamp: 'ar 6/7/2002 13:41'!prepareToExportOn: exporter	super prepareToExportOn: exporter.	mouseFocus := keyboardFocus := nil.	mouseClickState := nil.	mouseOverHandler := nil.! !!HandMorph methodsFor: '*Croquet' stamp: 'ar 6/22/2002 01:02'!restoreSavedPatchOn: aCanvas	"Clear the changed flag and restore the part of the given canvas under this hand from the previously saved patch. If necessary, handle the transition to using the hardware cursor."	hasChanged _ false.	savedPatch ifNotNil: [		aCanvas drawImage: savedPatch at: savedPatch offset.		self hasUserInformation ifTrue: [^self].	"cannot use hw cursor if so"		submorphs size > 0 ifTrue: [^self].		temporaryCursor ifNotNil: [^self].		"Make the transition to using hardware cursor. Clear savedPatch and		 report one final damage rectangle to erase the image of the software cursor."		super invalidRect: (savedPatch offset extent: savedPatch extent + self shadowOffset) from: self.		self showHardwareCursor: true.		savedPatch _ nil.	].! !!HandMorph methodsFor: '*Croquet' stamp: 'ar 6/22/2002 01:02'!showHardwareCursor: aBool	aBool 		ifTrue:[Sensor currentCursor == Cursor normal ifFalse: [Cursor normal show]]		ifFalse:[Sensor currentCursor == Cursor blank ifFalse: [Cursor blank show]].! !!InternalThreadNavigationMorph methodsFor: '*Croquet' stamp: 'ar 9/23/2002 13:30'!currentIndex	| currentName |	currentName _ (self world ifNil:[ActiveWorld]) project name.	listOfPages withIndexDo: [ :each :index |		(each first = currentName and: [preferredIndex = index]) ifTrue: [^currentIndex _ index]	].	listOfPages withIndexDo: [ :each :index |		each first = currentName ifTrue: [^currentIndex _ index]	].	^currentIndex ifNil: [1]! !!InternalThreadNavigationMorph methodsFor: '*Croquet' stamp: 'ar 9/23/2002 01:51'!loadPageWithProgress	| projectInfo projectName projOwner |	projectInfo _ listOfPages at: currentIndex.	projectName _ projectInfo at: 1.	loadedProject _ Project named: projectName.	self class know: listOfPages as: threadName.	projOwner _ RequestProjectOwner signal.	projOwner ifNil:[		WorldState addDeferredUIMessage: [			InternalThreadNavigationMorph openThreadNamed: threadName atIndex: currentIndex		] fixTemps.	].	loadedProject ifNil: [		ComplexProgressIndicator new 			targetMorph: self;			historyCategory: 'project loading';			withProgressDo: [				[					loadedProject _ CurrentProjectRefactoring 							currentFromMyServerLoad: projectName				] 					on: ProjectViewOpenNotification					do: [ :ex | ex resume: false]								"we probably don't want a project view morph in this case"			].	].	loadedProject ifNil: [		^self inform: 'I cannot find that project'	].	projOwner ifNil:[self delete].	loadedProject enter.	projOwner ifNotNil:[		self threadName: threadName index: currentIndex;			removeAllMorphs; addButtons.		projOwner world addMorphFront: self.		self positionAppropriately.	].! !!LineMorph class methodsFor: '*Croquet' stamp: 'ar 3/9/2004 21:45'!arrowFrom: startPoint to: endPoint width: lineWidth	^self arrowFrom: startPoint to: endPoint width: lineWidth color: Color black! !!LineMorph class methodsFor: '*Croquet' stamp: 'ar 3/9/2004 21:45'!arrowFrom: startPoint to: endPoint width: lineWidth color: aColor	^ (PolygonMorph vertices: {startPoint. endPoint}			color: aColor borderWidth: lineWidth borderColor: aColor) makeForwardArrow! !!MPEGDisplayMorph methodsFor: '*Croquet' stamp: 'das 6/5/2002 11:17'!running	^ running.! !!MenuMorph methodsFor: '*Croquet' stamp: 'ar 10/10/2002 18:44'!add: aString selector: aSymbol arguments: args	self add: aString		target: defaultTarget		selector: aSymbol		argumentList: args! !!MenuMorph methodsFor: '*Croquet' stamp: 'ar 10/11/2002 15:09'!setInvokingView: invokingView	"Re-work every menu item of the form		<target> perform: <selector>	to the form		<target> perform: <selector> orSendTo: <invokingView>.	This supports MVC's vectoring of non-model messages to the editPane."	self items do:[:item |		item subMenu ifNil:[		item arguments isEmpty ifTrue:  "only the simple messages"			[item arguments: (Array with: item selector with: invokingView).			item selector: #perform:orSendTo:]]]! !!MorphExtension methodsFor: '*Croquet' stamp: 'ar 2/19/2002 15:06'!copyWeakly	"list of names of properties whose values should be weak-copied when veryDeepCopying a morph.  See DeepCopier."	^ #(formerOwner newPermanentPlayer myPlayer myEvents myEventMap myScripts) 	"add yours to this list" "formerOwner should really be nil at the time of the copy, but this will work just fine."! !!MorphExtension methodsFor: '*Croquet' stamp: 'ar 9/22/2002 21:27'!removeProperty: propName	| prevValue |	otherProperties == nil ifTrue: [^ nil].	prevValue _ otherProperties removeKey: propName ifAbsent: [nil].	otherProperties size == 0 ifTrue: [otherProperties _ nil].	^prevValue! !!NewParagraph methodsFor: '*Croquet' stamp: 'ar 6/23/2002 21:10'!bounds	^0@0 extent: maxRightX @ (lines last bottom - lines first top)! !!NewParagraph methodsFor: '*Croquet' stamp: 'ar 6/30/2002 23:02'!positionWhenComposed	^positionWhenComposed! !!Number class methodsFor: '*Croquet-override' stamp: 'ar 10/4/2004 23:00'!readFrom: stringOrStream 	"Answer a number as described on aStream.  The number may	include a leading radix specification, as in 16rFADE"	| value base aStream sign |	aStream _ (stringOrStream isMemberOf: String)		ifTrue: [ReadStream on: stringOrStream]		ifFalse: [stringOrStream].	(aStream nextMatchAll: 'NaN') ifTrue: [^ Float nan].	sign _ (aStream peekFor: $-) ifTrue: [-1] ifFalse: [1].	(aStream nextMatchAll: 'Infinity') ifTrue: [^ Float infinity * sign].	base _ 10.	value _ Integer readFrom: aStream base: base.	value ifNil:[^nil].	(aStream peekFor: $r)		ifTrue: 			["<base>r<integer>"			(base _ value) < 2 ifTrue: [^self error: 'Invalid radix'].			(aStream peekFor: $-) ifTrue: [sign _ sign negated].			value _ Integer readFrom: aStream base: base.			value ifNil:[^nil].].	^ self readRemainderOf: value from: aStream base: base withSign: sign.! !!Number class methodsFor: '*Croquet-override' stamp: 'ar 10/4/2004 23:00'!readRemainderOf: integerPart from: aStream base: base withSign: sign	"Read optional fractional part and exponent, and return the final result"	| value fraction fracpos val |	value _ integerPart.	(aStream peekFor: $.)		ifTrue: 			["<integer>.<fraction>"			(aStream atEnd not and: [aStream peek digitValue between: 0 and: base - 1])				ifTrue: 					[fracpos _ aStream position.					fraction _ Integer readFrom: aStream base: base.					fraction ifNil:[^nil].					fraction _ 						fraction asFloat / (base raisedTo: aStream position - fracpos).					value _ value asFloat + fraction]				ifFalse: 					["oops - just <integer>."					aStream skip: -1.		"un-gobble the period"					^ value * sign					"Number readFrom: '3r-22.2'"]].	(aStream peekFor: $e)		ifTrue: 			["<integer>e<exponent>"			val _ Integer readFrom: aStream.			val ifNil:[^nil].			value _ value * (base raisedTo: val)].	(value isFloat and: [value = 0.0 and: [sign = -1]])		ifTrue: [^ Float negativeZero]		ifFalse: [^ value * sign]! !!Float class methodsFor: '*Croquet' stamp: 'das 5/7/2002 02:00'!epsilon	"Answer the precision of mathematical functions."	^ Epsilon. ! !!Float class methodsFor: '*Croquet' stamp: 'ar 6/5/2002 23:21'!teaImportLiteralFrom: byteStream	| lit value |	lit := byteStream next: 8.	value := 0 asFloat.	value basicAt: 1 put: (lit unsignedLongAt: 1 bigEndian: true).	value basicAt: 2 put: (lit unsignedLongAt: 5 bigEndian: true).	^value! !!Float class methodsFor: '*Croquet-override' stamp: 'ar 10/4/2004 23:01'!readFrom: aStream 	"Answer a new Float as described on the stream, aStream."	| val |	val_ (super readFrom: aStream).	val ifNil:[^nil].	^val asFloat! !!Integer class methodsFor: '*Croquet-override' stamp: 'ar 10/4/2004 23:00'!readFrom: aStream base: base 	"Answer an instance of one of my concrete subclasses. Initial minus sign 	accepted, and bases > 10 use letters A-Z. Embedded radix specifiers not 	allowed--use Number readFrom: for that. Answer zero (not an error) if 	there are no digits."	| digit value neg startPos |	neg _ aStream peekFor: $-.	neg ifFalse: [aStream peekFor: $+].	value _ 0.	startPos _ aStream position.	[aStream atEnd]		whileFalse: 			[digit _ aStream next digitValue.			(digit < 0 or: [digit >= base])				ifTrue: 					[aStream skip: -1.					aStream position = startPos ifTrue: [^ nil. "self error: 'At least one digit expected here'"].					neg ifTrue: [^ value negated].					^ value]				ifFalse: [value _ value * base + digit]].	neg ifTrue: [^ value negated].	^ value! !!OGLBlt methodsFor: 'text display' stamp: 'das 3/12/2004 12:27'!displayString: aString from: startIndex to: stopIndex at: aPoint strikeFont: font kern: kernDelta	ogl glRasterPos3f: textPosition x with: textPosition y with: textPosition z.	ogl glBitmap: 0 with: 0 with: 0 with: 0		with: aPoint x		with: 0 - aPoint y - font height		with: nil.	ogl fontManager drawString: aString from: startIndex to: stopIndex font: font align: nil.! !!OGLBlt methodsFor: 'text display' stamp: 'das 3/12/2004 12:27'!fillRectangle: aRectangle color: caretColor	ogl glColor3f: caretColor red with: caretColor green with: caretColor blue.	ogl glRectf: aRectangle left with: aRectangle top with: aRectangle right with: aRectangle bottom.! !!OGLBlt methodsFor: 'text display' stamp: 'das 3/12/2004 12:27'!installStrikeFont: aStrikeFont foregroundColor: fg backgroundColor: bg	ogl glColor4f: fg red with: fg green with: fg blue with: fg alpha.! !!OGLBlt methodsFor: 'text display' stamp: 'ar 6/23/2002 20:58'!textOffset: offset	textOffset := offset.! !!OGLBlt methodsFor: 'text display' stamp: 'ar 6/23/2002 20:58'!textPosition: pt	textPosition := pt.! !!OGLBlt methodsFor: 'initialize' stamp: 'das 3/12/2004 12:27'!initialize: oGL	ogl := oGL.	self clipRect: (Display boundingBox).! !!OGLCanvas methodsFor: 'private' stamp: 'ar 6/30/2002 21:41'!fillOval: aRectangle! !!OGLCanvas methodsFor: 'private' stamp: 'das 3/12/2004 12:29'!fillPoly: vertices	ogl glBegin: GLPolygon.	vertices do:[:vtx|		ogl glVertex2f: vtx x with: vtx y.	].	ogl glEnd.! !!OGLCanvas methodsFor: 'private' stamp: 'das 3/12/2004 12:28'!fillRect: aRectangle	ogl glRectf: aRectangle left with: aRectangle top with: aRectangle right with: aRectangle bottom.! !!OGLCanvas methodsFor: 'private' stamp: 'ar 6/30/2002 21:41'!frameOval: aRectangle! !!OGLCanvas methodsFor: 'private' stamp: 'das 3/12/2004 12:29'!framePoly: vertices	ogl glBegin: GLLineLoop.	vertices do:[:vtx|		ogl glVertex2f: vtx x with: vtx y.	].	ogl glEnd.! !!OGLCanvas methodsFor: 'private' stamp: 'das 3/12/2004 12:28'!frameRectInner: inner outer: outer	ogl glBegin: GLTriangleStrip.	ogl glVertex2f: outer left with: outer top.	ogl glVertex2f: inner left with: inner top.	ogl glVertex2f: outer right with: outer top.	ogl glVertex2f: inner right with: inner top.	ogl glVertex2f: outer right with: outer bottom.	ogl glVertex2f: inner right with: inner bottom.	ogl glVertex2f: outer left with: outer bottom.	ogl glVertex2f: inner left with: inner bottom.	ogl glVertex2f: outer left with: outer top.	ogl glVertex2f: inner left with: inner top.	ogl glEnd.! !!OGLCanvas methodsFor: 'private' stamp: 'das 3/12/2004 12:28'!lineFrom: pt1 to: pt2	ogl glBegin: GLLines.	ogl glVertex2f: pt1 x with: pt1 y.	ogl glVertex2f: pt2 x with: pt2 y.	ogl glEnd.! !!OGLCanvas methodsFor: 'private' stamp: 'das 3/12/2004 12:28'!setFillColor: aColor	| color |	color := shadowColor ifNil:[aColor].	color ifNil:[^self].	ogl glColor4f: color red with: color green with: color blue with: color alpha.! !!OGLCanvas methodsFor: 'private' stamp: 'das 3/12/2004 12:28'!setLineWidth: bw	ogl glLineWidth: bw.! !!OGLCanvas methodsFor: 'drawing-support' stamp: 'das 3/12/2004 12:29'!clipBy: aRectangle during: aBlock	| oldClip |	clipDepth = 0 ifTrue:[ogl glEnable: GLStencilTest].	clipDepth := clipDepth + 1.	ogl glStencilOp: GLKeep with: GLKeep with: GLIncr.	ogl glColorMask: GLFalse with: GLFalse with: GLFalse with: GLFalse.	oldClip := clipRect.	clipRect := clipRect intersect: (aRectangle translateBy: origin).	self fillRect: clipRect.	ogl glColorMask: GLTrue with: GLTrue with: GLTrue with: GLTrue.	ogl glStencilOp: GLKeep with: GLKeep with: GLKeep.	ogl glStencilFunc: GLEqual with: clipDepth with: -1.	[aBlock value: self] ensure:[		ogl glStencilOp: GLKeep with: GLKeep with: GLDecr.		ogl glColorMask: GLFalse with: GLFalse with: GLFalse with: GLFalse.		self fillRect: clipRect.		ogl glColorMask: GLTrue with: GLTrue with: GLTrue with: GLTrue.		ogl glStencilOp: GLKeep with: GLKeep with: GLKeep.		clipDepth := clipDepth - 1.		ogl glStencilFunc: GLEqual with: clipDepth with: -1.		clipDepth = 0 ifTrue:[ogl glDisable: GLStencilTest].		clipRect := oldClip.	].! !!OGLCanvas methodsFor: 'drawing-support' stamp: 'ar 6/30/2002 21:23'!clipRect	"Return the currently active clipping rectangle"	^ clipRect translateBy: origin negated! !!OGLCanvas methodsFor: 'drawing-support' stamp: 'ar 6/30/2002 21:23'!contentsOfArea: aRectangle into: aForm	"Return the contents of the given area"	^aForm! !!OGLCanvas methodsFor: 'drawing-support' stamp: 'ar 6/30/2002 21:57'!drawPolygon: vertices color: aColor borderWidth: bw borderColor: bc	"Draw the given polygon."	self setFillColor: aColor.	self fillPoly: vertices.	(bw = 0 or:[bc == nil or:[bc isTransparent]]) ifFalse:[		self setFillColor: bc.		self setLineWidth: bw.		self framePoly: vertices.	].! !!OGLCanvas methodsFor: 'drawing-support' stamp: 'das 3/12/2004 12:29'!drawString: s from: firstIndex to: lastIndex in: boundsRect font: fontOrNil color: aColor	self setFillColor: aColor.	ogl drawString: s from: firstIndex to: lastIndex at: boundsRect topLeft font: fontOrNil align: #topLeft.! !!OGLCanvas methodsFor: 'drawing-support' stamp: 'das 3/12/2004 12:29'!extent	"Return the physical extent of the output device"	^ogl extent! !!OGLCanvas methodsFor: 'drawing-support' stamp: 'ar 6/30/2002 21:41'!fillOval: r color: c borderWidth: borderWidth borderColor: borderColor	"Fill the given oval."	self setFillColor: c.	self fillOval: r.	(borderWidth = 0 or:[borderColor == nil or:[borderColor isTransparent]]) ifFalse:[		self setFillColor: borderColor.		self setLineWidth: borderWidth.		self frameOval: r.	].! !!OGLCanvas methodsFor: 'drawing-support' stamp: 'ar 6/30/2002 22:23'!frameAndFillRectangle: r fillColor: fillColor borderWidth: borderWidth borderColor: borderColor	"Draw the rectangle using the given attributes"	(borderWidth = 0 or:[borderColor isTransparent]) ifFalse:[		self setFillColor: borderColor.		self frameRectInner: (r insetBy: borderWidth) outer: r.	].	fillColor isTransparent ifFalse:[		self setFillColor: fillColor.		self fillRect: (r insetBy: borderWidth).	].! !!OGLCanvas methodsFor: 'drawing-support' stamp: 'ar 6/30/2002 21:24'!image: aForm at: aPoint sourceRect: sourceRect rule: rule	"Note: The public use of this protocol is deprecated. It will become private. Nobody in the outside world must assume that a thing like a combination rule has any specific effect."! !!OGLCanvas methodsFor: 'drawing-support' stamp: 'ar 6/30/2002 21:41'!line: pt1 to: pt2 width: w color: c	"Draw a line using the given width and color"	self setFillColor: c.	self setLineWidth: w.	self lineFrom: pt1 to: pt2.! !!OGLCanvas methodsFor: 'drawing-support' stamp: 'ar 6/30/2002 21:24'!origin	"Return the current origin for drawing operations"	^ origin! !!OGLCanvas methodsFor: 'drawing-support' stamp: 'das 3/12/2004 12:29'!paragraph: paragraph bounds: bounds color: aColor	"Draw the given paragraph"	ogl drawParagraph: paragraph color: aColor at: bounds topLeft align: #topLeft.! !!OGLCanvas methodsFor: 'drawing-support' stamp: 'ar 6/30/2002 21:24'!stencil: stencilForm at: aPoint sourceRect: sourceRect color: aColor	"Flood this canvas with aColor wherever stencilForm has non-zero pixels"! !!OGLCanvas methodsFor: 'drawing-support' stamp: 'ar 6/30/2002 23:06'!transformBy: aDisplayTransform clippingTo: aClipRect during: aBlock smoothing: cellSize	"Transform the receiver by the given display transformation during the execution of aBlock. The given clip rectangle defines the *global* (e.g., outer) rectangle against which the receiver should clip (which would be equivalent to 'self clipRect: aClipRect; transformBy: aDisplayTransform')."	self clipBy: aClipRect during:[:cc|		cc translateBy: aDisplayTransform offset negated rounded during: aBlock.	].! !!OGLCanvas methodsFor: 'drawing-support' stamp: 'das 3/12/2004 12:29'!translateBy: delta during: aBlock	"Set a translation only during the execution of aBlock."	| oldOrigin |	oldOrigin := origin.	ogl glTranslatef: delta x with: delta y with: 0.	origin := origin + delta.	[aBlock value: self] ensure:[		ogl glTranslatef: 0-delta x with: 0-delta y with: 0.		origin := oldOrigin.	].! !!OGLCanvas methodsFor: 'drawing-support' stamp: 'ar 6/30/2002 21:25'!warpImage: aForm transform: aTransform at: extraOffset sourceRect: sourceRect cellSize: cellSize	"Warp the given using the appropriate transform and offset."! !!OGLCanvas methodsFor: 'copying' stamp: 'ar 6/30/2002 21:50'!copy	self error:'oh no'.! !!OGLCanvas methodsFor: 'initialize' stamp: 'das 3/12/2004 12:29'!initialize: oGL	ogl := oGL.	origin := 0@0.	clipRect := origin extent: ogl extent.	clipDepth := 0.	ogl glClear: GLStencilBufferBit.! !!OGLExtManager methodsFor: 'dynamic lookup' stamp: 'das 3/12/2004 14:19'!doesNotUnderstand: aMessage	"WARNING: DON'T TRY THIS AT HOME!!	If you grok this method you are seriously ready for meta-programming.	If you don't you shouldn't worry either - it's not your fault ;-)"	| method ffiCall extension |	"see if that method is really there"	method := OGLExtManager class "(!!)" compiledMethodAt: aMessage selector ifAbsent:[nil].	method ifNil:[^super doesNotUnderstand: aMessage].	"see if it's an FFI call"	(method numLiterals > 0 and:[(method literalAt: 1) isKindOf: ExternalFunction])		ifFalse:[^super doesNotUnderstand: aMessage].	"grab the ffi call from the method"	ffiCall := method literalAt: 1.	"see if it describes some extension (module needs to be empty)"	ffiCall module isNil ifFalse:[^super doesNotUnderstand: aMessage].	"look up the extension"	extension := OGLExtManager class organization categoryOfElement: aMessage selector.	"load the extension"	self loadExtension: extension.	"and reinvoke method"	(self respondsTo: aMessage selector) ifTrue:[		^self perform: aMessage selector withArguments: aMessage arguments	].	^super doesNotUnderstand: aMessage! !!OGLExtManager methodsFor: 'dynamic lookup' stamp: 'das 3/12/2004 14:19'!loadExtension: extName	"Load and install the extension with the given name"	| selectors callType method ffiCall ffiAddr methodCopy |	ogl ifNil:[^self error: 'OGLExtManager must be bound to a specific context'].	"see if the extension is present"	(ogl extensions includes: extName) ifFalse:[^self error: extName, ' is not present'].	"verify that we're an anonymous subclass of OGLExtManager"	(self class superclass ~~ OGLExtManager or:[		OGLExtManager subclasses includes: self class]) ifTrue:[			^self error: 'Must be anonymous'].	"pick up the selectors"	selectors := OGLExtManager class "!!" organization listAtCategoryNamed: extName.	"get the calling convention"	callType := ogl glExtCallingConvention.	"install the methods"	selectors do:[:sel|		method := OGLExtManager class compiledMethodAt: sel ifAbsent:[nil].		(method notNil 			and:[method numLiterals > 0 				and:[(ffiCall := method literalAt: 1) isKindOf: ExternalLibraryFunction]]) 					ifTrue:[			"get the address of the extension function"			ffiAddr := ogl glExtGetProcAddress: ffiCall name.			(ffiAddr == nil or:[ffiAddr = 0]) ifFalse:[				ffiAddr := ExternalAddress new fromInteger: ffiAddr.			].			"clone the method"			methodCopy := method clone.			"set up a new ffi function"			ffiCall := ExternalLibraryFunction new 				name: ffiCall name 				module: ffiCall module 				flags: callType 				argTypes: ffiCall argTypes.			ffiCall setHandle: ffiAddr.			"install the new ffi call"			methodCopy literalAt: 1 put: ffiCall.			"add the copy to our method dictionary"			self class addSelector: sel withMethod: methodCopy.		].	].! !!OGLExtManager methodsFor: 'accessing' stamp: 'das 3/12/2004 12:44'!ogl	^ogl! !!OGLExtManager methodsFor: 'accessing' stamp: 'das 3/12/2004 12:44'!ogl: aOGL	ogl := aOGL.! !!OGLExtManager class methodsFor: 'GL_ARB_texture_compression' stamp: 'ar 12/4/2003 21:08'!glCompressedTexImage1DARB(target, level, internalformat, width, border, imageSize, data)	"void glCompressedTexImage1DARB(enum target, int level,                                 enum internalformat, sizei width,                                 int border, sizei imageSize,                                 const void *data);"	<apicall: void 'glCompressedTexImage1DARB' (long long long long long long void*)>	^self externalCallFailed! !!OGLExtManager class methodsFor: 'GL_ARB_texture_compression' stamp: 'ar 4/26/2003 02:06'!glCompressedTexImage1DARB: target with: level with: internalformat with: width with: border with: imageSize with: data	"void glCompressedTexImage1DARB(enum target, int level,                                 enum internalformat, sizei width,                                 int border, sizei imageSize,                                 const void *data);"	<apicall: void 'glCompressedTexImage1DARB' (long long long long long long void*)>	^self externalCallFailed! !!OGLExtManager class methodsFor: 'GL_ARB_texture_compression' stamp: 'ar 12/4/2003 21:08'!glCompressedTexImage2DARB(target, level, internalformat, width, height, border, imageSize, data)	"void glCompressedTexImage2DARB(enum target, int level,                                 enum internalformat, sizei width,                                 sizei height,                                 int border, sizei imageSize,                                 const void *data);"	<apicall: void 'glCompressedTexImage2DARB' (long long long long long long long void*)>	^self externalCallFailed! !!OGLExtManager class methodsFor: 'GL_ARB_texture_compression' stamp: 'ar 4/26/2003 02:06'!glCompressedTexImage2DARB: target with: level with: internalformat with: width with: height with: border with: imageSize with: data	"void glCompressedTexImage2DARB(enum target, int level,                                 enum internalformat, sizei width,                                 sizei height,                                 int border, sizei imageSize,                                 const void *data);"	<apicall: void 'glCompressedTexImage2DARB' (long long long long long long long void*)>	^self externalCallFailed! !!OGLExtManager class methodsFor: 'GL_ARB_texture_compression' stamp: 'ar 12/4/2003 21:07'!glCompressedTexImage3DARB(target, level, internalformat, width, height, depth, border, imageSize, data)	"void glCompressedTexImage3DARB(enum target, int level,                                 enum internalformat, sizei width,                                 sizei height, sizei depth,                                 int border, sizei imageSize,                                 const void *data);"	<apicall: void 'glCompressedTexImage3DARB' (long long long long long long long long void*)>	^self externalCallFailed! !!OGLExtManager class methodsFor: 'GL_ARB_texture_compression' stamp: 'ar 4/26/2003 02:04'!glCompressedTexImage3DARB: target with: level with: internalformat with: width with: height with: depth with: border with: imageSize with: data	"void glCompressedTexImage3DARB(enum target, int level,                                 enum internalformat, sizei width,                                 sizei height, sizei depth,                                 int border, sizei imageSize,                                 const void *data);"	<apicall: void 'glCompressedTexImage3DARB' (long long long long long long long long void*)>	^self externalCallFailed! !!OGLExtManager class methodsFor: 'GL_ARB_texture_compression' stamp: 'ar 12/4/2003 21:07'!glCompressedTexSubImage1DARB(target, level, xoffset, width, aFormat, imageSize, data)	"void CompressedTexSubImage1DARB(enum target, int level,                                     int xoffset, sizei height,                                    enum format, sizei imageSize,                                    const void *data);"	<apicall: void 'glCompressedTexImage2DARB' (long long long long long long void*)>	^self externalCallFailed! !!OGLExtManager class methodsFor: 'GL_ARB_texture_compression' stamp: 'ar 4/26/2003 02:09'!glCompressedTexSubImage1DARB: target with: level with: xoffset with: width with: aFormat with: imageSize with: data	"void CompressedTexSubImage1DARB(enum target, int level,                                     int xoffset, sizei height,                                    enum format, sizei imageSize,                                    const void *data);"	<apicall: void 'glCompressedTexImage2DARB' (long long long long long long void*)>	^self externalCallFailed! !!OGLExtManager class methodsFor: 'GL_ARB_texture_compression' stamp: 'ar 12/4/2003 21:07'!glCompressedTexSubImage2DARB(target, level, xoffset, yoffset, width, height, aFormat, imageSize, data)	"void CompressedTexSubImage2DARB(enum target, int level,                                     int xoffset, int yoffset,                                    sizei width, sizei height,                                    enum format, sizei imageSize,                                    const void *data);"	<apicall: void 'glCompressedTexImage2DARB' (long long long long long long long long void*)>	^self externalCallFailed! !!OGLExtManager class methodsFor: 'GL_ARB_texture_compression' stamp: 'ar 4/26/2003 02:08'!glCompressedTexSubImage2DARB: target with: level with: xoffset with: yoffset with: width with: height with: aFormat with: imageSize with: data	"void CompressedTexSubImage2DARB(enum target, int level,                                     int xoffset, int yoffset,                                    sizei width, sizei height,                                    enum format, sizei imageSize,                                    const void *data);"	<apicall: void 'glCompressedTexImage2DARB' (long long long long long long long long void*)>	^self externalCallFailed! !!OGLExtManager class methodsFor: 'GL_ARB_texture_compression' stamp: 'ar 12/4/2003 21:06'!glCompressedTexSubImage3DARB(target, level, xoffset, yoffset, zoffset, width, height, depth, aFormat, imageSize, data)	"void CompressedTexSubImage3DARB(enum target, int level,                                     int xoffset, int yoffset,                                    int zoffset, sizei width,                                    sizei height, sizei depth,                                    enum format, sizei imageSize,                                    const void *data);"	<apicall: void 'glCompressedTexImage2DARB' (long long long long long long long long long long void*)>	^self externalCallFailed! !!OGLExtManager class methodsFor: 'GL_ARB_texture_compression' stamp: 'ar 4/26/2003 02:08'!glCompressedTexSubImage3DARB: target with: level with: xoffset with: yoffset with: zoffset with: width with: height with: depth with: aFormat with: imageSize with: data	"void CompressedTexSubImage3DARB(enum target, int level,                                     int xoffset, int yoffset,                                    int zoffset, sizei width,                                    sizei height, sizei depth,                                    enum format, sizei imageSize,                                    const void *data);"	<apicall: void 'glCompressedTexImage2DARB' (long long long long long long long long long long void*)>	^self externalCallFailed! !!OGLExtManager class methodsFor: 'GL_ARB_texture_compression' stamp: 'ar 12/4/2003 21:06'!glGetCompressedTexImageARB(target, lod, img)	"void GetCompressedTexImageARB(enum target, int lod,                                    void *img);"	<apicall: void 'glCompressedTexImage1DARB' (long long void*)>	^self externalCallFailed! !!OGLExtManager class methodsFor: 'GL_ARB_texture_compression' stamp: 'ar 4/26/2003 02:18'!glGetCompressedTexImageARB: target with: lod with: img	"void GetCompressedTexImageARB(enum target, int lod,                                    void *img);"	<apicall: void 'glCompressedTexImage1DARB' (long long void*)>	^self externalCallFailed! !!OGLExtManager class methodsFor: 'GL_ARB_texture_compression' stamp: 'das 3/13/2004 14:50'!initializeArbTextureCompression	"OGLExtManager initialize"	"Initialize ARB_texture_compression constants"	self install: 'ArbTextureCompression' withEXTConstants: #(		"glTexImage/glCopyTexImage"		'COMPRESSED_ALPHA_ARB				0x84E9'		'COMPRESSED_LUMINANCE_ARB			0x84EA'		'COMPRESSED_LUMINANCE_ALPHA_ARB			0x84EB'		'COMPRESSED_INTENSITY_ARB			0x84EC'		'COMPRESSED_RGB_ARB				0x84ED'		'COMPRESSED_RGBA_ARB				0x84EE'		"glHint/glGet"		'TEXTURE_COMPRESSION_HINT_ARB			0x84EF'		"glGetTexLevelParameter"		'TEXTURE_COMPRESSED_IMAGE_SIZE_ARB		0x86A0'		'TEXTURE_COMPRESSED_ARB				0x86A1'		"glGet*"		'NUM_COMPRESSED_TEXTURE_FORMATS_ARB		0x86A2'		'COMPRESSED_TEXTURE_FORMATS_ARB			0x86A3'	)! !!OGLExtManager class methodsFor: 'GL_EXT_texture_compression_s3tc' stamp: 'das 3/13/2004 14:50'!initializeExtTextureCompressionS3tc	"OGLExtManager initialize"	"Initialize EXT_texture_compression_s3tc constants"	self install: 'ExtTextureCompressionS3tc' withEXTConstants: #(		'COMPRESSED_RGB_S3TC_DXT1_EXT                   0x83F0'		'COMPRESSED_RGBA_S3TC_DXT1_EXT                  0x83F1'		'COMPRESSED_RGBA_S3TC_DXT3_EXT                  0x83F2'		'COMPRESSED_RGBA_S3TC_DXT5_EXT                  0x83F3'	)! !!OGLExtManager class methodsFor: 'GL_EXT_compiled_vertex_array' stamp: 'ar 12/4/2003 21:05'!glLockArraysEXT(first, count)	"void glLockArraysEXT (int first, sizei count)"	<apicall: void 'glLockArraysEXT' (long long)>	^self externalCallFailed! !!OGLExtManager class methodsFor: 'GL_EXT_compiled_vertex_array' stamp: 'ar 1/4/2003 00:00'!glLockArraysEXT: first with: count	"void glLockArraysEXT (int first, sizei count)"	<apicall: void 'glLockArraysEXT' (long long)>	^self externalCallFailed! !!OGLExtManager class methodsFor: 'GL_EXT_compiled_vertex_array' stamp: 'ar 1/4/2003 00:00'!glUnlockArraysEXT	"void glUnlockArraysEXT (void)"	<apicall: void 'glUnlockArraysEXT' (void)>	^self externalCallFailed! !!OGLExtManager class methodsFor: 'GL_EXT_compiled_vertex_array' stamp: 'ar 12/4/2003 21:05'!glUnlockArraysEXT()	"void glUnlockArraysEXT (void)"	<apicall: void 'glUnlockArraysEXT' (void)>	^self externalCallFailed! !!OGLExtManager class methodsFor: 'GL_EXT_compiled_vertex_array' stamp: 'ar 5/18/2003 17:16'!initializeExtCompiledVertexArray	self install: 'ExtCompiledVertexArray' withEXTConstants: #(		'ARRAY_ELEMENT_LOCK_COUNT_EXT	0x81A9'		'ARRAY_ELEMENT_LOCK_FIRST_EXT	0x81A8'	).! !!OGLExtManager class methodsFor: 'GL_SGIS_generate_mipmap' stamp: 'ar 5/18/2003 17:17'!initializeSgisGenerateMipmap	"GLExtensions initialize"	"Initialize SGIS_GENERATE_MIPMAP constants"	self install: 'SgisGenerateMipmap' withEXTConstants: #(		'GENERATE_MIPMAP_SGIS		0x8191'		'GENERATE_MIPMAP_HINT_SGIS	0x8192'	)! !!OGLExtManager class methodsFor: 'class initialization' stamp: 'das 3/12/2004 15:19'!forwardExtMethod: aSelector	"Compile a forwarder method in OpenGL"	| code parser fwdCode |	code := self class sourceCodeAt: aSelector.	parser := self parserClass new.	parser parseSelector: code.	code := code copyFrom: 1 to: (parser endOfLastToken min: code size).	fwdCode := String streamContents:[:s|		s nextPutAll: code.		s crtab; nextPutAll: '"This method was automatically generated"'.		s crtab; nextPutAll: '^glExt '; nextPutAll: code.	].	OpenGL compile: fwdCode classified: (self class organization categoryOfElement: aSelector).! !!OGLExtManager class methodsFor: 'class initialization' stamp: 'das 3/13/2004 14:49'!initialize	"OGLExtManager initialize"	"Initialize all registered extensions. Please see the class comment."	self class selectorsAndMethodsDo:[:sel :meth|		(sel ~= #initialize and:[sel beginsWith: 'initialize']) ifTrue:[self perform: sel].		((sel beginsWith: 'gl') and:[meth numLiterals > 0 and:[(meth literalAt: 1) isKindOf: ExternalLibraryFunction]]) ifTrue:[			self forwardExtMethod: sel.		].	].	GLExtConstants initialize.! !!OGLExtManager class methodsFor: 'class initialization' stamp: 'das 3/13/2004 14:50'!install: extension withEXTConstants: list	"Take a list of strings comprising open gl constants, and install them into GLEXTConstants.	See also parseSpecConstants:."	| code |	code := String new writeStream.	code nextPutAll: 'initialize', extension.	code crtab; nextPutAll: '"This method was automatically generated by OGLExtManager"'.	(self parseEXTConstants: list) do:[:binding|		(GLExtConstants bindingOf: binding key) ifNil:[			GLExtConstants addClassVarName: binding key.		].		code crtab; nextPutAll: binding key; nextPutAll: ' := '.		code print: binding value; nextPutAll: '.'.	].	GLExtConstants class compile: code contents classified: 'pool initialization'.! !!OGLExtManager class methodsFor: 'class initialization' stamp: 'ar 1/4/2003 00:00'!parseEXTConstants: list	"Take a list of strings comprising open gl constants, and answer them converted into suitable constant bindings. The elements of the list are expected to follow the semi-standardized rules found in most of the extensions documents, e.g., something like:		MAX_PALETTE_MATRICES_ARB	0x8842			=> GLMaxPaletteMatricesARB		GENERATE_MIPMAP_SGIS			0x8191			=> GLGenerateMipMapSGIS		ELEMENT_ARRAY_APPLE			0x8768			=> GLElementArrayAPPLE		PIXEL_COUNT_NV					0x8866			=> GLPixelCountNV	"	| parts constName constValue |	^list collect:[:string|		parts := string withBlanksTrimmed findTokens:			(String with: Character space with: Character tab).		constName := parts first.		constValue := parts last.		(constValue beginsWith: '0x') ifTrue:[			constValue := constValue copyFrom: 3 to: constValue size.			constValue := Integer readFrom: (ReadStream on: constValue) base: 16.		] ifFalse:[			constValue := Number readFrom: (ReadStream on: constValue).		].		parts := constName findTokens: '_'.		constName := String streamContents:[:s|			s nextPutAll: 'GL'.			parts allButLast do:[:str| 				s nextPut: str first asUppercase.				s nextPutAll: str allButFirst asLowercase.			].			s nextPutAll: parts last.		].		constName asSymbol -> constValue	].! !!OGLExtManager class methodsFor: 'instance creation' stamp: 'das 3/13/2004 14:50'!new	"To use OGLExtManager we must always create a new anonymous subclass"	| baseClass newClass |	self == OGLExtManager ifFalse:[self error: 'OGLExtManager: Cannot create instances of subclasses'].	baseClass := OGLExtManager. "hardcoded for a reason"	"Create a new anonymous subclass"	newClass := ClassBuilder new		newSubclassOf: baseClass		type: baseClass typeOfClass		instanceVariables: ''		from: nil.	baseClass addObsoleteSubclass: newClass.	newClass setName: '*', baseClass name.	^newClass basicNew! !!OGLFontManager methodsFor: 'displaying' stamp: 'ar 6/12/2002 04:56'!drawString: aString from: firstIndex to: lastIndex font: aFont	| sz glFontID |	glFontID := fonts at: aFont ifAbsentPut:[self uploadFont: aFont].	glx glListBase: glFontID.	sz := lastIndex - firstIndex + 1.	sz > charList size ifTrue:[charList := ByteArray new: sz].	charList replaceFrom: 1 to: sz with: aString startingAt: firstIndex.	glx glCallLists: sz with: GLByte with: charList! !!OGLFontManager methodsFor: 'displaying' stamp: 'ar 6/17/2002 00:08'!drawString: aString from: firstIndex to: lastIndex font: aFont align: aSymbol	| sz glFontID rect offset |	glFontID := fonts at: aFont ifAbsentPut:[self uploadFont: aFont].	glx glListBase: glFontID.	sz := lastIndex - firstIndex + 1.	aSymbol ifNotNil:[		rect := 0@0 extent: (aFont widthOfString: aString) @ aFont height.		offset := (rect perform: aSymbol).		glx glBitmap: 0 with: 0 with: 0 with: 0			with: 0 - offset x			with: offset y - aFont height			with: nil.	].	sz > charList size ifTrue:[charList := ByteArray new: sz].	charList replaceFrom: 1 to: sz with: aString startingAt: firstIndex.	glx glCallLists: sz with: GLByte with: charList! !!OGLFontManager methodsFor: 'displaying' stamp: 'ar 6/23/2002 23:27'!drawStringRect: rect align: aSymbol	| offset extent |	aSymbol ifNotNil:[		offset := (rect perform: aSymbol).		glx glBitmap: 0 with: 0 with: 0 with: 0			with: rect left - offset x			with: offset y - rect height			with: nil.	].	extent := rect extent.	glx glBitmap: extent x with: extent y with: 0 with: 0			with: extent x			with: extent y			with: ((Form extent: extent depth: 1) bits atAllPut: 16rFFFFFFFF).! !!OGLFontManager methodsFor: 'displaying' stamp: 'ar 6/23/2002 23:28'!frameStringRect: rect align: aSymbol	| offset form extent |	aSymbol ifNotNil:[		offset := (rect perform: aSymbol).		glx glBitmap: 0 with: 0 with: 0 with: 0			with: rect left - offset x			with: offset y - rect height			with: nil.	].	extent := rect extent.	form := (Form extent: extent depth: 1).	form getCanvas frameRectangle: form boundingBox width: 1 color: Color black.	form flipVertically.	form bits swapEndianness.	glx glBitmap: extent x with: extent y with: 0 with: 0			with: extent x			with: extent y			with: form bits.! !!OGLFontManager methodsFor: 'displaying' stamp: 'ar 6/23/2002 19:51'!uploadFont: aFont	| glFontID form |	glFontID := glx glGenLists: 256.	0 to: 255 do:[:i|		form := aFont characterFormAt: (i asCharacter).		form flipVertically.		form bits swapEndianness.		glx glNewList: glFontID+i with: GLCompile.		glx glBitmap: form width			with: form height			with: 0			with: 0			with: form width			with: 0			with: form bits.		glx glEndList.	].	^glFontID! !!OGLFontManager methodsFor: 'initialize' stamp: 'ar 6/12/2002 04:49'!initialize: glX	glx := glX.	fonts := IdentityDictionary new.	charList := ByteArray new: 256.! !!OGLTextureHandle methodsFor: 'accessing'!bytesUsed	^bytesUsed! !!OGLTextureHandle methodsFor: 'accessing'!bytesUsed: nBytes	bytesUsed := nBytes! !!OGLTextureHandle methodsFor: 'accessing'!glID	^glID! !!OGLTextureHandle methodsFor: 'accessing'!glID: aNumber	glID := aNumber! !!OGLTextureHandle methodsFor: 'accessing' stamp: 'ar 9/23/2002 23:20'!isAllocated	^allocated! !!OGLTextureHandle methodsFor: 'accessing' stamp: 'ar 9/23/2002 23:20'!isAllocated: aBool	allocated _ aBool! !!OGLTextureHandle methodsFor: 'accessing'!scaledSize	^scaledSize! !!OGLTextureHandle methodsFor: 'accessing'!scaledSize: aPoint	scaledSize := aPoint! !!OGLTextureHandle methodsFor: 'accessing' stamp: 'ar 9/23/2002 23:42'!target	^target! !!OGLTextureHandle methodsFor: 'accessing' stamp: 'ar 9/23/2002 23:42'!target: aNumber	target _ aNumber! !!OGLTextureHandle methodsFor: 'accessing' stamp: 'ar 10/1/2004 15:19'!timeStamp	^timeStamp! !!OGLTextureHandle methodsFor: 'accessing' stamp: 'ar 10/1/2004 15:19'!timeStamp: aStamp	timeStamp := aStamp! !!OGLTextureHandle methodsFor: 'printing' stamp: 'ar 10/1/2004 15:19'!printOn: aStream	super printOn: aStream.	aStream nextPutAll:'('; print: glID; nextPutAll:', '; print: scaledSize; nextPutAll:', '; print: timeStamp; nextPutAll:')'.! !!OGLTextureManager methodsFor: 'initialize'!beginFrame	memFrame := 0.! !!OGLTextureManager methodsFor: 'initialize' stamp: 'ar 10/1/2004 14:55'!cleanup	"clean up any lost references"	| any handle |	"first pass - clean up any unreferenced textures"	any := false.	textures associationsDo:[:assoc|		assoc key == nil ifTrue:[			handle := assoc value.			ogl glDeleteTextures: 1 with: (WordArray with: handle glID).			memUsed := memUsed - handle bytesUsed.			any := true].	].	any ifTrue:[textures finalizeValues].	"second pass - if we exceed maxMem of texture space clean up oldest (unused) textures"	self releaseTextureMemoryIfNeeded.! !!OGLTextureManager methodsFor: 'initialize' stamp: 'ar 4/9/2002 22:51'!endFrame	self cleanup."	'Max: ', memUsed asStringWithCommas displayAt: 0@0.	'Now: ', memFrame asStringWithCommas displayAt: 0@15.	Display forceToScreen: (0@0 extent: 100@30)."! !!OGLTextureManager methodsFor: 'initialize' stamp: 'ar 10/1/2004 14:55'!initialize: glX	ogl := glX.	textures := WeakIdentityKeyDictionary new.	memAvail := 16*1024*1024.	memUsed := 0.	memFrame := 0.! !!OGLTextureManager methodsFor: 'initialize' stamp: 'ar 10/1/2004 15:20'!releaseTextureMemoryIfNeeded	"Release some textures if we exceed a certain space usage"	| maxMem list texture |	true ifTrue:[^self]. "doesn't *quite* work yet"	"set upper memory bound"	maxMem := 32*1024*1024. "for testing - set this to zero to force uploads on every frame"	"Make sure we don't release anything if we needed it all in the current frame.	Leave a bit of headroom for sudden changes in direction too."	maxMem := maxMem max: memFrame + (4*1024*1024).	memUsed > maxMem ifFalse:[^self].	list := textures values asArray sort:[:h1 :h2| 		h1 timeStamp = h2 timeStamp			ifTrue:[h1 bytesUsed >= h2 bytesUsed]			ifFalse:[h1 timeStamp < h2 timeStamp].	].	list do:[:handle|		texture := textures keyAtIdentityValue: handle.		texture uploadRectangle: texture textureForm boundingBox.		textures removeKey: texture.		ogl glDeleteTextures: 1 with: (WordArray with: handle glID).		memUsed := memUsed - handle bytesUsed.		memUsed < maxMem ifTrue:[^self].	].! !!OGLTextureManager methodsFor: 'accessing' stamp: 'ar 10/1/2004 15:28'!bindTexture: aTexture	| handle |	handle := self textureHandleOf: aTexture.	handle timeStamp = ogl timeStamp ifFalse:[		handle timeStamp: ogl timeStamp.		memFrame := memFrame + handle bytesUsed.	].	ogl glBindTexture: aTexture target with: handle glID.! !!OGLTextureManager methodsFor: 'accessing' stamp: 'ar 10/1/2004 14:55'!deleteTexture: aTexture	| handle |	handle := textures removeKey: aTexture ifAbsent:[nil].	handle ifNotNil:[		ogl glDeleteTextures: 1 with: (WordArray with: handle).		memUsed := memUsed - handle bytesUsed.	].! !!OGLTextureManager methodsFor: 'accessing' stamp: 'ar 4/26/2003 01:42'!releaseTexture: aTexture	| binding |	binding := textures associationAt: aTexture ifAbsent:[^self].	binding key: nil. "clean up after frame completed"! !!OGLTextureManager methodsFor: 'accessing'!setTextureSizeOf: aTexture to: aPoint	| handle |	handle := self textureHandleOf: aTexture ifAbsent:[nil].	handle ifNil:[^nil]. "unknown"	^handle scaledSize: aPoint! !!OGLTextureManager methodsFor: 'accessing' stamp: 'ar 10/1/2004 15:20'!textureHandleOf: aTexture	| holder handle newMem |	^textures at: aTexture ifAbsentPut:[		aTexture invalidate: aTexture textureForm boundingBox.		holder := WordArray new: 1.		ogl glGenTextures: 1 with: holder.		handle := OGLTextureHandle new.		handle glID: (holder at: 1).		handle scaledSize: aTexture textureForm extent.		handle timeStamp: ogl timeStamp.		newMem := handle scaledSize area * 4.		aTexture bMipmap ifTrue:[newMem := newMem + (newMem // 3)].		handle bytesUsed: newMem.		memUsed := memUsed + newMem.		memFrame := memFrame + newMem.		handle].! !!OGLTextureManager methodsFor: 'accessing'!textureHandleOf: aTexture ifAbsent: aBlock	^textures at: aTexture ifAbsent: aBlock! !!OGLTextureManager methodsFor: 'accessing'!textureSizeOf: aTexture	| handle |	handle := self textureHandleOf: aTexture ifAbsent:[nil].	handle ifNil:[^nil]. "unknown"	^handle scaledSize! !!OGLTextureManager methodsFor: 'accessing' stamp: 'ar 10/1/2004 15:28'!uploadTexture: aTexture	| rect |	rect := aTexture updateRect ifNil:[^self]. "nothing to upload"	self uploadTexture: aTexture dirtyRect: rect.	aTexture resetUpdateRect.! !!OGLTextureManager methodsFor: 'accessing' stamp: 'ar 10/1/2004 15:20'!uploadTexture: aTexture dirtyRect: aRectangle	"TODO: Later only upload the dirty portion"	| handle form level scaledSize dirtyRect autoMip internalFormat byteSize |	autoMip := aTexture bMipmap and:[ogl autoMipmap].	handle := self textureHandleOf: aTexture.	handle timeStamp: ogl timeStamp.	form := aTexture textureForm.	form unhibernate.	dirtyRect := aRectangle.	aTexture isStatic ifTrue:[		"Static (possibly compressed) textures typically require complete uploads;		as they don't change often just upload everything."		dirtyRect := 0@0 extent: aTexture textureForm extent.	].	dirtyRect := dirtyRect intersect: form boundingBox.	ogl glBindTexture: aTexture target with: handle glID.	ogl glTexParameteri: GLTexture2d with: GLTextureMinFilter with: aTexture minFilter.	ogl glTexParameteri: GLTexture2d with: GLTextureMagFilter with: aTexture magFilter.	autoMip ifTrue:[ogl glTexParameteri: GLTexture2d with: GLGenerateMipmapSGIS with: true].	"TODO: This would be the right place to figure out what the initial size of the texture should be given that we're already low on texture memory."	scaledSize := handle scaledSize.	"specific optimization for morphic textures"	(dirtyRect extent ~= form extent "needed since first-time upload *must* use glTexImage2D"		and:[form depth = 32 "needed since we only upload 32bpp forms"		and:[scaledSize = form extent "needed since we don't scale here"		and:[autoMip or:[aTexture bMipmap not "only allow for non-mipmaps"]]]]) ifTrue:[			ogl glPixelStorei: GLUnpackRowLength with: form width.			ogl glPixelStorei: GLUnpackSkipRows with: dirtyRect top.			ogl glPixelStorei: GLUnpackSkipPixels with: dirtyRect left.			ogl glTexSubImage2D: aTexture target with: 0 				with: dirtyRect left with: dirtyRect top 				with: dirtyRect width with: dirtyRect height 				with: ogl texturePixelFormat with: ogl texturePixelType 				with: form bits.			ogl glPixelStorei: GLUnpackRowLength with: 0.			ogl glPixelStorei: GLUnpackSkipRows with: 0.			ogl glPixelStorei: GLUnpackSkipPixels with: 0.			^self].	level _ 0.	"figure out the internal format to use"	internalFormat := ogl textureInternalFormat.	aTexture isStatic ifTrue:[		(ogl hasExtension: #'GL_ARB_texture_compression') ifTrue:[			"internalFormat := ogl textureInternalFormatCompressed."		].		byteSize := 0.	].	[		form := self scaleTexture: form to: scaledSize.		ogl glTexImage2D: aTexture target 			with: level with: internalFormat 			with: form width with: form height 			with: 0 			with: ogl texturePixelFormat 			with: ogl texturePixelType 			with: form bits.		aTexture isStatic ifTrue:[			byteSize := byteSize + (self compressedSizeOf: aTexture at: level form: form).		].	autoMip not 		and:[aTexture bMipmap 		and:[scaledSize x > 1 or:[scaledSize y > 1]]]] whileTrue:[			scaledSize := (scaledSize // 2) max: (1@1).			level := level + 1.	].	aTexture isStatic ifTrue:[		memUsed := memUsed - handle bytesUsed.		memFrame := memFrame - handle bytesUsed.		handle bytesUsed: byteSize.		memUsed := memUsed + handle bytesUsed.		memFrame := memFrame + handle bytesUsed.	].! !!OGLTextureManager methodsFor: 'private' stamp: 'ar 10/1/2004 14:58'!compressedSizeOf: aTexture at: level form: aForm	(ogl glGetTexLevelParameteri: aTexture target		with: level		with: GLTextureCompressedARB) = 0 ifTrue:[			"texture was not compressed"			^aForm width * aForm height * 4.	].	^ogl glGetTexLevelParameteri: aTexture target		with: level		with: GLTextureCompressedImageSizeARB! !!OGLTextureManager methodsFor: 'private'!scaleTexture: form to: scaledSize	| mmForm |	form extent = scaledSize ifTrue:[^form].	mmForm := Form extent: scaledSize depth: 32.	(WarpBlt current toForm: mmForm)		sourceForm: form destRect: mmForm boundingBox;		combinationRule: 3;		cellSize: 2;		warpBits.	^mmForm! !!OGLTextureManager methodsFor: 'stats' stamp: 'ar 4/26/2003 01:38'!memFrame	^memFrame! !!OGLTextureManager methodsFor: 'stats' stamp: 'ar 4/26/2003 01:38'!memUsed	^memUsed! !!OGLTextureManager methodsFor: 'stats' stamp: 'ar 4/26/2003 01:38'!numTexturesBound	^0! !!OGLTextureManager methodsFor: 'stats' stamp: 'ar 4/26/2003 01:39'!numTexturesReused	^0! !!OGLTextureManager methodsFor: 'stats' stamp: 'ar 4/26/2003 01:38'!numTexturesUsed	^0! !!OpenGL methodsFor: 'accessing' stamp: 'ar 9/29/2004 15:12'!camera	^camera! !!OpenGL methodsFor: 'accessing' stamp: 'ar 9/29/2004 15:12'!camera: cam	camera _ cam.! !!OpenGL methodsFor: 'accessing'!changeTexture	^ changeTexture.! !!OpenGL methodsFor: 'accessing'!changeTexture: bool	changeTexture _ bool.! !!OpenGL methodsFor: 'accessing' stamp: 'das 6/30/2004 11:16'!closeDisplayList	openDisplayList_ nil.! !!OpenGL methodsFor: 'accessing'!currentPortal	^ currentPortal.! !!OpenGL methodsFor: 'accessing'!currentPortal: cp	currentPortal _ cp! !!OpenGL methodsFor: 'accessing' stamp: 'ar 6/30/2002 21:31'!extent	^bufRect extent! !!OpenGL methodsFor: 'accessing'!flipFace		frontFace = GLCcw ifTrue:[frontFace _ GLCw] ifFalse:[frontFace_ GLCcw].! !!OpenGL methodsFor: 'accessing' stamp: 'ar 6/23/2002 21:01'!fontManager	^fontManager! !!OpenGL methodsFor: 'accessing' stamp: 'das 8/12/2004 10:01'!forceWire	^ forceWire.! !!OpenGL methodsFor: 'accessing' stamp: 'das 8/12/2004 10:01'!forceWire: bool	forceWire _ bool.! !!OpenGL methodsFor: 'accessing'!frontFace		^ frontFace.! !!OpenGL methodsFor: 'accessing' stamp: 'ar 6/30/2002 23:39'!glGetBoolean: param	| value |	value := WordArray new: 1.	self glGetBooleanv: param with: value.	^(value at: 1) == GLTrue! !!OpenGL methodsFor: 'accessing' stamp: 'ar 6/30/2002 23:40'!glGetFloat: param	| value |	value := FloatArray new: 1.	self glGetFloatv: param with: value.	^value at: 1! !!OpenGL methodsFor: 'accessing' stamp: 'ar 6/30/2002 23:40'!glGetInteger: param	| value |	value := IntegerArray new: 1.	self glGetIntegerv: param with: value.	^value at: 1! !!OpenGL methodsFor: 'accessing' stamp: 'ar 4/26/2003 03:07'!glGetTexLevelParameterf: aTarget with: level with: param	| value |	value := FloatArray new: 1.	self glGetTexLevelParameterfv: aTarget with: level with: param with: value.	^value at: 1! !!OpenGL methodsFor: 'accessing' stamp: 'ar 4/26/2003 03:07'!glGetTexLevelParameteri: aTarget with: level with: param	| value |	value := IntegerArray new: 1.	self glGetTexLevelParameteriv: aTarget with: level with: param with: value.	^value at: 1! !!OpenGL methodsFor: 'accessing' stamp: 'ar 4/26/2003 04:30'!glGetTexParameterf: aTarget with: param	| value |	value := FloatArray new: 1.	self glGetTexParameterfv: aTarget with: param with: value.	^value at: 1! !!OpenGL methodsFor: 'accessing' stamp: 'ar 4/26/2003 04:31'!glGetTexParameteri: aTarget with: param	| value |	value := IntegerArray new: 1.	self glGetTexParameteriv: aTarget with: param with: value.	^value at: 1! !!OpenGL methodsFor: 'accessing' stamp: 'das 7/24/2003 14:39'!inPortal3D	^ inPortal3D.! !!OpenGL methodsFor: 'accessing' stamp: 'das 7/24/2003 14:40'!inPortal3D: bool	inPortal3D _ bool.! !!OpenGL methodsFor: 'accessing' stamp: 'das 4/1/2003 12:19'!isMirror	^ isMirror.! !!OpenGL methodsFor: 'accessing'!maxPortalDepth	^ maxPortalDepth.! !!OpenGL methodsFor: 'accessing'!maxPortalDepth: mpd	maxPortalDepth _ mpd.! !!OpenGL methodsFor: 'accessing' stamp: 'das 4/1/2003 12:20'!mirrorFlip	isMirror _ isMirror not.! !!OpenGL methodsFor: 'accessing' stamp: 'das 6/30/2004 11:16'!openDisplayList	^ openDisplayList.! !!OpenGL methodsFor: 'accessing' stamp: 'das 6/30/2004 11:15'!openDisplayList: odl	openDisplayList _ odl.! !!OpenGL methodsFor: 'accessing' stamp: 'ar 6/30/2002 21:32'!origin	^bufRect origin! !!OpenGL methodsFor: 'accessing' stamp: 'ar 6/21/2002 19:05'!screenShot	"Make a screen shot with the given extent"	^self screenShot: (0@0 extent: bufRect extent)! !!OpenGL methodsFor: 'accessing' stamp: 'das 9/24/2002 00:42'!screenShot: aRectangle	"Make a screen shot with the given extent"	| form |	form := Form extent: aRectangle extent depth: 32.	self glReadPixels: aRectangle left with: bufRect height - aRectangle bottom with: aRectangle width with: aRectangle height with: self imagePixelFormat32 with: self imagePixelType32 with: form bits.	form flipVertically.	^form! !!OpenGL methodsFor: 'accessing'!test		^ test.! !!OpenGL methodsFor: 'accessing'!test: bool		test _ bool.! !!OpenGL methodsFor: 'accessing' stamp: 'ar 10/1/2004 14:53'!textureManager	^textureManager! !!OpenGL methodsFor: 'accessing' stamp: 'das 6/29/2004 10:56'!timeStamp	^ timeStamp.! !!OpenGL methodsFor: 'accessing' stamp: 'das 6/29/2004 10:56'!timeStamp: ts	timeStamp _ ts.! !!OpenGL methodsFor: 'textures' stamp: 'ar 10/1/2004 14:50'!bindTexture: aTexture	changeTexture ifFalse:[^false].	textureManager bindTexture: aTexture.	^ true.! !!OpenGL methodsFor: 'textures' stamp: 'ar 10/1/2004 14:50'!deleteTexture: aTexture	textureManager deleteTexture: aTexture! !!OpenGL methodsFor: 'textures' stamp: 'das 10/18/2002 21:00'!disableTexture: aTexture	changeTexture ifFalse:[^false].	self glDisable: aTexture target.	^ true.! !!OpenGL methodsFor: 'textures' stamp: 'das 10/18/2002 21:00'!enableTexture: aTexture	changeTexture ifFalse:[^false].	self glEnable: aTexture target.	^ true.! !!OpenGL methodsFor: 'textures' stamp: 'ar 10/1/2004 14:51'!installTexture: aTexture	changeTexture ifFalse:[^false].	self bindTexture: aTexture.	textureManager uploadTexture: aTexture.	^ true.! !!OpenGL methodsFor: 'textures' stamp: 'ar 10/1/2004 14:51'!releaseTexture: aTexture	textureManager releaseTexture: aTexture.! !!OpenGL methodsFor: 'textures' stamp: 'ar 10/1/2004 14:52'!setTextureSizeOf: aTexture to: aPoint	^textureManager setTextureSizeOf: aTexture to: aPoint	! !!OpenGL methodsFor: 'textures' stamp: 'ar 4/26/2003 05:22'!textureInternalFormatCompressed	^GLCompressedRgbaARB! !!OpenGL methodsFor: 'textures' stamp: 'ar 10/1/2004 14:52'!textureSizeOf: aTexture	^textureManager textureSizeOf: aTexture! !!OpenGL methodsFor: 'project'!gluLookAtEyeX: eyex aEyeY: eyey aEyeZ: eyez aCenterX: centerx aCenterY: centery aCenterZ: centerz aUpX: upx aUpY: upy aUpZ: upz 	| forward up side m |	forward _ B3DVector3 x: centerx - eyex 						  y: centery - eyey						  z: centerz - eyez.	forward normalize.	up _ B3DVector3 x: upx y: upy z: upz.	side _ (forward cross: up) normalized.	up _ (side cross: forward) normalized.	m _ B3DMatrix4x4 identity.	m a11: side x.	m a21: side y.	m a31: side z.	m a12: up x.	m a22: up y.	m a32: up z.	m a13: forward x negated.	m a23: forward y negated.	m a33: forward z negated.	self glMultMatrixf m.	self glTranslated: eyex negated with: eyey  negated with: eyez negated."void GLAPIENTRYgluLookAt(GLdouble eyex, GLdouble eyey, GLdouble eyez, GLdouble centerx,	  GLdouble centery, GLdouble centerz, GLdouble upx, GLdouble upy,	  GLdouble upz){    	int i;    	float forward[3], 	side[3], up[3];    	GLfloat m[4][4];    	forward[0] = centerx - eyex;    	forward[1] = centery - eyey;    	forward[2] = centerz - eyez;    	up[0] = upx;    	up[1] = upy;    	up[2] = upz;    	normalize(forward);    /* Side = forward x up */    	cross(forward, up, side);    	normalize(side);    /* Recompute up as: up = side x forward */    	cross(side, forward, up);    	__gluMakeIdentityf(&m[0][0]);    	m[0][0] = side[0];    	m[1][0] = side[1];    	m[2][0] = side[2];    	m[0][1] = up[0];    	m[1][1] = up[1];    	m[2][1] = up[2];    	m[0][2] = -forward[0];    	m[1][2] = -forward[1];    	m[2][2] = -forward[2];    	glMultMatrixf(&m[0][0]);    	glTranslated(-eyex, -eyey, -eyez);}"! !!OpenGL methodsFor: 'project' stamp: 'das 8/26/2002 15:58'!gluPerspective: aFOVY aspect: aAspect zNear: aZNear zFar: aZFar| m sine cotangent deltaZ radians |m _ B3DMatrix4x4 identity.radians _ (aFOVY/2.0)*(Float pi/180.0).sine _ radians sin.deltaZ _ aZFar - aZNear.cotangent _ radians cos/sine.m a11: cotangent/aAspect.m a22: cotangent.m a33: ((aZFar + aZNear) negated)/deltaZ.m a34: -1.m a43: -2 * aZNear * aZFar / deltaZ.m a44: 0.self glMultMatrixf: m."void GLAPIENTRYgluPerspective(GLdouble fovy, GLdouble aspect, GLdouble zNear, GLdouble zFar){    	GLdouble m[4][4];    	double sine, cotangent, deltaZ;    	double radians = fovy / 2 * __glPi / 180;    	deltaZ = zFar - zNear;    	sine = sin(radians);    	if ((deltaZ == 0) || (sine == 0) || (aspect == 0)) 	{	return;    }    	cotangent = COS(radians) / sine;	__gluMakeIdentityd(&m[0][0]);    	m[0][0] = cotangent / aspect;    	m[1][1] = cotangent;    	m[2][2] = -(zFar + zNear) / deltaZ;    	m[2][3] = -1;    	m[3][2] = -2 * zNear * zFar / deltaZ;    	m[3][3] = 0;    	glMultMatrixd(&m[0][0]);}"! !!OpenGL methodsFor: 'testing' stamp: 'ar 1/3/2003 22:39'!autoMipmap	"Answer whether we support automatic mipmap generation"	^self extensions includes: #'GL_SGIS_generate_mipmap'! !!OpenGL methodsFor: 'testing'!maxIndices	|mxInd|	mxInd _ IntegerArray ofSize: 1.	self glGetIntegerv: GLMaxElementsIndices with: mxInd.	^ mxInd at: 1.! !!OpenGL methodsFor: 'testing'!maxVertices	|mxVrt|	mxVrt _ IntegerArray ofSize: 1.	self glGetIntegerv: GLMaxElementsVertices with: mxVrt.	^ mxVrt at: 1.! !!OpenGL methodsFor: 'Keyword API' stamp: 'ar 12/4/2003 20:58'!glAccum: op with: value	"This method was automatically generated."	"void glAccum(GLenum op, GLfloat value);"	<apicall: void 'glAccum' (ulong float) module: 'opengl32.dll'>	^self externalCallFailed! !!OpenGL methodsFor: 'Keyword API' stamp: 'ar 12/4/2003 20:58'!glActiveTextureARB: texture	"This method was automatically generated."	"void glActiveTextureARB(GLenum texture);"	<apicall: void 'glActiveTextureARB' (ulong) module: 'opengl32.dll'>	^self externalCallFailed! !!OpenGL methodsFor: 'Keyword API' stamp: 'ar 12/4/2003 20:58'!glAlphaFunc: func with: ref	"This method was automatically generated."	"void glAlphaFunc(GLenum func, GLclampf ref);"	<apicall: void 'glAlphaFunc' (ulong float) module: 'opengl32.dll'>	^self externalCallFailed! !!OpenGL methodsFor: 'Keyword API' stamp: 'ar 12/4/2003 20:58'!glAreTexturesResident: n with: textures with: residences	"This method was automatically generated."	"GLboolean glAreTexturesResident(GLsizei n, GLuint* textures, GLboolean* residences);"	<apicall: bool 'glAreTexturesResident' (long ulong* ulong*) module: 'opengl32.dll'>	^self externalCallFailed! !!OpenGL methodsFor: 'Keyword API' stamp: 'ar 12/4/2003 20:58'!glAreTexturesResidentEXT: n with: textures with: residences	"This method was automatically generated."	"GLboolean glAreTexturesResidentEXT(GLsizei n, GLuint* textures, GLboolean* residences);"	<apicall: bool 'glAreTexturesResidentEXT' (long ulong* ulong*) module: 'opengl32.dll'>	^self externalCallFailed! !!OpenGL methodsFor: 'Keyword API' stamp: 'ar 12/4/2003 20:58'!glArrayElement: i	"This method was automatically generated."	"void glArrayElement(GLint i);"	<apicall: void 'glArrayElement' (long) module: 'opengl32.dll'>	^self externalCallFailed! !!OpenGL methodsFor: 'Keyword API' stamp: 'ar 12/4/2003 20:58'!glArrayElementEXT: i	"This method was automatically generated."	"void glArrayElementEXT(GLint i);"	<apicall: void 'glArrayElementEXT' (long) module: 'opengl32.dll'>	^self externalCallFailed! !!OpenGL methodsFor: 'Keyword API' stamp: 'ar 12/4/2003 20:58'!glBindTexture: target with: texture	"This method was automatically generated."	"void glBindTexture(GLenum target, GLuint texture);"	<apicall: void 'glBindTexture' (ulong ulong) module: 'opengl32.dll'>	^self externalCallFailed! !!OpenGL methodsFor: 'Keyword API' stamp: 'ar 12/4/2003 20:58'!glBitmap: width with: height with: xorig with: yorig with: xmove with: ymove with: bitmap	"This method was automatically generated."	"void glBitmap(GLsizei width, GLsizei height, GLfloat xorig, GLfloat yorig, GLfloat xmove, GLfloat ymove, GLubyte* bitmap);"	<apicall: void 'glBitmap' (long long float float float float void*) module: 'opengl32.dll'>	^self externalCallFailed! !!OpenGL methodsFor: 'Keyword API' stamp: 'ar 12/4/2003 20:58'!glBlendColor: red with: green with: blue with: alpha	"This method was automatically generated."	"void glBlendColor(GLclampf red, GLclampf green, GLclampf blue, GLclampf alpha);"	<apicall: void 'glBlendColor' (float float float float) module: 'opengl32.dll'>	^self externalCallFailed! !!OpenGL methodsFor: 'Keyword API' stamp: 'ar 12/4/2003 20:58'!glBlendEquation: mode	"This method was automatically generated."	"void glBlendEquation(GLenum mode);"	<apicall: void 'glBlendEquation' (ulong) module: 'opengl32.dll'>	^self externalCallFailed! !!OpenGL methodsFor: 'Keyword API' stamp: 'ar 12/4/2003 20:58'!glBlendFunc: sfactor with: dfactor	"This method was automatically generated."	"void glBlendFunc(GLenum sfactor, GLenum dfactor);"	<apicall: void 'glBlendFunc' (ulong ulong) module: 'opengl32.dll'>	^self externalCallFailed! !!OpenGL methodsFor: 'Keyword API' stamp: 'ar 12/4/2003 20:58'!glCallList: list	"This method was automatically generated."	"void glCallList(GLuint list);"	<apicall: void 'glCallList' (ulong) module: 'opengl32.dll'>	^self externalCallFailed! !!OpenGL methodsFor: 'Keyword API' stamp: 'ar 12/4/2003 20:58'!glCallLists: n with: type with: lists	"This method was automatically generated."	"void glCallLists(GLsizei n, GLenum type, GLvoid* lists);"	<apicall: void 'glCallLists' (long ulong void*) module: 'opengl32.dll'>	^self externalCallFailed! !!OpenGL methodsFor: 'Keyword API' stamp: 'ar 12/4/2003 20:58'!glClear: mask	"This method was automatically generated."	"void glClear(GLbitfield mask);"	<apicall: void 'glClear' (ulong) module: 'opengl32.dll'>	^self externalCallFailed! !!OpenGL methodsFor: 'Keyword API' stamp: 'ar 12/4/2003 20:58'!glClearAccum: red with: green with: blue with: alpha	"This method was automatically generated."	"void glClearAccum(GLfloat red, GLfloat green, GLfloat blue, GLfloat alpha);"	<apicall: void 'glClearAccum' (float float float float) module: 'opengl32.dll'>	^self externalCallFailed! !!OpenGL methodsFor: 'Keyword API' stamp: 'ar 12/4/2003 20:58'!glClearColor: red with: green with: blue with: alpha	"This method was automatically generated."	"void glClearColor(GLclampf red, GLclampf green, GLclampf blue, GLclampf alpha);"	<apicall: void 'glClearColor' (float float float float) module: 'opengl32.dll'>	^self externalCallFailed! !!OpenGL methodsFor: 'Keyword API' stamp: 'ar 12/4/2003 20:58'!glClearDepth: depth	"This method was automatically generated."	"void glClearDepth(GLclampd depth);"	<apicall: void 'glClearDepth' (double) module: 'opengl32.dll'>	^self externalCallFailed! !!OpenGL methodsFor: 'Keyword API' stamp: 'ar 12/4/2003 20:58'!glClearIndex: c	"This method was automatically generated."	"void glClearIndex(GLfloat c);"	<apicall: void 'glClearIndex' (float) module: 'opengl32.dll'>	^self externalCallFailed! !!OpenGL methodsFor: 'Keyword API' stamp: 'ar 12/4/2003 20:58'!glClearStencil: s	"This method was automatically generated."	"void glClearStencil(GLint s);"	<apicall: void 'glClearStencil' (long) module: 'opengl32.dll'>	^self externalCallFailed! !!OpenGL methodsFor: 'Keyword API' stamp: 'ar 12/4/2003 20:58'!glClientActiveTextureARB: texture	"This method was automatically generated."	"void glClientActiveTextureARB(GLenum texture);"	<apicall: void 'glClientActiveTextureARB' (ulong) module: 'opengl32.dll'>	^self externalCallFailed! !!OpenGL methodsFor: 'Keyword API' stamp: 'ar 12/4/2003 20:58'!glClipPlane: plane with: equation	"This method was automatically generated."	"void glClipPlane(GLenum plane, GLdouble* equation);"	<apicall: void 'glClipPlane' (ulong double*) module: 'opengl32.dll'>	^self externalCallFailed! !!OpenGL methodsFor: 'Keyword API' stamp: 'ar 12/4/2003 20:58'!glColor3b: red with: green with: blue	"This method was automatically generated."	"void glColor3b(GLbyte red, GLbyte green, GLbyte blue);"	<apicall: void 'glColor3b' (byte byte byte) module: 'opengl32.dll'>	^self externalCallFailed! !!OpenGL methodsFor: 'Keyword API' stamp: 'ar 12/4/2003 20:58'!glColor3bv: v	"This method was automatically generated."	"void glColor3bv(GLbyte* v);"	<apicall: void 'glColor3bv' (byte*) module: 'opengl32.dll'>	^self externalCallFailed! !!OpenGL methodsFor: 'Keyword API' stamp: 'ar 12/4/2003 20:58'!glColor3d: red with: green with: blue	"This method was automatically generated."	"void glColor3d(GLdouble red, GLdouble green, GLdouble blue);"	<apicall: void 'glColor3d' (double double double) module: 'opengl32.dll'>	^self externalCallFailed! !!OpenGL methodsFor: 'Keyword API' stamp: 'ar 12/4/2003 20:58'!glColor3dv: v	"This method was automatically generated."	"void glColor3dv(GLdouble* v);"	<apicall: void 'glColor3dv' (double*) module: 'opengl32.dll'>	^self externalCallFailed! !!OpenGL methodsFor: 'Keyword API' stamp: 'ar 12/4/2003 20:58'!glColor3f: red with: green with: blue	"This method was automatically generated."	"void glColor3f(GLfloat red, GLfloat green, GLfloat blue);"	<apicall: void 'glColor3f' (float float float) module: 'opengl32.dll'>	^self externalCallFailed! !!OpenGL methodsFor: 'Keyword API' stamp: 'ar 12/4/2003 20:58'!glColor3fv: v	"This method was automatically generated."	"void glColor3fv(GLfloat* v);"	<apicall: void 'glColor3fv' (float*) module: 'opengl32.dll'>	^self externalCallFailed! !!OpenGL methodsFor: 'Keyword API' stamp: 'ar 12/4/2003 20:58'!glColor3i: red with: green with: blue	"This method was automatically generated."	"void glColor3i(GLint red, GLint green, GLint blue);"	<apicall: void 'glColor3i' (long long long) module: 'opengl32.dll'>	^self externalCallFailed! !!OpenGL methodsFor: 'Keyword API' stamp: 'ar 12/4/2003 20:58'!glColor3iv: v	"This method was automatically generated."	"void glColor3iv(GLint* v);"	<apicall: void 'glColor3iv' (long*) module: 'opengl32.dll'>	^self externalCallFailed! !!OpenGL methodsFor: 'Keyword API' stamp: 'ar 12/4/2003 20:58'!glColor3s: red with: green with: blue	"This method was automatically generated."	"void glColor3s(GLshort red, GLshort green, GLshort blue);"	<apicall: void 'glColor3s' (short short short) module: 'opengl32.dll'>	^self externalCallFailed! !!OpenGL methodsFor: 'Keyword API' stamp: 'ar 12/4/2003 20:58'!glColor3sv: v	"This method was automatically generated."	"void glColor3sv(GLshort* v);"	<apicall: void 'glColor3sv' (short*) module: 'opengl32.dll'>	^self externalCallFailed! !!OpenGL methodsFor: 'Keyword API' stamp: 'ar 12/4/2003 20:58'!glColor3ub: red with: green with: blue	"This method was automatically generated."	"void glColor3ub(GLubyte red, GLubyte green, GLubyte blue);"	<apicall: void 'glColor3ub' (byte byte byte) module: 'opengl32.dll'>	^self externalCallFailed! !!OpenGL methodsFor: 'Keyword API' stamp: 'ar 12/4/2003 20:58'!glColor3ubv: v	"This method was automatically generated."	"void glColor3ubv(GLubyte* v);"	<apicall: void 'glColor3ubv' (byte*) module: 'opengl32.dll'>	^self externalCallFailed! !!OpenGL methodsFor: 'Keyword API' stamp: 'ar 12/4/2003 20:58'!glColor3ui: red with: green with: blue	"This method was automatically generated."	"void glColor3ui(GLuint red, GLuint green, GLuint blue);"	<apicall: void 'glColor3ui' (ulong ulong ulong) module: 'opengl32.dll'>	^self externalCallFailed! !!OpenGL methodsFor: 'Keyword API' stamp: 'ar 12/4/2003 20:58'!glColor3uiv: v	"This method was automatically generated."	"void glColor3uiv(GLuint* v);"	<apicall: void 'glColor3uiv' (ulong*) module: 'opengl32.dll'>	^self externalCallFailed! !!OpenGL methodsFor: 'Keyword API' stamp: 'ar 12/4/2003 20:58'!glColor3us: red with: green with: blue	"This method was automatically generated."	"void glColor3us(GLushort red, GLushort green, GLushort blue);"	<apicall: void 'glColor3us' (ushort ushort ushort) module: 'opengl32.dll'>	^self externalCallFailed! !!OpenGL methodsFor: 'Keyword API' stamp: 'ar 12/4/2003 20:58'!glColor3usv: v	"This method was automatically generated."	"void glColor3usv(GLushort* v);"	<apicall: void 'glColor3usv' (ushort*) module: 'opengl32.dll'>	^self externalCallFailed! !!OpenGL methodsFor: 'Keyword API' stamp: 'ar 12/4/2003 20:58'!glColor4b: red with: green with: blue with: alpha	"This method was automatically generated."	"void glColor4b(GLbyte red, GLbyte green, GLbyte blue, GLbyte alpha);"	<apicall: void 'glColor4b' (byte byte byte byte) module: 'opengl32.dll'>	^self externalCallFailed! !!OpenGL methodsFor: 'Keyword API' stamp: 'ar 12/4/2003 20:58'!glColor4bv: v	"This method was automatically generated."	"void glColor4bv(GLbyte* v);"	<apicall: void 'glColor4bv' (byte*) module: 'opengl32.dll'>	^self externalCallFailed! !!OpenGL methodsFor: 'Keyword API' stamp: 'ar 12/4/2003 20:58'!glColor4d: red with: green with: blue with: alpha	"This method was automatically generated."	"void glColor4d(GLdouble red, GLdouble green, GLdouble blue, GLdouble alpha);"	<apicall: void 'glColor4d' (double double double double) module: 'opengl32.dll'>	^self externalCallFailed! !!OpenGL methodsFor: 'Keyword API' stamp: 'ar 12/4/2003 20:58'!glColor4dv: v	"This method was automatically generated."	"void glColor4dv(GLdouble* v);"	<apicall: void 'glColor4dv' (double*) module: 'opengl32.dll'>	^self externalCallFailed! !!OpenGL methodsFor: 'Keyword API' stamp: 'ar 12/4/2003 20:58'!glColor4f: red with: green with: blue with: alpha	"This method was automatically generated."	"void glColor4f(GLfloat red, GLfloat green, GLfloat blue, GLfloat alpha);"	<apicall: void 'glColor4f' (float float float float) module: 'opengl32.dll'>	^self externalCallFailed! !!OpenGL methodsFor: 'Keyword API' stamp: 'ar 12/4/2003 20:58'!glColor4fv: v	"This method was automatically generated."	"void glColor4fv(GLfloat* v);"	<apicall: void 'glColor4fv' (float*) module: 'opengl32.dll'>	^self externalCallFailed! !!OpenGL methodsFor: 'Keyword API' stamp: 'ar 12/4/2003 20:58'!glColor4i: red with: green with: blue with: alpha	"This method was automatically generated."	"void glColor4i(GLint red, GLint green, GLint blue, GLint alpha);"	<apicall: void 'glColor4i' (long long long long) module: 'opengl32.dll'>	^self externalCallFailed! !!OpenGL methodsFor: 'Keyword API' stamp: 'ar 12/4/2003 20:58'!glColor4iv: v	"This method was automatically generated."	"void glColor4iv(GLint* v);"	<apicall: void 'glColor4iv' (long*) module: 'opengl32.dll'>	^self externalCallFailed! !!OpenGL methodsFor: 'Keyword API' stamp: 'ar 12/4/2003 20:58'!glColor4s: red with: green with: blue with: alpha	"This method was automatically generated."	"void glColor4s(GLshort red, GLshort green, GLshort blue, GLshort alpha);"	<apicall: void 'glColor4s' (short short short short) module: 'opengl32.dll'>	^self externalCallFailed! !!OpenGL methodsFor: 'Keyword API' stamp: 'ar 12/4/2003 20:58'!glColor4sv: v	"This method was automatically generated."	"void glColor4sv(GLshort* v);"	<apicall: void 'glColor4sv' (short*) module: 'opengl32.dll'>	^self externalCallFailed! !!OpenGL methodsFor: 'Keyword API' stamp: 'ar 12/4/2003 20:58'!glColor4ub: red with: green with: blue with: alpha	"This method was automatically generated."	"void glColor4ub(GLubyte red, GLubyte green, GLubyte blue, GLubyte alpha);"	<apicall: void 'glColor4ub' (byte byte byte byte) module: 'opengl32.dll'>	^self externalCallFailed! !!OpenGL methodsFor: 'Keyword API' stamp: 'ar 12/4/2003 20:58'!glColor4ubv: v	"This method was automatically generated."	"void glColor4ubv(GLubyte* v);"	<apicall: void 'glColor4ubv' (byte*) module: 'opengl32.dll'>	^self externalCallFailed! !!OpenGL methodsFor: 'Keyword API' stamp: 'ar 12/4/2003 20:58'!glColor4ui: red with: green with: blue with: alpha	"This method was automatically generated."	"void glColor4ui(GLuint red, GLuint green, GLuint blue, GLuint alpha);"	<apicall: void 'glColor4ui' (ulong ulong ulong ulong) module: 'opengl32.dll'>	^self externalCallFailed! !!OpenGL methodsFor: 'Keyword API' stamp: 'ar 12/4/2003 20:58'!glColor4uiv: v	"This method was automatically generated."	"void glColor4uiv(GLuint* v);"	<apicall: void 'glColor4uiv' (ulong*) module: 'opengl32.dll'>	^self externalCallFailed! !!OpenGL methodsFor: 'Keyword API' stamp: 'ar 12/4/2003 20:58'!glColor4us: red with: green with: blue with: alpha	"This method was automatically generated."	"void glColor4us(GLushort red, GLushort green, GLushort blue, GLushort alpha);"	<apicall: void 'glColor4us' (ushort ushort ushort ushort) module: 'opengl32.dll'>	^self externalCallFailed! !!OpenGL methodsFor: 'Keyword API' stamp: 'ar 12/4/2003 20:58'!glColor4usv: v	"This method was automatically generated."	"void glColor4usv(GLushort* v);"	<apicall: void 'glColor4usv' (ushort*) module: 'opengl32.dll'>	^self externalCallFailed! !!OpenGL methodsFor: 'Keyword API' stamp: 'ar 12/4/2003 20:58'!glColorMask: red with: green with: blue with: alpha	"This method was automatically generated."	"void glColorMask(GLboolean red, GLboolean green, GLboolean blue, GLboolean alpha);"	<apicall: void 'glColorMask' (bool bool bool bool) module: 'opengl32.dll'>	^self externalCallFailed! !!OpenGL methodsFor: 'Keyword API' stamp: 'ar 12/4/2003 20:58'!glColorMaterial: face with: mode	"This method was automatically generated."	"void glColorMaterial(GLenum face, GLenum mode);"	<apicall: void 'glColorMaterial' (ulong ulong) module: 'opengl32.dll'>	^self externalCallFailed! !!OpenGL methodsFor: 'Keyword API' stamp: 'ar 12/4/2003 20:58'!glColorPointer: size with: type with: stride with: pointer	"This method was automatically generated."	"void glColorPointer(GLint size, GLenum type, GLsizei stride, GLvoid* pointer);"	<apicall: void 'glColorPointer' (long ulong long void*) module: 'opengl32.dll'>	^self externalCallFailed! !!OpenGL methodsFor: 'Keyword API' stamp: 'ar 12/4/2003 20:58'!glColorPointerEXT: size with: type with: stride with: count with: pointer	"This method was automatically generated."	"void glColorPointerEXT(GLint size, GLenum type, GLsizei stride, GLsizei count, GLvoid* pointer);"	<apicall: void 'glColorPointerEXT' (long ulong long long void*) module: 'opengl32.dll'>	^self externalCallFailed! !!OpenGL methodsFor: 'Keyword API' stamp: 'ar 12/4/2003 20:59'!glColorSubTable: target with: start with: count with: format with: type with: data	"This method was automatically generated."	"void glColorSubTable(GLenum target, GLsizei start, GLsizei count, GLenum format, GLenum type, GLvoid* data);"	<apicall: void 'glColorSubTable' (ulong long long ulong ulong void*) module: 'opengl32.dll'>	^self externalCallFailed! !!OpenGL methodsFor: 'Keyword API' stamp: 'ar 12/4/2003 20:59'!glColorTable: target with: internalformat with: width with: format with: type with: table	"This method was automatically generated."	"void glColorTable(GLenum target, GLenum internalformat, GLsizei width, GLenum format, GLenum type, GLvoid* table);"	<apicall: void 'glColorTable' (ulong ulong long ulong ulong void*) module: 'opengl32.dll'>	^self externalCallFailed! !!OpenGL methodsFor: 'Keyword API' stamp: 'ar 12/4/2003 20:59'!glColorTableParameterfv: target with: pname with: params	"This method was automatically generated."	"void glColorTableParameterfv(GLenum target, GLenum pname, GLfloat* params);"	<apicall: void 'glColorTableParameterfv' (ulong ulong float*) module: 'opengl32.dll'>	^self externalCallFailed! !!OpenGL methodsFor: 'Keyword API' stamp: 'ar 12/4/2003 20:59'!glColorTableParameteriv: target with: pname with: params	"This method was automatically generated."	"void glColorTableParameteriv(GLenum target, GLenum pname, GLint* params);"	<apicall: void 'glColorTableParameteriv' (ulong ulong long*) module: 'opengl32.dll'>	^self externalCallFailed! !!OpenGL methodsFor: 'Keyword API' stamp: 'ar 12/4/2003 20:59'!glConvolutionFilter1D: target with: internalformat with: width with: format with: type with: image	"This method was automatically generated."	"void glConvolutionFilter1D(GLenum target, GLenum internalformat, GLsizei width, GLenum format, GLenum type, GLvoid* image);"	<apicall: void 'glConvolutionFilter1D' (ulong ulong long ulong ulong void*) module: 'opengl32.dll'>	^self externalCallFailed! !!OpenGL methodsFor: 'Keyword API' stamp: 'ar 12/4/2003 20:59'!glConvolutionFilter2D: target with: internalformat with: width with: height with: format with: type with: image	"This method was automatically generated."	"void glConvolutionFilter2D(GLenum target, GLenum internalformat, GLsizei width, GLsizei height, GLenum format, GLenum type, GLvoid* image);"	<apicall: void 'glConvolutionFilter2D' (ulong ulong long long ulong ulong void*) module: 'opengl32.dll'>	^self externalCallFailed! !!OpenGL methodsFor: 'Keyword API' stamp: 'ar 12/4/2003 20:59'!glConvolutionParameterf: target with: pname with: params	"This method was automatically generated."	"void glConvolutionParameterf(GLenum target, GLenum pname, GLfloat params);"	<apicall: void 'glConvolutionParameterf' (ulong ulong float) module: 'opengl32.dll'>	^self externalCallFailed! !!OpenGL methodsFor: 'Keyword API' stamp: 'ar 12/4/2003 20:59'!glConvolutionParameterfv: target with: pname with: params	"This method was automatically generated."	"void glConvolutionParameterfv(GLenum target, GLenum pname, GLfloat* params);"	<apicall: void 'glConvolutionParameterfv' (ulong ulong float*) module: 'opengl32.dll'>	^self externalCallFailed! !!OpenGL methodsFor: 'Keyword API' stamp: 'ar 12/4/2003 20:59'!glConvolutionParameteri: target with: pname with: params	"This method was automatically generated."	"void glConvolutionParameteri(GLenum target, GLenum pname, GLint params);"	<apicall: void 'glConvolutionParameteri' (ulong ulong long) module: 'opengl32.dll'>	^self externalCallFailed! !!OpenGL methodsFor: 'Keyword API' stamp: 'ar 12/4/2003 20:59'!glConvolutionParameteriv: target with: pname with: params	"This method was automatically generated."	"void glConvolutionParameteriv(GLenum target, GLenum pname, GLint* params);"	<apicall: void 'glConvolutionParameteriv' (ulong ulong long*) module: 'opengl32.dll'>	^self externalCallFailed! !!OpenGL methodsFor: 'Keyword API' stamp: 'ar 12/4/2003 20:59'!glCopyColorSubTable: target with: start with: x with: y with: width	"This method was automatically generated."	"void glCopyColorSubTable(GLenum target, GLsizei start, GLint x, GLint y, GLsizei width);"	<apicall: void 'glCopyColorSubTable' (ulong long long long long) module: 'opengl32.dll'>	^self externalCallFailed! !!OpenGL methodsFor: 'Keyword API' stamp: 'ar 12/4/2003 20:59'!glCopyColorTable: target with: internalformat with: x with: y with: width	"This method was automatically generated."	"void glCopyColorTable(GLenum target, GLenum internalformat, GLint x, GLint y, GLsizei width);"	<apicall: void 'glCopyColorTable' (ulong ulong long long long) module: 'opengl32.dll'>	^self externalCallFailed! !!OpenGL methodsFor: 'Keyword API' stamp: 'ar 12/4/2003 20:59'!glCopyConvolutionFilter1D: target with: internalformat with: x with: y with: width	"This method was automatically generated."	"void glCopyConvolutionFilter1D(GLenum target, GLenum internalformat, GLint x, GLint y, GLsizei width);"	<apicall: void 'glCopyConvolutionFilter1D' (ulong ulong long long long) module: 'opengl32.dll'>	^self externalCallFailed! !!OpenGL methodsFor: 'Keyword API' stamp: 'ar 12/4/2003 20:59'!glCopyConvolutionFilter2D: target with: internalformat with: x with: y with: width with: height	"This method was automatically generated."	"void glCopyConvolutionFilter2D(GLenum target, GLenum internalformat, GLint x, GLint y, GLsizei width, GLsizei height);"	<apicall: void 'glCopyConvolutionFilter2D' (ulong ulong long long long long) module: 'opengl32.dll'>	^self externalCallFailed! !!OpenGL methodsFor: 'Keyword API' stamp: 'ar 12/4/2003 20:59'!glCopyPixels: x with: y with: width with: height with: type	"This method was automatically generated."	"void glCopyPixels(GLint x, GLint y, GLsizei width, GLsizei height, GLenum type);"	<apicall: void 'glCopyPixels' (long long long long ulong) module: 'opengl32.dll'>	^self externalCallFailed! !!OpenGL methodsFor: 'Keyword API' stamp: 'ar 12/4/2003 20:59'!glCopyTexImage1D: target with: level with: internalformat with: x with: y with: width with: border	"This method was automatically generated."	"void glCopyTexImage1D(GLenum target, GLint level, GLenum internalformat, GLint x, GLint y, GLsizei width, GLint border);"	<apicall: void 'glCopyTexImage1D' (ulong long ulong long long long long) module: 'opengl32.dll'>	^self externalCallFailed! !!OpenGL methodsFor: 'Keyword API' stamp: 'ar 12/4/2003 20:59'!glCopyTexImage2D: target with: level with: internalformat with: x with: y with: width with: height with: border	"This method was automatically generated."	"void glCopyTexImage2D(GLenum target, GLint level, GLenum internalformat, GLint x, GLint y, GLsizei width, GLsizei height, GLint border);"	<apicall: void 'glCopyTexImage2D' (ulong long ulong long long long long long) module: 'opengl32.dll'>	^self externalCallFailed! !!OpenGL methodsFor: 'Keyword API' stamp: 'ar 12/4/2003 20:59'!glCopyTexSubImage1D: target with: level with: xoffset with: x with: y with: width	"This method was automatically generated."	"void glCopyTexSubImage1D(GLenum target, GLint level, GLint xoffset, GLint x, GLint y, GLsizei width);"	<apicall: void 'glCopyTexSubImage1D' (ulong long long long long long) module: 'opengl32.dll'>	^self externalCallFailed! !!OpenGL methodsFor: 'Keyword API' stamp: 'ar 12/4/2003 20:59'!glCopyTexSubImage2D: target with: level with: xoffset with: yoffset with: x with: y with: width with: height	"This method was automatically generated."	"void glCopyTexSubImage2D(GLenum target, GLint level, GLint xoffset, GLint yoffset, GLint x, GLint y, GLsizei width, GLsizei height);"	<apicall: void 'glCopyTexSubImage2D' (ulong long long long long long long long) module: 'opengl32.dll'>	^self externalCallFailed! !!OpenGL methodsFor: 'Keyword API' stamp: 'ar 12/4/2003 20:59'!glCopyTexSubImage3D: target with: level with: xoffset with: yoffset with: zoffset with: x with: y with: width with: height	"This method was automatically generated."	"void glCopyTexSubImage3D(GLenum target, GLint level, GLint xoffset, GLint yoffset, GLint zoffset, GLint x, GLint y, GLsizei width, GLsizei height);"	<apicall: void 'glCopyTexSubImage3D' (ulong long long long long long long long long) module: 'opengl32.dll'>	^self externalCallFailed! !!OpenGL methodsFor: 'Keyword API' stamp: 'ar 12/4/2003 20:59'!glCullFace: mode	"This method was automatically generated."	"void glCullFace(GLenum mode);"	<apicall: void 'glCullFace' (ulong) module: 'opengl32.dll'>	^self externalCallFailed! !!OpenGL methodsFor: 'Keyword API' stamp: 'ar 12/4/2003 20:59'!glDeleteLists: list with: range	"This method was automatically generated."	"void glDeleteLists(GLuint list, GLsizei range);"	<apicall: void 'glDeleteLists' (ulong long) module: 'opengl32.dll'>	^self externalCallFailed! !!OpenGL methodsFor: 'Keyword API' stamp: 'ar 12/4/2003 20:59'!glDeleteTextures: n with: textures	"This method was automatically generated."	"void glDeleteTextures(GLsizei n, GLuint* textures);"	<apicall: void 'glDeleteTextures' (long ulong*) module: 'opengl32.dll'>	^self externalCallFailed! !!OpenGL methodsFor: 'Keyword API' stamp: 'ar 12/4/2003 20:59'!glDeleteTexturesEXT: n with: textures	"This method was automatically generated."	"void glDeleteTexturesEXT(GLsizei n, GLuint* textures);"	<apicall: void 'glDeleteTexturesEXT' (long ulong*) module: 'opengl32.dll'>	^self externalCallFailed! !!OpenGL methodsFor: 'Keyword API' stamp: 'ar 12/4/2003 20:59'!glDepthFunc: func	"This method was automatically generated."	"void glDepthFunc(GLenum func);"	<apicall: void 'glDepthFunc' (ulong) module: 'opengl32.dll'>	^self externalCallFailed! !!OpenGL methodsFor: 'Keyword API' stamp: 'ar 12/4/2003 20:59'!glDepthMask: flag	"This method was automatically generated."	"void glDepthMask(GLboolean flag);"	<apicall: void 'glDepthMask' (bool) module: 'opengl32.dll'>	^self externalCallFailed! !!OpenGL methodsFor: 'Keyword API' stamp: 'ar 12/4/2003 20:59'!glDepthRange: zNear with: zFar	"This method was automatically generated."	"void glDepthRange(GLclampd zNear, GLclampd zFar);"	<apicall: void 'glDepthRange' (double double) module: 'opengl32.dll'>	^self externalCallFailed! !!OpenGL methodsFor: 'Keyword API' stamp: 'ar 12/4/2003 20:59'!glDisable: cap	"This method was automatically generated."	"void glDisable(GLenum cap);"	<apicall: void 'glDisable' (ulong) module: 'opengl32.dll'>	^self externalCallFailed! !!OpenGL methodsFor: 'Keyword API' stamp: 'ar 12/4/2003 20:59'!glDisableClientState: array	"This method was automatically generated."	"void glDisableClientState(GLenum array);"	<apicall: void 'glDisableClientState' (ulong) module: 'opengl32.dll'>	^self externalCallFailed! !!OpenGL methodsFor: 'Keyword API' stamp: 'ar 12/4/2003 20:59'!glDrawArrays: mode with: first with: count	"This method was automatically generated."	"void glDrawArrays(GLenum mode, GLint first, GLsizei count);"	<apicall: void 'glDrawArrays' (ulong long long) module: 'opengl32.dll'>	^self externalCallFailed! !!OpenGL methodsFor: 'Keyword API' stamp: 'ar 12/4/2003 20:59'!glDrawArraysEXT: mode with: first with: count	"This method was automatically generated."	"void glDrawArraysEXT(GLenum mode, GLint first, GLsizei count);"	<apicall: void 'glDrawArraysEXT' (ulong long long) module: 'opengl32.dll'>	^self externalCallFailed! !!OpenGL methodsFor: 'Keyword API' stamp: 'ar 12/4/2003 20:59'!glDrawBuffer: mode	"This method was automatically generated."	"void glDrawBuffer(GLenum mode);"	<apicall: void 'glDrawBuffer' (ulong) module: 'opengl32.dll'>	^self externalCallFailed! !!OpenGL methodsFor: 'Keyword API' stamp: 'ar 12/4/2003 20:59'!glDrawElements: mode with: count with: type with: indices	"This method was automatically generated."	"void glDrawElements(GLenum mode, GLsizei count, GLenum type, GLvoid* indices);"	<apicall: void 'glDrawElements' (ulong long ulong void*) module: 'opengl32.dll'>	^self externalCallFailed! !!OpenGL methodsFor: 'Keyword API' stamp: 'ar 12/4/2003 20:59'!glDrawPixels: width with: height with: format with: type with: pixels	"This method was automatically generated."	"void glDrawPixels(GLsizei width, GLsizei height, GLenum format, GLenum type, GLvoid* pixels);"	<apicall: void 'glDrawPixels' (long long ulong ulong void*) module: 'opengl32.dll'>	^self externalCallFailed! !!OpenGL methodsFor: 'Keyword API' stamp: 'ar 12/4/2003 20:59'!glDrawRangeElements: mode with: start with: end with: count with: type with: indices	"This method was automatically generated."	"void glDrawRangeElements(GLenum mode, GLuint start, GLuint end, GLsizei count, GLenum type, GLvoid* indices);"	<apicall: void 'glDrawRangeElements' (ulong ulong ulong long ulong void*) module: 'opengl32.dll'>	^self externalCallFailed! !!OpenGL methodsFor: 'Keyword API' stamp: 'ar 12/4/2003 20:59'!glEdgeFlag: flag	"This method was automatically generated."	"void glEdgeFlag(GLboolean flag);"	<apicall: void 'glEdgeFlag' (bool) module: 'opengl32.dll'>	^self externalCallFailed! !!OpenGL methodsFor: 'Keyword API' stamp: 'ar 12/4/2003 20:59'!glEdgeFlagPointer: stride with: pointer	"This method was automatically generated."	"void glEdgeFlagPointer(GLsizei stride, GLboolean* pointer);"	<apicall: void 'glEdgeFlagPointer' (long ulong*) module: 'opengl32.dll'>	^self externalCallFailed! !!OpenGL methodsFor: 'Keyword API' stamp: 'ar 12/4/2003 20:59'!glEdgeFlagPointerEXT: stride with: count with: pointer	"This method was automatically generated."	"void glEdgeFlagPointerEXT(GLsizei stride, GLsizei count, GLboolean* pointer);"	<apicall: void 'glEdgeFlagPointerEXT' (long long ulong*) module: 'opengl32.dll'>	^self externalCallFailed! !!OpenGL methodsFor: 'Keyword API' stamp: 'ar 12/4/2003 20:59'!glEdgeFlagv: flag	"This method was automatically generated."	"void glEdgeFlagv(GLboolean* flag);"	<apicall: void 'glEdgeFlagv' (ulong*) module: 'opengl32.dll'>	^self externalCallFailed! !!OpenGL methodsFor: 'Keyword API' stamp: 'ar 12/4/2003 20:59'!glEnable: cap	"This method was automatically generated."	"void glEnable(GLenum cap);"	<apicall: void 'glEnable' (ulong) module: 'opengl32.dll'>	^self externalCallFailed! !!OpenGL methodsFor: 'Keyword API' stamp: 'ar 12/4/2003 20:59'!glEnableClientState: array	"This method was automatically generated."	"void glEnableClientState(GLenum array);"	<apicall: void 'glEnableClientState' (ulong) module: 'opengl32.dll'>	^self externalCallFailed! !!OpenGL methodsFor: 'Keyword API' stamp: 'ar 12/4/2003 20:59'!glEnd	"This method was automatically generated."	"void glEnd();"	<apicall: void 'glEnd' (void) module: 'opengl32.dll'>	^self externalCallFailed! !!OpenGL methodsFor: 'Keyword API' stamp: 'ar 12/4/2003 20:59'!glEndList	"This method was automatically generated."	"void glEndList();"	<apicall: void 'glEndList' (void) module: 'opengl32.dll'>	^self externalCallFailed! !!OpenGL methodsFor: 'Keyword API' stamp: 'ar 12/4/2003 20:59'!glEvalCoord1d: u	"This method was automatically generated."	"void glEvalCoord1d(GLdouble u);"	<apicall: void 'glEvalCoord1d' (double) module: 'opengl32.dll'>	^self externalCallFailed! !!OpenGL methodsFor: 'Keyword API' stamp: 'ar 12/4/2003 20:59'!glEvalCoord1dv: u	"This method was automatically generated."	"void glEvalCoord1dv(GLdouble* u);"	<apicall: void 'glEvalCoord1dv' (double*) module: 'opengl32.dll'>	^self externalCallFailed! !!OpenGL methodsFor: 'Keyword API' stamp: 'ar 12/4/2003 20:59'!glEvalCoord1f: u	"This method was automatically generated."	"void glEvalCoord1f(GLfloat u);"	<apicall: void 'glEvalCoord1f' (float) module: 'opengl32.dll'>	^self externalCallFailed! !!OpenGL methodsFor: 'Keyword API' stamp: 'ar 12/4/2003 20:59'!glEvalCoord1fv: u	"This method was automatically generated."	"void glEvalCoord1fv(GLfloat* u);"	<apicall: void 'glEvalCoord1fv' (float*) module: 'opengl32.dll'>	^self externalCallFailed! !!OpenGL methodsFor: 'Keyword API' stamp: 'ar 12/4/2003 20:59'!glEvalCoord2d: u with: v	"This method was automatically generated."	"void glEvalCoord2d(GLdouble u, GLdouble v);"	<apicall: void 'glEvalCoord2d' (double double) module: 'opengl32.dll'>	^self externalCallFailed! !!OpenGL methodsFor: 'Keyword API' stamp: 'ar 12/4/2003 20:59'!glEvalCoord2dv: u	"This method was automatically generated."	"void glEvalCoord2dv(GLdouble* u);"	<apicall: void 'glEvalCoord2dv' (double*) module: 'opengl32.dll'>	^self externalCallFailed! !!OpenGL methodsFor: 'Keyword API' stamp: 'ar 12/4/2003 20:59'!glEvalCoord2f: u with: v	"This method was automatically generated."	"void glEvalCoord2f(GLfloat u, GLfloat v);"	<apicall: void 'glEvalCoord2f' (float float) module: 'opengl32.dll'>	^self externalCallFailed! !!OpenGL methodsFor: 'Keyword API' stamp: 'ar 12/4/2003 20:59'!glEvalCoord2fv: u	"This method was automatically generated."	"void glEvalCoord2fv(GLfloat* u);"	<apicall: void 'glEvalCoord2fv' (float*) module: 'opengl32.dll'>	^self externalCallFailed! !!OpenGL methodsFor: 'Keyword API' stamp: 'ar 12/4/2003 20:59'!glEvalMesh1: mode with: i1 with: i2	"This method was automatically generated."	"void glEvalMesh1(GLenum mode, GLint i1, GLint i2);"	<apicall: void 'glEvalMesh1' (ulong long long) module: 'opengl32.dll'>	^self externalCallFailed! !!OpenGL methodsFor: 'Keyword API' stamp: 'ar 12/4/2003 20:59'!glEvalMesh2: mode with: i1 with: i2 with: j1 with: j2	"This method was automatically generated."	"void glEvalMesh2(GLenum mode, GLint i1, GLint i2, GLint j1, GLint j2);"	<apicall: void 'glEvalMesh2' (ulong long long long long) module: 'opengl32.dll'>	^self externalCallFailed! !!OpenGL methodsFor: 'Keyword API' stamp: 'ar 12/4/2003 20:59'!glEvalPoint1: i	"This method was automatically generated."	"void glEvalPoint1(GLint i);"	<apicall: void 'glEvalPoint1' (long) module: 'opengl32.dll'>	^self externalCallFailed! !!OpenGL methodsFor: 'Keyword API' stamp: 'ar 12/4/2003 20:59'!glEvalPoint2: i with: j	"This method was automatically generated."	"void glEvalPoint2(GLint i, GLint j);"	<apicall: void 'glEvalPoint2' (long long) module: 'opengl32.dll'>	^self externalCallFailed! !!OpenGL methodsFor: 'Keyword API' stamp: 'ar 12/4/2003 20:59'!glFeedbackBuffer: size with: type with: buffer	"This method was automatically generated."	"void glFeedbackBuffer(GLsizei size, GLenum type, GLfloat* buffer);"	<apicall: void 'glFeedbackBuffer' (long ulong float*) module: 'opengl32.dll'>	^self externalCallFailed! !!OpenGL methodsFor: 'Keyword API' stamp: 'ar 12/4/2003 20:59'!glFinish	"This method was automatically generated."	"void glFinish();"	<apicall: void 'glFinish' (void) module: 'opengl32.dll'>	^self externalCallFailed! !!OpenGL methodsFor: 'Keyword API' stamp: 'ar 12/4/2003 20:59'!glFlush	"This method was automatically generated."	"void glFlush();"	<apicall: void 'glFlush' (void) module: 'opengl32.dll'>	^self externalCallFailed! !!OpenGL methodsFor: 'Keyword API' stamp: 'ar 12/4/2003 20:59'!glFogf: pname with: param	"This method was automatically generated."	"void glFogf(GLenum pname, GLfloat param);"	<apicall: void 'glFogf' (ulong float) module: 'opengl32.dll'>	^self externalCallFailed! !!OpenGL methodsFor: 'Keyword API' stamp: 'ar 12/4/2003 20:59'!glFogfv: pname with: params	"This method was automatically generated."	"void glFogfv(GLenum pname, GLfloat* params);"	<apicall: void 'glFogfv' (ulong float*) module: 'opengl32.dll'>	^self externalCallFailed! !!OpenGL methodsFor: 'Keyword API' stamp: 'ar 12/4/2003 20:59'!glFogi: pname with: param	"This method was automatically generated."	"void glFogi(GLenum pname, GLint param);"	<apicall: void 'glFogi' (ulong long) module: 'opengl32.dll'>	^self externalCallFailed! !!OpenGL methodsFor: 'Keyword API' stamp: 'ar 12/4/2003 20:59'!glFogiv: pname with: params	"This method was automatically generated."	"void glFogiv(GLenum pname, GLint* params);"	<apicall: void 'glFogiv' (ulong long*) module: 'opengl32.dll'>	^self externalCallFailed! !!OpenGL methodsFor: 'Keyword API' stamp: 'ar 12/4/2003 20:59'!glFrontFace: mode	"This method was automatically generated."	"void glFrontFace(GLenum mode);"	<apicall: void 'glFrontFace' (ulong) module: 'opengl32.dll'>	^self externalCallFailed! !!OpenGL methodsFor: 'Keyword API' stamp: 'ar 12/4/2003 20:59'!glFrustum: left with: right with: bottom with: top with: zNear with: zFar	"This method was automatically generated."	"void glFrustum(GLdouble left, GLdouble right, GLdouble bottom, GLdouble top, GLdouble zNear, GLdouble zFar);"	<apicall: void 'glFrustum' (double double double double double double) module: 'opengl32.dll'>	^self externalCallFailed! !!OpenGL methodsFor: 'Keyword API' stamp: 'ar 12/4/2003 20:59'!glGenLists: range	"This method was automatically generated."	"GLuint glGenLists(GLsizei range);"	<apicall: ulong 'glGenLists' (long) module: 'opengl32.dll'>	^self externalCallFailed! !!OpenGL methodsFor: 'Keyword API' stamp: 'ar 12/4/2003 20:59'!glGenTextures: n with: textures	"This method was automatically generated."	"void glGenTextures(GLsizei n, GLuint* textures);"	<apicall: void 'glGenTextures' (long ulong*) module: 'opengl32.dll'>	^self externalCallFailed! !!OpenGL methodsFor: 'Keyword API' stamp: 'ar 12/4/2003 20:59'!glGenTexturesEXT: n with: textures	"This method was automatically generated."	"void glGenTexturesEXT(GLsizei n, GLuint* textures);"	<apicall: void 'glGenTexturesEXT' (long ulong*) module: 'opengl32.dll'>	^self externalCallFailed! !!OpenGL methodsFor: 'Keyword API' stamp: 'ar 12/4/2003 20:59'!glGetBooleanv: pname with: params	"This method was automatically generated."	"void glGetBooleanv(GLenum pname, GLboolean* params);"	<apicall: void 'glGetBooleanv' (ulong ulong*) module: 'opengl32.dll'>	^self externalCallFailed! !!OpenGL methodsFor: 'Keyword API' stamp: 'ar 12/4/2003 20:59'!glGetClipPlane: plane with: equation	"This method was automatically generated."	"void glGetClipPlane(GLenum plane, GLdouble* equation);"	<apicall: void 'glGetClipPlane' (ulong double*) module: 'opengl32.dll'>	^self externalCallFailed! !!OpenGL methodsFor: 'Keyword API' stamp: 'ar 12/4/2003 20:59'!glGetColorTable: target with: format with: type with: table	"This method was automatically generated."	"void glGetColorTable(GLenum target, GLenum format, GLenum type, GLvoid* table);"	<apicall: void 'glGetColorTable' (ulong ulong ulong void*) module: 'opengl32.dll'>	^self externalCallFailed! !!OpenGL methodsFor: 'Keyword API' stamp: 'ar 12/4/2003 20:59'!glGetColorTableParameterfv: target with: pname with: params	"This method was automatically generated."	"void glGetColorTableParameterfv(GLenum target, GLenum pname, GLfloat* params);"	<apicall: void 'glGetColorTableParameterfv' (ulong ulong float*) module: 'opengl32.dll'>	^self externalCallFailed! !!OpenGL methodsFor: 'Keyword API' stamp: 'ar 12/4/2003 20:59'!glGetColorTableParameteriv: target with: pname with: params	"This method was automatically generated."	"void glGetColorTableParameteriv(GLenum target, GLenum pname, GLint* params);"	<apicall: void 'glGetColorTableParameteriv' (ulong ulong long*) module: 'opengl32.dll'>	^self externalCallFailed! !!OpenGL methodsFor: 'Keyword API' stamp: 'ar 12/4/2003 20:59'!glGetConvolutionFilter: target with: format with: type with: image	"This method was automatically generated."	"void glGetConvolutionFilter(GLenum target, GLenum format, GLenum type, GLvoid* image);"	<apicall: void 'glGetConvolutionFilter' (ulong ulong ulong void*) module: 'opengl32.dll'>	^self externalCallFailed! !!OpenGL methodsFor: 'Keyword API' stamp: 'ar 12/4/2003 20:59'!glGetConvolutionParameterfv: target with: pname with: params	"This method was automatically generated."	"void glGetConvolutionParameterfv(GLenum target, GLenum pname, GLfloat* params);"	<apicall: void 'glGetConvolutionParameterfv' (ulong ulong float*) module: 'opengl32.dll'>	^self externalCallFailed! !!OpenGL methodsFor: 'Keyword API' stamp: 'ar 12/4/2003 20:59'!glGetConvolutionParameteriv: target with: pname with: params	"This method was automatically generated."	"void glGetConvolutionParameteriv(GLenum target, GLenum pname, GLint* params);"	<apicall: void 'glGetConvolutionParameteriv' (ulong ulong long*) module: 'opengl32.dll'>	^self externalCallFailed! !!OpenGL methodsFor: 'Keyword API' stamp: 'ar 12/4/2003 20:59'!glGetDoublev: pname with: params	"This method was automatically generated."	"void glGetDoublev(GLenum pname, GLdouble* params);"	<apicall: void 'glGetDoublev' (ulong double*) module: 'opengl32.dll'>	^self externalCallFailed! !!OpenGL methodsFor: 'Keyword API' stamp: 'ar 12/4/2003 20:59'!glGetError	"This method was automatically generated."	"GLenum glGetError();"	<apicall: ulong 'glGetError' (void) module: 'opengl32.dll'>	^self externalCallFailed! !!OpenGL methodsFor: 'Keyword API' stamp: 'ar 12/4/2003 20:59'!glGetFloatv: pname with: params	"This method was automatically generated."	"void glGetFloatv(GLenum pname, GLfloat* params);"	<apicall: void 'glGetFloatv' (ulong float*) module: 'opengl32.dll'>	^self externalCallFailed! !!OpenGL methodsFor: 'Keyword API' stamp: 'ar 12/4/2003 20:59'!glGetHistogram: target with: reset with: format with: type with: values	"This method was automatically generated."	"void glGetHistogram(GLenum target, GLboolean reset, GLenum format, GLenum type, GLvoid* values);"	<apicall: void 'glGetHistogram' (ulong bool ulong ulong void*) module: 'opengl32.dll'>	^self externalCallFailed! !!OpenGL methodsFor: 'Keyword API' stamp: 'ar 12/4/2003 20:59'!glGetHistogramParameterfv: target with: pname with: params	"This method was automatically generated."	"void glGetHistogramParameterfv(GLenum target, GLenum pname, GLfloat* params);"	<apicall: void 'glGetHistogramParameterfv' (ulong ulong float*) module: 'opengl32.dll'>	^self externalCallFailed! !!OpenGL methodsFor: 'Keyword API' stamp: 'ar 12/4/2003 20:59'!glGetHistogramParameteriv: target with: pname with: params	"This method was automatically generated."	"void glGetHistogramParameteriv(GLenum target, GLenum pname, GLint* params);"	<apicall: void 'glGetHistogramParameteriv' (ulong ulong long*) module: 'opengl32.dll'>	^self externalCallFailed! !!OpenGL methodsFor: 'Keyword API' stamp: 'ar 12/4/2003 20:59'!glGetIntegerv: pname with: params	"This method was automatically generated."	"void glGetIntegerv(GLenum pname, GLint* params);"	<apicall: void 'glGetIntegerv' (ulong long*) module: 'opengl32.dll'>	^self externalCallFailed! !!OpenGL methodsFor: 'Keyword API' stamp: 'ar 12/4/2003 20:59'!glGetLightfv: light with: pname with: params	"This method was automatically generated."	"void glGetLightfv(GLenum light, GLenum pname, GLfloat* params);"	<apicall: void 'glGetLightfv' (ulong ulong float*) module: 'opengl32.dll'>	^self externalCallFailed! !!OpenGL methodsFor: 'Keyword API' stamp: 'ar 12/4/2003 20:59'!glGetLightiv: light with: pname with: params	"This method was automatically generated."	"void glGetLightiv(GLenum light, GLenum pname, GLint* params);"	<apicall: void 'glGetLightiv' (ulong ulong long*) module: 'opengl32.dll'>	^self externalCallFailed! !!OpenGL methodsFor: 'Keyword API' stamp: 'ar 12/4/2003 20:59'!glGetMapdv: target with: query with: v	"This method was automatically generated."	"void glGetMapdv(GLenum target, GLenum query, GLdouble* v);"	<apicall: void 'glGetMapdv' (ulong ulong double*) module: 'opengl32.dll'>	^self externalCallFailed! !!OpenGL methodsFor: 'Keyword API' stamp: 'ar 12/4/2003 20:59'!glGetMapfv: target with: query with: v	"This method was automatically generated."	"void glGetMapfv(GLenum target, GLenum query, GLfloat* v);"	<apicall: void 'glGetMapfv' (ulong ulong float*) module: 'opengl32.dll'>	^self externalCallFailed! !!OpenGL methodsFor: 'Keyword API' stamp: 'ar 12/4/2003 20:59'!glGetMapiv: target with: query with: v	"This method was automatically generated."	"void glGetMapiv(GLenum target, GLenum query, GLint* v);"	<apicall: void 'glGetMapiv' (ulong ulong long*) module: 'opengl32.dll'>	^self externalCallFailed! !!OpenGL methodsFor: 'Keyword API' stamp: 'ar 12/4/2003 20:59'!glGetMaterialfv: face with: pname with: params	"This method was automatically generated."	"void glGetMaterialfv(GLenum face, GLenum pname, GLfloat* params);"	<apicall: void 'glGetMaterialfv' (ulong ulong float*) module: 'opengl32.dll'>	^self externalCallFailed! !!OpenGL methodsFor: 'Keyword API' stamp: 'ar 12/4/2003 20:59'!glGetMaterialiv: face with: pname with: params	"This method was automatically generated."	"void glGetMaterialiv(GLenum face, GLenum pname, GLint* params);"	<apicall: void 'glGetMaterialiv' (ulong ulong long*) module: 'opengl32.dll'>	^self externalCallFailed! !!OpenGL methodsFor: 'Keyword API' stamp: 'ar 12/4/2003 20:59'!glGetMinmax: target with: reset with: format with: type with: values	"This method was automatically generated."	"void glGetMinmax(GLenum target, GLboolean reset, GLenum format, GLenum type, GLvoid* values);"	<apicall: void 'glGetMinmax' (ulong bool ulong ulong void*) module: 'opengl32.dll'>	^self externalCallFailed! !!OpenGL methodsFor: 'Keyword API' stamp: 'ar 12/4/2003 20:59'!glGetMinmaxParameterfv: target with: pname with: params	"This method was automatically generated."	"void glGetMinmaxParameterfv(GLenum target, GLenum pname, GLfloat* params);"	<apicall: void 'glGetMinmaxParameterfv' (ulong ulong float*) module: 'opengl32.dll'>	^self externalCallFailed! !!OpenGL methodsFor: 'Keyword API' stamp: 'ar 12/4/2003 20:59'!glGetMinmaxParameteriv: target with: pname with: params	"This method was automatically generated."	"void glGetMinmaxParameteriv(GLenum target, GLenum pname, GLint* params);"	<apicall: void 'glGetMinmaxParameteriv' (ulong ulong long*) module: 'opengl32.dll'>	^self externalCallFailed! !!OpenGL methodsFor: 'Keyword API' stamp: 'ar 12/4/2003 20:59'!glGetPixelMapfv: map with: values	"This method was automatically generated."	"void glGetPixelMapfv(GLenum map, GLfloat* values);"	<apicall: void 'glGetPixelMapfv' (ulong float*) module: 'opengl32.dll'>	^self externalCallFailed! !!OpenGL methodsFor: 'Keyword API' stamp: 'ar 12/4/2003 20:59'!glGetPixelMapuiv: map with: values	"This method was automatically generated."	"void glGetPixelMapuiv(GLenum map, GLuint* values);"	<apicall: void 'glGetPixelMapuiv' (ulong ulong*) module: 'opengl32.dll'>	^self externalCallFailed! !!OpenGL methodsFor: 'Keyword API' stamp: 'ar 12/4/2003 20:59'!glGetPixelMapusv: map with: values	"This method was automatically generated."	"void glGetPixelMapusv(GLenum map, GLushort* values);"	<apicall: void 'glGetPixelMapusv' (ulong ushort*) module: 'opengl32.dll'>	^self externalCallFailed! !!OpenGL methodsFor: 'Keyword API' stamp: 'ar 12/4/2003 20:59'!glGetPointerv: pname with: params	"This method was automatically generated."	"void glGetPointerv(GLenum pname, GLvoid** params);"	<apicall: void 'glGetPointerv' (ulong void*) module: 'opengl32.dll'>	^self externalCallFailed! !!OpenGL methodsFor: 'Keyword API' stamp: 'ar 12/4/2003 20:59'!glGetPointervEXT: pname with: params	"This method was automatically generated."	"void glGetPointervEXT(GLenum pname, GLvoid** params);"	<apicall: void 'glGetPointervEXT' (ulong void*) module: 'opengl32.dll'>	^self externalCallFailed! !!OpenGL methodsFor: 'Keyword API' stamp: 'ar 12/4/2003 20:59'!glGetPolygonStipple: mask	"This method was automatically generated."	"void glGetPolygonStipple(GLubyte* mask);"	<apicall: void 'glGetPolygonStipple' (byte*) module: 'opengl32.dll'>	^self externalCallFailed! !!OpenGL methodsFor: 'Keyword API' stamp: 'ar 12/4/2003 20:59'!glGetSeparableFilter: target with: format with: type with: row with: column with: span	"This method was automatically generated."	"void glGetSeparableFilter(GLenum target, GLenum format, GLenum type, GLvoid* row, GLvoid* column, GLvoid* span);"	<apicall: void 'glGetSeparableFilter' (ulong ulong ulong void* void* void*) module: 'opengl32.dll'>	^self externalCallFailed! !!OpenGL methodsFor: 'Keyword API' stamp: 'ar 12/4/2003 20:59'!glGetString: name	"This method was automatically generated."	"GLubyte* glGetString(GLenum name);"	<apicall: byte* 'glGetString' (ulong) module: 'opengl32.dll'>	^self externalCallFailed! !!OpenGL methodsFor: 'Keyword API' stamp: 'ar 12/4/2003 20:59'!glGetTexEnvfv: target with: pname with: params	"This method was automatically generated."	"void glGetTexEnvfv(GLenum target, GLenum pname, GLfloat* params);"	<apicall: void 'glGetTexEnvfv' (ulong ulong float*) module: 'opengl32.dll'>	^self externalCallFailed! !!OpenGL methodsFor: 'Keyword API' stamp: 'ar 12/4/2003 20:59'!glGetTexEnviv: target with: pname with: params	"This method was automatically generated."	"void glGetTexEnviv(GLenum target, GLenum pname, GLint* params);"	<apicall: void 'glGetTexEnviv' (ulong ulong long*) module: 'opengl32.dll'>	^self externalCallFailed! !!OpenGL methodsFor: 'Keyword API' stamp: 'ar 12/4/2003 20:59'!glGetTexGendv: coord with: pname with: params	"This method was automatically generated."	"void glGetTexGendv(GLenum coord, GLenum pname, GLdouble* params);"	<apicall: void 'glGetTexGendv' (ulong ulong double*) module: 'opengl32.dll'>	^self externalCallFailed! !!OpenGL methodsFor: 'Keyword API' stamp: 'ar 12/4/2003 20:59'!glGetTexGenfv: coord with: pname with: params	"This method was automatically generated."	"void glGetTexGenfv(GLenum coord, GLenum pname, GLfloat* params);"	<apicall: void 'glGetTexGenfv' (ulong ulong float*) module: 'opengl32.dll'>	^self externalCallFailed! !!OpenGL methodsFor: 'Keyword API' stamp: 'ar 12/4/2003 20:59'!glGetTexGeniv: coord with: pname with: params	"This method was automatically generated."	"void glGetTexGeniv(GLenum coord, GLenum pname, GLint* params);"	<apicall: void 'glGetTexGeniv' (ulong ulong long*) module: 'opengl32.dll'>	^self externalCallFailed! !!OpenGL methodsFor: 'Keyword API' stamp: 'ar 12/4/2003 20:59'!glGetTexImage: target with: level with: format with: type with: pixels	"This method was automatically generated."	"void glGetTexImage(GLenum target, GLint level, GLenum format, GLenum type, GLvoid* pixels);"	<apicall: void 'glGetTexImage' (ulong long ulong ulong void*) module: 'opengl32.dll'>	^self externalCallFailed! !!OpenGL methodsFor: 'Keyword API' stamp: 'ar 12/4/2003 20:59'!glGetTexLevelParameterfv: target with: level with: pname with: params	"This method was automatically generated."	"void glGetTexLevelParameterfv(GLenum target, GLint level, GLenum pname, GLfloat* params);"	<apicall: void 'glGetTexLevelParameterfv' (ulong long ulong float*) module: 'opengl32.dll'>	^self externalCallFailed! !!OpenGL methodsFor: 'Keyword API' stamp: 'ar 12/4/2003 20:59'!glGetTexLevelParameteriv: target with: level with: pname with: params	"This method was automatically generated."	"void glGetTexLevelParameteriv(GLenum target, GLint level, GLenum pname, GLint* params);"	<apicall: void 'glGetTexLevelParameteriv' (ulong long ulong long*) module: 'opengl32.dll'>	^self externalCallFailed! !!OpenGL methodsFor: 'Keyword API' stamp: 'ar 12/4/2003 20:59'!glGetTexParameterfv: target with: pname with: params	"This method was automatically generated."	"void glGetTexParameterfv(GLenum target, GLenum pname, GLfloat* params);"	<apicall: void 'glGetTexParameterfv' (ulong ulong float*) module: 'opengl32.dll'>	^self externalCallFailed! !!OpenGL methodsFor: 'Keyword API' stamp: 'ar 12/4/2003 20:59'!glGetTexParameteriv: target with: pname with: params	"This method was automatically generated."	"void glGetTexParameteriv(GLenum target, GLenum pname, GLint* params);"	<apicall: void 'glGetTexParameteriv' (ulong ulong long*) module: 'opengl32.dll'>	^self externalCallFailed! !!OpenGL methodsFor: 'Keyword API' stamp: 'ar 12/4/2003 20:59'!glHint: target with: mode	"This method was automatically generated."	"void glHint(GLenum target, GLenum mode);"	<apicall: void 'glHint' (ulong ulong) module: 'opengl32.dll'>	^self externalCallFailed! !!OpenGL methodsFor: 'Keyword API' stamp: 'ar 12/4/2003 20:59'!glHistogram: target with: width with: internalformat with: sink	"This method was automatically generated."	"void glHistogram(GLenum target, GLsizei width, GLenum internalformat, GLboolean sink);"	<apicall: void 'glHistogram' (ulong long ulong bool) module: 'opengl32.dll'>	^self externalCallFailed! !!OpenGL methodsFor: 'Keyword API' stamp: 'ar 12/4/2003 20:59'!glIndexMask: mask	"This method was automatically generated."	"void glIndexMask(GLuint mask);"	<apicall: void 'glIndexMask' (ulong) module: 'opengl32.dll'>	^self externalCallFailed! !!OpenGL methodsFor: 'Keyword API' stamp: 'ar 12/4/2003 20:59'!glIndexPointer: type with: stride with: pointer	"This method was automatically generated."	"void glIndexPointer(GLenum type, GLsizei stride, GLvoid* pointer);"	<apicall: void 'glIndexPointer' (ulong long void*) module: 'opengl32.dll'>	^self externalCallFailed! !!OpenGL methodsFor: 'Keyword API' stamp: 'ar 12/4/2003 20:59'!glIndexPointerEXT: type with: stride with: count with: pointer	"This method was automatically generated."	"void glIndexPointerEXT(GLenum type, GLsizei stride, GLsizei count, GLvoid* pointer);"	<apicall: void 'glIndexPointerEXT' (ulong long long void*) module: 'opengl32.dll'>	^self externalCallFailed! !!OpenGL methodsFor: 'Keyword API' stamp: 'ar 12/4/2003 20:59'!glIndexd: c	"This method was automatically generated."	"void glIndexd(GLdouble c);"	<apicall: void 'glIndexd' (double) module: 'opengl32.dll'>	^self externalCallFailed! !!OpenGL methodsFor: 'Keyword API' stamp: 'ar 12/4/2003 20:59'!glIndexdv: c	"This method was automatically generated."	"void glIndexdv(GLdouble* c);"	<apicall: void 'glIndexdv' (double*) module: 'opengl32.dll'>	^self externalCallFailed! !!OpenGL methodsFor: 'Keyword API' stamp: 'ar 12/4/2003 20:59'!glIndexf: c	"This method was automatically generated."	"void glIndexf(GLfloat c);"	<apicall: void 'glIndexf' (float) module: 'opengl32.dll'>	^self externalCallFailed! !!OpenGL methodsFor: 'Keyword API' stamp: 'ar 12/4/2003 20:59'!glIndexfv: c	"This method was automatically generated."	"void glIndexfv(GLfloat* c);"	<apicall: void 'glIndexfv' (float*) module: 'opengl32.dll'>	^self externalCallFailed! !!OpenGL methodsFor: 'Keyword API' stamp: 'ar 12/4/2003 20:59'!glIndexi: c	"This method was automatically generated."	"void glIndexi(GLint c);"	<apicall: void 'glIndexi' (long) module: 'opengl32.dll'>	^self externalCallFailed! !!OpenGL methodsFor: 'Keyword API' stamp: 'ar 12/4/2003 20:59'!glIndexiv: c	"This method was automatically generated."	"void glIndexiv(GLint* c);"	<apicall: void 'glIndexiv' (long*) module: 'opengl32.dll'>	^self externalCallFailed! !!OpenGL methodsFor: 'Keyword API' stamp: 'ar 12/4/2003 20:59'!glIndexs: c	"This method was automatically generated."	"void glIndexs(GLshort c);"	<apicall: void 'glIndexs' (short) module: 'opengl32.dll'>	^self externalCallFailed! !!OpenGL methodsFor: 'Keyword API' stamp: 'ar 12/4/2003 20:59'!glIndexsv: c	"This method was automatically generated."	"void glIndexsv(GLshort* c);"	<apicall: void 'glIndexsv' (short*) module: 'opengl32.dll'>	^self externalCallFailed! !!OpenGL methodsFor: 'Keyword API' stamp: 'ar 12/4/2003 20:59'!glIndexub: c	"This method was automatically generated."	"void glIndexub(GLubyte c);"	<apicall: void 'glIndexub' (byte) module: 'opengl32.dll'>	^self externalCallFailed! !!OpenGL methodsFor: 'Keyword API' stamp: 'ar 12/4/2003 20:59'!glIndexubv: c	"This method was automatically generated."	"void glIndexubv(GLubyte* c);"	<apicall: void 'glIndexubv' (byte*) module: 'opengl32.dll'>	^self externalCallFailed! !!OpenGL methodsFor: 'Keyword API' stamp: 'ar 12/4/2003 20:59'!glInitNames	"This method was automatically generated."	"void glInitNames();"	<apicall: void 'glInitNames' (void) module: 'opengl32.dll'>	^self externalCallFailed! !!OpenGL methodsFor: 'Keyword API' stamp: 'ar 12/4/2003 20:59'!glInterleavedArrays: format with: stride with: pointer	"This method was automatically generated."	"void glInterleavedArrays(GLenum format, GLsizei stride, GLvoid* pointer);"	<apicall: void 'glInterleavedArrays' (ulong long void*) module: 'opengl32.dll'>	^self externalCallFailed! !!OpenGL methodsFor: 'Keyword API' stamp: 'ar 12/4/2003 20:59'!glIsEnabled: cap	"This method was automatically generated."	"GLboolean glIsEnabled(GLenum cap);"	<apicall: bool 'glIsEnabled' (ulong) module: 'opengl32.dll'>	^self externalCallFailed! !!OpenGL methodsFor: 'Keyword API' stamp: 'ar 12/4/2003 20:59'!glIsList: list	"This method was automatically generated."	"GLboolean glIsList(GLuint list);"	<apicall: bool 'glIsList' (ulong) module: 'opengl32.dll'>	^self externalCallFailed! !!OpenGL methodsFor: 'Keyword API' stamp: 'ar 12/4/2003 20:59'!glIsTexture: texture	"This method was automatically generated."	"GLboolean glIsTexture(GLuint texture);"	<apicall: bool 'glIsTexture' (ulong) module: 'opengl32.dll'>	^self externalCallFailed! !!OpenGL methodsFor: 'Keyword API' stamp: 'ar 12/4/2003 20:59'!glIsTextureEXT: texture	"This method was automatically generated."	"GLboolean glIsTextureEXT(GLuint texture);"	<apicall: bool 'glIsTextureEXT' (ulong) module: 'opengl32.dll'>	^self externalCallFailed! !!OpenGL methodsFor: 'Keyword API' stamp: 'ar 12/4/2003 20:59'!glLightModelf: pname with: param	"This method was automatically generated."	"void glLightModelf(GLenum pname, GLfloat param);"	<apicall: void 'glLightModelf' (ulong float) module: 'opengl32.dll'>	^self externalCallFailed! !!OpenGL methodsFor: 'Keyword API' stamp: 'ar 12/4/2003 20:59'!glLightModelfv: pname with: params	"This method was automatically generated."	"void glLightModelfv(GLenum pname, GLfloat* params);"	<apicall: void 'glLightModelfv' (ulong float*) module: 'opengl32.dll'>	^self externalCallFailed! !!OpenGL methodsFor: 'Keyword API' stamp: 'ar 12/4/2003 20:59'!glLightModeli: pname with: param	"This method was automatically generated."	"void glLightModeli(GLenum pname, GLint param);"	<apicall: void 'glLightModeli' (ulong long) module: 'opengl32.dll'>	^self externalCallFailed! !!OpenGL methodsFor: 'Keyword API' stamp: 'ar 12/4/2003 20:59'!glLightModeliv: pname with: params	"This method was automatically generated."	"void glLightModeliv(GLenum pname, GLint* params);"	<apicall: void 'glLightModeliv' (ulong long*) module: 'opengl32.dll'>	^self externalCallFailed! !!OpenGL methodsFor: 'Keyword API' stamp: 'ar 12/4/2003 20:59'!glLightf: light with: pname with: param	"This method was automatically generated."	"void glLightf(GLenum light, GLenum pname, GLfloat param);"	<apicall: void 'glLightf' (ulong ulong float) module: 'opengl32.dll'>	^self externalCallFailed! !!OpenGL methodsFor: 'Keyword API' stamp: 'ar 12/4/2003 20:59'!glLightfv: light with: pname with: params	"This method was automatically generated."	"void glLightfv(GLenum light, GLenum pname, GLfloat* params);"	<apicall: void 'glLightfv' (ulong ulong float*) module: 'opengl32.dll'>	^self externalCallFailed! !!OpenGL methodsFor: 'Keyword API' stamp: 'ar 12/4/2003 20:59'!glLighti: light with: pname with: param	"This method was automatically generated."	"void glLighti(GLenum light, GLenum pname, GLint param);"	<apicall: void 'glLighti' (ulong ulong long) module: 'opengl32.dll'>	^self externalCallFailed! !!OpenGL methodsFor: 'Keyword API' stamp: 'ar 12/4/2003 20:59'!glLightiv: light with: pname with: params	"This method was automatically generated."	"void glLightiv(GLenum light, GLenum pname, GLint* params);"	<apicall: void 'glLightiv' (ulong ulong long*) module: 'opengl32.dll'>	^self externalCallFailed! !!OpenGL methodsFor: 'Keyword API' stamp: 'ar 12/4/2003 20:59'!glLineStipple: factor with: pattern	"This method was automatically generated."	"void glLineStipple(GLint factor, GLushort pattern);"	<apicall: void 'glLineStipple' (long ushort) module: 'opengl32.dll'>	^self externalCallFailed! !!OpenGL methodsFor: 'Keyword API' stamp: 'ar 12/4/2003 20:59'!glLineWidth: width	"This method was automatically generated."	"void glLineWidth(GLfloat width);"	<apicall: void 'glLineWidth' (float) module: 'opengl32.dll'>	^self externalCallFailed! !!OpenGL methodsFor: 'Keyword API' stamp: 'ar 12/4/2003 20:59'!glListBase: base	"This method was automatically generated."	"void glListBase(GLuint base);"	<apicall: void 'glListBase' (ulong) module: 'opengl32.dll'>	^self externalCallFailed! !!OpenGL methodsFor: 'Keyword API' stamp: 'ar 12/4/2003 20:59'!glLoadIdentity	"This method was automatically generated."	"void glLoadIdentity();"	<apicall: void 'glLoadIdentity' (void) module: 'opengl32.dll'>	^self externalCallFailed! !!OpenGL methodsFor: 'Keyword API' stamp: 'ar 12/4/2003 20:59'!glLoadMatrixd: m	"This method was automatically generated."	"void glLoadMatrixd(GLdouble* m);"	<apicall: void 'glLoadMatrixd' (double*) module: 'opengl32.dll'>	^self externalCallFailed! !!OpenGL methodsFor: 'Keyword API' stamp: 'ar 12/4/2003 20:59'!glLoadMatrixf: m	"This method was automatically generated."	"void glLoadMatrixf(GLfloat* m);"	<apicall: void 'glLoadMatrixf' (float*) module: 'opengl32.dll'>	^self externalCallFailed! !!OpenGL methodsFor: 'Keyword API' stamp: 'ar 12/4/2003 20:59'!glLoadName: name	"This method was automatically generated."	"void glLoadName(GLuint name);"	<apicall: void 'glLoadName' (ulong) module: 'opengl32.dll'>	^self externalCallFailed! !!OpenGL methodsFor: 'Keyword API' stamp: 'ar 12/4/2003 20:59'!glLogicOp: opcode	"This method was automatically generated."	"void glLogicOp(GLenum opcode);"	<apicall: void 'glLogicOp' (ulong) module: 'opengl32.dll'>	^self externalCallFailed! !!OpenGL methodsFor: 'Keyword API' stamp: 'ar 12/4/2003 20:59'!glMap1d: target with: u1 with: u2 with: stride with: order with: points	"This method was automatically generated."	"void glMap1d(GLenum target, GLdouble u1, GLdouble u2, GLint stride, GLint order, GLdouble* points);"	<apicall: void 'glMap1d' (ulong double double long long double*) module: 'opengl32.dll'>	^self externalCallFailed! !!OpenGL methodsFor: 'Keyword API' stamp: 'ar 12/4/2003 20:59'!glMap1f: target with: u1 with: u2 with: stride with: order with: points	"This method was automatically generated."	"void glMap1f(GLenum target, GLfloat u1, GLfloat u2, GLint stride, GLint order, GLfloat* points);"	<apicall: void 'glMap1f' (ulong float float long long float*) module: 'opengl32.dll'>	^self externalCallFailed! !!OpenGL methodsFor: 'Keyword API' stamp: 'ar 12/4/2003 20:59'!glMap2d: target with: u1 with: u2 with: ustride with: uorder with: v1 with: v2 with: vstride with: vorder with: points	"This method was automatically generated."	"void glMap2d(GLenum target, GLdouble u1, GLdouble u2, GLint ustride, GLint uorder, GLdouble v1, GLdouble v2, GLint vstride, GLint vorder, GLdouble* points);"	<apicall: void 'glMap2d' (ulong double double long long double double long long double*) module: 'opengl32.dll'>	^self externalCallFailed! !!OpenGL methodsFor: 'Keyword API' stamp: 'ar 12/4/2003 20:59'!glMap2f: target with: u1 with: u2 with: ustride with: uorder with: v1 with: v2 with: vstride with: vorder with: points	"This method was automatically generated."	"void glMap2f(GLenum target, GLfloat u1, GLfloat u2, GLint ustride, GLint uorder, GLfloat v1, GLfloat v2, GLint vstride, GLint vorder, GLfloat* points);"	<apicall: void 'glMap2f' (ulong float float long long float float long long float*) module: 'opengl32.dll'>	^self externalCallFailed! !!OpenGL methodsFor: 'Keyword API' stamp: 'ar 12/4/2003 20:59'!glMapGrid1d: un with: u1 with: u2	"This method was automatically generated."	"void glMapGrid1d(GLint un, GLdouble u1, GLdouble u2);"	<apicall: void 'glMapGrid1d' (long double double) module: 'opengl32.dll'>	^self externalCallFailed! !!OpenGL methodsFor: 'Keyword API' stamp: 'ar 12/4/2003 20:59'!glMapGrid1f: un with: u1 with: u2	"This method was automatically generated."	"void glMapGrid1f(GLint un, GLfloat u1, GLfloat u2);"	<apicall: void 'glMapGrid1f' (long float float) module: 'opengl32.dll'>	^self externalCallFailed! !!OpenGL methodsFor: 'Keyword API' stamp: 'ar 12/4/2003 20:59'!glMapGrid2d: un with: u1 with: u2 with: vn with: v1 with: v2	"This method was automatically generated."	"void glMapGrid2d(GLint un, GLdouble u1, GLdouble u2, GLint vn, GLdouble v1, GLdouble v2);"	<apicall: void 'glMapGrid2d' (long double double long double double) module: 'opengl32.dll'>	^self externalCallFailed! !!OpenGL methodsFor: 'Keyword API' stamp: 'ar 12/4/2003 20:59'!glMapGrid2f: un with: u1 with: u2 with: vn with: v1 with: v2	"This method was automatically generated."	"void glMapGrid2f(GLint un, GLfloat u1, GLfloat u2, GLint vn, GLfloat v1, GLfloat v2);"	<apicall: void 'glMapGrid2f' (long float float long float float) module: 'opengl32.dll'>	^self externalCallFailed! !!OpenGL methodsFor: 'Keyword API' stamp: 'ar 12/4/2003 20:59'!glMaterialf: face with: pname with: param	"This method was automatically generated."	"void glMaterialf(GLenum face, GLenum pname, GLfloat param);"	<apicall: void 'glMaterialf' (ulong ulong float) module: 'opengl32.dll'>	^self externalCallFailed! !!OpenGL methodsFor: 'Keyword API' stamp: 'ar 12/4/2003 20:59'!glMaterialfv: face with: pname with: params	"This method was automatically generated."	"void glMaterialfv(GLenum face, GLenum pname, GLfloat* params);"	<apicall: void 'glMaterialfv' (ulong ulong float*) module: 'opengl32.dll'>	^self externalCallFailed! !!OpenGL methodsFor: 'Keyword API' stamp: 'ar 12/4/2003 20:59'!glMateriali: face with: pname with: param	"This method was automatically generated."	"void glMateriali(GLenum face, GLenum pname, GLint param);"	<apicall: void 'glMateriali' (ulong ulong long) module: 'opengl32.dll'>	^self externalCallFailed! !!OpenGL methodsFor: 'Keyword API' stamp: 'ar 12/4/2003 20:59'!glMaterialiv: face with: pname with: params	"This method was automatically generated."	"void glMaterialiv(GLenum face, GLenum pname, GLint* params);"	<apicall: void 'glMaterialiv' (ulong ulong long*) module: 'opengl32.dll'>	^self externalCallFailed! !!OpenGL methodsFor: 'Keyword API' stamp: 'ar 12/4/2003 20:59'!glMatrixMode: mode	"This method was automatically generated."	"void glMatrixMode(GLenum mode);"	<apicall: void 'glMatrixMode' (ulong) module: 'opengl32.dll'>	^self externalCallFailed! !!OpenGL methodsFor: 'Keyword API' stamp: 'ar 12/4/2003 20:59'!glMinmax: target with: internalformat with: sink	"This method was automatically generated."	"void glMinmax(GLenum target, GLenum internalformat, GLboolean sink);"	<apicall: void 'glMinmax' (ulong ulong bool) module: 'opengl32.dll'>	^self externalCallFailed! !!OpenGL methodsFor: 'Keyword API' stamp: 'ar 12/4/2003 20:59'!glMultMatrixd: m	"This method was automatically generated."	"void glMultMatrixd(GLdouble* m);"	<apicall: void 'glMultMatrixd' (double*) module: 'opengl32.dll'>	^self externalCallFailed! !!OpenGL methodsFor: 'Keyword API' stamp: 'ar 12/4/2003 20:59'!glMultMatrixf: m	"This method was automatically generated."	"void glMultMatrixf(GLfloat* m);"	<apicall: void 'glMultMatrixf' (float*) module: 'opengl32.dll'>	^self externalCallFailed! !!OpenGL methodsFor: 'Keyword API' stamp: 'ar 12/4/2003 20:59'!glMultiTexCoord1dARB: target with: s	"This method was automatically generated."	"void glMultiTexCoord1dARB(GLenum target, GLdouble s);"	<apicall: void 'glMultiTexCoord1dARB' (ulong double) module: 'opengl32.dll'>	^self externalCallFailed! !!OpenGL methodsFor: 'Keyword API' stamp: 'ar 12/4/2003 20:59'!glMultiTexCoord1dvARB: target with: v	"This method was automatically generated."	"void glMultiTexCoord1dvARB(GLenum target, GLdouble* v);"	<apicall: void 'glMultiTexCoord1dvARB' (ulong double*) module: 'opengl32.dll'>	^self externalCallFailed! !!OpenGL methodsFor: 'Keyword API' stamp: 'ar 12/4/2003 20:59'!glMultiTexCoord1fARB: target with: s	"This method was automatically generated."	"void glMultiTexCoord1fARB(GLenum target, GLfloat s);"	<apicall: void 'glMultiTexCoord1fARB' (ulong float) module: 'opengl32.dll'>	^self externalCallFailed! !!OpenGL methodsFor: 'Keyword API' stamp: 'ar 12/4/2003 20:59'!glMultiTexCoord1fvARB: target with: v	"This method was automatically generated."	"void glMultiTexCoord1fvARB(GLenum target, GLfloat* v);"	<apicall: void 'glMultiTexCoord1fvARB' (ulong float*) module: 'opengl32.dll'>	^self externalCallFailed! !!OpenGL methodsFor: 'Keyword API' stamp: 'ar 12/4/2003 20:59'!glMultiTexCoord1iARB: target with: s	"This method was automatically generated."	"void glMultiTexCoord1iARB(GLenum target, GLint s);"	<apicall: void 'glMultiTexCoord1iARB' (ulong long) module: 'opengl32.dll'>	^self externalCallFailed! !!OpenGL methodsFor: 'Keyword API' stamp: 'ar 12/4/2003 20:59'!glMultiTexCoord1ivARB: target with: v	"This method was automatically generated."	"void glMultiTexCoord1ivARB(GLenum target, GLint* v);"	<apicall: void 'glMultiTexCoord1ivARB' (ulong long*) module: 'opengl32.dll'>	^self externalCallFailed! !!OpenGL methodsFor: 'Keyword API' stamp: 'ar 12/4/2003 20:59'!glMultiTexCoord1sARB: target with: s	"This method was automatically generated."	"void glMultiTexCoord1sARB(GLenum target, GLshort s);"	<apicall: void 'glMultiTexCoord1sARB' (ulong short) module: 'opengl32.dll'>	^self externalCallFailed! !!OpenGL methodsFor: 'Keyword API' stamp: 'ar 12/4/2003 20:59'!glMultiTexCoord1svARB: target with: v	"This method was automatically generated."	"void glMultiTexCoord1svARB(GLenum target, GLshort* v);"	<apicall: void 'glMultiTexCoord1svARB' (ulong short*) module: 'opengl32.dll'>	^self externalCallFailed! !!OpenGL methodsFor: 'Keyword API' stamp: 'ar 12/4/2003 20:59'!glMultiTexCoord2dARB: target with: s with: t	"This method was automatically generated."	"void glMultiTexCoord2dARB(GLenum target, GLdouble s, GLdouble t);"	<apicall: void 'glMultiTexCoord2dARB' (ulong double double) module: 'opengl32.dll'>	^self externalCallFailed! !!OpenGL methodsFor: 'Keyword API' stamp: 'ar 12/4/2003 20:59'!glMultiTexCoord2dvARB: target with: v	"This method was automatically generated."	"void glMultiTexCoord2dvARB(GLenum target, GLdouble* v);"	<apicall: void 'glMultiTexCoord2dvARB' (ulong double*) module: 'opengl32.dll'>	^self externalCallFailed! !!OpenGL methodsFor: 'Keyword API' stamp: 'ar 12/4/2003 20:59'!glMultiTexCoord2fARB: target with: s with: t	"This method was automatically generated."	"void glMultiTexCoord2fARB(GLenum target, GLfloat s, GLfloat t);"	<apicall: void 'glMultiTexCoord2fARB' (ulong float float) module: 'opengl32.dll'>	^self externalCallFailed! !!OpenGL methodsFor: 'Keyword API' stamp: 'ar 12/4/2003 20:59'!glMultiTexCoord2fvARB: target with: v	"This method was automatically generated."	"void glMultiTexCoord2fvARB(GLenum target, GLfloat* v);"	<apicall: void 'glMultiTexCoord2fvARB' (ulong float*) module: 'opengl32.dll'>	^self externalCallFailed! !!OpenGL methodsFor: 'Keyword API' stamp: 'ar 12/4/2003 20:59'!glMultiTexCoord2iARB: target with: s with: t	"This method was automatically generated."	"void glMultiTexCoord2iARB(GLenum target, GLint s, GLint t);"	<apicall: void 'glMultiTexCoord2iARB' (ulong long long) module: 'opengl32.dll'>	^self externalCallFailed! !!OpenGL methodsFor: 'Keyword API' stamp: 'ar 12/4/2003 20:59'!glMultiTexCoord2ivARB: target with: v	"This method was automatically generated."	"void glMultiTexCoord2ivARB(GLenum target, GLint* v);"	<apicall: void 'glMultiTexCoord2ivARB' (ulong long*) module: 'opengl32.dll'>	^self externalCallFailed! !!OpenGL methodsFor: 'Keyword API' stamp: 'ar 12/4/2003 20:59'!glMultiTexCoord2sARB: target with: s with: t	"This method was automatically generated."	"void glMultiTexCoord2sARB(GLenum target, GLshort s, GLshort t);"	<apicall: void 'glMultiTexCoord2sARB' (ulong short short) module: 'opengl32.dll'>	^self externalCallFailed! !!OpenGL methodsFor: 'Keyword API' stamp: 'ar 12/4/2003 20:59'!glMultiTexCoord2svARB: target with: v	"This method was automatically generated."	"void glMultiTexCoord2svARB(GLenum target, GLshort* v);"	<apicall: void 'glMultiTexCoord2svARB' (ulong short*) module: 'opengl32.dll'>	^self externalCallFailed! !!OpenGL methodsFor: 'Keyword API' stamp: 'ar 12/4/2003 20:59'!glMultiTexCoord3dARB: target with: s with: t with: r	"This method was automatically generated."	"void glMultiTexCoord3dARB(GLenum target, GLdouble s, GLdouble t, GLdouble r);"	<apicall: void 'glMultiTexCoord3dARB' (ulong double double double) module: 'opengl32.dll'>	^self externalCallFailed! !!OpenGL methodsFor: 'Keyword API' stamp: 'ar 12/4/2003 20:59'!glMultiTexCoord3dvARB: target with: v	"This method was automatically generated."	"void glMultiTexCoord3dvARB(GLenum target, GLdouble* v);"	<apicall: void 'glMultiTexCoord3dvARB' (ulong double*) module: 'opengl32.dll'>	^self externalCallFailed! !!OpenGL methodsFor: 'Keyword API' stamp: 'ar 12/4/2003 20:59'!glMultiTexCoord3fARB: target with: s with: t with: r	"This method was automatically generated."	"void glMultiTexCoord3fARB(GLenum target, GLfloat s, GLfloat t, GLfloat r);"	<apicall: void 'glMultiTexCoord3fARB' (ulong float float float) module: 'opengl32.dll'>	^self externalCallFailed! !!OpenGL methodsFor: 'Keyword API' stamp: 'ar 12/4/2003 20:59'!glMultiTexCoord3fvARB: target with: v	"This method was automatically generated."	"void glMultiTexCoord3fvARB(GLenum target, GLfloat* v);"	<apicall: void 'glMultiTexCoord3fvARB' (ulong float*) module: 'opengl32.dll'>	^self externalCallFailed! !!OpenGL methodsFor: 'Keyword API' stamp: 'ar 12/4/2003 20:59'!glMultiTexCoord3iARB: target with: s with: t with: r	"This method was automatically generated."	"void glMultiTexCoord3iARB(GLenum target, GLint s, GLint t, GLint r);"	<apicall: void 'glMultiTexCoord3iARB' (ulong long long long) module: 'opengl32.dll'>	^self externalCallFailed! !!OpenGL methodsFor: 'Keyword API' stamp: 'ar 12/4/2003 20:59'!glMultiTexCoord3ivARB: target with: v	"This method was automatically generated."	"void glMultiTexCoord3ivARB(GLenum target, GLint* v);"	<apicall: void 'glMultiTexCoord3ivARB' (ulong long*) module: 'opengl32.dll'>	^self externalCallFailed! !!OpenGL methodsFor: 'Keyword API' stamp: 'ar 12/4/2003 20:59'!glMultiTexCoord3sARB: target with: s with: t with: r	"This method was automatically generated."	"void glMultiTexCoord3sARB(GLenum target, GLshort s, GLshort t, GLshort r);"	<apicall: void 'glMultiTexCoord3sARB' (ulong short short short) module: 'opengl32.dll'>	^self externalCallFailed! !!OpenGL methodsFor: 'Keyword API' stamp: 'ar 12/4/2003 20:59'!glMultiTexCoord3svARB: target with: v	"This method was automatically generated."	"void glMultiTexCoord3svARB(GLenum target, GLshort* v);"	<apicall: void 'glMultiTexCoord3svARB' (ulong short*) module: 'opengl32.dll'>	^self externalCallFailed! !!OpenGL methodsFor: 'Keyword API' stamp: 'ar 12/4/2003 20:59'!glMultiTexCoord4dARB: target with: s with: t with: r with: q	"This method was automatically generated."	"void glMultiTexCoord4dARB(GLenum target, GLdouble s, GLdouble t, GLdouble r, GLdouble q);"	<apicall: void 'glMultiTexCoord4dARB' (ulong double double double double) module: 'opengl32.dll'>	^self externalCallFailed! !!OpenGL methodsFor: 'Keyword API' stamp: 'ar 12/4/2003 20:59'!glMultiTexCoord4dvARB: target with: v	"This method was automatically generated."	"void glMultiTexCoord4dvARB(GLenum target, GLdouble* v);"	<apicall: void 'glMultiTexCoord4dvARB' (ulong double*) module: 'opengl32.dll'>	^self externalCallFailed! !!OpenGL methodsFor: 'Keyword API' stamp: 'ar 12/4/2003 20:59'!glMultiTexCoord4fARB: target with: s with: t with: r with: q	"This method was automatically generated."	"void glMultiTexCoord4fARB(GLenum target, GLfloat s, GLfloat t, GLfloat r, GLfloat q);"	<apicall: void 'glMultiTexCoord4fARB' (ulong float float float float) module: 'opengl32.dll'>	^self externalCallFailed! !!OpenGL methodsFor: 'Keyword API' stamp: 'ar 12/4/2003 20:59'!glMultiTexCoord4fvARB: target with: v	"This method was automatically generated."	"void glMultiTexCoord4fvARB(GLenum target, GLfloat* v);"	<apicall: void 'glMultiTexCoord4fvARB' (ulong float*) module: 'opengl32.dll'>	^self externalCallFailed! !!OpenGL methodsFor: 'Keyword API' stamp: 'ar 12/4/2003 20:59'!glMultiTexCoord4iARB: target with: s with: t with: r with: q	"This method was automatically generated."	"void glMultiTexCoord4iARB(GLenum target, GLint s, GLint t, GLint r, GLint q);"	<apicall: void 'glMultiTexCoord4iARB' (ulong long long long long) module: 'opengl32.dll'>	^self externalCallFailed! !!OpenGL methodsFor: 'Keyword API' stamp: 'ar 12/4/2003 20:59'!glMultiTexCoord4ivARB: target with: v	"This method was automatically generated."	"void glMultiTexCoord4ivARB(GLenum target, GLint* v);"	<apicall: void 'glMultiTexCoord4ivARB' (ulong long*) module: 'opengl32.dll'>	^self externalCallFailed! !!OpenGL methodsFor: 'Keyword API' stamp: 'ar 12/4/2003 20:59'!glMultiTexCoord4sARB: target with: s with: t with: r with: q	"This method was automatically generated."	"void glMultiTexCoord4sARB(GLenum target, GLshort s, GLshort t, GLshort r, GLshort q);"	<apicall: void 'glMultiTexCoord4sARB' (ulong short short short short) module: 'opengl32.dll'>	^self externalCallFailed! !!OpenGL methodsFor: 'Keyword API' stamp: 'ar 12/4/2003 20:59'!glMultiTexCoord4svARB: target with: v	"This method was automatically generated."	"void glMultiTexCoord4svARB(GLenum target, GLshort* v);"	<apicall: void 'glMultiTexCoord4svARB' (ulong short*) module: 'opengl32.dll'>	^self externalCallFailed! !!OpenGL methodsFor: 'Keyword API' stamp: 'ar 12/4/2003 20:59'!glNewList: list with: mode	"This method was automatically generated."	"void glNewList(GLuint list, GLenum mode);"	<apicall: void 'glNewList' (ulong ulong) module: 'opengl32.dll'>	^self externalCallFailed! !!OpenGL methodsFor: 'Keyword API' stamp: 'ar 12/4/2003 20:59'!glNormal3b: nx with: ny with: nz	"This method was automatically generated."	"void glNormal3b(GLbyte nx, GLbyte ny, GLbyte nz);"	<apicall: void 'glNormal3b' (byte byte byte) module: 'opengl32.dll'>	^self externalCallFailed! !!OpenGL methodsFor: 'Keyword API' stamp: 'ar 12/4/2003 20:59'!glNormal3bv: v	"This method was automatically generated."	"void glNormal3bv(GLbyte* v);"	<apicall: void 'glNormal3bv' (byte*) module: 'opengl32.dll'>	^self externalCallFailed! !!OpenGL methodsFor: 'Keyword API' stamp: 'ar 12/4/2003 20:59'!glNormal3d: nx with: ny with: nz	"This method was automatically generated."	"void glNormal3d(GLdouble nx, GLdouble ny, GLdouble nz);"	<apicall: void 'glNormal3d' (double double double) module: 'opengl32.dll'>	^self externalCallFailed! !!OpenGL methodsFor: 'Keyword API' stamp: 'ar 12/4/2003 20:59'!glNormal3dv: v	"This method was automatically generated."	"void glNormal3dv(GLdouble* v);"	<apicall: void 'glNormal3dv' (double*) module: 'opengl32.dll'>	^self externalCallFailed! !!OpenGL methodsFor: 'Keyword API' stamp: 'ar 12/4/2003 20:59'!glNormal3f: nx with: ny with: nz	"This method was automatically generated."	"void glNormal3f(GLfloat nx, GLfloat ny, GLfloat nz);"	<apicall: void 'glNormal3f' (float float float) module: 'opengl32.dll'>	^self externalCallFailed! !!OpenGL methodsFor: 'Keyword API' stamp: 'ar 12/4/2003 20:59'!glNormal3fv: v	"This method was automatically generated."	"void glNormal3fv(GLfloat* v);"	<apicall: void 'glNormal3fv' (float*) module: 'opengl32.dll'>	^self externalCallFailed! !!OpenGL methodsFor: 'Keyword API' stamp: 'ar 12/4/2003 20:59'!glNormal3i: nx with: ny with: nz	"This method was automatically generated."	"void glNormal3i(GLint nx, GLint ny, GLint nz);"	<apicall: void 'glNormal3i' (long long long) module: 'opengl32.dll'>	^self externalCallFailed! !!OpenGL methodsFor: 'Keyword API' stamp: 'ar 12/4/2003 20:59'!glNormal3iv: v	"This method was automatically generated."	"void glNormal3iv(GLint* v);"	<apicall: void 'glNormal3iv' (long*) module: 'opengl32.dll'>	^self externalCallFailed! !!OpenGL methodsFor: 'Keyword API' stamp: 'ar 12/4/2003 20:59'!glNormal3s: nx with: ny with: nz	"This method was automatically generated."	"void glNormal3s(GLshort nx, GLshort ny, GLshort nz);"	<apicall: void 'glNormal3s' (short short short) module: 'opengl32.dll'>	^self externalCallFailed! !!OpenGL methodsFor: 'Keyword API' stamp: 'ar 12/4/2003 20:59'!glNormal3sv: v	"This method was automatically generated."	"void glNormal3sv(GLshort* v);"	<apicall: void 'glNormal3sv' (short*) module: 'opengl32.dll'>	^self externalCallFailed! !!OpenGL methodsFor: 'Keyword API' stamp: 'ar 12/4/2003 20:59'!glNormalPointer: type with: stride with: pointer	"This method was automatically generated."	"void glNormalPointer(GLenum type, GLsizei stride, GLvoid* pointer);"	<apicall: void 'glNormalPointer' (ulong long void*) module: 'opengl32.dll'>	^self externalCallFailed! !!OpenGL methodsFor: 'Keyword API' stamp: 'ar 12/4/2003 20:59'!glNormalPointerEXT: type with: stride with: count with: pointer	"This method was automatically generated."	"void glNormalPointerEXT(GLenum type, GLsizei stride, GLsizei count, GLvoid* pointer);"	<apicall: void 'glNormalPointerEXT' (ulong long long void*) module: 'opengl32.dll'>	^self externalCallFailed! !!OpenGL methodsFor: 'Keyword API' stamp: 'ar 12/4/2003 20:59'!glOrtho: left with: right with: bottom with: top with: zNear with: zFar	"This method was automatically generated."	"void glOrtho(GLdouble left, GLdouble right, GLdouble bottom, GLdouble top, GLdouble zNear, GLdouble zFar);"	<apicall: void 'glOrtho' (double double double double double double) module: 'opengl32.dll'>	^self externalCallFailed! !!OpenGL methodsFor: 'Keyword API' stamp: 'ar 12/4/2003 20:59'!glPassThrough: token	"This method was automatically generated."	"void glPassThrough(GLfloat token);"	<apicall: void 'glPassThrough' (float) module: 'opengl32.dll'>	^self externalCallFailed! !!OpenGL methodsFor: 'Keyword API' stamp: 'ar 12/4/2003 20:59'!glPixelMapfv: map with: mapsize with: values	"This method was automatically generated."	"void glPixelMapfv(GLenum map, GLint mapsize, GLfloat* values);"	<apicall: void 'glPixelMapfv' (ulong long float*) module: 'opengl32.dll'>	^self externalCallFailed! !!OpenGL methodsFor: 'Keyword API' stamp: 'ar 12/4/2003 20:59'!glPixelMapuiv: map with: mapsize with: values	"This method was automatically generated."	"void glPixelMapuiv(GLenum map, GLint mapsize, GLuint* values);"	<apicall: void 'glPixelMapuiv' (ulong long ulong*) module: 'opengl32.dll'>	^self externalCallFailed! !!OpenGL methodsFor: 'Keyword API' stamp: 'ar 12/4/2003 20:59'!glPixelMapusv: map with: mapsize with: values	"This method was automatically generated."	"void glPixelMapusv(GLenum map, GLint mapsize, GLushort* values);"	<apicall: void 'glPixelMapusv' (ulong long ushort*) module: 'opengl32.dll'>	^self externalCallFailed! !!OpenGL methodsFor: 'Keyword API' stamp: 'ar 12/4/2003 20:59'!glPixelStoref: pname with: param	"This method was automatically generated."	"void glPixelStoref(GLenum pname, GLfloat param);"	<apicall: void 'glPixelStoref' (ulong float) module: 'opengl32.dll'>	^self externalCallFailed! !!OpenGL methodsFor: 'Keyword API' stamp: 'ar 12/4/2003 20:59'!glPixelStorei: pname with: param	"This method was automatically generated."	"void glPixelStorei(GLenum pname, GLint param);"	<apicall: void 'glPixelStorei' (ulong long) module: 'opengl32.dll'>	^self externalCallFailed! !!OpenGL methodsFor: 'Keyword API' stamp: 'ar 12/4/2003 20:59'!glPixelTransferf: pname with: param	"This method was automatically generated."	"void glPixelTransferf(GLenum pname, GLfloat param);"	<apicall: void 'glPixelTransferf' (ulong float) module: 'opengl32.dll'>	^self externalCallFailed! !!OpenGL methodsFor: 'Keyword API' stamp: 'ar 12/4/2003 20:59'!glPixelTransferi: pname with: param	"This method was automatically generated."	"void glPixelTransferi(GLenum pname, GLint param);"	<apicall: void 'glPixelTransferi' (ulong long) module: 'opengl32.dll'>	^self externalCallFailed! !!OpenGL methodsFor: 'Keyword API' stamp: 'ar 12/4/2003 20:59'!glPixelZoom: xfactor with: yfactor	"This method was automatically generated."	"void glPixelZoom(GLfloat xfactor, GLfloat yfactor);"	<apicall: void 'glPixelZoom' (float float) module: 'opengl32.dll'>	^self externalCallFailed! !!OpenGL methodsFor: 'Keyword API' stamp: 'ar 12/4/2003 20:59'!glPointSize: size	"This method was automatically generated."	"void glPointSize(GLfloat size);"	<apicall: void 'glPointSize' (float) module: 'opengl32.dll'>	^self externalCallFailed! !!OpenGL methodsFor: 'Keyword API' stamp: 'ar 12/4/2003 20:59'!glPolygonMode: face with: mode	"This method was automatically generated."	"void glPolygonMode(GLenum face, GLenum mode);"	<apicall: void 'glPolygonMode' (ulong ulong) module: 'opengl32.dll'>	^self externalCallFailed! !!OpenGL methodsFor: 'Keyword API' stamp: 'ar 12/4/2003 20:59'!glPolygonOffset: factor with: units	"This method was automatically generated."	"void glPolygonOffset(GLfloat factor, GLfloat units);"	<apicall: void 'glPolygonOffset' (float float) module: 'opengl32.dll'>	^self externalCallFailed! !!OpenGL methodsFor: 'Keyword API' stamp: 'ar 12/4/2003 20:59'!glPolygonStipple: mask	"This method was automatically generated."	"void glPolygonStipple(GLubyte* mask);"	<apicall: void 'glPolygonStipple' (byte*) module: 'opengl32.dll'>	^self externalCallFailed! !!OpenGL methodsFor: 'Keyword API' stamp: 'ar 12/4/2003 20:59'!glPopAttrib	"This method was automatically generated."	"void glPopAttrib();"	<apicall: void 'glPopAttrib' (void) module: 'opengl32.dll'>	^self externalCallFailed! !!OpenGL methodsFor: 'Keyword API' stamp: 'ar 12/4/2003 20:59'!glPopClientAttrib	"This method was automatically generated."	"void glPopClientAttrib();"	<apicall: void 'glPopClientAttrib' (void) module: 'opengl32.dll'>	^self externalCallFailed! !!OpenGL methodsFor: 'Keyword API' stamp: 'ar 12/4/2003 20:59'!glPopMatrix	"This method was automatically generated."	"void glPopMatrix();"	<apicall: void 'glPopMatrix' (void) module: 'opengl32.dll'>	^self externalCallFailed! !!OpenGL methodsFor: 'Keyword API' stamp: 'ar 12/4/2003 20:59'!glPopName	"This method was automatically generated."	"void glPopName();"	<apicall: void 'glPopName' (void) module: 'opengl32.dll'>	^self externalCallFailed! !!OpenGL methodsFor: 'Keyword API' stamp: 'ar 12/4/2003 20:59'!glPrioritizeTextures: n with: textures with: priorities	"This method was automatically generated."	"void glPrioritizeTextures(GLsizei n, GLuint* textures, GLclampf* priorities);"	<apicall: void 'glPrioritizeTextures' (long ulong* float*) module: 'opengl32.dll'>	^self externalCallFailed! !!OpenGL methodsFor: 'Keyword API' stamp: 'ar 12/4/2003 20:59'!glPushAttrib: mask	"This method was automatically generated."	"void glPushAttrib(GLbitfield mask);"	<apicall: void 'glPushAttrib' (ulong) module: 'opengl32.dll'>	^self externalCallFailed! !!OpenGL methodsFor: 'Keyword API' stamp: 'ar 12/4/2003 20:59'!glPushClientAttrib: mask	"This method was automatically generated."	"void glPushClientAttrib(GLbitfield mask);"	<apicall: void 'glPushClientAttrib' (ulong) module: 'opengl32.dll'>	^self externalCallFailed! !!OpenGL methodsFor: 'Keyword API' stamp: 'ar 12/4/2003 20:59'!glPushMatrix	"This method was automatically generated."	"void glPushMatrix();"	<apicall: void 'glPushMatrix' (void) module: 'opengl32.dll'>	^self externalCallFailed! !!OpenGL methodsFor: 'Keyword API' stamp: 'ar 12/4/2003 20:59'!glPushName: name	"This method was automatically generated."	"void glPushName(GLuint name);"	<apicall: void 'glPushName' (ulong) module: 'opengl32.dll'>	^self externalCallFailed! !!OpenGL methodsFor: 'Keyword API' stamp: 'ar 12/4/2003 20:59'!glRasterPos2d: x with: y	"This method was automatically generated."	"void glRasterPos2d(GLdouble x, GLdouble y);"	<apicall: void 'glRasterPos2d' (double double) module: 'opengl32.dll'>	^self externalCallFailed! !!OpenGL methodsFor: 'Keyword API' stamp: 'ar 12/4/2003 20:59'!glRasterPos2dv: v	"This method was automatically generated."	"void glRasterPos2dv(GLdouble* v);"	<apicall: void 'glRasterPos2dv' (double*) module: 'opengl32.dll'>	^self externalCallFailed! !!OpenGL methodsFor: 'Keyword API' stamp: 'ar 12/4/2003 20:59'!glRasterPos2f: x with: y	"This method was automatically generated."	"void glRasterPos2f(GLfloat x, GLfloat y);"	<apicall: void 'glRasterPos2f' (float float) module: 'opengl32.dll'>	^self externalCallFailed! !!OpenGL methodsFor: 'Keyword API' stamp: 'ar 12/4/2003 20:59'!glRasterPos2fv: v	"This method was automatically generated."	"void glRasterPos2fv(GLfloat* v);"	<apicall: void 'glRasterPos2fv' (float*) module: 'opengl32.dll'>	^self externalCallFailed! !!OpenGL methodsFor: 'Keyword API' stamp: 'ar 12/4/2003 20:59'!glRasterPos2i: x with: y	"This method was automatically generated."	"void glRasterPos2i(GLint x, GLint y);"	<apicall: void 'glRasterPos2i' (long long) module: 'opengl32.dll'>	^self externalCallFailed! !!OpenGL methodsFor: 'Keyword API' stamp: 'ar 12/4/2003 20:59'!glRasterPos2iv: v	"This method was automatically generated."	"void glRasterPos2iv(GLint* v);"	<apicall: void 'glRasterPos2iv' (long*) module: 'opengl32.dll'>	^self externalCallFailed! !!OpenGL methodsFor: 'Keyword API' stamp: 'ar 12/4/2003 20:59'!glRasterPos2s: x with: y	"This method was automatically generated."	"void glRasterPos2s(GLshort x, GLshort y);"	<apicall: void 'glRasterPos2s' (short short) module: 'opengl32.dll'>	^self externalCallFailed! !!OpenGL methodsFor: 'Keyword API' stamp: 'ar 12/4/2003 20:59'!glRasterPos2sv: v	"This method was automatically generated."	"void glRasterPos2sv(GLshort* v);"	<apicall: void 'glRasterPos2sv' (short*) module: 'opengl32.dll'>	^self externalCallFailed! !!OpenGL methodsFor: 'Keyword API' stamp: 'ar 12/4/2003 20:59'!glRasterPos3d: x with: y with: z	"This method was automatically generated."	"void glRasterPos3d(GLdouble x, GLdouble y, GLdouble z);"	<apicall: void 'glRasterPos3d' (double double double) module: 'opengl32.dll'>	^self externalCallFailed! !!OpenGL methodsFor: 'Keyword API' stamp: 'ar 12/4/2003 20:59'!glRasterPos3dv: v	"This method was automatically generated."	"void glRasterPos3dv(GLdouble* v);"	<apicall: void 'glRasterPos3dv' (double*) module: 'opengl32.dll'>	^self externalCallFailed! !!OpenGL methodsFor: 'Keyword API' stamp: 'ar 12/4/2003 20:59'!glRasterPos3f: x with: y with: z	"This method was automatically generated."	"void glRasterPos3f(GLfloat x, GLfloat y, GLfloat z);"	<apicall: void 'glRasterPos3f' (float float float) module: 'opengl32.dll'>	^self externalCallFailed! !!OpenGL methodsFor: 'Keyword API' stamp: 'ar 12/4/2003 20:59'!glRasterPos3fv: v	"This method was automatically generated."	"void glRasterPos3fv(GLfloat* v);"	<apicall: void 'glRasterPos3fv' (float*) module: 'opengl32.dll'>	^self externalCallFailed! !!OpenGL methodsFor: 'Keyword API' stamp: 'ar 12/4/2003 20:59'!glRasterPos3i: x with: y with: z	"This method was automatically generated."	"void glRasterPos3i(GLint x, GLint y, GLint z);"	<apicall: void 'glRasterPos3i' (long long long) module: 'opengl32.dll'>	^self externalCallFailed! !!OpenGL methodsFor: 'Keyword API' stamp: 'ar 12/4/2003 20:59'!glRasterPos3iv: v	"This method was automatically generated."	"void glRasterPos3iv(GLint* v);"	<apicall: void 'glRasterPos3iv' (long*) module: 'opengl32.dll'>	^self externalCallFailed! !!OpenGL methodsFor: 'Keyword API' stamp: 'ar 12/4/2003 20:59'!glRasterPos3s: x with: y with: z	"This method was automatically generated."	"void glRasterPos3s(GLshort x, GLshort y, GLshort z);"	<apicall: void 'glRasterPos3s' (short short short) module: 'opengl32.dll'>	^self externalCallFailed! !!OpenGL methodsFor: 'Keyword API' stamp: 'ar 12/4/2003 20:59'!glRasterPos3sv: v	"This method was automatically generated."	"void glRasterPos3sv(GLshort* v);"	<apicall: void 'glRasterPos3sv' (short*) module: 'opengl32.dll'>	^self externalCallFailed! !!OpenGL methodsFor: 'Keyword API' stamp: 'ar 12/4/2003 20:59'!glRasterPos4d: x with: y with: z with: w	"This method was automatically generated."	"void glRasterPos4d(GLdouble x, GLdouble y, GLdouble z, GLdouble w);"	<apicall: void 'glRasterPos4d' (double double double double) module: 'opengl32.dll'>	^self externalCallFailed! !!OpenGL methodsFor: 'Keyword API' stamp: 'ar 12/4/2003 20:59'!glRasterPos4dv: v	"This method was automatically generated."	"void glRasterPos4dv(GLdouble* v);"	<apicall: void 'glRasterPos4dv' (double*) module: 'opengl32.dll'>	^self externalCallFailed! !!OpenGL methodsFor: 'Keyword API' stamp: 'ar 12/4/2003 20:59'!glRasterPos4f: x with: y with: z with: w	"This method was automatically generated."	"void glRasterPos4f(GLfloat x, GLfloat y, GLfloat z, GLfloat w);"	<apicall: void 'glRasterPos4f' (float float float float) module: 'opengl32.dll'>	^self externalCallFailed! !!OpenGL methodsFor: 'Keyword API' stamp: 'ar 12/4/2003 20:59'!glRasterPos4fv: v	"This method was automatically generated."	"void glRasterPos4fv(GLfloat* v);"	<apicall: void 'glRasterPos4fv' (float*) module: 'opengl32.dll'>	^self externalCallFailed! !!OpenGL methodsFor: 'Keyword API' stamp: 'ar 12/4/2003 20:59'!glRasterPos4i: x with: y with: z with: w	"This method was automatically generated."	"void glRasterPos4i(GLint x, GLint y, GLint z, GLint w);"	<apicall: void 'glRasterPos4i' (long long long long) module: 'opengl32.dll'>	^self externalCallFailed! !!OpenGL methodsFor: 'Keyword API' stamp: 'ar 12/4/2003 20:59'!glRasterPos4iv: v	"This method was automatically generated."	"void glRasterPos4iv(GLint* v);"	<apicall: void 'glRasterPos4iv' (long*) module: 'opengl32.dll'>	^self externalCallFailed! !!OpenGL methodsFor: 'Keyword API' stamp: 'ar 12/4/2003 20:59'!glRasterPos4s: x with: y with: z with: w	"This method was automatically generated."	"void glRasterPos4s(GLshort x, GLshort y, GLshort z, GLshort w);"	<apicall: void 'glRasterPos4s' (short short short short) module: 'opengl32.dll'>	^self externalCallFailed! !!OpenGL methodsFor: 'Keyword API' stamp: 'ar 12/4/2003 20:59'!glRasterPos4sv: v	"This method was automatically generated."	"void glRasterPos4sv(GLshort* v);"	<apicall: void 'glRasterPos4sv' (short*) module: 'opengl32.dll'>	^self externalCallFailed! !!OpenGL methodsFor: 'Keyword API' stamp: 'ar 12/4/2003 20:59'!glReadBuffer: mode	"This method was automatically generated."	"void glReadBuffer(GLenum mode);"	<apicall: void 'glReadBuffer' (ulong) module: 'opengl32.dll'>	^self externalCallFailed! !!OpenGL methodsFor: 'Keyword API' stamp: 'ar 12/4/2003 20:59'!glReadPixels: x with: y with: width with: height with: format with: type with: pixels	"This method was automatically generated."	"void glReadPixels(GLint x, GLint y, GLsizei width, GLsizei height, GLenum format, GLenum type, GLvoid* pixels);"	<apicall: void 'glReadPixels' (long long long long ulong ulong void*) module: 'opengl32.dll'>	^self externalCallFailed! !!OpenGL methodsFor: 'Keyword API' stamp: 'ar 12/4/2003 20:59'!glRectd: x1 with: y1 with: x2 with: y2	"This method was automatically generated."	"void glRectd(GLdouble x1, GLdouble y1, GLdouble x2, GLdouble y2);"	<apicall: void 'glRectd' (double double double double) module: 'opengl32.dll'>	^self externalCallFailed! !!OpenGL methodsFor: 'Keyword API' stamp: 'ar 12/4/2003 20:59'!glRectdv: v1 with: v2	"This method was automatically generated."	"void glRectdv(GLdouble* v1, GLdouble* v2);"	<apicall: void 'glRectdv' (double* double*) module: 'opengl32.dll'>	^self externalCallFailed! !!OpenGL methodsFor: 'Keyword API' stamp: 'ar 12/4/2003 20:59'!glRectf: x1 with: y1 with: x2 with: y2	"This method was automatically generated."	"void glRectf(GLfloat x1, GLfloat y1, GLfloat x2, GLfloat y2);"	<apicall: void 'glRectf' (float float float float) module: 'opengl32.dll'>	^self externalCallFailed! !!OpenGL methodsFor: 'Keyword API' stamp: 'ar 12/4/2003 20:59'!glRectfv: v1 with: v2	"This method was automatically generated."	"void glRectfv(GLfloat* v1, GLfloat* v2);"	<apicall: void 'glRectfv' (float* float*) module: 'opengl32.dll'>	^self externalCallFailed! !!OpenGL methodsFor: 'Keyword API' stamp: 'ar 12/4/2003 20:59'!glRecti: x1 with: y1 with: x2 with: y2	"This method was automatically generated."	"void glRecti(GLint x1, GLint y1, GLint x2, GLint y2);"	<apicall: void 'glRecti' (long long long long) module: 'opengl32.dll'>	^self externalCallFailed! !!OpenGL methodsFor: 'Keyword API' stamp: 'ar 12/4/2003 20:59'!glRectiv: v1 with: v2	"This method was automatically generated."	"void glRectiv(GLint* v1, GLint* v2);"	<apicall: void 'glRectiv' (long* long*) module: 'opengl32.dll'>	^self externalCallFailed! !!OpenGL methodsFor: 'Keyword API' stamp: 'ar 12/4/2003 20:59'!glRects: x1 with: y1 with: x2 with: y2	"This method was automatically generated."	"void glRects(GLshort x1, GLshort y1, GLshort x2, GLshort y2);"	<apicall: void 'glRects' (short short short short) module: 'opengl32.dll'>	^self externalCallFailed! !!OpenGL methodsFor: 'Keyword API' stamp: 'ar 12/4/2003 20:59'!glRectsv: v1 with: v2	"This method was automatically generated."	"void glRectsv(GLshort* v1, GLshort* v2);"	<apicall: void 'glRectsv' (short* short*) module: 'opengl32.dll'>	^self externalCallFailed! !!OpenGL methodsFor: 'Keyword API' stamp: 'ar 12/4/2003 20:59'!glRenderMode: mode	"This method was automatically generated."	"GLint glRenderMode(GLenum mode);"	<apicall: long 'glRenderMode' (ulong) module: 'opengl32.dll'>	^self externalCallFailed! !!OpenGL methodsFor: 'Keyword API' stamp: 'ar 12/4/2003 20:59'!glResetHistogram: target	"This method was automatically generated."	"void glResetHistogram(GLenum target);"	<apicall: void 'glResetHistogram' (ulong) module: 'opengl32.dll'>	^self externalCallFailed! !!OpenGL methodsFor: 'Keyword API' stamp: 'ar 12/4/2003 20:59'!glResetMinmax: target	"This method was automatically generated."	"void glResetMinmax(GLenum target);"	<apicall: void 'glResetMinmax' (ulong) module: 'opengl32.dll'>	^self externalCallFailed! !!OpenGL methodsFor: 'Keyword API' stamp: 'ar 12/4/2003 20:59'!glRotated: angle with: x with: y with: z	"This method was automatically generated."	"void glRotated(GLdouble angle, GLdouble x, GLdouble y, GLdouble z);"	<apicall: void 'glRotated' (double double double double) module: 'opengl32.dll'>	^self externalCallFailed! !!OpenGL methodsFor: 'Keyword API' stamp: 'ar 12/4/2003 20:59'!glRotatef: angle with: x with: y with: z	"This method was automatically generated."	"void glRotatef(GLfloat angle, GLfloat x, GLfloat y, GLfloat z);"	<apicall: void 'glRotatef' (float float float float) module: 'opengl32.dll'>	^self externalCallFailed! !!OpenGL methodsFor: 'Keyword API' stamp: 'ar 12/4/2003 20:59'!glScaled: x with: y with: z	"This method was automatically generated."	"void glScaled(GLdouble x, GLdouble y, GLdouble z);"	<apicall: void 'glScaled' (double double double) module: 'opengl32.dll'>	^self externalCallFailed! !!OpenGL methodsFor: 'Keyword API' stamp: 'ar 12/4/2003 20:59'!glScalef: x with: y with: z	"This method was automatically generated."	"void glScalef(GLfloat x, GLfloat y, GLfloat z);"	<apicall: void 'glScalef' (float float float) module: 'opengl32.dll'>	^self externalCallFailed! !!OpenGL methodsFor: 'Keyword API' stamp: 'ar 12/4/2003 20:59'!glScissor: x with: y with: width with: height	"This method was automatically generated."	"void glScissor(GLint x, GLint y, GLsizei width, GLsizei height);"	<apicall: void 'glScissor' (long long long long) module: 'opengl32.dll'>	^self externalCallFailed! !!OpenGL methodsFor: 'Keyword API' stamp: 'ar 12/4/2003 20:59'!glSelectBuffer: size with: buffer	"This method was automatically generated."	"void glSelectBuffer(GLsizei size, GLuint* buffer);"	<apicall: void 'glSelectBuffer' (long ulong*) module: 'opengl32.dll'>	^self externalCallFailed! !!OpenGL methodsFor: 'Keyword API' stamp: 'ar 12/4/2003 20:59'!glSeparableFilter2D: target with: internalformat with: width with: height with: format with: type with: row with: column	"This method was automatically generated."	"void glSeparableFilter2D(GLenum target, GLenum internalformat, GLsizei width, GLsizei height, GLenum format, GLenum type, GLvoid* row, GLvoid* column);"	<apicall: void 'glSeparableFilter2D' (ulong ulong long long ulong ulong void* void*) module: 'opengl32.dll'>	^self externalCallFailed! !!OpenGL methodsFor: 'Keyword API' stamp: 'ar 12/4/2003 20:59'!glShadeModel: mode	"This method was automatically generated."	"void glShadeModel(GLenum mode);"	<apicall: void 'glShadeModel' (ulong) module: 'opengl32.dll'>	^self externalCallFailed! !!OpenGL methodsFor: 'Keyword API' stamp: 'ar 12/4/2003 20:59'!glStencilFunc: func with: ref with: mask	"This method was automatically generated."	"void glStencilFunc(GLenum func, GLint ref, GLuint mask);"	<apicall: void 'glStencilFunc' (ulong long ulong) module: 'opengl32.dll'>	^self externalCallFailed! !!OpenGL methodsFor: 'Keyword API' stamp: 'ar 12/4/2003 20:59'!glStencilMask: mask	"This method was automatically generated."	"void glStencilMask(GLuint mask);"	<apicall: void 'glStencilMask' (ulong) module: 'opengl32.dll'>	^self externalCallFailed! !!OpenGL methodsFor: 'Keyword API' stamp: 'ar 12/4/2003 20:59'!glStencilOp: fail with: zfail with: zpass	"This method was automatically generated."	"void glStencilOp(GLenum fail, GLenum zfail, GLenum zpass);"	<apicall: void 'glStencilOp' (ulong ulong ulong) module: 'opengl32.dll'>	^self externalCallFailed! !!OpenGL methodsFor: 'Keyword API' stamp: 'ar 12/4/2003 20:59'!glTexCoord1d: s	"This method was automatically generated."	"void glTexCoord1d(GLdouble s);"	<apicall: void 'glTexCoord1d' (double) module: 'opengl32.dll'>	^self externalCallFailed! !!OpenGL methodsFor: 'Keyword API' stamp: 'ar 12/4/2003 20:59'!glTexCoord1dv: v	"This method was automatically generated."	"void glTexCoord1dv(GLdouble* v);"	<apicall: void 'glTexCoord1dv' (double*) module: 'opengl32.dll'>	^self externalCallFailed! !!OpenGL methodsFor: 'Keyword API' stamp: 'ar 12/4/2003 20:59'!glTexCoord1f: s	"This method was automatically generated."	"void glTexCoord1f(GLfloat s);"	<apicall: void 'glTexCoord1f' (float) module: 'opengl32.dll'>	^self externalCallFailed! !!OpenGL methodsFor: 'Keyword API' stamp: 'ar 12/4/2003 20:59'!glTexCoord1fv: v	"This method was automatically generated."	"void glTexCoord1fv(GLfloat* v);"	<apicall: void 'glTexCoord1fv' (float*) module: 'opengl32.dll'>	^self externalCallFailed! !!OpenGL methodsFor: 'Keyword API' stamp: 'ar 12/4/2003 20:59'!glTexCoord1i: s	"This method was automatically generated."	"void glTexCoord1i(GLint s);"	<apicall: void 'glTexCoord1i' (long) module: 'opengl32.dll'>	^self externalCallFailed! !!OpenGL methodsFor: 'Keyword API' stamp: 'ar 12/4/2003 20:59'!glTexCoord1iv: v	"This method was automatically generated."	"void glTexCoord1iv(GLint* v);"	<apicall: void 'glTexCoord1iv' (long*) module: 'opengl32.dll'>	^self externalCallFailed! !!OpenGL methodsFor: 'Keyword API' stamp: 'ar 12/4/2003 20:59'!glTexCoord1s: s	"This method was automatically generated."	"void glTexCoord1s(GLshort s);"	<apicall: void 'glTexCoord1s' (short) module: 'opengl32.dll'>	^self externalCallFailed! !!OpenGL methodsFor: 'Keyword API' stamp: 'ar 12/4/2003 20:59'!glTexCoord1sv: v	"This method was automatically generated."	"void glTexCoord1sv(GLshort* v);"	<apicall: void 'glTexCoord1sv' (short*) module: 'opengl32.dll'>	^self externalCallFailed! !!OpenGL methodsFor: 'Keyword API' stamp: 'ar 12/4/2003 20:59'!glTexCoord2d: s with: t	"This method was automatically generated."	"void glTexCoord2d(GLdouble s, GLdouble t);"	<apicall: void 'glTexCoord2d' (double double) module: 'opengl32.dll'>	^self externalCallFailed! !!OpenGL methodsFor: 'Keyword API' stamp: 'ar 12/4/2003 20:59'!glTexCoord2dv: v	"This method was automatically generated."	"void glTexCoord2dv(GLdouble* v);"	<apicall: void 'glTexCoord2dv' (double*) module: 'opengl32.dll'>	^self externalCallFailed! !!OpenGL methodsFor: 'Keyword API' stamp: 'ar 12/4/2003 20:59'!glTexCoord2f: s with: t	"This method was automatically generated."	"void glTexCoord2f(GLfloat s, GLfloat t);"	<apicall: void 'glTexCoord2f' (float float) module: 'opengl32.dll'>	^self externalCallFailed! !!OpenGL methodsFor: 'Keyword API' stamp: 'ar 12/4/2003 20:59'!glTexCoord2fv: v	"This method was automatically generated."	"void glTexCoord2fv(GLfloat* v);"	<apicall: void 'glTexCoord2fv' (float*) module: 'opengl32.dll'>	^self externalCallFailed! !!OpenGL methodsFor: 'Keyword API' stamp: 'ar 12/4/2003 20:59'!glTexCoord2i: s with: t	"This method was automatically generated."	"void glTexCoord2i(GLint s, GLint t);"	<apicall: void 'glTexCoord2i' (long long) module: 'opengl32.dll'>	^self externalCallFailed! !!OpenGL methodsFor: 'Keyword API' stamp: 'ar 12/4/2003 20:59'!glTexCoord2iv: v	"This method was automatically generated."	"void glTexCoord2iv(GLint* v);"	<apicall: void 'glTexCoord2iv' (long*) module: 'opengl32.dll'>	^self externalCallFailed! !!OpenGL methodsFor: 'Keyword API' stamp: 'ar 12/4/2003 20:59'!glTexCoord2s: s with: t	"This method was automatically generated."	"void glTexCoord2s(GLshort s, GLshort t);"	<apicall: void 'glTexCoord2s' (short short) module: 'opengl32.dll'>	^self externalCallFailed! !!OpenGL methodsFor: 'Keyword API' stamp: 'ar 12/4/2003 20:59'!glTexCoord2sv: v	"This method was automatically generated."	"void glTexCoord2sv(GLshort* v);"	<apicall: void 'glTexCoord2sv' (short*) module: 'opengl32.dll'>	^self externalCallFailed! !!OpenGL methodsFor: 'Keyword API' stamp: 'ar 12/4/2003 20:59'!glTexCoord3d: s with: t with: r	"This method was automatically generated."	"void glTexCoord3d(GLdouble s, GLdouble t, GLdouble r);"	<apicall: void 'glTexCoord3d' (double double double) module: 'opengl32.dll'>	^self externalCallFailed! !!OpenGL methodsFor: 'Keyword API' stamp: 'ar 12/4/2003 20:59'!glTexCoord3dv: v	"This method was automatically generated."	"void glTexCoord3dv(GLdouble* v);"	<apicall: void 'glTexCoord3dv' (double*) module: 'opengl32.dll'>	^self externalCallFailed! !!OpenGL methodsFor: 'Keyword API' stamp: 'ar 12/4/2003 20:59'!glTexCoord3f: s with: t with: r	"This method was automatically generated."	"void glTexCoord3f(GLfloat s, GLfloat t, GLfloat r);"	<apicall: void 'glTexCoord3f' (float float float) module: 'opengl32.dll'>	^self externalCallFailed! !!OpenGL methodsFor: 'Keyword API' stamp: 'ar 12/4/2003 20:59'!glTexCoord3fv: v	"This method was automatically generated."	"void glTexCoord3fv(GLfloat* v);"	<apicall: void 'glTexCoord3fv' (float*) module: 'opengl32.dll'>	^self externalCallFailed! !!OpenGL methodsFor: 'Keyword API' stamp: 'ar 12/4/2003 20:59'!glTexCoord3i: s with: t with: r	"This method was automatically generated."	"void glTexCoord3i(GLint s, GLint t, GLint r);"	<apicall: void 'glTexCoord3i' (long long long) module: 'opengl32.dll'>	^self externalCallFailed! !!OpenGL methodsFor: 'Keyword API' stamp: 'ar 12/4/2003 20:59'!glTexCoord3iv: v	"This method was automatically generated."	"void glTexCoord3iv(GLint* v);"	<apicall: void 'glTexCoord3iv' (long*) module: 'opengl32.dll'>	^self externalCallFailed! !!OpenGL methodsFor: 'Keyword API' stamp: 'ar 12/4/2003 20:59'!glTexCoord3s: s with: t with: r	"This method was automatically generated."	"void glTexCoord3s(GLshort s, GLshort t, GLshort r);"	<apicall: void 'glTexCoord3s' (short short short) module: 'opengl32.dll'>	^self externalCallFailed! !!OpenGL methodsFor: 'Keyword API' stamp: 'ar 12/4/2003 20:59'!glTexCoord3sv: v	"This method was automatically generated."	"void glTexCoord3sv(GLshort* v);"	<apicall: void 'glTexCoord3sv' (short*) module: 'opengl32.dll'>	^self externalCallFailed! !!OpenGL methodsFor: 'Keyword API' stamp: 'ar 12/4/2003 20:59'!glTexCoord4d: s with: t with: r with: q	"This method was automatically generated."	"void glTexCoord4d(GLdouble s, GLdouble t, GLdouble r, GLdouble q);"	<apicall: void 'glTexCoord4d' (double double double double) module: 'opengl32.dll'>	^self externalCallFailed! !!OpenGL methodsFor: 'Keyword API' stamp: 'ar 12/4/2003 20:59'!glTexCoord4dv: v	"This method was automatically generated."	"void glTexCoord4dv(GLdouble* v);"	<apicall: void 'glTexCoord4dv' (double*) module: 'opengl32.dll'>	^self externalCallFailed! !!OpenGL methodsFor: 'Keyword API' stamp: 'ar 12/4/2003 20:59'!glTexCoord4f: s with: t with: r with: q	"This method was automatically generated."	"void glTexCoord4f(GLfloat s, GLfloat t, GLfloat r, GLfloat q);"	<apicall: void 'glTexCoord4f' (float float float float) module: 'opengl32.dll'>	^self externalCallFailed! !!OpenGL methodsFor: 'Keyword API' stamp: 'ar 12/4/2003 20:59'!glTexCoord4fv: v	"This method was automatically generated."	"void glTexCoord4fv(GLfloat* v);"	<apicall: void 'glTexCoord4fv' (float*) module: 'opengl32.dll'>	^self externalCallFailed! !!OpenGL methodsFor: 'Keyword API' stamp: 'ar 12/4/2003 20:59'!glTexCoord4i: s with: t with: r with: q	"This method was automatically generated."	"void glTexCoord4i(GLint s, GLint t, GLint r, GLint q);"	<apicall: void 'glTexCoord4i' (long long long long) module: 'opengl32.dll'>	^self externalCallFailed! !!OpenGL methodsFor: 'Keyword API' stamp: 'ar 12/4/2003 20:59'!glTexCoord4iv: v	"This method was automatically generated."	"void glTexCoord4iv(GLint* v);"	<apicall: void 'glTexCoord4iv' (long*) module: 'opengl32.dll'>	^self externalCallFailed! !!OpenGL methodsFor: 'Keyword API' stamp: 'ar 12/4/2003 20:59'!glTexCoord4s: s with: t with: r with: q	"This method was automatically generated."	"void glTexCoord4s(GLshort s, GLshort t, GLshort r, GLshort q);"	<apicall: void 'glTexCoord4s' (short short short short) module: 'opengl32.dll'>	^self externalCallFailed! !!OpenGL methodsFor: 'Keyword API' stamp: 'ar 12/4/2003 20:59'!glTexCoord4sv: v	"This method was automatically generated."	"void glTexCoord4sv(GLshort* v);"	<apicall: void 'glTexCoord4sv' (short*) module: 'opengl32.dll'>	^self externalCallFailed! !!OpenGL methodsFor: 'Keyword API' stamp: 'ar 12/4/2003 20:59'!glTexCoordPointer: size with: type with: stride with: pointer	"This method was automatically generated."	"void glTexCoordPointer(GLint size, GLenum type, GLsizei stride, GLvoid* pointer);"	<apicall: void 'glTexCoordPointer' (long ulong long void*) module: 'opengl32.dll'>	^self externalCallFailed! !!OpenGL methodsFor: 'Keyword API' stamp: 'ar 12/4/2003 20:59'!glTexCoordPointerEXT: size with: type with: stride with: count with: pointer	"This method was automatically generated."	"void glTexCoordPointerEXT(GLint size, GLenum type, GLsizei stride, GLsizei count, GLvoid* pointer);"	<apicall: void 'glTexCoordPointerEXT' (long ulong long long void*) module: 'opengl32.dll'>	^self externalCallFailed! !!OpenGL methodsFor: 'Keyword API' stamp: 'ar 12/4/2003 20:59'!glTexEnvf: target with: pname with: param	"This method was automatically generated."	"void glTexEnvf(GLenum target, GLenum pname, GLfloat param);"	<apicall: void 'glTexEnvf' (ulong ulong float) module: 'opengl32.dll'>	^self externalCallFailed! !!OpenGL methodsFor: 'Keyword API' stamp: 'ar 12/4/2003 20:59'!glTexEnvfv: target with: pname with: params	"This method was automatically generated."	"void glTexEnvfv(GLenum target, GLenum pname, GLfloat* params);"	<apicall: void 'glTexEnvfv' (ulong ulong float*) module: 'opengl32.dll'>	^self externalCallFailed! !!OpenGL methodsFor: 'Keyword API' stamp: 'ar 12/4/2003 20:59'!glTexEnvi: target with: pname with: param	"This method was automatically generated."	"void glTexEnvi(GLenum target, GLenum pname, GLint param);"	<apicall: void 'glTexEnvi' (ulong ulong long) module: 'opengl32.dll'>	^self externalCallFailed! !!OpenGL methodsFor: 'Keyword API' stamp: 'ar 12/4/2003 20:59'!glTexEnviv: target with: pname with: params	"This method was automatically generated."	"void glTexEnviv(GLenum target, GLenum pname, GLint* params);"	<apicall: void 'glTexEnviv' (ulong ulong long*) module: 'opengl32.dll'>	^self externalCallFailed! !!OpenGL methodsFor: 'Keyword API' stamp: 'ar 12/4/2003 20:59'!glTexGend: coord with: pname with: param	"This method was automatically generated."	"void glTexGend(GLenum coord, GLenum pname, GLdouble param);"	<apicall: void 'glTexGend' (ulong ulong double) module: 'opengl32.dll'>	^self externalCallFailed! !!OpenGL methodsFor: 'Keyword API' stamp: 'ar 12/4/2003 20:59'!glTexGendv: coord with: pname with: params	"This method was automatically generated."	"void glTexGendv(GLenum coord, GLenum pname, GLdouble* params);"	<apicall: void 'glTexGendv' (ulong ulong double*) module: 'opengl32.dll'>	^self externalCallFailed! !!OpenGL methodsFor: 'Keyword API' stamp: 'ar 12/4/2003 20:59'!glTexGenf: coord with: pname with: param	"This method was automatically generated."	"void glTexGenf(GLenum coord, GLenum pname, GLfloat param);"	<apicall: void 'glTexGenf' (ulong ulong float) module: 'opengl32.dll'>	^self externalCallFailed! !!OpenGL methodsFor: 'Keyword API' stamp: 'ar 12/4/2003 20:59'!glTexGenfv: coord with: pname with: params	"This method was automatically generated."	"void glTexGenfv(GLenum coord, GLenum pname, GLfloat* params);"	<apicall: void 'glTexGenfv' (ulong ulong float*) module: 'opengl32.dll'>	^self externalCallFailed! !!OpenGL methodsFor: 'Keyword API' stamp: 'ar 12/4/2003 20:59'!glTexGeni: coord with: pname with: param	"This method was automatically generated."	"void glTexGeni(GLenum coord, GLenum pname, GLint param);"	<apicall: void 'glTexGeni' (ulong ulong long) module: 'opengl32.dll'>	^self externalCallFailed! !!OpenGL methodsFor: 'Keyword API' stamp: 'ar 12/4/2003 20:59'!glTexGeniv: coord with: pname with: params	"This method was automatically generated."	"void glTexGeniv(GLenum coord, GLenum pname, GLint* params);"	<apicall: void 'glTexGeniv' (ulong ulong long*) module: 'opengl32.dll'>	^self externalCallFailed! !!OpenGL methodsFor: 'Keyword API' stamp: 'ar 12/4/2003 20:59'!glTexImage1D: target with: level with: internalformat with: width with: border with: format with: type with: pixels	"This method was automatically generated."	"void glTexImage1D(GLenum target, GLint level, GLint internalformat, GLsizei width, GLint border, GLenum format, GLenum type, GLvoid* pixels);"	<apicall: void 'glTexImage1D' (ulong long long long long ulong ulong void*) module: 'opengl32.dll'>	^self externalCallFailed! !!OpenGL methodsFor: 'Keyword API' stamp: 'ar 12/4/2003 20:59'!glTexImage2D: target with: level with: internalformat with: width with: height with: border with: format with: type with: pixels	"This method was automatically generated."	"void glTexImage2D(GLenum target, GLint level, GLint internalformat, GLsizei width, GLsizei height, GLint border, GLenum format, GLenum type, GLvoid* pixels);"	<apicall: void 'glTexImage2D' (ulong long long long long long ulong ulong void*) module: 'opengl32.dll'>	^self externalCallFailed! !!OpenGL methodsFor: 'Keyword API' stamp: 'ar 12/4/2003 20:59'!glTexImage3D: target with: level with: internalformat with: width with: height with: depth with: border with: format with: type with: pixels	"This method was automatically generated."	"void glTexImage3D(GLenum target, GLint level, GLenum internalformat, GLsizei width, GLsizei height, GLsizei depth, GLint border, GLenum format, GLenum type, GLvoid* pixels);"	<apicall: void 'glTexImage3D' (ulong long ulong long long long long ulong ulong void*) module: 'opengl32.dll'>	^self externalCallFailed! !!OpenGL methodsFor: 'Keyword API' stamp: 'ar 12/4/2003 20:59'!glTexParameterf: target with: pname with: param	"This method was automatically generated."	"void glTexParameterf(GLenum target, GLenum pname, GLfloat param);"	<apicall: void 'glTexParameterf' (ulong ulong float) module: 'opengl32.dll'>	^self externalCallFailed! !!OpenGL methodsFor: 'Keyword API' stamp: 'ar 12/4/2003 20:59'!glTexParameterfv: target with: pname with: params	"This method was automatically generated."	"void glTexParameterfv(GLenum target, GLenum pname, GLfloat* params);"	<apicall: void 'glTexParameterfv' (ulong ulong float*) module: 'opengl32.dll'>	^self externalCallFailed! !!OpenGL methodsFor: 'Keyword API' stamp: 'ar 12/4/2003 20:59'!glTexParameteri: target with: pname with: param	"This method was automatically generated."	"void glTexParameteri(GLenum target, GLenum pname, GLint param);"	<apicall: void 'glTexParameteri' (ulong ulong long) module: 'opengl32.dll'>	^self externalCallFailed! !!OpenGL methodsFor: 'Keyword API' stamp: 'ar 12/4/2003 20:59'!glTexParameteriv: target with: pname with: params	"This method was automatically generated."	"void glTexParameteriv(GLenum target, GLenum pname, GLint* params);"	<apicall: void 'glTexParameteriv' (ulong ulong long*) module: 'opengl32.dll'>	^self externalCallFailed! !!OpenGL methodsFor: 'Keyword API' stamp: 'ar 12/4/2003 20:59'!glTexSubImage1D: target with: level with: xoffset with: width with: format with: type with: pixels	"This method was automatically generated."	"void glTexSubImage1D(GLenum target, GLint level, GLint xoffset, GLsizei width, GLenum format, GLenum type, GLvoid* pixels);"	<apicall: void 'glTexSubImage1D' (ulong long long long ulong ulong void*) module: 'opengl32.dll'>	^self externalCallFailed! !!OpenGL methodsFor: 'Keyword API' stamp: 'ar 12/4/2003 20:59'!glTexSubImage2D: target with: level with: xoffset with: yoffset with: width with: height with: format with: type with: pixels	"This method was automatically generated."	"void glTexSubImage2D(GLenum target, GLint level, GLint xoffset, GLint yoffset, GLsizei width, GLsizei height, GLenum format, GLenum type, GLvoid* pixels);"	<apicall: void 'glTexSubImage2D' (ulong long long long long long ulong ulong void*) module: 'opengl32.dll'>	^self externalCallFailed! !!OpenGL methodsFor: 'Keyword API' stamp: 'ar 12/4/2003 20:59'!glTexSubImage3D: target with: level with: xoffset with: yoffset with: zoffset with: width with: height with: depth with: format with: type with: pixels	"This method was automatically generated."	"void glTexSubImage3D(GLenum target, GLint level, GLint xoffset, GLint yoffset, GLint zoffset, GLsizei width, GLsizei height, GLsizei depth, GLenum format, GLenum type, GLvoid* pixels);"	<apicall: void 'glTexSubImage3D' (ulong long long long long long long long ulong ulong void*) module: 'opengl32.dll'>	^self externalCallFailed! !!OpenGL methodsFor: 'Keyword API' stamp: 'ar 12/4/2003 20:59'!glTranslated: x with: y with: z	"This method was automatically generated."	"void glTranslated(GLdouble x, GLdouble y, GLdouble z);"	<apicall: void 'glTranslated' (double double double) module: 'opengl32.dll'>	^self externalCallFailed! !!OpenGL methodsFor: 'Keyword API' stamp: 'ar 12/4/2003 20:59'!glTranslatef: x with: y with: z	"This method was automatically generated."	"void glTranslatef(GLfloat x, GLfloat y, GLfloat z);"	<apicall: void 'glTranslatef' (float float float) module: 'opengl32.dll'>	^self externalCallFailed! !!OpenGL methodsFor: 'Keyword API' stamp: 'ar 12/4/2003 20:59'!glVertex2d: x with: y	"This method was automatically generated."	"void glVertex2d(GLdouble x, GLdouble y);"	<apicall: void 'glVertex2d' (double double) module: 'opengl32.dll'>	^self externalCallFailed! !!OpenGL methodsFor: 'Keyword API' stamp: 'ar 12/4/2003 20:59'!glVertex2dv: v	"This method was automatically generated."	"void glVertex2dv(GLdouble* v);"	<apicall: void 'glVertex2dv' (double*) module: 'opengl32.dll'>	^self externalCallFailed! !!OpenGL methodsFor: 'Keyword API' stamp: 'ar 12/4/2003 20:59'!glVertex2f: x with: y	"This method was automatically generated."	"void glVertex2f(GLfloat x, GLfloat y);"	<apicall: void 'glVertex2f' (float float) module: 'opengl32.dll'>	^self externalCallFailed! !!OpenGL methodsFor: 'Keyword API' stamp: 'ar 12/4/2003 20:59'!glVertex2fv: v	"This method was automatically generated."	"void glVertex2fv(GLfloat* v);"	<apicall: void 'glVertex2fv' (float*) module: 'opengl32.dll'>	^self externalCallFailed! !!OpenGL methodsFor: 'Keyword API' stamp: 'ar 12/4/2003 20:59'!glVertex2i: x with: y	"This method was automatically generated."	"void glVertex2i(GLint x, GLint y);"	<apicall: void 'glVertex2i' (long long) module: 'opengl32.dll'>	^self externalCallFailed! !!OpenGL methodsFor: 'Keyword API' stamp: 'ar 12/4/2003 20:59'!glVertex2iv: v	"This method was automatically generated."	"void glVertex2iv(GLint* v);"	<apicall: void 'glVertex2iv' (long*) module: 'opengl32.dll'>	^self externalCallFailed! !!OpenGL methodsFor: 'Keyword API' stamp: 'ar 12/4/2003 20:59'!glVertex2s: x with: y	"This method was automatically generated."	"void glVertex2s(GLshort x, GLshort y);"	<apicall: void 'glVertex2s' (short short) module: 'opengl32.dll'>	^self externalCallFailed! !!OpenGL methodsFor: 'Keyword API' stamp: 'ar 12/4/2003 20:59'!glVertex2sv: v	"This method was automatically generated."	"void glVertex2sv(GLshort* v);"	<apicall: void 'glVertex2sv' (short*) module: 'opengl32.dll'>	^self externalCallFailed! !!OpenGL methodsFor: 'Keyword API' stamp: 'ar 12/4/2003 20:59'!glVertex3d: x with: y with: z	"This method was automatically generated."	"void glVertex3d(GLdouble x, GLdouble y, GLdouble z);"	<apicall: void 'glVertex3d' (double double double) module: 'opengl32.dll'>	^self externalCallFailed! !!OpenGL methodsFor: 'Keyword API' stamp: 'ar 12/4/2003 20:59'!glVertex3dv: v	"This method was automatically generated."	"void glVertex3dv(GLdouble* v);"	<apicall: void 'glVertex3dv' (double*) module: 'opengl32.dll'>	^self externalCallFailed! !!OpenGL methodsFor: 'Keyword API' stamp: 'ar 12/4/2003 20:59'!glVertex3f: x with: y with: z	"This method was automatically generated."	"void glVertex3f(GLfloat x, GLfloat y, GLfloat z);"	<apicall: void 'glVertex3f' (float float float) module: 'opengl32.dll'>	^self externalCallFailed! !!OpenGL methodsFor: 'Keyword API' stamp: 'ar 12/4/2003 20:59'!glVertex3fv: v	"This method was automatically generated."	"void glVertex3fv(GLfloat* v);"	<apicall: void 'glVertex3fv' (float*) module: 'opengl32.dll'>	^self externalCallFailed! !!OpenGL methodsFor: 'Keyword API' stamp: 'ar 12/4/2003 20:59'!glVertex3i: x with: y with: z	"This method was automatically generated."	"void glVertex3i(GLint x, GLint y, GLint z);"	<apicall: void 'glVertex3i' (long long long) module: 'opengl32.dll'>	^self externalCallFailed! !!OpenGL methodsFor: 'Keyword API' stamp: 'ar 12/4/2003 20:59'!glVertex3iv: v	"This method was automatically generated."	"void glVertex3iv(GLint* v);"	<apicall: void 'glVertex3iv' (long*) module: 'opengl32.dll'>	^self externalCallFailed! !!OpenGL methodsFor: 'Keyword API' stamp: 'ar 12/4/2003 20:59'!glVertex3s: x with: y with: z	"This method was automatically generated."	"void glVertex3s(GLshort x, GLshort y, GLshort z);"	<apicall: void 'glVertex3s' (short short short) module: 'opengl32.dll'>	^self externalCallFailed! !!OpenGL methodsFor: 'Keyword API' stamp: 'ar 12/4/2003 20:59'!glVertex3sv: v	"This method was automatically generated."	"void glVertex3sv(GLshort* v);"	<apicall: void 'glVertex3sv' (short*) module: 'opengl32.dll'>	^self externalCallFailed! !!OpenGL methodsFor: 'Keyword API' stamp: 'ar 12/4/2003 20:59'!glVertex4d: x with: y with: z with: w	"This method was automatically generated."	"void glVertex4d(GLdouble x, GLdouble y, GLdouble z, GLdouble w);"	<apicall: void 'glVertex4d' (double double double double) module: 'opengl32.dll'>	^self externalCallFailed! !!OpenGL methodsFor: 'Keyword API' stamp: 'ar 12/4/2003 20:59'!glVertex4dv: v	"This method was automatically generated."	"void glVertex4dv(GLdouble* v);"	<apicall: void 'glVertex4dv' (double*) module: 'opengl32.dll'>	^self externalCallFailed! !!OpenGL methodsFor: 'Keyword API' stamp: 'ar 12/4/2003 20:59'!glVertex4f: x with: y with: z with: w	"This method was automatically generated."	"void glVertex4f(GLfloat x, GLfloat y, GLfloat z, GLfloat w);"	<apicall: void 'glVertex4f' (float float float float) module: 'opengl32.dll'>	^self externalCallFailed! !!OpenGL methodsFor: 'Keyword API' stamp: 'ar 12/4/2003 20:59'!glVertex4fv: v	"This method was automatically generated."	"void glVertex4fv(GLfloat* v);"	<apicall: void 'glVertex4fv' (float*) module: 'opengl32.dll'>	^self externalCallFailed! !!OpenGL methodsFor: 'Keyword API' stamp: 'ar 12/4/2003 20:59'!glVertex4i: x with: y with: z with: w	"This method was automatically generated."	"void glVertex4i(GLint x, GLint y, GLint z, GLint w);"	<apicall: void 'glVertex4i' (long long long long) module: 'opengl32.dll'>	^self externalCallFailed! !!OpenGL methodsFor: 'Keyword API' stamp: 'ar 12/4/2003 20:59'!glVertex4iv: v	"This method was automatically generated."	"void glVertex4iv(GLint* v);"	<apicall: void 'glVertex4iv' (long*) module: 'opengl32.dll'>	^self externalCallFailed! !!OpenGL methodsFor: 'Keyword API' stamp: 'ar 12/4/2003 20:59'!glVertex4s: x with: y with: z with: w	"This method was automatically generated."	"void glVertex4s(GLshort x, GLshort y, GLshort z, GLshort w);"	<apicall: void 'glVertex4s' (short short short short) module: 'opengl32.dll'>	^self externalCallFailed! !!OpenGL methodsFor: 'Keyword API' stamp: 'ar 12/4/2003 20:59'!glVertex4sv: v	"This method was automatically generated."	"void glVertex4sv(GLshort* v);"	<apicall: void 'glVertex4sv' (short*) module: 'opengl32.dll'>	^self externalCallFailed! !!OpenGL methodsFor: 'Keyword API' stamp: 'ar 12/4/2003 20:59'!glVertexPointer: size with: type with: stride with: pointer	"This method was automatically generated."	"void glVertexPointer(GLint size, GLenum type, GLsizei stride, GLvoid* pointer);"	<apicall: void 'glVertexPointer' (long ulong long void*) module: 'opengl32.dll'>	^self externalCallFailed! !!OpenGL methodsFor: 'Keyword API' stamp: 'ar 12/4/2003 20:59'!glVertexPointerEXT: size with: type with: stride with: count with: pointer	"This method was automatically generated."	"void glVertexPointerEXT(GLint size, GLenum type, GLsizei stride, GLsizei count, GLvoid* pointer);"	<apicall: void 'glVertexPointerEXT' (long ulong long long void*) module: 'opengl32.dll'>	^self externalCallFailed! !!OpenGL methodsFor: 'Keyword API' stamp: 'ar 12/4/2003 20:59'!glViewport: x with: y with: width with: height	"This method was automatically generated."	"void glViewport(GLint x, GLint y, GLsizei width, GLsizei height);"	<apicall: void 'glViewport' (long long long long) module: 'opengl32.dll'>	^self externalCallFailed! !!OpenGL methodsFor: 'Keyword API' stamp: 'das 8/12/2004 11:28'!realglBegin: mode	"This method was automatically generated."	"void glBegin(GLenum mode);"	<apicall: void 'glBegin' (ulong) module: 'opengl32.dll'>	^self externalCallFailed! !!OpenGL methodsFor: 'extensions' stamp: 'ar 1/4/2003 00:18'!extensions	"answer a set of extension strings for this renderer"	^extensions ifNil:[		extensions := (self glGetString: GLExtensions) fromCString.		extensions := extensions findTokens: ' '.		extensions := extensions collect:[:str| str asSymbol].		extensions := IdentitySet withAll: extensions.		extensions].! !!OpenGL methodsFor: 'extensions' stamp: 'ar 1/4/2003 00:50'!glExtCallingConvention	"Answer the calling convention for extension functions"	^ExternalFunction callTypeCDecl! !!OpenGL methodsFor: 'extensions' stamp: 'ar 1/4/2003 00:50'!glExtGetProcAddress: aString	"Answer the function address for the given extension function"	^self subclassResponsibility! !!OpenGL methodsFor: 'extensions' stamp: 'DPR 7/18/2004 21:26'!hasExtension: extName	^self extensions includes: extName! !!OpenGL methodsFor: 'extensions' stamp: 'ar 1/4/2003 17:35'!loadExtension: extName	^glExt loadExtension: extName.! !!OpenGL methodsFor: 'rendering'!drawIndexed: type faces: faces vertices: vertices normals: vtxNormals colors: vtxColors texCoords: vtxTexCoords	vtxColors ifNotNil:[		self glEnableClientState: GLColorArray.		self glColorPointer: 4 with: GLFloat with: 16 with: vtxColors.	].	vtxNormals ifNotNil:[		self glEnableClientState: GLNormalArray.		self glNormalPointer: GLFloat with: 12 with: vtxNormals.	].	vtxTexCoords ifNotNil:[		self glEnableClientState: GLTextureCoordArray.		self glTexCoordPointer: 2 with: GLFloat with: 8 with: vtxTexCoords.	].	self glEnableClientState: GLVertexArray.	self glVertexPointer: 3 with: GLFloat with: 12 with: vertices.	self glDrawElements: type with: faces basicSize with: GLUnsignedInt with: faces.	vtxColors ifNotNil:[self glDisableClientState: GLColorArray].	vtxNormals ifNotNil:[self glDisableClientState: GLNormalArray].	vtxTexCoords ifNotNil:[self glDisableClientState: GLTextureCoordArray].	self glDisableClientState: GLVertexArray.! !!OpenGL methodsFor: 'rendering' stamp: 'das 8/12/2004 11:30'!drawIndexedQuadMesh: aMesh	^self drawIndexed:(forceWire ifTrue:[GLLineStrip] ifFalse:[GLQuads]) 			faces: aMesh zeroBasedFaces			vertices: aMesh vertices 			normals: aMesh vertexNormals 			colors: aMesh vertexColors 			texCoords: aMesh texCoords! !!OpenGL methodsFor: 'rendering' stamp: 'das 8/12/2004 11:30'!drawIndexedQuads: faces vertices: vertices normals: vtxNormals colors: vtxColors texCoords: vtxTexCoords		^self drawIndexed: (forceWire ifTrue:[GLLineStrip] ifFalse:[GLQuads]) faces: faces vertices: vertices normals: vtxNormals colors: vtxColors texCoords: vtxTexCoords! !!OpenGL methodsFor: 'rendering' stamp: 'das 8/12/2004 11:30'!drawIndexedTriangleMesh: aMesh	^self drawIndexed: (forceWire ifTrue:[GLLineStrip] ifFalse:[GLTriangles]) 			faces: aMesh zeroBasedFaces			vertices: aMesh vertices 			normals: aMesh vertexNormals 			colors: aMesh vertexColors 			texCoords: aMesh texCoords! !!OpenGL methodsFor: 'rendering' stamp: 'das 8/12/2004 11:31'!drawIndexedTriangles: faces vertices: vertices normals: vtxNormals colors: vtxColors texCoords: vtxTexCoords	^self drawIndexed: (forceWire ifTrue:[GLLineStrip] ifFalse:[GLTriangles]) faces: faces vertices: vertices normals: vtxNormals colors: vtxColors texCoords: vtxTexCoords! !!OpenGL methodsFor: 'rendering' stamp: 'das 7/28/2003 13:38'!setCull	self glEnable: GLCullFace.	self glFrontFace: self frontFace.! !!OpenGL methodsFor: 'GL_ARB_texture_compression' stamp: 'ar 9/29/2004 15:01'!glCompressedTexImage1DARB(target, level, internalformat, width, border, imageSize, data)	"This method was automatically generated"	^glExt glCompressedTexImage1DARB(target, level, internalformat, width, border, imageSize, data)! !!OpenGL methodsFor: 'GL_ARB_texture_compression' stamp: 'ar 9/29/2004 15:01'!glCompressedTexImage1DARB: target with: level with: internalformat with: width with: border with: imageSize with: data	"This method was automatically generated"	^glExt glCompressedTexImage1DARB: target with: level with: internalformat with: width with: border with: imageSize with: data! !!OpenGL methodsFor: 'GL_ARB_texture_compression' stamp: 'ar 9/29/2004 15:01'!glCompressedTexImage2DARB(target, level, internalformat, width, height, border, imageSize, data)	"This method was automatically generated"	^glExt glCompressedTexImage2DARB(target, level, internalformat, width, height, border, imageSize, data)! !!OpenGL methodsFor: 'GL_ARB_texture_compression' stamp: 'ar 9/29/2004 15:01'!glCompressedTexImage2DARB: target with: level with: internalformat with: width with: height with: border with: imageSize with: data	"This method was automatically generated"	^glExt glCompressedTexImage2DARB: target with: level with: internalformat with: width with: height with: border with: imageSize with: data! !!OpenGL methodsFor: 'GL_ARB_texture_compression' stamp: 'ar 9/29/2004 15:01'!glCompressedTexImage3DARB(target, level, internalformat, width, height, depth, border, imageSize, data)	"This method was automatically generated"	^glExt glCompressedTexImage3DARB(target, level, internalformat, width, height, depth, border, imageSize, data)! !!OpenGL methodsFor: 'GL_ARB_texture_compression' stamp: 'ar 9/29/2004 15:01'!glCompressedTexImage3DARB: target with: level with: internalformat with: width with: height with: depth with: border with: imageSize with: data	"This method was automatically generated"	^glExt glCompressedTexImage3DARB: target with: level with: internalformat with: width with: height with: depth with: border with: imageSize with: data! !!OpenGL methodsFor: 'GL_ARB_texture_compression' stamp: 'ar 9/29/2004 15:01'!glCompressedTexSubImage1DARB(target, level, xoffset, width, aFormat, imageSize, data)	"This method was automatically generated"	^glExt glCompressedTexSubImage1DARB(target, level, xoffset, width, aFormat, imageSize, data)! !!OpenGL methodsFor: 'GL_ARB_texture_compression' stamp: 'ar 9/29/2004 15:01'!glCompressedTexSubImage1DARB: target with: level with: xoffset with: width with: aFormat with: imageSize with: data	"This method was automatically generated"	^glExt glCompressedTexSubImage1DARB: target with: level with: xoffset with: width with: aFormat with: imageSize with: data! !!OpenGL methodsFor: 'GL_ARB_texture_compression' stamp: 'ar 9/29/2004 15:01'!glCompressedTexSubImage2DARB(target, level, xoffset, yoffset, width, height, aFormat, imageSize, data)	"This method was automatically generated"	^glExt glCompressedTexSubImage2DARB(target, level, xoffset, yoffset, width, height, aFormat, imageSize, data)! !!OpenGL methodsFor: 'GL_ARB_texture_compression' stamp: 'ar 9/29/2004 15:01'!glCompressedTexSubImage2DARB: target with: level with: xoffset with: yoffset with: width with: height with: aFormat with: imageSize with: data	"This method was automatically generated"	^glExt glCompressedTexSubImage2DARB: target with: level with: xoffset with: yoffset with: width with: height with: aFormat with: imageSize with: data! !!OpenGL methodsFor: 'GL_ARB_texture_compression' stamp: 'ar 9/29/2004 15:01'!glCompressedTexSubImage3DARB(target, level, xoffset, yoffset, zoffset, width, height, depth, aFormat, imageSize, data)	"This method was automatically generated"	^glExt glCompressedTexSubImage3DARB(target, level, xoffset, yoffset, zoffset, width, height, depth, aFormat, imageSize, data)! !!OpenGL methodsFor: 'GL_ARB_texture_compression' stamp: 'ar 9/29/2004 15:01'!glCompressedTexSubImage3DARB: target with: level with: xoffset with: yoffset with: zoffset with: width with: height with: depth with: aFormat with: imageSize with: data	"This method was automatically generated"	^glExt glCompressedTexSubImage3DARB: target with: level with: xoffset with: yoffset with: zoffset with: width with: height with: depth with: aFormat with: imageSize with: data! !!OpenGL methodsFor: 'GL_ARB_texture_compression' stamp: 'ar 9/29/2004 15:01'!glGetCompressedTexImageARB(target, lod, img)	"This method was automatically generated"	^glExt glGetCompressedTexImageARB(target, lod, img)! !!OpenGL methodsFor: 'GL_ARB_texture_compression' stamp: 'ar 9/29/2004 15:01'!glGetCompressedTexImageARB: target with: lod with: img	"This method was automatically generated"	^glExt glGetCompressedTexImageARB: target with: lod with: img! !!OpenGL methodsFor: 'initialize' stamp: 'ar 10/1/2004 14:53'!beginFrame	textureManager beginFrame.	self glPixelStorei: GLUnpackAlignment with: 4.! !!OpenGL methodsFor: 'initialize' stamp: 'ar 9/30/2004 16:51'!beginFrame: aTimeStamp	timeStamp := aTimeStamp.	self beginFrame! !!OpenGL methodsFor: 'initialize' stamp: 'ar 9/29/2004 15:08'!beginMorphicOverlay: bounds	"Set up gl to provide overlay drawing - this is done in pixel coordinates"	self glMatrixMode: GLProjection.	self glPushMatrix.	self glLoadIdentity.	self glMatrixMode: GLModelview.	self glPushMatrix.	self glLoadIdentity.	self glTranslated: -1 with: 1 with: 0.0.	self glScaled: (2.0 / bounds width) with: (-2.0 / bounds height) with: 1.0.	self glDisable: GLDepthTest.	self glEnable: GLBlend.	self glBlendFunc: GLSrcAlpha with: GLOneMinusSrcAlpha.! !!OpenGL methodsFor: 'initialize' stamp: 'ar 9/6/2002 01:44'!cleanup	"Clean up any unused display list"	| any listRange |	any := false.	glListRegistry associationsDo:[:assoc|		assoc key == nil ifTrue:[			listRange := assoc value.			self glDeleteLists: listRange first with: listRange last.			any := true].	].	any ifTrue:[glListRegistry finalizeValues].! !!OpenGL methodsFor: 'initialize' stamp: 'ar 9/5/2002 21:53'!defaultFlags	"Answer the flags to use by default when creating a new renderer.	By default we request either software or hardware renderer with no specific flags."	^B3DHardwareRenderer + B3DSoftwareRenderer + B3DStencilBuffer! !!OpenGL methodsFor: 'initialize' stamp: 'das 3/12/2004 12:44'!destroy	glExt ifNotNil:[		glExt ogl: nil.		glExt := nil].	super destroy.! !!OpenGL methodsFor: 'initialize' stamp: 'ar 10/1/2004 14:53'!endFrame	textureManager endFrame.	self cleanup.! !!OpenGL methodsFor: 'initialize' stamp: 'das 8/26/2004 17:52'!endMorphicOverlay	"Set up gl to provide overlay drawing - this is done in pixel coordinates"	self glDisable: GLBlend.	self glMatrixMode: GLModelview.	self glPopMatrix.	self glMatrixMode: GLProjection.	self glPopMatrix.	self glMatrixMode: GLModelview.! !!OpenGL methodsFor: 'initialize' stamp: 'das 9/23/2002 14:48'!initFrustum: angle bounds: bounds zNear: nVal zFar: fVal	| aspect |	aspect _ (bounds width/bounds height) asFloat.  	self glMatrixMode: GLProjection.  	self glLoadIdentity.	self gluPerspective:angle aspect: aspect zNear: nVal zFar: fVal.  	self glMatrixMode: GLModelview.  	self glLoadIdentity.  	self glViewport:bounds left with:bounds top with: bounds width with: bounds height.! !!OpenGL methodsFor: 'initialize' stamp: 'ar 10/1/2004 15:02'!initialize	"the following makes sure that the FFI link library name is set correctly for this platform"	self privateInstallLibrary: self openGLLibraryName.	textureManager := OGLTextureManager new initialize: self.	glListRegistry := WeakIdentityKeyDictionary new.	fontManager := OGLFontManager new initialize: self.	timeStamp _ 0.	frontFace _ GLCcw.	currentPortal _ nil.	maxPortalDepth _ 5. "arbitrary value, probably should be less than 8."	changeTexture _ true.	test _ false.	instance _ TeaTime nowAsMilliseconds. "timestamp of this ogl instance"	isMirror _ false.	inPortal3D _ false.	self forceWire: false.	^ super initialize.! !!OpenGL methodsFor: 'initialize' stamp: 'das 3/12/2004 14:18'!initializeIn: bounds	super initializeIn: bounds.	handle ifNotNil:[glExt := OGLExtManager new ogl: self].	^handle ifNotNil:[self]! !!OpenGL methodsFor: 'initialize'!makeCurrent	"Hack!! We can't make it explicitly but getting a property requires to have me current, so..."	self primRender: handle getProperty: 1.! !!OpenGL methodsFor: 'initialize' stamp: 'ar 12/4/2003 20:50'!openGLLibraryName	^self subclassResponsibility! !!OpenGL methodsFor: 'GL_EXT_compiled_vertex_array' stamp: 'ar 9/29/2004 15:01'!glLockArraysEXT(first, count)	"This method was automatically generated"	^glExt glLockArraysEXT(first, count)! !!OpenGL methodsFor: 'GL_EXT_compiled_vertex_array' stamp: 'ar 9/29/2004 15:01'!glLockArraysEXT: first with: count	"This method was automatically generated"	^glExt glLockArraysEXT: first with: count! !!OpenGL methodsFor: 'GL_EXT_compiled_vertex_array' stamp: 'ar 9/29/2004 15:01'!glUnlockArraysEXT	"This method was automatically generated"	^glExt glUnlockArraysEXT! !!OpenGL methodsFor: 'GL_EXT_compiled_vertex_array' stamp: 'ar 9/29/2004 15:01'!glUnlockArraysEXT()	"This method was automatically generated"	^glExt glUnlockArraysEXT()! !!OpenGL methodsFor: 'OpenGL API' stamp: 'ar 12/4/2003 20:57'!glAccum(op, value)	"This method was automatically generated."	"void glAccum(GLenum op, GLfloat value);"	<apicall: void 'glAccum' (ulong float) module: 'opengl32.dll'>	^self externalCallFailed! !!OpenGL methodsFor: 'OpenGL API' stamp: 'ar 12/4/2003 20:57'!glActiveTextureARB(texture)	"This method was automatically generated."	"void glActiveTextureARB(GLenum texture);"	<apicall: void 'glActiveTextureARB' (ulong) module: 'opengl32.dll'>	^self externalCallFailed! !!OpenGL methodsFor: 'OpenGL API' stamp: 'ar 12/4/2003 20:57'!glAlphaFunc(func, ref)	"This method was automatically generated."	"void glAlphaFunc(GLenum func, GLclampf ref);"	<apicall: void 'glAlphaFunc' (ulong float) module: 'opengl32.dll'>	^self externalCallFailed! !!OpenGL methodsFor: 'OpenGL API' stamp: 'ar 12/4/2003 20:57'!glAreTexturesResident(n, textures, residences)	"This method was automatically generated."	"GLboolean glAreTexturesResident(GLsizei n, GLuint* textures, GLboolean* residences);"	<apicall: bool 'glAreTexturesResident' (long ulong* ulong*) module: 'opengl32.dll'>	^self externalCallFailed! !!OpenGL methodsFor: 'OpenGL API' stamp: 'ar 12/4/2003 20:57'!glAreTexturesResidentEXT(n, textures, residences)	"This method was automatically generated."	"GLboolean glAreTexturesResidentEXT(GLsizei n, GLuint* textures, GLboolean* residences);"	<apicall: bool 'glAreTexturesResidentEXT' (long ulong* ulong*) module: 'opengl32.dll'>	^self externalCallFailed! !!OpenGL methodsFor: 'OpenGL API' stamp: 'ar 12/4/2003 20:57'!glArrayElement(i)	"This method was automatically generated."	"void glArrayElement(GLint i);"	<apicall: void 'glArrayElement' (long) module: 'opengl32.dll'>	^self externalCallFailed! !!OpenGL methodsFor: 'OpenGL API' stamp: 'ar 12/4/2003 20:57'!glArrayElementEXT(i)	"This method was automatically generated."	"void glArrayElementEXT(GLint i);"	<apicall: void 'glArrayElementEXT' (long) module: 'opengl32.dll'>	^self externalCallFailed! !!OpenGL methodsFor: 'OpenGL API' stamp: 'das 8/12/2004 11:29'!glBegin(mode)	forceWire ifTrue:[		self realglBegin: GLLineStrip.]	ifFalse:[		self realglBegin: mode.].! !!OpenGL methodsFor: 'OpenGL API' stamp: 'das 8/12/2004 11:29'!glBegin: mode	forceWire ifTrue:[		self realglBegin: GLLineStrip.]	ifFalse:[		self realglBegin: mode.].! !!OpenGL methodsFor: 'OpenGL API' stamp: 'ar 12/4/2003 20:57'!glBindTexture(target, texture)	"This method was automatically generated."	"void glBindTexture(GLenum target, GLuint texture);"	<apicall: void 'glBindTexture' (ulong ulong) module: 'opengl32.dll'>	^self externalCallFailed! !!OpenGL methodsFor: 'OpenGL API' stamp: 'ar 12/4/2003 20:57'!glBitmap(width, height, xorig, yorig, xmove, ymove, bitmap)	"This method was automatically generated."	"void glBitmap(GLsizei width, GLsizei height, GLfloat xorig, GLfloat yorig, GLfloat xmove, GLfloat ymove, GLubyte* bitmap);"	<apicall: void 'glBitmap' (long long float float float float void*) module: 'opengl32.dll'>	^self externalCallFailed! !!OpenGL methodsFor: 'OpenGL API' stamp: 'ar 12/4/2003 20:57'!glBlendColor(red, green, blue, alpha)	"This method was automatically generated."	"void glBlendColor(GLclampf red, GLclampf green, GLclampf blue, GLclampf alpha);"	<apicall: void 'glBlendColor' (float float float float) module: 'opengl32.dll'>	^self externalCallFailed! !!OpenGL methodsFor: 'OpenGL API' stamp: 'ar 12/4/2003 20:57'!glBlendEquation(mode)	"This method was automatically generated."	"void glBlendEquation(GLenum mode);"	<apicall: void 'glBlendEquation' (ulong) module: 'opengl32.dll'>	^self externalCallFailed! !!OpenGL methodsFor: 'OpenGL API' stamp: 'ar 12/4/2003 20:57'!glBlendFunc(sfactor, dfactor)	"This method was automatically generated."	"void glBlendFunc(GLenum sfactor, GLenum dfactor);"	<apicall: void 'glBlendFunc' (ulong ulong) module: 'opengl32.dll'>	^self externalCallFailed! !!OpenGL methodsFor: 'OpenGL API' stamp: 'ar 12/4/2003 20:57'!glCallList(list)	"This method was automatically generated."	"void glCallList(GLuint list);"	<apicall: void 'glCallList' (ulong) module: 'opengl32.dll'>	^self externalCallFailed! !!OpenGL methodsFor: 'OpenGL API' stamp: 'ar 12/4/2003 20:57'!glCallLists(n, type, lists)	"This method was automatically generated."	"void glCallLists(GLsizei n, GLenum type, GLvoid* lists);"	<apicall: void 'glCallLists' (long ulong void*) module: 'opengl32.dll'>	^self externalCallFailed! !!OpenGL methodsFor: 'OpenGL API' stamp: 'ar 12/4/2003 20:57'!glClear(mask)	"This method was automatically generated."	"void glClear(GLbitfield mask);"	<apicall: void 'glClear' (ulong) module: 'opengl32.dll'>	^self externalCallFailed! !!OpenGL methodsFor: 'OpenGL API' stamp: 'ar 12/4/2003 20:57'!glClearAccum(red, green, blue, alpha)	"This method was automatically generated."	"void glClearAccum(GLfloat red, GLfloat green, GLfloat blue, GLfloat alpha);"	<apicall: void 'glClearAccum' (float float float float) module: 'opengl32.dll'>	^self externalCallFailed! !!OpenGL methodsFor: 'OpenGL API' stamp: 'ar 12/4/2003 20:57'!glClearColor(red, green, blue, alpha)	"This method was automatically generated."	"void glClearColor(GLclampf red, GLclampf green, GLclampf blue, GLclampf alpha);"	<apicall: void 'glClearColor' (float float float float) module: 'opengl32.dll'>	^self externalCallFailed! !!OpenGL methodsFor: 'OpenGL API' stamp: 'ar 12/4/2003 20:57'!glClearDepth(depth)	"This method was automatically generated."	"void glClearDepth(GLclampd depth);"	<apicall: void 'glClearDepth' (double) module: 'opengl32.dll'>	^self externalCallFailed! !!OpenGL methodsFor: 'OpenGL API' stamp: 'ar 12/4/2003 20:57'!glClearIndex(c)	"This method was automatically generated."	"void glClearIndex(GLfloat c);"	<apicall: void 'glClearIndex' (float) module: 'opengl32.dll'>	^self externalCallFailed! !!OpenGL methodsFor: 'OpenGL API' stamp: 'ar 12/4/2003 20:57'!glClearStencil(s)	"This method was automatically generated."	"void glClearStencil(GLint s);"	<apicall: void 'glClearStencil' (long) module: 'opengl32.dll'>	^self externalCallFailed! !!OpenGL methodsFor: 'OpenGL API' stamp: 'ar 12/4/2003 20:57'!glClientActiveTextureARB(texture)	"This method was automatically generated."	"void glClientActiveTextureARB(GLenum texture);"	<apicall: void 'glClientActiveTextureARB' (ulong) module: 'opengl32.dll'>	^self externalCallFailed! !!OpenGL methodsFor: 'OpenGL API' stamp: 'ar 12/4/2003 20:57'!glClipPlane(plane, equation)	"This method was automatically generated."	"void glClipPlane(GLenum plane, GLdouble* equation);"	<apicall: void 'glClipPlane' (ulong double*) module: 'opengl32.dll'>	^self externalCallFailed! !!OpenGL methodsFor: 'OpenGL API' stamp: 'ar 12/4/2003 20:57'!glColor3b(red, green, blue)	"This method was automatically generated."	"void glColor3b(GLbyte red, GLbyte green, GLbyte blue);"	<apicall: void 'glColor3b' (byte byte byte) module: 'opengl32.dll'>	^self externalCallFailed! !!OpenGL methodsFor: 'OpenGL API' stamp: 'ar 12/4/2003 20:57'!glColor3bv(v)	"This method was automatically generated."	"void glColor3bv(GLbyte* v);"	<apicall: void 'glColor3bv' (byte*) module: 'opengl32.dll'>	^self externalCallFailed! !!OpenGL methodsFor: 'OpenGL API' stamp: 'ar 12/4/2003 20:57'!glColor3d(red, green, blue)	"This method was automatically generated."	"void glColor3d(GLdouble red, GLdouble green, GLdouble blue);"	<apicall: void 'glColor3d' (double double double) module: 'opengl32.dll'>	^self externalCallFailed! !!OpenGL methodsFor: 'OpenGL API' stamp: 'ar 12/4/2003 20:57'!glColor3dv(v)	"This method was automatically generated."	"void glColor3dv(GLdouble* v);"	<apicall: void 'glColor3dv' (double*) module: 'opengl32.dll'>	^self externalCallFailed! !!OpenGL methodsFor: 'OpenGL API' stamp: 'ar 12/4/2003 20:57'!glColor3f(red, green, blue)	"This method was automatically generated."	"void glColor3f(GLfloat red, GLfloat green, GLfloat blue);"	<apicall: void 'glColor3f' (float float float) module: 'opengl32.dll'>	^self externalCallFailed! !!OpenGL methodsFor: 'OpenGL API' stamp: 'ar 12/4/2003 20:57'!glColor3fv(v)	"This method was automatically generated."	"void glColor3fv(GLfloat* v);"	<apicall: void 'glColor3fv' (float*) module: 'opengl32.dll'>	^self externalCallFailed! !!OpenGL methodsFor: 'OpenGL API' stamp: 'ar 12/4/2003 20:57'!glColor3i(red, green, blue)	"This method was automatically generated."	"void glColor3i(GLint red, GLint green, GLint blue);"	<apicall: void 'glColor3i' (long long long) module: 'opengl32.dll'>	^self externalCallFailed! !!OpenGL methodsFor: 'OpenGL API' stamp: 'ar 12/4/2003 20:57'!glColor3iv(v)	"This method was automatically generated."	"void glColor3iv(GLint* v);"	<apicall: void 'glColor3iv' (long*) module: 'opengl32.dll'>	^self externalCallFailed! !!OpenGL methodsFor: 'OpenGL API' stamp: 'ar 12/4/2003 20:57'!glColor3s(red, green, blue)	"This method was automatically generated."	"void glColor3s(GLshort red, GLshort green, GLshort blue);"	<apicall: void 'glColor3s' (short short short) module: 'opengl32.dll'>	^self externalCallFailed! !!OpenGL methodsFor: 'OpenGL API' stamp: 'ar 12/4/2003 20:57'!glColor3sv(v)	"This method was automatically generated."	"void glColor3sv(GLshort* v);"	<apicall: void 'glColor3sv' (short*) module: 'opengl32.dll'>	^self externalCallFailed! !!OpenGL methodsFor: 'OpenGL API' stamp: 'ar 12/4/2003 20:57'!glColor3ub(red, green, blue)	"This method was automatically generated."	"void glColor3ub(GLubyte red, GLubyte green, GLubyte blue);"	<apicall: void 'glColor3ub' (byte byte byte) module: 'opengl32.dll'>	^self externalCallFailed! !!OpenGL methodsFor: 'OpenGL API' stamp: 'ar 12/4/2003 20:57'!glColor3ubv(v)	"This method was automatically generated."	"void glColor3ubv(GLubyte* v);"	<apicall: void 'glColor3ubv' (byte*) module: 'opengl32.dll'>	^self externalCallFailed! !!OpenGL methodsFor: 'OpenGL API' stamp: 'ar 12/4/2003 20:57'!glColor3ui(red, green, blue)	"This method was automatically generated."	"void glColor3ui(GLuint red, GLuint green, GLuint blue);"	<apicall: void 'glColor3ui' (ulong ulong ulong) module: 'opengl32.dll'>	^self externalCallFailed! !!OpenGL methodsFor: 'OpenGL API' stamp: 'ar 12/4/2003 20:57'!glColor3uiv(v)	"This method was automatically generated."	"void glColor3uiv(GLuint* v);"	<apicall: void 'glColor3uiv' (ulong*) module: 'opengl32.dll'>	^self externalCallFailed! !!OpenGL methodsFor: 'OpenGL API' stamp: 'ar 12/4/2003 20:57'!glColor3us(red, green, blue)	"This method was automatically generated."	"void glColor3us(GLushort red, GLushort green, GLushort blue);"	<apicall: void 'glColor3us' (ushort ushort ushort) module: 'opengl32.dll'>	^self externalCallFailed! !!OpenGL methodsFor: 'OpenGL API' stamp: 'ar 12/4/2003 20:57'!glColor3usv(v)	"This method was automatically generated."	"void glColor3usv(GLushort* v);"	<apicall: void 'glColor3usv' (ushort*) module: 'opengl32.dll'>	^self externalCallFailed! !!OpenGL methodsFor: 'OpenGL API' stamp: 'ar 12/4/2003 20:57'!glColor4b(red, green, blue, alpha)	"This method was automatically generated."	"void glColor4b(GLbyte red, GLbyte green, GLbyte blue, GLbyte alpha);"	<apicall: void 'glColor4b' (byte byte byte byte) module: 'opengl32.dll'>	^self externalCallFailed! !!OpenGL methodsFor: 'OpenGL API' stamp: 'ar 12/4/2003 20:57'!glColor4bv(v)	"This method was automatically generated."	"void glColor4bv(GLbyte* v);"	<apicall: void 'glColor4bv' (byte*) module: 'opengl32.dll'>	^self externalCallFailed! !!OpenGL methodsFor: 'OpenGL API' stamp: 'ar 12/4/2003 20:57'!glColor4d(red, green, blue, alpha)	"This method was automatically generated."	"void glColor4d(GLdouble red, GLdouble green, GLdouble blue, GLdouble alpha);"	<apicall: void 'glColor4d' (double double double double) module: 'opengl32.dll'>	^self externalCallFailed! !!OpenGL methodsFor: 'OpenGL API' stamp: 'ar 12/4/2003 20:57'!glColor4dv(v)	"This method was automatically generated."	"void glColor4dv(GLdouble* v);"	<apicall: void 'glColor4dv' (double*) module: 'opengl32.dll'>	^self externalCallFailed! !!OpenGL methodsFor: 'OpenGL API' stamp: 'ar 12/4/2003 20:57'!glColor4f(red, green, blue, alpha)	"This method was automatically generated."	"void glColor4f(GLfloat red, GLfloat green, GLfloat blue, GLfloat alpha);"	<apicall: void 'glColor4f' (float float float float) module: 'opengl32.dll'>	^self externalCallFailed! !!OpenGL methodsFor: 'OpenGL API' stamp: 'ar 12/4/2003 20:57'!glColor4fv(v)	"This method was automatically generated."	"void glColor4fv(GLfloat* v);"	<apicall: void 'glColor4fv' (float*) module: 'opengl32.dll'>	^self externalCallFailed! !!OpenGL methodsFor: 'OpenGL API' stamp: 'ar 12/4/2003 20:57'!glColor4i(red, green, blue, alpha)	"This method was automatically generated."	"void glColor4i(GLint red, GLint green, GLint blue, GLint alpha);"	<apicall: void 'glColor4i' (long long long long) module: 'opengl32.dll'>	^self externalCallFailed! !!OpenGL methodsFor: 'OpenGL API' stamp: 'ar 12/4/2003 20:57'!glColor4iv(v)	"This method was automatically generated."	"void glColor4iv(GLint* v);"	<apicall: void 'glColor4iv' (long*) module: 'opengl32.dll'>	^self externalCallFailed! !!OpenGL methodsFor: 'OpenGL API' stamp: 'ar 12/4/2003 20:57'!glColor4s(red, green, blue, alpha)	"This method was automatically generated."	"void glColor4s(GLshort red, GLshort green, GLshort blue, GLshort alpha);"	<apicall: void 'glColor4s' (short short short short) module: 'opengl32.dll'>	^self externalCallFailed! !!OpenGL methodsFor: 'OpenGL API' stamp: 'ar 12/4/2003 20:57'!glColor4sv(v)	"This method was automatically generated."	"void glColor4sv(GLshort* v);"	<apicall: void 'glColor4sv' (short*) module: 'opengl32.dll'>	^self externalCallFailed! !!OpenGL methodsFor: 'OpenGL API' stamp: 'ar 12/4/2003 20:57'!glColor4ub(red, green, blue, alpha)	"This method was automatically generated."	"void glColor4ub(GLubyte red, GLubyte green, GLubyte blue, GLubyte alpha);"	<apicall: void 'glColor4ub' (byte byte byte byte) module: 'opengl32.dll'>	^self externalCallFailed! !!OpenGL methodsFor: 'OpenGL API' stamp: 'ar 12/4/2003 20:57'!glColor4ubv(v)	"This method was automatically generated."	"void glColor4ubv(GLubyte* v);"	<apicall: void 'glColor4ubv' (byte*) module: 'opengl32.dll'>	^self externalCallFailed! !!OpenGL methodsFor: 'OpenGL API' stamp: 'ar 12/4/2003 20:57'!glColor4ui(red, green, blue, alpha)	"This method was automatically generated."	"void glColor4ui(GLuint red, GLuint green, GLuint blue, GLuint alpha);"	<apicall: void 'glColor4ui' (ulong ulong ulong ulong) module: 'opengl32.dll'>	^self externalCallFailed! !!OpenGL methodsFor: 'OpenGL API' stamp: 'ar 12/4/2003 20:57'!glColor4uiv(v)	"This method was automatically generated."	"void glColor4uiv(GLuint* v);"	<apicall: void 'glColor4uiv' (ulong*) module: 'opengl32.dll'>	^self externalCallFailed! !!OpenGL methodsFor: 'OpenGL API' stamp: 'ar 12/4/2003 20:57'!glColor4us(red, green, blue, alpha)	"This method was automatically generated."	"void glColor4us(GLushort red, GLushort green, GLushort blue, GLushort alpha);"	<apicall: void 'glColor4us' (ushort ushort ushort ushort) module: 'opengl32.dll'>	^self externalCallFailed! !!OpenGL methodsFor: 'OpenGL API' stamp: 'ar 12/4/2003 20:57'!glColor4usv(v)	"This method was automatically generated."	"void glColor4usv(GLushort* v);"	<apicall: void 'glColor4usv' (ushort*) module: 'opengl32.dll'>	^self externalCallFailed! !!OpenGL methodsFor: 'OpenGL API' stamp: 'ar 12/4/2003 20:57'!glColorMask(red, green, blue, alpha)	"This method was automatically generated."	"void glColorMask(GLboolean red, GLboolean green, GLboolean blue, GLboolean alpha);"	<apicall: void 'glColorMask' (bool bool bool bool) module: 'opengl32.dll'>	^self externalCallFailed! !!OpenGL methodsFor: 'OpenGL API' stamp: 'ar 12/4/2003 20:57'!glColorMaterial(face, mode)	"This method was automatically generated."	"void glColorMaterial(GLenum face, GLenum mode);"	<apicall: void 'glColorMaterial' (ulong ulong) module: 'opengl32.dll'>	^self externalCallFailed! !!OpenGL methodsFor: 'OpenGL API' stamp: 'ar 12/4/2003 20:57'!glColorPointer(size, type, stride, pointer)	"This method was automatically generated."	"void glColorPointer(GLint size, GLenum type, GLsizei stride, GLvoid* pointer);"	<apicall: void 'glColorPointer' (long ulong long void*) module: 'opengl32.dll'>	^self externalCallFailed! !!OpenGL methodsFor: 'OpenGL API' stamp: 'ar 12/4/2003 20:57'!glColorPointerEXT(size, type, stride, count, pointer)	"This method was automatically generated."	"void glColorPointerEXT(GLint size, GLenum type, GLsizei stride, GLsizei count, GLvoid* pointer);"	<apicall: void 'glColorPointerEXT' (long ulong long long void*) module: 'opengl32.dll'>	^self externalCallFailed! !!OpenGL methodsFor: 'OpenGL API' stamp: 'ar 12/4/2003 20:57'!glColorSubTable(target, start, count, format, type, data)	"This method was automatically generated."	"void glColorSubTable(GLenum target, GLsizei start, GLsizei count, GLenum format, GLenum type, GLvoid* data);"	<apicall: void 'glColorSubTable' (ulong long long ulong ulong void*) module: 'opengl32.dll'>	^self externalCallFailed! !!OpenGL methodsFor: 'OpenGL API' stamp: 'ar 12/4/2003 20:57'!glColorTable(target, internalformat, width, format, type, table)	"This method was automatically generated."	"void glColorTable(GLenum target, GLenum internalformat, GLsizei width, GLenum format, GLenum type, GLvoid* table);"	<apicall: void 'glColorTable' (ulong ulong long ulong ulong void*) module: 'opengl32.dll'>	^self externalCallFailed! !!OpenGL methodsFor: 'OpenGL API' stamp: 'ar 12/4/2003 20:57'!glColorTableParameterfv(target, pname, params)	"This method was automatically generated."	"void glColorTableParameterfv(GLenum target, GLenum pname, GLfloat* params);"	<apicall: void 'glColorTableParameterfv' (ulong ulong float*) module: 'opengl32.dll'>	^self externalCallFailed! !!OpenGL methodsFor: 'OpenGL API' stamp: 'ar 12/4/2003 20:57'!glColorTableParameteriv(target, pname, params)	"This method was automatically generated."	"void glColorTableParameteriv(GLenum target, GLenum pname, GLint* params);"	<apicall: void 'glColorTableParameteriv' (ulong ulong long*) module: 'opengl32.dll'>	^self externalCallFailed! !!OpenGL methodsFor: 'OpenGL API' stamp: 'ar 12/4/2003 20:57'!glConvolutionFilter1D(target, internalformat, width, format, type, image)	"This method was automatically generated."	"void glConvolutionFilter1D(GLenum target, GLenum internalformat, GLsizei width, GLenum format, GLenum type, GLvoid* image);"	<apicall: void 'glConvolutionFilter1D' (ulong ulong long ulong ulong void*) module: 'opengl32.dll'>	^self externalCallFailed! !!OpenGL methodsFor: 'OpenGL API' stamp: 'ar 12/4/2003 20:57'!glConvolutionFilter2D(target, internalformat, width, height, format, type, image)	"This method was automatically generated."	"void glConvolutionFilter2D(GLenum target, GLenum internalformat, GLsizei width, GLsizei height, GLenum format, GLenum type, GLvoid* image);"	<apicall: void 'glConvolutionFilter2D' (ulong ulong long long ulong ulong void*) module: 'opengl32.dll'>	^self externalCallFailed! !!OpenGL methodsFor: 'OpenGL API' stamp: 'ar 12/4/2003 20:57'!glConvolutionParameterf(target, pname, params)	"This method was automatically generated."	"void glConvolutionParameterf(GLenum target, GLenum pname, GLfloat params);"	<apicall: void 'glConvolutionParameterf' (ulong ulong float) module: 'opengl32.dll'>	^self externalCallFailed! !!OpenGL methodsFor: 'OpenGL API' stamp: 'ar 12/4/2003 20:57'!glConvolutionParameterfv(target, pname, params)	"This method was automatically generated."	"void glConvolutionParameterfv(GLenum target, GLenum pname, GLfloat* params);"	<apicall: void 'glConvolutionParameterfv' (ulong ulong float*) module: 'opengl32.dll'>	^self externalCallFailed! !!OpenGL methodsFor: 'OpenGL API' stamp: 'ar 12/4/2003 20:57'!glConvolutionParameteri(target, pname, params)	"This method was automatically generated."	"void glConvolutionParameteri(GLenum target, GLenum pname, GLint params);"	<apicall: void 'glConvolutionParameteri' (ulong ulong long) module: 'opengl32.dll'>	^self externalCallFailed! !!OpenGL methodsFor: 'OpenGL API' stamp: 'ar 12/4/2003 20:57'!glConvolutionParameteriv(target, pname, params)	"This method was automatically generated."	"void glConvolutionParameteriv(GLenum target, GLenum pname, GLint* params);"	<apicall: void 'glConvolutionParameteriv' (ulong ulong long*) module: 'opengl32.dll'>	^self externalCallFailed! !!OpenGL methodsFor: 'OpenGL API' stamp: 'ar 12/4/2003 20:57'!glCopyColorSubTable(target, start, x, y, width)	"This method was automatically generated."	"void glCopyColorSubTable(GLenum target, GLsizei start, GLint x, GLint y, GLsizei width);"	<apicall: void 'glCopyColorSubTable' (ulong long long long long) module: 'opengl32.dll'>	^self externalCallFailed! !!OpenGL methodsFor: 'OpenGL API' stamp: 'ar 12/4/2003 20:57'!glCopyColorTable(target, internalformat, x, y, width)	"This method was automatically generated."	"void glCopyColorTable(GLenum target, GLenum internalformat, GLint x, GLint y, GLsizei width);"	<apicall: void 'glCopyColorTable' (ulong ulong long long long) module: 'opengl32.dll'>	^self externalCallFailed! !!OpenGL methodsFor: 'OpenGL API' stamp: 'ar 12/4/2003 20:57'!glCopyConvolutionFilter1D(target, internalformat, x, y, width)	"This method was automatically generated."	"void glCopyConvolutionFilter1D(GLenum target, GLenum internalformat, GLint x, GLint y, GLsizei width);"	<apicall: void 'glCopyConvolutionFilter1D' (ulong ulong long long long) module: 'opengl32.dll'>	^self externalCallFailed! !!OpenGL methodsFor: 'OpenGL API' stamp: 'ar 12/4/2003 20:57'!glCopyConvolutionFilter2D(target, internalformat, x, y, width, height)	"This method was automatically generated."	"void glCopyConvolutionFilter2D(GLenum target, GLenum internalformat, GLint x, GLint y, GLsizei width, GLsizei height);"	<apicall: void 'glCopyConvolutionFilter2D' (ulong ulong long long long long) module: 'opengl32.dll'>	^self externalCallFailed! !!OpenGL methodsFor: 'OpenGL API' stamp: 'ar 12/4/2003 20:57'!glCopyPixels(x, y, width, height, type)	"This method was automatically generated."	"void glCopyPixels(GLint x, GLint y, GLsizei width, GLsizei height, GLenum type);"	<apicall: void 'glCopyPixels' (long long long long ulong) module: 'opengl32.dll'>	^self externalCallFailed! !!OpenGL methodsFor: 'OpenGL API' stamp: 'ar 12/4/2003 20:57'!glCopyTexImage1D(target, level, internalformat, x, y, width, border)	"This method was automatically generated."	"void glCopyTexImage1D(GLenum target, GLint level, GLenum internalformat, GLint x, GLint y, GLsizei width, GLint border);"	<apicall: void 'glCopyTexImage1D' (ulong long ulong long long long long) module: 'opengl32.dll'>	^self externalCallFailed! !!OpenGL methodsFor: 'OpenGL API' stamp: 'ar 12/4/2003 20:57'!glCopyTexImage2D(target, level, internalformat, x, y, width, height, border)	"This method was automatically generated."	"void glCopyTexImage2D(GLenum target, GLint level, GLenum internalformat, GLint x, GLint y, GLsizei width, GLsizei height, GLint border);"	<apicall: void 'glCopyTexImage2D' (ulong long ulong long long long long long) module: 'opengl32.dll'>	^self externalCallFailed! !!OpenGL methodsFor: 'OpenGL API' stamp: 'ar 12/4/2003 20:57'!glCopyTexSubImage1D(target, level, xoffset, x, y, width)	"This method was automatically generated."	"void glCopyTexSubImage1D(GLenum target, GLint level, GLint xoffset, GLint x, GLint y, GLsizei width);"	<apicall: void 'glCopyTexSubImage1D' (ulong long long long long long) module: 'opengl32.dll'>	^self externalCallFailed! !!OpenGL methodsFor: 'OpenGL API' stamp: 'ar 12/4/2003 20:57'!glCopyTexSubImage2D(target, level, xoffset, yoffset, x, y, width, height)	"This method was automatically generated."	"void glCopyTexSubImage2D(GLenum target, GLint level, GLint xoffset, GLint yoffset, GLint x, GLint y, GLsizei width, GLsizei height);"	<apicall: void 'glCopyTexSubImage2D' (ulong long long long long long long long) module: 'opengl32.dll'>	^self externalCallFailed! !!OpenGL methodsFor: 'OpenGL API' stamp: 'ar 12/4/2003 20:57'!glCopyTexSubImage3D(target, level, xoffset, yoffset, zoffset, x, y, width, height)	"This method was automatically generated."	"void glCopyTexSubImage3D(GLenum target, GLint level, GLint xoffset, GLint yoffset, GLint zoffset, GLint x, GLint y, GLsizei width, GLsizei height);"	<apicall: void 'glCopyTexSubImage3D' (ulong long long long long long long long long) module: 'opengl32.dll'>	^self externalCallFailed! !!OpenGL methodsFor: 'OpenGL API' stamp: 'ar 12/4/2003 20:57'!glCullFace(mode)	"This method was automatically generated."	"void glCullFace(GLenum mode);"	<apicall: void 'glCullFace' (ulong) module: 'opengl32.dll'>	^self externalCallFailed! !!OpenGL methodsFor: 'OpenGL API' stamp: 'ar 12/4/2003 20:57'!glDeleteLists(list, range)	"This method was automatically generated."	"void glDeleteLists(GLuint list, GLsizei range);"	<apicall: void 'glDeleteLists' (ulong long) module: 'opengl32.dll'>	^self externalCallFailed! !!OpenGL methodsFor: 'OpenGL API' stamp: 'ar 12/4/2003 20:57'!glDeleteTextures(n, textures)	"This method was automatically generated."	"void glDeleteTextures(GLsizei n, GLuint* textures);"	<apicall: void 'glDeleteTextures' (long ulong*) module: 'opengl32.dll'>	^self externalCallFailed! !!OpenGL methodsFor: 'OpenGL API' stamp: 'ar 12/4/2003 20:57'!glDeleteTexturesEXT(n, textures)	"This method was automatically generated."	"void glDeleteTexturesEXT(GLsizei n, GLuint* textures);"	<apicall: void 'glDeleteTexturesEXT' (long ulong*) module: 'opengl32.dll'>	^self externalCallFailed! !!OpenGL methodsFor: 'OpenGL API' stamp: 'ar 12/4/2003 20:57'!glDepthFunc(func)	"This method was automatically generated."	"void glDepthFunc(GLenum func);"	<apicall: void 'glDepthFunc' (ulong) module: 'opengl32.dll'>	^self externalCallFailed! !!OpenGL methodsFor: 'OpenGL API' stamp: 'ar 12/4/2003 20:57'!glDepthMask(flag)	"This method was automatically generated."	"void glDepthMask(GLboolean flag);"	<apicall: void 'glDepthMask' (bool) module: 'opengl32.dll'>	^self externalCallFailed! !!OpenGL methodsFor: 'OpenGL API' stamp: 'ar 12/4/2003 20:57'!glDepthRange(zNear, zFar)	"This method was automatically generated."	"void glDepthRange(GLclampd zNear, GLclampd zFar);"	<apicall: void 'glDepthRange' (double double) module: 'opengl32.dll'>	^self externalCallFailed! !!OpenGL methodsFor: 'OpenGL API' stamp: 'ar 12/4/2003 20:57'!glDisable(cap)	"This method was automatically generated."	"void glDisable(GLenum cap);"	<apicall: void 'glDisable' (ulong) module: 'opengl32.dll'>	^self externalCallFailed! !!OpenGL methodsFor: 'OpenGL API' stamp: 'ar 12/4/2003 20:57'!glDisableClientState(array)	"This method was automatically generated."	"void glDisableClientState(GLenum array);"	<apicall: void 'glDisableClientState' (ulong) module: 'opengl32.dll'>	^self externalCallFailed! !!OpenGL methodsFor: 'OpenGL API' stamp: 'ar 12/4/2003 20:57'!glDrawArrays(mode, first, count)	"This method was automatically generated."	"void glDrawArrays(GLenum mode, GLint first, GLsizei count);"	<apicall: void 'glDrawArrays' (ulong long long) module: 'opengl32.dll'>	^self externalCallFailed! !!OpenGL methodsFor: 'OpenGL API' stamp: 'ar 12/4/2003 20:57'!glDrawArraysEXT(mode, first, count)	"This method was automatically generated."	"void glDrawArraysEXT(GLenum mode, GLint first, GLsizei count);"	<apicall: void 'glDrawArraysEXT' (ulong long long) module: 'opengl32.dll'>	^self externalCallFailed! !!OpenGL methodsFor: 'OpenGL API' stamp: 'ar 12/4/2003 20:57'!glDrawBuffer(mode)	"This method was automatically generated."	"void glDrawBuffer(GLenum mode);"	<apicall: void 'glDrawBuffer' (ulong) module: 'opengl32.dll'>	^self externalCallFailed! !!OpenGL methodsFor: 'OpenGL API' stamp: 'ar 12/4/2003 20:57'!glDrawElements(mode, count, type, indices)	"This method was automatically generated."	"void glDrawElements(GLenum mode, GLsizei count, GLenum type, GLvoid* indices);"	<apicall: void 'glDrawElements' (ulong long ulong void*) module: 'opengl32.dll'>	^self externalCallFailed! !!OpenGL methodsFor: 'OpenGL API' stamp: 'ar 12/4/2003 20:57'!glDrawPixels(width, height, format, type, pixels)	"This method was automatically generated."	"void glDrawPixels(GLsizei width, GLsizei height, GLenum format, GLenum type, GLvoid* pixels);"	<apicall: void 'glDrawPixels' (long long ulong ulong void*) module: 'opengl32.dll'>	^self externalCallFailed! !!OpenGL methodsFor: 'OpenGL API' stamp: 'ar 12/4/2003 20:57'!glDrawRangeElements(mode, start, end, count, type, indices)	"This method was automatically generated."	"void glDrawRangeElements(GLenum mode, GLuint start, GLuint end, GLsizei count, GLenum type, GLvoid* indices);"	<apicall: void 'glDrawRangeElements' (ulong ulong ulong long ulong void*) module: 'opengl32.dll'>	^self externalCallFailed! !!OpenGL methodsFor: 'OpenGL API' stamp: 'ar 12/4/2003 20:57'!glEdgeFlag(flag)	"This method was automatically generated."	"void glEdgeFlag(GLboolean flag);"	<apicall: void 'glEdgeFlag' (bool) module: 'opengl32.dll'>	^self externalCallFailed! !!OpenGL methodsFor: 'OpenGL API' stamp: 'ar 12/4/2003 20:57'!glEdgeFlagPointer(stride, pointer)	"This method was automatically generated."	"void glEdgeFlagPointer(GLsizei stride, GLboolean* pointer);"	<apicall: void 'glEdgeFlagPointer' (long ulong*) module: 'opengl32.dll'>	^self externalCallFailed! !!OpenGL methodsFor: 'OpenGL API' stamp: 'ar 12/4/2003 20:57'!glEdgeFlagPointerEXT(stride, count, pointer)	"This method was automatically generated."	"void glEdgeFlagPointerEXT(GLsizei stride, GLsizei count, GLboolean* pointer);"	<apicall: void 'glEdgeFlagPointerEXT' (long long ulong*) module: 'opengl32.dll'>	^self externalCallFailed! !!OpenGL methodsFor: 'OpenGL API' stamp: 'ar 12/4/2003 20:57'!glEdgeFlagv(flag)	"This method was automatically generated."	"void glEdgeFlagv(GLboolean* flag);"	<apicall: void 'glEdgeFlagv' (ulong*) module: 'opengl32.dll'>	^self externalCallFailed! !!OpenGL methodsFor: 'OpenGL API' stamp: 'ar 12/4/2003 20:57'!glEnable(cap)	"This method was automatically generated."	"void glEnable(GLenum cap);"	<apicall: void 'glEnable' (ulong) module: 'opengl32.dll'>	^self externalCallFailed! !!OpenGL methodsFor: 'OpenGL API' stamp: 'ar 12/4/2003 20:57'!glEnableClientState(array)	"This method was automatically generated."	"void glEnableClientState(GLenum array);"	<apicall: void 'glEnableClientState' (ulong) module: 'opengl32.dll'>	^self externalCallFailed! !!OpenGL methodsFor: 'OpenGL API' stamp: 'ar 12/4/2003 20:57'!glEnd()	"This method was automatically generated."	"void glEnd();"	<apicall: void 'glEnd' (void) module: 'opengl32.dll'>	^self externalCallFailed! !!OpenGL methodsFor: 'OpenGL API' stamp: 'ar 12/4/2003 20:57'!glEndList()	"This method was automatically generated."	"void glEndList();"	<apicall: void 'glEndList' (void) module: 'opengl32.dll'>	^self externalCallFailed! !!OpenGL methodsFor: 'OpenGL API' stamp: 'ar 12/4/2003 20:57'!glEvalCoord1d(u)	"This method was automatically generated."	"void glEvalCoord1d(GLdouble u);"	<apicall: void 'glEvalCoord1d' (double) module: 'opengl32.dll'>	^self externalCallFailed! !!OpenGL methodsFor: 'OpenGL API' stamp: 'ar 12/4/2003 20:57'!glEvalCoord1dv(u)	"This method was automatically generated."	"void glEvalCoord1dv(GLdouble* u);"	<apicall: void 'glEvalCoord1dv' (double*) module: 'opengl32.dll'>	^self externalCallFailed! !!OpenGL methodsFor: 'OpenGL API' stamp: 'ar 12/4/2003 20:57'!glEvalCoord1f(u)	"This method was automatically generated."	"void glEvalCoord1f(GLfloat u);"	<apicall: void 'glEvalCoord1f' (float) module: 'opengl32.dll'>	^self externalCallFailed! !!OpenGL methodsFor: 'OpenGL API' stamp: 'ar 12/4/2003 20:57'!glEvalCoord1fv(u)	"This method was automatically generated."	"void glEvalCoord1fv(GLfloat* u);"	<apicall: void 'glEvalCoord1fv' (float*) module: 'opengl32.dll'>	^self externalCallFailed! !!OpenGL methodsFor: 'OpenGL API' stamp: 'ar 12/4/2003 20:57'!glEvalCoord2d(u, v)	"This method was automatically generated."	"void glEvalCoord2d(GLdouble u, GLdouble v);"	<apicall: void 'glEvalCoord2d' (double double) module: 'opengl32.dll'>	^self externalCallFailed! !!OpenGL methodsFor: 'OpenGL API' stamp: 'ar 12/4/2003 20:57'!glEvalCoord2dv(u)	"This method was automatically generated."	"void glEvalCoord2dv(GLdouble* u);"	<apicall: void 'glEvalCoord2dv' (double*) module: 'opengl32.dll'>	^self externalCallFailed! !!OpenGL methodsFor: 'OpenGL API' stamp: 'ar 12/4/2003 20:57'!glEvalCoord2f(u, v)	"This method was automatically generated."	"void glEvalCoord2f(GLfloat u, GLfloat v);"	<apicall: void 'glEvalCoord2f' (float float) module: 'opengl32.dll'>	^self externalCallFailed! !!OpenGL methodsFor: 'OpenGL API' stamp: 'ar 12/4/2003 20:57'!glEvalCoord2fv(u)	"This method was automatically generated."	"void glEvalCoord2fv(GLfloat* u);"	<apicall: void 'glEvalCoord2fv' (float*) module: 'opengl32.dll'>	^self externalCallFailed! !!OpenGL methodsFor: 'OpenGL API' stamp: 'ar 12/4/2003 20:57'!glEvalMesh1(mode, i1, i2)	"This method was automatically generated."	"void glEvalMesh1(GLenum mode, GLint i1, GLint i2);"	<apicall: void 'glEvalMesh1' (ulong long long) module: 'opengl32.dll'>	^self externalCallFailed! !!OpenGL methodsFor: 'OpenGL API' stamp: 'ar 12/4/2003 20:57'!glEvalMesh2(mode, i1, i2, j1, j2)	"This method was automatically generated."	"void glEvalMesh2(GLenum mode, GLint i1, GLint i2, GLint j1, GLint j2);"	<apicall: void 'glEvalMesh2' (ulong long long long long) module: 'opengl32.dll'>	^self externalCallFailed! !!OpenGL methodsFor: 'OpenGL API' stamp: 'ar 12/4/2003 20:57'!glEvalPoint1(i)	"This method was automatically generated."	"void glEvalPoint1(GLint i);"	<apicall: void 'glEvalPoint1' (long) module: 'opengl32.dll'>	^self externalCallFailed! !!OpenGL methodsFor: 'OpenGL API' stamp: 'ar 12/4/2003 20:57'!glEvalPoint2(i, j)	"This method was automatically generated."	"void glEvalPoint2(GLint i, GLint j);"	<apicall: void 'glEvalPoint2' (long long) module: 'opengl32.dll'>	^self externalCallFailed! !!OpenGL methodsFor: 'OpenGL API' stamp: 'ar 12/4/2003 20:57'!glFeedbackBuffer(size, type, buffer)	"This method was automatically generated."	"void glFeedbackBuffer(GLsizei size, GLenum type, GLfloat* buffer);"	<apicall: void 'glFeedbackBuffer' (long ulong float*) module: 'opengl32.dll'>	^self externalCallFailed! !!OpenGL methodsFor: 'OpenGL API' stamp: 'ar 12/4/2003 20:57'!glFinish()	"This method was automatically generated."	"void glFinish();"	<apicall: void 'glFinish' (void) module: 'opengl32.dll'>	^self externalCallFailed! !!OpenGL methodsFor: 'OpenGL API' stamp: 'ar 12/4/2003 20:57'!glFlush()	"This method was automatically generated."	"void glFlush();"	<apicall: void 'glFlush' (void) module: 'opengl32.dll'>	^self externalCallFailed! !!OpenGL methodsFor: 'OpenGL API' stamp: 'ar 12/4/2003 20:57'!glFogf(pname, param)	"This method was automatically generated."	"void glFogf(GLenum pname, GLfloat param);"	<apicall: void 'glFogf' (ulong float) module: 'opengl32.dll'>	^self externalCallFailed! !!OpenGL methodsFor: 'OpenGL API' stamp: 'ar 12/4/2003 20:57'!glFogfv(pname, params)	"This method was automatically generated."	"void glFogfv(GLenum pname, GLfloat* params);"	<apicall: void 'glFogfv' (ulong float*) module: 'opengl32.dll'>	^self externalCallFailed! !!OpenGL methodsFor: 'OpenGL API' stamp: 'ar 12/4/2003 20:57'!glFogi(pname, param)	"This method was automatically generated."	"void glFogi(GLenum pname, GLint param);"	<apicall: void 'glFogi' (ulong long) module: 'opengl32.dll'>	^self externalCallFailed! !!OpenGL methodsFor: 'OpenGL API' stamp: 'ar 12/4/2003 20:57'!glFogiv(pname, params)	"This method was automatically generated."	"void glFogiv(GLenum pname, GLint* params);"	<apicall: void 'glFogiv' (ulong long*) module: 'opengl32.dll'>	^self externalCallFailed! !!OpenGL methodsFor: 'OpenGL API' stamp: 'ar 12/4/2003 20:57'!glFrontFace(mode)	"This method was automatically generated."	"void glFrontFace(GLenum mode);"	<apicall: void 'glFrontFace' (ulong) module: 'opengl32.dll'>	^self externalCallFailed! !!OpenGL methodsFor: 'OpenGL API' stamp: 'ar 12/4/2003 20:57'!glFrustum(left, right, bottom, top, zNear, zFar)	"This method was automatically generated."	"void glFrustum(GLdouble left, GLdouble right, GLdouble bottom, GLdouble top, GLdouble zNear, GLdouble zFar);"	<apicall: void 'glFrustum' (double double double double double double) module: 'opengl32.dll'>	^self externalCallFailed! !!OpenGL methodsFor: 'OpenGL API' stamp: 'ar 12/4/2003 20:57'!glGenLists(range)	"This method was automatically generated."	"GLuint glGenLists(GLsizei range);"	<apicall: ulong 'glGenLists' (long) module: 'opengl32.dll'>	^self externalCallFailed! !!OpenGL methodsFor: 'OpenGL API' stamp: 'ar 12/4/2003 20:57'!glGenTextures(n, textures)	"This method was automatically generated."	"void glGenTextures(GLsizei n, GLuint* textures);"	<apicall: void 'glGenTextures' (long ulong*) module: 'opengl32.dll'>	^self externalCallFailed! !!OpenGL methodsFor: 'OpenGL API' stamp: 'ar 12/4/2003 20:57'!glGenTexturesEXT(n, textures)	"This method was automatically generated."	"void glGenTexturesEXT(GLsizei n, GLuint* textures);"	<apicall: void 'glGenTexturesEXT' (long ulong*) module: 'opengl32.dll'>	^self externalCallFailed! !!OpenGL methodsFor: 'OpenGL API' stamp: 'ar 12/4/2003 20:57'!glGetBooleanv(pname, params)	"This method was automatically generated."	"void glGetBooleanv(GLenum pname, GLboolean* params);"	<apicall: void 'glGetBooleanv' (ulong ulong*) module: 'opengl32.dll'>	^self externalCallFailed! !!OpenGL methodsFor: 'OpenGL API' stamp: 'ar 12/4/2003 20:57'!glGetClipPlane(plane, equation)	"This method was automatically generated."	"void glGetClipPlane(GLenum plane, GLdouble* equation);"	<apicall: void 'glGetClipPlane' (ulong double*) module: 'opengl32.dll'>	^self externalCallFailed! !!OpenGL methodsFor: 'OpenGL API' stamp: 'ar 12/4/2003 20:57'!glGetColorTable(target, format, type, table)	"This method was automatically generated."	"void glGetColorTable(GLenum target, GLenum format, GLenum type, GLvoid* table);"	<apicall: void 'glGetColorTable' (ulong ulong ulong void*) module: 'opengl32.dll'>	^self externalCallFailed! !!OpenGL methodsFor: 'OpenGL API' stamp: 'ar 12/4/2003 20:57'!glGetColorTableParameterfv(target, pname, params)	"This method was automatically generated."	"void glGetColorTableParameterfv(GLenum target, GLenum pname, GLfloat* params);"	<apicall: void 'glGetColorTableParameterfv' (ulong ulong float*) module: 'opengl32.dll'>	^self externalCallFailed! !!OpenGL methodsFor: 'OpenGL API' stamp: 'ar 12/4/2003 20:57'!glGetColorTableParameteriv(target, pname, params)	"This method was automatically generated."	"void glGetColorTableParameteriv(GLenum target, GLenum pname, GLint* params);"	<apicall: void 'glGetColorTableParameteriv' (ulong ulong long*) module: 'opengl32.dll'>	^self externalCallFailed! !!OpenGL methodsFor: 'OpenGL API' stamp: 'ar 12/4/2003 20:57'!glGetConvolutionFilter(target, format, type, image)	"This method was automatically generated."	"void glGetConvolutionFilter(GLenum target, GLenum format, GLenum type, GLvoid* image);"	<apicall: void 'glGetConvolutionFilter' (ulong ulong ulong void*) module: 'opengl32.dll'>	^self externalCallFailed! !!OpenGL methodsFor: 'OpenGL API' stamp: 'ar 12/4/2003 20:57'!glGetConvolutionParameterfv(target, pname, params)	"This method was automatically generated."	"void glGetConvolutionParameterfv(GLenum target, GLenum pname, GLfloat* params);"	<apicall: void 'glGetConvolutionParameterfv' (ulong ulong float*) module: 'opengl32.dll'>	^self externalCallFailed! !!OpenGL methodsFor: 'OpenGL API' stamp: 'ar 12/4/2003 20:57'!glGetConvolutionParameteriv(target, pname, params)	"This method was automatically generated."	"void glGetConvolutionParameteriv(GLenum target, GLenum pname, GLint* params);"	<apicall: void 'glGetConvolutionParameteriv' (ulong ulong long*) module: 'opengl32.dll'>	^self externalCallFailed! !!OpenGL methodsFor: 'OpenGL API' stamp: 'ar 12/4/2003 20:57'!glGetDoublev(pname, params)	"This method was automatically generated."	"void glGetDoublev(GLenum pname, GLdouble* params);"	<apicall: void 'glGetDoublev' (ulong double*) module: 'opengl32.dll'>	^self externalCallFailed! !!OpenGL methodsFor: 'OpenGL API' stamp: 'ar 12/4/2003 20:57'!glGetError()	"This method was automatically generated."	"GLenum glGetError();"	<apicall: ulong 'glGetError' (void) module: 'opengl32.dll'>	^self externalCallFailed! !!OpenGL methodsFor: 'OpenGL API' stamp: 'ar 12/4/2003 20:57'!glGetFloatv(pname, params)	"This method was automatically generated."	"void glGetFloatv(GLenum pname, GLfloat* params);"	<apicall: void 'glGetFloatv' (ulong float*) module: 'opengl32.dll'>	^self externalCallFailed! !!OpenGL methodsFor: 'OpenGL API' stamp: 'ar 12/4/2003 20:57'!glGetHistogram(target, reset, format, type, values)	"This method was automatically generated."	"void glGetHistogram(GLenum target, GLboolean reset, GLenum format, GLenum type, GLvoid* values);"	<apicall: void 'glGetHistogram' (ulong bool ulong ulong void*) module: 'opengl32.dll'>	^self externalCallFailed! !!OpenGL methodsFor: 'OpenGL API' stamp: 'ar 12/4/2003 20:57'!glGetHistogramParameterfv(target, pname, params)	"This method was automatically generated."	"void glGetHistogramParameterfv(GLenum target, GLenum pname, GLfloat* params);"	<apicall: void 'glGetHistogramParameterfv' (ulong ulong float*) module: 'opengl32.dll'>	^self externalCallFailed! !!OpenGL methodsFor: 'OpenGL API' stamp: 'ar 12/4/2003 20:57'!glGetHistogramParameteriv(target, pname, params)	"This method was automatically generated."	"void glGetHistogramParameteriv(GLenum target, GLenum pname, GLint* params);"	<apicall: void 'glGetHistogramParameteriv' (ulong ulong long*) module: 'opengl32.dll'>	^self externalCallFailed! !!OpenGL methodsFor: 'OpenGL API' stamp: 'ar 12/4/2003 20:57'!glGetIntegerv(pname, params)	"This method was automatically generated."	"void glGetIntegerv(GLenum pname, GLint* params);"	<apicall: void 'glGetIntegerv' (ulong long*) module: 'opengl32.dll'>	^self externalCallFailed! !!OpenGL methodsFor: 'OpenGL API' stamp: 'ar 12/4/2003 20:57'!glGetLightfv(light, pname, params)	"This method was automatically generated."	"void glGetLightfv(GLenum light, GLenum pname, GLfloat* params);"	<apicall: void 'glGetLightfv' (ulong ulong float*) module: 'opengl32.dll'>	^self externalCallFailed! !!OpenGL methodsFor: 'OpenGL API' stamp: 'ar 12/4/2003 20:57'!glGetLightiv(light, pname, params)	"This method was automatically generated."	"void glGetLightiv(GLenum light, GLenum pname, GLint* params);"	<apicall: void 'glGetLightiv' (ulong ulong long*) module: 'opengl32.dll'>	^self externalCallFailed! !!OpenGL methodsFor: 'OpenGL API' stamp: 'ar 12/4/2003 20:57'!glGetMapdv(target, query, v)	"This method was automatically generated."	"void glGetMapdv(GLenum target, GLenum query, GLdouble* v);"	<apicall: void 'glGetMapdv' (ulong ulong double*) module: 'opengl32.dll'>	^self externalCallFailed! !!OpenGL methodsFor: 'OpenGL API' stamp: 'ar 12/4/2003 20:57'!glGetMapfv(target, query, v)	"This method was automatically generated."	"void glGetMapfv(GLenum target, GLenum query, GLfloat* v);"	<apicall: void 'glGetMapfv' (ulong ulong float*) module: 'opengl32.dll'>	^self externalCallFailed! !!OpenGL methodsFor: 'OpenGL API' stamp: 'ar 12/4/2003 20:57'!glGetMapiv(target, query, v)	"This method was automatically generated."	"void glGetMapiv(GLenum target, GLenum query, GLint* v);"	<apicall: void 'glGetMapiv' (ulong ulong long*) module: 'opengl32.dll'>	^self externalCallFailed! !!OpenGL methodsFor: 'OpenGL API' stamp: 'ar 12/4/2003 20:57'!glGetMaterialfv(face, pname, params)	"This method was automatically generated."	"void glGetMaterialfv(GLenum face, GLenum pname, GLfloat* params);"	<apicall: void 'glGetMaterialfv' (ulong ulong float*) module: 'opengl32.dll'>	^self externalCallFailed! !!OpenGL methodsFor: 'OpenGL API' stamp: 'ar 12/4/2003 20:57'!glGetMaterialiv(face, pname, params)	"This method was automatically generated."	"void glGetMaterialiv(GLenum face, GLenum pname, GLint* params);"	<apicall: void 'glGetMaterialiv' (ulong ulong long*) module: 'opengl32.dll'>	^self externalCallFailed! !!OpenGL methodsFor: 'OpenGL API' stamp: 'ar 12/4/2003 20:57'!glGetMinmax(target, reset, format, type, values)	"This method was automatically generated."	"void glGetMinmax(GLenum target, GLboolean reset, GLenum format, GLenum type, GLvoid* values);"	<apicall: void 'glGetMinmax' (ulong bool ulong ulong void*) module: 'opengl32.dll'>	^self externalCallFailed! !!OpenGL methodsFor: 'OpenGL API' stamp: 'ar 12/4/2003 20:57'!glGetMinmaxParameterfv(target, pname, params)	"This method was automatically generated."	"void glGetMinmaxParameterfv(GLenum target, GLenum pname, GLfloat* params);"	<apicall: void 'glGetMinmaxParameterfv' (ulong ulong float*) module: 'opengl32.dll'>	^self externalCallFailed! !!OpenGL methodsFor: 'OpenGL API' stamp: 'ar 12/4/2003 20:57'!glGetMinmaxParameteriv(target, pname, params)	"This method was automatically generated."	"void glGetMinmaxParameteriv(GLenum target, GLenum pname, GLint* params);"	<apicall: void 'glGetMinmaxParameteriv' (ulong ulong long*) module: 'opengl32.dll'>	^self externalCallFailed! !!OpenGL methodsFor: 'OpenGL API' stamp: 'ar 12/4/2003 20:57'!glGetPixelMapfv(map, values)	"This method was automatically generated."	"void glGetPixelMapfv(GLenum map, GLfloat* values);"	<apicall: void 'glGetPixelMapfv' (ulong float*) module: 'opengl32.dll'>	^self externalCallFailed! !!OpenGL methodsFor: 'OpenGL API' stamp: 'ar 12/4/2003 20:57'!glGetPixelMapuiv(map, values)	"This method was automatically generated."	"void glGetPixelMapuiv(GLenum map, GLuint* values);"	<apicall: void 'glGetPixelMapuiv' (ulong ulong*) module: 'opengl32.dll'>	^self externalCallFailed! !!OpenGL methodsFor: 'OpenGL API' stamp: 'ar 12/4/2003 20:57'!glGetPixelMapusv(map, values)	"This method was automatically generated."	"void glGetPixelMapusv(GLenum map, GLushort* values);"	<apicall: void 'glGetPixelMapusv' (ulong ushort*) module: 'opengl32.dll'>	^self externalCallFailed! !!OpenGL methodsFor: 'OpenGL API' stamp: 'ar 12/4/2003 20:57'!glGetPointerv(pname, params)	"This method was automatically generated."	"void glGetPointerv(GLenum pname, GLvoid** params);"	<apicall: void 'glGetPointerv' (ulong void*) module: 'opengl32.dll'>	^self externalCallFailed! !!OpenGL methodsFor: 'OpenGL API' stamp: 'ar 12/4/2003 20:57'!glGetPointervEXT(pname, params)	"This method was automatically generated."	"void glGetPointervEXT(GLenum pname, GLvoid** params);"	<apicall: void 'glGetPointervEXT' (ulong void*) module: 'opengl32.dll'>	^self externalCallFailed! !!OpenGL methodsFor: 'OpenGL API' stamp: 'ar 12/4/2003 20:57'!glGetPolygonStipple(mask)	"This method was automatically generated."	"void glGetPolygonStipple(GLubyte* mask);"	<apicall: void 'glGetPolygonStipple' (byte*) module: 'opengl32.dll'>	^self externalCallFailed! !!OpenGL methodsFor: 'OpenGL API' stamp: 'ar 12/4/2003 20:57'!glGetSeparableFilter(target, format, type, row, column, span)	"This method was automatically generated."	"void glGetSeparableFilter(GLenum target, GLenum format, GLenum type, GLvoid* row, GLvoid* column, GLvoid* span);"	<apicall: void 'glGetSeparableFilter' (ulong ulong ulong void* void* void*) module: 'opengl32.dll'>	^self externalCallFailed! !!OpenGL methodsFor: 'OpenGL API' stamp: 'ar 12/4/2003 20:57'!glGetString(name)	"This method was automatically generated."	"GLubyte* glGetString(GLenum name);"	<apicall: byte* 'glGetString' (ulong) module: 'opengl32.dll'>	^self externalCallFailed! !!OpenGL methodsFor: 'OpenGL API' stamp: 'ar 12/4/2003 20:57'!glGetTexEnvfv(target, pname, params)	"This method was automatically generated."	"void glGetTexEnvfv(GLenum target, GLenum pname, GLfloat* params);"	<apicall: void 'glGetTexEnvfv' (ulong ulong float*) module: 'opengl32.dll'>	^self externalCallFailed! !!OpenGL methodsFor: 'OpenGL API' stamp: 'ar 12/4/2003 20:57'!glGetTexEnviv(target, pname, params)	"This method was automatically generated."	"void glGetTexEnviv(GLenum target, GLenum pname, GLint* params);"	<apicall: void 'glGetTexEnviv' (ulong ulong long*) module: 'opengl32.dll'>	^self externalCallFailed! !!OpenGL methodsFor: 'OpenGL API' stamp: 'ar 12/4/2003 20:57'!glGetTexGendv(coord, pname, params)	"This method was automatically generated."	"void glGetTexGendv(GLenum coord, GLenum pname, GLdouble* params);"	<apicall: void 'glGetTexGendv' (ulong ulong double*) module: 'opengl32.dll'>	^self externalCallFailed! !!OpenGL methodsFor: 'OpenGL API' stamp: 'ar 12/4/2003 20:57'!glGetTexGenfv(coord, pname, params)	"This method was automatically generated."	"void glGetTexGenfv(GLenum coord, GLenum pname, GLfloat* params);"	<apicall: void 'glGetTexGenfv' (ulong ulong float*) module: 'opengl32.dll'>	^self externalCallFailed! !!OpenGL methodsFor: 'OpenGL API' stamp: 'ar 12/4/2003 20:57'!glGetTexGeniv(coord, pname, params)	"This method was automatically generated."	"void glGetTexGeniv(GLenum coord, GLenum pname, GLint* params);"	<apicall: void 'glGetTexGeniv' (ulong ulong long*) module: 'opengl32.dll'>	^self externalCallFailed! !!OpenGL methodsFor: 'OpenGL API' stamp: 'ar 12/4/2003 20:57'!glGetTexImage(target, level, format, type, pixels)	"This method was automatically generated."	"void glGetTexImage(GLenum target, GLint level, GLenum format, GLenum type, GLvoid* pixels);"	<apicall: void 'glGetTexImage' (ulong long ulong ulong void*) module: 'opengl32.dll'>	^self externalCallFailed! !!OpenGL methodsFor: 'OpenGL API' stamp: 'ar 12/4/2003 20:57'!glGetTexLevelParameterfv(target, level, pname, params)	"This method was automatically generated."	"void glGetTexLevelParameterfv(GLenum target, GLint level, GLenum pname, GLfloat* params);"	<apicall: void 'glGetTexLevelParameterfv' (ulong long ulong float*) module: 'opengl32.dll'>	^self externalCallFailed! !!OpenGL methodsFor: 'OpenGL API' stamp: 'ar 12/4/2003 20:57'!glGetTexLevelParameteriv(target, level, pname, params)	"This method was automatically generated."	"void glGetTexLevelParameteriv(GLenum target, GLint level, GLenum pname, GLint* params);"	<apicall: void 'glGetTexLevelParameteriv' (ulong long ulong long*) module: 'opengl32.dll'>	^self externalCallFailed! !!OpenGL methodsFor: 'OpenGL API' stamp: 'ar 12/4/2003 20:57'!glGetTexParameterfv(target, pname, params)	"This method was automatically generated."	"void glGetTexParameterfv(GLenum target, GLenum pname, GLfloat* params);"	<apicall: void 'glGetTexParameterfv' (ulong ulong float*) module: 'opengl32.dll'>	^self externalCallFailed! !!OpenGL methodsFor: 'OpenGL API' stamp: 'ar 12/4/2003 20:57'!glGetTexParameteriv(target, pname, params)	"This method was automatically generated."	"void glGetTexParameteriv(GLenum target, GLenum pname, GLint* params);"	<apicall: void 'glGetTexParameteriv' (ulong ulong long*) module: 'opengl32.dll'>	^self externalCallFailed! !!OpenGL methodsFor: 'OpenGL API' stamp: 'ar 12/4/2003 20:57'!glHint(target, mode)	"This method was automatically generated."	"void glHint(GLenum target, GLenum mode);"	<apicall: void 'glHint' (ulong ulong) module: 'opengl32.dll'>	^self externalCallFailed! !!OpenGL methodsFor: 'OpenGL API' stamp: 'ar 12/4/2003 20:57'!glHistogram(target, width, internalformat, sink)	"This method was automatically generated."	"void glHistogram(GLenum target, GLsizei width, GLenum internalformat, GLboolean sink);"	<apicall: void 'glHistogram' (ulong long ulong bool) module: 'opengl32.dll'>	^self externalCallFailed! !!OpenGL methodsFor: 'OpenGL API' stamp: 'ar 12/4/2003 20:57'!glIndexMask(mask)	"This method was automatically generated."	"void glIndexMask(GLuint mask);"	<apicall: void 'glIndexMask' (ulong) module: 'opengl32.dll'>	^self externalCallFailed! !!OpenGL methodsFor: 'OpenGL API' stamp: 'ar 12/4/2003 20:57'!glIndexPointer(type, stride, pointer)	"This method was automatically generated."	"void glIndexPointer(GLenum type, GLsizei stride, GLvoid* pointer);"	<apicall: void 'glIndexPointer' (ulong long void*) module: 'opengl32.dll'>	^self externalCallFailed! !!OpenGL methodsFor: 'OpenGL API' stamp: 'ar 12/4/2003 20:57'!glIndexPointerEXT(type, stride, count, pointer)	"This method was automatically generated."	"void glIndexPointerEXT(GLenum type, GLsizei stride, GLsizei count, GLvoid* pointer);"	<apicall: void 'glIndexPointerEXT' (ulong long long void*) module: 'opengl32.dll'>	^self externalCallFailed! !!OpenGL methodsFor: 'OpenGL API' stamp: 'ar 12/4/2003 20:57'!glIndexd(c)	"This method was automatically generated."	"void glIndexd(GLdouble c);"	<apicall: void 'glIndexd' (double) module: 'opengl32.dll'>	^self externalCallFailed! !!OpenGL methodsFor: 'OpenGL API' stamp: 'ar 12/4/2003 20:57'!glIndexdv(c)	"This method was automatically generated."	"void glIndexdv(GLdouble* c);"	<apicall: void 'glIndexdv' (double*) module: 'opengl32.dll'>	^self externalCallFailed! !!OpenGL methodsFor: 'OpenGL API' stamp: 'ar 12/4/2003 20:57'!glIndexf(c)	"This method was automatically generated."	"void glIndexf(GLfloat c);"	<apicall: void 'glIndexf' (float) module: 'opengl32.dll'>	^self externalCallFailed! !!OpenGL methodsFor: 'OpenGL API' stamp: 'ar 12/4/2003 20:57'!glIndexfv(c)	"This method was automatically generated."	"void glIndexfv(GLfloat* c);"	<apicall: void 'glIndexfv' (float*) module: 'opengl32.dll'>	^self externalCallFailed! !!OpenGL methodsFor: 'OpenGL API' stamp: 'ar 12/4/2003 20:57'!glIndexi(c)	"This method was automatically generated."	"void glIndexi(GLint c);"	<apicall: void 'glIndexi' (long) module: 'opengl32.dll'>	^self externalCallFailed! !!OpenGL methodsFor: 'OpenGL API' stamp: 'ar 12/4/2003 20:57'!glIndexiv(c)	"This method was automatically generated."	"void glIndexiv(GLint* c);"	<apicall: void 'glIndexiv' (long*) module: 'opengl32.dll'>	^self externalCallFailed! !!OpenGL methodsFor: 'OpenGL API' stamp: 'ar 12/4/2003 20:57'!glIndexs(c)	"This method was automatically generated."	"void glIndexs(GLshort c);"	<apicall: void 'glIndexs' (short) module: 'opengl32.dll'>	^self externalCallFailed! !!OpenGL methodsFor: 'OpenGL API' stamp: 'ar 12/4/2003 20:57'!glIndexsv(c)	"This method was automatically generated."	"void glIndexsv(GLshort* c);"	<apicall: void 'glIndexsv' (short*) module: 'opengl32.dll'>	^self externalCallFailed! !!OpenGL methodsFor: 'OpenGL API' stamp: 'ar 12/4/2003 20:57'!glIndexub(c)	"This method was automatically generated."	"void glIndexub(GLubyte c);"	<apicall: void 'glIndexub' (byte) module: 'opengl32.dll'>	^self externalCallFailed! !!OpenGL methodsFor: 'OpenGL API' stamp: 'ar 12/4/2003 20:57'!glIndexubv(c)	"This method was automatically generated."	"void glIndexubv(GLubyte* c);"	<apicall: void 'glIndexubv' (byte*) module: 'opengl32.dll'>	^self externalCallFailed! !!OpenGL methodsFor: 'OpenGL API' stamp: 'ar 12/4/2003 20:57'!glInitNames()	"This method was automatically generated."	"void glInitNames();"	<apicall: void 'glInitNames' (void) module: 'opengl32.dll'>	^self externalCallFailed! !!OpenGL methodsFor: 'OpenGL API' stamp: 'ar 12/4/2003 20:57'!glInterleavedArrays(format, stride, pointer)	"This method was automatically generated."	"void glInterleavedArrays(GLenum format, GLsizei stride, GLvoid* pointer);"	<apicall: void 'glInterleavedArrays' (ulong long void*) module: 'opengl32.dll'>	^self externalCallFailed! !!OpenGL methodsFor: 'OpenGL API' stamp: 'ar 12/4/2003 20:57'!glIsEnabled(cap)	"This method was automatically generated."	"GLboolean glIsEnabled(GLenum cap);"	<apicall: bool 'glIsEnabled' (ulong) module: 'opengl32.dll'>	^self externalCallFailed! !!OpenGL methodsFor: 'OpenGL API' stamp: 'ar 12/4/2003 20:57'!glIsList(list)	"This method was automatically generated."	"GLboolean glIsList(GLuint list);"	<apicall: bool 'glIsList' (ulong) module: 'opengl32.dll'>	^self externalCallFailed! !!OpenGL methodsFor: 'OpenGL API' stamp: 'ar 12/4/2003 20:57'!glIsTexture(texture)	"This method was automatically generated."	"GLboolean glIsTexture(GLuint texture);"	<apicall: bool 'glIsTexture' (ulong) module: 'opengl32.dll'>	^self externalCallFailed! !!OpenGL methodsFor: 'OpenGL API' stamp: 'ar 12/4/2003 20:57'!glIsTextureEXT(texture)	"This method was automatically generated."	"GLboolean glIsTextureEXT(GLuint texture);"	<apicall: bool 'glIsTextureEXT' (ulong) module: 'opengl32.dll'>	^self externalCallFailed! !!OpenGL methodsFor: 'OpenGL API' stamp: 'ar 12/4/2003 20:57'!glLightModelf(pname, param)	"This method was automatically generated."	"void glLightModelf(GLenum pname, GLfloat param);"	<apicall: void 'glLightModelf' (ulong float) module: 'opengl32.dll'>	^self externalCallFailed! !!OpenGL methodsFor: 'OpenGL API' stamp: 'ar 12/4/2003 20:57'!glLightModelfv(pname, params)	"This method was automatically generated."	"void glLightModelfv(GLenum pname, GLfloat* params);"	<apicall: void 'glLightModelfv' (ulong float*) module: 'opengl32.dll'>	^self externalCallFailed! !!OpenGL methodsFor: 'OpenGL API' stamp: 'ar 12/4/2003 20:57'!glLightModeli(pname, param)	"This method was automatically generated."	"void glLightModeli(GLenum pname, GLint param);"	<apicall: void 'glLightModeli' (ulong long) module: 'opengl32.dll'>	^self externalCallFailed! !!OpenGL methodsFor: 'OpenGL API' stamp: 'ar 12/4/2003 20:57'!glLightModeliv(pname, params)	"This method was automatically generated."	"void glLightModeliv(GLenum pname, GLint* params);"	<apicall: void 'glLightModeliv' (ulong long*) module: 'opengl32.dll'>	^self externalCallFailed! !!OpenGL methodsFor: 'OpenGL API' stamp: 'ar 12/4/2003 20:57'!glLightf(light, pname, param)	"This method was automatically generated."	"void glLightf(GLenum light, GLenum pname, GLfloat param);"	<apicall: void 'glLightf' (ulong ulong float) module: 'opengl32.dll'>	^self externalCallFailed! !!OpenGL methodsFor: 'OpenGL API' stamp: 'ar 12/4/2003 20:57'!glLightfv(light, pname, params)	"This method was automatically generated."	"void glLightfv(GLenum light, GLenum pname, GLfloat* params);"	<apicall: void 'glLightfv' (ulong ulong float*) module: 'opengl32.dll'>	^self externalCallFailed! !!OpenGL methodsFor: 'OpenGL API' stamp: 'ar 12/4/2003 20:57'!glLighti(light, pname, param)	"This method was automatically generated."	"void glLighti(GLenum light, GLenum pname, GLint param);"	<apicall: void 'glLighti' (ulong ulong long) module: 'opengl32.dll'>	^self externalCallFailed! !!OpenGL methodsFor: 'OpenGL API' stamp: 'ar 12/4/2003 20:57'!glLightiv(light, pname, params)	"This method was automatically generated."	"void glLightiv(GLenum light, GLenum pname, GLint* params);"	<apicall: void 'glLightiv' (ulong ulong long*) module: 'opengl32.dll'>	^self externalCallFailed! !!OpenGL methodsFor: 'OpenGL API' stamp: 'ar 12/4/2003 20:57'!glLineStipple(factor, pattern)	"This method was automatically generated."	"void glLineStipple(GLint factor, GLushort pattern);"	<apicall: void 'glLineStipple' (long ushort) module: 'opengl32.dll'>	^self externalCallFailed! !!OpenGL methodsFor: 'OpenGL API' stamp: 'ar 12/4/2003 20:57'!glLineWidth(width)	"This method was automatically generated."	"void glLineWidth(GLfloat width);"	<apicall: void 'glLineWidth' (float) module: 'opengl32.dll'>	^self externalCallFailed! !!OpenGL methodsFor: 'OpenGL API' stamp: 'ar 12/4/2003 20:57'!glListBase(base)	"This method was automatically generated."	"void glListBase(GLuint base);"	<apicall: void 'glListBase' (ulong) module: 'opengl32.dll'>	^self externalCallFailed! !!OpenGL methodsFor: 'OpenGL API' stamp: 'ar 12/4/2003 20:57'!glLoadIdentity()	"This method was automatically generated."	"void glLoadIdentity();"	<apicall: void 'glLoadIdentity' (void) module: 'opengl32.dll'>	^self externalCallFailed! !!OpenGL methodsFor: 'OpenGL API' stamp: 'ar 12/4/2003 20:57'!glLoadMatrixd(m)	"This method was automatically generated."	"void glLoadMatrixd(GLdouble* m);"	<apicall: void 'glLoadMatrixd' (double*) module: 'opengl32.dll'>	^self externalCallFailed! !!OpenGL methodsFor: 'OpenGL API' stamp: 'ar 12/4/2003 20:57'!glLoadMatrixf(m)	"This method was automatically generated."	"void glLoadMatrixf(GLfloat* m);"	<apicall: void 'glLoadMatrixf' (float*) module: 'opengl32.dll'>	^self externalCallFailed! !!OpenGL methodsFor: 'OpenGL API' stamp: 'ar 12/4/2003 20:57'!glLoadName(name)	"This method was automatically generated."	"void glLoadName(GLuint name);"	<apicall: void 'glLoadName' (ulong) module: 'opengl32.dll'>	^self externalCallFailed! !!OpenGL methodsFor: 'OpenGL API' stamp: 'ar 12/4/2003 20:57'!glLogicOp(opcode)	"This method was automatically generated."	"void glLogicOp(GLenum opcode);"	<apicall: void 'glLogicOp' (ulong) module: 'opengl32.dll'>	^self externalCallFailed! !!OpenGL methodsFor: 'OpenGL API' stamp: 'ar 12/4/2003 20:57'!glMap1d(target, u1, u2, stride, order, points)	"This method was automatically generated."	"void glMap1d(GLenum target, GLdouble u1, GLdouble u2, GLint stride, GLint order, GLdouble* points);"	<apicall: void 'glMap1d' (ulong double double long long double*) module: 'opengl32.dll'>	^self externalCallFailed! !!OpenGL methodsFor: 'OpenGL API' stamp: 'ar 12/4/2003 20:57'!glMap1f(target, u1, u2, stride, order, points)	"This method was automatically generated."	"void glMap1f(GLenum target, GLfloat u1, GLfloat u2, GLint stride, GLint order, GLfloat* points);"	<apicall: void 'glMap1f' (ulong float float long long float*) module: 'opengl32.dll'>	^self externalCallFailed! !!OpenGL methodsFor: 'OpenGL API' stamp: 'ar 12/4/2003 20:57'!glMap2d(target, u1, u2, ustride, uorder, v1, v2, vstride, vorder, points)	"This method was automatically generated."	"void glMap2d(GLenum target, GLdouble u1, GLdouble u2, GLint ustride, GLint uorder, GLdouble v1, GLdouble v2, GLint vstride, GLint vorder, GLdouble* points);"	<apicall: void 'glMap2d' (ulong double double long long double double long long double*) module: 'opengl32.dll'>	^self externalCallFailed! !!OpenGL methodsFor: 'OpenGL API' stamp: 'ar 12/4/2003 20:57'!glMap2f(target, u1, u2, ustride, uorder, v1, v2, vstride, vorder, points)	"This method was automatically generated."	"void glMap2f(GLenum target, GLfloat u1, GLfloat u2, GLint ustride, GLint uorder, GLfloat v1, GLfloat v2, GLint vstride, GLint vorder, GLfloat* points);"	<apicall: void 'glMap2f' (ulong float float long long float float long long float*) module: 'opengl32.dll'>	^self externalCallFailed! !!OpenGL methodsFor: 'OpenGL API' stamp: 'ar 12/4/2003 20:57'!glMapGrid1d(un, u1, u2)	"This method was automatically generated."	"void glMapGrid1d(GLint un, GLdouble u1, GLdouble u2);"	<apicall: void 'glMapGrid1d' (long double double) module: 'opengl32.dll'>	^self externalCallFailed! !!OpenGL methodsFor: 'OpenGL API' stamp: 'ar 12/4/2003 20:57'!glMapGrid1f(un, u1, u2)	"This method was automatically generated."	"void glMapGrid1f(GLint un, GLfloat u1, GLfloat u2);"	<apicall: void 'glMapGrid1f' (long float float) module: 'opengl32.dll'>	^self externalCallFailed! !!OpenGL methodsFor: 'OpenGL API' stamp: 'ar 12/4/2003 20:57'!glMapGrid2d(un, u1, u2, vn, v1, v2)	"This method was automatically generated."	"void glMapGrid2d(GLint un, GLdouble u1, GLdouble u2, GLint vn, GLdouble v1, GLdouble v2);"	<apicall: void 'glMapGrid2d' (long double double long double double) module: 'opengl32.dll'>	^self externalCallFailed! !!OpenGL methodsFor: 'OpenGL API' stamp: 'ar 12/4/2003 20:57'!glMapGrid2f(un, u1, u2, vn, v1, v2)	"This method was automatically generated."	"void glMapGrid2f(GLint un, GLfloat u1, GLfloat u2, GLint vn, GLfloat v1, GLfloat v2);"	<apicall: void 'glMapGrid2f' (long float float long float float) module: 'opengl32.dll'>	^self externalCallFailed! !!OpenGL methodsFor: 'OpenGL API' stamp: 'ar 12/4/2003 20:57'!glMaterialf(face, pname, param)	"This method was automatically generated."	"void glMaterialf(GLenum face, GLenum pname, GLfloat param);"	<apicall: void 'glMaterialf' (ulong ulong float) module: 'opengl32.dll'>	^self externalCallFailed! !!OpenGL methodsFor: 'OpenGL API' stamp: 'ar 12/4/2003 20:57'!glMaterialfv(face, pname, params)	"This method was automatically generated."	"void glMaterialfv(GLenum face, GLenum pname, GLfloat* params);"	<apicall: void 'glMaterialfv' (ulong ulong float*) module: 'opengl32.dll'>	^self externalCallFailed! !!OpenGL methodsFor: 'OpenGL API' stamp: 'ar 12/4/2003 20:57'!glMateriali(face, pname, param)	"This method was automatically generated."	"void glMateriali(GLenum face, GLenum pname, GLint param);"	<apicall: void 'glMateriali' (ulong ulong long) module: 'opengl32.dll'>	^self externalCallFailed! !!OpenGL methodsFor: 'OpenGL API' stamp: 'ar 12/4/2003 20:57'!glMaterialiv(face, pname, params)	"This method was automatically generated."	"void glMaterialiv(GLenum face, GLenum pname, GLint* params);"	<apicall: void 'glMaterialiv' (ulong ulong long*) module: 'opengl32.dll'>	^self externalCallFailed! !!OpenGL methodsFor: 'OpenGL API' stamp: 'ar 12/4/2003 20:57'!glMatrixMode(mode)	"This method was automatically generated."	"void glMatrixMode(GLenum mode);"	<apicall: void 'glMatrixMode' (ulong) module: 'opengl32.dll'>	^self externalCallFailed! !!OpenGL methodsFor: 'OpenGL API' stamp: 'ar 12/4/2003 20:57'!glMinmax(target, internalformat, sink)	"This method was automatically generated."	"void glMinmax(GLenum target, GLenum internalformat, GLboolean sink);"	<apicall: void 'glMinmax' (ulong ulong bool) module: 'opengl32.dll'>	^self externalCallFailed! !!OpenGL methodsFor: 'OpenGL API' stamp: 'ar 12/4/2003 20:57'!glMultMatrixd(m)	"This method was automatically generated."	"void glMultMatrixd(GLdouble* m);"	<apicall: void 'glMultMatrixd' (double*) module: 'opengl32.dll'>	^self externalCallFailed! !!OpenGL methodsFor: 'OpenGL API' stamp: 'ar 12/4/2003 20:57'!glMultMatrixf(m)	"This method was automatically generated."	"void glMultMatrixf(GLfloat* m);"	<apicall: void 'glMultMatrixf' (float*) module: 'opengl32.dll'>	^self externalCallFailed! !!OpenGL methodsFor: 'OpenGL API' stamp: 'ar 12/4/2003 20:57'!glMultiTexCoord1dARB(target, s)	"This method was automatically generated."	"void glMultiTexCoord1dARB(GLenum target, GLdouble s);"	<apicall: void 'glMultiTexCoord1dARB' (ulong double) module: 'opengl32.dll'>	^self externalCallFailed! !!OpenGL methodsFor: 'OpenGL API' stamp: 'ar 12/4/2003 20:57'!glMultiTexCoord1dvARB(target, v)	"This method was automatically generated."	"void glMultiTexCoord1dvARB(GLenum target, GLdouble* v);"	<apicall: void 'glMultiTexCoord1dvARB' (ulong double*) module: 'opengl32.dll'>	^self externalCallFailed! !!OpenGL methodsFor: 'OpenGL API' stamp: 'ar 12/4/2003 20:57'!glMultiTexCoord1fARB(target, s)	"This method was automatically generated."	"void glMultiTexCoord1fARB(GLenum target, GLfloat s);"	<apicall: void 'glMultiTexCoord1fARB' (ulong float) module: 'opengl32.dll'>	^self externalCallFailed! !!OpenGL methodsFor: 'OpenGL API' stamp: 'ar 12/4/2003 20:57'!glMultiTexCoord1fvARB(target, v)	"This method was automatically generated."	"void glMultiTexCoord1fvARB(GLenum target, GLfloat* v);"	<apicall: void 'glMultiTexCoord1fvARB' (ulong float*) module: 'opengl32.dll'>	^self externalCallFailed! !!OpenGL methodsFor: 'OpenGL API' stamp: 'ar 12/4/2003 20:57'!glMultiTexCoord1iARB(target, s)	"This method was automatically generated."	"void glMultiTexCoord1iARB(GLenum target, GLint s);"	<apicall: void 'glMultiTexCoord1iARB' (ulong long) module: 'opengl32.dll'>	^self externalCallFailed! !!OpenGL methodsFor: 'OpenGL API' stamp: 'ar 12/4/2003 20:57'!glMultiTexCoord1ivARB(target, v)	"This method was automatically generated."	"void glMultiTexCoord1ivARB(GLenum target, GLint* v);"	<apicall: void 'glMultiTexCoord1ivARB' (ulong long*) module: 'opengl32.dll'>	^self externalCallFailed! !!OpenGL methodsFor: 'OpenGL API' stamp: 'ar 12/4/2003 20:57'!glMultiTexCoord1sARB(target, s)	"This method was automatically generated."	"void glMultiTexCoord1sARB(GLenum target, GLshort s);"	<apicall: void 'glMultiTexCoord1sARB' (ulong short) module: 'opengl32.dll'>	^self externalCallFailed! !!OpenGL methodsFor: 'OpenGL API' stamp: 'ar 12/4/2003 20:57'!glMultiTexCoord1svARB(target, v)	"This method was automatically generated."	"void glMultiTexCoord1svARB(GLenum target, GLshort* v);"	<apicall: void 'glMultiTexCoord1svARB' (ulong short*) module: 'opengl32.dll'>	^self externalCallFailed! !!OpenGL methodsFor: 'OpenGL API' stamp: 'ar 12/4/2003 20:57'!glMultiTexCoord2dARB(target, s, t)	"This method was automatically generated."	"void glMultiTexCoord2dARB(GLenum target, GLdouble s, GLdouble t);"	<apicall: void 'glMultiTexCoord2dARB' (ulong double double) module: 'opengl32.dll'>	^self externalCallFailed! !!OpenGL methodsFor: 'OpenGL API' stamp: 'ar 12/4/2003 20:57'!glMultiTexCoord2dvARB(target, v)	"This method was automatically generated."	"void glMultiTexCoord2dvARB(GLenum target, GLdouble* v);"	<apicall: void 'glMultiTexCoord2dvARB' (ulong double*) module: 'opengl32.dll'>	^self externalCallFailed! !!OpenGL methodsFor: 'OpenGL API' stamp: 'ar 12/4/2003 20:57'!glMultiTexCoord2fARB(target, s, t)	"This method was automatically generated."	"void glMultiTexCoord2fARB(GLenum target, GLfloat s, GLfloat t);"	<apicall: void 'glMultiTexCoord2fARB' (ulong float float) module: 'opengl32.dll'>	^self externalCallFailed! !!OpenGL methodsFor: 'OpenGL API' stamp: 'ar 12/4/2003 20:57'!glMultiTexCoord2fvARB(target, v)	"This method was automatically generated."	"void glMultiTexCoord2fvARB(GLenum target, GLfloat* v);"	<apicall: void 'glMultiTexCoord2fvARB' (ulong float*) module: 'opengl32.dll'>	^self externalCallFailed! !!OpenGL methodsFor: 'OpenGL API' stamp: 'ar 12/4/2003 20:57'!glMultiTexCoord2iARB(target, s, t)	"This method was automatically generated."	"void glMultiTexCoord2iARB(GLenum target, GLint s, GLint t);"	<apicall: void 'glMultiTexCoord2iARB' (ulong long long) module: 'opengl32.dll'>	^self externalCallFailed! !!OpenGL methodsFor: 'OpenGL API' stamp: 'ar 12/4/2003 20:57'!glMultiTexCoord2ivARB(target, v)	"This method was automatically generated."	"void glMultiTexCoord2ivARB(GLenum target, GLint* v);"	<apicall: void 'glMultiTexCoord2ivARB' (ulong long*) module: 'opengl32.dll'>	^self externalCallFailed! !!OpenGL methodsFor: 'OpenGL API' stamp: 'ar 12/4/2003 20:57'!glMultiTexCoord2sARB(target, s, t)	"This method was automatically generated."	"void glMultiTexCoord2sARB(GLenum target, GLshort s, GLshort t);"	<apicall: void 'glMultiTexCoord2sARB' (ulong short short) module: 'opengl32.dll'>	^self externalCallFailed! !!OpenGL methodsFor: 'OpenGL API' stamp: 'ar 12/4/2003 20:57'!glMultiTexCoord2svARB(target, v)	"This method was automatically generated."	"void glMultiTexCoord2svARB(GLenum target, GLshort* v);"	<apicall: void 'glMultiTexCoord2svARB' (ulong short*) module: 'opengl32.dll'>	^self externalCallFailed! !!OpenGL methodsFor: 'OpenGL API' stamp: 'ar 12/4/2003 20:57'!glMultiTexCoord3dARB(target, s, t, r)	"This method was automatically generated."	"void glMultiTexCoord3dARB(GLenum target, GLdouble s, GLdouble t, GLdouble r);"	<apicall: void 'glMultiTexCoord3dARB' (ulong double double double) module: 'opengl32.dll'>	^self externalCallFailed! !!OpenGL methodsFor: 'OpenGL API' stamp: 'ar 12/4/2003 20:57'!glMultiTexCoord3dvARB(target, v)	"This method was automatically generated."	"void glMultiTexCoord3dvARB(GLenum target, GLdouble* v);"	<apicall: void 'glMultiTexCoord3dvARB' (ulong double*) module: 'opengl32.dll'>	^self externalCallFailed! !!OpenGL methodsFor: 'OpenGL API' stamp: 'ar 12/4/2003 20:57'!glMultiTexCoord3fARB(target, s, t, r)	"This method was automatically generated."	"void glMultiTexCoord3fARB(GLenum target, GLfloat s, GLfloat t, GLfloat r);"	<apicall: void 'glMultiTexCoord3fARB' (ulong float float float) module: 'opengl32.dll'>	^self externalCallFailed! !!OpenGL methodsFor: 'OpenGL API' stamp: 'ar 12/4/2003 20:57'!glMultiTexCoord3fvARB(target, v)	"This method was automatically generated."	"void glMultiTexCoord3fvARB(GLenum target, GLfloat* v);"	<apicall: void 'glMultiTexCoord3fvARB' (ulong float*) module: 'opengl32.dll'>	^self externalCallFailed! !!OpenGL methodsFor: 'OpenGL API' stamp: 'ar 12/4/2003 20:57'!glMultiTexCoord3iARB(target, s, t, r)	"This method was automatically generated."	"void glMultiTexCoord3iARB(GLenum target, GLint s, GLint t, GLint r);"	<apicall: void 'glMultiTexCoord3iARB' (ulong long long long) module: 'opengl32.dll'>	^self externalCallFailed! !!OpenGL methodsFor: 'OpenGL API' stamp: 'ar 12/4/2003 20:57'!glMultiTexCoord3ivARB(target, v)	"This method was automatically generated."	"void glMultiTexCoord3ivARB(GLenum target, GLint* v);"	<apicall: void 'glMultiTexCoord3ivARB' (ulong long*) module: 'opengl32.dll'>	^self externalCallFailed! !!OpenGL methodsFor: 'OpenGL API' stamp: 'ar 12/4/2003 20:57'!glMultiTexCoord3sARB(target, s, t, r)	"This method was automatically generated."	"void glMultiTexCoord3sARB(GLenum target, GLshort s, GLshort t, GLshort r);"	<apicall: void 'glMultiTexCoord3sARB' (ulong short short short) module: 'opengl32.dll'>	^self externalCallFailed! !!OpenGL methodsFor: 'OpenGL API' stamp: 'ar 12/4/2003 20:57'!glMultiTexCoord3svARB(target, v)	"This method was automatically generated."	"void glMultiTexCoord3svARB(GLenum target, GLshort* v);"	<apicall: void 'glMultiTexCoord3svARB' (ulong short*) module: 'opengl32.dll'>	^self externalCallFailed! !!OpenGL methodsFor: 'OpenGL API' stamp: 'ar 12/4/2003 20:57'!glMultiTexCoord4dARB(target, s, t, r, q)	"This method was automatically generated."	"void glMultiTexCoord4dARB(GLenum target, GLdouble s, GLdouble t, GLdouble r, GLdouble q);"	<apicall: void 'glMultiTexCoord4dARB' (ulong double double double double) module: 'opengl32.dll'>	^self externalCallFailed! !!OpenGL methodsFor: 'OpenGL API' stamp: 'ar 12/4/2003 20:57'!glMultiTexCoord4dvARB(target, v)	"This method was automatically generated."	"void glMultiTexCoord4dvARB(GLenum target, GLdouble* v);"	<apicall: void 'glMultiTexCoord4dvARB' (ulong double*) module: 'opengl32.dll'>	^self externalCallFailed! !!OpenGL methodsFor: 'OpenGL API' stamp: 'ar 12/4/2003 20:57'!glMultiTexCoord4fARB(target, s, t, r, q)	"This method was automatically generated."	"void glMultiTexCoord4fARB(GLenum target, GLfloat s, GLfloat t, GLfloat r, GLfloat q);"	<apicall: void 'glMultiTexCoord4fARB' (ulong float float float float) module: 'opengl32.dll'>	^self externalCallFailed! !!OpenGL methodsFor: 'OpenGL API' stamp: 'ar 12/4/2003 20:57'!glMultiTexCoord4fvARB(target, v)	"This method was automatically generated."	"void glMultiTexCoord4fvARB(GLenum target, GLfloat* v);"	<apicall: void 'glMultiTexCoord4fvARB' (ulong float*) module: 'opengl32.dll'>	^self externalCallFailed! !!OpenGL methodsFor: 'OpenGL API' stamp: 'ar 12/4/2003 20:57'!glMultiTexCoord4iARB(target, s, t, r, q)	"This method was automatically generated."	"void glMultiTexCoord4iARB(GLenum target, GLint s, GLint t, GLint r, GLint q);"	<apicall: void 'glMultiTexCoord4iARB' (ulong long long long long) module: 'opengl32.dll'>	^self externalCallFailed! !!OpenGL methodsFor: 'OpenGL API' stamp: 'ar 12/4/2003 20:57'!glMultiTexCoord4ivARB(target, v)	"This method was automatically generated."	"void glMultiTexCoord4ivARB(GLenum target, GLint* v);"	<apicall: void 'glMultiTexCoord4ivARB' (ulong long*) module: 'opengl32.dll'>	^self externalCallFailed! !!OpenGL methodsFor: 'OpenGL API' stamp: 'ar 12/4/2003 20:57'!glMultiTexCoord4sARB(target, s, t, r, q)	"This method was automatically generated."	"void glMultiTexCoord4sARB(GLenum target, GLshort s, GLshort t, GLshort r, GLshort q);"	<apicall: void 'glMultiTexCoord4sARB' (ulong short short short short) module: 'opengl32.dll'>	^self externalCallFailed! !!OpenGL methodsFor: 'OpenGL API' stamp: 'ar 12/4/2003 20:57'!glMultiTexCoord4svARB(target, v)	"This method was automatically generated."	"void glMultiTexCoord4svARB(GLenum target, GLshort* v);"	<apicall: void 'glMultiTexCoord4svARB' (ulong short*) module: 'opengl32.dll'>	^self externalCallFailed! !!OpenGL methodsFor: 'OpenGL API' stamp: 'ar 12/4/2003 20:57'!glNewList(list, mode)	"This method was automatically generated."	"void glNewList(GLuint list, GLenum mode);"	<apicall: void 'glNewList' (ulong ulong) module: 'opengl32.dll'>	^self externalCallFailed! !!OpenGL methodsFor: 'OpenGL API' stamp: 'ar 12/4/2003 20:57'!glNormal3b(nx, ny, nz)	"This method was automatically generated."	"void glNormal3b(GLbyte nx, GLbyte ny, GLbyte nz);"	<apicall: void 'glNormal3b' (byte byte byte) module: 'opengl32.dll'>	^self externalCallFailed! !!OpenGL methodsFor: 'OpenGL API' stamp: 'ar 12/4/2003 20:57'!glNormal3bv(v)	"This method was automatically generated."	"void glNormal3bv(GLbyte* v);"	<apicall: void 'glNormal3bv' (byte*) module: 'opengl32.dll'>	^self externalCallFailed! !!OpenGL methodsFor: 'OpenGL API' stamp: 'ar 12/4/2003 20:57'!glNormal3d(nx, ny, nz)	"This method was automatically generated."	"void glNormal3d(GLdouble nx, GLdouble ny, GLdouble nz);"	<apicall: void 'glNormal3d' (double double double) module: 'opengl32.dll'>	^self externalCallFailed! !!OpenGL methodsFor: 'OpenGL API' stamp: 'ar 12/4/2003 20:57'!glNormal3dv(v)	"This method was automatically generated."	"void glNormal3dv(GLdouble* v);"	<apicall: void 'glNormal3dv' (double*) module: 'opengl32.dll'>	^self externalCallFailed! !!OpenGL methodsFor: 'OpenGL API' stamp: 'ar 12/4/2003 20:57'!glNormal3f(nx, ny, nz)	"This method was automatically generated."	"void glNormal3f(GLfloat nx, GLfloat ny, GLfloat nz);"	<apicall: void 'glNormal3f' (float float float) module: 'opengl32.dll'>	^self externalCallFailed! !!OpenGL methodsFor: 'OpenGL API' stamp: 'ar 12/4/2003 20:57'!glNormal3fv(v)	"This method was automatically generated."	"void glNormal3fv(GLfloat* v);"	<apicall: void 'glNormal3fv' (float*) module: 'opengl32.dll'>	^self externalCallFailed! !!OpenGL methodsFor: 'OpenGL API' stamp: 'ar 12/4/2003 20:57'!glNormal3i(nx, ny, nz)	"This method was automatically generated."	"void glNormal3i(GLint nx, GLint ny, GLint nz);"	<apicall: void 'glNormal3i' (long long long) module: 'opengl32.dll'>	^self externalCallFailed! !!OpenGL methodsFor: 'OpenGL API' stamp: 'ar 12/4/2003 20:57'!glNormal3iv(v)	"This method was automatically generated."	"void glNormal3iv(GLint* v);"	<apicall: void 'glNormal3iv' (long*) module: 'opengl32.dll'>	^self externalCallFailed! !!OpenGL methodsFor: 'OpenGL API' stamp: 'ar 12/4/2003 20:57'!glNormal3s(nx, ny, nz)	"This method was automatically generated."	"void glNormal3s(GLshort nx, GLshort ny, GLshort nz);"	<apicall: void 'glNormal3s' (short short short) module: 'opengl32.dll'>	^self externalCallFailed! !!OpenGL methodsFor: 'OpenGL API' stamp: 'ar 12/4/2003 20:57'!glNormal3sv(v)	"This method was automatically generated."	"void glNormal3sv(GLshort* v);"	<apicall: void 'glNormal3sv' (short*) module: 'opengl32.dll'>	^self externalCallFailed! !!OpenGL methodsFor: 'OpenGL API' stamp: 'ar 12/4/2003 20:57'!glNormalPointer(type, stride, pointer)	"This method was automatically generated."	"void glNormalPointer(GLenum type, GLsizei stride, GLvoid* pointer);"	<apicall: void 'glNormalPointer' (ulong long void*) module: 'opengl32.dll'>	^self externalCallFailed! !!OpenGL methodsFor: 'OpenGL API' stamp: 'ar 12/4/2003 20:57'!glNormalPointerEXT(type, stride, count, pointer)	"This method was automatically generated."	"void glNormalPointerEXT(GLenum type, GLsizei stride, GLsizei count, GLvoid* pointer);"	<apicall: void 'glNormalPointerEXT' (ulong long long void*) module: 'opengl32.dll'>	^self externalCallFailed! !!OpenGL methodsFor: 'OpenGL API' stamp: 'ar 12/4/2003 20:57'!glOrtho(left, right, bottom, top, zNear, zFar)	"This method was automatically generated."	"void glOrtho(GLdouble left, GLdouble right, GLdouble bottom, GLdouble top, GLdouble zNear, GLdouble zFar);"	<apicall: void 'glOrtho' (double double double double double double) module: 'opengl32.dll'>	^self externalCallFailed! !!OpenGL methodsFor: 'OpenGL API' stamp: 'ar 12/4/2003 20:57'!glPassThrough(token)	"This method was automatically generated."	"void glPassThrough(GLfloat token);"	<apicall: void 'glPassThrough' (float) module: 'opengl32.dll'>	^self externalCallFailed! !!OpenGL methodsFor: 'OpenGL API' stamp: 'ar 12/4/2003 20:57'!glPixelMapfv(map, mapsize, values)	"This method was automatically generated."	"void glPixelMapfv(GLenum map, GLint mapsize, GLfloat* values);"	<apicall: void 'glPixelMapfv' (ulong long float*) module: 'opengl32.dll'>	^self externalCallFailed! !!OpenGL methodsFor: 'OpenGL API' stamp: 'ar 12/4/2003 20:57'!glPixelMapuiv(map, mapsize, values)	"This method was automatically generated."	"void glPixelMapuiv(GLenum map, GLint mapsize, GLuint* values);"	<apicall: void 'glPixelMapuiv' (ulong long ulong*) module: 'opengl32.dll'>	^self externalCallFailed! !!OpenGL methodsFor: 'OpenGL API' stamp: 'ar 12/4/2003 20:57'!glPixelMapusv(map, mapsize, values)	"This method was automatically generated."	"void glPixelMapusv(GLenum map, GLint mapsize, GLushort* values);"	<apicall: void 'glPixelMapusv' (ulong long ushort*) module: 'opengl32.dll'>	^self externalCallFailed! !!OpenGL methodsFor: 'OpenGL API' stamp: 'ar 12/4/2003 20:57'!glPixelStoref(pname, param)	"This method was automatically generated."	"void glPixelStoref(GLenum pname, GLfloat param);"	<apicall: void 'glPixelStoref' (ulong float) module: 'opengl32.dll'>	^self externalCallFailed! !!OpenGL methodsFor: 'OpenGL API' stamp: 'ar 12/4/2003 20:57'!glPixelStorei(pname, param)	"This method was automatically generated."	"void glPixelStorei(GLenum pname, GLint param);"	<apicall: void 'glPixelStorei' (ulong long) module: 'opengl32.dll'>	^self externalCallFailed! !!OpenGL methodsFor: 'OpenGL API' stamp: 'ar 12/4/2003 20:57'!glPixelTransferf(pname, param)	"This method was automatically generated."	"void glPixelTransferf(GLenum pname, GLfloat param);"	<apicall: void 'glPixelTransferf' (ulong float) module: 'opengl32.dll'>	^self externalCallFailed! !!OpenGL methodsFor: 'OpenGL API' stamp: 'ar 12/4/2003 20:57'!glPixelTransferi(pname, param)	"This method was automatically generated."	"void glPixelTransferi(GLenum pname, GLint param);"	<apicall: void 'glPixelTransferi' (ulong long) module: 'opengl32.dll'>	^self externalCallFailed! !!OpenGL methodsFor: 'OpenGL API' stamp: 'ar 12/4/2003 20:57'!glPixelZoom(xfactor, yfactor)	"This method was automatically generated."	"void glPixelZoom(GLfloat xfactor, GLfloat yfactor);"	<apicall: void 'glPixelZoom' (float float) module: 'opengl32.dll'>	^self externalCallFailed! !!OpenGL methodsFor: 'OpenGL API' stamp: 'ar 12/4/2003 20:57'!glPointSize(size)	"This method was automatically generated."	"void glPointSize(GLfloat size);"	<apicall: void 'glPointSize' (float) module: 'opengl32.dll'>	^self externalCallFailed! !!OpenGL methodsFor: 'OpenGL API' stamp: 'ar 12/4/2003 20:57'!glPolygonMode(face, mode)	"This method was automatically generated."	"void glPolygonMode(GLenum face, GLenum mode);"	<apicall: void 'glPolygonMode' (ulong ulong) module: 'opengl32.dll'>	^self externalCallFailed! !!OpenGL methodsFor: 'OpenGL API' stamp: 'ar 12/4/2003 20:57'!glPolygonOffset(factor, units)	"This method was automatically generated."	"void glPolygonOffset(GLfloat factor, GLfloat units);"	<apicall: void 'glPolygonOffset' (float float) module: 'opengl32.dll'>	^self externalCallFailed! !!OpenGL methodsFor: 'OpenGL API' stamp: 'ar 12/4/2003 20:57'!glPolygonStipple(mask)	"This method was automatically generated."	"void glPolygonStipple(GLubyte* mask);"	<apicall: void 'glPolygonStipple' (byte*) module: 'opengl32.dll'>	^self externalCallFailed! !!OpenGL methodsFor: 'OpenGL API' stamp: 'ar 12/4/2003 20:57'!glPopAttrib()	"This method was automatically generated."	"void glPopAttrib();"	<apicall: void 'glPopAttrib' (void) module: 'opengl32.dll'>	^self externalCallFailed! !!OpenGL methodsFor: 'OpenGL API' stamp: 'ar 12/4/2003 20:57'!glPopClientAttrib()	"This method was automatically generated."	"void glPopClientAttrib();"	<apicall: void 'glPopClientAttrib' (void) module: 'opengl32.dll'>	^self externalCallFailed! !!OpenGL methodsFor: 'OpenGL API' stamp: 'ar 12/4/2003 20:57'!glPopMatrix()	"This method was automatically generated."	"void glPopMatrix();"	<apicall: void 'glPopMatrix' (void) module: 'opengl32.dll'>	^self externalCallFailed! !!OpenGL methodsFor: 'OpenGL API' stamp: 'ar 12/4/2003 20:57'!glPopName()	"This method was automatically generated."	"void glPopName();"	<apicall: void 'glPopName' (void) module: 'opengl32.dll'>	^self externalCallFailed! !!OpenGL methodsFor: 'OpenGL API' stamp: 'ar 12/4/2003 20:57'!glPrioritizeTextures(n, textures, priorities)	"This method was automatically generated."	"void glPrioritizeTextures(GLsizei n, GLuint* textures, GLclampf* priorities);"	<apicall: void 'glPrioritizeTextures' (long ulong* float*) module: 'opengl32.dll'>	^self externalCallFailed! !!OpenGL methodsFor: 'OpenGL API' stamp: 'ar 12/4/2003 20:57'!glPushAttrib(mask)	"This method was automatically generated."	"void glPushAttrib(GLbitfield mask);"	<apicall: void 'glPushAttrib' (ulong) module: 'opengl32.dll'>	^self externalCallFailed! !!OpenGL methodsFor: 'OpenGL API' stamp: 'ar 12/4/2003 20:57'!glPushClientAttrib(mask)	"This method was automatically generated."	"void glPushClientAttrib(GLbitfield mask);"	<apicall: void 'glPushClientAttrib' (ulong) module: 'opengl32.dll'>	^self externalCallFailed! !!OpenGL methodsFor: 'OpenGL API' stamp: 'ar 12/4/2003 20:57'!glPushMatrix()	"This method was automatically generated."	"void glPushMatrix();"	<apicall: void 'glPushMatrix' (void) module: 'opengl32.dll'>	^self externalCallFailed! !!OpenGL methodsFor: 'OpenGL API' stamp: 'ar 12/4/2003 20:57'!glPushName(name)	"This method was automatically generated."	"void glPushName(GLuint name);"	<apicall: void 'glPushName' (ulong) module: 'opengl32.dll'>	^self externalCallFailed! !!OpenGL methodsFor: 'OpenGL API' stamp: 'ar 12/4/2003 20:57'!glRasterPos2d(x, y)	"This method was automatically generated."	"void glRasterPos2d(GLdouble x, GLdouble y);"	<apicall: void 'glRasterPos2d' (double double) module: 'opengl32.dll'>	^self externalCallFailed! !!OpenGL methodsFor: 'OpenGL API' stamp: 'ar 12/4/2003 20:57'!glRasterPos2dv(v)	"This method was automatically generated."	"void glRasterPos2dv(GLdouble* v);"	<apicall: void 'glRasterPos2dv' (double*) module: 'opengl32.dll'>	^self externalCallFailed! !!OpenGL methodsFor: 'OpenGL API' stamp: 'ar 12/4/2003 20:57'!glRasterPos2f(x, y)	"This method was automatically generated."	"void glRasterPos2f(GLfloat x, GLfloat y);"	<apicall: void 'glRasterPos2f' (float float) module: 'opengl32.dll'>	^self externalCallFailed! !!OpenGL methodsFor: 'OpenGL API' stamp: 'ar 12/4/2003 20:57'!glRasterPos2fv(v)	"This method was automatically generated."	"void glRasterPos2fv(GLfloat* v);"	<apicall: void 'glRasterPos2fv' (float*) module: 'opengl32.dll'>	^self externalCallFailed! !!OpenGL methodsFor: 'OpenGL API' stamp: 'ar 12/4/2003 20:57'!glRasterPos2i(x, y)	"This method was automatically generated."	"void glRasterPos2i(GLint x, GLint y);"	<apicall: void 'glRasterPos2i' (long long) module: 'opengl32.dll'>	^self externalCallFailed! !!OpenGL methodsFor: 'OpenGL API' stamp: 'ar 12/4/2003 20:57'!glRasterPos2iv(v)	"This method was automatically generated."	"void glRasterPos2iv(GLint* v);"	<apicall: void 'glRasterPos2iv' (long*) module: 'opengl32.dll'>	^self externalCallFailed! !!OpenGL methodsFor: 'OpenGL API' stamp: 'ar 12/4/2003 20:57'!glRasterPos2s(x, y)	"This method was automatically generated."	"void glRasterPos2s(GLshort x, GLshort y);"	<apicall: void 'glRasterPos2s' (short short) module: 'opengl32.dll'>	^self externalCallFailed! !!OpenGL methodsFor: 'OpenGL API' stamp: 'ar 12/4/2003 20:57'!glRasterPos2sv(v)	"This method was automatically generated."	"void glRasterPos2sv(GLshort* v);"	<apicall: void 'glRasterPos2sv' (short*) module: 'opengl32.dll'>	^self externalCallFailed! !!OpenGL methodsFor: 'OpenGL API' stamp: 'ar 12/4/2003 20:57'!glRasterPos3d(x, y, z)	"This method was automatically generated."	"void glRasterPos3d(GLdouble x, GLdouble y, GLdouble z);"	<apicall: void 'glRasterPos3d' (double double double) module: 'opengl32.dll'>	^self externalCallFailed! !!OpenGL methodsFor: 'OpenGL API' stamp: 'ar 12/4/2003 20:57'!glRasterPos3dv(v)	"This method was automatically generated."	"void glRasterPos3dv(GLdouble* v);"	<apicall: void 'glRasterPos3dv' (double*) module: 'opengl32.dll'>	^self externalCallFailed! !!OpenGL methodsFor: 'OpenGL API' stamp: 'ar 12/4/2003 20:57'!glRasterPos3f(x, y, z)	"This method was automatically generated."	"void glRasterPos3f(GLfloat x, GLfloat y, GLfloat z);"	<apicall: void 'glRasterPos3f' (float float float) module: 'opengl32.dll'>	^self externalCallFailed! !!OpenGL methodsFor: 'OpenGL API' stamp: 'ar 12/4/2003 20:57'!glRasterPos3fv(v)	"This method was automatically generated."	"void glRasterPos3fv(GLfloat* v);"	<apicall: void 'glRasterPos3fv' (float*) module: 'opengl32.dll'>	^self externalCallFailed! !!OpenGL methodsFor: 'OpenGL API' stamp: 'ar 12/4/2003 20:57'!glRasterPos3i(x, y, z)	"This method was automatically generated."	"void glRasterPos3i(GLint x, GLint y, GLint z);"	<apicall: void 'glRasterPos3i' (long long long) module: 'opengl32.dll'>	^self externalCallFailed! !!OpenGL methodsFor: 'OpenGL API' stamp: 'ar 12/4/2003 20:57'!glRasterPos3iv(v)	"This method was automatically generated."	"void glRasterPos3iv(GLint* v);"	<apicall: void 'glRasterPos3iv' (long*) module: 'opengl32.dll'>	^self externalCallFailed! !!OpenGL methodsFor: 'OpenGL API' stamp: 'ar 12/4/2003 20:57'!glRasterPos3s(x, y, z)	"This method was automatically generated."	"void glRasterPos3s(GLshort x, GLshort y, GLshort z);"	<apicall: void 'glRasterPos3s' (short short short) module: 'opengl32.dll'>	^self externalCallFailed! !!OpenGL methodsFor: 'OpenGL API' stamp: 'ar 12/4/2003 20:57'!glRasterPos3sv(v)	"This method was automatically generated."	"void glRasterPos3sv(GLshort* v);"	<apicall: void 'glRasterPos3sv' (short*) module: 'opengl32.dll'>	^self externalCallFailed! !!OpenGL methodsFor: 'OpenGL API' stamp: 'ar 12/4/2003 20:57'!glRasterPos4d(x, y, z, w)	"This method was automatically generated."	"void glRasterPos4d(GLdouble x, GLdouble y, GLdouble z, GLdouble w);"	<apicall: void 'glRasterPos4d' (double double double double) module: 'opengl32.dll'>	^self externalCallFailed! !!OpenGL methodsFor: 'OpenGL API' stamp: 'ar 12/4/2003 20:57'!glRasterPos4dv(v)	"This method was automatically generated."	"void glRasterPos4dv(GLdouble* v);"	<apicall: void 'glRasterPos4dv' (double*) module: 'opengl32.dll'>	^self externalCallFailed! !!OpenGL methodsFor: 'OpenGL API' stamp: 'ar 12/4/2003 20:57'!glRasterPos4f(x, y, z, w)	"This method was automatically generated."	"void glRasterPos4f(GLfloat x, GLfloat y, GLfloat z, GLfloat w);"	<apicall: void 'glRasterPos4f' (float float float float) module: 'opengl32.dll'>	^self externalCallFailed! !!OpenGL methodsFor: 'OpenGL API' stamp: 'ar 12/4/2003 20:57'!glRasterPos4fv(v)	"This method was automatically generated."	"void glRasterPos4fv(GLfloat* v);"	<apicall: void 'glRasterPos4fv' (float*) module: 'opengl32.dll'>	^self externalCallFailed! !!OpenGL methodsFor: 'OpenGL API' stamp: 'ar 12/4/2003 20:57'!glRasterPos4i(x, y, z, w)	"This method was automatically generated."	"void glRasterPos4i(GLint x, GLint y, GLint z, GLint w);"	<apicall: void 'glRasterPos4i' (long long long long) module: 'opengl32.dll'>	^self externalCallFailed! !!OpenGL methodsFor: 'OpenGL API' stamp: 'ar 12/4/2003 20:57'!glRasterPos4iv(v)	"This method was automatically generated."	"void glRasterPos4iv(GLint* v);"	<apicall: void 'glRasterPos4iv' (long*) module: 'opengl32.dll'>	^self externalCallFailed! !!OpenGL methodsFor: 'OpenGL API' stamp: 'ar 12/4/2003 20:57'!glRasterPos4s(x, y, z, w)	"This method was automatically generated."	"void glRasterPos4s(GLshort x, GLshort y, GLshort z, GLshort w);"	<apicall: void 'glRasterPos4s' (short short short short) module: 'opengl32.dll'>	^self externalCallFailed! !!OpenGL methodsFor: 'OpenGL API' stamp: 'ar 12/4/2003 20:57'!glRasterPos4sv(v)	"This method was automatically generated."	"void glRasterPos4sv(GLshort* v);"	<apicall: void 'glRasterPos4sv' (short*) module: 'opengl32.dll'>	^self externalCallFailed! !!OpenGL methodsFor: 'OpenGL API' stamp: 'ar 12/4/2003 20:57'!glReadBuffer(mode)	"This method was automatically generated."	"void glReadBuffer(GLenum mode);"	<apicall: void 'glReadBuffer' (ulong) module: 'opengl32.dll'>	^self externalCallFailed! !!OpenGL methodsFor: 'OpenGL API' stamp: 'ar 12/4/2003 20:57'!glReadPixels(x, y, width, height, format, type, pixels)	"This method was automatically generated."	"void glReadPixels(GLint x, GLint y, GLsizei width, GLsizei height, GLenum format, GLenum type, GLvoid* pixels);"	<apicall: void 'glReadPixels' (long long long long ulong ulong void*) module: 'opengl32.dll'>	^self externalCallFailed! !!OpenGL methodsFor: 'OpenGL API' stamp: 'ar 12/4/2003 20:57'!glRectd(x1, y1, x2, y2)	"This method was automatically generated."	"void glRectd(GLdouble x1, GLdouble y1, GLdouble x2, GLdouble y2);"	<apicall: void 'glRectd' (double double double double) module: 'opengl32.dll'>	^self externalCallFailed! !!OpenGL methodsFor: 'OpenGL API' stamp: 'ar 12/4/2003 20:57'!glRectdv(v1, v2)	"This method was automatically generated."	"void glRectdv(GLdouble* v1, GLdouble* v2);"	<apicall: void 'glRectdv' (double* double*) module: 'opengl32.dll'>	^self externalCallFailed! !!OpenGL methodsFor: 'OpenGL API' stamp: 'ar 12/4/2003 20:57'!glRectf(x1, y1, x2, y2)	"This method was automatically generated."	"void glRectf(GLfloat x1, GLfloat y1, GLfloat x2, GLfloat y2);"	<apicall: void 'glRectf' (float float float float) module: 'opengl32.dll'>	^self externalCallFailed! !!OpenGL methodsFor: 'OpenGL API' stamp: 'ar 12/4/2003 20:57'!glRectfv(v1, v2)	"This method was automatically generated."	"void glRectfv(GLfloat* v1, GLfloat* v2);"	<apicall: void 'glRectfv' (float* float*) module: 'opengl32.dll'>	^self externalCallFailed! !!OpenGL methodsFor: 'OpenGL API' stamp: 'ar 12/4/2003 20:57'!glRecti(x1, y1, x2, y2)	"This method was automatically generated."	"void glRecti(GLint x1, GLint y1, GLint x2, GLint y2);"	<apicall: void 'glRecti' (long long long long) module: 'opengl32.dll'>	^self externalCallFailed! !!OpenGL methodsFor: 'OpenGL API' stamp: 'ar 12/4/2003 20:57'!glRectiv(v1, v2)	"This method was automatically generated."	"void glRectiv(GLint* v1, GLint* v2);"	<apicall: void 'glRectiv' (long* long*) module: 'opengl32.dll'>	^self externalCallFailed! !!OpenGL methodsFor: 'OpenGL API' stamp: 'ar 12/4/2003 20:57'!glRects(x1, y1, x2, y2)	"This method was automatically generated."	"void glRects(GLshort x1, GLshort y1, GLshort x2, GLshort y2);"	<apicall: void 'glRects' (short short short short) module: 'opengl32.dll'>	^self externalCallFailed! !!OpenGL methodsFor: 'OpenGL API' stamp: 'ar 12/4/2003 20:57'!glRectsv(v1, v2)	"This method was automatically generated."	"void glRectsv(GLshort* v1, GLshort* v2);"	<apicall: void 'glRectsv' (short* short*) module: 'opengl32.dll'>	^self externalCallFailed! !!OpenGL methodsFor: 'OpenGL API' stamp: 'ar 12/4/2003 20:57'!glRenderMode(mode)	"This method was automatically generated."	"GLint glRenderMode(GLenum mode);"	<apicall: long 'glRenderMode' (ulong) module: 'opengl32.dll'>	^self externalCallFailed! !!OpenGL methodsFor: 'OpenGL API' stamp: 'ar 12/4/2003 20:57'!glResetHistogram(target)	"This method was automatically generated."	"void glResetHistogram(GLenum target);"	<apicall: void 'glResetHistogram' (ulong) module: 'opengl32.dll'>	^self externalCallFailed! !!OpenGL methodsFor: 'OpenGL API' stamp: 'ar 12/4/2003 20:57'!glResetMinmax(target)	"This method was automatically generated."	"void glResetMinmax(GLenum target);"	<apicall: void 'glResetMinmax' (ulong) module: 'opengl32.dll'>	^self externalCallFailed! !!OpenGL methodsFor: 'OpenGL API' stamp: 'ar 12/4/2003 20:57'!glRotated(angle, x, y, z)	"This method was automatically generated."	"void glRotated(GLdouble angle, GLdouble x, GLdouble y, GLdouble z);"	<apicall: void 'glRotated' (double double double double) module: 'opengl32.dll'>	^self externalCallFailed! !!OpenGL methodsFor: 'OpenGL API' stamp: 'ar 12/4/2003 20:57'!glRotatef(angle, x, y, z)	"This method was automatically generated."	"void glRotatef(GLfloat angle, GLfloat x, GLfloat y, GLfloat z);"	<apicall: void 'glRotatef' (float float float float) module: 'opengl32.dll'>	^self externalCallFailed! !!OpenGL methodsFor: 'OpenGL API' stamp: 'ar 12/4/2003 20:57'!glScaled(x, y, z)	"This method was automatically generated."	"void glScaled(GLdouble x, GLdouble y, GLdouble z);"	<apicall: void 'glScaled' (double double double) module: 'opengl32.dll'>	^self externalCallFailed! !!OpenGL methodsFor: 'OpenGL API' stamp: 'ar 12/4/2003 20:57'!glScalef(x, y, z)	"This method was automatically generated."	"void glScalef(GLfloat x, GLfloat y, GLfloat z);"	<apicall: void 'glScalef' (float float float) module: 'opengl32.dll'>	^self externalCallFailed! !!OpenGL methodsFor: 'OpenGL API' stamp: 'ar 12/4/2003 20:57'!glScissor(x, y, width, height)	"This method was automatically generated."	"void glScissor(GLint x, GLint y, GLsizei width, GLsizei height);"	<apicall: void 'glScissor' (long long long long) module: 'opengl32.dll'>	^self externalCallFailed! !!OpenGL methodsFor: 'OpenGL API' stamp: 'ar 12/4/2003 20:57'!glSelectBuffer(size, buffer)	"This method was automatically generated."	"void glSelectBuffer(GLsizei size, GLuint* buffer);"	<apicall: void 'glSelectBuffer' (long ulong*) module: 'opengl32.dll'>	^self externalCallFailed! !!OpenGL methodsFor: 'OpenGL API' stamp: 'ar 12/4/2003 20:57'!glSeparableFilter2D(target, internalformat, width, height, format, type, row, column)	"This method was automatically generated."	"void glSeparableFilter2D(GLenum target, GLenum internalformat, GLsizei width, GLsizei height, GLenum format, GLenum type, GLvoid* row, GLvoid* column);"	<apicall: void 'glSeparableFilter2D' (ulong ulong long long ulong ulong void* void*) module: 'opengl32.dll'>	^self externalCallFailed! !!OpenGL methodsFor: 'OpenGL API' stamp: 'ar 12/4/2003 20:57'!glShadeModel(mode)	"This method was automatically generated."	"void glShadeModel(GLenum mode);"	<apicall: void 'glShadeModel' (ulong) module: 'opengl32.dll'>	^self externalCallFailed! !!OpenGL methodsFor: 'OpenGL API' stamp: 'ar 12/4/2003 20:57'!glStencilFunc(func, ref, mask)	"This method was automatically generated."	"void glStencilFunc(GLenum func, GLint ref, GLuint mask);"	<apicall: void 'glStencilFunc' (ulong long ulong) module: 'opengl32.dll'>	^self externalCallFailed! !!OpenGL methodsFor: 'OpenGL API' stamp: 'ar 12/4/2003 20:57'!glStencilMask(mask)	"This method was automatically generated."	"void glStencilMask(GLuint mask);"	<apicall: void 'glStencilMask' (ulong) module: 'opengl32.dll'>	^self externalCallFailed! !!OpenGL methodsFor: 'OpenGL API' stamp: 'ar 12/4/2003 20:57'!glStencilOp(fail, zfail, zpass)	"This method was automatically generated."	"void glStencilOp(GLenum fail, GLenum zfail, GLenum zpass);"	<apicall: void 'glStencilOp' (ulong ulong ulong) module: 'opengl32.dll'>	^self externalCallFailed! !!OpenGL methodsFor: 'OpenGL API' stamp: 'ar 12/4/2003 20:57'!glTexCoord1d(s)	"This method was automatically generated."	"void glTexCoord1d(GLdouble s);"	<apicall: void 'glTexCoord1d' (double) module: 'opengl32.dll'>	^self externalCallFailed! !!OpenGL methodsFor: 'OpenGL API' stamp: 'ar 12/4/2003 20:57'!glTexCoord1dv(v)	"This method was automatically generated."	"void glTexCoord1dv(GLdouble* v);"	<apicall: void 'glTexCoord1dv' (double*) module: 'opengl32.dll'>	^self externalCallFailed! !!OpenGL methodsFor: 'OpenGL API' stamp: 'ar 12/4/2003 20:57'!glTexCoord1f(s)	"This method was automatically generated."	"void glTexCoord1f(GLfloat s);"	<apicall: void 'glTexCoord1f' (float) module: 'opengl32.dll'>	^self externalCallFailed! !!OpenGL methodsFor: 'OpenGL API' stamp: 'ar 12/4/2003 20:57'!glTexCoord1fv(v)	"This method was automatically generated."	"void glTexCoord1fv(GLfloat* v);"	<apicall: void 'glTexCoord1fv' (float*) module: 'opengl32.dll'>	^self externalCallFailed! !!OpenGL methodsFor: 'OpenGL API' stamp: 'ar 12/4/2003 20:57'!glTexCoord1i(s)	"This method was automatically generated."	"void glTexCoord1i(GLint s);"	<apicall: void 'glTexCoord1i' (long) module: 'opengl32.dll'>	^self externalCallFailed! !!OpenGL methodsFor: 'OpenGL API' stamp: 'ar 12/4/2003 20:57'!glTexCoord1iv(v)	"This method was automatically generated."	"void glTexCoord1iv(GLint* v);"	<apicall: void 'glTexCoord1iv' (long*) module: 'opengl32.dll'>	^self externalCallFailed! !!OpenGL methodsFor: 'OpenGL API' stamp: 'ar 12/4/2003 20:57'!glTexCoord1s(s)	"This method was automatically generated."	"void glTexCoord1s(GLshort s);"	<apicall: void 'glTexCoord1s' (short) module: 'opengl32.dll'>	^self externalCallFailed! !!OpenGL methodsFor: 'OpenGL API' stamp: 'ar 12/4/2003 20:57'!glTexCoord1sv(v)	"This method was automatically generated."	"void glTexCoord1sv(GLshort* v);"	<apicall: void 'glTexCoord1sv' (short*) module: 'opengl32.dll'>	^self externalCallFailed! !!OpenGL methodsFor: 'OpenGL API' stamp: 'ar 12/4/2003 20:57'!glTexCoord2d(s, t)	"This method was automatically generated."	"void glTexCoord2d(GLdouble s, GLdouble t);"	<apicall: void 'glTexCoord2d' (double double) module: 'opengl32.dll'>	^self externalCallFailed! !!OpenGL methodsFor: 'OpenGL API' stamp: 'ar 12/4/2003 20:57'!glTexCoord2dv(v)	"This method was automatically generated."	"void glTexCoord2dv(GLdouble* v);"	<apicall: void 'glTexCoord2dv' (double*) module: 'opengl32.dll'>	^self externalCallFailed! !!OpenGL methodsFor: 'OpenGL API' stamp: 'ar 12/4/2003 20:57'!glTexCoord2f(s, t)	"This method was automatically generated."	"void glTexCoord2f(GLfloat s, GLfloat t);"	<apicall: void 'glTexCoord2f' (float float) module: 'opengl32.dll'>	^self externalCallFailed! !!OpenGL methodsFor: 'OpenGL API' stamp: 'ar 12/4/2003 20:57'!glTexCoord2fv(v)	"This method was automatically generated."	"void glTexCoord2fv(GLfloat* v);"	<apicall: void 'glTexCoord2fv' (float*) module: 'opengl32.dll'>	^self externalCallFailed! !!OpenGL methodsFor: 'OpenGL API' stamp: 'ar 12/4/2003 20:57'!glTexCoord2i(s, t)	"This method was automatically generated."	"void glTexCoord2i(GLint s, GLint t);"	<apicall: void 'glTexCoord2i' (long long) module: 'opengl32.dll'>	^self externalCallFailed! !!OpenGL methodsFor: 'OpenGL API' stamp: 'ar 12/4/2003 20:57'!glTexCoord2iv(v)	"This method was automatically generated."	"void glTexCoord2iv(GLint* v);"	<apicall: void 'glTexCoord2iv' (long*) module: 'opengl32.dll'>	^self externalCallFailed! !!OpenGL methodsFor: 'OpenGL API' stamp: 'ar 12/4/2003 20:57'!glTexCoord2s(s, t)	"This method was automatically generated."	"void glTexCoord2s(GLshort s, GLshort t);"	<apicall: void 'glTexCoord2s' (short short) module: 'opengl32.dll'>	^self externalCallFailed! !!OpenGL methodsFor: 'OpenGL API' stamp: 'ar 12/4/2003 20:57'!glTexCoord2sv(v)	"This method was automatically generated."	"void glTexCoord2sv(GLshort* v);"	<apicall: void 'glTexCoord2sv' (short*) module: 'opengl32.dll'>	^self externalCallFailed! !!OpenGL methodsFor: 'OpenGL API' stamp: 'ar 12/4/2003 20:57'!glTexCoord3d(s, t, r)	"This method was automatically generated."	"void glTexCoord3d(GLdouble s, GLdouble t, GLdouble r);"	<apicall: void 'glTexCoord3d' (double double double) module: 'opengl32.dll'>	^self externalCallFailed! !!OpenGL methodsFor: 'OpenGL API' stamp: 'ar 12/4/2003 20:57'!glTexCoord3dv(v)	"This method was automatically generated."	"void glTexCoord3dv(GLdouble* v);"	<apicall: void 'glTexCoord3dv' (double*) module: 'opengl32.dll'>	^self externalCallFailed! !!OpenGL methodsFor: 'OpenGL API' stamp: 'ar 12/4/2003 20:57'!glTexCoord3f(s, t, r)	"This method was automatically generated."	"void glTexCoord3f(GLfloat s, GLfloat t, GLfloat r);"	<apicall: void 'glTexCoord3f' (float float float) module: 'opengl32.dll'>	^self externalCallFailed! !!OpenGL methodsFor: 'OpenGL API' stamp: 'ar 12/4/2003 20:57'!glTexCoord3fv(v)	"This method was automatically generated."	"void glTexCoord3fv(GLfloat* v);"	<apicall: void 'glTexCoord3fv' (float*) module: 'opengl32.dll'>	^self externalCallFailed! !!OpenGL methodsFor: 'OpenGL API' stamp: 'ar 12/4/2003 20:57'!glTexCoord3i(s, t, r)	"This method was automatically generated."	"void glTexCoord3i(GLint s, GLint t, GLint r);"	<apicall: void 'glTexCoord3i' (long long long) module: 'opengl32.dll'>	^self externalCallFailed! !!OpenGL methodsFor: 'OpenGL API' stamp: 'ar 12/4/2003 20:57'!glTexCoord3iv(v)	"This method was automatically generated."	"void glTexCoord3iv(GLint* v);"	<apicall: void 'glTexCoord3iv' (long*) module: 'opengl32.dll'>	^self externalCallFailed! !!OpenGL methodsFor: 'OpenGL API' stamp: 'ar 12/4/2003 20:57'!glTexCoord3s(s, t, r)	"This method was automatically generated."	"void glTexCoord3s(GLshort s, GLshort t, GLshort r);"	<apicall: void 'glTexCoord3s' (short short short) module: 'opengl32.dll'>	^self externalCallFailed! !!OpenGL methodsFor: 'OpenGL API' stamp: 'ar 12/4/2003 20:57'!glTexCoord3sv(v)	"This method was automatically generated."	"void glTexCoord3sv(GLshort* v);"	<apicall: void 'glTexCoord3sv' (short*) module: 'opengl32.dll'>	^self externalCallFailed! !!OpenGL methodsFor: 'OpenGL API' stamp: 'ar 12/4/2003 20:57'!glTexCoord4d(s, t, r, q)	"This method was automatically generated."	"void glTexCoord4d(GLdouble s, GLdouble t, GLdouble r, GLdouble q);"	<apicall: void 'glTexCoord4d' (double double double double) module: 'opengl32.dll'>	^self externalCallFailed! !!OpenGL methodsFor: 'OpenGL API' stamp: 'ar 12/4/2003 20:57'!glTexCoord4dv(v)	"This method was automatically generated."	"void glTexCoord4dv(GLdouble* v);"	<apicall: void 'glTexCoord4dv' (double*) module: 'opengl32.dll'>	^self externalCallFailed! !!OpenGL methodsFor: 'OpenGL API' stamp: 'ar 12/4/2003 20:57'!glTexCoord4f(s, t, r, q)	"This method was automatically generated."	"void glTexCoord4f(GLfloat s, GLfloat t, GLfloat r, GLfloat q);"	<apicall: void 'glTexCoord4f' (float float float float) module: 'opengl32.dll'>	^self externalCallFailed! !!OpenGL methodsFor: 'OpenGL API' stamp: 'ar 12/4/2003 20:57'!glTexCoord4fv(v)	"This method was automatically generated."	"void glTexCoord4fv(GLfloat* v);"	<apicall: void 'glTexCoord4fv' (float*) module: 'opengl32.dll'>	^self externalCallFailed! !!OpenGL methodsFor: 'OpenGL API' stamp: 'ar 12/4/2003 20:57'!glTexCoord4i(s, t, r, q)	"This method was automatically generated."	"void glTexCoord4i(GLint s, GLint t, GLint r, GLint q);"	<apicall: void 'glTexCoord4i' (long long long long) module: 'opengl32.dll'>	^self externalCallFailed! !!OpenGL methodsFor: 'OpenGL API' stamp: 'ar 12/4/2003 20:57'!glTexCoord4iv(v)	"This method was automatically generated."	"void glTexCoord4iv(GLint* v);"	<apicall: void 'glTexCoord4iv' (long*) module: 'opengl32.dll'>	^self externalCallFailed! !!OpenGL methodsFor: 'OpenGL API' stamp: 'ar 12/4/2003 20:57'!glTexCoord4s(s, t, r, q)	"This method was automatically generated."	"void glTexCoord4s(GLshort s, GLshort t, GLshort r, GLshort q);"	<apicall: void 'glTexCoord4s' (short short short short) module: 'opengl32.dll'>	^self externalCallFailed! !!OpenGL methodsFor: 'OpenGL API' stamp: 'ar 12/4/2003 20:57'!glTexCoord4sv(v)	"This method was automatically generated."	"void glTexCoord4sv(GLshort* v);"	<apicall: void 'glTexCoord4sv' (short*) module: 'opengl32.dll'>	^self externalCallFailed! !!OpenGL methodsFor: 'OpenGL API' stamp: 'ar 12/4/2003 20:57'!glTexCoordPointer(size, type, stride, pointer)	"This method was automatically generated."	"void glTexCoordPointer(GLint size, GLenum type, GLsizei stride, GLvoid* pointer);"	<apicall: void 'glTexCoordPointer' (long ulong long void*) module: 'opengl32.dll'>	^self externalCallFailed! !!OpenGL methodsFor: 'OpenGL API' stamp: 'ar 12/4/2003 20:57'!glTexCoordPointerEXT(size, type, stride, count, pointer)	"This method was automatically generated."	"void glTexCoordPointerEXT(GLint size, GLenum type, GLsizei stride, GLsizei count, GLvoid* pointer);"	<apicall: void 'glTexCoordPointerEXT' (long ulong long long void*) module: 'opengl32.dll'>	^self externalCallFailed! !!OpenGL methodsFor: 'OpenGL API' stamp: 'ar 12/4/2003 20:57'!glTexEnvf(target, pname, param)	"This method was automatically generated."	"void glTexEnvf(GLenum target, GLenum pname, GLfloat param);"	<apicall: void 'glTexEnvf' (ulong ulong float) module: 'opengl32.dll'>	^self externalCallFailed! !!OpenGL methodsFor: 'OpenGL API' stamp: 'ar 12/4/2003 20:57'!glTexEnvfv(target, pname, params)	"This method was automatically generated."	"void glTexEnvfv(GLenum target, GLenum pname, GLfloat* params);"	<apicall: void 'glTexEnvfv' (ulong ulong float*) module: 'opengl32.dll'>	^self externalCallFailed! !!OpenGL methodsFor: 'OpenGL API' stamp: 'ar 12/4/2003 20:57'!glTexEnvi(target, pname, param)	"This method was automatically generated."	"void glTexEnvi(GLenum target, GLenum pname, GLint param);"	<apicall: void 'glTexEnvi' (ulong ulong long) module: 'opengl32.dll'>	^self externalCallFailed! !!OpenGL methodsFor: 'OpenGL API' stamp: 'ar 12/4/2003 20:57'!glTexEnviv(target, pname, params)	"This method was automatically generated."	"void glTexEnviv(GLenum target, GLenum pname, GLint* params);"	<apicall: void 'glTexEnviv' (ulong ulong long*) module: 'opengl32.dll'>	^self externalCallFailed! !!OpenGL methodsFor: 'OpenGL API' stamp: 'ar 12/4/2003 20:57'!glTexGend(coord, pname, param)	"This method was automatically generated."	"void glTexGend(GLenum coord, GLenum pname, GLdouble param);"	<apicall: void 'glTexGend' (ulong ulong double) module: 'opengl32.dll'>	^self externalCallFailed! !!OpenGL methodsFor: 'OpenGL API' stamp: 'ar 12/4/2003 20:57'!glTexGendv(coord, pname, params)	"This method was automatically generated."	"void glTexGendv(GLenum coord, GLenum pname, GLdouble* params);"	<apicall: void 'glTexGendv' (ulong ulong double*) module: 'opengl32.dll'>	^self externalCallFailed! !!OpenGL methodsFor: 'OpenGL API' stamp: 'ar 12/4/2003 20:57'!glTexGenf(coord, pname, param)	"This method was automatically generated."	"void glTexGenf(GLenum coord, GLenum pname, GLfloat param);"	<apicall: void 'glTexGenf' (ulong ulong float) module: 'opengl32.dll'>	^self externalCallFailed! !!OpenGL methodsFor: 'OpenGL API' stamp: 'ar 12/4/2003 20:57'!glTexGenfv(coord, pname, params)	"This method was automatically generated."	"void glTexGenfv(GLenum coord, GLenum pname, GLfloat* params);"	<apicall: void 'glTexGenfv' (ulong ulong float*) module: 'opengl32.dll'>	^self externalCallFailed! !!OpenGL methodsFor: 'OpenGL API' stamp: 'ar 12/4/2003 20:57'!glTexGeni(coord, pname, param)	"This method was automatically generated."	"void glTexGeni(GLenum coord, GLenum pname, GLint param);"	<apicall: void 'glTexGeni' (ulong ulong long) module: 'opengl32.dll'>	^self externalCallFailed! !!OpenGL methodsFor: 'OpenGL API' stamp: 'ar 12/4/2003 20:57'!glTexGeniv(coord, pname, params)	"This method was automatically generated."	"void glTexGeniv(GLenum coord, GLenum pname, GLint* params);"	<apicall: void 'glTexGeniv' (ulong ulong long*) module: 'opengl32.dll'>	^self externalCallFailed! !!OpenGL methodsFor: 'OpenGL API' stamp: 'ar 12/4/2003 20:57'!glTexImage1D(target, level, internalformat, width, border, format, type, pixels)	"This method was automatically generated."	"void glTexImage1D(GLenum target, GLint level, GLint internalformat, GLsizei width, GLint border, GLenum format, GLenum type, GLvoid* pixels);"	<apicall: void 'glTexImage1D' (ulong long long long long ulong ulong void*) module: 'opengl32.dll'>	^self externalCallFailed! !!OpenGL methodsFor: 'OpenGL API' stamp: 'ar 12/4/2003 20:57'!glTexImage2D(target, level, internalformat, width, height, border, format, type, pixels)	"This method was automatically generated."	"void glTexImage2D(GLenum target, GLint level, GLint internalformat, GLsizei width, GLsizei height, GLint border, GLenum format, GLenum type, GLvoid* pixels);"	<apicall: void 'glTexImage2D' (ulong long long long long long ulong ulong void*) module: 'opengl32.dll'>	^self externalCallFailed! !!OpenGL methodsFor: 'OpenGL API' stamp: 'ar 12/4/2003 20:57'!glTexImage3D(target, level, internalformat, width, height, depth, border, format, type, pixels)	"This method was automatically generated."	"void glTexImage3D(GLenum target, GLint level, GLenum internalformat, GLsizei width, GLsizei height, GLsizei depth, GLint border, GLenum format, GLenum type, GLvoid* pixels);"	<apicall: void 'glTexImage3D' (ulong long ulong long long long long ulong ulong void*) module: 'opengl32.dll'>	^self externalCallFailed! !!OpenGL methodsFor: 'OpenGL API' stamp: 'ar 12/4/2003 20:57'!glTexParameterf(target, pname, param)	"This method was automatically generated."	"void glTexParameterf(GLenum target, GLenum pname, GLfloat param);"	<apicall: void 'glTexParameterf' (ulong ulong float) module: 'opengl32.dll'>	^self externalCallFailed! !!OpenGL methodsFor: 'OpenGL API' stamp: 'ar 12/4/2003 20:57'!glTexParameterfv(target, pname, params)	"This method was automatically generated."	"void glTexParameterfv(GLenum target, GLenum pname, GLfloat* params);"	<apicall: void 'glTexParameterfv' (ulong ulong float*) module: 'opengl32.dll'>	^self externalCallFailed! !!OpenGL methodsFor: 'OpenGL API' stamp: 'ar 12/4/2003 20:57'!glTexParameteri(target, pname, param)	"This method was automatically generated."	"void glTexParameteri(GLenum target, GLenum pname, GLint param);"	<apicall: void 'glTexParameteri' (ulong ulong long) module: 'opengl32.dll'>	^self externalCallFailed! !!OpenGL methodsFor: 'OpenGL API' stamp: 'ar 12/4/2003 20:57'!glTexParameteriv(target, pname, params)	"This method was automatically generated."	"void glTexParameteriv(GLenum target, GLenum pname, GLint* params);"	<apicall: void 'glTexParameteriv' (ulong ulong long*) module: 'opengl32.dll'>	^self externalCallFailed! !!OpenGL methodsFor: 'OpenGL API' stamp: 'ar 12/4/2003 20:57'!glTexSubImage1D(target, level, xoffset, width, format, type, pixels)	"This method was automatically generated."	"void glTexSubImage1D(GLenum target, GLint level, GLint xoffset, GLsizei width, GLenum format, GLenum type, GLvoid* pixels);"	<apicall: void 'glTexSubImage1D' (ulong long long long ulong ulong void*) module: 'opengl32.dll'>	^self externalCallFailed! !!OpenGL methodsFor: 'OpenGL API' stamp: 'ar 12/4/2003 20:57'!glTexSubImage2D(target, level, xoffset, yoffset, width, height, format, type, pixels)	"This method was automatically generated."	"void glTexSubImage2D(GLenum target, GLint level, GLint xoffset, GLint yoffset, GLsizei width, GLsizei height, GLenum format, GLenum type, GLvoid* pixels);"	<apicall: void 'glTexSubImage2D' (ulong long long long long long ulong ulong void*) module: 'opengl32.dll'>	^self externalCallFailed! !!OpenGL methodsFor: 'OpenGL API' stamp: 'ar 12/4/2003 20:57'!glTexSubImage3D(target, level, xoffset, yoffset, zoffset, width, height, depth, format, type, pixels)	"This method was automatically generated."	"void glTexSubImage3D(GLenum target, GLint level, GLint xoffset, GLint yoffset, GLint zoffset, GLsizei width, GLsizei height, GLsizei depth, GLenum format, GLenum type, GLvoid* pixels);"	<apicall: void 'glTexSubImage3D' (ulong long long long long long long long ulong ulong void*) module: 'opengl32.dll'>	^self externalCallFailed! !!OpenGL methodsFor: 'OpenGL API' stamp: 'ar 12/4/2003 20:57'!glTranslated(x, y, z)	"This method was automatically generated."	"void glTranslated(GLdouble x, GLdouble y, GLdouble z);"	<apicall: void 'glTranslated' (double double double) module: 'opengl32.dll'>	^self externalCallFailed! !!OpenGL methodsFor: 'OpenGL API' stamp: 'ar 12/4/2003 20:57'!glTranslatef(x, y, z)	"This method was automatically generated."	"void glTranslatef(GLfloat x, GLfloat y, GLfloat z);"	<apicall: void 'glTranslatef' (float float float) module: 'opengl32.dll'>	^self externalCallFailed! !!OpenGL methodsFor: 'OpenGL API' stamp: 'ar 12/4/2003 20:57'!glVertex2d(x, y)	"This method was automatically generated."	"void glVertex2d(GLdouble x, GLdouble y);"	<apicall: void 'glVertex2d' (double double) module: 'opengl32.dll'>	^self externalCallFailed! !!OpenGL methodsFor: 'OpenGL API' stamp: 'ar 12/4/2003 20:57'!glVertex2dv(v)	"This method was automatically generated."	"void glVertex2dv(GLdouble* v);"	<apicall: void 'glVertex2dv' (double*) module: 'opengl32.dll'>	^self externalCallFailed! !!OpenGL methodsFor: 'OpenGL API' stamp: 'ar 12/4/2003 20:57'!glVertex2f(x, y)	"This method was automatically generated."	"void glVertex2f(GLfloat x, GLfloat y);"	<apicall: void 'glVertex2f' (float float) module: 'opengl32.dll'>	^self externalCallFailed! !!OpenGL methodsFor: 'OpenGL API' stamp: 'ar 12/4/2003 20:57'!glVertex2fv(v)	"This method was automatically generated."	"void glVertex2fv(GLfloat* v);"	<apicall: void 'glVertex2fv' (float*) module: 'opengl32.dll'>	^self externalCallFailed! !!OpenGL methodsFor: 'OpenGL API' stamp: 'ar 12/4/2003 20:57'!glVertex2i(x, y)	"This method was automatically generated."	"void glVertex2i(GLint x, GLint y);"	<apicall: void 'glVertex2i' (long long) module: 'opengl32.dll'>	^self externalCallFailed! !!OpenGL methodsFor: 'OpenGL API' stamp: 'ar 12/4/2003 20:57'!glVertex2iv(v)	"This method was automatically generated."	"void glVertex2iv(GLint* v);"	<apicall: void 'glVertex2iv' (long*) module: 'opengl32.dll'>	^self externalCallFailed! !!OpenGL methodsFor: 'OpenGL API' stamp: 'ar 12/4/2003 20:57'!glVertex2s(x, y)	"This method was automatically generated."	"void glVertex2s(GLshort x, GLshort y);"	<apicall: void 'glVertex2s' (short short) module: 'opengl32.dll'>	^self externalCallFailed! !!OpenGL methodsFor: 'OpenGL API' stamp: 'ar 12/4/2003 20:57'!glVertex2sv(v)	"This method was automatically generated."	"void glVertex2sv(GLshort* v);"	<apicall: void 'glVertex2sv' (short*) module: 'opengl32.dll'>	^self externalCallFailed! !!OpenGL methodsFor: 'OpenGL API' stamp: 'ar 12/4/2003 20:57'!glVertex3d(x, y, z)	"This method was automatically generated."	"void glVertex3d(GLdouble x, GLdouble y, GLdouble z);"	<apicall: void 'glVertex3d' (double double double) module: 'opengl32.dll'>	^self externalCallFailed! !!OpenGL methodsFor: 'OpenGL API' stamp: 'ar 12/4/2003 20:57'!glVertex3dv(v)	"This method was automatically generated."	"void glVertex3dv(GLdouble* v);"	<apicall: void 'glVertex3dv' (double*) module: 'opengl32.dll'>	^self externalCallFailed! !!OpenGL methodsFor: 'OpenGL API' stamp: 'ar 12/4/2003 20:57'!glVertex3f(x, y, z)	"This method was automatically generated."	"void glVertex3f(GLfloat x, GLfloat y, GLfloat z);"	<apicall: void 'glVertex3f' (float float float) module: 'opengl32.dll'>	^self externalCallFailed! !!OpenGL methodsFor: 'OpenGL API' stamp: 'ar 12/4/2003 20:57'!glVertex3fv(v)	"This method was automatically generated."	"void glVertex3fv(GLfloat* v);"	<apicall: void 'glVertex3fv' (float*) module: 'opengl32.dll'>	^self externalCallFailed! !!OpenGL methodsFor: 'OpenGL API' stamp: 'ar 12/4/2003 20:57'!glVertex3i(x, y, z)	"This method was automatically generated."	"void glVertex3i(GLint x, GLint y, GLint z);"	<apicall: void 'glVertex3i' (long long long) module: 'opengl32.dll'>	^self externalCallFailed! !!OpenGL methodsFor: 'OpenGL API' stamp: 'ar 12/4/2003 20:57'!glVertex3iv(v)	"This method was automatically generated."	"void glVertex3iv(GLint* v);"	<apicall: void 'glVertex3iv' (long*) module: 'opengl32.dll'>	^self externalCallFailed! !!OpenGL methodsFor: 'OpenGL API' stamp: 'ar 12/4/2003 20:57'!glVertex3s(x, y, z)	"This method was automatically generated."	"void glVertex3s(GLshort x, GLshort y, GLshort z);"	<apicall: void 'glVertex3s' (short short short) module: 'opengl32.dll'>	^self externalCallFailed! !!OpenGL methodsFor: 'OpenGL API' stamp: 'ar 12/4/2003 20:57'!glVertex3sv(v)	"This method was automatically generated."	"void glVertex3sv(GLshort* v);"	<apicall: void 'glVertex3sv' (short*) module: 'opengl32.dll'>	^self externalCallFailed! !!OpenGL methodsFor: 'OpenGL API' stamp: 'ar 12/4/2003 20:57'!glVertex4d(x, y, z, w)	"This method was automatically generated."	"void glVertex4d(GLdouble x, GLdouble y, GLdouble z, GLdouble w);"	<apicall: void 'glVertex4d' (double double double double) module: 'opengl32.dll'>	^self externalCallFailed! !!OpenGL methodsFor: 'OpenGL API' stamp: 'ar 12/4/2003 20:57'!glVertex4dv(v)	"This method was automatically generated."	"void glVertex4dv(GLdouble* v);"	<apicall: void 'glVertex4dv' (double*) module: 'opengl32.dll'>	^self externalCallFailed! !!OpenGL methodsFor: 'OpenGL API' stamp: 'ar 12/4/2003 20:57'!glVertex4f(x, y, z, w)	"This method was automatically generated."	"void glVertex4f(GLfloat x, GLfloat y, GLfloat z, GLfloat w);"	<apicall: void 'glVertex4f' (float float float float) module: 'opengl32.dll'>	^self externalCallFailed! !!OpenGL methodsFor: 'OpenGL API' stamp: 'ar 12/4/2003 20:57'!glVertex4fv(v)	"This method was automatically generated."	"void glVertex4fv(GLfloat* v);"	<apicall: void 'glVertex4fv' (float*) module: 'opengl32.dll'>	^self externalCallFailed! !!OpenGL methodsFor: 'OpenGL API' stamp: 'ar 12/4/2003 20:57'!glVertex4i(x, y, z, w)	"This method was automatically generated."	"void glVertex4i(GLint x, GLint y, GLint z, GLint w);"	<apicall: void 'glVertex4i' (long long long long) module: 'opengl32.dll'>	^self externalCallFailed! !!OpenGL methodsFor: 'OpenGL API' stamp: 'ar 12/4/2003 20:57'!glVertex4iv(v)	"This method was automatically generated."	"void glVertex4iv(GLint* v);"	<apicall: void 'glVertex4iv' (long*) module: 'opengl32.dll'>	^self externalCallFailed! !!OpenGL methodsFor: 'OpenGL API' stamp: 'ar 12/4/2003 20:57'!glVertex4s(x, y, z, w)	"This method was automatically generated."	"void glVertex4s(GLshort x, GLshort y, GLshort z, GLshort w);"	<apicall: void 'glVertex4s' (short short short short) module: 'opengl32.dll'>	^self externalCallFailed! !!OpenGL methodsFor: 'OpenGL API' stamp: 'ar 12/4/2003 20:57'!glVertex4sv(v)	"This method was automatically generated."	"void glVertex4sv(GLshort* v);"	<apicall: void 'glVertex4sv' (short*) module: 'opengl32.dll'>	^self externalCallFailed! !!OpenGL methodsFor: 'OpenGL API' stamp: 'ar 12/4/2003 20:57'!glVertexPointer(size, type, stride, pointer)	"This method was automatically generated."	"void glVertexPointer(GLint size, GLenum type, GLsizei stride, GLvoid* pointer);"	<apicall: void 'glVertexPointer' (long ulong long void*) module: 'opengl32.dll'>	^self externalCallFailed! !!OpenGL methodsFor: 'OpenGL API' stamp: 'ar 12/4/2003 20:57'!glVertexPointerEXT(size, type, stride, count, pointer)	"This method was automatically generated."	"void glVertexPointerEXT(GLint size, GLenum type, GLsizei stride, GLsizei count, GLvoid* pointer);"	<apicall: void 'glVertexPointerEXT' (long ulong long long void*) module: 'opengl32.dll'>	^self externalCallFailed! !!OpenGL methodsFor: 'OpenGL API' stamp: 'ar 12/4/2003 20:57'!glViewport(x, y, width, height)	"This method was automatically generated."	"void glViewport(GLint x, GLint y, GLsizei width, GLsizei height);"	<apicall: void 'glViewport' (long long long long) module: 'opengl32.dll'>	^self externalCallFailed! !!OpenGL methodsFor: 'display lists' stamp: 'das 3/12/2004 12:54'!instance	^instance "return unique id for this ogl rendering instance"! !!OpenGL methodsFor: 'display lists' stamp: 'ar 9/6/2002 01:45'!registerList: glListID range: range owner: anObject	"Remember that anObject owns a display list"	glListRegistry at: anObject put: (Array with: glListID with: range)! !!OpenGL methodsFor: 'display lists' stamp: 'ar 9/6/2002 17:01'!unregisterList: anObject	glListRegistry removeKey: anObject ifAbsent:[].! !!OpenGL methodsFor: 'private' stamp: 'das 3/12/2004 15:19'!privateInstallLibrary: glLibraryName	"Do a bit of reflective hacking so that we don't have to carry around lots and lots of duplicate methods for the OpenGL API on each platform. The only 'real' difference is the name of the appropriate shared library here. Indeed, we could (nay... we SHOULD) have done this through a subclass of ExternalLibrary which handles this for us but since we haven't, get out the reflective hammer and nail down the problem."	| lit |	InstalledOpenGLLibrary = glLibraryName ifTrue:[^self].	OpenGL methodsDo:[:meth|		lit := meth numLiterals > 0 ifTrue:[meth literalAt: 1].		lit class == ExternalLibraryFunction ifTrue:[lit setModule: glLibraryName].	].	InstalledOpenGLLibrary := glLibraryName.! !!OpenGL methodsFor: 'private' stamp: 'das 8/26/2004 20:21'!test2D| s |true ifTrue:[	s _ 10.	self glMatrixMode: GLModelview.	self glLoadIdentity.	self glDisable: GLDepthTest.	self glTranslated: 0 with: 0 with: -1.0.	self glEnable: GLBlend.	self glBlendFunc: GLSrcAlpha with: GLOneMinusSrcAlpha.	self glColor4f: 0 with: 0 with: 0 with: 1.	self		glBegin: GLQuads;			glVertex2f: 0.0 with: 0.0;			glVertex2f: 0.0 with: s;			glVertex2f: s with: s;			glVertex2f: s with: 0.0;		glEnd.	self 		glEnable: GLBlend;		glBlendFunc: GLSrcAlpha with: GLOneMinusSrcAlpha;		glColor4f: 0.0 with: 0.0 with: 0.0 with: 0.5;		glLineWidth: 1;		glBegin: GLLineLoop;			glVertex2f: 0 with: s;			glVertex2f: 0 with: 0;			glVertex2f: s with: s;			glVertex2f:s with: 0;		glEnd;		glColor4f: 1.0 with: 1.0 with: 1.0 with: 0.5;		glBegin: GLQuads;			glVertex2f: 0 + 0.1 with: s - 0.1;			glVertex2f: 0 + 0.1 with: 0 + 0.1;			glVertex2f: s - 0.1 with: 0 + 0.1;			glVertex2f: s - 0.1 with: s - 0.1;		glEnd;		glDisable: GLBlend.].! !!OpenGL methodsFor: 'gotchas' stamp: 'ar 6/30/2002 20:20'!popMatrix	^self error:'Use glPopMatrix'! !!OpenGL methodsFor: 'gotchas' stamp: 'ar 6/30/2002 20:20'!pushMatrix	^self error:'Use glPushMatrix'! !!OpenGL methodsFor: 'text support' stamp: 'das 3/12/2004 12:28'!drawParagraph: para color: aColor at: pt align: aSymbol	| rect offset blt scanner |	offset := 0@0.	aSymbol ifNotNil:[		rect := para bounds.		offset := (rect perform: aSymbol) negated.	].	blt := OGLBlt new initialize: self.	blt textOffset: offset.	blt textPosition: pt.	scanner := (DisplayScanner new text: para text textStyle: para textStyle			foreground: aColor background: Color transparent fillBlt: nil			ignoreColorChanges: false)		setPort: blt.	para positionWhenComposed ifNil:[para positionWhenComposed: 0@0].	para displayOn: blt using: scanner at: offset.! !!OpenGL methodsFor: 'text support' stamp: 'ar 6/12/2002 04:53'!drawString: s at: pt	^ self drawString: s at: pt font: nil color: Color blue! !!OpenGL methodsFor: 'text support' stamp: 'ar 6/12/2002 04:53'!drawString: s at: pt font: aFont color: aColor	self glRasterPos3f: pt x with: pt y with: pt z.	self glColor4f: aColor red with: aColor green with: aColor blue with: aColor alpha.	fontManager drawString: s from: 1 to: s size font: (aFont ifNil:[TextStyle defaultFont])! !!OpenGL methodsFor: 'text support' stamp: 'ar 6/23/2002 17:13'!drawString: s at: pt font: aFont color: aColor align: align	self glColor4f: aColor red with: aColor green with: aColor blue with: aColor alpha.	self glRasterPos3f: pt x with: pt y with: pt z.	fontManager drawString: s from: 1 to: s size font: (aFont ifNil:[TextStyle defaultFont]) align: align.! !!OpenGL methodsFor: 'text support' stamp: 'ar 6/23/2002 20:44'!drawString: s from: startIndex to: stopIndex at: pt font: font	self glRasterPos3f: pt x with: pt y with: pt z.	fontManager drawString: s from: startIndex to: stopIndex font: (font ifNil:[TextStyle defaultFont]) align: nil.! !!OpenGL methodsFor: 'text support' stamp: 'ar 6/30/2002 21:56'!drawString: s from: startIndex to: stopIndex at: pt font: font align: align	self glRasterPos3f: pt x with: pt y with: pt z.	fontManager drawString: s from: startIndex to: stopIndex font: (font ifNil:[TextStyle defaultFont]) align: align.! !!OpenGL methodsFor: 'text support' stamp: 'ar 6/30/2002 21:28'!drawString: s from: startIndex to: stopIndex at: pt font: font color: aColor	self glColor4f: aColor red with: aColor green with: aColor blue with: aColor alpha.	self glRasterPos3f: pt x with: pt y with: pt z.	fontManager drawString: s from: startIndex to: stopIndex font: (font ifNil:[TextStyle defaultFont]) align: nil.! !!OpenGL methodsFor: 'text support' stamp: 'ar 6/23/2002 19:30'!drawStringRect: extent at: pt color: aColor align: align	self glColor4f: aColor red with: aColor green with: aColor blue with: aColor alpha.	self glRasterPos3f: pt x with: pt y with: pt z.	fontManager drawStringRect: extent align: align.! !!OpenGL methodsFor: 'text support' stamp: 'ar 6/23/2002 19:38'!frameStringRect: extent at: pt color: aColor align: align	self glColor4f: aColor red with: aColor green with: aColor blue with: aColor alpha.	self glRasterPos3f: pt x with: pt y with: pt z.	fontManager frameStringRect: extent align: align.! !!OGLMacOSX methodsFor: 'accessing' stamp: 'ar 6/26/2002 19:13'!imagePixelFormat32	^GLBgra! !!OGLMacOSX methodsFor: 'accessing' stamp: 'ar 6/26/2002 19:13'!imagePixelType32	^GLUnsignedInt8888Rev! !!OGLMacOSX methodsFor: 'accessing' stamp: 'ar 6/26/2002 19:16'!textureInternalFormat	^GLRgba! !!OGLMacOSX methodsFor: 'accessing' stamp: 'ar 6/26/2002 19:13'!texturePixelFormat	^GLBgra! !!OGLMacOSX methodsFor: 'accessing' stamp: 'ar 6/26/2002 19:14'!texturePixelType	^GLUnsignedInt8888Rev! !!OGLMacOSX methodsFor: 'initialize' stamp: 'ar 12/4/2003 21:01'!openGLLibraryName	^'OpenGL.framework'! !!OGLMacOS9 methodsFor: 'initialize' stamp: 'ar 12/4/2003 21:00'!openGLLibraryName	^'OpenGLLibrary'! !!OGLUnix methodsFor: 'accessing' stamp: 'bf 10/21/2002 19:10'!imagePixelFormat32	^GLBgra! !!OGLUnix methodsFor: 'accessing' stamp: 'bf 10/21/2002 20:03'!imagePixelType32	^GLUnsignedByte! !!OGLUnix methodsFor: 'accessing' stamp: 'bf 10/21/2002 19:15'!textureInternalFormat	^GLRgba! !!OGLUnix methodsFor: 'accessing' stamp: 'bf 10/21/2002 19:09'!texturePixelFormat	^GLBgra! !!OGLUnix methodsFor: 'accessing' stamp: 'bf 10/21/2002 19:10'!texturePixelType	^GLUnsignedByte! !!OGLUnix methodsFor: 'initialize' stamp: 'ar 12/4/2003 21:01'!openGLLibraryName	^'GL'! !!OGLUnixQuartz methodsFor: 'accessing' stamp: 'ikp 1/7/2003 21:14'!imagePixelFormat32	^GLBgra! !!OGLUnixQuartz methodsFor: 'accessing' stamp: 'ikp 1/7/2003 21:14'!imagePixelType32	^GLUnsignedInt8888Rev! !!OGLUnixQuartz methodsFor: 'accessing' stamp: 'ikp 1/7/2003 21:14'!textureInternalFormat	^GLRgba! !!OGLUnixQuartz methodsFor: 'accessing' stamp: 'ikp 1/7/2003 21:14'!texturePixelFormat	^GLBgra! !!OGLUnixQuartz methodsFor: 'accessing' stamp: 'ikp 1/7/2003 21:14'!texturePixelType	^GLUnsignedInt8888Rev! !!OGLUnixQuartz methodsFor: 'initialize' stamp: 'ar 12/4/2003 21:01'!openGLLibraryName	^'OpenGL'! !!OGLUnixX11BE methodsFor: 'accessing' stamp: 'ikp 2/3/2003 17:01'!imagePixelType32	^GLUnsignedInt8888Rev! !!OGLUnixX11BE methodsFor: 'accessing' stamp: 'ikp 2/3/2003 17:02'!texturePixelType	^GLUnsignedInt8888Rev! !!OGLUnixX11LE methodsFor: 'accessing' stamp: 'ikp 2/3/2003 17:01'!imagePixelType32	^GLUnsignedByte! !!OGLUnixX11LE methodsFor: 'accessing' stamp: 'ikp 2/3/2003 17:02'!texturePixelType	^GLUnsignedByte! !!OGLUnixX11LE methodsFor: 'intitialize' stamp: 'ikp 2/3/2003 17:00'!beginFrame	super beginFrame.	self glPixelStorei: GLUnpackLsbFirst with: 0.! !!OGLWin32 methodsFor: 'accessing' stamp: 'ar 1/4/2003 00:07'!glExtCallingConvention	"Answer the calling convention for extension functions"	^ExternalFunction callTypeAPI! !!OGLWin32 methodsFor: 'accessing' stamp: 'ar 1/4/2003 00:09'!glExtGetProcAddress: aString	"Answer the function address for the given extension function"	<apicall: ulong 'wglGetProcAddress' (char*) module: 'opengl32.dll'>	^0! !!OGLWin32 methodsFor: 'accessing' stamp: 'ar 6/26/2002 19:10'!imagePixelFormat32	^GLBgra! !!OGLWin32 methodsFor: 'accessing' stamp: 'ar 6/26/2002 20:03'!imagePixelType32	^GLUnsignedByte! !!OGLWin32 methodsFor: 'accessing' stamp: 'ar 6/26/2002 19:15'!textureInternalFormat	^GLRgba! !!OGLWin32 methodsFor: 'accessing' stamp: 'ar 6/26/2002 19:09'!texturePixelFormat	^GLBgra! !!OGLWin32 methodsFor: 'accessing' stamp: 'ar 6/26/2002 19:10'!texturePixelType	^GLUnsignedByte! !!OGLWin32 methodsFor: 'initialize' stamp: 'ar 6/26/2002 19:08'!beginFrame	super beginFrame.	self glPixelStorei: GLUnpackLsbFirst with: 0.! !!OGLWin32 methodsFor: 'initialize' stamp: 'ar 12/4/2003 21:01'!openGLLibraryName	^'opengl32.dll'! !!OpenGL class methodsFor: 'instance creation' stamp: 'das 3/12/2004 12:42'!new	Smalltalk platformName = 'Win32' ifTrue:[^OGLWin32 basicNew initialize].	Smalltalk platformName = 'unix'		ifTrue:			[(Smalltalk windowSystemName = 'Quartz')				"implicitly big endian"				ifTrue: [^OGLUnixQuartz basicNew initialize].				"default to X11 window system"				Smalltalk isLittleEndian					ifTrue: [^OGLUnixX11LE basicNew initialize]					ifFalse: [^OGLUnixX11BE basicNew initialize]].	Smalltalk platformName = 'Mac OS' ifTrue:[		Smalltalk osVersion asNumber < 1000 			ifTrue: [^OGLMacOS9 basicNew initialize]			ifFalse:[^OGLMacOSX basicNew initialize].	].	^self error:'Cannot identify platform'! !!OpenGL class methodsFor: 'compiling' stamp: 'ar 5/18/2004 16:50'!addSelector: aSelector withMethod: aMethod	"Flush the installed OGL library to force relinking"	InstalledOpenGLLibrary := nil.	^super addSelector: aSelector withMethod: aMethod! !!OGLUnixQuartz class methodsFor: 'as yet unclassified' stamp: 'das 3/12/2004 12:55'!test	"OGLUnixOSX test"	<cdecl: void 'ffiTest2' (long long) module: 'B3DAcceleratorPlugin'>	^self error: 'test failed'! !!OGLUnixQuartz class methodsFor: 'as yet unclassified' stamp: 'das 3/12/2004 12:55'!test: x with: y	"OGLUnixOSX test: 6 with: 7"	<cdecl: void 'ffiTest2' (long long) module: 'B3DAcceleratorPlugin'>	^self error: 'test failed'! !!OpenGLMorph methodsFor: 'acceleration'!accelerationEnabled	"Return true if hardware acceleration is enabled"	self accelerationSuspended ifTrue:[^false].	^self valueOfProperty: #accelerationEnabled ifAbsent:[false]! !!OpenGLMorph methodsFor: 'acceleration'!accelerationEnabled: aBool	"Enable or disable hardware acceleration"	myRenderer ifNotNil:[		myRenderer destroy.		myRenderer _ nil].	aBool		ifTrue:[self setProperty: #accelerationEnabled toValue: aBool]		ifFalse:[self removeProperty: #accelerationEnabled]! !!OpenGLMorph methodsFor: 'acceleration'!accelerationSuspended	"Return true if hardware acceleration is temporarily suspended"	^self valueOfProperty: #accelerationSuspended ifAbsent:[false]! !!OpenGLMorph methodsFor: 'acceleration'!accelerationSuspended: aBool	"Temporarily suspend hardware acceleration"	aBool		ifTrue:[self setProperty: #accelerationSuspended toValue: aBool]		ifFalse:[self removeProperty: #accelerationSuspended]! !!OpenGLMorph methodsFor: 'acceleration'!restoreAcceleration	"Restore temporarily suspend acceleration"	self accelerationSuspended: false.! !!OpenGLMorph methodsFor: 'acceleration'!suspendAcceleration	"Temporarily suspend acceleration"	myRenderer ifNotNil:[myRenderer destroy].	myRenderer _ nil.	self accelerationSuspended: true.	self changed.! !!OpenGLMorph methodsFor: 'drawing'!areasRemainingToFill: aRectangle	"Minimize overdraw"	(color isColor and:[color isOpaque]) ifFalse: [^ Array with: aRectangle].	^ aRectangle areasOutside: self bounds! !!OpenGLMorph methodsFor: 'drawing'!drawAcceleratedOn: aCanvas	"Management for the HWA renderer"	| myRect |	myRect _ (self bounds: bounds in: nil) intersect: (0@0 extent: DisplayScreen actualScreenSize).	(myRenderer notNil and:[myRenderer isAccelerated]) ifFalse:[		myRenderer ifNotNil:[myRenderer destroy].		myRenderer _ nil.	].	myRenderer ifNotNil:[		myRenderer _ myRenderer bufferRect: myRect.	].	myRenderer ifNil:[		myRenderer _ B3DHardwareEngine newIn: myRect.		myRenderer ifNil:[^self drawSimulatedOn: aCanvas].	] ifNotNil:[		myRenderer reset.	].	myRenderer viewportOffset: aCanvas origin.	myRenderer clipRect: aCanvas clipRect.	self renderOn: myRenderer.	Display addExtraRegion: myRect for: self.! !!OpenGLMorph methodsFor: 'drawing'!drawOn: aCanvas 	"Figure out if we can use HWA or if we need to simulate"	(aCanvas form == Display and:[self accelerationEnabled and:[self isFlexed not]])		ifTrue:[self drawAcceleratedOn: aCanvas]		ifFalse:[self drawSimulatedOn: aCanvas].! !!OpenGLMorph methodsFor: 'drawing'!drawSimulatedOn: aCanvas	"Draw the receiver using the builtin software renderer.	NOTE TO DAVE: The builtin renderer is not GL capable so we just drop this."	(myRenderer notNil and:[myRenderer isOverlayRenderer]) ifTrue:[		"Dump it. We may just being dragged around by the hand."		myRenderer destroy.		myRenderer _ nil].	aCanvas fillRectangle: self bounds color: self color.! !!OpenGLMorph methodsFor: 'drawing'!forceToScreen	"When using hardware acceleration, this method forces the receiver to swap its buffers."	myRenderer ifNotNil:[		myRenderer swapBuffers ifFalse:[			"Something went wrong"			myRenderer destroy.			myRenderer _ nil]].! !!OpenGLMorph methodsFor: 'drawing'!renderOn: aRenderer	(color isTransparent or:[color isTranslucent]) 		ifTrue:[aRenderer restoreMorphicBackground: self bounds under: self].	aRenderer viewport: self bounds.	aRenderer clearDepthBuffer.	color isTransparent 		ifFalse:[aRenderer clearViewport: color].	aRenderer loadIdentity.	aRenderer isOpenGLRenderer		ifTrue:[self glRenderOn: aRenderer].	aRenderer restoreMorphicForeground: self bounds above: self.! !!OpenGLMorph methodsFor: 'initialize'!delete	myRenderer		ifNotNil: [myRenderer destroy].	super delete! !!OpenGLMorph methodsFor: 'initialize'!initialize	super initialize.	self accelerationEnabled: true.	self		color: (Color				r: 0.7				g: 0.9				b: 1.0).	bounds _ 0 @ 0 corner: 400 @ 300.! !!OpenGLMorph methodsFor: 'initialize'!intoWorld: aWorld	"The receiver is showing in the given world"	aWorld ifNil:[^self].	super intoWorld: aWorld.	aWorld when: #aboutToLeaveWorld send: #suspendAcceleration to: self.	aWorld when: #aboutToEnterWorld send: #restoreAcceleration to: self.	self restoreAcceleration.! !!OpenGLMorph methodsFor: 'initialize' stamp: 'ar 3/9/2004 19:10'!outOfWorld: aWorld	"The receiver is leaving the given world"	aWorld ifNil:[^self].	self suspendAcceleration.	aWorld removeActionsWithReceiver: self.	super outOfWorld: aWorld.! !!OpenGLMorph methodsFor: 'OpenGL rendering'!glRenderOn: aRenderer	"Here's the top level entry for rendering. Viewport has been set, depth buffer is cleared. Do the rendering. Don't call swap buffers. Make sure you check for the validity of any display lists (when we create a temporary new renderer we don't share any display lists!!!!!!)"| dx dy |"aRenderer	glViewport: 0 with: 0 with: (bounds width) with: (bounds height).aRenderer	glLoadIdentity.aRenderer	glMatrixMode: GLProjection."bounds width > bounds height ifTrue:[dx _ 1.0. dy _ ((bounds height)/(bounds width) asFloat).]							  ifFalse:[dy _ 1.0. dx _ ((bounds width)/(bounds height) asFloat).].aRenderer	glFrustum: (dx negated) with: dx with: (dy negated) with: dy with: 0.5 with: 100.aRenderer 	glTranslatef: 0.0 with: 0.0 with: -1.2.aRenderer	glClear: GLColorBufferBit.aRenderer	glColor3f: 1.0 with: 0.0 with: 0.0.aRenderer	glBegin: GLTriangles;		glVertex3f: 1.0 with: 0.0 with: 0.0;		glVertex3f: 0.0 with: (2.0 sqrt) with: 0.0;		glVertex3f: -1.0 with: 0.0 with: 0.0;	glEnd."	aRenderer 		glBegin: GLPolygon;			glVertex2f: -0.9 with: -0.9;			glColor3f: 1.0 with: 0.0 with: 0.0;			glVertex2f: 0.9 with: -0.9;			glColor3f: 0.0 with: 1.0 with: 0.0;			glVertex2f: 0.9 with: 0.9;			glColor3f: 0.0 with: 0.0 with: 1.0;			glVertex2f: -0.9 with: 0.9;			glColor3f: 1.0 with: 1.0 with: 0.0;		glEnd."aRenderer	glFlush.! !!OpenGLMorph methodsFor: 'fileIn/Out' stamp: 'ar 9/6/2002 15:47'!prepareToExportOn: exporter	super prepareToExportOn: exporter.	myRenderer := nil.! !!OpenGLMorph methodsFor: 'stepping'!step	self changed.! !!OpenGLMorph methodsFor: 'stepping'!stepTime	^0 "every frame"! !!OpenGLMorph methodsFor: 'stepping'!wantsSteps	^true! !!OpenGLMorph class methodsFor: 'as yet unclassified'!descriptionForPartsBin	^ self partName:	'OpenGL'		categories:		#('OpenGL')		documentation:	'Prototype OpenGL Engine test bed.'! !!OpenGLMorph class methodsFor: 'as yet unclassified'!includeInNewMorphMenu	^true! !!OrderedCollection methodsFor: '*Croquet' stamp: 'das 5/24/2003 19:38'!next: oldObject "find the object after this one and return it. If we are at the end return the first item."	| index found |	found _ false.	index _ firstIndex.	[index <= lastIndex]		whileTrue:			[			found ifTrue:[ ^ array at: index ].			(array at: index) = oldObject ifTrue: [ 				index = lastIndex ifTrue:[^ array at: firstIndex].				found _ true.].			index _ index + 1].	self errorNotFound: oldObject! !!OrderedCollection methodsFor: '*Croquet' stamp: 'das 5/24/2003 19:40'!previous: oldObject "find the object after this one and return it. If we are at the end return the first item."	| index found |	found _ false.	index _ lastIndex.	[index >= firstIndex]		whileTrue:			[			found ifTrue:[ ^ array at: index ].			(array at: index) = oldObject ifTrue: [ 				index = firstIndex ifTrue:[^ array at: lastIndex].				found _ true.].			index _ index - 1].	self errorNotFound: oldObject! !!OrderedCollection methodsFor: '*Croquet' stamp: 'ar 6/12/2002 19:49'!removeAll	"Remove all elements of the receiver"	firstIndex to: lastIndex do: [:index | array at: index put: nil].	lastIndex _ firstIndex - 1! !!OrderedCollection methodsFor: '*Croquet' stamp: 'das 5/24/2003 19:30'!replace: oldObject with: newObject	| index |	index _ firstIndex.	[index <= lastIndex]		whileTrue:			[(array at: index) = oldObject ifTrue: [ array at: index put: newObject. ^ index].			index _ index + 1].	self errorNotFound: oldObject! !!PasteUpMorph methodsFor: '*Croquet' stamp: 'ar 6/22/2002 19:14'!assuredCanvas		^worldState assuredCanvasFor: self! !!PasteUpMorph methodsFor: '*Croquet' stamp: 'ar 1/17/2002 18:51'!canvas: x	worldState canvas: x.! !!PasteUpMorph methodsFor: '*Croquet' stamp: 'ar 7/16/2002 01:03'!drawOn: aCanvas	"Update and draw the turtleTrails form. See the comment in updateTrailsForm."	self isWorldMorph		ifTrue:[aCanvas fillColor: self color]		ifFalse:[super drawOn: aCanvas].	(self griddingOn and: [self gridVisible]) ifTrue:		[aCanvas fillRectangle: self bounds fillStyle:			(self gridFormOrigin: self gridOrigin + self position grid: self gridModulus background: nil line: Color lightGray)].	self updateTrailsForm.	turtleTrailsForm ifNotNil: [aCanvas paintImage: turtleTrailsForm at: self position].	(submorphs size > 0 and: [self indicateCursor]) ifTrue:		[aCanvas			frameRectangle: self selectedRect			width: 2			color: Color black].! !!PasteUpMorph methodsFor: '*Croquet' stamp: 'ar 7/17/2001 20:21'!enableScriptProcesses	^worldState enableScriptProcesses! !!PasteUpMorph methodsFor: '*Croquet' stamp: 'ar 7/17/2001 20:21'!enableScriptProcesses: aBool	worldState enableScriptProcesses: aBool! !!PasteUpMorph methodsFor: '*Croquet' stamp: 'ar 1/17/2002 21:31'!invalidRect: damageRect from: aMorph	"Clip damage reports to my bounds, since drawing is clipped to my bounds."	self isWorldMorph		ifTrue: [worldState recordDamagedRect: damageRect].	^super invalidRect: damageRect from: aMorph! !!PasteUpMorph methodsFor: '*Croquet' stamp: 'ar 9/6/2002 15:47'!prepareToExportOn: exporter	super prepareToExportOn: exporter.	worldState := nil.	self removeProperty: #myProject.! !!PasteUpMorph methodsFor: '*Croquet' stamp: 'ar 3/19/2002 11:26'!project	"Find the project that owns me.  Not efficient to call this."	| prj |	^self valueOfProperty: #myProject ifAbsent:[		prj := Project ofWorld: self.		self project: prj.		prj].! !!PasteUpMorph methodsFor: '*Croquet' stamp: 'ar 3/19/2002 11:25'!project: aProject	self setProperty: #myProject toValue: aProject! !!PasteUpMorph methodsFor: '*Croquet' stamp: 'ar 7/20/2001 23:18'!worldScriptScheduler	^worldState worldScriptScheduler! !!PluggableTextMorph methodsFor: '*Croquet' stamp: 'ar 10/10/2002 20:05'!bindingOf: aString	^self model bindingOf: aString! !!PluggableTextMorph methodsFor: '*Croquet' stamp: 'ar 6/28/2002 21:53'!update: aSymbol	aSymbol ifNil: [^ self].	aSymbol == #flash ifTrue: [^ self flash].	aSymbol == getTextSelector ifTrue:			[self setText: self getText.			^ self setSelection: self getSelection].	aSymbol == getSelectionSelector ifTrue: [^ self setSelection: self getSelection].	(aSymbol == #autoSelect and: [getSelectionSelector ~~ nil]) ifTrue:			[self handleEdit:				[ParagraphEditor abandonChangeText.	"no replacement!!"				textMorph editor setSearch: model autoSelectString;							againOrSame: true]].	aSymbol == #clearUserEdits ifTrue: [^ self hasUnacceptedEdits: false].	aSymbol == #wantToChange ifTrue:			[self canDiscardEdits ifFalse: [^ self promptForCancel].			^ self].	aSymbol == #appendEntry ifTrue:			[self handleEdit: [self appendEntry].			^ self "refreshWorld"].	aSymbol == #clearText ifTrue:			[self handleEdit: [self changeText: Text new].			^ self refreshWorld].	aSymbol == #bs ifTrue:			[self handleEdit: [self bsText].			^ self refreshWorld].	aSymbol == #codeChangedElsewhere ifTrue:			[self hasEditingConflicts: true.			^ self changed]! !!Point methodsFor: '*Croquet'!area	^x*y! !!Point methodsFor: '*Croquet' stamp: 'ar 8/26/2002 19:04'!asLargerPowerOfTwo	^x asLargerPowerOfTwo @ y asLargerPowerOfTwo! !!Point methodsFor: '*Croquet' stamp: 'ar 8/26/2002 19:03'!asPowerOfTwo	^x asPowerOfTwo @ y asPowerOfTwo! !!Point methodsFor: '*Croquet' stamp: 'ar 8/26/2002 19:03'!asSmallerPowerOfTwo	^x asSmallerPowerOfTwo @ y asSmallerPowerOfTwo! !!Point methodsFor: '*Croquet' stamp: 'ar 6/23/2002 17:47'!w	^1! !!Point methodsFor: '*Croquet' stamp: 'ar 6/23/2002 17:47'!z	^0! !!PositionableStream methodsFor: '*Croquet' stamp: 'ar 6/5/2002 22:40'!nextBytesInto: byteObject	| bytes |	bytes := self next: byteObject basicSize.	byteObject replaceFrom: 1 to: bytes size with: bytes startingAt: 1.	^byteObject! !!PositionableStream methodsFor: '*Croquet' stamp: 'ar 6/5/2002 23:31'!nextInt32	"Read a 32-bit signed integer from the next 4 bytes"	^(self next: 4) longAt: 1 bigEndian: true! !!PositionableStream methodsFor: '*Croquet' stamp: 'ar 6/5/2002 23:37'!nextInt32Put: int32	"Write a signed integer to the next 4 bytes"	^self nextPutAll: ((ByteArray new: 4) longAt: 1 put: int32 bigEndian: true; yourself).! !!PositionableStream methodsFor: '*Croquet' stamp: 'ar 6/5/2002 23:32'!nextUInt32	"Read a 32-bit signed integer from the next 4 bytes"	^(self next: 4) unsignedLongAt: 1 bigEndian: true! !!PositionableStream methodsFor: '*Croquet' stamp: 'ar 6/5/2002 23:40'!nextUInt32Put: int32	"Write a signed integer to the next 4 bytes"	^self nextPutAll: ((ByteArray new: 4) unsignedLongAt: 1 put: int32 bigEndian: true; yourself).! !!PositionableStream methodsFor: '*Croquet' stamp: 'ar 6/5/2002 22:36'!nextWordsInto: aBitmap 	| blt pos source |	"Fill the word based buffer from my collection.	Stored on stream as Big Endian.  Optimized for speed.	Read in BigEndian, then restoreEndianness."	collection class isBytes ifFalse: [		^ self next: aBitmap basicSize into: aBitmap startingAt: 1.	].	"1 to: aBitmap size do: [:index | aBitmap at: index put: (self nextNumber: 4)]."	(self position \\ 4 = 0 and: [collection basicSize \\ 4 = 0]) ifTrue: [		source _ collection.  		pos _ self position.		self skip: aBitmap basicSize * aBitmap bytesPerElement "1, 2, or 4"	] ifFalse: [		source _ self next: aBitmap basicSize * aBitmap bytesPerElement.		"forced to copy it into a buffer"		pos _ 0	].	blt _ (BitBlt current toForm: (Form new hackBits: aBitmap)) 				sourceForm: (Form new hackBits: source).	blt combinationRule: Form over.  "store"	blt sourceX: 0; sourceY: pos // 4; height: aBitmap basicSize; width: 4.	blt destX: 0; destY: 0.	blt copyBits.	aBitmap restoreEndianness.	"May be WordArray, ColorArray, etc"	^ aBitmap! !!PositionableStream methodsFor: '*Croquet' stamp: 'ar 6/5/2002 23:17'!readWordsInto: aBitmap 	| blt string |	string _ self next: aBitmap basicSize * 4.	blt _ (BitBlt current toForm: (Form new hackBits: aBitmap)) 				sourceForm: (Form new hackBits: string).	blt combinationRule: Form over.  "store"	blt sourceX: 0; sourceY:  0; height: aBitmap basicSize; width: 4.	blt destX: 0; destY: 0.	blt copyBits.	^ aBitmap! !!PositionableStream methodsFor: '*Croquet' stamp: 'ar 6/6/2002 00:25'!storeWordsFrom: aCollection	"Write the argument a word-like object in big endian format on the receiver.	May be used to write other than plain word-like objects (such as ColorArray)."	| bytes |	bytes := ByteArray new: aCollection basicSize * 4.	(Form new hackBits: aCollection) displayOn: (Form new hackBits: bytes).	self nextPutAll: bytes.	^aCollection! !!PositionableStream methodsFor: '*Croquet' stamp: 'ar 9/30/2004 19:22'!upToAnyOf: aCharacterSet 	"Answer string until aCharacterSet found. The answer INCLUDES the 	character "	"'test' readStream upToAnyOf: {$e} asCharacterSet"	| pos buffer count |	pos _ self position.	buffer _ self next: 100.	(count _ String					findFirstInString: buffer					inSet: aCharacterSet byteArrayMap					startingAt: 1) > 0		ifTrue: [self position: pos + count.			^ buffer copyFrom: 1 to: count].	self atEnd		ifTrue: ["Never found it, and hit end of file"			^ buffer , Character end asString].	"Never found it, but there's more..."	^ buffer		, (self upToAnyOf: aCharacterSet)! !!Process methodsFor: '*Croquet' stamp: 'das 10/1/2004 11:03'!hostName	^ TeaHost currentHostName.! !!Process methodsFor: '*Croquet' stamp: 'das 10/1/2004 18:53'!nextObjectNumber	^ TeaHost nextObjectNumber.! !!Process methodsFor: '*Croquet' stamp: 'das 10/1/2004 11:03'!objectNumber	^ TeaHost nextObjectNumber.! !!Process methodsFor: '*Croquet' stamp: 'ar 6/6/2002 22:34'!teaExportOn: exporter	^self error: 'Cannot export'! !!ProcessorScheduler methodsFor: '*Croquet' stamp: 'ar 6/6/2002 22:34'!teaExportOn: exporter	^self error: 'Cannot export'! !!Project methodsFor: '*Croquet' stamp: 'das 7/14/2003 18:36'!displayZoom: entering	"Show the project transition when entering a new project"	| newDisplay vanishingPoint |	"Play the flash transition if any."	self projectParameters at: #flashTransition ifPresent:[:dict|		dict at: CurrentProject ifPresent:[:player| ^player playProjectTransitionFrom: CurrentProject to: self entering: entering]].	"Show animated zoom to new display"	newDisplay _ self imageForm."	entering		ifTrue: [vanishingPoint _ Sensor cursorPoint]		ifFalse: [vanishingPoint _ self viewLocFor: CurrentProject].	Display zoomIn: entering orOutTo: newDisplay at: 0@0			vanishingPoint: vanishingPoint."! !!Project methodsFor: '*Croquet' stamp: 'ar 3/19/2002 11:24'!enter: returningFlag revert: revertFlag saveForRevert: saveForRevert	"Install my ChangeSet, Transcript, and scheduled views as current globals. If returningFlag is true, we will return to the project from whence the current project was entered; don't change its previousProject link in this case.	If saveForRevert is true, save the ImageSegment of the project being left.	If revertFlag is true, make stubs for the world of the project being left.	If revertWithoutAsking is true in the project being left, then always revert."	| showZoom recorderOrNil old forceRevert response seg newProcess owner |	owner := RequestProjectOwner signal.	owner ifNotNil:[^owner enter: returningFlag project: self].	(world isKindOf: StringMorph) ifTrue: [		self inform: 'This project is not all here. I will try to load a complete version.'.		^self loadFromServer: true	"try to get a fresh copy"	].	self isCurrentProject ifTrue: [^ self].	"Check the guards"	guards ifNotNil:		[guards _ guards reject: [:obj | obj isNil].		guards do: [:obj | obj okayToEnterProject ifFalse: [^ self]]].	CurrentProject world triggerEvent: #aboutToLeaveWorld.	forceRevert _ false.	CurrentProject rawParameters 		ifNil: [revertFlag ifTrue: [^ self inform: 'nothing to revert to']]		ifNotNil: [saveForRevert ifFalse: [				forceRevert _ CurrentProject projectParameters 								at: #revertWithoutAsking ifAbsent: [false]]].	forceRevert not & revertFlag ifTrue: [		response _ SelectionMenu confirm: 'Are you sure you want to destroy this Project\ and revert to an older version?\\(From the parent project, click on this project''s thumbnail.)' withCRs			trueChoice: 'Revert to saved version' 			falseChoice: 'Cancel'.		response ifFalse: [^ self]].	revertFlag | forceRevert 		ifTrue: [seg _ CurrentProject projectParameters at: #revertToMe ifAbsent: [					^ self inform: 'nothing to revert to']]		ifFalse: [			CurrentProject finalExitActions.			CurrentProject makeThumbnail.			returningFlag == #specialReturn				ifTrue:					[ProjectHistory forget: CurrentProject.		"this guy is irrelevant"					Project forget: CurrentProject]				ifFalse:					[ProjectHistory remember: CurrentProject]].	(revertFlag | saveForRevert | forceRevert) ifFalse:		[(Preferences valueOfFlag: #projectsSentToDisk) ifTrue:			[self storeToMakeRoom]].	CurrentProject abortResourceLoading.	Smalltalk isMorphic ifTrue: [CurrentProject world triggerClosingScripts].	CurrentProject saveProjectPreferences.	"Update the display depth and make a thumbnail of the current project"	CurrentProject displayDepth: Display depth.	old _ CurrentProject.		"for later"	"Show the project transition.	Note: The project zoom is run in the context of the old project,		so that eventual errors can be handled accordingly"	displayDepth == nil ifTrue: [displayDepth _ Display depth].	self installNewDisplay: Display extent depth: displayDepth.	(showZoom _ self showZoom) ifTrue: [		self displayZoom: CurrentProject parent ~~ self].	(world isMorph and: [world hasProperty: #letTheMusicPlay])		ifTrue: [world removeProperty: #letTheMusicPlay]		ifFalse: [Smalltalk at: #ScorePlayer ifPresentAndInMemory:					[:playerClass | playerClass allSubInstancesDo:						[:player | player pause]]].	returningFlag == #specialReturn ifTrue: [		old removeChangeSetIfPossible.	"keep this stuff from accumulating"		nextProject _ nil	] ifFalse: [		returningFlag			ifTrue: [nextProject _ CurrentProject]			ifFalse: [previousProject _ CurrentProject].	].	CurrentProject saveState.	CurrentProject isolationHead == self isolationHead ifFalse:		[self invokeFrom: CurrentProject].	CurrentProject _ self.	self installProjectPreferences.	Smalltalk newChanges: changeSet.	TranscriptStream newTranscript: transcript.	Sensor flushKeyboard.	Smalltalk isMorphic ifTrue: [recorderOrNil _ World pauseEventRecorder].	ProjectHistory remember: CurrentProject.	world isMorph		ifTrue:			[World _ world.  "Signifies Morphic"			world install.			world transferRemoteServerFrom: old world.			"(revertFlag | saveForRevert | forceRevert) ifFalse: [				(Preferences valueOfFlag: #projectsSentToDisk) ifTrue: [					self storeSomeSegment]]."			recorderOrNil ifNotNil: [recorderOrNil resumeIn: world].			world triggerOpeningScripts]		ifFalse:			[World _ nil.  "Signifies MVC"			Smalltalk at: #ScheduledControllers put: world].	saveForRevert ifTrue: [		Smalltalk garbageCollect.	"let go of pointers"		old storeSegment.		"result _" old world isInMemory 			ifTrue: ['Can''t seem to write the project.']			ifFalse: [old projectParameters at: #revertToMe put: 					old world xxxSegment clone].				'Project written.'].			"original is for coming back in and continuing."	revertFlag | forceRevert ifTrue: [		seg clone revert].	"non-cloned one is for reverting again later"	self removeParameter: #exportState.	"Complete the enter: by launching a new process"	world isMorph ifTrue: [		self finalEnterActions.		world repairEmbeddedWorlds.		world triggerEvent: #aboutToEnterWorld.		Project spawnNewProcessAndTerminateOld: true	] ifFalse: [		SystemWindow clearTopWindow.	"break external ref to this project"		newProcess _ [				ScheduledControllers resetActiveController.	"in case of walkback in #restore"			showZoom ifFalse: [ScheduledControllers restore].			ScheduledControllers searchForActiveController		] fixTemps newProcess priority: Processor userSchedulingPriority.		newProcess resume.		"lose the current process and its referenced morphs"		Processor terminateActive.	]! !!Project methodsFor: '*Croquet' stamp: 'ar 3/19/2002 11:39'!enterTeaProject	ProjectHistory remember: self.	world triggerOpeningScripts.	self finalEnterActions.	world triggerEvent: #aboutToEnterWorld.! !!Project methodsFor: '*Croquet' stamp: 'ar 3/20/2002 23:50'!leaveTeaProject	self world triggerEvent: #aboutToLeaveWorld.	self finalExitActions.	self makeThumbnail.	ProjectHistory remember: self.	self abortResourceLoading.	self world triggerClosingScripts.	self saveProjectPreferences.! !!Project methodsFor: '*Croquet' stamp: 'ar 3/21/2002 23:46'!makeThumbnail	"Make a thumbnail image of this project from the Display."	| image |	world isMorph ifTrue: [world displayWorldSafely]. "clean pending damage"	viewSize ifNil: [viewSize _ Display extent // 8].	thumbnail _ Form extent: viewSize depth: Display depth.	world == World 		ifTrue:[image := Display] 		ifFalse:[image := world imageFormForRectangle: world bounds].	(WarpBlt current toForm: thumbnail)			sourceForm: image;			cellSize: 2;  "installs a colormap"			combinationRule: Form over;			copyQuad: (image boundingBox) innerCorners			toRect: (0@0 extent: viewSize).	InternalThreadNavigationMorph cacheThumbnailFor: self.	^thumbnail! !!Project methodsFor: '*Croquet' stamp: 'ar 3/19/2002 11:34'!mayEnterTeaProject	"Can we enter this project?"	(world isKindOf: StringMorph) ifTrue: [		self inform: 'This project is not all here'.		^false].	"Check the guards"	guards ifNotNil:		[guards _ guards reject: [:obj | obj isNil].		guards do: [:obj | obj okayToEnterProject ifFalse: [^ false]]].	^true! !!Project methodsFor: '*Croquet' stamp: 'ar 6/6/2002 22:34'!teaExportOn: exporter	^self error: 'Cannot export'! !!Project class methodsFor: '*Croquet' stamp: 'ar 9/23/2002 02:23'!alphabeticalNamesAndProjects	"Answer a list of all project names, with each entry preceded by white space commensurate with its depth beneath the top project"	^(Project allProjects collect:[:p| {p name. p}]) asArray sort:[:p1 :p2|		p1 first asLowercase <= p2 first asLowercase.	].! !!Project class methodsFor: '*Croquet' stamp: 'ar 9/23/2002 02:23'!buildJumpToMenu: menu	"Make the supplied menu offer a list of potential projects, consisting of:		*	The previous-project chain		*	The next project, if any		*	The parent project, if any		*	All projects, hierarchically"	| prev listed i next  toAdd |	listed _ OrderedCollection with: CurrentProject.	i _ 0.	"The previous Project chain"	prev _ CurrentProject previousProject.	[(prev ~~ nil and: [(listed includes: prev) not])] whileTrue:	  [i _ i + 1.		listed add: prev.		self 	addItem: prev name , ' (back ' , i printString , ')'				toMenu: menu 				selection: ('%back' , i printString) 				project: prev.		prev _ prev previousProject].	i > 0 ifTrue: [menu addLine].	"Then the next Project"	(((next _ CurrentProject nextProject) ~~ nil) and: [(listed includes: next) not]) ifTrue:		[self	addItem: (next name, ' (forward 1)') 				toMenu: menu 				selection: next name 				project: next]. 	next ~~ nil ifTrue: [menu addLine].	"Then the parent"	CurrentProject isTopProject ifFalse: 		[self	addItem: CurrentProject parent name , ' (parent)' 				toMenu: menu 				selection: #parent 				project: CurrentProject parent.		  menu addLine].	"Finally all the projects, in hierarchical order"	Project alphabeticalNamesAndProjects do:		[:aPair | 			toAdd _ aPair last isCurrentProject				ifTrue:				  [aPair first, ' (current)']				ifFalse:				  [aPair first].			self	addItem: toAdd 				toMenu: menu 				selection: aPair first 				project: aPair last].	^ menu! !!ProjectViewMorph methodsFor: '*Croquet' stamp: 'ar 3/20/2002 21:34'!enter	"Enter my project."	project class == DiskProxy ifFalse: [		(project world notNil and: [project world isMorph and:				[project world hasOwner: self outermostWorldMorph]]) ifTrue: [			^1 beep		"project is open in a window already"		].	].	project class == DiskProxy ifTrue: ["When target is not in yet"		self enterWhenNotPresent.	"will bring it in"		project class == DiskProxy ifTrue: [^self inform: 'Project not found']].	(owner isKindOf: SystemWindow)		ifTrue: [project setViewSize: self extent].	self showMouseState: 3.	project enter: false revert: false saveForRevert: false.! !!ReadWriteStream methodsFor: '*Croquet' stamp: 'ar 6/7/2002 00:53'!setFileTypeToObject! !!RequestProjectOwner methodsFor: 'exceptionDescription' stamp: 'ar 3/19/2002 11:22'!defaultAction	"No action is taken. The value nil is returned as the value of the message that signaled the exception."	^nil! !!RequestProjectOwner methodsFor: 'exceptionDescription' stamp: 'ar 3/19/2002 11:22'!isResumable	^true! !!ResourceLocator methodsFor: '*Croquet' stamp: 'ar 6/6/2002 12:57'!isLoaded	^localFileName notNil! !!ResourceLocator methodsFor: '*Croquet' stamp: 'ar 9/6/2002 15:47'!prepareToExportOn: exporter	super prepareToExportOn: exporter.	localFileName := nil.! !!ScriptProcess methodsFor: '*Croquet' stamp: 'ar 10/2/2004 13:04'!hostName	^(self valueOfProperty: #hostName) ifNil:[super hostName]! !!ScriptProcess methodsFor: '*Croquet' stamp: 'ar 10/2/2004 13:04'!nextObjectNumber	| val |	val _ self valueOfProperty: #objectCounter.	val ifNil:[^super nextObjectNumber].	val _ val + 1.	self setProperty: #objectCounter toValue: val.	^ val.! !!ScriptProcess methodsFor: '*Croquet' stamp: 'ar 10/2/2004 13:04'!objectNumber	^(self valueOfProperty: #objectNumber) ifNil:[super objectNumber]! !!SharedQueue methodsFor: '*Croquet' stamp: 'ar 6/13/2003 02:09'!contents	| contents |	contents := #().	accessProtect critical:[		readPosition < writePosition ifTrue:[			contents := contentsArray copyFrom: readPosition to: writePosition-1.			contentsArray from: readPosition to: writePosition-1 put: nil.			readPosition := writePosition := 1.		].	].	^contents! !!ShortIntegerArray methodsFor: '*Croquet' stamp: 'ar 6/5/2002 23:09'!swapEndianness	Smalltalk swapHalvesIn: self from: 1 to: self basicSize! !!ShortRunArray methodsFor: '*Croquet' stamp: 'ar 6/5/2002 23:10'!swapEndianness	Smalltalk swapHalvesIn: self from: 1 to: self basicSize! !!SmallInteger methodsFor: '*Croquet' stamp: 'ar 6/5/2002 23:34'!teaExportLiteralOn: byteStream	byteStream nextInt32Put: self.! !!SmallInteger methodsFor: '*Croquet' stamp: 'ar 6/6/2002 22:34'!teaExportOn: exporter	^exporter exportLiteral: self! !!SmallInteger class methodsFor: '*Croquet' stamp: 'ar 6/5/2002 23:33'!teaImportLiteralFrom: byteStream	^byteStream nextInt32! !!SoundBuffer methodsFor: '*Croquet' stamp: 'ar 3/13/2002 00:28'!byteSize	^self basicSize * 4! !!SoundBuffer methodsFor: '*Croquet' stamp: 'das 4/11/2003 12:22'!meterLevel	"Update the meter level with the maximum signal level in the given range of the given buffer."	| max sample |	max _ 0.	1 to: self size do: [:i |		sample _ self at: i.		sample < 0 ifTrue: [sample _ sample negated].		sample > max ifTrue: [max _ sample]].	^ max.! !!SoundBuffer methodsFor: '*Croquet' stamp: 'ar 6/5/2002 23:10'!swapEndianness	Smalltalk swapHalvesIn: self from: 1 to: self basicSize! !!SoundCodec methodsFor: '*Croquet' stamp: 'yo 2/27/2003 17:48'!compressSoundNoReset: aSound	"Compress the entirety of the given sound with this codec. Answer a CompressedSoundData."	| compressed channels |	compressed _ CompressedSoundData new		codecName: self class name;		soundClassName: aSound class name.	(aSound isKindOf: SampledSound) ifTrue: [		channels _ Array new: 1.		channels at: 1 put: (self encodeSoundBufferNoReset: aSound samples).		compressed			channels: channels;			samplingRate: aSound originalSamplingRate;			firstSample: 1;			loopEnd: aSound samples size;			loopLength: 0.0;			perceivedPitch: 100.0;			gain: aSound loudness.		^ compressed].	(aSound isKindOf: LoopedSampledSound) ifTrue: [		aSound isStereo			ifTrue: [				channels _ Array new: 2.				channels at: 1 put: (self encodeSoundBuffer: aSound leftSamples).				channels at: 2 put: (self encodeSoundBuffer: aSound rightSamples)]			ifFalse: [				channels _ Array new: 1.				channels at: 1 put: (self encodeSoundBuffer: aSound leftSamples)].		compressed			channels: channels;			samplingRate: aSound originalSamplingRate;			firstSample: aSound firstSample;			loopEnd: aSound loopEnd;			loopLength: aSound loopLength;			perceivedPitch: aSound perceivedPitch;			gain: aSound gain.		^ compressed].	self error: 'you can only compress sampled sounds'.! !!SoundCodec methodsFor: '*Croquet' stamp: 'yo 3/24/2003 17:23'!compressSoundNoReset: aSound atRate: desiredSampleRate	"Compress the entirety of the given sound with this codec. Answer a CompressedSoundData."	| compressed channels samples newRate ratio buffer |	compressed _ CompressedSoundData new		codecName: self class name;		soundClassName: aSound class name.	(aSound isKindOf: SampledSound) ifTrue: [		(desiredSampleRate isNil or: 				[(ratio _ aSound originalSamplingRate // desiredSampleRate) <= 1]) ifTrue: [			samples _ aSound samples.			newRate _ aSound originalSamplingRate.		] ifFalse: [			buffer _ aSound samples.			samples _ SoundBuffer 				averageEvery: ratio 				from: buffer 				upTo: buffer monoSampleCount.			newRate _ aSound originalSamplingRate / ratio.		].		channels _ Array new: 1.		channels at: 1 put: (self encodeSoundBufferNoReset: samples).		compressed			channels: channels;			samplingRate: newRate;			firstSample: 1;			loopEnd: samples size;			loopLength: 0.0;			perceivedPitch: 100.0;			gain: aSound loudness.		^ compressed].	(aSound isKindOf: LoopedSampledSound) ifTrue: [		aSound isStereo			ifTrue: [				channels _ Array new: 2.				channels at: 1 put: (self encodeSoundBufferNoReset: aSound leftSamples).				channels at: 2 put: (self encodeSoundBufferNoReset: aSound rightSamples)]			ifFalse: [				channels _ Array new: 1.				channels at: 1 put: (self encodeSoundBufferNoReset: aSound leftSamples)].		compressed			channels: channels;			samplingRate: aSound originalSamplingRate;			firstSample: aSound firstSample;			loopEnd: aSound loopEnd;			loopLength: aSound loopLength;			perceivedPitch: aSound perceivedPitch;			gain: aSound gain.		^ compressed].	self error: 'you can only compress sampled sounds'.! !!SoundCodec methodsFor: '*Croquet' stamp: 'yo 3/24/2003 17:30'!decodeCompressedDataNoReset: aByteArray	"Decode the entirety of the given encoded data buffer with this codec. Answer a monophonic SoundBuffer containing the uncompressed samples."	| frameCount result increments |	frameCount _ self frameCount: aByteArray.	result _ SoundBuffer newMonoSampleCount: frameCount * self samplesPerFrame.	"self reset."	increments _ self decodeFrames: frameCount from: aByteArray at: 1 into: result at: 1.	((increments first = aByteArray size) and: [increments last = result size]) ifFalse: [		self error: 'implementation problem; increment sizes should match buffer sizes'].	^ result! !!SoundCodec methodsFor: '*Croquet' stamp: 'yo 3/24/2003 17:30'!decompressSoundNoReset: aCompressedSound	"Decompress the entirety of the given compressed sound with this codec and answer the resulting sound."	| channels sound |	channels _ aCompressedSound channels		collect: [:compressed | self decodeCompressedDataNoReset: compressed].	'SampledSound' = aCompressedSound soundClassName ifTrue: [		sound _ SampledSound			samples: channels first			samplingRate: (aCompressedSound samplingRate).		sound loudness: aCompressedSound gain.		^ sound].	'LoopedSampledSound' = aCompressedSound soundClassName ifTrue: [		aCompressedSound loopLength = 0			ifTrue: [				sound _ LoopedSampledSound					unloopedSamples: channels first					pitch: aCompressedSound perceivedPitch					samplingRate: aCompressedSound samplingRate]			ifFalse: [				sound _ LoopedSampledSound					samples: channels first					loopEnd: aCompressedSound loopEnd					loopLength: aCompressedSound loopLength					pitch: aCompressedSound perceivedPitch					samplingRate: aCompressedSound samplingRate].		channels size > 1 ifTrue: [sound rightSamples: channels last].		sound			firstSample: aCompressedSound firstSample;			gain: aCompressedSound gain.		sound			setPitch: 100.0			dur: (channels first size / aCompressedSound samplingRate)			loudness: 1.0.		^ sound].	self error: 'unknown sound class'.! !!SoundCodec methodsFor: '*Croquet' stamp: 'yo 2/27/2003 17:48'!encodeSoundBufferNoReset: aSoundBuffer	"Encode the entirety of the given monophonic SoundBuffer with this codec. Answer a ByteArray containing the compressed sound data."	| codeFrameSize frameSize fullFrameCount lastFrameSamples result increments finalFrame i lastIncs |	frameSize _ self samplesPerFrame.	fullFrameCount _ aSoundBuffer monoSampleCount // frameSize.	lastFrameSamples _ aSoundBuffer monoSampleCount - (fullFrameCount * frameSize).	codeFrameSize _ self bytesPerEncodedFrame.	codeFrameSize = 0 ifTrue:		["Allow room for 1 byte per sample for variable-length compression"		codeFrameSize _ frameSize].	lastFrameSamples > 0		ifTrue: [result _ ByteArray new: (fullFrameCount + 1) * codeFrameSize]		ifFalse: [result _ ByteArray new: fullFrameCount * codeFrameSize].	"self reset."	increments _ self encodeFrames: fullFrameCount from: aSoundBuffer at: 1 into: result at: 1.	lastFrameSamples > 0 ifTrue: [		finalFrame _ SoundBuffer newMonoSampleCount: frameSize.		i _ fullFrameCount * frameSize.		1 to: lastFrameSamples do: [:j |			finalFrame at: j put: (aSoundBuffer at: (i _ i + 1))].		lastIncs _ self encodeFrames: 1 from: finalFrame at: 1 into: result at: 1 + increments second.		increments _ Array with: increments first + lastIncs first							with: increments second + lastIncs second].	increments second < result size		ifTrue: [^ result copyFrom: 1 to: increments second]		ifFalse: [^ result]! !!SoundPlayer class methodsFor: '*Croquet' stamp: 'das 6/15/2003 23:24'!hiThere	"Tests the sound output primitives by playing a scale."	"SoundPlayer boinkScale"	| sineTable pan |	self shutDown.	SamplingRate _ 11025.	Stereo _ true.	sineTable _ self sineTable: 1000.	Buffer _ SoundBuffer newStereoSampleCount: 1000.	BufferIndex _ 1.	self primSoundStartBufferSize: Buffer stereoSampleCount		rate: SamplingRate		stereo: Stereo.	pan _ 0.	#(261.626 329.628 391.996 ) do: [:p |		self boinkPitch: p dur: 0.3 loudness: 300 waveTable: sineTable pan: pan.		pan _ pan + 125].	self boinkPitch: 523.252 dur: 1.0 loudness: 300 waveTable: sineTable pan: 500.	self primSoundStop.	self shutDown.	SoundPlayer initialize.  "reset sampling rate, buffer size, and stereo flag"! !!SoundPlayer class methodsFor: '*Croquet' stamp: 'ar 1/26/2002 21:40'!isPlaying	^PlayerProcess notNil! !!SoundPlayer class methodsFor: '*Croquet' stamp: 'ar 3/12/2002 23:46'!mixLastBuffer: aBuffer	"Private -- debugging only"	"LastBuffer ifNotNil:[		LastBuffer replaceFrom: 1 to: (aBuffer size min: LastBuffer size) with: aBuffer startingAt: 1.	]."! !!SoundPlayer class methodsFor: '*Croquet' stamp: 'ar 3/13/2002 00:05'!soundVolume: volumeArray	"Set sound volume as array of doubles left then right channel, range is 0.0 to 1.0 but may be overdriven"	^self setVolumeLeft: volumeArray first volumeRight: volumeArray last.! !!SoundPlayer class methodsFor: '*Croquet' stamp: 'das 4/14/2003 02:22'!startPlayerProcessBufferSize: bufferSize rate: samplesPerSecond stereo: stereoFlag sound: aSound	"Start the sound player process. Terminate the old process, if any."	"SoundPlayer startPlayerProcessBufferSize: 1000 rate: 11025 stereo: false"	self stopPlayerProcess.	aSound		ifNil:[ActiveSounds _ OrderedCollection new]		ifNotNil:[ActiveSounds _ OrderedCollection with: aSound].	Buffer _ SoundBuffer newStereoSampleCount: (bufferSize // 4) * 4.	LastBuffer ifNotNil:[LastBuffer _ SoundBuffer basicNew: Buffer basicSize].	PlayerSemaphore _ Semaphore forMutualExclusion.	SamplingRate _ samplesPerSecond.	Stereo _ stereoFlag.	ReadyForBuffer _ Semaphore new.	SoundSupported _ true. "Assume so"	UseReadySemaphore _ true.  "set to false if ready semaphore not supported by VM"	self primSoundStartBufferSize: Buffer stereoSampleCount		rate: samplesPerSecond		stereo: Stereo		semaIndex: (Smalltalk registerExternalObject: ReadyForBuffer).	"Check if sound start prim was successful"	SoundSupported ifFalse:[^self].	UseReadySemaphore		ifTrue: [	PlayerProcess _ [SoundPlayer playLoop] newProcess]		ifFalse: [	PlayerProcess _ [SoundPlayer oldStylePlayLoop] newProcess].	UseReverb ifTrue: [self startReverb]."	PlayerProcess priority: Processor userInterruptPriority."	PlayerProcess priority: Processor highIOPriority.	PlayerProcess resume.! !!SpreadSheet methodsFor: 'initialization' stamp: 'das 3/4/2004 20:56'!drawOn: aCanvas	selectedField ifNotNil:[		aCanvas frameRectangle: (selectedField bounds translateBy:(-2@0)) color: Color black.].! !!SpreadSheet methodsFor: 'initialization' stamp: 'das 3/5/2004 03:56'!initialize	| rloc row cloc tm x y z |	super initialize.	self color: Color transparent.	self layoutPolicy: nil.	self hResizing: #rigid.	self vResizing: #rigid.	numRows _ 27.	numColumns _ 16.	colWidth _ OrderedCollection new.	rowHeight _ OrderedCollection new.	numColumns timesRepeat:[colWidth add:64].	numRows timesRepeat:[rowHeight add:28].	rows _ OrderedCollection new.	top _ 0.	left _ 0.	rloc _ top.	1 to: numRows do:[:r |		row _ OrderedCollection new.		cloc _ left.		1 to: numColumns do:[:c|			tm_SpreadSheetField new initialize: self row: r column:c.			row add: tm.			tm extent: (colWidth at: c)@(rowHeight at:r).			tm position: cloc@rloc.			cloc _ cloc + (colWidth at: c).			(r = 1 or:[c = 1])ifTrue:[				c = 1 ifTrue:[ 					r = 1 ifTrue:[tm contents:''.] 				ifFalse:[tm contents: '[',((r-1) asString),']'.]				]					ifFalse:[tm contents: ($A asInteger + c-2)asCharacter asString.].			tm margins: 4@0;centered.			tm fontName: #ComicBold size: 18; textColor: Color blue; backgroundColor: Color white.			] ifFalse:[			"compute the Sombrero function."			x_((c-(numColumns/2.0)) * 5.0/numColumns).			y_((r-(numRows/2.0))* 5.0/numRows).			z _ (((x*x)+(y*y)) cos) asString.			z size > 6 ifTrue:[				z _ z copyFrom: 1 to:6.].			tm contents: (z,'  ').			].			self addMorph: tm.			].		rows add: row.		rloc _ rloc + (rowHeight at: r).	].	self extent: cloc@rloc.		! !!SpreadSheet methodsFor: 'initialization' stamp: 'das 3/5/2004 03:50'!selectAll	| all |	tSpreadSheet ifNotNil:[			all _ OrderedCollection new.		rows do:[:r |			r do:[:c | all add: c]].		tSpreadSheet selectFields: all.].		! !!SpreadSheet methodsFor: 'initialization' stamp: 'das 3/5/2004 02:29'!selectColumn: cnum	| col |	col _ OrderedCollection new.	tSpreadSheet ifNotNil:[			rows do:[:r | col add: (r at: cnum)].		tSpreadSheet selectFields: col.].! !!SpreadSheet methodsFor: 'initialization' stamp: 'das 3/4/2004 23:20'!selectField: field	selectedField _ field.	selectedField ifNotNil:[		self invalidRect: (selectedField bounds translateBy:(-2@0))].	tSpreadSheet ifNotNil:[tSpreadSheet selectField: field.].! !!SpreadSheet methodsFor: 'initialization' stamp: 'das 3/5/2004 04:30'!selectRow: rnum	tSpreadSheet ifNotNil:[			tSpreadSheet selectFields: (rows at:rnum).].! !!SpreadSheet methodsFor: 'initialization' stamp: 'das 3/4/2004 22:07'!tSpreadSheet: tss	tSpreadSheet _ tss.! !!SpreadSheet methodsFor: 'initialization' stamp: 'das 3/4/2004 22:20'!updateField: field	tSpreadSheet ifNotNil:[tSpreadSheet updateField: field.].	selectedField ifNotNil:[		self invalidRect: (selectedField bounds translateBy:(-2@0))].	selectedField _ nil.! !!SpreadSheetField methodsFor: 'initialization' stamp: 'das 3/4/2004 20:13'!acceptContents	spreadSheet updateField: self.! !!SpreadSheetField methodsFor: 'initialization' stamp: 'das 3/4/2004 23:36'!initialize: ss	spreadSheet _ ss.	self crAction: (MessageSend receiver: self selector: #acceptContents).	self autoFit: false.! !!SpreadSheetField methodsFor: 'initialization' stamp: 'das 3/5/2004 01:52'!initialize: ss row:r column:c	spreadSheet _ ss.	self crAction: (MessageSend receiver: self selector: #acceptContents).	self autoFit: false.	row _ r.	column _ c.! !!SpreadSheetField methodsFor: 'initialization' stamp: 'das 3/5/2004 02:47'!mouseDown: evt	super mouseDown: evt.	(row=1 and:[column=1])ifTrue:[^spreadSheet selectAll].	row=1 ifTrue:[^spreadSheet selectColumn:column].	column=1 ifTrue:[^spreadSheet selectRow:row].	spreadSheet selectField: self.! !!SpreadSheetField methodsFor: 'initialization' stamp: 'das 3/4/2004 20:38'!releaseEditor	super releaseEditor.	self acceptContents.! !!StandardFileStream methodsFor: '*Croquet' stamp: 'bf 10/22/2002 17:22'!primOpen: fileName writable: writableFlag	"Open a file of the given name, and return the file ID obtained.	If writableFlag is true, then		if there is none with this name, then create one		else prepare to overwrite the existing from the beginning	otherwise		if the file exists, open it read-only		else return nil"	<primitive: 'primitiveFileOpen' module: 'FilePlugin'>	FileDirectory withCaseInsensitiveMatchFor: fileName		retry: [:match | ^ self primOpen: match writable: writableFlag].	^ nil! !!StandardFileStream methodsFor: '*Croquet' stamp: 'ar 6/6/2002 00:25'!storeWordsFrom: aCollection	"Write the argument a word-like object in big endian format on the receiver.	May be used to write other than plain word-like objects (such as ColorArray)."	^self nextPutAll: aCollection! !!StandardFileStream methodsFor: '*Croquet' stamp: 'ar 6/6/2002 22:38'!teaExportOn: exporter	^self error: 'Cannot export'! !!StreamingMP3Sound methodsFor: '*Croquet' stamp: 'ar 6/6/2002 15:25'!isLoaded	^mpegFile isLoaded! !!StrikeFont methodsFor: '*Croquet' stamp: 'ar 6/6/2002 22:34'!teaExportOn: exporter	^self error: 'Cannot export'! !!String methodsFor: '*Croquet' stamp: 'ar 7/21/2002 21:39'!yellowScriptSelectorParts	"Return the parts of some selector for yellow script matching"	| lastIndex nextIndex |	^Array streamContents:[:s|		nextIndex _ self indexOf: $: startingAt: 1 ifAbsent:[self size+1].		s nextPut: (self copyFrom: 1 to: nextIndex-1).		[nextIndex < self size] whileTrue:[			lastIndex _ nextIndex.			nextIndex _ self indexOf: $: startingAt: nextIndex+1 ifAbsent:[self size].			s nextPut: (self copyFrom: lastIndex+1 to: nextIndex-1).		].	].! !!StringMorph methodsFor: '*Croquet' stamp: 'ar 10/26/2002 19:30'!labelColor	^self color! !!StringMorph methodsFor: '*Croquet' stamp: 'ar 10/26/2002 19:31'!labelColor: aColor	self color: aColor.! !!StringMorph methodsFor: '*Croquet' stamp: 'ar 6/7/2002 01:00'!postImportFrom: importer	super postImportFrom: importer.	font := font comeFullyUpOnReload: nil.! !!StringMorph methodsFor: '*Croquet' stamp: 'ar 6/7/2002 00:59'!prepareToExportOn: exporter	super prepareToExportOn: exporter.	font ifNotNil:[		font _ DiskProxy global: #StrikeFont selector: #familyName:size:emphasized:			args: (Array with: font familyName with: font height with: font emphasis).	].! !!Symbol methodsFor: '*Croquet' stamp: 'ar 6/5/2002 23:35'!teaExportLiteralOn: byteStream	byteStream nextUInt32Put: self basicSize.	byteStream nextPutAll: self asByteArray! !!Symbol methodsFor: '*Croquet' stamp: 'ar 6/6/2002 22:34'!teaExportOn: exporter	^exporter exportLiteral: self! !!Symbol class methodsFor: '*Croquet' stamp: 'ar 6/5/2002 23:33'!teaImportLiteralFrom: byteStream	^(byteStream next: (byteStream nextUInt32)) asString asSymbol.! !!SystemDictionary methodsFor: '*Croquet' stamp: 'RAA 3/15/2001 10:54'!logError: errMsg inContext: aContext to: aFilename	"Log the error message and a stack trace to the given file."	| ff ctx |	FileDirectory default deleteFileNamed: aFilename ifAbsent: [].	(ff _ FileStream fileNamed: aFilename) ifNil: [^ self "avoid recursive errors"].  	ff print: Date today; space; print: Time now; cr.  	ff nextPutAll: errMsg; cr.	ff cr.	ff nextPutAll: 'VM: ';		nextPutAll: Smalltalk platformName asString;		nextPutAll: ' - ';		nextPutAll: Smalltalk vmVersion asString;		cr.	ff nextPutAll: 'Image: ';		nextPutAll: Smalltalk version asString;		nextPutAll: ' [';		nextPutAll: Smalltalk lastUpdateString asString;		nextPutAll: ']';		cr.	ff cr.	"Note: The following is an open-coded version of ContextPart>>stackOfSize:	since this method may be called during a low space condition and we might	run out of space for allocating the full stack."	ctx _ aContext.	[ctx == nil] whileFalse:[		ff print: ctx; cr.		ctx _ ctx sender].	ff close.! !!SystemDictionary methodsFor: '*Croquet' stamp: 'ar 6/5/2002 23:08'!swapHalvesIn: aNonPointerThing from: start to: stop	"Perform a bigEndian/littleEndian byte reversal of my words.	We only intend this for non-pointer arrays.  Do nothing if I contain pointers."	| hack blt |	"The implementation is a hack, but fast for large ranges"	hack _ Form new hackBits: aNonPointerThing.	blt _ (BitBlt toForm: hack) sourceForm: hack.	blt combinationRule: Form reverse.  "XOR"	blt sourceY: 0; destY: 0; height: self size; width: 1.	blt sourceX: 0; destX: 1; copyBits.  "Exchange bytes 0 and 1"	blt sourceX: 1; destX: 0; copyBits.	blt sourceX: 0; destX: 1; copyBits.	blt sourceX: 2; destX: 3; copyBits.  "Exchange bytes 2 and 3"	blt sourceX: 3; destX: 2; copyBits.	blt sourceX: 2; destX: 3; copyBits.! !!SystemDictionary methodsFor: '*Croquet' stamp: 'ar 6/6/2002 22:34'!teaExportOn: exporter	^self error: 'Cannot export'! !!SystemDictionary methodsFor: '*Croquet' stamp: 'ikp 2/3/2003 16:56'!windowSystemName			"Smalltalk windowSystemName"	"Answer the name of the window system currently being used for display."	^self getSystemAttribute: 1005! !!SystemOrganizer methodsFor: '*Croquet' stamp: 'ar 6/6/2002 22:34'!teaExportOn: exporter	^self error: 'Cannot export'! !!TBoundSphere methodsFor: 'access' stamp: 'das 4/24/2002 12:25'!addChild: child	children ifNil:[children _ OrderedCollection new.].	children add: child.! !!TBoundSphere methodsFor: 'access' stamp: 'das 4/25/2002 15:55'!box	^ box.! !!TBoundSphere methodsFor: 'access' stamp: 'das 4/25/2002 15:55'!box: bx	box _ bx.! !!TBoundSphere methodsFor: 'access' stamp: 'das 4/24/2002 12:25'!children	^ children.! !!TBoundSphere methodsFor: 'access' stamp: 'das 4/27/2002 15:25'!children: ch	children _ ch.! !!TBoundSphere methodsFor: 'access'!frame	^ frame.! !!TBoundSphere methodsFor: 'access'!globalPosition	^ globalPosition.! !!TBoundSphere methodsFor: 'access' stamp: 'ar 2/11/2003 18:12'!isLeafSphere	"Answer whether I am a leaf sphere"	^normal notNil! !!TBoundSphere methodsFor: 'access'!localPosition	^ localPosition.! !!TBoundSphere methodsFor: 'access'!localPosition: pos	localPosition _ pos.! !!TBoundSphere methodsFor: 'access'!localPosition: pos radius: rad	globalPosition _ B3DVector3 new.	self localPosition: pos.	self radius: rad.! !!TBoundSphere methodsFor: 'access'!radius	^ radius.! !!TBoundSphere methodsFor: 'access'!radius: rad	radius _ rad.	radiusSquared _ rad*rad.! !!TBoundSphere methodsFor: 'access'!radiusSquared	^ radiusSquared.! !!TBoundSphere methodsFor: 'access' stamp: 'yo 9/24/2003 12:20'!scale: scale	self radius: radius*scale.	self localPosition: (self localPosition * scale).	children do: [:each | (each isMemberOf: TBoundSphere) ifTrue: [each scale: scale]].! !!TBoundSphere methodsFor: 'access' stamp: 'das 5/6/2002 15:59'!sumFaces	| total |" Returns the number of faces in the leaves."	children ifNil:[^ 0].	vertices ifTrue:[^children size/3].	total _ 0.	children do:[:c | total _ total + c sumFaces.].	^total.! !!TBoundSphere methodsFor: 'access' stamp: 'das 5/6/2002 16:00'!sumNodes	| total |" Returns the total number of nodes in the tree."	children ifNil:[^ 1].	vertices ifNotNil:[^1].	total _ 1.	children do:[:c | total _ total + c sumNodes.].	^total.! !!TBoundSphere methodsFor: 'access' stamp: 'ar 6/22/2002 17:51'!volume	^4.0 / 3.0 * Float pi * radius * radius * radius! !!TBoundSphere methodsFor: 'construct' stamp: 'das 6/13/2002 10:18'!calcBoundSphere: verts	|  iP iN xmx xmn ymx ymn zmx zmn xspan yspan zspan maxSpan d1 d2 center radSq rad |	" This routine is from the Graphics Gems 1, C code on page 723. verts is a B3DVector3Array. It constructs a bounding sphere from the vertices."	iP _ Float infinity.	iN _ Float infinity negated.	xmx _ B3DVector3 x: iN y: iN z: iN.	ymx _ B3DVector3 x: iN y: iN z: iN.	zmx _ B3DVector3 x: iN y: iN z: iN.	xmn _ B3DVector3 x: iP y: iP z: iP.	ymn _ B3DVector3 x: iP y: iP z: iP.	zmn _ B3DVector3 x: iP y: iP z: iP." First pass, find a pair of maximally distant points between each axis."	verts do:[ :v |		v x > xmx x ifTrue:[ xmx _ v].		v x < xmn x ifTrue:[ xmn _ v].		v y > ymx y ifTrue:[ ymx _ v].		v y < ymn y ifTrue:[ ymn _ v].		v z > zmx z ifTrue:[ zmx _ v].		v z < zmn z ifTrue:[ zmn _ v].].	xspan _ (xmx-xmn) squaredLength.	yspan _ (ymx-ymn) squaredLength.	zspan _ (zmx-zmn) squaredLength.			maxSpan _ xspan.	d1 _ xmn.	d2 _ xmx.	yspan > maxSpan ifTrue:[maxSpan _ yspan. d1 _ ymn. d2 _ ymx.].	zspan > maxSpan ifTrue:[maxSpan _ zspan. d1 _ zmn. d2 _ zmx.].		center _ (d1 + d2)/2.0.	radSq _ (d1 - center) squaredLength.	rad _ radSq sqrt.	"Second pass, expand sphere to include outlying points."	verts do:[ :v |		d1 _ (v-center)squaredLength.		d1 > radSq ifTrue:[			d1 _ d1 sqrt.			rad _ (d1 + rad)/2.0.			radSq _ rad*rad.			d2 _ d1 - rad.			center _ ((rad * center) + (d2*v))/d1.			].		].	localPosition _ center.	radius _ rad.	radiusSquared _ radSq."	vertices _ verts. " "don't need this and it screws up other things later."	^  self.! !!TBoundSphere methodsFor: 'construct' stamp: 'das 5/6/2002 16:31'!calcBoundSphere: verts faces: faces	|  v iP iN xmx xmn ymx ymn zmx zmn xspan yspan zspan maxSpan d1 d2 center radSq rad |	" This routine is from the Graphics Gems 1, C code on page 723. verts is a B3DVector3Array. It constructs a bounding sphere based upon the faces and vertices."	iP _ Float infinity.	iN _ Float infinity negated.	xmx _ B3DVector3 x: iN y: iN z: iN.	ymx _ B3DVector3 x: iN y: iN z: iN.	zmx _ B3DVector3 x: iN y: iN z: iN.	xmn _ B3DVector3 x: iP y: iP z: iP.	ymn _ B3DVector3 x: iP y: iP z: iP.	zmn _ B3DVector3 x: iP y: iP z: iP." First pass, find a pair of maximally distant points between each axis."	faces do:[ :f |		v _ verts at:(f+1).		v x > xmx x ifTrue:[ xmx _ v].		v x < xmn x ifTrue:[ xmn _ v].		v y > ymx y ifTrue:[ ymx _ v].		v y < ymn y ifTrue:[ ymn _ v].		v z > zmx z ifTrue:[ zmx _ v].		v z < zmn z ifTrue:[ zmn _ v].].	xspan _ (xmx-xmn) squaredLength.	yspan _ (ymx-ymn) squaredLength.	zspan _ (zmx-zmn) squaredLength.			maxSpan _ xspan.	d1 _ xmn.	d2 _ xmx.	yspan > maxSpan ifTrue:[maxSpan _ yspan. d1 _ ymn. d2 _ ymx.].	zspan > maxSpan ifTrue:[maxSpan _ zspan. d1 _ zmn. d2 _ zmx.].		center _ (d1 + d2)/2.0.	radSq _ (d1 - center) squaredLength.	rad _ radSq sqrt.	"Second pass, expand sphere to include outlying points."	faces do:[ :f |		v _ verts at: (f+1).		d1 _ (v-center)squaredLength.		d1 > radSq ifTrue:[			d1 _ d1 sqrt.			rad _ (d1 + rad)/2.0.			radSq _ rad*rad.			d2 _ d1 - rad.			center _ ((rad * center) + (d2*v))/d1.			].		].	localPosition _ center.	radius _ rad.	radiusSquared _ radSq.	^  self.! !!TBoundSphere methodsFor: 'construct' stamp: 'das 6/13/2002 09:40'!calcSurface: verts faces: faces"This is for a first approximation - I may need a better solution later."	| n nabs m nlist ray t |	normal _ B3DVector3 new.	nlist _ OrderedCollection new.	1 to: faces size by: 3 do:[ :i |				n _ 		(((verts at:1+(faces at: i)) - (verts at:1+(faces at: i+1))) cross:		(((verts at:1+(faces at: i)) - (verts at:1+(faces at: i+2))))).		n squaredLength = 0.0 ifFalse:[			nlist add: n.			normal _ normal + n. ].].	normal _ normal/( faces size/3).	normal squaredLength = 0.0 ifTrue:[normal _ B3DVector3 x: 0.0 y: 1.0 z: 0.0].	normal normalize.	nabs _ normal abs.	up _ B3DVector3 new.	nabs x < nabs y ifTrue:[		nabs x < nabs z ifTrue:[up x:1.0] 		ifFalse:[up z:1.0].]ifFalse:[		nabs y < nabs z ifTrue:[up y: 1.0] ifFalse:[up z: 1.0]].	side _ (up cross: normal) normalized.	up _ (normal cross: side) normalized.	m _ B3DMatrix4x4 identity.		m at: 1 at: 1 put: side x.	m at: 1 at: 2 put: side y.	m at: 1 at: 3 put: side z.	m at: 2 at: 1 put: up x.	m at: 2 at: 2 put: up y.	m at: 2 at: 3 put: up z.	m at: 3 at: 1 put: normal x.	m at: 3 at: 2 put: normal y.	m at: 3 at: 3 put: normal z.	offset _ 0.	1 to: faces size by: 3 do:[ :i |		ray _ self ray: m tri: localPosition - (verts at: 1+(faces at:i))					tri: localPosition - (verts at: 1+(faces at: i+1))					tri: localPosition - (verts at: 1+(faces at: i+2)).				ray ifNotNil:[ 			nabs x > nabs y ifTrue:[				nabs x > nabs z ifTrue:[t _ ray x/normal x] 				ifFalse:[ t _ ray z/normal z].]ifFalse:[				nabs y > nabs z ifTrue:[t _ ray y/normal y] ifFalse:[t _ ray z/normal z]].		t abs > offset abs ifTrue:[ offset _ t negated.]]].! !!TBoundSphere methodsFor: 'construct' stamp: 'das 2/20/2004 11:01'!calcTree: verts faces: faces box: bx depth: depth	| child faceBox boxes flist |" See TBoundSphere >>#calcTree:faces:depth for more info."	vertices _ nil.	(depth = 0 or:[ faces size <= 12])ifFalse:[	"depth = 0 ifFalse:["		boxes _ self splitBoxes: bx." Calculate the list of faces that overlap each box, and recurse."		boxes do:[:b |			flist _ OrderedCollection new.			1 to: faces size by:3 do:[:i |				(b intersectT1: (verts at:1+(faces at: i)) 					T2:(verts at: 1+(faces at: i+1)) 					T3:(verts at: 1+(faces at: i+2))) ifTrue:[						flist add: (faces at: i).						flist add: (faces at: i+1).						flist add: (faces at: i+2).].].			flist size > 1 ifTrue:[				faceBox _ TBox new.				flist do:[:f | faceBox growVertex: (verts at: 1+f).].				faceBox _ faceBox intersectBox: b.				child _ (TBoundSphere calcTree: verts faces: flist box: faceBox depth: depth-1).				child children ifNotNil:[self addChild: child].									].].]	ifTrue:[		vertices _ verts. 		children _ faces asIntegerArray. 		]." Now calculate the minimal bounding sphere. We do it this way because the polygons actually overlap between boxes. If we were to use the mtfBall approach, the resulting radius could well be larger than this one."	self box: bx.	self localPosition: bx center radius: bx diagonal/2.0.	vertices ifNotNil:[self calcSurface: verts faces: faces.].							! !!TBoundSphere methodsFor: 'construct' stamp: 'das 2/20/2004 11:01'!calcTree: verts faces: faces depth: depth	| bx epsilon |" CONSTRUCTION FOR SPHERE HIERARCHYThis method is used to compute a heirarchy of bounding spheres for a complex object. This allows for extremely fast picking and collision detection. The object is broken into octrees if the ratio of sides permits. Long thin objects tend to be split into two parts, flat objects into four.	1.	This is a top down approach. I use aligned boxes (TBox) as the basis of the		construction, given the assumption that when the boxes are small enough		their shape and relative orientation doesn't matter as long as they		completely cover the object. We will construct spheres from these boxes		(or cubes) that only contain the contents of the cubes, hence, overlap		is not much of an issue.	2.	Once the top level containing box is calculated from the underlying objects		vertices (TBox>>#max is the maximum value corner and TBox>>#min is the		minimal value corner), we slice the object into smaller boxes and recurse.		This slicing is only done along the 'longer' dimensions, hence a long		thin object may only be sliced once perpendicular to its long axis, 		a flat object may only be sliced twice each perpendicular to each other.		We determine whether a dimension is 'sliceable' based upon the ratio of		its length relative to the other dimensions.	3.	The recursion first determines which surfaces of the containing box 		overlap the resulting bounding box. These resulting values are stored as 		an array for use in the same way by the children of this box.	4.	We test the depth of the recursion at this stage. If the depth is zero or		the number of surfaces that we overlap is zero we stop the recursion. If		this cube does not contain any surfaces its parent will delete it.	5.	Inside the recursion, we determine which of the set of faces overlap		this box. Once we know this, we calculate the bounding box of these		surfaces. We then take the intersection between this box and the 		previously constructed box from the parent. This can only be the same		size or smaller, which improves the accuracy of the bounding box 		representation of the object and further improves its value in 		collision detection.	6.	Once we construct the child cubes, we calculate the minimal bounding boxes		of these in attempt to make the current cube size even smaller.	7.	The last thing to do here is if this cube covers four faces or less, we		shouldn't bother testing the children, and go directly to these surfaces.		We set this cube to be a leaf node and destroy all of the children.	8.	And now, the things we have been waiting for. We construct the sphere		tree from the cube tree recursively (of course). The boolean leaf value indicates		whether or not this is a leaf sphere, hence its children are faces.We use the TBox class to help us out here. The TBox class defines a min and max corner and has a number of useful methods to simplify the code here."	bx _ TBox new.	faces do:[:f| bx growVertex: (verts at: 1+f).]." Grow by epsilon to make sure the box has some depth - otherwise, it will fail to construct good boxes."	epsilon _ 0.000001.	bx growVertex: bx min - (B3DVector3 x: epsilon y: epsilon z: epsilon).	bx growVertex: bx max + (B3DVector3 x: epsilon y: epsilon z: epsilon).	self calcTree: verts faces: faces box: bx depth: depth.					globalPosition _ B3DVector3 new.	! !!TBoundSphere methodsFor: 'construct' stamp: 'das 5/6/2002 16:00'!frame: frm	frame _ frm.	children ifNotNil:[ vertices ifNil:[ 		children do:[:c | c frame: frm.].].].! !!TBoundSphere methodsFor: 'construct' stamp: 'das 4/28/2002 22:46'!splitBoxes: bx	| epsilon ratio boxes splitBoxes extent |" Split along the axis where the ratio with the other axes is greater than 0.6. I am sure there is a more efficient number. Just don't know what it is.""	ratio _ 0.737."	ratio _ 0.6.	extent _ bx extent." Make sure we don't divide by zero. "	epsilon _ 0.000001.	extent _ extent max: (B3DVector3 x: epsilon y: epsilon z: epsilon).	boxes _ OrderedCollection new.	boxes add: bx.	(((extent x/extent y) > ratio) and:[(extent x/extent z) > ratio]) ifTrue:[ 		splitBoxes _ OrderedCollection new.		boxes do:[:b | 			splitBoxes add: b splitXMin.			splitBoxes add: b splitXMax.			].		boxes _ splitBoxes.		].	(((extent y/extent x) > ratio) and:[(extent y/extent z) > ratio]) ifTrue:[ 		splitBoxes _ OrderedCollection new.		boxes do:[:b | 			splitBoxes add: b splitYMin.			splitBoxes add: b splitYMax.			].		boxes _ splitBoxes.		].	(((extent z/extent x) > ratio) and:[(extent z/extent y) > ratio]) ifTrue:[ 		splitBoxes _ OrderedCollection new.		boxes do:[:b | 			splitBoxes add: b splitZMin.			splitBoxes add: b splitZMax.			].		boxes _ splitBoxes.		].	^ boxes.! !!TBoundSphere methodsFor: 'construct' stamp: 'das 9/13/2002 01:42'!union: sphere" We calculate the minimal sphere that contains both this sphere and the argument sphere."" This needs to be performed in global coordinates."	| vector length norm p1 p2 |	sphere ifNil:[ ^ TBoundSphere localPosition: (self globalPosition) radius: (self radius).].	vector _ sphere globalPosition - self globalPosition.	vector length = 0.0 ifTrue:[		^ TBoundSphere localPosition: (self globalPosition) radius: (self radius max: sphere radius).		].	length _ vector length.	norm _ vector/length.	length + sphere radius > self radius ifTrue:[ p2 _ norm * (length + sphere radius).] 		ifFalse:[ ^ TBoundSphere localPosition: (self globalPosition) radius: (self radius).].	length + self radius > sphere radius ifTrue:[ p1 _ norm * (self radius) negated ] 		ifFalse:[ ^ TBoundSphere localPosition: (sphere globalPosition) radius: (sphere radius).].	length _ ((p1-p2) length)/2.0.	p1 _ ((p1+p2)/2.0) + self globalPosition.	^ TBoundSphere localPosition: p1 radius: length.	! !!TBoundSphere methodsFor: 'collision' stamp: 'das 5/10/2002 14:01'!collideFloor: floor transform: trans	| collideLoc rval vrt |	"	(trans localPointToGlobal: localPosition) y - floor > radius ifTrue:[ ^ nil. ]."	collideLoc _ B3DVector4 x: 0.0 y: Float infinity z: 0.0 w:0.0.	vertices ifNil:[ 		children do:[ :c | 			(trans localPointToGlobal: c localPosition) y - floor > c radius ifFalse:[				rval _ c collideFloor: floor transform: trans. 				rval ifNotNil:[ collideLoc y > rval y ifTrue:[collideLoc _ rval.].].].].			collideLoc y <= floor ifTrue:[^ collideLoc.].			^ nil.	] ifNotNil: [		children ifNil:[			vertices do:[:v | 				vrt _ trans localPointToGlobal: v. 				vrt y < floor ifTrue:[ vrt y < collideLoc y ifTrue:[ 					collideLoc _ vrt asB3DVector4. 					collideLoc w: vrt y - floor].].].] 				ifNotNil:[			children do:[:f | 				vrt _ trans localPointToGlobal: (vertices at: (f+1)).				vrt y < floor ifTrue:[ vrt y < collideLoc y ifTrue:[ 					collideLoc _ vrt asB3DVector4. 					collideLoc w: vrt y - floor.].].].].].	collideLoc y <= floor ifTrue:[ ^ collideLoc.].	^ nil.! !!TBoundSphere methodsFor: 'collision' stamp: 'das 5/13/2002 15:44'!collidePlane: norm offset: offst 	| current |" The plane is defined in the local coordinate frame - no transforms of vertices are necessary. Compare this to #collideFloor:transform: where the plane is the floor, and the test vertices must be transformed into global coordinate space."	current _ B3DVector4 new.	current w: Float infinity.	current _ self collidePlane: norm offset: offst current: current.	current w = Float infinity ifTrue:[^ nil. ].	^ current.! !!TBoundSphere methodsFor: 'collision' stamp: 'das 5/13/2002 15:45'!collidePlane: norm offset: offst current: current	| distance rval vrt |	" Presumably, we already know that the current sphere intersects this plane - we just want to test its contents."	rval _ current.	vertices ifNil:[ 		children do:[ :c | 			(c localPosition dot: norm)-offst < c radius ifTrue:[				rval _ c collidePlane: norm offset: offst current: rval.].].			^ rval.	] ifNotNil: [		children ifNil:[			vertices do:[:v | 				distance _ (v dot: norm) - offst. 				distance < 0.0 ifTrue:[					distance < rval w ifTrue:[ rval _ v asB3DVector4. rval w: distance.].].				].] 		ifNotNil:[			children do:[:f | 				vrt _ vertices at: (f+1).				distance _ (vrt dot: norm) - offst.				distance < 0.0 ifTrue:[					distance < rval w ifTrue:[ rval _  vrt asB3DVector4. rval w: distance.].].				].].].	^ rval.! !!TBoundSphere methodsFor: 'collision' stamp: 'ar 2/11/2003 18:44'!collideSphere: aSphere	"Answer whether I collilde into aSphere."	| myPos itsPos dist pt |	"Note: For some reason the global position of some spheres is broken. E.g.,		(frame globalTransform localPointToGlobal: localPosition) distanceTo: globalPosition.	is NOT zero."	myPos := self frame globalTransform localPointToGlobal: localPosition.	itsPos := aSphere frame globalTransform localPointToGlobal: localPosition.	dist := myPos - itsPos.	dist := dist dot: dist.	dist > (self radiusSquared + aSphere radiusSquared) ifTrue:[^nil]. "no intersection"	"The global spheres intersect. If I have any local spheres, then recurse into them."	normal ifNil:[ children ifNotNil:[ children size > 0 ifTrue:[		children do:[:each|			pt := each collideSphere: aSphere.			pt ifNotNil:[^pt].		].		^nil.	]]].	"I am a leaf sphere"	aSphere isLeafSphere ifTrue:[		"It's a leaf sphere as well. Answer an approximate collision point (not accurate!!)"		^(self globalPosition + aSphere globalPosition) * 0.5.	].	"Otherwise have the other sphere collide"	^aSphere collideSphere: self.! !!TBoundSphere methodsFor: 'collision' stamp: 'das 5/13/2002 16:41'!ray: framePtr tri: p1 tri: p2 tri: p3" This method works by using the orthogonal picking matrix as orthogonal planes going through the origin at 'origin'. The points of the triangle are tested to the two planes orthoganal to the direction of picking. If they are on either side of both planes, then there is a very high probability that our picking ray interesects the triangle, and we do the actual calculation of the intersection point. Note the comments below. I use a vertical bar to indicate which side of the plane a point is on.  ***** p1 p2 | ***** means that p1 and p2 are on the same side, ***** p1 | p2 ***** indicates that they are on opposite sides. p1 is always on the left side, because it is the first one I test. This really just means - same side as p1 - no meaning other than that. This can be optimized for tri-strips, tri-fans, and even full face based meshes. When I have the time... "	| d1 d2 d3 pp1 pp2 dd1 dd2 xPlane yPlane  |			xPlane _ framePtr row1.	d1 _ xPlane dot: p1.	d2 _ xPlane dot: p2.	d3 _ xPlane dot: p3.	dd1 _ d1*d2.	dd2 _ d1*d3." test if all points are on the same side of the x plane."	dd1 < 0 ifFalse:[ 				"***** p1 p2 |  *****"		dd2 < 0  ifFalse:[  ^ nil		"***** p1 p2 p3 | *****" ] 				ifTrue:[ 			"***** p1 p2 | p3 *****"						pp1 _ p1 + ((p3-p1) * (d1/(d1-d3))).						pp2 _ p2 + ((p3-p2) * (d2/(d2-d3))).]]		ifTrue:[ 				"***** p1 | p2 *****"			dd2 < 0  ifTrue:[ 		"***** p1 | p2 p3 *****" 						pp1 _ p1 + ((p2-p1) * (d1/(d1-d2))).						pp2 _ p1 + ((p3-p1) * (d1/(d1-d3))).] 					ifFalse:[ 		"***** p1 p3 | p2 *****"						pp1 _ p1 + ((p2-p1) * (d1/(d1-d2))).						pp2 _ p3 + ((p2-p3) * (d3/(d3-d2))).].]." At this point, the triangle is intersected by the x plane and we know where. If both points are on the same side of the y plane, we are done. "	yPlane _ framePtr row2.	d1 _ yPlane dot: pp1.	d2 _ yPlane dot: pp2." test if both points are on the same side of the y plane."	d1 * d2 < 0 ifFalse:[ 	 ^ nil ].	pp1 _ pp1 + ((pp2-pp1) * ( d1/ (d1-d2))).	^ pp1.			! !!TBoundSphere methodsFor: 'mini ball' stamp: 'das 2/20/2004 11:01'!mtfBall: aCollection	"Create a minimum enclosing sphere from aCollection of points.	See Emo Welzl, 'Smallest enclosing disks (balls and ellipsoids)' (1991),	H. Maurer (Ed.), New Results and New Trends in Computer Science, LNCS 555	http://citeseer.nj.nec.com/welzl91smallest.html"	| border idxList |	idxList := WordArray new: aCollection size.	1 to: idxList size do:[:i| idxList at: i put: i].	self privateMtfRandomize: idxList.	border := Array new: 4.	self privateMtfBall0: aCollection with: idxList with: 1 with: border.	radius := radiusSquared sqrt.	box _ TBox new.	aCollection do:[ :v | box growVertex:(v).].! !!TBoundSphere methodsFor: 'mini ball' stamp: 'ar 6/23/2002 15:09'!mtfBall: aCollection faces: faceCollection	"Create a minimum enclosing sphere from aCollection of points.	See Emo Welzl, 'Smallest enclosing disks (balls and ellipsoids)' (1991),	H. Maurer (Ed.), New Results and New Trends in Computer Science, LNCS 555	http://citeseer.nj.nec.com/welzl91smallest.html"	| border idxList |	idxList := WordArray new: faceCollection size.	1 to: idxList size do:[:i| idxList at: i put: (faceCollection at: i) + 1].	self privateMtfRandomize: idxList.	border := Array new: 4.	self privateMtfBall0: aCollection with: idxList with: 1 with: border.	radius := radiusSquared sqrt.! !!TBoundSphere methodsFor: 'mini ball' stamp: 'ar 6/23/2002 16:11'!privateMtfBall0: pointList with: indexList with: minIndex with: borderList	"Note: In this variant the default recursion path is inlined. The recursion exclusively affects changes of the border vertices so its depth is bounded by the max. number of vertices on the border (which is four)."	| idx p dist2 index |	localPosition := B3DVector3 new.	radiusSquared := -1.0.	index := indexList size.	[index >= minIndex] whileTrue:[		idx := indexList at: index.		p := pointList at: idx.		p -= localPosition.		dist2 := (p dot: p) * 0.999. "numerical accuracy"		dist2 <= radiusSquared ifFalse:[			p := pointList at: idx.			borderList at: 1 put: p.			self privateMtfBall1: pointList with: indexList with: index+1 with: borderList.			"Move p to front"			indexList replaceFrom: index to: indexList size-1 with: indexList startingAt: index+1.			indexList at: indexList size put: idx.		].		index := index - 1.	].! !!TBoundSphere methodsFor: 'mini ball' stamp: 'ar 6/23/2002 16:11'!privateMtfBall1: pointList with: indexList with: minIndex with: borderList	"Note: In this variant the default recursion path is inlined. The recursion exclusively affects changes of the border vertices so its depth is bounded by the max. number of vertices on the border (which is four)."	| idx p dist2 index |	localPosition := (borderList at: 1).	radiusSquared := 0.0.	index := indexList size.	[index >= minIndex] whileTrue:[		idx := indexList at: index.		p := pointList at: idx.		p -= localPosition.		dist2 := (p dot: p) * 0.999. "numerical accuracy"		dist2 <= radiusSquared ifFalse:[			p := pointList at: idx.			borderList at: 2 put: p.			self privateMtfBall2: pointList with: indexList with: index+1 with: borderList.			"Move p to front"			indexList replaceFrom: index to: indexList size-1 with: indexList startingAt: index+1.			indexList at: indexList size put: idx.		].		index := index - 1.	].! !!TBoundSphere methodsFor: 'mini ball' stamp: 'ar 6/23/2002 16:11'!privateMtfBall2: pointList with: indexList with: minIndex with: borderList	"Note: In this variant the default recursion path is inlined. The recursion exclusively affects changes of the border vertices so its depth is bounded by the max. number of vertices on the border (which is four)."	| idx p dist2 index |	self privateMtfSphereFromP1: (borderList at: 1) p2: (borderList at: 2).	index := indexList size.	[index >= minIndex] whileTrue:[		idx := indexList at: index.		p := pointList at: idx.		p -= localPosition.		dist2 := (p dot: p) * 0.999. "numerical accuracy"		dist2 <= radiusSquared ifFalse:[			p := pointList at: idx.			borderList at: 3 put: p.			self privateMtfBall3: pointList with: indexList with: index+1 with: borderList.			"Move p to front"			indexList replaceFrom: index to: indexList size-1 with: indexList startingAt: index+1.			indexList at: indexList size put: idx.		].		index := index - 1.	].! !!TBoundSphere methodsFor: 'mini ball' stamp: 'ar 6/23/2002 16:11'!privateMtfBall3: pointList with: indexList with: minIndex with: borderList	"Note: In this variant the default recursion path is inlined. The recursion exclusively affects changes of the border vertices so its depth is bounded by the max. number of vertices on the border (which is four)."	| idx p dist2 index |	self privateMtfSphereFromP1: (borderList at: 1) p2: (borderList at: 2) p3: (borderList at: 3).	index := indexList size.	[index >= minIndex] whileTrue:[		idx := indexList at: index.		p := pointList at: idx.		p -= localPosition.		dist2 := (p dot: p) * 0.999. "numerical accuracy"		dist2 <= radiusSquared ifFalse:[			p := pointList at: idx.			borderList at: 4 put: p.			self privateMtfSphereFromP1: (borderList at: 1) p2: (borderList at: 2) 								p3: (borderList at: 3) p4: (borderList at: 4).			"Move p to front"			indexList replaceFrom: index to: indexList size-1 with: indexList startingAt: index+1.			indexList at: indexList size put: idx.		].		index := index - 1.	].! !!TBoundSphere methodsFor: 'mini ball' stamp: 'ar 6/23/2002 15:09'!privateMtfRandomize: idxList	"Randomize input"	| max rnd j tmp |	max := idxList size.	rnd := Random new" seed: 16r2134567".	1 to: max do:[:i|		j := (rnd next * i) truncated +1.		tmp := idxList at: i.		idxList at: i put: (idxList at: j).		idxList at: j put: tmp.	].! !!TBoundSphere methodsFor: 'mini ball' stamp: 'ar 6/23/2002 15:10'!privateMtfSphereFromP1: p1 p2: p2	"Two points"	| delta center rad2 |	center := (p1 + p2).	center *= 0.5.	delta := center - p1.	rad2 := delta dot: delta.	localPosition := center.	radiusSquared := rad2.! !!TBoundSphere methodsFor: 'mini ball' stamp: 'ar 6/23/2002 15:10'!privateMtfSphereFromP1: p1 p2: p2 p3: p3	| d1 d2 d3 v1 v2 v3 m b rad2 center |	v1 := (p1 + p2). v1 *= 0.5.	v2 := (p1 + p3). v2 *= 0.5.	v3 := p1.	d1 := (p2 - p1).	d2 := (p3 - p1).	d3 := d1 cross: d2.	m := B3DMatrix4x4 new.	m		a11: d1 x; a12: d1 y; a13: d1 z;		a21: d2 x; a22: d2 y; a23: d2 z;		a31: d3 x; a32: d3 y; a33: d3 z.	b := B3DVector3			x: (v1 dot: d1)			y: (v2 dot: d2)			z: (v3 dot: d3).	center := m solve3x3: b.	center ifNil:[^self privateMtfSphereFromP1: p1 p2: p2].	d1 := center - p1.	rad2 := d1 dot: d1.	localPosition := center.	radiusSquared := rad2.! !!TBoundSphere methodsFor: 'mini ball' stamp: 'ar 6/23/2002 15:10'!privateMtfSphereFromP1: p1 p2: p2 p3: p3 p4: p4	| d1 d2 d3 v1 v2 v3 m b rad2 center |	v1 := (p1 + p2). v1 *= 0.5.	v2 := (p1 + p3). v2 *= 0.5.	v3 := (p1 + p4). v3 *= 0.5.	d1 := (p2 - p1).	d2 := (p3 - p1).	d3 := (p4 - p1).	m := B3DMatrix4x4 new.	m		a11: d1 x; a12: d1 y; a13: d1 z;		a21: d2 x; a22: d2 y; a23: d2 z;		a31: d3 x; a32: d3 y; a33: d3 z.	b := B3DVector3			x: (v1 dot: d1)			y: (v2 dot: d2)			z: (v3 dot: d3).	center := m solve3x3: b.	center ifNil:[^self privateMtfSphereFromP1: p1 p2: p2 p3: p3].	d1 := center - p1.	rad2 := d1 dot: d1.	localPosition := center.	radiusSquared := rad2.! !!TBoundSphere methodsFor: 'render' stamp: 'ar 1/2/2003 02:26'!pick: pointer	| rval |" There is a problem here. I do not have the norm for these faces, which means that this will allow us to pick a triangle on the wrong side of the object. This must be fixed.Another thing that needs to be looked at is just because we find a triangle to pick does NOT mean that there isn't a closer one. This code exits on the very first triangle - but I am leaving it -as is- for performance reasons. To fix it, look at the next 'clause', where I had the same problem with groups of polys."	(pointer pickLocalBoundSphere: self) ifFalse:[^false].	vertices ifNotNil:[^pointer pickTriangles: vertices list: children].	rval _ false.	children do:[:c | rval _ (c pick: pointer) or:[ rval]. ].	^rval.		! !!TBoundSphere methodsFor: 'render' stamp: 'ar 1/2/2003 02:28'!pickChildren: pointer	| rval |" This method exists to avoid testing the top-most sphere twice. It is just a special case of the #pick: method. Notice the commented out code.""	(pointer pickLocalBoundSphere: self)ifTrue:["	vertices ifNotNil:[^pointer pickTriangles: vertices list: children].	rval _ false.	children do:[:c | rval _ (c pick: pointer) or:[ rval]. ].	^ rval! !!TBoundSphere methodsFor: 'render' stamp: 'das 3/12/2004 12:57'!render: ogl box: frm	children ifNotNil:[		vertices ifNil: [ children do:[ :c | c render: ogl box: frm].].].	self box ifNotNil:[frm render: ogl box: self box].! !!TBoundSphere methodsFor: 'render' stamp: 'das 3/12/2004 12:57'!render: ogl box: frm depth: depth	children ifNotNil:[		vertices ifNil: [ children do:[ :c | c render: ogl box: frm depth: depth-1. ].].].	depth = 0 ifTrue:[ box ifNotNil:[		frm render: ogl box: self box.].].! !!TBoundSphere methodsFor: 'render' stamp: 'das 3/12/2004 12:57'!render: ogl frame: frm segments: segs	children ifNotNil:[		vertices ifNil: [ children do:[ :c | c render: ogl frame: frm segments: segs. ].].].	frm render: ogl sphere: self segments: segs.! !!TBoundSphere methodsFor: 'render' stamp: 'das 3/12/2004 13:33'!renderSurface: ogl	| mid |	children ifNotNil:[		normal ifNil: [ children do:[ :c | c renderSurface: ogl. ].].].	normal ifNotNil:[	 		ogl glColor3fv: #(1.0 0 0)asFloatArray.			ogl glBegin: GLLineStrip.    			ogl glVertex3fv:localPosition + (normal*offset) + normal.			ogl glVertex3fv:localPosition + (normal * offset).			ogl glVertex3fv:localPosition + (normal*offset) + (up*radius).		mid _ (up+side) normalized.			ogl glVertex3fv:localPosition + (normal*offset) + (mid*radius).					ogl glVertex3fv:localPosition + (normal*offset) + (side*radius).		mid _ (side - up) normalized.			ogl glVertex3fv:localPosition + (normal*offset) + (mid*radius).					ogl glVertex3fv:localPosition + (normal*offset) + (up*radius negated).		mid _( side+up)normalized negated.			ogl glVertex3fv:localPosition + (normal*offset) + (mid*radius).					ogl glVertex3fv:localPosition + (normal*offset) + (side*radius negated).		mid _ (up-side)normalized.			ogl glVertex3fv:localPosition + (normal*offset) + (mid*radius).					ogl glVertex3fv:localPosition + (normal*offset) + (up*radius).		ogl glEnd.].! !!TBoundSphere methodsFor: 'transform' stamp: 'das 4/24/2002 19:51'!transform: trans	trans ifNotNil:[		globalPosition _ trans localPointToGlobal: localPosition.] 	ifNil: [globalPosition _ localPosition.]." As far as I can tell, we never need to transform the children boundSpheres.	children ifNotNil:[		leaf ifFalse:[		children do:[:cs | cs transform: trans.].].]."! !!TBoundSphere class methodsFor: 'instance creation' stamp: 'das 4/5/2002 10:39'!calcBoundSphere: verts	 ^ TBoundSphere new calcBoundSphere: verts.! !!TBoundSphere class methodsFor: 'instance creation' stamp: 'das 4/24/2002 12:15'!calcBoundSphere: verts faces: faces	 ^ TBoundSphere new calcBoundSphere: verts faces: faces.! !!TBoundSphere class methodsFor: 'instance creation' stamp: 'das 4/25/2002 20:36'!calcTree: vertices faces: faces box: bx depth: depth	^ TBoundSphere new calcTree: vertices faces: faces box: bx depth: depth.! !!TBoundSphere class methodsFor: 'instance creation' stamp: 'das 4/24/2002 12:18'!calcTree: vertices faces: faces depth: depth	^ TBoundSphere new calcTree: vertices faces: faces depth: depth.! !!TBoundSphere class methodsFor: 'instance creation'!localPosition: pos radius: rad	^ TBoundSphere new localPosition: pos radius: rad.! !!TBoundSphere class methodsFor: 'instance creation' stamp: 'das 6/23/2002 12:26'!mtfBall: verts	 ^ self new mtfBall: verts.! !!TBoundSphere class methodsFor: 'instance creation' stamp: 'das 6/23/2002 12:26'!mtfBall: verts faces: faces	 ^ self new mtfBall: verts faces: faces.! !!TBox methodsFor: 'math' stamp: 'das 2/10/2003 07:53'!* aNumber		^ TBox min: (minCorner * aNumber) max: (maxCorner * aNumber).! !!TBox methodsFor: 'math' stamp: 'das 2/10/2003 08:18'!addBox: aBox	^ TBox min: minCorner + aBox min max: maxCorner + aBox max.! !!TBox methodsFor: 'accessing' stamp: 'das 12/21/2002 12:15'!atRandom: segments	| dm |	dm _ (maxCorner - minCorner)/segments.	^ B3DVector3 x:(dm x * (segments atRandom) + minCorner x) 				y:(dm y * (segments atRandom) + minCorner y)				z:(dm z * (segments atRandom) + minCorner z).! !!TBox methodsFor: 'accessing' stamp: 'das 4/23/2002 00:27'!center	^ (minCorner + maxCorner)/2.0.! !!TBox methodsFor: 'accessing' stamp: 'das 4/23/2002 00:36'!centerX	^ (minCorner x + maxCorner x)/2.0.! !!TBox methodsFor: 'accessing' stamp: 'das 4/23/2002 00:36'!centerY	^ (minCorner y + maxCorner y)/2.0.! !!TBox methodsFor: 'accessing' stamp: 'das 4/23/2002 00:36'!centerZ	^ (minCorner z + maxCorner z)/2.0.! !!TBox methodsFor: 'accessing' stamp: 'ar 10/8/2002 10:42'!corner	^maxCorner! !!TBox methodsFor: 'accessing' stamp: 'ar 10/8/2002 10:49'!cornerVertices	"Answer all the vertices defining the corners of this block"	| out |	out := (WriteStream on: (Array new: 8)).	self cornerVerticesDo:[:vtx| out nextPut: vtx].	^out contents! !!TBox methodsFor: 'accessing' stamp: 'ar 10/8/2002 10:48'!cornerVerticesDo: aBlock	"Evaluate aBlock with all the vertices defining the corners of this block"	| min max |	min := minCorner.	max := maxCorner.	aBlock value: min x @ min y @ min z.	aBlock value: min x @ min y @ max z.	aBlock value: min x @ max y @ min z.	aBlock value: min x @ max y @ max z.	aBlock value: max x @ min y @ min z.	aBlock value: max x @ min y @ max z.	aBlock value: max x @ max y @ min z.	aBlock value: max x @ max y @ max z.! !!TBox methodsFor: 'accessing' stamp: 'das 4/25/2002 16:25'!diagonal	^ (maxCorner - minCorner)length.! !!TBox methodsFor: 'accessing' stamp: 'das 4/23/2002 00:26'!extent	^ maxCorner - minCorner.! !!TBox methodsFor: 'accessing' stamp: 'das 10/14/2003 01:24'!extentMax	^ (maxCorner - minCorner) max.! !!TBox methodsFor: 'accessing' stamp: 'das 10/14/2003 01:24'!extentMin	^ (maxCorner - minCorner) min.! !!TBox methodsFor: 'accessing' stamp: 'das 4/24/2002 10:28'!extentX	^ maxCorner x - minCorner x.! !!TBox methodsFor: 'accessing' stamp: 'das 4/24/2002 10:28'!extentY	^ maxCorner y - minCorner y.! !!TBox methodsFor: 'accessing' stamp: 'das 4/24/2002 10:28'!extentZ	^ maxCorner z - minCorner z.! !!TBox methodsFor: 'accessing' stamp: 'das 4/23/2002 00:19'!growVertex: v	minCorner _ minCorner min: v.	maxCorner _ maxCorner max: v.! !!TBox methodsFor: 'accessing' stamp: 'das 4/23/2002 11:12'!max	^ maxCorner.! !!TBox methodsFor: 'accessing' stamp: 'das 4/23/2002 11:12'!max: mx	maxCorner _ mx.! !!TBox methodsFor: 'accessing' stamp: 'das 5/17/2003 01:25'!merge: aBox	"Answer a Box that contains both the receiver and aBox."	^TBox 		origin: (self origin min: aBox origin)		corner: (self corner max: aBox corner)! !!TBox methodsFor: 'accessing' stamp: 'das 4/23/2002 11:11'!min	^ minCorner.! !!TBox methodsFor: 'accessing' stamp: 'das 4/23/2002 11:12'!min: mn	minCorner _ mn.! !!TBox methodsFor: 'accessing' stamp: 'ar 10/8/2002 10:42'!origin	^minCorner! !!TBox methodsFor: 'accessing' stamp: 'das 10/14/2003 01:25'!radius	^ self diagonal/2.0.! !!TBox methodsFor: 'accessing' stamp: 'das 9/14/2002 00:13'!scale: scale	minCorner _ minCorner * scale.	maxCorner _ maxCorner * scale.! !!TBox methodsFor: 'accessing' stamp: 'das 4/25/2002 15:13'!splitXMax	| corner |	corner _ self min copy.	corner x: self centerX.	^ TBox min: corner max: self max copy.! !!TBox methodsFor: 'accessing' stamp: 'das 4/25/2002 15:13'!splitXMin	| corner |	corner _ self max copy.	corner x: self centerX.	^ TBox min: self min copy max: corner.! !!TBox methodsFor: 'accessing' stamp: 'das 4/25/2002 15:13'!splitYMax	| corner |	corner _ self min copy.	corner y: self centerY.	^ TBox min: corner max: self max copy.! !!TBox methodsFor: 'accessing' stamp: 'das 4/25/2002 15:14'!splitYMin	| corner |	corner _ self max copy.	corner y: self centerY.	^ TBox min: self min copy max: corner.! !!TBox methodsFor: 'accessing' stamp: 'das 4/25/2002 15:14'!splitZMax	| corner |	corner _ self min copy.	corner z: self centerZ.	^ TBox min: corner max: self max copy.! !!TBox methodsFor: 'accessing' stamp: 'das 4/25/2002 15:14'!splitZMin	| corner |	corner _ self max copy.	corner z: self centerZ.	^ TBox min: self min copy max: corner.! !!TBox methodsFor: 'accessing' stamp: 'ar 10/8/2002 10:47'!transformedBy: aTransform	"Answer a box transformed by the given transformation"	| aVertex min max |	min := max := nil.	self cornerVerticesDo:[:vtx| 		aVertex := aTransform localPointToGlobal: vtx.		min ifNil:[			min := max := aVertex.		] ifNotNil:[			min := min min: aVertex.			max := max max: aVertex.		].	].	^TBox origin: min corner: max! !!TBox methodsFor: 'accessing' stamp: 'ar 10/8/2002 11:01'!translatedBy: delta	"Answer a box transformed by the given transformation"	^TBox origin: minCorner + delta corner: maxCorner + delta! !!TBox methodsFor: 'comparing' stamp: 'das 4/24/2002 10:30'!axisTestXv1: v1 v2: v2 a: a b: b fa: fa fb: fb	| p0 p1 min max rad |	p0 _ (a * v1 y) - (b * v1 z).	p1 _ (a * v2 y) - (b * v2 z).	p0 < p1 ifTrue:[min _ p0. max _ p1.] ifFalse:[min _ p1. max _ p0.].	rad _ ((fa * self extentY) + (fb * self extentZ))/2.0.	(min > rad or:[max < (rad negated)]) ifTrue:[^ false.].	^ true.! !!TBox methodsFor: 'comparing' stamp: 'das 4/27/2002 13:08'!axisTestYv1: v1 v2: v2 a: a b: b fa: fa fb: fb	| p0 p1 min max rad |	p0 _ (b * v1 z) - (a * v1 x).	p1 _ (b * v2 z) - (a * v2 x).	p0 < p1 ifTrue:[min _ p0. max _ p1.] ifFalse:[min _ p1. max _ p0.].	rad _ ((fa * self extentX) + (fb * self extentZ))/2.0.	(min > rad or:[max < (rad negated)]) ifTrue:[^ false.].	^ true.! !!TBox methodsFor: 'comparing' stamp: 'das 4/24/2002 11:05'!axisTestZv1: v1 v2: v2 a: a b: b fa: fa fb: fb	| p0 p1 min max rad |	p0 _ (a * v1 x) - (b * v1 y).	p1 _ (a * v2 x) - (b * v2 y).	p0 < p1 ifTrue:[min _ p0. max _ p1.] ifFalse:[min _ p1. max _ p0.].	rad _ ((fa * self extentX) + (fb * self extentY))/2.0.	(min > rad or:[max < (rad negated)]) ifTrue:[^ false.].	^ true.! !!TBox methodsFor: 'comparing' stamp: 'das 4/25/2002 20:52'!intersectBox: bx	| mn mx |	mn _ bx min max: self min.	mx _ bx max min: self max.	^ TBox min: mn max: mx.! !!TBox methodsFor: 'comparing' stamp: 'das 4/27/2002 13:10'!intersectT1: t1 T2: t2 T3: t3	| v1 v2 v3 e1 e2 e3 a1 a2 a3 center tNormal d vmin vmax |" This method is based upon:	Fast 3D Triangle-Box Overlap Testing 	Tomas Akenine-Moller	March 2001, updated June 2001.The order of this code is somewhat different from that presented in the example C source provided with the paper.Though this is considered to be the fastest test in the graphics literature, I think that there is a better approach by attempting to construct a seperating plane between the two objects. Since I am not currently using it for real-time work, I won't worry about it."" First, the naive test - is the triangle all on one side of a half-plane?"	(t1 x < minCorner x and:[ t2 x < minCorner x and:[ t3 x < minCorner x]]) 		ifTrue:[ ^ false. ].	(t1 x > maxCorner x and:[. t2 x > maxCorner x and:[ t3 x > maxCorner x]]) 		ifTrue:[ ^ false. ].	(t1 y < minCorner y and:[ t2 y < minCorner y and:[ t3 y < minCorner y]]) 		ifTrue:[^ false. ].	(t1 y > maxCorner y and:[ t2 y > maxCorner y and:[ t3 y > maxCorner y]]) 		ifTrue:[ ^ false. ].	(t1 z < minCorner z and:[ t2 z < minCorner z and:[ t3 z < minCorner z]]) 		ifTrue:[ ^ false. ].	(t1 z > maxCorner z and:[ t2 z > maxCorner z and:[ t3 z > maxCorner z]]) 		ifTrue:[ ^ false. ]." Second, the cross product (edge from tri, (x y z) direction. "	center _ self center.	v1 _ t1 - center.	v2 _ t2 - center.	v3 _ t3 - center.	e1 _ t2 - t1.	a1 _ e1 abs.	(self axisTestXv1:v1 v2:v3 a: e1 z  b: e1 y fa: a1 z fb: a1 y) ifFalse:[^ false.].	(self axisTestYv1:v1 v2:v3 a: e1 z b: e1 x fa: a1 z fb: a1 x) ifFalse:[^ false.].	(self axisTestZv1:v2 v2:v3 a: e1 y b: e1 x fa: a1 y fb: a1 x) ifFalse:[^ false.].	e2 _ t3 - t2.	a2 _ e2 abs.	(self axisTestXv1:v1 v2:v3 a: e2 z  b: e2 y fa: a2 z fb: a2 y) ifFalse:[^ false.].	(self axisTestYv1:v1 v2:v3 a: e2 z b: e2 x fa: a2 z fb: a2 x) ifFalse:[^ false.].	(self axisTestZv1: v1 v2:v2 a:e2 y b: e2 x fa: a2 y fb: a2 x) ifFalse:[^ false.].	e3 _ t1 - t3.	a3 _ e3 abs.	(self axisTestXv1:v1 v2:v2 a: e3 z  b: e3 y fa: a3 z fb: a3 y) ifFalse:[^ false.].	(self axisTestYv1:v1 v2:v2 a: e3 z b: e3 x fa: a3 z fb: a3 x) ifFalse:[^ false.].	(self axisTestZv1:v2 v2:v3 a: e3 y b: e3 x fa: a3 y fb: a3 x) ifFalse:[^ false.]." Third, test if the box intersects the plane of the triangle."	tNormal _ e1 cross: e2.	d _ (tNormal dot: v1)negated.	vmin _ B3DVector3 new.		vmax _ B3DVector3 new.		tNormal x>0.0 ifTrue:[		vmin x: self extentX negated.		vmax x: self extentX.] ifFalse:[		vmin x: self extentX.		vmax x: self extentX negated.].	tNormal y>0.0 ifTrue:[		vmin y: self extentY negated.		vmax y: self extentY.] ifFalse:[		vmin y: self extentY.		vmax y: self extentY negated.].	tNormal z>0.0 ifTrue:[		vmin z: self extentZ negated.		vmax z: self extentZ.] ifFalse:[		vmin z: self extentZ.		vmax z: self extentZ negated.].	(tNormal dot: vmin)+d >0.0 ifTrue:[^ false. ].	(tNormal dot: vmax)+d >= 0.0 ifTrue:[^ true.].	^ true.	! !!TBox methodsFor: 'comparing' stamp: 'das 4/24/2002 11:46'!pointInBox: v	v x < minCorner x ifTrue:[^ false.].	v x > maxCorner x ifTrue:[^ false.].	v y < minCorner y ifTrue:[^ false.].	v y > maxCorner y ifTrue:[^ false.].	v z < minCorner z ifTrue:[^ false.].	v z > maxCorner z ifTrue:[^ false. ].	^ true.! !!TBox methodsFor: 'comparing' stamp: 'das 6/29/2002 16:54'!pointOverBox: v	v x < minCorner x ifTrue:[^ false.].	v x > maxCorner x ifTrue:[^ false.]."	v y < minCorner y ifTrue:[^ false.].	v y > maxCorner y ifTrue:[^ false.]."	v z < minCorner z ifTrue:[^ false.].	v z > maxCorner z ifTrue:[^ false. ].	^ true.! !!TBox methodsFor: 'comparing' stamp: 'das 6/18/2002 16:51'!unionBox: bx	| mn mx |	mn _ bx min min: self min.	mx _ bx max max: self max.	^ TBox min: mn max: mx.! !!TBox methodsFor: 'comparing' stamp: 'das 6/29/2002 16:37'!unionSphere: position radius: radius	| mn mx |	mn _ (position - radius) min: self min.	mx _ (position + radius) max: self max.	^ TBox min: mn max: mx.! !!TBox methodsFor: 'initialize' stamp: 'das 4/23/2002 11:55'!initialize	| iP iN |" Defines an infinitely empty box - min is positive infinity, max is negative infinity. We then add vertices to the box via the #growVertex: method to 'grow' it."	iP _ Float infinity.	iN _ Float infinity negated.	minCorner _ B3DVector3 x: iP y: iP z: iP.	maxCorner _ B3DVector3 x: iN y: iN z: iN.! !!TBox methodsFor: 'initialize' stamp: 'das 4/23/2002 00:28'!min: mn max: mx	minCorner _ mn.	maxCorner _ mx.! !!TBox class methodsFor: 'instance creation' stamp: 'das 4/23/2002 00:29'!min: mn max: mx	^ self new min:mn max: mx.! !!TBox class methodsFor: 'instance creation' stamp: 'ar 9/30/2004 19:20'!new	^self basicNew initialize! !!TBox class methodsFor: 'instance creation' stamp: 'ar 10/8/2002 10:43'!origin: origin corner: corner	^ self new min: origin max: corner.! !!TButtonMorph methodsFor: 'initialize' stamp: 'ar 10/15/2002 22:55'!beBordered	| newLabel |	newLabel := BorderedStringMorph contents: self label.	self replaceSubmorph: label by: newLabel.	label := newLabel.! !!TButtonMorph methodsFor: 'initialize' stamp: 'ar 10/25/2002 20:24'!initialize	super initialize.	highlightColor := Color white.	label := StringMorph new contents: 'Button'.	label emphasis: 1.	self addMorphBack: label.	self layoutPolicy: TableLayout new.	self listDirection: #leftToRight.	self hResizing: #shrinkWrap; vResizing: #shrinkWrap.	self listCentering: #center.	self layoutInset: 10@2.	self cellInset: 10@0.	self fillStyle: (GradientFillStyle colors: {		Color r: 0.7 g: 0.7 b: 0.4.		Color r: 1 g: 1 b: 0.95.	}).	self fillStyle origin: 0@0.	self fillStyle direction: 0@18.	self borderStyle: (BorderStyle complexRaised width: 1).! !!TButtonMorph methodsFor: 'accessing' stamp: 'ar 10/26/2002 19:30'!contents	^self label! !!TButtonMorph methodsFor: 'accessing' stamp: 'ar 10/26/2002 19:30'!contents: aString	self label: aString.! !!TButtonMorph methodsFor: 'accessing' stamp: 'ar 10/15/2002 22:44'!highlightColor	^highlightColor! !!TButtonMorph methodsFor: 'accessing' stamp: 'ar 10/15/2002 22:44'!highlightColor: aColor	highlightColor := aColor.! !!TButtonMorph methodsFor: 'accessing' stamp: 'ar 10/25/2002 20:43'!highlightWidth	^highlightWidth! !!TButtonMorph methodsFor: 'accessing' stamp: 'ar 10/25/2002 20:43'!highlightWidth: aNumber	highlightWidth := aNumber! !!TButtonMorph methodsFor: 'accessing' stamp: 'ar 10/15/2002 18:20'!label	^label contents! !!TButtonMorph methodsFor: 'accessing' stamp: 'ar 10/15/2002 18:20'!label: aString	^label contents: aString! !!TButtonMorph methodsFor: 'accessing' stamp: 'ar 10/15/2002 22:47'!labelColor	^label color! !!TButtonMorph methodsFor: 'accessing' stamp: 'ar 10/15/2002 22:46'!labelColor: aColor	label color: aColor! !!TButtonMorph methodsFor: 'event handling' stamp: 'ar 10/15/2002 18:16'!handlesMouseDown: evt	^true! !!TButtonMorph methodsFor: 'event handling' stamp: 'ar 10/15/2002 18:18'!handlesMouseOver: evt	^true! !!TButtonMorph methodsFor: 'event handling' stamp: 'ar 10/15/2002 18:19'!handlesMouseOverDragging: evt	^true! !!TButtonMorph methodsFor: 'event handling' stamp: 'ar 10/15/2002 18:17'!mouseDown: evt	self borderStyle: (BorderStyle complexInset width: self borderWidth)! !!TButtonMorph methodsFor: 'event handling' stamp: 'ar 10/25/2002 20:45'!mouseEnter: evt	oldColor := label color.	label color: highlightColor.	highlightWidth ifNotNil:[		oldWidth := self borderWidth.		self borderWidth: highlightWidth.	].! !!TButtonMorph methodsFor: 'event handling' stamp: 'ar 10/25/2002 20:25'!mouseEnterDragging: evt	oldColor := label color.	label color: highlightColor.! !!TButtonMorph methodsFor: 'event handling' stamp: 'ar 6/16/2003 22:54'!mouseLeave: evt	label color: oldColor.	oldWidth ifNotNil:[self borderWidth: oldWidth].! !!TButtonMorph methodsFor: 'event handling' stamp: 'ar 10/25/2002 20:25'!mouseLeaveDragging: evt	label color: oldColor.! !!TButtonMorph methodsFor: 'event handling' stamp: 'ar 10/25/2002 20:45'!mouseUp: evt	self borderStyle: (BorderStyle complexRaised width: self borderWidth).	(self containsPoint: evt position) ifTrue:[self signal: #fire].! !!TCleanup class methodsFor: 'as yet unclassified' stamp: 'das 4/15/2003 11:03'!run	"TCleanup run"	"Odd problems from before 3.2 got finalized"	(Smalltalk keys select:[:k| k class == String]) do:[:k| Smalltalk removeKey: k].	Smalltalk garbageCollect.	Behavior flushObsoleteSubclasses.	"WordState may hold on to TWorldCanvas"	WorldState allInstancesDo:[:ws| ws canvas: nil].	"WaveDemo holds on to sample instance"	TWaveDemo classPool at: #SomeInstance put: nil.	"Method change records may hold on to undeclareds"	MethodChangeRecord allInstancesDo:[:mcr| mcr noteNewMethod: nil].	TeaTime shutdown.	Smalltalk garbageCollect.! !!TCurveFitter3 methodsFor: 'fitting' stamp: 'ar 10/4/2004 14:38'!computeMaxError3: points from: firstIndex to: lastIndex in: curve params: params	"Compute the maximum squared error between the samples and the corresponding curve."	| splitIndex maxError samplePt u curvePt dist seg |	curve size = 6 ifFalse:[self halt].	seg _ Bezier3Segment from: curve first via: curve second and: curve third to: curve fourth.	maxError _ 0.0.	splitIndex _ nil.	firstIndex + 1 to: lastIndex-1 do:[:i|		samplePt _ points at: i.		u _ params at: (i - firstIndex + 1).		curvePt _ seg valueAt: u.		dist _ curvePt - samplePt.		dist _ dist dotProduct: dist.		dist > maxError ifTrue:[			maxError _ dist.			splitIndex _ i].	].	^maxError -> splitIndex! !!TCurveFitter3 methodsFor: 'fitting' stamp: 'ar 10/4/2004 14:38'!computeWeightedInTangent: points at: ptIndex max: maxLength	| inTangent inLength nextPt index prevPt nrm length |	inTangent := (points at:1)-(points at: 1). 	inLength := 0.	nextPt := points at: ptIndex.	index := ptIndex.	[(index _ index - 1) > 0 and:[inLength < maxLength]] whileTrue:[		prevPt := points at: index.		nrm := nextPt - prevPt.		length := nrm r.		inLength + length > maxLength ifTrue:[			"Add partial tangent"			length := maxLength - inLength.			nrm := nrm normalized * length.		].		inLength := inLength + length.		inTangent := inTangent + nrm.	].	^inTangent! !!TCurveFitter3 methodsFor: 'fitting' stamp: 'ar 10/4/2004 14:38'!computeWeightedOutTangent: points at: ptIndex max: maxLength	| nextPt index prevPt nrm length outTangent outLength |	outTangent := (points at: 1)-(points at: 1). "set to 0 vector of whatever dimension"	outLength := 0.	prevPt := points at: ptIndex.	index := ptIndex.	[(index _ index + 1) <= points size and:[outLength < maxLength]] whileTrue:[		nextPt := points at: index.		nrm := nextPt - prevPt.		length := nrm r.		outLength + length > maxLength ifTrue:[			"Add partial tangent"			length := maxLength - outLength.			nrm := nrm normalized * length.		].		outLength := outLength + length.		outTangent := outTangent + nrm.	].	^outTangent! !!TCurveFitter3 methodsFor: 'fitting' stamp: 'ar 10/4/2004 14:38'!fitPoints3: points from: firstIndex to: lastIndex error: maxError in: in out: out	| curve pair splitIndex params error midIn midOut |	(lastIndex - firstIndex + 1) < 3 		ifTrue:[^{"self quickDraw:" (self fitTwoPoints3: points from: firstIndex to: lastIndex in: in out: out)}].	"Compute chord-length parametrization for curve"	params _ self parametrizePoints: points from: firstIndex to: lastIndex.	"Compute new bezier curve fitting given points"	curve _ self generateBezier3: points from: firstIndex to: lastIndex params: params in: in out: out.	"Compute error distance and max. point for split"	pair _ self computeMaxError3: points from: firstIndex to: lastIndex in: curve params: params.	error _ pair key.	error <= maxError ifTrue:[^{"self quickDraw:" curve}].	splitIndex _ pair value.	"fitting failed; split at max error point and fit recursively"	midIn _ midOut _ self midTangent: points at: splitIndex.	midIn ifNil:[		midIn _ self inTangent: points at: splitIndex.		midOut _ self outTangent: points at: splitIndex.	].	^(self fitPoints3: points from: firstIndex to: splitIndex error: maxError in: in out: midOut),		(self fitPoints3: points from: splitIndex to: lastIndex error: maxError in: midIn out: out)! !!TCurveFitter3 methodsFor: 'fitting' stamp: 'ar 10/4/2004 14:38'!fitPoints: points error: maxError	^self fitPoints: points from: 1 to: points size error: maxError ! !!TCurveFitter3 methodsFor: 'fitting' stamp: 'ar 10/4/2004 14:38'!fitPoints: points from: first to: last error: maxError	^self fitPoints3: points from: 1 to: points size error: maxError in: (self inTangent: points at: first) out: (self outTangent: points at: last)! !!TCurveFitter3 methodsFor: 'fitting' stamp: 'ar 10/4/2004 14:38'!fitTwoPoints3: points from: firstIndex to: lastIndex in: in out: out	| dist p0 p3 p1 p2 |	dist _ (points at: firstIndex) dist: (points at: lastIndex).	dist _ dist * 0.33.	p0 _ points at: firstIndex.	p3 _ points at: lastIndex.	p1 _ p0 + (in normalized * dist).	p2 _ p3 - (out normalized * dist).	^{p0. p1. p2. p3. firstIndex. lastIndex}! !!TCurveFitter3 methodsFor: 'fitting' stamp: 'ar 10/4/2004 14:38'!generateBezier3: points from: firstIndex to: lastIndex params: params in: in out: out	"Compute a bezier curve fitting the given points from firstIndex to lastIndex"	| p0 p2 p1 u nPts p3 seg a0 a1 c00 c01 c10 c11 x0 x1 tmp det detA detB alpha beta |true ifTrue:[^self fitTwoPoints3: points from: firstIndex to: lastIndex in: in out: out].	nPts _ (lastIndex - firstIndex + 1).	p0 _ points at: firstIndex.	p3 _ points at: lastIndex.	p1 _ p0 + in.	p2 _ p3 - out.	seg _ Bezier3Segment from: p0 via: p1 and: p2 to: p3.	a0 _ Array new: nPts.	a1 _ Array new: nPts.	"compute tha a's"	1 to: nPts do:[:i|		u _ params at: i.		a0 at: i put: in * (3.0 * u * (1.0 - u) * (1.0 - u)).		a1 at: i put: out * (-3.0 * u * u * (1.0 - u)).	].	c00 _ 0.0. c01 _ 0.0. c10 _ 0.0. c11 _ 0.0.	x0 _ 0.0. x1 _ 0.0.	1 to: nPts do:[:i|		c00 _ c00 + ((a0 at: i) dotProduct: (a0 at: i)).		c01 _ c01 + ((a0 at: i) dotProduct: (a1 at: i)).		c10 _ c10 + ((a1 at: i) dotProduct: (a0 at: i)).		c11 _ c11 + ((a1 at: i) dotProduct: (a1 at: i)).		u _ params at: i.		tmp _ (points at: firstIndex + i - 1) - (seg valueAt: u).		x0 _ x0 + ((a0 at: i) dotProduct: tmp).		x1 _ x1 + ((a1 at: i) dotProduct: tmp).	].	det _ (c00 * c11) - (c01 * c11).	detA _ (c00 * x0) - (c10 * x1).	detB _ (x1 * c11) - (x0 * c10).	det = 0.0 ifTrue:[det _ c00 * c11 * 1.0e-10].	alpha _ detB / det.	beta _ detA / det.	(alpha < 0.0 or:[beta < 0.0]) 		ifTrue:[^self fitTwoPoints3: points from: firstIndex to: lastIndex in: in out: out].	p1 _ p0 + (in * alpha).	p2 _ p3 - (out * beta).	^Array with: p0 with: p1 with: p2 with: p3 with: firstIndex with: lastIndex! !!TCurveFitter3 methodsFor: 'fitting' stamp: 'ar 10/4/2004 14:38'!inTangent: points at: index	| len tan |	len _ 0.2.	tan := self computeWeightedOutTangent: points at: index max: len.	tan isZero ifTrue:[^1@0].	^tan normalized! !!TCurveFitter3 methodsFor: 'fitting' stamp: 'ar 10/4/2004 14:38'!midTangent: points at: index	| tan1 tan2 len dot |	len _ 0.2.	index = 1 ifTrue:[^(self computeWeightedOutTangent: points at: index max: len) normalized].	index = points size ifTrue:[^(self computeWeightedInTangent: points at: index max: len) normalized].	tan1 _ (self computeWeightedInTangent: points at: index max: len) normalized.	tan2 _ (self computeWeightedOutTangent: points at: index max: len) normalized.	dot := tan1 dotProduct: tan2.	dot > 0.0 ifFalse:[^nil].	"(dot < 50 degreesToRadians cos) ifTrue:[^nil]."	^(tan1 + tan2) normalized! !!TCurveFitter3 methodsFor: 'fitting' stamp: 'ar 10/4/2004 14:38'!outTangent: points at: index	| len tan |	len _ 0.2.	tan := self computeWeightedInTangent: points at: index max: len.	tan isZero ifTrue:[tan := 1@0].	^tan! !!TCurveFitter3 methodsFor: 'fitting' stamp: 'ar 10/4/2004 14:38'!parametrizePoints: points from: firstIndex to: lastIndex	"Create a chord-length parametrization of the points from firstIndex to lastIndex"	| params nPts prevPt nextPt scale prevDist dx dy dist |	nPts _ lastIndex - firstIndex + 1.	params _ Array new: nPts.	params at: 1 put: (prevDist _ 0.0).	prevPt _ points at: firstIndex.	2 to: nPts do:[:i|		nextPt _ points at: firstIndex + i-1.		dx _ nextPt x - prevPt x.		dy _ nextPt y - prevPt y.		dist _ ((dx * dx) + (dy * dy)) asFloat sqrt.		params at: i put: (prevDist _ prevDist + dist).		prevPt _ nextPt.	].	scale _ 1.0 / prevDist.	2 to: nPts do:[:i|		params at: i put: (params at: i) * scale.	].	^params! !!TExportData methodsFor: 'accessing' stamp: 'ar 6/5/2002 22:15'!at: index	^data at: index! !!TExportData methodsFor: 'accessing' stamp: 'ar 6/5/2002 22:15'!at: index put: value	^data at: index put: value! !!TExportData methodsFor: 'accessing' stamp: 'ar 5/29/2002 22:53'!binary	^binary! !!TExportData methodsFor: 'accessing' stamp: 'ar 5/29/2002 22:53'!binary: anObject	binary := anObject.! !!TExportData methodsFor: 'accessing' stamp: 'ar 6/5/2002 20:35'!binarySize	^4 "id" + 4 "class-id" + 4 "indexed-size" +		(binary ifNil:[self size*4] ifNotNil:[binary byteSize])! !!TExportData methodsFor: 'accessing' stamp: 'ar 6/4/2002 18:19'!id	^id! !!TExportData methodsFor: 'accessing' stamp: 'ar 6/4/2002 18:19'!id: anObject	id := anObject! !!TExportData methodsFor: 'accessing' stamp: 'ar 5/29/2002 22:46'!indexedSize	^indexedSize! !!TExportData methodsFor: 'accessing' stamp: 'ar 5/29/2002 22:46'!indexedSize: aNumber	indexedSize := aNumber.! !!TExportData methodsFor: 'accessing' stamp: 'ar 6/4/2002 17:36'!instShape	^instShape! !!TExportData methodsFor: 'accessing' stamp: 'ar 6/4/2002 17:36'!instShape: aNumber	instShape := aNumber.! !!TExportData methodsFor: 'accessing' stamp: 'ar 6/5/2002 23:49'!refClass	^refClass! !!TExportData methodsFor: 'accessing' stamp: 'ar 6/5/2002 23:49'!refClass: aClass	refClass := aClass.! !!TExportData methodsFor: 'accessing' stamp: 'ar 6/5/2002 22:15'!size	^data size! !!TExportData methodsFor: 'exporting' stamp: 'ar 6/6/2002 00:26'!exportDataOn: byteStream classMap: classMap swapEnds: aBool	byteStream nextUInt32Put: (classMap at: refClass).	"Note: instShape/instSize is implicit in class map"	byteStream nextUInt32Put: indexedSize.	binary ifNotNil:[		aBool ifTrue:[binary swapEndianness].		binary class isBytes			ifTrue:[byteStream nextPutAll: binary asByteArray]			ifFalse:[byteStream storeWordsFrom: binary].		aBool ifTrue:[binary swapEndianness].		^self].	1 to: data size do:[:i|		(data at: i) exportReferenceOn: byteStream classMap: classMap.	].! !!TExportData methodsFor: 'exporting' stamp: 'ar 6/6/2002 13:02'!exportReferenceOn: byteStream classMap: classMap	byteStream nextUInt32Put: id.! !!TExportData methodsFor: 'exporting' stamp: 'ar 6/6/2002 12:11'!importDataFrom: byteStream classMap: classMap shapeMap: shapeMap refMap: refMap swapEnds: swapEnds	| classID obj refID |	classID := byteStream nextUInt32.	refClass := classMap at: classID.	instShape := shapeMap at: classID.	indexedSize := byteStream nextUInt32.	refClass isPointers ifFalse:[		"binary blurb of data"		binary := refClass basicNew: indexedSize.		refClass isBytes 			ifTrue:[byteStream nextBytesInto: binary]			ifFalse:[byteStream readWordsInto: binary].		swapEnds ifTrue:[binary swapEndianness].		^self].	"non-binary data (pointers)"	data := Array new: (instShape size + indexedSize).	1 to: data size do:[:i|		refID := byteStream nextUInt32.		refID = 0 ifTrue:[			classID := byteStream nextUInt32.			obj := (classMap at: classID) teaImportLiteralFrom: byteStream.		] ifFalse:[			obj := refMap at: refID.		].		data at: i put: obj.	].! !!TExportData methodsFor: 'exporting' stamp: 'ar 6/6/2002 22:34'!teaExportOn: exporter	self error:'cannot export'! !!TExportData methodsFor: 'initialize' stamp: 'ar 6/5/2002 22:00'!initialize: n	n = 0 ifTrue:[data := #()] ifFalse:[data := Array new: n].! !!TExportData methodsFor: 'printing' stamp: 'ar 6/5/2002 23:48'!printOn: aStream	super printOn: aStream.	aStream nextPut:$(;		nextPutAll: refClass name;		nextPut: $).! !!TExportData methodsFor: 'printing' stamp: 'ar 6/5/2002 23:48'!storeBinaryXMLOn: writer	| str |false ifTrue:[	binary class isWords ifTrue:[		str := self wordStringOf: binary.	] ifFalse:[		str := String new: binary basicSize.		str replaceFrom: 1 to: str size with: binary startingAt: 1.	].	str := (Base64MimeConverter mimeEncode: (ReadStream on: str)) contents.	writer attribute: 'encoding' value:'base64'.	writer attribute: 'order' value: Smalltalk endianness.	writer attribute: 'data' value: str.].	writer endEmptyTag: refClass name.! !!TExportData methodsFor: 'printing' stamp: 'ar 6/5/2002 23:48'!storeXMLOn: writer	| obj instSize |	writer startTag: refClass name.	writer attribute:'id' value: id abs asString.	id < 0 ifTrue:[^writer endEmptyTag: refClass name].	id := id negated.	binary ifNotNil:[^self storeBinaryXMLOn: writer].	writer endTag.	instSize := instShape size.	instShape keysAndValuesDo:[:i :attr|		(obj := self at: i) ifNil:[			writer startTag: attr; endEmptyTag: attr.		] ifNotNil:[			obj class == TExportData ifTrue:[				writer startTag: attr; endTag.				obj storeXMLOn: writer.				writer endTag: attr.			] ifFalse:[				writer startTag: attr.				writer attribute: 'value' value: obj asString.				writer endEmptyTag: attr.			].		].	].	(indexedSize > 0) ifTrue:[		writer startTag:'indexed-values'; endTag.		1 to: indexedSize do:[:i|			(obj := self at: instSize+i) ifNotNil:[				obj class == TExportData ifTrue:[					obj storeXMLOn: writer.				] ifFalse:[					writer startTag: obj class name.					writer attribute: 'value' value: obj asString.					writer endEmptyTag: obj class name.				].			].		].		writer endTag:'indexed-values'.	].	writer endTag: refClass name.! !!TExportData methodsFor: 'printing' stamp: 'ar 6/4/2002 23:51'!wordBitsOf: string as: wordClass	| str src dst bits |	str _ Base64MimeConverter mimeDecode: string as: String.	bits _ wordClass new: (str size // 4).	src := Form new hackBits: str.	dst := Form new hackBits: bits.	src displayOn: dst.	^bits! !!TExportData methodsFor: 'printing' stamp: 'ar 6/4/2002 23:53'!wordStringOf: bits	| str src dst |	str := String new: bits basicSize * 4.	src := Form new hackBits: bits.	dst := Form new hackBits: str.	src displayOn: dst.	^str! !!TExportData class methodsFor: 'instance creation' stamp: 'ar 6/5/2002 21:59'!new	^self new: 0! !!TExportData class methodsFor: 'instance creation' stamp: 'ar 6/5/2002 22:15'!new: n	^super new initialize: n! !!TExporter methodsFor: 'exporting' stamp: 'ar 6/6/2002 21:26'!addFileResource: aFileName locator: aLocator	| localName locator fs fileSize cacheName newUrl |	baseUrl ifNil:[^aLocator].	aFileName ifNil:[^aLocator].	fs := [FileDirectory default readOnlyFileNamed: aFileName] 			on: FileDoesNotExistException 			do:[:ex| ex return: nil].	fs ifNil:[^aLocator].	fileSize := fs size.	fs close.	localName := FileDirectory default localNameFor: aFileName.	newUrl := localName asUrlRelativeTo: baseUrl.	cacheName := TResourceLoader fileNameFromUrl: newUrl toText.	locator := aLocator.	(locator notNil and:[cacheName = locator localFileName]) ifFalse:[		locator ifNil:[locator := ResourceLocator new].		locator urlString: newUrl toText.		locator localFileName: aFileName.		locator resourceFileSize: fileSize.		resources add: locator].	^locator! !!TExporter methodsFor: 'exporting' stamp: 'ar 6/6/2002 22:35'!export: anObject	^anObject teaExportOn: self.! !!TExporter methodsFor: 'exporting' stamp: 'ar 6/3/2002 21:24'!export: anObject as: fileName	| data fs |	data := self export: anObject.	fs := FileStream newFileNamed: fileName.	fs fileOutClass: nil andObject: data.	fs close.! !!TExporter methodsFor: 'exporting' stamp: 'ar 10/8/2002 15:04'!export: anObject asBinary: urlString	^self export: anObject asBinary: urlString withThumbnail: nil! !!TExporter methodsFor: 'exporting' stamp: 'ar 10/9/2002 16:34'!export: anObject asBinary: urlString withThumbnail: thumb	| stream classMap shapeString fs count fileName |	(urlString endsWith: '.tea') ifTrue:[		baseUrl := ((urlString copyFrom: 1 to: urlString size - 4),'/') asUrl.	].	fileName := TResourceLoader fileNameFromUrl: urlString.	Cursor wait showWhile:[self export: anObject].	fs := StandardFileStream forceNewFileNamed: fileName.	Cursor write showWhile:[		fs binary.		[			fs nextPutAll: self version asByteArray.			stream := GZipWriteStream on: fs.			"Write class names and shapes"			classMap := IdentityDictionary new.			self literalClasses do:[:cls| shapeMap at: cls put: #()].			stream nextUInt32Put: shapeMap size.			shapeMap keysAndValuesDo:[:cls :clsShape|				stream nextUInt32Put: cls name size.				stream nextPutAll: cls name asByteArray.				shapeString := String streamContents:[:s|					clsShape do:[:iv| s nextPutAll: iv] separatedBy:[s space].				].				stream nextUInt32Put: shapeString size.				stream nextPutAll: shapeString asByteArray.				classMap at: cls put: (classMap size+1).			].			"Store data"			count := dataStream position.			stream nextUInt32Put: count.			dataStream position: 0.			1 to: count do:[:i|				dataStream next exportDataOn: stream classMap: classMap swapEnds: false.			].			stream close.		] ensure:[fs close].		self copyResources.		thumb ifNotNil:[			fileName := TResourceLoader fileNameFromUrl: 					(urlString copyFrom: 1 to: urlString size - 4),'.gif'.			FileDirectory default deleteFileNamed: fileName ifAbsent:[].			GIFReadWriter putForm: thumb onFileNamed: fileName.		].	].! !!TExporter methodsFor: 'exporting' stamp: 'ar 6/4/2002 22:34'!export: anObject asXML: fileName	| data fs writer stream |	data := self export: anObject.	stream := WriteStream on: (String new: 100000).	writer := XMLWriter on: stream.	writer xmlDeclaration: '1.0'.	data storeXMLOn: writer.	fs := CrLfFileStream newFileNamed: fileName.	fs nextPutAll: stream contents.	fs close.! !!TExporter methodsFor: 'exporting' stamp: 'ar 6/3/2002 21:36'!exportLiteral: value	^value! !!TExporter methodsFor: 'exporting' stamp: 'ar 6/7/2002 00:55'!exportMorph: aMorph	^self exportObject: aMorph! !!TExporter methodsFor: 'exporting' stamp: 'ar 6/6/2002 22:36'!exportObject: anObject	"Export some generic object"	| saved instSize indexedSize data instShape |	saved := anObject objectForTeaExport prepareToExportOn: self.	lvl := lvl + 1.	instShape := shapeMap at: saved class ifAbsentPut:[saved class allInstVarNames asArray].	instSize := instShape size.	indexedSize := saved basicSize.	saved class isPointers ifTrue:[		data := TExportData new: (instSize + indexedSize).		byteSize := byteSize + (4+data basicSize * 4).		data refClass: saved class.		data instShape: instShape.		data indexedSize: indexedSize.		refMap at: anObject put: data.		1 to: instSize do:[:i| data at: i put: (self remap: (saved instVarAt: i))].		1 to: indexedSize do:[:i| data at: instSize+i put: (self remap: (saved basicAt: i))].	] ifFalse:[		data := TExportData new.		byteSize := byteSize + (4 * 4).		data refClass: saved class.		data instShape: instShape.		data indexedSize: indexedSize.		data binary: saved.		saved class isBytes 			ifTrue:[byteSize := byteSize + saved basicSize]			ifFalse:[byteSize := byteSize + (saved basicSize * 4)].		refMap at: anObject put: data.	].	dataStream nextPut: data.	data id: dataStream position.	lvl := lvl - 1.	^data! !!TExporter methodsFor: 'exporting' stamp: 'ar 11/15/2002 19:37'!exportTeaObject: anObject	^self exportObject: anObject! !!TExporter methodsFor: 'exporting' stamp: 'ar 6/5/2002 21:54'!literalClasses	^{True. False. Character. Float. SmallInteger. Symbol. UndefinedObject}! !!TExporter methodsFor: 'exporting' stamp: 'ar 6/26/2002 16:56'!version	^Smalltalk isBigEndian ifTrue:['TEA1'] ifFalse:['1AET'].! !!TExporter methodsFor: 'accessing' stamp: 'ar 6/7/2002 00:53'!baseUrl	^baseUrl toText! !!TExporter methodsFor: 'accessing' stamp: 'ar 6/6/2002 13:00'!resources	^resources! !!TExporter methodsFor: 'private' stamp: 'ar 6/6/2002 21:29'!copyResources	| newFileName oldFileName |	Utilities informUserDuring:[:bar|		resources do:[:loc|			bar value: 'Relocating ', loc urlString.			newFileName := TResourceLoader fileNameFromUrl: loc urlString.			oldFileName := loc localFileName.			(newFileName sameAs: oldFileName) ifFalse:[				FileDirectory default deleteFileNamed: newFileName ifAbsent:[].				FileDirectory default copyFileNamed: oldFileName toFileNamed: newFileName.			].			loc localFileName: newFileName.		].	].! !!TExporter methodsFor: 'private' stamp: 'ar 6/6/2002 22:35'!remap: anObject	"Remap the given object to an export data reference"	^refMap at: anObject ifAbsentPut:[anObject teaExportOn: self].! !!TExporter methodsFor: 'initialize' stamp: 'ar 6/6/2002 12:43'!initialize	refMap := IdentityDictionary new: 10000.	shapeMap := IdentityDictionary new: 500.	dataStream := ReadWriteStream on: (Array new: 1000).	resources := OrderedCollection new.	lvl := -1.	byteSize := 0.! !!TExporter class methodsFor: 'instance creation' stamp: 'ar 6/2/2002 14:40'!export: anObject	^self new export: anObject! !!TExporter class methodsFor: 'instance creation' stamp: 'ar 6/3/2002 21:22'!export: anObject as: fileName	^self new export: anObject as: fileName! !!TExporter class methodsFor: 'instance creation' stamp: 'ar 6/5/2002 18:40'!export: anObject asBinary: fileName	^self new export: anObject asBinary: fileName! !!TExporter class methodsFor: 'instance creation' stamp: 'ar 10/8/2002 14:58'!export: anObject asBinary: fileName withThumbnail: thumb	^self new export: anObject asBinary: fileName withThumbnail: thumb! !!TExporter class methodsFor: 'instance creation' stamp: 'ar 6/4/2002 18:33'!export: anObject asXML: fileName	^self new export: anObject asXML: fileName! !!TExporter class methodsFor: 'instance creation' stamp: 'ar 5/29/2002 22:50'!new	^super new initialize! !!TFileOutMaker class methodsFor: 'fileOut' stamp: 'ar 10/4/2004 22:17'!fileOutCroquet	"self fileOutCroquet"	| file pools full |	file := FileStream forceNewFileNamed: 'Croquet-Organization.st'.	(SystemOrganization categories select:[:each| each beginsWith: 'Croquet-']) do:[:catName|		file cr; nextChunkPut: 'SystemOrganization addCategory: ', catName storeString.	].	file close.	pools := (PackageInfo named: 'Croquet-Pools') asChangeSet.	full := (PackageInfo named: 'Croquet') asChangeSet.	full forgetAllChangesFoundIn: pools.	pools fileOut.	full fileOut.! !!TGraphicsTest methodsFor: 'testing' stamp: 'ar 9/5/2002 19:22'!analyzeLog: log success: successFlag	"Analyze the log to see what's going on"	| index parts end accelerated hasDepth hasStencil stream nn |	index := 0.	parts := WriteStream on: Array new.	[index := log findString: '#### Checking pixel format' startingAt: index+1.	index = 0] whileFalse:[		end := log findString: '#### Checking pixel format' startingAt: index+10.		end = 0 ifTrue:[end := log size+1].		parts nextPut: (log copyFrom: index to: end-1).	].	hasDepth := hasStencil := accelerated := false.	parts := parts contents.	parts do:[:p|		stream := ReadStream on: p.		(p findString: '===>') = 0 ifFalse:[			accelerated := true.			index := p findString: 'stencilBits = '.			stream position: index + 12.			stream skipSeparators.			(nn := Number readFrom: stream) >= 8 ifTrue:[hasStencil := true].			index := p findString: 'depthBits = '.			stream position: index + 11.			(nn := Number readFrom: stream) >= 16 ifTrue:[hasDepth := true].		].	].	self cr; show: 'Here is the entire log: '.	self cr; cr; show: log.	self cr; cr; show: 'ANALYSIS:'.	accelerated 		ifTrue:[self cr; show: 'This hardware has accelerated OpenGL support (good news).']		ifFalse:[self cr; show: 'This hardware has NO accelerated OpenGL support whatsoever (bad news). If the hardware is indeed 3D capable, you will need to obtain OpenGL drivers from your vendor.'].	hasDepth		ifTrue:[self cr; show: 'This hardware has sufficient depth buffer support (good news).']		ifFalse:[self cr; show: 'This hardware has no sufficient depth buffer support (bad news). A depth buffer of at least 16 bit is required by Tea.'].	hasStencil 		ifTrue:[self cr; show: 'This hardware has stencil buffer support (good news).']		ifFalse:[self cr; show: 'This hardware has NO stencil buffer support (bad news). Stencil buffer support is required by Tea.'].	successFlag ifTrue:[		self cr; cr; show: 'SUMMARY: This system should be capable of running Tea just fine.'	] ifFalse:[		self cr; cr; show: 'SUMMARY: This system will NOT run Tea.'.		(accelerated and:[hasDepth and:[hasStencil]]) ifTrue:[			self show: ' Although the hardware supports all requirements individually it does not support the ''right'' combination.RECOMMENDATION: Please set your display depth to 32 bits and re-run this test. If this doesn''t help, please send the above log information to andreas.raab@gmx.de'		].	].	self cr; cr.! !!TGraphicsTest methodsFor: 'testing' stamp: 'ar 9/5/2002 17:17'!cr	self nextPutAll: String cr.! !!TGraphicsTest methodsFor: 'testing' stamp: 'ar 9/5/2002 17:21'!flush	World displayWorld.! !!TGraphicsTest methodsFor: 'testing' stamp: 'ar 10/4/2004 22:20'!newOGL	^OpenGL newIn: (0@0 corner: 100@100)! !!TGraphicsTest methodsFor: 'testing' stamp: 'ar 9/5/2002 17:20'!nextPutAll: aString	textPane 		setText: textPane text, aString;		setSelection: (textPane text size+1 to: textPane text size)! !!TGraphicsTest methodsFor: 'testing' stamp: 'ar 10/4/2004 22:19'!runTests	| ogl file fileDir log success |	success := false.	self cr; nextPutAll: 'Tea graphics tests starting...'; cr; flush.	B3DHardwareEngine primitiveSetVerboseLevel: 5.	ogl := self newOGL.	ogl ifNotNil:[success := true. ogl destroy].	"find the place where Squeak3D.log is located"	self cr; nextPutAll:'Looking for log file Squeak3D.log ... '.	file := [FileDirectory default readOnlyFileNamed: 'Squeak3D.log'] 			on: FileDoesNotExistException do:[:ex| ex return: nil].	file ifNil:[		file := [(FileDirectory on: Smalltalk vmPath) readOnlyFileNamed: 'Squeak3D.log']				on: FileDoesNotExistException do:[:ex| ex return: nil].	].	self show: (file ifNil:['failed'] ifNotNil:['success']).	file ifNil:[		self cr; cr; nextPutAll:'WARNING: The log file Squeak3D.log does neither appear in the current nor the VM directory. This is VERY uncommon and should be fixed.'.		self cr; cr; nextPutAll: 'RECOMMENDATION: Put all of the files you need to run Tea (e.g., the virtual machine (TeaSqueak.exe), the image (TeaXYZ.image) and the changes (TeaXYZ.changes) in the same directory. Then start Squeak by DRAGGING the image file (TeaXYZ.image) ONTO the virtual machine (TeaSqueak.exe) and retry this test.'.		^self.	].	self cr; show: 'Deleting old log file ... '.	fileDir := file directory.	file close.	fileDir deleteFileNamed: file localName.	self show: 'success'.	ogl := self newOGL.	ogl ifNotNil:[success := true. ogl destroy].	file := fileDir readOnlyFileNamed: file localName.	log := file contents.	file close.	self analyzeLog: log success: success.	B3DHardwareEngine primitiveSetVerboseLevel: 1.! !!TGraphicsTest methodsFor: 'testing' stamp: 'ar 9/5/2002 17:32'!show: aString	self nextPutAll: aString; flush.! !!TGraphicsTest methodsFor: 'initialize' stamp: 'ar 9/5/2002 17:14'!initialize	textPane := PluggableTextMorph on: self text: nil accept: nil.	runButton := PluggableButtonMorph on: self getState: nil action: #runTests.	runButton label: 'Run Tests'.! !!TGraphicsTest methodsFor: 'initialize' stamp: 'ar 9/5/2002 17:12'!open	| window |	window _ (SystemWindow labelled: 'Tea Graphics Tester') model: self.	window addMorph: runButton frame: (0@0 corner: 1@0.1).	window addMorph: textPane frame: (0@0.1 corner: 1@1).	window openInWorld! !!TGraphicsTest class methodsFor: 'as yet unclassified' stamp: 'ar 9/5/2002 17:12'!new	^super new initialize! !!TGraphicsTest class methodsFor: 'as yet unclassified' stamp: 'ar 9/5/2002 17:12'!open	^self new open! !!THandMorph methodsFor: 'as yet unclassified' stamp: 'ar 7/14/2002 14:26'!drawOn: aCanvas	super drawOn: aCanvas.	temporaryCursor ifNil:[aCanvas paintImage: NormalCursor at: self position].! !!THandMorph methodsFor: 'as yet unclassified' stamp: 'das 5/30/2002 14:29'!processEvents	" This is a noop"! !!THandMorph methodsFor: 'as yet unclassified' stamp: 'ar 6/22/2002 01:03'!showHardwareCursor: aBool	"Ignored"! !!TImporter methodsFor: 'accessing' stamp: 'ar 6/3/2002 21:15'!addAttribute: attrName value: value	attributes at: attrName put: value.! !!TImporter methodsFor: 'accessing' stamp: 'ar 6/3/2002 21:27'!attributeAt: key	^attributes at: key! !!TImporter methodsFor: 'accessing' stamp: 'ar 6/3/2002 21:27'!attributeAt: key ifAbsent: aBlock	^attributes at: key ifAbsent: aBlock! !!TImporter methodsFor: 'accessing' stamp: 'ar 6/6/2002 13:00'!resources	^resources! !!TImporter methodsFor: 'importing' stamp: 'ar 6/5/2002 23:46'!checkVersion: aStream	| version |	version := aStream next: 4.	(version = 'TEA1' or:[version = '1AET']) ifFalse:[^self error:'Not a tea file'].	^(version = 'TEA1') = Smalltalk isLittleEndian.! !!TImporter methodsFor: 'importing' stamp: 'ar 6/6/2002 12:58'!download: aLocator whenFinishedSend: aSelector to: anObject	resources add: {aLocator. anObject. aSelector}! !!TImporter methodsFor: 'importing' stamp: 'ar 6/6/2002 00:15'!import: dataSet	| indexedSize instSize inst instShape instClass remap |	dataSet binary ifNotNil:[^dataSet binary].	indexedSize := dataSet indexedSize.	instShape := dataSet instShape.	instClass := dataSet refClass.	instSize := instShape size. 	remap := shapeMap at: instClass ifAbsentPut:[instShape ~= instClass allInstVarNames].	indexedSize = 0		ifTrue:[inst := instClass basicNew]		ifFalse:[inst := instClass basicNew: indexedSize].	refMap at: dataSet put: inst.	remap ifTrue:[		self import: dataSet migratingTo: inst.	] ifFalse:[		1 to: instSize do:[:i|			inst instVarAt: i put: (self remap: (dataSet at: i)).		].	].	1 to: indexedSize do:[:i|		inst basicAt: i put: (self remap: (dataSet at: instSize+i)).	].	inst postImportFrom: self.	^inst! !!TImporter methodsFor: 'importing' stamp: 'ar 6/7/2002 19:28'!import: dataSet migratingTo: newInstance	"Import the given data set migrating to a reshaped instance of the original class described in the data set"	| map value mapped |	map := reshapeMap at: newInstance class ifAbsentPut:[		map := newInstance class allInstVarNames.		dataSet instShape collect:[:iv| map indexOf: iv]].	1 to: dataSet size do:[:i|		value := self remap: (dataSet at: i).		mapped := map at: i.		mapped > 0 ifTrue:[newInstance instVarAt: mapped put: value].	].! !!TImporter methodsFor: 'importing' stamp: 'ar 6/6/2002 00:27'!importStream: aStream	| unzip count classes shapes sz string data swapEnds |	swapEnds := self checkVersion: aStream.	unzip := GZipReadStream on: aStream.	"Read class names and shapes"	count := unzip nextUInt32.	classes := Array new: count.	shapes := Array new: count.	1 to: count do:[:i|		sz := unzip nextUInt32.		string := (unzip next: sz) asString asSymbol.		classes at: i put: (Smalltalk at: string).		sz := unzip nextUInt32.		string := (unzip next: sz) asString.		shapes at: i put: (Scanner new scanFieldNames: string).	].	"read data"	count := unzip nextUInt32.	data := Array new: count.	1 to: count do:[:i| data at: i put: TExportData new].	1 to: count do:[:i|		(data at: i) importDataFrom: unzip classMap: classes shapeMap: shapes refMap: data swapEnds: swapEnds.	].	^self import: data last! !!TImporter methodsFor: 'importing' stamp: 'ar 6/5/2002 23:34'!readFrom: aStream	| unzip count classes shapes sz string data version swapEnds |	version := aStream next: 4.	(version = 'TEA1' or:[version = '1AET']) ifFalse:[^self error:'Not a tea file'].	swapEnds := (version = 'TEA1') = Smalltalk isLittleEndian.	unzip := GZipReadStream on: aStream.	"Read class names and shapes"	count := unzip nextUInt32.	classes := Array new: count.	shapes := Array new: count.	1 to: count do:[:i|		sz := unzip nextUInt32.		string := (unzip next: sz) asString asSymbol.		classes at: i put: (Smalltalk at: string).		sz := unzip nextUInt32.		string := (unzip next: sz) asString.		shapes at: i put: (Scanner new scanFieldNames: string).	].	"read data"	count := unzip nextUInt32.	data := Array new: count.	1 to: count do:[:i| data at: i put: TExportData new].	1 to: count do:[:i|		(data at: i) importDataFrom: unzip classMap: classes shapeMap: shapes refMap: data swapEnds: swapEnds.	].! !!TImporter methodsFor: 'importing' stamp: 'ar 6/2/2002 15:29'!remap: dataSet	"Remap the given object to an export data reference"	dataSet class == TExportData ifFalse:[^dataSet].	^refMap at: dataSet ifAbsent:[self import: dataSet].! !!TImporter methodsFor: 'initialize' stamp: 'ar 6/7/2002 19:13'!initialize	refMap := IdentityDictionary new: 10000.	shapeMap := IdentityDictionary new: 200.	reshapeMap := IdentityDictionary new: 100.	attributes := IdentityDictionary new.	resources := OrderedCollection new.! !!TImporter class methodsFor: 'instance creation' stamp: 'ar 6/2/2002 15:25'!import: dataSet	^self new import: dataSet! !!TImporter class methodsFor: 'instance creation' stamp: 'ar 6/5/2002 23:44'!importFile: fileName	| file |	file := FileStream readOnlyFileNamed: fileName.	^[self importStream: file] ensure:[file close]! !!TImporter class methodsFor: 'instance creation' stamp: 'ar 6/5/2002 23:44'!importStream: byteStream	^self new importStream: byteStream! !!TImporter class methodsFor: 'instance creation' stamp: 'ar 6/2/2002 15:24'!new	^super new initialize! !!TLoad3DSMaxPlugin methodsFor: 'as yet unclassified' stamp: 'yo 9/23/2003 09:59'!cross3: a with: b into: r	| rcvr arg result |	self inline: true.	self var: 'a' declareC: 'vector3 *a'.	self var: 'b' declareC: 'vector3 *b'.	self var: 'r' declareC: 'vector3 *r'.	self var: 'rcvr' declareC: 'float *rcvr'.	self var: 'arg' declareC: 'float *arg'.	self var: 'result' declareC: 'float *result'.	rcvr _ self cCode: '(float*)a' inSmalltalk: [interpreterProxy firstIndexableField: a].	arg _ self cCode: '(float*)b' inSmalltalk: [interpreterProxy firstIndexableField: b].	result _ self cCode: '(float*)r' inSmalltalk: [interpreterProxy firstIndexableField: r].	result at: 0 put: (rcvr at: 1) * (arg at: 2) - ((arg at: 1) * (rcvr at: 2)).	result at: 1 put: (rcvr at: 2) * (arg at: 0) - ((arg at: 2) * (rcvr at: 0)).	result at: 2 put: (rcvr at: 0) * (arg at: 1) - ((arg at: 0) * (rcvr at: 1)).! !!TLoad3DSMaxPlugin methodsFor: 'as yet unclassified' stamp: 'yo 9/23/2003 10:00'!dot3: a with: b	| rcvr arg result |	self inline: true.	self returnTypeC: 'float'.	self var: 'a' declareC: 'vector3 *a'.	self var: 'b' declareC: 'vector3 *b'.	self var: 'rcvr' declareC: 'float *rcvr'.	self var: 'arg' declareC: 'float *arg'.	self var: 'result' declareC: 'float result'.	rcvr _ self cCode: '(float*)a' inSmalltalk: [interpreterProxy firstIndexableField: a].	arg _ self cCode: '(float*)b' inSmalltalk: [interpreterProxy firstIndexableField: b].	result _ 0.0.	0 to: 2 do: [:i |		result _ result + ((rcvr at: i) * (arg at: i)).	].	^ result.! !!TLoad3DSMaxPlugin methodsFor: 'as yet unclassified' stamp: 'yo 9/23/2003 10:00'!length3: a	| vec result |	self inline: true.	self returnTypeC: 'float'.	self var: 'a' declareC: 'vector3 *a'.	self var: 'vec' declareC: 'float* vec'.	self var: 'result' declareC: 'float result'.	vec _ self cCode: '(float*)a' inSmalltalk: [interpreterProxy firstIndexableField: a].	result _ 0.0.	0 to: 2 do: [:i |		result _ result + ((vec at: i) * (vec at: i)).	].	result _ self cCode: 'sqrt(result)' inSmalltalk: [result sqrt].	^ result.! !!TLoad3DSMaxPlugin methodsFor: 'as yet unclassified' stamp: 'yo 9/23/2003 10:00'!normalize3: a	| length vec |	self inline: true.	self var: 'a' declareC: 'vector3 *a'.	self var: 'vec' declareC: 'float* vec'.	self var: 'length' declareC: 'float length'.	vec _ self cCode: '(float*)a' inSmalltalk: [interpreterProxy firstIndexableField: a].	length _ self length3: a.	length = 0.0 ifFalse: [		vec at: 0 put: (vec at: 0) / length.		vec at: 1 put: (vec at: 1) / length.		vec at: 2 put: (vec at: 2) / length.	].! !!TLoad3DSMaxPlugin methodsFor: 'as yet unclassified' stamp: 'yo 9/23/2003 10:00'!normalizeIfNotZero: a	| length vec |	self inline: true.	self var: 'a' declareC: 'vector3 *a'.	self var: 'vec' declareC: 'float* vec'.	self var: 'result' declareC: 'float result'.	self var: 'length' declareC: 'float length'.	vec _ self cCode: '(float*)a' inSmalltalk: [interpreterProxy firstIndexableField: a].	length _ self length3: a.	length = 0.0 ifFalse: [		vec at: 0 put: (vec at: 0) / length.		vec at: 1 put: (vec at: 1) / length.		vec at: 2 put: (vec at: 2) / length.	].! !!TLoad3DSMaxPlugin methodsFor: 'as yet unclassified' stamp: 'yo 9/20/2003 11:02'!primCalcFaceNormals: argVertices faces: argFaces faceNormals: argFaceNormals	| faceNormals vertices faces count v1 v2 v |	self var: 'v1' declareC: 'vector3 v1'.	self var: 'v2' declareC: 'vector3 v2'.	self var: 'v' declareC: 'vector3 v'.	self var: 'vertices' declareC: 'vector3 *vertices'.	self var: 'faces' declareC: 'int *faces'.	self var: 'faceNormals' declareC: 'vector3 *faceNormals'.	self primitive: 'primitiveCalcFaceNormals'		parameters: #(			Oop "vertices"			Oop "faces"			Oop "faceNormals"		)		receiver: #Oop.	"self halt."	faces _  self cCoerce: (interpreterProxy firstIndexableField: argFaces) to: 'int*'.	vertices _ self cCoerce: (interpreterProxy firstIndexableField: argVertices) to: 'vector3*'.	faceNormals _ self cCoerce: (interpreterProxy firstIndexableField: argFaceNormals) to: 'vector3*'.	self cCode: '' inSmalltalk: [		v _ B3DVector3 new.	].	count _ 0.	0 to: faces size // 3 - 1 do: [:i |		v1 _ vertices at: (faces at: count).		v _ vertices at: (faces at: count+1).		self cCode: 'vector3Subwith(&v1, &v)' inSmalltalk: [self vector3Sub: v1 with: v].		v2 _ vertices at:(faces at: count+1).		v _ vertices at: (faces at: count+2).		self cCode: 'vector3Subwith(&v2, &v)' inSmalltalk: [self vector3Sub: v2 with: v].		self cCode: 'cross3withinto(&v1, &v2, &v)' inSmalltalk: [self cross3: v1 with: v2 into: v].		self cCode: 'normalizeIfNotZero(&v)' inSmalltalk: [self normalizeIfNotZero: v].		faceNormals at: i put: v.		count _ count + 3.	].	^ argFaceNormals.! !!TLoad3DSMaxPlugin methodsFor: 'as yet unclassified' stamp: 'das 10/11/2003 13:37'!primCalcVertexNormals: argVertexNormals vertexCount: argVertexCount faces: argFaces faceNormals: argFaceNormals shadeAngleCos: shadeAngleCos	| vertexNormals vertexCount faces faceNormals iCount faceIndex1 faceIndex2 v1 length v2 s |	self var: 'v1' declareC: 'vector3 v1'.	self var: 'v2' declareC: 'vector3 v2'.	self var: 'v' declareC: 'vector3 v'.	self var: 's' declareC: 'float s'.	self var: 'vertices' declareC: 'vector3 *vertices'.	self var: 'vertexNormals' declareC: 'vector3 *vertexNormals'.	self var: 'vertexCount' declareC: 'int *vertexCount'.	self var: 'faces' declareC: 'int *faces'.	self var: 'faceNormals' declareC: 'vector3 *faceNormals'.	self var: 'shadeAngleCos' declareC: 'float shadeAngleCos'.	self primitive: 'primitiveCalcVertexNormals'		parameters: #(			Oop "vertexNormals"			Oop "vertexCount"			Oop "faces"			Oop "faceNormals"			Float "shadeAngleCos"		)		receiver: #Oop.	vertexNormals _ self cCoerce: (interpreterProxy firstIndexableField: argVertexNormals) to: 'vector3*'.	vertexCount _ self cCoerce: (interpreterProxy firstIndexableField: argVertexCount) to: 'int*'.	faces _  self cCoerce: (interpreterProxy firstIndexableField: argFaces) to: 'int*'."	vertices _ self cCoerce: (interpreterProxy firstIndexableField: argVertices) to: 'vector3*'."	faceNormals _ self cCoerce: (interpreterProxy firstIndexableField: argFaceNormals) to: 'vector3*'.	iCount _ 0.	0 to: faces size - 1 by: 3 do: [:i |		vertexNormals at: i put: (faceNormals at: iCount).		vertexNormals at: i+1 put: (faceNormals at: iCount).		vertexNormals at: i+2 put: (faceNormals at: iCount).		iCount _ iCount + 1.	].	"self halt."	0 to: faces size -1 do: [:i |		i + 1 to: faces size - 1 do: [:j |			(faces at: i) = (faces at: j) ifTrue: [				faceIndex1 _ i//3.				faceIndex2 _ j//3.				v1 _ faceNormals at: faceIndex1.				v2 _ faceNormals at: faceIndex2.				(self cCode: 'testNormnormshadeAngleCos(&v1, &v2, shadeAngleCos)' inSmalltalk: [self testNorm: v1 norm: v2 shadeAngleCos: shadeAngleCos]) ifTrue: [					v1 _ vertexNormals at: i.					v2 _ faceNormals at: faceIndex2. "redundant assignment, but..."					self cCode: 'vector3Addwith(&v1, &v2)' inSmalltalk: [self vector3Add: v1 with: v2].					vertexNormals at: i put: v1.					vertexCount at: i put: (vertexCount at: i) + 1.					v1 _ vertexNormals at: j.					v2 _ faceNormals at: faceIndex1.					self cCode: 'vector3Addwith(&v1, &v2)' inSmalltalk: [self vector3Add: v1 with: v2].					vertexNormals at: j put: v1.					vertexCount at: j put: (vertexCount at: j) + 1.				]			]		]	].	0 to: vertexNormals size -1 do: [:i |		v1 _ vertexNormals at: i.		length _ self cCode: 'length3(&v1)' inSmalltalk: [self length3: v1].		length = 0.0 ifFalse: [			s _ 1.0 + (vertexCount at: i).			self cCode: 'vector3DivwithScalar(&v1, s)' inSmalltalk: [self vector3Div: v1 withScalar: s].			self cCode: 'normalize3(&v1)' inSmalltalk: [self normalize3: v1].			vertexNormals at: i put: v1.		].	].	^ argVertexNormals.! !!TLoad3DSMaxPlugin methodsFor: 'as yet unclassified' stamp: 'yo 9/24/2003 09:20'!testNorm: n1 norm: n2 shadeAngleCos: shadeAngleCos	| result |	"self returnTypeC: 'int'."	self var: 'n1' declareC: 'vector3 *n1'.	self var: 'n2' declareC: 'vector3 *n2'.	self var: 'shadeAngleCos' declareC: 'float shadeAngleCos'.	self var: 'result' declareC: 'float result'.	result _ self cCode: 'dot3with(n1, n2)' inSmalltalk: [self dot3: n1 with: n2].	^ (0.0-result) < shadeAngleCos.! !!TLoad3DSMaxPlugin methodsFor: 'as yet unclassified' stamp: 'yo 9/23/2003 10:00'!vector3Add: v1 with: v2	| vec1 vec2 |	self inline: true.	self var: 'v1' declareC: 'vector3 *v1'.	self var: 'v2' declareC: 'vector3 *v2'.	self var: 'vec1' declareC: 'float *vec1'.	self var: 'vec2' declareC: 'float *vec2'.	vec1 _ self cCode: '(float*)v1' inSmalltalk: [interpreterProxy firstIndexableField: v1].	vec2 _ self cCode: '(float*)v2' inSmalltalk: [interpreterProxy firstIndexableField: v2].	vec1 at: 0 put: (vec1 at: 0)  + (vec2 at: 0).	vec1 at: 1 put: (vec1 at: 1) + (vec2 at: 1).	vec1 at: 2 put: (vec1 at: 2) + (vec2 at: 2).! !!TLoad3DSMaxPlugin methodsFor: 'as yet unclassified' stamp: 'yo 9/23/2003 10:00'!vector3Div: v1 withScalar: s	| vec |	self inline: true.	self var: 'vec' declareC: 'float *vec'.	self var: 'v1' declareC: 'vector3 *v1'.	self var: 's' declareC: 'float s'.	vec _ self cCode: '(float*)v1' inSmalltalk: [interpreterProxy firstIndexableField: v1].	vec at: 0 put: (vec at: 0) / s.	vec at: 1 put: (vec at: 1) / s.	vec at: 2 put: (vec at: 2) / s.! !!TLoad3DSMaxPlugin methodsFor: 'as yet unclassified' stamp: 'yo 9/23/2003 10:00'!vector3Sub: v1 with: v2	| vec1 vec2 |	self inline: true.	self var: 'v1' declareC: 'vector3 *v1'.	self var: 'v2' declareC: 'vector3 *v2'.	self var: 'vec1' declareC: 'float *vec1'.	self var: 'vec2' declareC: 'float *vec2'.	vec1 _ self cCode: '(float*)v1' inSmalltalk: [interpreterProxy firstIndexableField: v1].	vec2 _ self cCode: '(float*)v2' inSmalltalk: [interpreterProxy firstIndexableField: v2].	vec1 at: 0 put: (vec1 at: 0)  - (vec2 at: 0).	vec1 at: 1 put: (vec1 at: 1) - (vec2 at: 1).	vec1 at: 2 put: (vec1 at: 2) - (vec2 at: 2).! !!TLoad3DSMaxPlugin class methodsFor: 'as yet unclassified' stamp: 'yo 9/19/2003 18:05'!hasHeaderFile	^ true.! !!TLoad3DSMaxPlugin class methodsFor: 'as yet unclassified' stamp: 'yo 9/20/2003 10:15'!headerFile	^ 'typedef struct _vector3 {float x; float y; float z;} vector3;'.! !!TLoad3DSMaxTest methodsFor: 'Testing' stamp: 'tak 6/23/2004 10:57'!testNextToken	| strm tload ans |	strm _ '*3DSMAX_ASCIIEXPORT	200' readStream.	tload _ TLoad3DSMax basicNew reset.	ans _ tload nextOn: strm.	self assert: ans first = #T3dsmaxAsciiexport.	self assert: ans second = '200'.	self assert: (ans _ tload nextOn: strm) first = #EOF.! !!TLoad3DSMaxTest methodsFor: 'Testing' stamp: 'tak 6/23/2004 10:58'!testNextTokenWithParenthesis	| strm tload ans |	strm _ '	*MATERIAL 0 {		*MATERIAL_NAME "plateau01"		*LONG 1 2 3 *MULTI 4	5	6	}' readStream.	tload _ TLoad3DSMax basicNew.	ans _ tload reset nextOn: strm.	self assert: ans first = #TMaterial.	self assert: ans second = '0'.	ans _ tload nextOn: strm.	self assert: ans first = #BEGIN.	ans _ tload nextOn: strm.	self assert: ans first = #TMaterialName.	self assert: ans second = '"plateau01"'.	ans _ tload nextOn: strm.	self assert: ans first = #TLong.	self assert: ans second = '1 2 3'.	ans _ tload nextOn: strm.	self assert: ans first = #TMulti.	self assert: ans second = '4	5	6'.	ans _ tload nextOn: strm.	self assert: ans first = #END.	self assert: (ans _ tload nextOn: strm) first = #EOF.! !!TLoad3DSMaxTest methodsFor: 'Testing' stamp: 'tak 6/23/2004 10:58'!testParse	| source tree |	source _ '*3DSMAX_ASCIIEXPORT	200'.	tree _ TLoad3DSMax basicNew parse: source readStream.	self assert: tree first = #T3dsmaxAsciiexport.	self assert: tree second = '200'.! !!TLoad3DSMaxTest methodsFor: 'Testing' stamp: 'tak 6/23/2004 10:58'!testParseNesting	| source tree |	source _ '*FIRST 1*SECOND  2 {	*THIRD 3 {		*FOURTH 4	}}*FIFTH 5'.	tree _ TLoad3DSMax basicNew parse: source readStream.	self assert: tree first = #TFirst.	self assert: tree fourth last first = #TFourth.! !!TLoad3DSMaxTest methodsFor: 'Testing' stamp: 'tak 6/23/2004 10:58'!testParseNesting2	| source tree |	source _ '*FIRST 1*SECOND  2 {	*THIRD 3 {	}}*FIFTH 5'.	tree _ TLoad3DSMax basicNew parse: source readStream.	self assert: tree first = #TFirst.	self assert: tree last = '5'.! !!TLoginMorph methodsFor: 'building' stamp: 'ar 12/26/2002 16:06'!buttonColor	^color darker! !!TLoginMorph methodsFor: 'building' stamp: 'ar 12/26/2002 16:22'!buttonNamed: aString action: aSymbol color: aColor help: helpString	| f col |	f _ SimpleButtonMorph new		target: self;		label: aString font: self myFont;		color: aColor;		actionSelector: aSymbol;		setBalloonText: helpString.	f width: 80.	f cornerStyle: #square.	f color: (Color r: 0.95 g: 0.95 b: 1.0).	f borderStyle: (BorderStyle raised width: 2).	col _ (self inAColumn: {f}) hResizing: #spaceFill.	^col! !!TLoginMorph methodsFor: 'building' stamp: 'ar 12/26/2002 16:06'!cancelButton	^self		buttonNamed: 'Cancel' 		action: #doCancel 		color: self buttonColor 		help: 'Cancel this login operation.'! !!TLoginMorph methodsFor: 'building' stamp: 'ar 12/26/2002 16:06'!myFont	^(TextStyle named: #ComicBold) fontOfSize: 16! !!TLoginMorph methodsFor: 'building' stamp: 'ar 12/26/2002 16:06'!okButton	^self		buttonNamed: 'OK' 		action: #doOK 		color: self buttonColor 		help: 'Login into Squeak'! !!TLoginMorph methodsFor: 'actions' stamp: 'ar 12/26/2002 16:05'!doCancel	self delete.	cancelBlock ifNotNil:[cancelBlock value].! !!TLoginMorph methodsFor: 'actions' stamp: 'ar 12/26/2002 16:21'!doOK	| user password |	user := theNameMorph contents string.	password := thePasswordMorph contents string.	(actionBlock value: user value: password) ifTrue:[self delete].! !!TLoginMorph methodsFor: 'initialize' stamp: 'ar 12/26/2002 16:32'!initialize	| fs |	super initialize.	self beSticky.	fs _ GradientFillStyle ramp: {0.0 -> (Color r: 0.8 g: 0.8 b: 1.0). 1.0 -> (Color white) }.	self vResizing: #shrinkWrap.	self hResizing: #shrinkWrap.	color _ Color paleYellow.	borderWidth _ 4.	borderColor _ #complexRaised.	self layoutInset: (4@6).	self rebuild.	fs origin: bounds origin.	fs direction: 0@self fullBounds height.	self fillStyle: fs.! !!TLoginMorph methodsFor: 'initialize' stamp: 'ar 12/26/2002 16:05'!name: aString actionBlock: aBlock cancelBlock: altBlock	theName _ aString.	actionBlock _ aBlock.	cancelBlock _ altBlock.	theNameMorph contentsWrapped: theName.	theNameMorph editor selectAll.! !!TLoginMorph methodsFor: 'initialize' stamp: 'ar 12/26/2002 16:05'!openInWorld: aWorld	super openInWorld: aWorld.	aWorld primaryHand newKeyboardFocus: theNameMorph.! !!TLoginMorph methodsFor: 'initialize' stamp: 'ar 12/26/2002 16:20'!rebuild	self removeAllMorphs.	"self addARow: { (StringMorph contents:'Please enter your credentials') lock }."	self addARow: {		(StringMorph contents: 'User name' font: self myFont) lock.	}.	(self addARow: {		(theNameMorph _ TextMorph new			beAllFont: self myFont;			crAction: (MessageSend receiver: self selector: #doOK);			extent: 236@20;			contentsWrapped: '<user name>';			setBalloonText: 'Enter your name'			).	}) color: Color white; borderColor: Color black; borderWidth: 1.	self addARow: {		(StringMorph contents: 'Password:' font: self myFont) lock.	}.	(self addARow: {		(thePasswordMorph _ TextMorph new			beAllFont: (StrikeFont passwordFontSize: 16);			crAction: (MessageSend receiver: self selector: #doOK);			extent: 236@20;			contentsWrapped: '<password>';			setBalloonText: 'Enter your password'			).	}) color: Color white; borderColor: Color black; borderWidth: 1.	self addARow: {		self okButton.		self cancelButton.	}.	"self addARow: { (StringMorph contents:'') lock }."! !!TMetaNil methodsFor: 'nilMessage' stamp: 'das 4/11/2003 16:05'!doesNotUnderstand: message"don't do anything"! !!TMetaNotification methodsFor: 'as yet unclassified' stamp: 'das 9/29/2004 18:34'!defaultAction	self resume: false! !!TMetaSend methodsFor: 'initialize' stamp: 'ar 10/3/2004 08:05'!teaObject: to		teaObject _ to.! !!TMetaSend methodsFor: 'action' stamp: 'ar 10/4/2004 13:10'!doesNotUnderstand: aMessage"This 'meta' message first calls the local version of the method then makes a remote call if required. There are three possibilities:	meta - send message locally and remotely.	metaSend - send message only remotely.	metaConstruct - send message locally and send a contruct message remotely to the 		glx metaConstructor."	| message args |	"----------------Send the message locally."	TeaHost setBaseObjectNumber. "saves the current object construction number for sending"	"-------------------Send the message."	"convert tea objects into tea names"	args := aMessage arguments collect:[:a | a teaName].	message _ TeaMessage new setTarget: teaObject teaName selector: aMessage selector arguments: args host: TeaHost currentHostName number: TeaHost getBaseObjectNumber atTime: TeaTime now.	CroquetGlobals teaParty broadcastForEffect: message.	^teaObject.! !!TMeta methodsFor: 'action' stamp: 'ar 10/4/2004 13:15'!doesNotUnderstand: aMessage	super doesNotUnderstand: aMessage. "broadcast remotely"	^teaObject perform: aMessage selector withArguments: aMessage arguments! !!TModel methodsFor: 'as yet unclassified' stamp: 'ar 10/1/2004 14:10'!camera: ac! !!TModel methodsFor: 'as yet unclassified' stamp: 'ar 10/12/2002 23:49'!close	self delete.! !!TModel methodsFor: 'as yet unclassified' stamp: 'ar 10/25/2002 23:22'!closeRequest	self close.! !!TModel methodsFor: 'as yet unclassified' stamp: 'ar 9/10/2002 21:15'!delete	window ifNotNil:[window delete].! !!TModel methodsFor: 'as yet unclassified' stamp: 'ar 9/8/2002 02:23'!initialize! !!TModel methodsFor: 'as yet unclassified' stamp: 'ar 9/8/2002 03:56'!myEventMap	^myEventMap! !!TModel methodsFor: 'as yet unclassified' stamp: 'ar 9/8/2002 03:56'!myEventMap: x	myEventMap := x! !!TModel methodsFor: 'as yet unclassified' stamp: 'ar 9/8/2002 03:56'!myScripts	^myScripts ifNil:[#()]! !!TModel methodsFor: 'as yet unclassified' stamp: 'ar 9/8/2002 03:56'!myScripts: x	myScripts := x.! !!TModel methodsFor: 'as yet unclassified' stamp: 'ar 10/25/2002 23:21'!open	window := TWindowMorph new.	window model: self.	window frame alphaSlider hResizing: #spaceFill.	window model: self.	window content addMorph: ((BorderedMorph new) borderColor: #inset; color: Color transparent) frame: (0@0 corner: 1@1).	window windowColor: self windowColor.	window extent: 256@256.	World addMorphFront: window.	^window! !!TModel methodsFor: 'as yet unclassified' stamp: 'ar 9/8/2002 14:28'!perform: aSymbol orSendTo: ignored	^self perform: aSymbol! !!TModel methodsFor: 'as yet unclassified' stamp: 'ar 10/26/2002 00:47'!postBuildIn: teapot! !!TModel methodsFor: 'as yet unclassified' stamp: 'ar 10/25/2002 22:10'!window	^window! !!TModel methodsFor: 'as yet unclassified' stamp: 'ar 9/8/2002 02:47'!windowColor	^Color r: 0.7 g: 0.7 b: 0.4! !!TConnectionDialog methodsFor: 'initialize' stamp: 'ar 10/4/2004 15:58'!addInputNames: propNames values: propValues	| nameTile valueTile |	{		{'Nickname:'.	#nickName.		#nickName:}.		{'Partyname:'.	#partyName.	#partyName:}.		"{'Rendevous:'.	#partyURL. #partyURL:}."	} do:[:spec|		nameTile := UpdatingStringMorph new contents: spec first.		valueTile := UpdatingStringMorph new contents: ''.		valueTile useStringFormat.		valueTile target: self.		valueTile getSelector: spec second.		valueTile putSelector: spec third.		valueTile step.		propNames addMorphBack: nameTile.		propValues addMorphBack: valueTile.	].! !!TConnectionDialog methodsFor: 'initialize' stamp: 'ar 9/10/2002 21:02'!buildConnectButton	| button |	button _ ScriptableButton new.	button color: (Color white mixed: 0.8 with: self windowColor).	button borderColor: #raised; borderWidth: 2; cornerStyle: #square.	button label: 'Connect' font: nil.	button target: self.	button actionSelector: #connect.	^button! !!TConnectionDialog methodsFor: 'initialize' stamp: 'ar 9/10/2002 21:05'!buildInputPane	| frame lf div propNames propValues |	div := 0.3.	frame := Morph new color: Color transparent.	frame layoutPolicy: ProportionalLayout new.	frame hResizing: #spaceFill; vResizing: #shrinkWrap.	propNames := Morph new color: Color transparent.	lf := LayoutFrame new.	lf leftFraction: 0.0.	lf rightFraction: div offset: -1.	frame addMorph: propNames fullFrame: lf.	propNames clipSubmorphs: true.	propNames hResizing: #spaceFill; vResizing: #shrinkWrap.	propNames layoutPolicy: TableLayout new.	propNames cellPositioning: #topLeft.	propNames layoutInset: 2@2; cellInset: 0@2.	propValues := AlignmentMorph new color: Color transparent.	lf := LayoutFrame new.	lf leftFraction: div offset: 1.	lf rightFraction: 1.	frame addMorph: propValues fullFrame: lf.	propValues clipSubmorphs: true.	propValues hResizing: #spaceFill; vResizing: #shrinkWrap.	propValues layoutPolicy: TableLayout new.	propValues listDirection: #topToBottom.	propValues cellPositioning: #topLeft.	propValues layoutInset: 2@2; cellInset: 0@2.	self addInputNames: propNames values: propValues.	^frame! !!TConnectionDialog methodsFor: 'initialize' stamp: 'ar 9/10/2002 21:12'!buildOptionsList	| holder row toggle label |	holder _ Morph new color: Color transparent.	holder layoutPolicy: TableLayout new; listDirection: #topToBottom; cellPositioning: #topLeft.	holder hResizing: #spaceFill; vResizing: #shrinkWrap.	{		{'Force tunneling'. #forceTunnel. #toggleTunnel}.		{'LAN only (disable internet)'. #disableInternet. #toggleInternet}.	} do:[:spec|		row _ Morph new color: Color transparent.		row layoutPolicy: TableLayout new; hResizing: #spaceFill; vResizing: #shrinkWrap.		row listDirection: #leftToRight; layoutInset: 20@2; cellInset: 2@2.		toggle _ (EtoyUpdatingThreePhaseButtonMorph checkBox)			target: self; getSelector: spec second; actionSelector: spec third; arguments: #().		row addMorphBack: toggle.		label _ StringMorph new contents: spec first.		row addMorphBack: label.		holder addMorphBack: row.	].	^holder! !!TConnectionDialog methodsFor: 'initialize' stamp: 'ar 10/1/2004 14:10'!camera: ac	teapot := ac morphicOverlay.	^super camera: ac! !!TConnectionDialog methodsFor: 'initialize' stamp: 'ar 9/10/2002 21:20'!initialize	super initialize.	forceTunnel _ TeaParty forceTunnel.	disableInternet _ TeaParty disableInternet.	partyName _ 'Tea'.	partyURL _ 'http://www.reed.com/TeaParties/'.	nickName _ Utilities authorInitialsPerSe.! !!TConnectionDialog methodsFor: 'initialize' stamp: 'ar 10/25/2002 23:21'!open	window := TWindowMorph new.	window model: self.	window content hResizing: #rigid; vResizing: #rigid.	window content extent: 225@135.	window content addMorph: self buildInputPane frame: (0@0.1 corner: 1@0.3).	window content addMorph: self buildOptionsList frame: (0@0.5 corner: 1@0.7).	window content addMorph: self buildConnectButton frame: (0@0.8 corner: 1@1).	window windowColor: self windowColor.	window label: 'Connect'.	window extent: 225@225. "need to fix the layout problem..."	World addMorphFront: window.	^window! !!TConnectionDialog methodsFor: 'connect' stamp: 'ar 9/10/2002 21:14'!connect	teapot ifNil:[^self delete].	TeaParty forceTunnel: forceTunnel.	TeaParty disableInternet: disableInternet.	teapot connect: partyURL partyName: partyName nickName: nickName.	self delete.! !!TConnectionDialog methodsFor: 'accessing' stamp: 'ar 9/10/2002 20:24'!disableInternet	^disableInternet! !!TConnectionDialog methodsFor: 'accessing' stamp: 'ar 9/10/2002 20:23'!disableInternet: aBool	disableInternet _ aBool.	self changed: #disableInternet.! !!TConnectionDialog methodsFor: 'accessing' stamp: 'ar 9/10/2002 20:24'!forceTunnel	^forceTunnel! !!TConnectionDialog methodsFor: 'accessing' stamp: 'ar 9/10/2002 20:40'!forceTunnel: aBool	forceTunnel _ aBool.	self changed: #forceTunnel.! !!TConnectionDialog methodsFor: 'accessing' stamp: 'ar 9/10/2002 21:10'!nickName	^nickName isEmptyOrNil ifTrue:['visitor'] ifFalse:[nickName].! !!TConnectionDialog methodsFor: 'accessing' stamp: 'ar 9/10/2002 20:26'!nickName: aString	nickName _ aString.	self changed: #nickName.! !!TConnectionDialog methodsFor: 'accessing' stamp: 'ar 9/10/2002 20:26'!partyName	^partyName! !!TConnectionDialog methodsFor: 'accessing' stamp: 'ar 9/10/2002 20:26'!partyName: aString	partyName _ aString.	self changed: #partyName.! !!TConnectionDialog methodsFor: 'accessing' stamp: 'ar 9/10/2002 20:26'!partyURL	^partyURL! !!TConnectionDialog methodsFor: 'accessing' stamp: 'ar 9/10/2002 20:27'!partyURL: aString	partyURL _ aString.	self changed: #partyURL.! !!TConnectionDialog methodsFor: 'accessing' stamp: 'ar 9/10/2002 21:12'!teapot	^teapot! !!TConnectionDialog methodsFor: 'accessing' stamp: 'ar 9/10/2002 21:13'!teapot: aTeapotMorph	teapot:= aTeapotMorph! !!TConnectionDialog methodsFor: 'accessing' stamp: 'ar 9/10/2002 20:40'!toggleInternet	self disableInternet: self disableInternet not.! !!TConnectionDialog methodsFor: 'accessing' stamp: 'ar 9/10/2002 20:39'!toggleTunnel	self forceTunnel: self forceTunnel not! !!TModel class methodsFor: 'as yet unclassified' stamp: 'ar 9/8/2002 02:24'!new	^super new initialize! !!TModel class methodsFor: 'as yet unclassified' stamp: 'ar 9/8/2002 02:23'!open	^self new open! !!TObject methodsFor: 'accessing' stamp: 'das 10/3/2004 10:02'!teaName	^TeaName new initialize: self teaObjectName class: false.! !!TObject methodsFor: 'accessing' stamp: 'das 9/28/2004 14:15'!teaObjectName	^teaObjectName! !!TObject methodsFor: 'accessing' stamp: 'das 9/28/2004 14:15'!teaObjectName: oName	teaObjectName _ oName.! !!TObject methodsFor: 'fileIn/fileOut' stamp: 'ar 10/2/2004 08:24'!postImportFrom: importer	self register.! !!TObject methodsFor: 'fileIn/fileOut' stamp: 'ar 10/2/2004 08:23'!prepareToExportOn: exporter	teaObjectName := nil.! !!TObject methodsFor: 'fileIn/fileOut' stamp: 'ar 11/15/2002 19:38'!teaExportOn: exporter	^exporter exportTeaObject: self! !!TObject methodsFor: 'initialize' stamp: 'ar 10/2/2004 15:38'!initialize	self register.! !!TObject methodsFor: 'initialize' stamp: 'ar 10/2/2004 19:44'!register	teaObjectName _ (self class name, Processor activeProcess hostName, Processor activeProcess  nextObjectNumber) asSymbol.	CroquetGlobals registerTeaObject: self.! !!TObject methodsFor: 'testing' stamp: 'das 10/16/2002 00:12'!isFrame	^ false.! !!TObject methodsFor: 'testing' stamp: 'das 9/28/2004 14:30'!isTeaObject		^ true.! !!TObject methodsFor: 'testing' stamp: 'DPR 8/8/2004 14:33'!isTeaParty	^ false.! !!TObject methodsFor: 'copying' stamp: 'ar 10/2/2004 08:29'!copy	^self shallowCopy postCopy! !!TObject methodsFor: 'copying' stamp: 'ar 10/2/2004 08:24'!postCopy	self register.! !!TObject methodsFor: 'teatime' stamp: 'das 10/3/2004 14:04'!future: fval perform: selector 	self future: fval perform: selector withArguments: #().! !!TObject methodsFor: 'teatime' stamp: 'das 10/3/2004 15:33'!future: fval perform: selector withArguments: args 	| tm |	tm _ TeaMessage new setTarget: self selector: selector arguments: args atTime: TeaTime now + fval.	CroquetGlobals messageList add: tm.! !!TFrame methodsFor: 'hierarchy' stamp: 'ar 9/30/2004 16:27'!addChild: child	frameChildren ifNil:[frameChildren _ OrderedCollection new.]."If child singleParent is true, then we can not add this frame until we have removed it from a previous parent."	child singleParent ifTrue:[ 		child parent ifNotNil:[child parent removeChild: child].		self singleParent: true.].	"make sure child and all its subframes are informed of all viewers so they can be added to their tea parties"	frameChildren add: child.	child isComponent ifTrue: [ child startStepping].	child parent: self.	child addLightFrames.	child addPortalFrames.	child addRayFrames.	myPlayer ifNotNil:[myPlayer signal: #structureChanged].! !!TFrame methodsFor: 'hierarchy' stamp: 'das 3/9/2004 13:23'!boundSpheresDo: aBlock	| bSphere |	bSphere := self boundSphere.	bSphere ifNotNil:[^aBlock value: bSphere].	frameChildren ifNil:[^self].	self frameChildren do:[:each| each boundSpheresDo: aBlock].! !!TFrame methodsFor: 'hierarchy'!child: index	^frameChildren at: index.! !!TFrame methodsFor: 'hierarchy' stamp: 'das 12/18/2002 11:44'!collapse"Forces all frames to identity transform while retaining translation, and pushes the previous transform to the frame children. This is used primarily for meshes and their supporting groups."	| orient trans |	trans _ self translation.	orient _ self orientation.	frameChildren ifNotNil:[ 		frameChildren do:[ :fc |  			fc localTransform: (orient composeWith: fc localTransform).			fc collapse.		].	].	self localTransform: B3DMatrix4x4 identity.	self translation: trans.! !!TFrame methodsFor: 'hierarchy' stamp: 'das 5/11/2002 13:56'!currentParent: fParent		frameParent _ fParent.! !!TFrame methodsFor: 'hierarchy' stamp: 'DPR 1/9/2004 14:05'!destroy	frameParent ifNotNil:[frameParent removeChild: self].! !!TFrame methodsFor: 'hierarchy' stamp: 'das 1/2/2003 17:57'!hasChild: child	frameChildren ifNotNil:[		frameChildren do:[:fc | 			fc = child ifTrue:[^ true ].].].	^ false.! !!TFrame methodsFor: 'hierarchy' stamp: 'DPR 1/9/2004 14:05'!insertFrame: frm	| parent |	self parent ifNotNil:[		parent _ self parent.		parent removeChild: self.		parent addChild: frm.		].	frm addChild: self.! !!TFrame methodsFor: 'hierarchy' stamp: 'DPR 1/9/2004 14:05'!isChild: parent	^ parent hasChild: self.! !!TFrame methodsFor: 'hierarchy'!parent		 ^frameParent.! !!TFrame methodsFor: 'hierarchy'!parent: fParent		self frameChanged.	frameParent _ fParent.! !!TFrame methodsFor: 'hierarchy' stamp: 'das 8/15/2002 13:40'!prune"	frameChildren ifNotNil:[		frameChildren do:[ :fc | fc prune ifTrue:[			self removeChild: fc.].].		frameChildren size = 0 ifTrue:[frameChildren _ nil].		].	(self class = TFrame and:[ frameChildren = nil ])ifTrue:[^true].	^ false."! !!TFrame methodsFor: 'hierarchy'!removeAll	| child |		frameChildren ifNil:[^nil.].	[frameChildren size = 0] whileFalse:[		child _ frameChildren at: 1.		frameChildren removeAt: 1.		child removeLightFrames.		child removePortalFrames.		].	frameChildren _ nil.! !!TFrame methodsFor: 'hierarchy' stamp: 'DPR 1/18/2004 22:21'!removeChild: child	| |	child removeLightFrames.	child removePortalFrames.		child removeRayFrames.	frameChildren ifNotNil:[frameChildren remove: child ifAbsent:[].].	child isComponent ifTrue:[ child stopStepping. ].	child parent: nil.	myPlayer ifNotNil:[myPlayer signal: #structureChanged].! !!TFrame methodsFor: 'hierarchy' stamp: 'DPR 1/9/2004 14:05'!removeSelf	self parent ifNotNil:[		self parent removeChild: self.].! !!TFrame methodsFor: 'hierarchy' stamp: 'DPR 1/9/2004 14:05'!root	frameParent ifNil:[^ self] ifNotNil:[^ frameParent root.].! !!TFrame methodsFor: 'hierarchy'!singleParent	" singleParent forces a frame to only have one parent. Most frames enable multiple parents to easily enable instancing of the objects. However, certain object types such as lights and cameras can NOT be instanced. If singleParent is set to true, if a frame is added as a child to a new parent, it will be removed from the previous parent frame first."	 ^singleParent.! !!TFrame methodsFor: 'hierarchy'!singleParent: bool		 singleParent _ bool.! !!TFrame methodsFor: 'hierarchy' stamp: 'DPR 1/9/2004 14:05'!transferTo: frame	self parent ifNotNil:[ self parent removeChild: self].	frame addChild: self.! !!TFrame methodsFor: 'scripts' stamp: 'ar 10/3/2004 11:04'!attachBehavior: aBehavior	aBehavior target == self ifFalse:[^aBehavior attachTo: self].	self myBehaviors: (self myBehaviors copyWith: aBehavior).! !!TFrame methodsFor: 'scripts' stamp: 'ar 10/3/2004 11:04'!detachBehavior: aBehavior	aBehavior target == nil ifFalse:[		aBehavior target == self ifFalse:[^self error:'Behavior is not owned by me'].		^aBehavior detach].	self myBehaviors: (self myBehaviors copyWithout: aBehavior).! !!TFrame methodsFor: 'scripts' stamp: 'ar 7/21/2002 17:41'!myEventMap	^myEventMap! !!TFrame methodsFor: 'scripts' stamp: 'ar 7/21/2002 17:41'!myEventMap: anEventMap	myEventMap _ anEventMap! !!TFrame methodsFor: 'scripts' stamp: 'ar 10/10/2002 19:11'!myPlayer	^myPlayer! !!TFrame methodsFor: 'scripts' stamp: 'ar 10/10/2002 11:28'!myPlayer: aPlayer	myPlayer := aPlayer! !!TFrame methodsFor: 'scripts' stamp: 'ar 7/21/2002 17:41'!myScripts: scriptList	myScripts _ scriptList! !!TFrame methodsFor: 'scripts' stamp: 'ar 10/2/2004 19:55'!player	^myPlayer! !!TFrame methodsFor: 'scripts' stamp: 'ar 10/2/2004 19:49'!signalEvent: anEvent	"Signal the occurance of anEvent"	super signalEvent: anEvent.	myPlayer ifNil:[^self].	anEvent setSender: myPlayer.	myPlayer signalEvent: anEvent.! !!TFrame methodsFor: 'frameManagement'!addLightFrame: litefrm	frameParent ifNotNil:[frameParent addLightFrame: litefrm.]! !!TFrame methodsFor: 'frameManagement' stamp: 'DPR 1/9/2004 14:05'!addLightFrames	" When a frame is added as a child, any lights included in the heirarchy are reported to the base TRoom."	self isLight ifTrue:[ self addLightFrame: self].	frameChildren ifNotNil: [frameChildren do:[ :fc | fc addLightFrames ].].	! !!TFrame methodsFor: 'frameManagement'!addPortalFrame: prtlFrm	frameParent ifNotNil:[frameParent addPortalFrame: prtlFrm.]! !!TFrame methodsFor: 'frameManagement' stamp: 'DPR 1/9/2004 14:05'!addPortalFrames	" When a frame is added as a child, any portals included in the heirarchy are reported to the base TRoom."	self isPortal ifTrue:[ self addPortalFrame: self].	frameChildren ifNotNil: [frameChildren do:[ :fc | fc addPortalFrames ].].	! !!TFrame methodsFor: 'frameManagement' stamp: 'das 11/9/2002 15:06'!addRayFrame: rayfrm	frameParent ifNotNil:[frameParent addRayFrame: rayfrm.]! !!TFrame methodsFor: 'frameManagement' stamp: 'DPR 1/9/2004 14:05'!addRayFrames	" When a frame is added as a child, any rays included in the heirarchy are reported to the base TSpace."	self isRay ifTrue:[ self addRayFrame: self].	frameChildren ifNotNil: [frameChildren do:[ :fc | fc addRayFrames ].].	! !!TFrame methodsFor: 'frameManagement' stamp: 'das 10/26/2002 13:31'!forceGlobalToLocal"This is used by TMesh when the imported vertices are pre-transformed, and all of the nodes are in global coordinates and we want to put them back into their untransformed state. This occurs with the 3DS Max ASE files."	frameChildren ifNotNil:[ frameChildren do:[ :fc | fc forceGlobalToLocal.]].	frameParent ifNotNil:[		self localTransform: (			frameParent localTransform orthoNormInverse composeWith: self localTransform).		].! !!TFrame methodsFor: 'frameManagement'!removeLightFrame: litefrm	frameParent ifNotNil:[frameParent removeLightFrame: litefrm.]! !!TFrame methodsFor: 'frameManagement' stamp: 'DPR 1/9/2004 14:05'!removeLightFrames	" When a frame is disconnected from its parent, we need to remove the references to the lights in the TRoom."	self isLight ifTrue:[self removeLightFrame: self.].	frameChildren ifNotNil:[frameChildren do:[ :fc | fc removeLightFrames ].].	! !!TFrame methodsFor: 'frameManagement' stamp: 'das 7/11/2002 01:44'!removePortalFrame: prtlFrm	frameParent ifNotNil:[frameParent removePortalFrame: prtlFrm.]! !!TFrame methodsFor: 'frameManagement' stamp: 'DPR 1/9/2004 14:05'!removePortalFrames	" When a frame is disconnected from its parent, we need to remove the references to the lights in the TRoom."	self isPortal ifTrue:[self removePortalFrame: self.].	frameChildren ifNotNil:[frameChildren do:[ :fc | fc removePortalFrames ].].	! !!TFrame methodsFor: 'frameManagement' stamp: 'das 11/9/2002 15:07'!removeRayFrame: rayfrm	frameParent ifNotNil:[frameParent removeRayFrame: rayfrm.]! !!TFrame methodsFor: 'frameManagement' stamp: 'DPR 1/9/2004 14:05'!removeRayFrames	" When a frame is disconnected from its parent, we need to remove the references to the rays in the TSpace."	self isRay ifTrue:[self removeRayFrame: self.].	frameChildren ifNotNil:[frameChildren do:[ :fc | fc removeRayFrames ].].	! !!TFrame methodsFor: 'frameManagement' stamp: 'DPR 1/18/2004 22:22'!replaceChild: oldChild with: newChild	| |	oldChild removeLightFrames.	oldChild removePortalFrames.		oldChild removeRayFrames.	frameChildren replace: oldChild with: newChild.	oldChild isComponent ifTrue:[ oldChild stopStepping.].	oldChild parent: nil.	newChild isComponent ifTrue: [ newChild startStepping. ].	newChild parent: self.	newChild addLightFrames.	newChild addPortalFrames.	newChild addRayFrames.! !!TFrame methodsFor: 'transform' stamp: 'das 5/10/2004 15:10'!addRotationAroundX: anAngle	| trans rtrans |	self frameChanged.	rtrans _ B3DMatrix4x4 identity.	rtrans rotationAroundX: anAngle.	trans _ self translation.	localTransform _ rtrans composeWith:localTransform.	self translation: trans.	^ localTransform.! !!TFrame methodsFor: 'transform' stamp: 'das 5/10/2004 15:10'!addRotationAroundY: anAngle	| trans rtrans |	self frameChanged.	rtrans _ B3DMatrix4x4 identity.	rtrans rotationAroundY: anAngle.	trans _ self translation.	localTransform _ rtrans composeWith:localTransform.	self translation: trans.	^ localTransform.! !!TFrame methodsFor: 'transform' stamp: 'das 5/10/2004 15:07'!addRotationAroundZ: anAngle	| trans rtrans |	self frameChanged.	rtrans _ B3DMatrix4x4 identity.	rtrans rotationAroundZ: anAngle.	trans _ self translation.	localTransform _ rtrans composeWith:localTransform.	self translation: trans.	^ localTransform.! !!TFrame methodsFor: 'transform' stamp: 'das 2/10/2003 12:12'!addYaw: y	self yaw: self yaw + y.! !!TFrame methodsFor: 'transform' stamp: 'das 10/3/2004 16:37'!frameLookAt: frame" used to put my lookAt vector into the frame of the argument"	^ frame inverseGlobalOrientation localPointToGlobal: self lookAt negated.! !!TFrame methodsFor: 'transform' stamp: 'das 3/31/2003 11:51'!globalMatrixOut" This simply reverses the direction of the matrix. An example of use is for TPortals, where the global matrix used for rendering the outside of the portal is the reverse of the exiting render, hence we need to flip the matrix around to get what we want."	| gt |	gt _ self globalTransform copy.	gt a11: 0.0 - gt a11.	gt a21: 0.0 - gt a21.	gt a31: 0.0 - gt a31.	gt a13: 0.0 - gt a13.	gt a23: 0.0 - gt a23.	gt a33: 0.0 - gt a33.	^ gt! !!TFrame methodsFor: 'transform'!globalOrientation"This is used to return just the orientation part of the matrix.The translation part is 0.0."	| mat |	mat _ self globalTransform clone.	mat translationX: 0.0 y: 0.0 z: 0.0.	^ mat.! !!TFrame methodsFor: 'transform' stamp: 'das 2/10/2003 12:16'!globalPitch	^self globalPitchYawRoll x! !!TFrame methodsFor: 'transform' stamp: 'das 2/10/2003 12:19'!globalPitchYawRoll	globalTransform ifNil:[^ 0.0@0.0@0.0].	^globalTransform pitchYawRoll! !!TFrame methodsFor: 'transform' stamp: 'das 12/4/2002 19:34'!globalPosition	frameChanged ifTrue:[	self globalTransform. ].	^ globalPosition."	^ self globalTransform translation."! !!TFrame methodsFor: 'transform' stamp: 'das 7/26/2004 19:42'!globalPosition: gp	self globalTransform.	frameChanged _ false.	globalPosition _ gp.	globalTransform translation: gp.	! !!TFrame methodsFor: 'transform' stamp: 'das 2/10/2003 12:16'!globalRoll	^self globalPitchYawRoll z! !!TFrame methodsFor: 'transform' stamp: 'das 7/11/2003 12:27'!globalTransform	" This is the global transform of the frame - its location and orientation in global world coordinates. We only	calculate this when we have to, which is only when a local coordinate frame has been changed AND when someone 	asks for it. "	frameChanged ifTrue:[			frameParent ifNotNil: [ self globalTransform: 			((frameParent globalTransform) composeWith: self localTransform)] ifNil:[		self globalTransform:  self localTransform.].		globalPosition _ globalTransform translation.	].	^ globalTransform." NOT ^ self globalTransform - this causes bad recursion error!!"					 ! !!TFrame methodsFor: 'transform' stamp: 'das 7/11/2003 12:49'!globalTransform: gTrans		frameChanged _ false.	globalTransform _ gTrans.	globalPosition _ globalTransform translation.	self globalTransformUpdate.	^ globalTransform.! !!TFrame methodsFor: 'transform' stamp: 'das 5/11/2002 14:31'!globalTransformUpdate	" This is called when a new global transfom is calculated. It is designed to be extended by other frame sub-classes, such as TRigidBody, that would have variables that should be updated once when the frame gets changed."! !!TFrame methodsFor: 'transform' stamp: 'das 2/10/2003 12:16'!globalYaw	^self globalPitchYawRoll y! !!TFrame methodsFor: 'transform'!inverseGlobalOrientation	^ self globalOrientation orthoNormInverse.! !!TFrame methodsFor: 'transform'!inverseGlobalTransform	^ self globalTransform orthoNormInverse.! !!TFrame methodsFor: 'transform' stamp: 'das 5/10/2004 15:08'!localTransform	^localTransform.! !!TFrame methodsFor: 'transform'!localTransform: m4x4	self frameChanged.	localTransform _ m4x4.! !!TFrame methodsFor: 'transform' stamp: 'das 7/14/2004 16:02'!lookAt: v up: u	| at side m trans up |	up _ u.	trans _ self translation.	at _ trans - v.	at normalize.	up ifNil:[		at y abs = 1.0 ifFalse:[ up _ B3DVector3 x: 0 y: 1 z: 0.] ifTrue:[			up _ B3DVector3 x:0 y:0 z:-1].].	side _ (at cross: up) normalized negated.	up _ (side cross: at) normalized negated.	m _ B3DMatrix4x4 identity.	m a11: side x.	m a21: side y.	m a31: side z.	m a12: up x.	m a22: up y.	m a32: up z.	m a13: at x.	m a23: at y.	m a33: at z.	self localTransform: m.	self translation: trans.! !!TFrame methodsFor: 'transform' stamp: 'DPR 1/9/2004 14:05'!newRoot: newRoot newTransform: newTransform	| oldRoot |	oldRoot := self root.	self signal: #spaceLeave with: oldRoot.	oldRoot signal: #objectLeave with: self.	self parent removeChild: self.	newRoot addChild: self.	self localTransform: newTransform.	self signal: #spaceEnter with: newRoot.	newRoot signal: #objectEnter with: self.! !!TFrame methodsFor: 'transform' stamp: 'das 5/10/2004 15:09'!orientation"This is used to return just the orientation part of the matrix.The translation part is 0.0."	| mat |	mat _ localTransform clone.	mat translationX: 0.0 y: 0.0 z: 0.0.	^ mat.! !!TFrame methodsFor: 'transform' stamp: 'das 5/10/2004 15:10'!orientation: mat"This is used to set just the orientation part of the matrix. It keeps the translation parts intact."	| trans |	self frameChanged.	trans _ self translation.	localTransform _ mat clone.	self translation: trans.	^ localTransform.! !!TFrame methodsFor: 'transform' stamp: 'das 2/10/2003 12:12'!pitch	^self pitchYawRoll x! !!TFrame methodsFor: 'transform' stamp: 'das 2/10/2003 12:12'!pitch: p	| angles |	angles := self pitchYawRoll.	angles x: p.	self pitchYawRoll: angles.! !!TFrame methodsFor: 'transform' stamp: 'das 2/10/2003 12:11'!pitchYawRoll	^localTransform pitchYawRoll! !!TFrame methodsFor: 'transform' stamp: 'das 2/10/2003 12:11'!pitchYawRoll: aVector	| tfm |	tfm := localTransform copy pitchYawRoll: aVector.	self localTransform: tfm.! !!TFrame methodsFor: 'transform' stamp: 'das 2/10/2003 12:11'!pitchYawRollBy: delta	self pitchYawRoll: self pitchYawRoll + delta! !!TFrame methodsFor: 'transform' stamp: 'das 5/10/2004 15:08'!quaternion	^ localTransform asQuaternion.! !!TFrame methodsFor: 'transform' stamp: 'das 7/6/2002 15:20'!relativeTransform: frame	^ self globalTransform orthoNormInverse composeWith: frame globalTransform.! !!TFrame methodsFor: 'transform' stamp: 'das 3/9/2004 14:35'!releaseToRoot	"Transfer the frame from the current parent to the root frame while keeping the pose in exactly the same orientation"	| trans root |	trans _ self globalTransform.	root _ self root.	self transferTo: root.	self localTransform: trans.! !!TFrame methodsFor: 'transform' stamp: 'das 2/10/2003 12:12'!roll	^self pitchYawRoll z! !!TFrame methodsFor: 'transform' stamp: 'das 2/10/2003 12:13'!roll: r	| angles |	angles := self pitchYawRoll.	angles z: r.	self pitchYawRoll: angles.! !!TFrame methodsFor: 'transform' stamp: 'ar 9/8/2002 15:51'!rotFromBallPoints: from to: to |  f t |" This matrix needs to be transposed to convert from left handed to right (which is OpenGL's world)."	f _ from normalized.	t _ to normalized.	f _ (f+t) normalized.	f _ (f+t) normalized.	^  (B3DRotation 	a: (f x * t x) + (f y * t y) + (f z * t z )				b: (f y * t z) - (f z * t y)			  	c: (f z * t x) - (f x * t z)			  	d: (f x * t y) - (f y * t x)			  	).! !!TFrame methodsFor: 'transform' stamp: 'das 5/10/2004 15:10'!rotation: anAngle around: aVector3	| trans |	self frameChanged.	trans _ self translation.	localTransform rotation: anAngle around: aVector3.	self translation: trans.	^ localTransform.! !!TFrame methodsFor: 'transform' stamp: 'das 5/10/2004 15:08'!rotation: anAngle aroundX: xValue y: yValue z: zValue	| trans |	self frameChanged.	trans _ self translation.	localTransform rotation: anAngle aroundX: xValue y: yValue z: zValue.	self translation: trans.	^ localTransform.! !!TFrame methodsFor: 'transform' stamp: 'das 5/10/2004 15:09'!rotationAroundX: anAngle	| trans |	self frameChanged.	trans _ self translation.	localTransform rotationAroundX: anAngle.	self translation: trans.	^ localTransform.! !!TFrame methodsFor: 'transform' stamp: 'das 5/10/2004 15:10'!rotationAroundY: anAngle	| trans |	self frameChanged.	trans _ self translation.	localTransform rotationAroundY: anAngle.	self translation: trans.	^ localTransform.! !!TFrame methodsFor: 'transform' stamp: 'das 5/10/2004 15:10'!rotationAroundZ: anAngle	| trans |	self frameChanged.	trans _ self translation.	localTransform rotationAroundZ: anAngle.	self translation: trans.	^ localTransform.! !!TFrame methodsFor: 'transform' stamp: 'das 3/9/2004 14:36'!scale		^ 1.0.! !!TFrame methodsFor: 'transform' stamp: 'das 7/15/2002 20:22'!scale: scale	self translation: scale * self translation.	frameChildren ifNotNil:[		frameChildren do:[ :fc | fc scale: scale.]].! !!TFrame methodsFor: 'transform' stamp: 'das 5/10/2004 15:09'!transformBy: m4x4	self frameChanged.	localTransform _ localTransform composedWithLocal: m4x4.! !!TFrame methodsFor: 'transform' stamp: 'das 5/10/2004 15:10'!translation	^localTransform translation.! !!TFrame methodsFor: 'transform' stamp: 'das 5/10/2004 15:11'!translation: aVector	self frameChanged.	^localTransform translation: aVector.! !!TFrame methodsFor: 'transform' stamp: 'das 5/10/2004 15:10'!translationX: xValue y: yValue z: zValue		self frameChanged.	^ localTransform translationX: xValue y: yValue z: zValue.! !!TFrame methodsFor: 'transform' stamp: 'das 2/10/2003 12:13'!yaw	^self pitchYawRoll y! !!TFrame methodsFor: 'transform' stamp: 'das 2/10/2003 12:13'!yaw: y	| angles |	angles := self pitchYawRoll.	angles y: y.	self pitchYawRoll: angles.! !!TFrame methodsFor: 'transform' stamp: 'das 2/10/2003 12:14'!yawTransform	| v |	v _ localTransform row3.	v x > 0 ifTrue:[self yaw: v z arcCos radiansToDegrees negated] ifFalse:							[self yaw: v z arcCos radiansToDegrees.].! !!TFrame methodsFor: 'yellow-scripts-support' stamp: 'ar 9/8/2002 16:59'!eventsGenerated	"Answer a list of events generated by the receiver"	^#(		pointerDown pointerMove pointerUp		pointerEnter pointerOver pointerLeave		keyDown keystroke keyUp		frameChanged	).! !!TFrame methodsFor: 'yellow-scripts-support' stamp: 'ar 9/8/2002 17:07'!myBehaviors	^myBehaviors ifNil:[#()].! !!TFrame methodsFor: 'yellow-scripts-support' stamp: 'ar 9/8/2002 17:00'!myBehaviors: aCollection	myBehaviors := aCollection.! !!TFrame methodsFor: 'yellow-scripts-support' stamp: 'ar 7/21/2002 19:22'!myScripts	^myScripts ifNil:[#()]! !!TFrame methodsFor: 'yellow-scripts-support' stamp: 'ar 9/13/2002 21:16'!scriptBehaviors	^myBehaviors ifNil:[#()]! !!TFrame methodsFor: 'fileIn/Out' stamp: 'DPR 2/24/2004 17:23'!postImportFrom: importer	super postImportFrom: importer.	frameChanged _ true. 	frameChildren ifNotNil:[		frameChildren do:[:child| child setFrameParent: self].	].	"this seems like a bug: self isComponent ifTrue:[self startStepping]."! !!TFrame methodsFor: 'fileIn/Out' stamp: 'das 6/29/2004 12:44'!prepareToExportOn: exporter	super prepareToExportOn: exporter.	frameParent := nil.	frameChanged := nil.	timeStamp := nil.	globalTransform := nil.	streamingSound := nil.	"This should not be necessary but apparently there is a problem with the spinners otherwise..."	localTransform := localTransform clone.	frameChildren ifNotNil:[		frameChildren := frameChildren reject:[:tframe| tframe isCamera].	].! !!TFrame methodsFor: 'fileIn/Out' stamp: 'ar 6/6/2002 22:16'!setFrameParent: fParent	frameParent := fParent.! !!TFrame methodsFor: 'accessing'!boundSphere	" This will return a render bounds object if one exists. This is a TBoundSphere (location + radius), which is used to determine if a particular object is inside the clipping planes or for collision detection tests. Otherwise, the object will be assumed to have a local coordinate location of 0,0,0 and a radius of 1.0."	^ nil.! !!TFrame methodsFor: 'accessing' stamp: 'das 3/9/2004 14:34'!boundingBox	"Answer the bounding box for the receiver and its children"	^ self boundingBox: B3DMatrix4x4 identity.! !!TFrame methodsFor: 'accessing' stamp: 'das 4/18/2003 19:21'!boundingBox: trans	"Answer the bounding box for the receiver and its children"	| box childBox |	box := self frameBox.	self frameChildrenDo:[:child|		childBox := child boundingBox transformedBy: (trans composeWith: child localTransform).		box := box merge: childBox.	].	^box! !!TFrame methodsFor: 'accessing' stamp: 'das 7/9/2003 12:19'!boundsChanged	" Does nothing"! !!TFrame methodsFor: 'accessing' stamp: 'das 4/28/2002 23:40'!boundsDepth: depth	frameChildren ifNotNil:[		frameChildren do:[:fc | fc boundsDepth: depth].].! !!TFrame methodsFor: 'accessing' stamp: 'das 3/9/2004 15:21'!changed: frame	" Does nothing, just forward on to parent."	self parent ifNotNil:[self parent changed: frame.]! !!TFrame methodsFor: 'accessing' stamp: 'das 3/9/2004 14:35'!childChanged			self childChanged: self.! !!TFrame methodsFor: 'accessing' stamp: 'das 3/9/2004 14:35'!childChanged: frame	" Does nothing, just forward on to parent."	self parent ifNotNil:[self parent changed: frame.]! !!TFrame methodsFor: 'accessing' stamp: 'das 5/24/2003 22:17'!colorize: color	"used by buttons and things - this just keeps us out of trouble for now, though I may need it later..."! !!TFrame methodsFor: 'accessing' stamp: 'das 3/9/2004 13:25'!compositeBoundSphere	"Answer either my own or a composition of my children's bound spheres"	| children bSphere |	children := OrderedCollection new.	self boundSpheresDo:[:bs|		bSphere := bs union: bSphere.		children add: bs.	].	children size = 0 ifTrue:[^nil].	children size = 1 ifTrue:[^children first].	bSphere children: children.	bSphere frame: self.	bSphere transform: self globalTransform.	^bSphere! !!TFrame methodsFor: 'accessing' stamp: 'ar 9/30/2004 16:28'!disableCaching! !!TFrame methodsFor: 'accessing' stamp: 'das 12/27/2002 17:52'!disableCachingTree.	self do:[ :f | f disableCaching ].! !!TFrame methodsFor: 'accessing' stamp: 'ar 10/10/2002 16:54'!distanceTo: aFrame	^(self globalPosition - aFrame globalPosition) length! !!TFrame methodsFor: 'accessing' stamp: 'das 12/27/2002 17:46'!do: block	block value: self.	frameChildren ifNotNil:[ 		frameChildren do:[ :fc | fc do: block].].! !!TFrame methodsFor: 'accessing' stamp: 'das 3/9/2004 14:35'!extent	"Answer the bounding box for the receiver and its children"	^ self boundingBox extent.! !!TFrame methodsFor: 'accessing' stamp: 'das 3/9/2004 14:35'!extent: ext	"Does nothing"! !!TFrame methodsFor: 'accessing' stamp: 'das 8/15/2002 22:59'!find: blockTest	| list |	blockTest ifNil:[^ nil].	list _ OrderedCollection new.	self find: blockTest into: list.	^ list.! !!TFrame methodsFor: 'accessing' stamp: 'DPR 1/9/2004 14:05'!find: blockTest into: list	frameChildren ifNotNil:[ 		frameChildren do:[ :fc | fc find: blockTest into: list].].	(blockTest value: self) ifTrue:[ list add: self].! !!TFrame methodsFor: 'accessing' stamp: 'ar 10/8/2002 11:03'!frameBox	"Answer the local bounding box of this frame"	^TBox origin: 0@0@0 corner: 0@0@0! !!TFrame methodsFor: 'accessing' stamp: 'ar 5/2/2003 03:11'!frameChanged	" This guarantees that if we make a change in a parent frame, all of the children are aware and can deal with it properly."	frameChanged _ true.	frameChildren ifNotNil:[		frameChildren do:[ :child | child frameChanged ].].	myEventMap ifNotNil:[self signal: #frameChanged]. "to inform interested parties"	myPlayer ifNotNil:[myPlayer signal: #frameChanged].! !!TFrame methodsFor: 'accessing'!frameChildren	^ frameChildren.! !!TFrame methodsFor: 'accessing' stamp: 'DPR 1/9/2004 14:05'!frameChildrenDo: aBlock	frameChildren ifNil:[^self].	^frameChildren do: aBlock! !!TFrame methodsFor: 'accessing' stamp: 'das 4/15/2003 17:10'!fullBright: bool	frameChildren ifNotNil:[frameChildren do:[:fc | fc fullBright: bool]].! !!TFrame methodsFor: 'accessing' stamp: 'ar 10/8/2002 17:18'!globalToLocal: anObject	^self globalTransform inverseTransformation localPointToGlobal: anObject! !!TFrame methodsFor: 'accessing' stamp: 'ar 9/7/2002 14:51'!hasAlpha	" Does this object have an alpha channel to render? Return true if it does."	^ false.! !!TFrame methodsFor: 'accessing' stamp: 'das 4/30/2002 17:05'!inertiaTensor		^ nil.! !!TFrame methodsFor: 'accessing' stamp: 'ar 9/8/2002 15:59'!localToGlobal: anObject	^self globalTransform localPointToGlobal: anObject! !!TFrame methodsFor: 'accessing' stamp: 'ar 6/6/2002 16:59'!locator	"Return a locator telling us where to find this guy on the net"	^nil! !!TFrame methodsFor: 'accessing' stamp: 'das 7/31/2004 16:03'!lookAt	^ self globalTransform column3.! !!TFrame methodsFor: 'accessing' stamp: 'das 7/31/2004 16:03'!lookSide	^ self globalTransform column1.! !!TFrame methodsFor: 'accessing' stamp: 'das 7/31/2004 16:03'!lookUp	^ self globalTransform column2.! !!TFrame methodsFor: 'accessing' stamp: 'das 9/1/2004 11:13'!makeFrame	self addChild: TFrame new.! !!TFrame methodsFor: 'accessing' stamp: 'ar 9/8/2002 18:42'!material	frameChildren isEmptyOrNil ifTrue:[^nil].	^frameChildren anyOne material! !!TFrame methodsFor: 'accessing' stamp: 'ar 9/8/2002 18:41'!material: mat	frameChildren ifNil:[^self].	frameChildren do:[:each| each material: mat].! !!TFrame methodsFor: 'accessing' stamp: 'ar 10/26/2002 23:04'!materialAlpha: ignored	"backstop"! !!TFrame methodsFor: 'accessing' stamp: 'ar 10/3/2004 10:05'!objectName	^objectName ifNil:[self class name]! !!TFrame methodsFor: 'accessing'!objectName: oName	objectName _ oName.! !!TFrame methodsFor: 'accessing' stamp: 'das 6/24/2002 09:58'!objectOwner	objectOwner ifNil:[		frameParent ifNotNil:[^ frameParent objectOwner.].].	^ objectOwner.! !!TFrame methodsFor: 'accessing' stamp: 'das 7/10/2002 10:23'!objectOwner: oOwner	objectOwner _ oOwner.	self isComponent ifFalse:[		frameChildren ifNotNil:[			frameChildren do:[ :child | child objectOwner: oOwner. ].].].! !!TFrame methodsFor: 'accessing' stamp: 'das 2/20/2004 11:02'!octreeBox	| box childBox bs |	box _ TBox new.	frameChildren ifNotNil:[		frameChildren do:[ :fc | 				childBox _ fc octreeBox.			childBox ifNotNil:[				box _ box unionBox: childBox.].			].		].	bs _ self boundSphere.	bs ifNotNil:[		bs transform: self globalTransform.		box growVertex: bs globalPosition.		].	box min x > box max x ifTrue:[^ nil ].	^ box.! !!TFrame methodsFor: 'accessing' stamp: 'das 6/23/2002 13:53'!octreeRadius	| rad childRad |" Find the max bound sphere radius of the tree. This is used for quadtree/octree construction "	self boundSphere ifNotNil:[ rad _ self boundSphere radius.] ifNil:[ rad _ 0 ].	frameChildren ifNotNil:[		frameChildren do:[ :fc | 							childRad _ fc octreeRadius.			rad _ rad max: childRad.			].		].	^ rad.! !!TFrame methodsFor: 'accessing' stamp: 'das 6/24/2002 14:53'!octreeSieve: octree	| bs |	bs _ self boundSphere.	bs ifNotNil:[ 				bs transform: self globalTransform.		octree add: bs. 		].	frameChildren ifNotNil:[		frameChildren do:[ :fc | 	fc octreeSieve: octree. ].		].! !!TFrame methodsFor: 'accessing' stamp: 'das 3/9/2004 15:22'!parentChanged	self parentChanged: self.! !!TFrame methodsFor: 'accessing' stamp: 'das 3/9/2004 15:22'!parentChanged: frame	" Does nothing, just forward on to children."	frameChildren ifNotNil:[frameChildren do:[:fc | fc parentChanged: frame].].! !!TFrame methodsFor: 'accessing' stamp: 'ar 9/7/2002 19:16'!scriptIcon	^self class scriptIcon! !!TFrame methodsFor: 'accessing' stamp: 'das 3/9/2004 15:29'!selected: fc"Inform the parent frame that this frame has been selected"	frameParent selected: fc.! !!TFrame methodsFor: 'accessing'!showFrame" TFrame >> showFrame recursively climbs the frame's tree and outputs it the Transcript."	self showFrame: 0.! !!TFrame methodsFor: 'accessing'!showFrame: depth	1 to: depth do:[ :i | Transcript show:'---|'].	Transcript show: self objectName; cr.	self frameChildren ifNotNil:[		frameChildren do:[ : fc |			fc showFrame: depth+1.].].! !!TFrame methodsFor: 'accessing' stamp: 'das 5/1/2002 22:03'!solid	^ solid.! !!TFrame methodsFor: 'accessing' stamp: 'das 12/29/2003 17:14'!solid: bool	solid _ bool.! !!TFrame methodsFor: 'accessing' stamp: 'das 12/27/2002 17:52'!solidTree: bool	self do:[ :f | f solid: bool].! !!TFrame methodsFor: 'accessing' stamp: 'das 12/3/2002 13:53'!solidVisibleTree: bool	self solidTree: bool.	self visibleTree: bool.! !!TFrame methodsFor: 'accessing' stamp: 'das 9/13/2002 02:59'!sphereTree	| bs |		bs _ self boundSphere.	bs ifNotNil:[		frameChildren ifNotNil:[ frameChildren do:[ :fc | bs _ bs union: (fc sphereTree).].].		^ bs.		].	frameChildren ifNotNil:[		frameChildren do:[ :fc |			bs ifNil:[ bs _ fc sphereTree. ] 				ifNotNil: [bs _ bs union: (fc sphereTree). ].		].	^ bs.	].	^ nil.! !!TFrame methodsFor: 'accessing' stamp: 'das 7/10/2002 23:37'!test	^ test.! !!TFrame methodsFor: 'accessing' stamp: 'das 7/10/2002 23:36'!test: tst	test _ tst.! !!TFrame methodsFor: 'accessing' stamp: 'das 12/20/2002 13:36'!transparency: trans		frameChildren ifNotNil:[		frameChildren do:[ :fc | fc transparency: trans].].! !!TFrame methodsFor: 'accessing'!visible	^ visible.! !!TFrame methodsFor: 'accessing'!visible: bool	visible _ bool.! !!TFrame methodsFor: 'accessing' stamp: 'das 10/7/2002 23:05'!visibleTree	self visible ifTrue:[^ true].	frameChildren ifNotNil:[		frameChildren do:[ :fc | fc visibleTree ifTrue:[^ true].].].	^ false.! !!TFrame methodsFor: 'accessing' stamp: 'das 12/27/2002 17:50'!visibleTree: bool	self do:[ :f | f visible: bool].! !!TFrame methodsFor: 'copying' stamp: 'ar 10/2/2004 20:06'!postCopy		super postCopy.	localTransform _ localTransform copy.	" Only make copies ofthe frame heirarchy. Everything else stays as-is."	frameChildren ifNotNil:[		frameChildren := frameChildren collect:[:fc|			fc isTexture ifTrue:[fc] ifFalse: [fc copy]		].	].	^self! !!TFrame methodsFor: 'stepping' stamp: 'ar 10/4/2004 13:21'!doStep	"stop stepping when requested"	| tt |	stepsOn ifFalse: [ stepperActive _ false. ^self ].	self wantsSteps ifTrue: [		tt _ TeaTime now.		self stepAt: tt.		lastStepTime _ tt.		self future: self stepTime perform: #doStep.	].! !!TFrame methodsFor: 'stepping'!lastStepTime	^ lastStepTime.! !!TFrame methodsFor: 'stepping'!lastStepTime: lst	lastStepTime _ lst.! !!TFrame methodsFor: 'stepping' stamp: 'ar 10/4/2004 13:46'!startStepping	stepsOn _ true.	stepperActive ifFalse: [		stepperActive _ true.		lastStepTime _ TeaTime now.		self future: self stepTime perform: #doStep.	].! !!TFrame methodsFor: 'stepping' stamp: 'das 6/16/2002 09:46'!step	"If you want to recieve the current time in miliseconds, override #stepAt:."! !!TFrame methodsFor: 'stepping'!stepAt: msecs	^self step! !!TFrame methodsFor: 'stepping' stamp: 'ar 9/30/2004 14:52'!stepTime	"adjust step time if we are more than 2 seconds behind"	^ stepTime.! !!TFrame methodsFor: 'stepping' stamp: 'DPR 5/12/2004 13:33'!stepTime: aNumber	stepTime _ aNumber asFloat.! !!TFrame methodsFor: 'stepping' stamp: 'DPR 2/18/2004 16:22'!stopStepping	stepsOn _ false. "request stepper to stop"	"when actually stopped, sets stepperActive to false"! !!TFrame methodsFor: 'stepping'!wantsSteps	" This needs to be overridden by the component if we want to step."	^ false.! !!TFrame methodsFor: 'yellow-scripts' stamp: 'ar 7/21/2002 18:48'!forwardBy: aDistance duration: aDuration style: aStyle rate: aSamplingRate	^self move: #forward distance: aDistance duration: aDuration style: aStyle rate: aSamplingRate! !!TFrame methodsFor: 'yellow-scripts' stamp: 'ar 9/30/2004 14:50'!moveBy: aDirection duration: aDuration style: aStyle rate: aSamplingRate	| direction duration style rate endState styleFunc lastState startState deltaTime msecsDuration proportion newState startT progressT script |	direction _ aDirection ifNil:[self defaultDirection asMoveDirection * self defaultDistance].	duration _ aDuration ifNil:[self defaultDuration].	style _ aStyle ifNil:[self defaultInterpolationStyle].	rate _ aSamplingRate ifNil:[self defaultSamplingRate].	"Get the ultimate state we're interested in"	endState := direction.	duration <= 0 ifTrue:[^self transformBy: (B3DMatrix4x4 withOffset: endState)].	"Compute msecs since that's what we'll be working on here"	msecsDuration := duration * 1000.	"Get the interpolation function (evaluating from 0-1 and returning values from 0-1)"	styleFunc := style asScriptStyle.	"Reset the interpolation state"	lastState := startState := 0@0@0.	"And go moving until we're out of time"	rate _ msecsDuration * rate // 1000.	deltaTime _ msecsDuration // rate.	startT _ TeaTime now.	script := Processor activeProcess.	1 to: rate do:[:i|		progressT _ (i*deltaTime) asFloat.		(startT + progressT) waitUntil. "<-- here is where tea scheduling kicks in"		"Compute the proportion of time that's over"		proportion := progressT / msecsDuration asFloat.		"Map it through the interpolation style"		proportion := styleFunc value: proportion.		"Compute the state (e.g., offset) at our new proportion"		newState := startState interpolateTo: endState at: proportion.		"Transform incrementally - this is so that we can superimpose animations."		self transformBy: (B3DMatrix4x4 withOffset: newState - lastState).		"Remember last state for the next round"		lastState := newState.		"see if a stop was requested"		script isStopRequested ifTrue:[^self].	].	(startT + msecsDuration) waitUntil. "<-- here is where tea scheduling kicks in"	"Apply the remaining part of the transform (if any)"	self transformBy: (B3DMatrix4x4 withOffset: endState - lastState).! !!TFrame methodsFor: 'yellow-scripts' stamp: 'ar 10/12/2002 18:20'!moveTo: aTarget duration: aDuration style: aStyle rate: aSamplingRate	| target targetDir length |	target _ aTarget ifNil:[^self].	targetDir := self globalToLocal: target globalPosition.	targetDir y: 0.0.	length := targetDir length.	targetDir := targetDir / length.	^self move: targetDir distance: length duration: aDuration style: aStyle rate: aSamplingRate! !!TFrame methodsFor: 'yellow-scripts' stamp: 'ar 7/21/2002 19:34'!rollBy: turns duration: duration style: style rate: samplingRate	^self turn: #ccw turns: turns duration: duration style: style rate: samplingRate! !!TFrame methodsFor: 'events' stamp: 'das 3/9/2004 13:25'!collidesInto: aFrame	"Answer whether I collide into the given frame"	| mySphere itsSphere |	mySphere := self compositeBoundSphere ifNil:[^false].	itsSphere := aFrame compositeBoundSphere ifNil:[^false].	^mySphere collideSphere: itsSphere! !!TFrame methodsFor: 'events' stamp: 'das 5/21/2002 08:37'!event2D: event2D! !!TFrame methodsFor: 'events' stamp: 'das 5/21/2002 08:38'!handlesEvent2D	^ false.! !!TFrame methodsFor: 'events'!handlesKeyboard: pointer"Do I want to receive the keyboard events -  keyDown, keyUp?  The default response is false." ^ false.! !!TFrame methodsFor: 'events' stamp: 'ar 9/8/2002 15:28'!handlesPointerDown: pointer	"Do I want to receive pointerDown events (pointerDown:, pointerMove:, pointerUp:)?"	^self handlesAnyOf: #(pointerDown pointerMove pointerUp).! !!TFrame methodsFor: 'events' stamp: 'ar 9/8/2002 15:28'!handlesPointerOver: pointer	"Do I want to receive the pointerOver events - pointerEnter:, pointerLeave:, and pointerOver: when the button is up and the hand is empty?  The default response is false." 	^self handlesAnyOf: #(pointerEnter pointerOver pointerLeave)! !!TFrame methodsFor: 'events' stamp: 'ar 9/8/2002 15:29'!keyDown: pointer	(self handlesEvent: #keyDown) ifFalse:[^false].	^self signal: #keyDown with: pointer! !!TFrame methodsFor: 'events' stamp: 'DPR 7/5/2004 19:58'!keyStroke: pointer	(self handlesEvent: #keyStroke) ifFalse:[^false].	^self signal: #keyStroke with: pointer! !!TFrame methodsFor: 'events' stamp: 'ar 9/8/2002 15:29'!keyUp: pointer	(self handlesEvent: #keyUp) ifFalse:[^false].	^self signal: #keyUp with: pointer! !!TFrame methodsFor: 'events' stamp: 'ar 9/8/2002 15:29'!pointerDown: pointer	self signal: #pointerDown with: pointer.! !!TFrame methodsFor: 'events' stamp: 'ar 9/8/2002 15:29'!pointerEnter: pointer	self signal: #pointerEnter with: pointer.! !!TFrame methodsFor: 'events' stamp: 'ar 9/8/2002 15:30'!pointerLeave: pointer	self signal: #pointerLeave with: pointer.! !!TFrame methodsFor: 'events' stamp: 'ar 9/8/2002 15:30'!pointerMove: pointer 	self signal: #pointerMove with: pointer.! !!TFrame methodsFor: 'events' stamp: 'ar 9/8/2002 15:30'!pointerOver: pointer	self signal: #pointerOver with: pointer.! !!TFrame methodsFor: 'events' stamp: 'ar 9/8/2002 15:30'!pointerUp: pointer 	self signal: #pointerUp with: pointer.! !!TFrame methodsFor: 'events' stamp: 'ar 6/6/2002 20:17'!wantsBlueButton	^false! !!TFrame methodsFor: 'initialize' stamp: 'das 8/15/2002 13:43'!initBounds	frameChildren ifNotNil:[		frameChildren do:[:fc | fc initBounds].].! !!TFrame methodsFor: 'initialize' stamp: 'ar 10/2/2004 08:06'!initialize	super initialize.	frameChanged _ true. 	localTransform _ B3DMatrix4x4 identity.	globalTransform _ nil.	frameChildren _ nil.	self solid: true.	singleParent _ false.	self visible: true.	self objectOwner: self.	stepsOn _ false.	stepperActive _ false.	stepTime _ 80.0.	test _ 0.	^self! !!TFrame methodsFor: 'testing' stamp: 'das 6/3/2002 12:49'!isBrowser	^ false.! !!TFrame methodsFor: 'testing'!isCamera	^ false.! !!TFrame methodsFor: 'testing' stamp: 'ar 9/8/2002 17:16'!isComponent	"^ false."	^myEventMap notNil.! !!TFrame methodsFor: 'testing' stamp: 'das 10/16/2002 00:12'!isFrame	^ true.! !!TFrame methodsFor: 'testing' stamp: 'das 4/10/2003 23:12'!isGroup	^ false.! !!TFrame methodsFor: 'testing'!isLight	^ false.! !!TFrame methodsFor: 'testing' stamp: 'das 4/10/2003 23:15'!isMesh	^ false.! !!TFrame methodsFor: 'testing'!isPortal	^ false.! !!TFrame methodsFor: 'testing' stamp: 'das 11/9/2002 15:03'!isRay	^ false.! !!TFrame methodsFor: 'testing' stamp: 'das 5/14/2002 10:40'!isRigidBody	^ false.! !!TFrame methodsFor: 'testing' stamp: 'das 5/1/2002 22:04'!isSolid	^ solid! !!TFrame methodsFor: 'testing' stamp: 'das 6/3/2003 21:49'!isSpace	^ false.! !!TFrame methodsFor: 'testing' stamp: 'das 7/8/2002 15:43'!isTexture	^ false.! !!TFrame methodsFor: 'testing' stamp: 'das 7/15/2002 20:45'!isWindow	^ false.! !!TFrame methodsFor: 'toys' stamp: 'das 9/1/2003 16:01'!jump: dist	self translation: self translation + (B3DVector3 x: 0 y: dist z: 0).! !!TFrame methodsFor: 'toys' stamp: 'ar 10/8/2002 12:17'!makeThumbnail	"Create a thumbnail of this object only"	^self makeThumbnail: 128@96! !!TFrame methodsFor: 'toys' stamp: 'ar 9/30/2004 19:27'!makeThumbnail: extent	"Create a thumbnail of this object only"	| space lt |true ifTrue:[^Form extent: extent depth: 32].	space _ TSpace new."we need *some* space here"	lt _ TLight new.	lt ambientColor: #(1 1 1 1) asFloatArray.	lt diffuseColor: #(1 1 1 1) asFloatArray.	lt specularColor: #(0.2 0.15 0.15 1.0) asFloatArray.	lt visible: false.	lt addRotationAroundZ: 120.	lt addRotationAroundY:-10.	space addChild: lt.		^space makeThumbnailOf: self extent: extent! !!TFrame methodsFor: 'toys' stamp: 'ar 10/8/2002 12:31'!makeThumbnailWithName	"Create a thumbnail of this object only"	^self makeThumbnailWithName: 128@96! !!TFrame methodsFor: 'toys' stamp: 'das 12/20/2003 11:00'!makeThumbnailWithName: extent	"Create a thumbnail of this object only"	| aForm nameString font nameForm box rectForName aCanvas |	aForm := self makeThumbnail: extent.	nameString := objectName ifNil:['???'].	font _ TextStyle defaultFont emphasized: 1.	nameForm _ (StringMorph contents: nameString font: font) imageForm.	nameForm _ nameForm scaledToSize: (aForm extent - (4@2) min: nameForm extent).	box _ aForm boundingBox.	rectForName _ box bottomLeft + 			(box width - nameForm width // 2 @ (nameForm height + 2) negated)				extent: nameForm extent.	aCanvas _ aForm getCanvas.	rectForName topLeft eightNeighbors do: [ :pt |		aCanvas			stencil: nameForm 			at: pt			color: Color white.	].	aCanvas		stencil: nameForm 		at: rectForName topLeft 		color: Color black.	^aForm! !!TFrame methodsFor: 'render' stamp: 'das 3/12/2004 13:36'!makeThumb: ogl	| rect thumb vis|	vis _ self visible.	self visible: false."avoid recursion."	rect _(0@0 corner: 128@96).	ogl renderWait:[thumb _ self root snapShot: ogl rectangle: rect atLoc: self globalTransform view: 45.0.].	self visible: vis.	^ thumb.! !!TFrame methodsFor: 'render'!pick: pointer^ false! !!TFrame methodsFor: 'render' stamp: 'das 6/29/2002 13:12'!pickFloor: pointer^ self pick: pointer.! !!TFrame methodsFor: 'render' stamp: 'das 3/12/2004 13:36'!render: ogl	ogl glDisable: GLLighting;	" This is used to render solid objects (if any). "		glColor3fv: #(1.0 0 0)asFloatArray;		glBegin: GLLineStrip;    			glVertex3fv:#(0.0 0.0 0.0)asFloatArray;    			glVertex3fv:#(1.0 0.0 0.0)asFloatArray;    				glVertex3fv:#(0.75 0.25 0.0)asFloatArray;    			glVertex3fv:#(0.75 -0.25 0.0)asFloatArray;    			glVertex3fv:#(1.0 0.0 0.0)asFloatArray;    			glVertex3fv:#(0.75 0.0 0.25)asFloatArray;    			glVertex3fv:#(0.75 0.0 -0.25)asFloatArray;    			glVertex3fv:#(1.0 0.0 0.0)asFloatArray;    		glEnd;    		glColor3fv: #(0.0 1.0 0)asFloatArray;		glBegin: GLLineStrip;    			glVertex3fv:#(0.0 0.0 0.0)asFloatArray;    			glVertex3fv:#(0.0 1.0 0.0)asFloatArray;    			glVertex3fv:#(0.0 0.75 0.25)asFloatArray;    			glVertex3fv:#(0.0 0.75 -0.25)asFloatArray;    			glVertex3fv:#(0.0 1.0 0.0)asFloatArray;    			glVertex3fv:#(0.25 0.75 0.0)asFloatArray;    			glVertex3fv:#(-0.25 0.75 0.0)asFloatArray;    			glVertex3fv:#(0.0 1.0 0.0)asFloatArray;    		glEnd;    		glColor3fv: #(0.0 0.0 1.0)asFloatArray;		glBegin: GLLineStrip;    			glVertex3fv:#(0.0 0.0 0.0)asFloatArray;    			glVertex3fv:#(0.0 0.0 1.0)asFloatArray;    			glVertex3fv:#(0.25 0.0 0.75)asFloatArray;   			glVertex3fv:#(-0.25 0.0 0.75)asFloatArray;    			glVertex3fv:#(0.0 0.0 1.0)asFloatArray;    			glVertex3fv:#(0.0 0.25 0.75)asFloatArray;    			glVertex3fv:#(0.0 -0.25 0.75)asFloatArray;    			glVertex3fv:#(0.0 0.0 1.0)asFloatArray;    		glEnd;	glEnable: GLLighting.! !!TFrame methodsFor: 'render' stamp: 'das 3/12/2004 13:36'!render: ogl box: box	|  |	self render: ogl cube: box location: box center scale: 1.0.! !!TFrame methodsFor: 'render' stamp: 'das 3/12/2004 13:37'!render: ogl cube: cube location: loc scale: scale	| dx dy dz x y z |" This message is used only to make sure a frame is actually drawing something. In this case, I draw a cube. "	dx _ scale/2.0.	dy _ scale/2.0.	dz _ scale/2.0.	x _ loc x.	y _ loc y.	z _ loc z.	ogl glBegin: GLQuads;			glNormal3f: 0.0 with: 0.0 with: 1.0;			glTexCoord2f:0.0 with:1.0;	glVertex3f: x+(dx negated) with: y+(dy negated) with: z+dz;			glTexCoord2f:1.0 with:1.0;	glVertex3f: x+dx with: y+(dy negated) with: z+dz;			glTexCoord2f:1.0 with:0.0;	glVertex3f: x+dx with: y+dy with: z+dz;			glTexCoord2f:0.0 with: 0.0;	glVertex3f: x+(dx negated) with: y+dy with: z+dz.		dz _ dz negated.		ogl glNormal3f: 0.0 with: 0.0 with: -1.0;			glTexCoord2f:1.0 with: 0.0;	glVertex3f: x+(dx negated) with: y+dy with: z+dz;			glTexCoord2f:0.0 with:0.0;	glVertex3f: x+dx with: y+dy with: z+dz;			glTexCoord2f:0.0 with:1.0;	glVertex3f: x+dx with: y+(dy negated) with: z+dz;			glTexCoord2f:1.0 with:1.0;	glVertex3f: x+(dx negated) with: y+(dy negated) with: z+dz.		dz _ dz negated.		ogl glNormal3f: 1.0 with: 0.0 with: 0.0;			glTexCoord2f:0.0 with:1.0;	glVertex3f: x+dx with: y+(dy negated) with: z+dz;			glTexCoord2f:1.0 with:1.0;	glVertex3f: x+dx with: y+(dy negated) with: z+(dz negated);			glTexCoord2f:1.0 with: 0.0;	glVertex3f: x+dx with: y+dy with: z+(dz negated);			glTexCoord2f:0.0 with: 0.0;	glVertex3f: x+dx with: y+dy with: z+dz.		dx _ dx negated.			ogl glNormal3f: -1.0 with: 0.0 with: 0.0;			glTexCoord2f:1.0 with: 0.0;	glVertex3f: x+dx with: y+dy with: z+dz;			glTexCoord2f:0.0 with:0.0;	glVertex3f: x+dx with: y+dy with: z+(dz negated);			glTexCoord2f:0.0 with:1.0;	glVertex3f: x+dx with: y+(dy negated) with: z+(dz negated);			glTexCoord2f:1.0 with:1.0;	glVertex3f: x+dx with: y+(dy negated) with: z+dz.		dx _ dx negated.		ogl glNormal3f: 0.0 with: 1.0 with: 0.0;			glTexCoord2f:1.0 with: 0.0;	glVertex3f: x+dx with: y+dy with: z+dz;			glTexCoord2f:0.0 with:0.0;	glVertex3f: x+dx with: y+dy with: z+(dz negated);			glTexCoord2f:0.0 with:1.0;	glVertex3f: x+(dx negated) with: y+dy with: z+(dz negated);			glTexCoord2f:1.0 with:1.0;	glVertex3f: x+(dx negated) with: y+dy with: z+dz.		dy _ dy negated.		ogl	glNormal3f: 0.0 with: -1.0 with: 0.0;			glTexCoord2f:0.0 with:1.0;	glVertex3f: x+(dx negated) with: y+dy with: z+dz;			glTexCoord2f:1.0 with:1.0;	glVertex3f: x+(dx negated) with: y+dy with: z+(dz negated);			glTexCoord2f:1.0 with:0.0;	glVertex3f: x+dx with: y+dy with: z+(dz negated);			glTexCoord2f:0.0 with: 0.0;	glVertex3f: x+dx with: y+dy with: z+dz.	ogl glEnd.! !!TFrame methodsFor: 'render' stamp: 'das 3/12/2004 13:37'!render: ogl cube: box scale: scale	self renderCube: ogl location: 0.0@0.0@0.0 scale: scale.! !!TFrame methodsFor: 'render' stamp: 'das 3/12/2004 13:37'!render: ogl sphere: bndSphr segments: segments	| position radius ringSin ringCos pi2 seg2 vert rts rbs rtc rbc ax u du v dv |	position _ bndSphr localPosition.	radius _ bndSphr radius.	seg2 _ 1+ (segments * 2) .	ringSin _ FloatArray ofSize: seg2.	ringCos _ FloatArray ofSize: seg2.	vert _ B3DVector3 new.	pi2 _ Float pi *2.0.	1 to: seg2-1 do:[ :index | 		ax _ ((index) * pi2)/ (seg2-1).		ringSin at:index put: ax sin.		ringCos at:index put: ax cos.].	ringSin at: seg2 put: (ringSin at: 1).	ringCos at: seg2 put: (ringCos at: 1).	rts _ 0.0.	rtc _ 1.0.	rbs _ringSin at: 1.	rbc _ ringCos at: 1.	du _ 1.0/(seg2-1).	v _ 0.0.	dv _ 1.0/segments.	1 to: segments do:[ :iv |		ogl glBegin: GLTriangleStrip.		u _ 0.0.		1 to: seg2 do: [ :ih | 			vert x: rts*(ringSin at: ih) y: rtc z: rts*(ringCos at: ih).			ogl glNormal3fv: vert;				glTexCoord2f: u with: v;				glVertex3fv:  (vert * radius)+ position.			vert x: rbs*(ringSin at: ih) y: rbc z: rbs*(ringCos at: ih).			ogl glNormal3fv: vert;				glTexCoord2f: u with: v+dv;				glVertex3fv:  (vert * radius)+ position.			u_ u+du.].		v _ v+dv.		rts _ rbs.		rtc _ rbc.		rbs _ ringSin at: iv+1.		rbc _ ringCos at: iv+1.		ogl glEnd.].! !!TFrame methodsFor: 'render' stamp: 'das 3/12/2004 13:37'!renderAlpha: ogl	"This is used to render transparent ( alpha blended ) objects."! !!TFrame methodsFor: 'render' stamp: 'das 3/12/2004 13:37'!renderCube: ogl location: loc scale: scale	| dx dy dz x y z |" This message is used only to make sure a frame is actually drawing something. In this case, I draw a cube. "	dx _ scale/2.0.	dy _ scale/2.0.	dz _ scale/2.0.	x _ loc x.	y _ loc y.	z _ loc z.	ogl glBegin: GLQuads;			glNormal3f: 0.0 with: 0.0 with: 1.0;			glTexCoord2f:0.0 with:1.0;	glVertex3f: x+(dx negated) with: y+(dy negated) with: z+dz;			glTexCoord2f:1.0 with:1.0;	glVertex3f: x+dx with: y+(dy negated) with: z+dz;			glTexCoord2f:1.0 with:0.0;	glVertex3f: x+dx with: y+dy with: z+dz;			glTexCoord2f:0.0 with: 0.0;	glVertex3f: x+(dx negated) with: y+dy with: z+dz.		dz _ dz negated.		ogl glNormal3f: 0.0 with: 0.0 with: -1.0;			glTexCoord2f:1.0 with: 0.0;	glVertex3f: x+(dx negated) with: y+dy with: z+dz;			glTexCoord2f:0.0 with:0.0;	glVertex3f: x+dx with: y+dy with: z+dz;			glTexCoord2f:0.0 with:1.0;	glVertex3f: x+dx with: y+(dy negated) with: z+dz;			glTexCoord2f:1.0 with:1.0;	glVertex3f: x+(dx negated) with: y+(dy negated) with: z+dz.		dz _ dz negated.		ogl glNormal3f: 1.0 with: 0.0 with: 0.0;			glTexCoord2f:0.0 with:1.0;	glVertex3f: x+dx with: y+(dy negated) with: z+dz;			glTexCoord2f:1.0 with:1.0;	glVertex3f: x+dx with: y+(dy negated) with: z+(dz negated);			glTexCoord2f:1.0 with: 0.0;	glVertex3f: x+dx with: y+dy with: z+(dz negated);			glTexCoord2f:0.0 with: 0.0;	glVertex3f: x+dx with: y+dy with: z+dz.		dx _ dx negated.			ogl glNormal3f: -1.0 with: 0.0 with: 0.0;			glTexCoord2f:1.0 with: 0.0;	glVertex3f: x+dx with: y+dy with: z+dz;			glTexCoord2f:0.0 with:0.0;	glVertex3f: x+dx with: y+dy with: z+(dz negated);			glTexCoord2f:0.0 with:1.0;	glVertex3f: x+dx with: y+(dy negated) with: z+(dz negated);			glTexCoord2f:1.0 with:1.0;	glVertex3f: x+dx with: y+(dy negated) with: z+dz.		dx _ dx negated.		ogl glNormal3f: 0.0 with: 1.0 with: 0.0;			glTexCoord2f:1.0 with: 0.0;	glVertex3f: x+dx with: y+dy with: z+dz;			glTexCoord2f:0.0 with:0.0;	glVertex3f: x+dx with: y+dy with: z+(dz negated);			glTexCoord2f:0.0 with:1.0;	glVertex3f: x+(dx negated) with: y+dy with: z+(dz negated);			glTexCoord2f:1.0 with:1.0;	glVertex3f: x+(dx negated) with: y+dy with: z+dz.		dy _ dy negated.		ogl	glNormal3f: 0.0 with: -1.0 with: 0.0;			glTexCoord2f:0.0 with:1.0;	glVertex3f: x+(dx negated) with: y+dy with: z+dz;			glTexCoord2f:1.0 with:1.0;	glVertex3f: x+(dx negated) with: y+dy with: z+(dz negated);			glTexCoord2f:1.0 with:0.0;	glVertex3f: x+dx with: y+dy with: z+(dz negated);			glTexCoord2f:0.0 with: 0.0;	glVertex3f: x+dx with: y+dy with: z+dz.	ogl glEnd.! !!TFrame methodsFor: 'render' stamp: 'das 3/12/2004 13:37'!renderCube: ogl scale: scale	self renderCube: ogl location: 0.0@0.0@0.0 scale: scale.! !!TFrame methodsFor: 'render' stamp: 'das 10/3/2004 17:01'!renderFrame: ogl parent: parent root: root	| count childCount globalTrans ac |" I am running a parallel set of transforms here. Why? Because I am told the OGL is inefficient at reading the current transform. Easy to change."" Any given frame can have multiple parents. This means that the frame can't keep a static reference to the parent frame. This must be dynamic, essentially filled out at render time. This allows for pure -instancing- of frame objects. That is, the same frame and all of its contents can easily be in multiple locations in the render tree without significant additional bookkeeping. It also means that when an object DOES need to refer to its parent or the space frame (read -root- for traditional approaches), this can ONLY be done at render-time via this mechanism. It also means that a child really must not modify the parent directly, as the parent has other responsibilities."" #renderFrame: must return the number of objects that were rendered - failure to do so will just crash."	count _ 0.	(visible or:[frameChildren notNil])ifFalse:[^ 0 ].		self parent ~= parent ifTrue:[ self isSpace ifFalse:[self frameChanged. ]].	self currentParent: parent.	" apply the local transform to this matrix "	frameChanged ifTrue:[		self globalTransform: (parent globalTransform composeWith: localTransform).].	ogl glPushMatrix. 	ogl glMultMatrixf: localTransform transposed. 	self boundSphere ifNotNil:[		self boundSphere transform: globalTransform.		solid ifTrue:[ root testRayFrames: self boundSphere.].	]."------ is this inside the viewing pyramid?"	ac _ ogl camera.	(visible and:[ac testBounds: self boundSphere]) ifTrue:[ 		ac pointer ifNotNil:[			ac inPortal ifTrue:[				(ac pointer pointerPick: self boundSphere).				]			ifFalse:[				self isPortal ifFalse:[					(ac pointer pointerPick: self boundSphere).					"(ac downPointer pick: self boundSphere)."					].				].			].		timeStamp _ ogl timeStamp.		count _ 1.		self render: ogl.			self hasAlpha ifTrue: [ 			globalTrans _ B3DMatrix4x4 new.			ogl glGetFloatv: GLModelviewMatrix with: globalTrans.			root addAlphaObject: self 				transform: globalTrans				distance: ((ac globalPosition - globalPosition ) squaredLength * CroquetGlobals frameScaleSquared)				parent: parent.].].	frameChildren ifNotNil:[		" render all of the child frames "		childCount _ 0.		frameChildren do:[:rFrame | childCount _ childCount+(rFrame renderFrame: ogl parent: self root: root).].		childCount > 0 ifTrue:[count _ count+childCount. timeStamp _ ogl timeStamp.]		].	ogl glPopMatrix.	^ count.! !!TFrame methodsFor: 'render' stamp: 'ar 9/30/2004 16:54'!renderFrame: ogl space: space	| saveParent saveTransform count childCount globalTrans ac |" I am running a parallel set of transforms here. Why? Because I am told the OGL is inefficient at reading the current transform. Easy to change."Transcript show:'TFrame>>#renderFrame:space: is deprecated.';cr." Any given frame can have multiple parents. This means that the frame can't keep a static reference to the parent frame. This must be dynamic, essentially filled out at render time. This allows for pure -instancing- of frame objects. That is, the same frame and all of its contents can easily be in multiple locations in the render tree without significant additional bookkeeping. It also means that when an object DOES need to refer to its parent or the space frame (read -root- for traditional approaches), this can ONLY be done at render-time via this mechanism. It also means that a child really must not modify the parent directly, as the parent has other responsibilities."" #renderFrame: must return the number of objects that were rendered - failure to do so will just crash."	count _ 0.	(visible or:[frameChildren notNil])ifFalse:[^ 0 ].	saveParent _ space currentParent.	self parent ~= saveParent ifTrue:[ self isSpace ifFalse:[self frameChanged. ]].	self currentParent: saveParent.	space currentParent: self. 	" apply the local transform to this matrix "	saveTransform _ space currentTransform.	saveTransform ifNotNil: [		space currentTransform: (saveTransform composeWith: localTransform).]		ifNil:[space currentTransform: localTransform. ].			ogl glPushMatrix. 	ogl glMultMatrixf: localTransform transposed. 	self boundSphere ifNotNil:[		self boundSphere transform: space currentTransform.		solid ifTrue:[ space testRayFrames: self boundSphere.].	]."------ is this inside the viewing pyramid?"	ac _ ogl camera.	(visible and:[ac testBounds: self boundSphere]) ifTrue:[ 		ac pointer ifNotNil:[			ac inPortal ifTrue:[				(ac pointer pointerPick: self boundSphere)				]			ifFalse:[				self isPortal ifFalse:[					(ac pointer pointerPick: self boundSphere)					].				].			].		timeStamp _ ogl timeStamp.		count _ 1.		self render: ogl.			self hasAlpha ifTrue: [ 			globalTrans _ B3DMatrix4x4 new.			ogl glGetFloatv: GLModelviewMatrix with: globalTrans.			space addAlphaObject: self 				transform: globalTrans "space currentTransform clone"				distance: ((ac globalPosition - space currentTranslation ) squaredLength * CroquetGlobals frameScaleSquared)				parent: space currentParent.].].	frameChildren ifNotNil:[		" render all of the child frames "		childCount _ 0.		frameChildren do:[:rFrame | childCount _ childCount+(rFrame renderFrame: ogl space: space).].		childCount > 0 ifTrue:[count _ count+childCount. timeStamp _ ogl timeStamp.]		].	ogl glPopMatrix.	space currentTransform: saveTransform.	space currentParent: saveParent.	^ count.! !!TFrame methodsFor: 'voice chat' stamp: 'das 4/11/2003 12:05'!playSoundBuffer: soundBuffer at: deltaMSecs stereo: stereoFlag samplingRate: samplingRate codec: codec	"Queue in the given sound buffer at deltaMSecs from the start of the sound."	self streamingSound addSoundBuffer: soundBuffer at: deltaMSecs stereo: stereoFlag samplingRate: samplingRate codec: codec.! !!TFrame methodsFor: 'voice chat' stamp: 'das 4/11/2003 15:46'!streamingSound	^streamingSound ifNil:[streamingSound := TSampledSound new play ]! !!TFrame methodsFor: 'voice chat' stamp: 'ar 6/12/2002 19:53'!streamingSound: aSound	streamingSound := aSound.! !!TBody methodsFor: 'accessing' stamp: 'das 11/17/2003 20:58'!addAttractor: attr	attractors add: attr.! !!TBody methodsFor: 'accessing' stamp: 'das 11/18/2003 11:26'!isOn	^ start! !!TBody methodsFor: 'accessing' stamp: 'das 11/19/2003 14:48'!reset	self stop.	self start.! !!TBody methodsFor: 'accessing' stamp: 'das 11/18/2003 12:53'!speed: sp	speed _ sp.! !!TBody methodsFor: 'accessing' stamp: 'das 11/18/2003 11:28'!start	start ifTrue:[^ self].	self root addChild: tracer. 	start _ true.! !!TBody methodsFor: 'accessing' stamp: 'das 11/19/2003 14:47'!stop	start ifFalse:[^ self].	tracer reset.	self root removeChild: tracer. 	start _ false.	stepRemainder _ 0.! !!TBody methodsFor: 'accessing' stamp: 'das 12/15/2003 14:34'!velocity	^ velocity.! !!TBody methodsFor: 'accessing' stamp: 'das 11/17/2003 22:51'!velocity: v	velocity _ v.! !!TBody methodsFor: 'stepping' stamp: 'das 12/15/2003 14:30'!doStep	|  secs delta |	start ifFalse:[^ self].	secs _ 0.05.	attractors do:[ :attr |		delta _ attr globalPosition - self globalPosition.		velocity _ velocity + 			(delta normalized *  (secs * (attr mass/100.0) /  (delta dot: delta))).	].	self translation: self translation + (secs * velocity).	tracer addPath: self  globalPosition.! !!TBody methodsFor: 'stepping' stamp: 'DPR 5/12/2004 13:43'!runStep	|  secs delta |	start ifFalse:[^ self].	secs _ 0.05.	attractors do:[ :attr |		delta _ attr globalPosition - self globalPosition.		velocity _ velocity + 			(delta normalized *  (secs * (attr mass/100.0) /  (delta dot: delta))).	].	self translation: self translation + (secs * velocity).	tracer addPath: self  globalPosition.! !!TBody methodsFor: 'stepping' stamp: 'das 11/18/2003 12:53'!stepAt: currentTime	|  msecs count secs delta |	start ifFalse:[^ self ].	msecs _ stepRemainder + ((currentTime - self lastStepTime) asFloat * speed).	stepRemainder _ msecs \\ 50.	count _ msecs // 50.	count timesRepeat:[		secs _ 0.05.		attractors do:[ :attr |			delta _ attr globalPosition - self globalPosition.			velocity _ velocity + 				(delta normalized *  (secs * (attr mass/100.0) /  (delta dot: delta))).			self translation: self translation + (secs * velocity).			tracer addPath: self  globalPosition.		].	].! !!TBody methodsFor: 'stepping' stamp: 'das 11/17/2003 20:50'!wantsSteps	^ true.! !!TBody methodsFor: 'initialize' stamp: 'das 2/20/2004 10:34'!initialize	| txtr tframe |	super initialize.	txtr _ TTexture new initializeWithFileName: 'checker.png'.	tframe _ TSphere new.	tframe radius: 2.0.	tframe texture:txtr.	self addChild: tframe.	velocity _ 0@0@0.	tracer_ TTracer new.	start _ false.	attractors _ OrderedCollection new.	stepRemainder _ 0.	speed_ 1.0.! !!TCAD2D methodsFor: 'accessing' stamp: 'das 10/30/2003 14:16'!addPaths: pth	paths add: pth.	self addChild:pth.	currentPath _ nil.! !!TCAD2D methodsFor: 'accessing' stamp: 'das 10/30/2003 14:07'!addToPath: point	 currentPath add: point.! !!TCAD2D methodsFor: 'accessing' stamp: 'das 10/29/2003 15:03'!boundingBox	^ base  frameBox.! !!TCAD2D methodsFor: 'accessing' stamp: 'das 10/20/2003 13:01'!epsilon	^ 0.01.! !!TCAD2D methodsFor: 'accessing' stamp: 'das 10/17/2003 17:54'!extent	^ max-min.! !!TCAD2D methodsFor: 'accessing' stamp: 'das 10/17/2003 17:53'!extent: ext! !!TCAD2D methodsFor: 'accessing' stamp: 'das 10/30/2003 14:06'!makePath	currentPath _ OrderedCollection new.! !!TCAD2D methodsFor: 'accessing' stamp: 'das 10/21/2003 16:54'!max	^ max.! !!TCAD2D methodsFor: 'accessing' stamp: 'das 10/21/2003 16:54'!max: mx	max _ mx.	self update.! !!TCAD2D methodsFor: 'accessing' stamp: 'das 10/21/2003 16:54'!min	^ min.! !!TCAD2D methodsFor: 'accessing' stamp: 'das 10/21/2003 16:55'!min: mn	min _ mn.	self update.! !!TCAD2D methodsFor: 'accessing' stamp: 'das 10/24/2003 13:20'!nextPlane: np	nextPlane _ np.	self parentChanged.! !!TCAD2D methodsFor: 'accessing' stamp: 'das 10/23/2003 15:23'!paths		| rpaths |	rpaths _ OrderedCollection new.	paths do:[:p | rpaths add: p copy].	^ rpaths.! !!TCAD2D methodsFor: 'accessing' stamp: 'das 10/23/2003 15:23'!paths: pths			paths_ pths.	paths do:[:p | self addChild: p].! !!TCAD2D methodsFor: 'accessing' stamp: 'das 10/23/2003 14:32'!previousPlane: pp	previousPlane _ pp.! !!TCAD2D methodsFor: 'accessing' stamp: 'das 10/21/2003 00:07'!resolution: rval	resolution _ rval.	resInverse _ 1.0/resolution.! !!TCAD2D methodsFor: 'accessing' stamp: 'das 1/28/2004 01:25'!scale: scl	paths do:[:p | p scale: scl.].	self update.! !!TCAD2D methodsFor: 'accessing' stamp: 'das 10/19/2003 20:47'!select	selected _ true.	super selected: self.! !!TCAD2D methodsFor: 'accessing' stamp: 'das 10/19/2003 20:44'!unselect	selected _ false.! !!TCAD2D methodsFor: 'events' stamp: 'das 10/19/2003 20:49'!handlesPointerDown: pointer	^ true.! !!TCAD2D methodsFor: 'events' stamp: 'das 3/10/2004 22:06'!pointerDown: pointer	selected ifFalse:[ ^ self select.].	currentPath ifNil:[		self makePath.		self addToPath: pointer selectedPoint.		].! !!TCAD2D methodsFor: 'events' stamp: 'das 3/10/2004 22:06'!pointerMove: pointer	currentPath ifNotNil:[	(pointer frame: self pickPlane: (0@0@0) normal: (0@0@1)) ifTrue:[		((TBox min: (currentPath last - self epsilon) max: (currentPath last + self epsilon))pointInBox: pointer selectedPoint)ifFalse:[			self addToPath: pointer selectedPoint.].		].	self update. 	].! !!TCAD2D methodsFor: 'events' stamp: 'ar 10/4/2004 14:38'!pointerUp: pointer	| spline p cspline scount |	currentPath ifNotNil:[		((TBox min: (currentPath last - self epsilon) max: (currentPath last + self epsilon))pointInBox: pointer selectedPoint)ifFalse:[			currentPath add: pointer selectedPoint.].		currentPath size > 1 ifTrue:[			cspline _ TCurveFitter3 new fitPoints: currentPath error: self epsilon.			spline _ B3DVector3Array new: (cspline size * 3) + 1.			scount _ 1.			cspline do:[:cs | 				0 to: 2 do:[ :index | spline at: scount+index put: (cs at: index+1)].				scount _ scount + 3.			].			spline at: spline size put: (cspline last at:4).			p _ TPath new initializeWithSpline: spline.			self addPaths: p.			].		currentPath _ nil.		].! !!TCAD2D methodsFor: 'initialize' stamp: 'das 3/10/2004 22:05'!initialize	| txtr mat |	super initialize.	base _ TRectangle new.	base objectOwner: self.	baseBack _ TRectangle new.	baseBack objectOwner: self.	baseBack flip: true.	txtr _ TTexture new				initializeWithFileName: 'box.png'				mipmap: true				shrinkFit: false.	mat _ TMaterial new.	mat ambientColor: #(0.5 0.7 0.7 0.1) asFloatArray.	mat diffuseColor: #(0.5 0.7 0.7 0.1) asFloatArray.	mat cullFace: false.	mat texture: txtr.	base material: mat.	baseBack material: mat.	self addChild: base.	self addChild: baseBack.	min _ -2@-2@0.	max _ 2@2@0.	matBlue _ TMaterial new.	matRed _ TMaterial new.	matRed color: #(1 0.4 0.3 0.6)asFloatArray.	selected _ true.	paths _ OrderedCollection new.	self resolution: 4.	self update.! !!TCAD2D methodsFor: 'initialize' stamp: 'ar 10/1/2004 12:49'!update	| box m |	box _ TBox new.	paths do:[ :p | box _ box unionBox: p box.].	currentPath ifNotNil:[		currentPath do:[ :v | box growVertex: v]].	min _ box min.	max _ box max.	min x > -2 ifTrue:[ min x: -2.].	min y> -2 ifTrue:[ min y: -2].	min z> -2 ifTrue:[ min z: -2].	max x < 2 ifTrue:[ max x: 2].	max y < 2 ifTrue:[ max y: 2].	max z < 2 ifTrue:[ max z: 2].	m _ max x max: min x negated.	max x: m.	min x: m negated.	m _ max y max: min y negated.	max y: m.	min y: m negated.	base extent: (max-min).	base translation: (max+min)/2.0.	baseBack extent: (max-min).	baseBack translation: (max+min)/2.0.	self parent changed.! !!TCAD2D methodsFor: 'testing' stamp: 'das 10/17/2003 15:13'!hasAlpha 	^ true.! !!TCAD2D methodsFor: 'testing' stamp: 'das 10/19/2003 20:49'!isComponent	^ true.! !!TCAD2D methodsFor: 'render' stamp: 'das 7/31/2004 11:35'!render: ogl	(ogl camera globalPosition - self globalPosition) length < 4 ifTrue:[ ogl glLineWidth: 2.0. ]		ifFalse:[ ogl glLineWidth: 1.0].	ogl glDisable: GLLighting.	ogl glColor3fv: #(0 0 1.0)asFloatArray.	currentPath ifNotNil:[		ogl glBegin: GLLineStrip.		currentPath do:[ :pnt | ogl glVertex3fv:pnt. ].   		ogl glEnd.	].	ogl glEnable: GLLighting.! !!TCAD2D methodsFor: 'render' stamp: 'ar 9/30/2004 09:56'!render: ogl horizontal: delta width: lineWidth	| lineWidthN |	lineWidthN _ lineWidth negated.	ogl glBegin: GLTriangleStrip.	ogl glVertex3fv: ((max x-lineWidth)@(delta-lineWidth)@lineWidth).	ogl glVertex3fv: ((min x+lineWidth)@(delta-lineWidth)@lineWidth).	ogl glVertex3fv: ((max x-lineWidth)@(delta-lineWidth)@lineWidthN).	ogl glVertex3fv: ((min x+lineWidth)@(delta-lineWidth)@lineWidthN).	ogl glVertex3fv: ((max x-lineWidth)@(delta+lineWidth)@lineWidthN).	ogl glVertex3fv: ((min x+lineWidth)@(delta+lineWidth)@lineWidthN).	ogl glVertex3fv: ((max x-lineWidth)@(delta+lineWidth)@lineWidth).	ogl glVertex3fv: ((min x+lineWidth)@(delta+lineWidth)@lineWidth).	ogl glVertex3fv: ((max x-lineWidth)@(delta-lineWidth)@lineWidth).	ogl glVertex3fv: ((min x+lineWidth)@(delta-lineWidth)@lineWidth).	ogl glEnd.! !!TCAD2D methodsFor: 'render' stamp: 'ar 9/30/2004 09:57'!render: ogl vertical: delta width: lineWidth	| lineWidthN |	lineWidthN _ lineWidth negated.	ogl glBegin: GLTriangleStrip.	ogl glVertex3fv: ((delta-lineWidth)@(min y+lineWidth)@lineWidth).	ogl glVertex3fv: ((delta-lineWidth)@(max y-lineWidth)@lineWidth).	ogl glVertex3fv: ((delta-lineWidth)@(min y+lineWidth)@lineWidthN).	ogl glVertex3fv: ((delta-lineWidth)@(max y-lineWidth)@lineWidthN).	ogl glVertex3fv: ((delta+lineWidth)@(min y+lineWidth)@lineWidthN).	ogl glVertex3fv: ((delta+lineWidth)@(max y-lineWidth)@lineWidthN).	ogl glVertex3fv: ((delta+lineWidth)@(min y+lineWidth)@lineWidth).	ogl glVertex3fv: ((delta+lineWidth)@(max y-lineWidth)@lineWidth).	ogl glVertex3fv: ((delta-lineWidth)@(min y+lineWidth)@lineWidth).	ogl glVertex3fv: ((delta-lineWidth)@(max y-lineWidth)@lineWidth).	ogl glEnd.! !!TCAD2D methodsFor: 'render' stamp: 'ar 9/30/2004 09:58'!renderAlpha: ogl	| lineWidth delta squareSize |"Dynamic scaling removes unwanted aliasing"	lineWidth _ (ogl camera globalPosition - self globalPosition) length * 0.0015.	squareSize _ 0.5.	selected ifTrue:[	matBlue enable:ogl.	delta _ squareSize.	[delta<= max x] whileTrue:[		self render: ogl vertical: delta width: lineWidth.		self render: ogl vertical: delta negated width: lineWidth.		delta _ delta + squareSize. 	].	delta _ squareSize.	[delta<= max y] whileTrue:[		self render: ogl horizontal: delta width: lineWidth.		self render: ogl horizontal: delta negated width: lineWidth.		delta _ delta + squareSize. 	].	matBlue disable:ogl.	].	matRed enable:ogl.	delta _ 0.0.	((delta >= min x) and:[delta <= max x])ifTrue:[			self render: ogl vertical: delta width: lineWidth.		].			((delta >= min y) and:[delta <= max y])ifTrue:[			self render: ogl horizontal: delta width: lineWidth.		].	matRed disable:ogl.! !!TCAD2D methodsFor: 'render' stamp: 'das 3/12/2004 13:34'!renderPrimitive: ogl	| lineWidth lineWidthN dx dy |	dx _ min x.	dy _ min y.	lineWidth _ 0.02.	lineWidthN _ lineWidth negated.	" This is used to render solid objects (if any). "	matBlue enable:ogl.	[dx<= max x] whileTrue:[		dx ~= 0.0 ifTrue:[			ogl glBegin: GLTriangleStrip.			ogl glVertex3fv: (dx@min y@lineWidth). 			ogl glVertex3fv: (dx@min y@lineWidthN).			ogl glVertex3fv: (dx@max y@lineWidth).			ogl glVertex3fv: (dx@max y@lineWidthN).   			ogl glEnd.			dx _ dx + 0.20. 		].	].		[dy<= max y] whileTrue:[		dy ~= 0.0 ifTrue:[			ogl glBegin: GLTriangleStrip.			ogl glVertex3fv: (min x@dy@lineWidth). 			ogl glVertex3fv: (min x@dy@lineWidthN).			ogl glVertex3fv: (max x@dy@lineWidth).			ogl glVertex3fv: (max x@dy@lineWidthN).   			ogl glEnd.			dy _ dy + 0.20. 		].	].	matBlue disable:ogl.	self root setCull.! !!TCrosshair methodsFor: 'render' stamp: 'das 3/12/2004 13:36'!render: ogl	ogl glDisable: GLLighting.	" This is used to render solid objects (if any). "	ogl glLineWidth:2.0.	ogl glColor3fv: #(1.0 0.7 0)asFloatArray;		glBegin: GLLineStrip;    			glVertex3fv:#(0.0 0.05 -1.1)asFloatArray;    			glVertex3fv:#(0.0 -0.05 -1.1)asFloatArray;    			glEnd;    		glBegin: GLLineStrip;    			glVertex3fv:#(0.05 0.0 -1.1)asFloatArray;    			glVertex3fv:#(-0.05 0.0 -1.1)asFloatArray;    			glEnd.	ogl glEnable: GLLighting.! !!TDemoBot methodsFor: 'stepping'!isComponent	^true! !!TDemoBot methodsFor: 'stepping'!moveSpeed	^5! !!TDemoBot methodsFor: 'stepping' stamp: 'DPR 2/18/2004 13:30'!moving	| p0 p1 p2 delta dist prior |	p0 _ self translation.	delta _ (0.001 * self stepTime) * self moveSpeed.	self transformBy: (B3DMatrix4x4 withOffset: 0@0@delta negated).	p1 _ self translation.	p2 _ myTarget translation.	dist _ (p2 - p1) length.	dist < self waitDistance ifTrue:[ ^self state: #startWait.].	prior _ (p2 - p0) length.	prior < dist ifTrue:[ self state: #turning.].! !!TDemoBot methodsFor: 'stepping'!moving: dt	| p0 p1 p2 delta dist prior |	p0 _ self translation.	delta _ (0.001 * dt) * self moveSpeed.	self transformBy: (B3DMatrix4x4 withOffset: 0@0@delta negated).	p1 _ self translation.	p2 _ myTarget translation.	dist _ (p2 - p1) length.	dist < self waitDistance ifTrue:[		stateTime _ lastStepTime + dt.		^state _ #startWait:].	prior _ (p2 - p0) length.	prior < dist ifTrue:[		state _ #turning:.		stateTime _ lastStepTime + dt.	].! !!TDemoBot methodsFor: 'stepping' stamp: 'DPR 2/18/2004 13:19'!nothing	"Do nothing"! !!TDemoBot methodsFor: 'stepping'!nothing: dt	"Do nothing"! !!TDemoBot methodsFor: 'stepping' stamp: 'DPR 2/18/2004 13:30'!searching	"Choose a new target for me"	| newTarget |	[newTarget _ targets atRandom.	newTarget == myTarget] whileTrue.	self state: #turning.	self myTarget: myTarget.! !!TDemoBot methodsFor: 'stepping' stamp: 'das 1/4/2003 21:35'!searching: dt	"Choose a new target for me"	| newTarget |	[newTarget _ targets atRandom.	newTarget == myTarget] whileTrue.	myTarget _ newTarget.	state _ #turning:.	stateTime _ lastStepTime + dt.	self metaSend myTargetId: myTarget teaObjectName.! !!TDemoBot methodsFor: 'stepping' stamp: 'DPR 2/18/2004 13:28'!startWait	self state: #waiting duration: self waitTime.! !!TDemoBot methodsFor: 'stepping'!startWait: dt	stateTime _ lastStepTime + dt + self waitTime.	state _ #waiting:.! !!TDemoBot methodsFor: 'stepping'!step	self perform: state.! !!TDemoBot methodsFor: 'stepping'!stepAt: nowTime	| delta |	delta _ (nowTime - lastStepTime).	delta > 0.0 ifTrue:[self perform: state with: delta].! !!TDemoBot methodsFor: 'stepping'!stepTime	^20! !!TDemoBot methodsFor: 'stepping'!turnSpeed	^45! !!TDemoBot methodsFor: 'stepping' stamp: 'DPR 2/18/2004 13:29'!turning	"Choose a new target for me"	| p0 p1 p2 dir1 dir2 delta before after |	myTarget ifNil:[^self state: #searching].	p0 _ self localTransform localPointToGlobal: 0@0@0.	p1 _ self localTransform localPointToGlobal: 0@0@-1.	p2 _ myTarget translation.	dir1 _ (p1 - p0). dir1 _ (dir1 x @ dir1 z) normalized.	dir2 _ (p2 - p0). dir2 _ (dir2 x @ dir2 z) normalized.	before _ dir1 dotProduct: dir2.	delta _ (self stepTime * 0.001) * self turnSpeed.	self transformBy: (B3DMatrix4x4 identity rotationAroundY: delta).	p1 _ self localTransform localPointToGlobal: 0@0@-1.	dir1 _ (p1 - p0). dir1 _ (dir1 x @ dir1 z) normalized.	after _ dir1 dotProduct: dir2.	(before > 0.5 and:[after < before]) ifTrue:[^self state: #moving.].! !!TDemoBot methodsFor: 'stepping'!turning: dt	"Choose a new target for me"	| p0 p1 p2 dir1 dir2 delta before after |	myTarget ifNil:[^state _ #searching:].	p0 _ self localTransform localPointToGlobal: 0@0@0.	p1 _ self localTransform localPointToGlobal: 0@0@-1.	p2 _ myTarget translation.	dir1 _ (p1 - p0). dir1 _ (dir1 x @ dir1 z) normalized.	dir2 _ (p2 - p0). dir2 _ (dir2 x @ dir2 z) normalized.	before _ dir1 dotProduct: dir2.	delta _ (dt * 0.001) * self turnSpeed.	self transformBy: (B3DMatrix4x4 identity rotationAroundY: delta).	p1 _ self localTransform localPointToGlobal: 0@0@-1.	dir1 _ (p1 - p0). dir1 _ (dir1 x @ dir1 z) normalized.	after _ dir1 dotProduct: dir2.	(before > 0.5 and:[after < before]) ifTrue:[		stateTime _ lastStepTime + dt.		^state _ #moving:].! !!TDemoBot methodsFor: 'stepping'!waitDistance	^10! !!TDemoBot methodsFor: 'stepping'!waitTime	^2000! !!TDemoBot methodsFor: 'stepping' stamp: 'ar 9/30/2004 14:49'!waiting	stateTime < (TeaTime now) ifTrue:[ self state: #searching ].! !!TDemoBot methodsFor: 'stepping'!waiting: dt	stateTime < (lastStepTime + dt) ifTrue:[		state _ #searching:.		^self].! !!TDemoBot methodsFor: 'stepping'!wantsSteps	^true! !!TDemoBot methodsFor: 'accessing' stamp: 'das 6/5/2002 16:23'!mySpace	^mySpace! !!TDemoBot methodsFor: 'accessing' stamp: 'das 6/5/2002 16:23'!mySpace: ms  	mySpace _ ms.! !!TDemoBot methodsFor: 'accessing'!myTarget	^myTarget! !!TDemoBot methodsFor: 'accessing' stamp: 'DPR 2/18/2004 13:26'!myTarget: aTarget	myTarget _ aTarget.	self state: #turning.! !!TDemoBot methodsFor: 'accessing' stamp: 'ar 9/30/2004 12:03'!myTargetId: id	| obj |	obj _ self teaObjects at: id ifAbsent:[nil].	obj ifNotNil:[self myTarget: obj].! !!TDemoBot methodsFor: 'accessing'!state	^state! !!TDemoBot methodsFor: 'accessing' stamp: 'DPR 2/18/2004 13:26'!state: newState	self state: newState duration: 0.0.! !!TDemoBot methodsFor: 'accessing' stamp: 'ar 9/30/2004 14:49'!state: newState duration: dl	state _ newState.	stateTime _ TeaTime now asFloat + dl.! !!TDemoBot methodsFor: 'accessing'!targets	^targets! !!TDemoBot methodsFor: 'accessing'!targets: newTargets	targets _ newTargets.! !!TFlag methodsFor: 'render'!boundSphere		^ boundSphere.! !!TFlag methodsFor: 'render' stamp: 'ar 9/30/2004 10:11'!render: ogl	| tx ty tty ttx top bottom tNorm bNorm |	ogl glDisable: GLCullFace.	texture ifNotNil: [ texture enable: ogl.].	ogl glLightModeli: GLLightModelColorControl with: GLSingleColor.	ogl glPushAttrib: (GLEnableBit bitOr: GLEvalBit)."	ogl glEnable: GLAutoNormal.""	ogl glEnable: GLNormalize."	tx _ 1.0/(segments x-1).	ty _ 1.0/(segments y-1).	tty _ 0.	top _ elements at: 1.	tNorm _ normals at: 1.	2 to: segments y do:[ :yIndex |		ogl glBegin: GLTriangleStrip.		bottom _ elements at: yIndex.		bNorm _ normals at: yIndex.		ttx _ 0.				1 to: segments x do: [ :xIndex |			ogl glTexCoord2f: ttx with: tty + ty;				glNormal3fv: (bNorm at: xIndex);				glVertex3fv:  (bottom at: xIndex);				glTexCoord2f: ttx with: tty;				glNormal3fv: (tNorm at: xIndex);				glVertex3fv: (top at: xIndex).			ttx _ ttx + tx.			].		ogl glEnd.		top _ bottom.		tNorm _ bNorm.		tty _ tty + ty.		].	ogl glPopAttrib.	texture ifNotNil:[texture disable: ogl.].	ogl setCull! !!TFlag methodsFor: 'initialize'!extent2: e segments: s	| dx dy elem norms pos |	extent _ e.	segments _ s.	dx _ extent x/segments x.	dy _ extent y/segments y negated.	elements _ Array new: segments y.	velocity _ Array new: segments y.	normals _ Array new: segments y.	1 to: segments y do: [ :i | 		elem _ B3DVector3Array new: segments x + 1.		norms _ B3DVector3Array new: segments x.		1 to: segments x do: [ :j |			elem at: j put: (dx * j) @ (dy * i) @ 0.			norms at: j put: 0@0@1].		elements at: i put: elem.		normals at: i put: norms.		velocity at: i put: (B3DVector3Array new: segments x).		].	tackTopLoc _ (elements at: 1) at: 1.	tackBottomLoc _ (elements at: segments y) at: 1.	pos _ B3DVector3 x: extent x/2.0 y: extent y/2.0 negated z:0.0.	boundSphere _ TBoundSphere localPosition: pos radius: (extent r)/2.0.	boundSphere frame: self.! !!TFlag methodsFor: 'initialize' stamp: 'ar 9/30/2004 19:57'!initialize	super initialize.	tackTop _ true.	tackBottom _ true.	windPeriod _ 15.0.	windPhase _ 0.9.	self extent2: 2.0@1.5 segments: 15@10.	kSpring _ 500.0.	gravity _ -0.01 @ -1 @ 0.01.	elapsed _ 0.0.	counter _ 1.	stepsLagging _ 0. "number of steps simulation is lagging by."	self objectOwner: self.! !!TFlag methodsFor: 'initialize' stamp: 'das 5/1/2002 09:49'!pick: pointertrue ifTrue:[^true].	"	| norm |	norm _ B3DVector3 x:0 y:0 z:11.	(pointer pickQuad: (B3DVector3 x:0 y:0 z:0)							q2: (B3DVector3 x: 0 y: extent y negated z:0)							q3: (B3DVector3 x: extent x y: extent y negated z:0)							q4: (B3DVector3 x: extent x y:0 z:0)) ifTrue:[^ true].	^ false."! !!TFlag methodsFor: 'events'!handlesKeyboard: pointer	^ true.! !!TFlag methodsFor: 'events' stamp: 'das 1/5/2003 13:34'!keyDown: pointer	| c |	c _ pointer event2D keyCharacter.	c = $b ifTrue:[		self meta tackBottom: true.		].	c = $t ifTrue:[		self meta tackTop: true.		].	c = $f ifTrue:[		self meta tackTop: false.		].! !!TFlag methodsFor: 'testing'!isComponent	^ true.! !!TFlag methodsFor: 'stepping' stamp: 'ar 9/30/2004 09:14'!step	| time xLength yLength xyLength xDelta yDelta xyDelta xDeltaSq yDeltaSq xyDeltaSq v vx vy vtot vlen zeroV topElement bottomElement topForce bottomForce transForce lastVx vel windForce windDirection xIndexLimit dashPot norms xyNorm twoPi |	counter > 100 ifTrue:[" This is just to make the flag pretty when we see it for the first time."2.0 raisedTo: 123456789.1. "ar 9/12/2001: One of the ugliest hacks in my life. Compute +Infinity to invoke an implicit reset of the FPU (!!!!!!) on Dave's Inspiron 8000 on which the GL drivers either screw up the FPU stack or leave the FPU in MMX mode - both of which resulting in 'stack check' exceptions on each and every FP load op. Incredible."		"frameNumber =  lastFrameNumber ifTrue:[^ self.]."	].	counter _ counter + 1.	"lastFrameNumber _ frameNumber."	time _ 0.04.	elapsed _ elapsed + time.	twoPi _ 2 * Float pi.	elapsed > twoPi ifTrue:[elapsed _ elapsed - twoPi].	dashPot _ 0.1.	xLength _ kSpring * extent x / segments x asFloat.	yLength _ kSpring * extent y / segments y asFloat.	xyLength _ (xLength * xLength + (yLength * yLength)) sqrt.	xDelta _ B3DVector3Array new: segments x + 1.	xDeltaSq _ B3DVector3Array new: segments x + 1.	yDelta _ B3DVector3Array new: segments x + 1.	yDeltaSq _ B3DVector3Array new: segments x + 1.	xyDelta _ B3DVector3Array new: segments x + 1.	xyDeltaSq _ B3DVector3Array new: segments x + 1.	topForce _ B3DVector3Array new: segments x + 1.	bottomForce _ B3DVector3Array new: segments x + 1.	v _ B3DVector3 new.	vx _ B3DVector3 new.	vy _ B3DVector3 new.	vtot _ B3DVector3 new.	zeroV _ B3DVector3 new.	lastVx _ B3DVector3 new.	xIndexLimit _ segments x.	xyNorm _ B3DVector3 new.	windForce _ B3DVector3 x: 4.0 		y: 1.3 * ((elapsed * twoPi/windPeriod) sin)		z: 1.3 * (( elapsed * twoPi/(windPeriod * windPhase)) cos).	windDirection _ windForce normalized.	1 to: segments y		do: [:yIndex | 			topElement _ elements at: yIndex.			vel _ velocity at: yIndex.			norms _ normals at: yIndex.			xDelta replaceFrom: 1 to: topElement size - 1 with: topElement startingAt: 2.			xDelta -= topElement.			xDeltaSq replaceFrom: 1 to: topElement size - 1 with: xDelta startingAt: 1.			xDeltaSq *= xDelta.			yIndex ~= segments y ifTrue: [					bottomElement _ elements at: yIndex + 1.					yDelta replaceFrom: 1 to: bottomElement size - 1 with: bottomElement startingAt: 1.					yDelta -= topElement.					yDeltaSq replaceFrom: 1 to: topElement size - 1 with: yDelta startingAt: 1.					yDeltaSq *= yDelta.					xyDelta replaceFrom: 1 to: bottomElement size - 1 with: bottomElement startingAt: 2.					xyDelta -= topElement.					xyDeltaSq replaceFrom: 1 to: topElement size - 1 with: xyDelta startingAt: 1.					xyDeltaSq *= xyDelta.					lastVx loadFrom: zeroV.					xyNorm loadFrom: zeroV.					1 to: xIndexLimit						do: [:xIndex | 							vtot loadFrom: gravity.							v_ topForce at: xIndex.							vtot -= v.							vtot -= lastVx.							v_ vel at: xIndex.							vtot -= (v*dashPot).							xyNorm x: (xyNorm x abs).		 					vtot += (windDirection * (xyNorm dot: windForce)).							v_ yDeltaSq at: xIndex.							vlen _ (v x + v y + v z) sqrt.							v_yDelta at: xIndex.							vy loadFrom: v.							v *= (kSpring - (yLength / vlen)).							vtot += v.							bottomForce at: xIndex put: ((bottomForce at: xIndex) + v).							xIndex ~= segments x								ifTrue: [									v_xDeltaSq at: xIndex.									vlen _ (v x + v y + v z) sqrt.									v_xDelta at: xIndex.									vx loadFrom: v.									v *= (kSpring - (xLength / vlen)).									vtot += v.									lastVx loadFrom: v.									v_xyDeltaSq at: xIndex.									vlen _ (v x + v y + v z) sqrt.									v_xyDelta at: xIndex.									v *= (kSpring - (xyLength / vlen)).									vtot += v.									xyNorm _  ((vy cross: vx) normalized).									norms at: xIndex put: xyNorm.									bottomForce at: xIndex+1 put: v].							((yIndex = 1 and: [xIndex = 1] ) and: [tackTop])								ifFalse: [									vel at: xIndex put: ((vel at: xIndex) + (vtot * time)).									topElement at: xIndex put: (topElement at: xIndex) + (time * 0.5 * vel at: xIndex)]								ifTrue: [ (tackTop and: [ tackTopLoc ~= (topElement at: 1) ]) ifTrue: [									v_ (tackTopLoc - (topElement at: 1)) normalize.									v*=0.02.									topElement at: 1 put: ((topElement at: 1)+ v)]]].					nil]				ifFalse: [					1 to: xIndexLimit do: [:xIndex | 							vtot loadFrom: gravity.							v_topForce at: xIndex.							vtot -= v.							vtot -= lastVx.							v_vel at: xIndex.							vtot -= (v*dashPot).							xIndex ~= segments x								ifTrue: [									v_xDeltaSq at: xIndex.									vlen _ (v x + v y + v z) sqrt.									vx_xDelta at: xIndex.									vx *= (kSpring - (xLength / vlen)).									vtot += vx.									lastVx loadFrom: vx].							(xIndex = 1 and: [tackBottom])								ifFalse: [									vel at: xIndex put: ((vel at: xIndex)+ (vtot * time)).									topElement at: xIndex put: ((topElement at: xIndex)+(time * 0.5 * vel at: xIndex))]].					nil].			transForce _ bottomForce.			bottomForce _ topForce.			topForce _ transForce.			bottomForce at: 1 put: zeroV].! !!TFlag methodsFor: 'stepping' stamp: 'DPR 9/3/2002 16:44'!stepAt: msecs	"this is a quick hack.   The way this works is that it simulates steps at a 25 fps frame rate - 40 milliseconds per step - by calling the step method as many times as would have occurred since lastStepTime if the steps occur on 40 msec boundaries"	| nSteps |	nSteps _ (msecs // 40) - (self lastStepTime // 40).	stepsLagging _ stepsLagging + nSteps.	nSteps _ stepsLagging min:  2.	"limit rate of catchup to double real time"	[nSteps > 0] whileTrue: [ nSteps _ nSteps - 1. stepsLagging _ stepsLagging -1. self step ].! !!TFlag methodsFor: 'stepping'!wantsSteps	^ true.! !!TFlag methodsFor: 'accessing'!tackBottom	^ tackBottom.! !!TFlag methodsFor: 'accessing'!tackBottom: bool	tackBottom _ bool.! !!TFlag methodsFor: 'accessing'!tackTop	^ tackTop.! !!TFlag methodsFor: 'accessing'!tackTop: bool	tackTop _ bool.! !!TFlag methodsFor: 'accessing'!texture	^ texture.! !!TFlag methodsFor: 'accessing'!texture: txtr	texture _ txtr.! !!TGroup methodsFor: 'accessing' stamp: 'das 2/24/2004 15:19'!colorize: col	doColorize ifNil:[doColorize _ true.].	doColorize ifTrue:[frameChildren do:[ :fc | fc colorize: col].].! !!TGroup methodsFor: 'accessing' stamp: 'das 2/24/2004 15:19'!doColorize: bool	doColorize _ bool.! !!TGroup methodsFor: 'accessing' stamp: 'das 2/24/2004 15:20'!material: mat	doColorize ifTrue:[^super material: mat].! !!TGroup methodsFor: 'accessing' stamp: 'das 9/8/2002 22:40'!visibleTree: bool	"Skip yourself, just do the children."	frameChildren ifNotNil:[		frameChildren do:[ :fc | fc visibleTree: bool.].].! !!TGroup methodsFor: 'initialize' stamp: 'das 2/24/2004 15:20'!initialize	super initialize.	visible _ false.	doColorize _true.! !!TGroup methodsFor: 'testing' stamp: 'das 4/10/2003 23:13'!isGroup	^ true.! !!T3Body methodsFor: 'events' stamp: 'das 11/17/2003 06:35'!handlesKeyboard: pointer^ true.! !!T3Body methodsFor: 'events' stamp: 'das 12/15/2003 14:54'!keyDown: pointer	| c v |	c _ pointer event2D keyCharacter.	v _ pointer event2D keyValue.	v = 32 ifTrue:[ self meta reset. thirdBody meta stop.].	c = $r ifTrue:[ saveVelocity ifNotNil:[					self meta reset.						thirdBody meta velocity: saveVelocity.					thirdBody meta translation: savePosition.					].				].	c = $+ ifTrue:[ self meta speed: speed + 1.0. ^ self].	c = $- ifTrue:[ self meta speed: speed - 1.0.  ^ self].	c isDigit ifTrue:[self meta reset. ].	c = $1 ifTrue:[  thirdBody meta velocity: 4@5@-5.					thirdBody meta translation: 9@29@44.					].	c = $2 ifTrue:[  thirdBody meta velocity: -7@0@3.					thirdBody meta translation: 50@10@25.				].	c = $3 ifTrue:[  thirdBody meta velocity: -6@-4.0@5.					thirdBody meta translation: 49@7@36.				].	c = $4 ifTrue:[  thirdBody meta velocity: -6@3@6.					thirdBody meta translation: 38@14@7.				].	c = $5 ifTrue:[  thirdBody meta velocity: -2@-4@6.					thirdBody meta translation: 45@44@17.				].	c = $6 ifTrue:[  thirdBody meta velocity: 5@-2@-1.					thirdBody meta translation: 24@3@42.				].	c = $7 ifTrue:[  thirdBody meta velocity: 5@4@-6.					thirdBody meta translation: 20@22@33.				].	c = $8 ifTrue:[  thirdBody meta velocity: -2@0@6.					thirdBody meta translation: 31@10@21.				].	c =$9 ifTrue:[  thirdBody meta velocity: 					(saveVelocity _ 7- ((14 atRandom)@7@(14 atRandom))).				thirdBody meta translation: 					(savePosition _ (50 atRandom)@10@(50 atRandom)).				].		c =$0 ifTrue:[  thirdBody meta velocity: 					(saveVelocity _ 7- ((14 atRandom)@(14 atRandom)@(14 atRandom))).				thirdBody meta translation: 					(savePosition _ (50 atRandom)@(50 atRandom)@(50 atRandom)).				].! !!T3Body methodsFor: 'events' stamp: 'DPR 7/5/2004 19:56'!keyStroke: pointer	| c v |	c _ pointer event2D keyCharacter.	v _ pointer event2D keyValue.	v = 32 ifTrue:[ self reset. thirdBody stop.].	c = $r ifTrue:[ saveVelocity ifNotNil:[					self reset.						thirdBody velocity: saveVelocity.					thirdBody translation: savePosition.					].				].	c = $+ ifTrue:[ self speed: speed + 1.0. ^ self].	c = $- ifTrue:[ self speed: speed - 1.0.  ^ self].	c isDigit ifTrue:[self reset. ].	c = $1 ifTrue:[  thirdBody velocity: 4@5@-5.					thirdBody translation: 9@29@44.					].	c = $2 ifTrue:[  thirdBody velocity: -7@0@3.					thirdBody translation: 50@10@25.				].	c = $3 ifTrue:[  thirdBody velocity: -6@-4.0@5.					thirdBody translation: 49@7@36.				].	c = $4 ifTrue:[  thirdBody velocity: -6@3@6.					thirdBody translation: 38@14@7.				].	c = $5 ifTrue:[  thirdBody velocity: -2@-4@6.					thirdBody translation: 45@44@17.				].	c = $6 ifTrue:[  thirdBody velocity: 5@-2@-1.					thirdBody translation: 24@3@42.				].	c = $7 ifTrue:[  thirdBody velocity: 5@4@-6.					thirdBody translation: 20@22@33.				].	c = $8 ifTrue:[  thirdBody velocity: -2@0@6.					thirdBody translation: 31@10@21.				].	c =$9 ifTrue:[  thirdBody velocity: 					(saveVelocity _ 7- ((14 atRandom)@7@(14 atRandom))).				thirdBody translation: 					(savePosition _ (50 atRandom)@10@(50 atRandom)).				].		c =$0 ifTrue:[  thirdBody velocity: 					(saveVelocity _ 7- ((14 atRandom)@(14 atRandom)@(14 atRandom))).				thirdBody translation: 					(savePosition _ (50 atRandom)@(50 atRandom)@(50 atRandom)).				].! !!T3Body methodsFor: 'events' stamp: 'das 11/19/2003 14:50'!reset	| moonEarthDistance earthRadius moonRadius |	earth translation: -10@10@-15.	moonVelocity _ 29.59@0@0.	earthRadius _ 12756/2.0.	moonRadius _ 3476/2.0.	moonEarthDistance _ 384400.	moon radius: earth radius * moonRadius/earthRadius.	moon translation: earth translation + (0@0@80). "((earth radius * moonEarthDistance/earthRadius)/15.0))."	stepRemainder _ 0.	thirdBody reset.! !!T3Body methodsFor: 'events' stamp: 'das 11/19/2003 14:23'!speed: sp	speed _ sp.	speed < 0.0 ifTrue:[speed _ 0.0]. 	thirdBody speed: speed.! !!T3Body methodsFor: 'stepping' stamp: 'DPR 5/12/2004 13:43'!step	| trans rot msecs delta secs count |	msecs _ stepRemainder + (self stepTime asFloat * speed).	stepRemainder _ msecs \\ 50.	count _ msecs // 50.	count timesRepeat:[		secs _ 0.05.		earthRot _ earthRot+(25.0*secs).		trans _ earth translation.		rot _ B3DMatrix4x4 identity rotationAroundY: earthRot.		earth localTransform: (tilt composeWith: rot).		earth localTransform: rot.		earthFrame localTransform: rot.		earth translation: trans.		earthFrame translation: trans.		delta _ earth globalPosition - moon globalPosition.			moonVelocity _ moonVelocity + (delta normalized *  (secs * (earthGravity mass/1000) * (moonGravity mass/1000)/  (delta dot: delta))).		moon translation: moon translation + (secs * moonVelocity).		thirdBody runStep.	].! !!T3Body methodsFor: 'stepping' stamp: 'das 11/18/2003 20:06'!stepAt: currentTime	| trans rot msecs delta secs count |	msecs _ stepRemainder + ((currentTime - self lastStepTime) asFloat * speed).	stepRemainder _ msecs \\ 50.	count _ msecs // 50.	count timesRepeat:[		secs _ 0.05.		earthRot _ earthRot+(25.0*secs).		trans _ earth translation.		rot _ B3DMatrix4x4 identity rotationAroundY: earthRot.		earth localTransform: (tilt composeWith: rot).		earth localTransform: rot.		earthFrame localTransform: rot.		earth translation: trans.		earthFrame translation: trans.		delta _ earth globalPosition - moon globalPosition.			moonVelocity _ moonVelocity + (delta normalized *  (secs * (earthGravity mass/1000) * (moonGravity mass/1000)/  (delta dot: delta))).		moon translation: moon translation + (secs * moonVelocity).		thirdBody doStep.	].! !!T3Body methodsFor: 'stepping' stamp: 'DPR 5/12/2004 13:39'!wantsSteps	^true.! !!T3Body methodsFor: 'initialize' stamp: 'DPR 5/12/2004 13:36'!initialize	| txtr mat |	super initialize.	earth _ TSphere new.	earth objectOwner: self.	earth radius: 20.0.	earth segments: 40.	txtr _ TTexture new initializeWithFileName: 'earth.png'.	mat _ TMaterial new.	mat texture: txtr.	mat ambientColor: #(1 1 1 1)asFloatArray.	mat diffuseColor: #(1 1 1 1)asFloatArray.	mat specularColor: #(0.1 0.1 0.1 1)asFloatArray.	mat shininess: 0.1.	earth material: mat.	earthFrame _ TGroup new.	earthFrame translation:(30@10@-120).	earth translation:(30@10@-120).	self addChild:earth.	self addChild: earthFrame.	earthGravity _ TAttractor new.	earthGravity radius: earth radius+2.	earthGravity mass: 700000.0.	earth addChild: earthGravity.		earthRot _ 0.	tilt _ B3DMatrix4x4 identity rotationAroundZ: 23.45.	earthRot _ 0.0.	moon _ TSphere new.	moon radius: (earth radius *0.27).	moon segments: 30.	txtr _ TTexture new initializeWithFileName: 'moon.png'.	mat _ TMaterial new.	mat texture: txtr.	mat ambientColor: #(1 1 1 1)asFloatArray.	mat diffuseColor: #(1 1 1 1)asFloatArray.	mat specularColor: #(0.1 0.1 0.1 1)asFloatArray.	mat shininess: 0.1.	moon material:mat.	moon translation: (70@0@100).	self addChild: moon.	moonGravity _ TAttractor new.	moonGravity radius: moon radius.	moonGravity mass: 100000.0.	moon addChild: moonGravity."	sky _ TSphereInside initialize: aCroquetWorld.	sky radius: 800.0.	sky segments: 40.	txtr _ TTexture new initializeWithFilaName: 'starsSmall.png'.	mat _ TMaterial new.	mat fullBright: true.	mat texture: txtr.	mat ambientColor: #(1 1 1 1)asFloatArray.	mat diffuseColor: #(1 1 1 1)asFloatArray.	mat cullFace: false.	sky material: mat.	sky solid: false.	self addChild: sky."	stepRemainder _ 0.		thirdBody _ TBody new.	self addChild: thirdBody.	thirdBody addAttractor: earthGravity.	thirdBody addAttractor: moonGravity.	thirdBody translation: 30@20@40.	speed _ 1.0.	self reset.	thirdBody stop.! !!T3Body methodsFor: 'testing' stamp: 'das 11/17/2003 05:37'!isComponent	^ true.! !!TAttractor methodsFor: 'accessing' stamp: 'das 9/12/2003 10:40'!hard	^ hard.! !!TAttractor methodsFor: 'accessing' stamp: 'das 9/12/2003 10:40'!hard: bool	hard _ bool.! !!TAttractor methodsFor: 'accessing' stamp: 'das 9/7/2003 15:35'!mass	^ mass.! !!TAttractor methodsFor: 'accessing' stamp: 'das 9/7/2003 15:35'!mass: m	mass _ m.! !!TAttractor methodsFor: 'accessing' stamp: 'das 9/7/2003 15:34'!radius	^ radius.! !!TAttractor methodsFor: 'accessing' stamp: 'das 9/10/2003 16:02'!radius: r	radius _ r.	radiusSquared _ r*r.! !!TAttractor methodsFor: 'accessing' stamp: 'das 9/10/2003 16:02'!radiusSquared	^ radiusSquared.! !!TAttractor methodsFor: 'initialize' stamp: 'das 2/17/2004 15:04'!initialize	super initialize.	self radius: 0.1.	mass_1.0.	hard _ true.! !!TAvatar methodsFor: 'driving' stamp: 'ar 10/3/2004 10:15'!driveStep	driving ifTrue: [		self sticky: false.		controlPitch			ifTrue: [self pitch: (speedControl y * 25 min: 75 max: -75)]			ifFalse: [ self forwardOnY: (speedControl y) negated.].		self addYaw: (speedControl x * 5).		].! !!TAvatar methodsFor: 'driving' stamp: 'ar 10/4/2004 14:18'!startDriving: yControlsPitch	driving ifFalse: [		controlPitch _ yControlsPitch.		driving _ true.	].! !!TAvatar methodsFor: 'driving' stamp: 'das 7/29/2004 18:54'!stopDriving	driving _ false.! !!TAvatar methodsFor: 'accessing' stamp: 'das 10/3/2004 17:17'!camera	^ camera.! !!TAvatar methodsFor: 'accessing' stamp: 'das 7/21/2004 14:45'!content: aFrame	content ifNotNil:[self removeChild: content].	content _ aFrame.	content ifNotNil:[self addChild: content].! !!TAvatar methodsFor: 'accessing' stamp: 'das 9/25/2004 17:21'!currentSpace	^ currentSpace.! !!TAvatar methodsFor: 'accessing' stamp: 'das 9/23/2004 16:37'!downPointer	^ downPointer.! !!TAvatar methodsFor: 'accessing' stamp: 'ar 10/3/2004 10:16'!driving	^driving! !!TAvatar methodsFor: 'accessing' stamp: 'das 7/30/2004 17:55'!goToPortal	^ goToPortal.! !!TAvatar methodsFor: 'accessing' stamp: 'DPR 8/15/2004 14:47'!goToPortal: gtp	gtp verifyProperlyVeiled.	goToPortal _ gtp.! !!TAvatar methodsFor: 'accessing' stamp: 'das 7/30/2004 17:55'!goToPortalTransform	^ goToPortalTransform.! !!TAvatar methodsFor: 'accessing' stamp: 'das 7/30/2004 17:55'!goToPortalTransform: gtpt	goToPortalTransform _ gtpt.! !!TAvatar methodsFor: 'accessing' stamp: 'ar 6/23/2002 23:41'!host	^host! !!TAvatar methodsFor: 'accessing' stamp: 'ar 6/23/2002 23:41'!host: aHost	host := aHost! !!TAvatar methodsFor: 'accessing' stamp: 'das 7/30/2004 22:34'!newSpace	^ newSpace.! !!TAvatar methodsFor: 'accessing' stamp: 'ar 6/23/2002 23:41'!nickname	^nickname! !!TAvatar methodsFor: 'accessing' stamp: 'ar 6/23/2002 23:41'!nickname: aString	nickname := aString! !!TAvatar methodsFor: 'accessing' stamp: 'das 9/25/2004 13:53'!pointer	^ pointer.! !!TAvatar methodsFor: 'accessing' stamp: 'abc 7/15/2002 19:26'!scale: scale	frameChildren ifNotNil:[		frameChildren do:[ :fc | fc scale: scale.]].! !!TAvatar methodsFor: 'accessing' stamp: 'das 4/14/2003 14:42'!setDoRender: bool	doRender _ bool.! !!TAvatar methodsFor: 'accessing' stamp: 'das 8/7/2004 12:46'!snapTrans	^ snapTrans.! !!TAvatar methodsFor: 'accessing' stamp: 'das 8/7/2004 12:49'!snapTrans: st	snapTrans _ st.! !!TAvatar methodsFor: 'accessing' stamp: 'das 7/29/2004 18:51'!speedControl: sc	speedControl _ sc.! !!TAvatar methodsFor: 'accessing' stamp: 'das 9/25/2004 17:08'!speedControl: sc pointerTransform: trans	speedControl _ sc.	self pointerTransform: trans.! !!TAvatar methodsFor: 'accessing' stamp: 'das 7/14/2004 03:36'!sticky: bool	sticky _ bool.! !!TAvatar methodsFor: 'accessing' stamp: 'das 8/4/2004 23:38'!transparency: tr	transparency _ tr.	super transparency: tr.! !!TAvatar methodsFor: 'accessing' stamp: 'das 9/26/2004 11:04'!viewAngle: vang bounds: bnds	camera viewAngle: vang.	camera bounds: bnds.! !!TAvatar methodsFor: 'accessing' stamp: 'das 10/3/2004 17:27'!viewAngle: vang bounds: bnds zScreen: zs	camera viewAngle: vang.	camera bounds: bnds.	camera zScreen: zs.! !!TAvatar methodsFor: 'initialize' stamp: 'das 7/29/2004 15:57'!defaultAvatar	self loadAvatar: #('Content' 'Alice' 'Animals' 'AliceLiddell.mdl').! !!TAvatar methodsFor: 'initialize' stamp: 'das 9/26/2004 10:58'!initialize	| downMatrix |	super initialize.	sticky _ false.	doRender _ true.	self defaultAvatar.	height _ 4.6.	lastDownPosition _ B3DVector3 new.	footFrame _ TGroup new.	footFrame singleParent: true.	gotoCount _ 0.	forwardOnY _ 0.	driving _ false.	controlPitch _ false.	currentSpace _ nil.	laser _ TLaser new.	laser translation:(B3DVector3 x: 0.5 y:-0.3 z:-0.2).	laser length: 0.5.	self addChild: laser.	transparency _ 1.0.	downMatrix _ B3DMatrix4x4 identity rotationAroundX: -90.	downPointer _ TRay new.	downPointer localTransform: downMatrix.	downPointer downRay: true.	self addChild: downPointer.	self fall.	pointer _ TPointer new.	camera _ TCamera new.	camera addChild: pointer.	pointer camera: camera.	pointer avatar: self.	^self! !!TAvatar methodsFor: 'initialize' stamp: 'ar 10/2/2004 09:06'!loadAvatar: avatarPath	| tframe  box scale dy |	tframe _ CroquetData loadAliceFile: avatarPath.	tframe ifNotNil:[		box _ tframe boundingBox.		scale _ 4.708164/box extentY.		dy _ box centerY * scale negated.		tframe scale: scale.		box _ tframe boundingBox.		tframe translationX: 0 y: 0.616526961326599+dy-2.3 z: 0.		tframe singleParent: false.		tframe solidTree: false.		tframe objectOwner: nil.	].	self content: tframe.	^tframe! !!TAvatar methodsFor: 'render' stamp: 'das 10/3/2004 17:05'!renderFrame: ogl parent: parent root: root	| ac rval |	ac _ ogl camera.	doRender ifTrue:["Render everyone else's avatars"		ac avatar = self ifFalse:[  ^ super renderFrame: ogl parent: parent root: root]."Only render ours if we are inside of a portal (such as a mirror) or the camera is behind the avatar"		ac inPortal ifTrue:[ "just render if we are in a portal"			transparency ~= 1.0 ifTrue:[self transparency: 1.0.].					^ super renderFrame: ogl parent: parent root: root. 		] ifFalse:[ "otherwise, check to see if we are thirdPerson or not"			ac thirdPerson ~= 0 ifTrue:[				ac thirdPerson ~= transparency ifTrue:[self transparency: ac thirdPerson.].				rval _ super renderFrame: ogl parent: parent root: root.				^ rval.			].		].	].	^ 0.! !!TAvatar methodsFor: 'render' stamp: 'das 3/12/2004 12:57'!renderFrame: ogl space: space	doRender ifTrue:[^ super renderFrame: ogl space: space].	^ 0.! !!TAvatar methodsFor: 'testing' stamp: 'ar 6/23/2002 23:42'!isComponent	^true! !!TAvatar methodsFor: 'voice chat' stamp: 'das 6/30/2004 23:23'!initPhone	| tframe  |	tframe _ TWidget createNewWithUrl:'http://www.reed.com/TeaLand/widgets/speaker.tea'		fileName:{FileDirectory default pathName. 'Content'. 'Widgets'. 'speaker.ASE'} scale:1.0.	speaker _ TSpeaker new initializeWithFrame: tframe.	speaker translationX: 0 y: 1.5 z: 0.	speaker rotationAroundY: 180.	self addChild: speaker.! !!TAvatar methodsFor: 'events' stamp: 'ar 7/21/2002 20:48'!handlesPointerDown: ptr	^true! !!TAvatar methodsFor: 'events' stamp: 'ar 6/23/2002 23:42'!handlesPointerOver: ptr	^true! !!TAvatar methodsFor: 'events' stamp: 'das 4/14/2003 16:32'!pointerDown: pointer! !!TAvatar methodsFor: 'events' stamp: 'ar 7/21/2002 20:54'!pointerEnter: pointer	self signal: #pointerEnter with: pointer with: self! !!TAvatar methodsFor: 'events' stamp: 'ar 7/21/2002 20:54'!pointerLeave: pointer 	self signal: #pointerLeave with: pointer with: self! !!TAvatar methodsFor: 'events' stamp: 'das 7/31/2004 10:54'!pointerUp: pointer! !!TAvatar methodsFor: 'events' stamp: 'das 9/25/2004 17:12'!selection: sel event2D: evt		camera localTransform: sel cameraTransform.	pointer selection: sel.	^pointer event2D: evt.! !!TAvatar methodsFor: 'events' stamp: 'das 9/25/2004 17:12'!selection: sel keyDown: evt		camera localTransform: sel cameraTransform.	pointer selection: sel.	^pointer keyDown: evt.! !!TAvatar methodsFor: 'events' stamp: 'das 9/25/2004 17:12'!selection: sel keyStroke: evt	camera localTransform: sel cameraTransform.	pointer selection: sel.	^pointer keyStroke: evt.! !!TAvatar methodsFor: 'events' stamp: 'das 9/25/2004 17:12'!selection: sel keyUp: evt		camera localTransform: sel cameraTransform.	pointer selection: sel.	^pointer keyUp: evt.! !!TAvatar methodsFor: 'events' stamp: 'das 9/25/2004 17:13'!selection: sel pointerDown: evt		camera localTransform: sel cameraTransform.	pointer selection: sel.	^ pointer pointerDown: evt.! !!TAvatar methodsFor: 'events' stamp: 'das 9/25/2004 17:13'!selection: sel pointerEnter: evt	camera localTransform: sel cameraTransform.	pointer selection: sel.	^ pointer pointerEnter: evt! !!TAvatar methodsFor: 'events' stamp: 'das 9/25/2004 17:47'!selection: sel pointerLeave: evt	camera localTransform: sel cameraTransform.	pointer selection: sel.	^ pointer pointerLeave: evt! !!TAvatar methodsFor: 'events' stamp: 'das 9/25/2004 17:47'!selection: sel pointerMove: evt		camera localTransform: sel cameraTransform.	pointer selection: sel.	^pointer pointerMove: evt! !!TAvatar methodsFor: 'events' stamp: 'das 9/25/2004 17:47'!selection: sel pointerOver: evt	camera localTransform: sel cameraTransform.	pointer selection: sel.	^ pointer pointerOver: evt! !!TAvatar methodsFor: 'events' stamp: 'das 9/25/2004 17:48'!selection: sel pointerUp: evt	camera localTransform: sel cameraTransform.	pointer selection: sel.	^ pointer pointerUp: evt! !!TAvatar methodsFor: 'transform' stamp: 'das 9/25/2004 17:21'!addToNewSpace: aSpace	aSpace addChild: self.	self frameChanged.	currentSpace _ aSpace.	self signal: #spaceEnter with: aSpace.	aSpace signal: #objectEnter with: self.! !!TAvatar methodsFor: 'transform' stamp: 'das 9/26/2004 11:31'!doGoto	| qFrom qTo fromLoc toLoc trans |" Is used to move the camera to a specific pose (location and orientation) in the TSpace, via an interpolated rotation/translation. "	gotoCount = 1 ifTrue:[		self localTransform: gotoTransform.		gotoCount _ 0.		self yawTransform.		"yaw _ (gotoTransform rotation y)."		^ self.].	qFrom _ localTransform asQuaternion.	qTo _ gotoTransform asQuaternion.	fromLoc _ localTransform translation.	toLoc _ gotoTransform translation.	fromLoc ~= toLoc ifTrue:[		fromLoc _ fromLoc  + ((toLoc - fromLoc)/gotoCount).].	qFrom _ qFrom slerpTo: qTo at: (1.0/gotoCount).	trans _ qFrom asMatrix4x4.	trans translation: fromLoc.	self localTransform: trans.	gotoCount _ gotoCount - 1. ! !!TAvatar methodsFor: 'transform' stamp: 'ar 10/3/2004 10:02'!downFloor: floor distance: dist position: pos	| trans ht transFloor downPosition |	gotoCount ~= 0 ifTrue:[ ^ self doGoto].	sticky ifTrue:[^ self].	floor ifNil:[^self].	floor isSolid ifFalse:[^self].	trans _ self translation." ---- Calculate distance to the current floor."	dist = height ifFalse:[		ht _ trans y + height - dist.		trans y > ht ifTrue:[ trans y - ht > 0.5 ifTrue:[ ht _ trans y - 0.5.].].		trans y: ht.	]." ---- Calculate the floor frame position in the floor's local frame. "	transFloor _ footFrame globalPosition-lastDownPosition.	lastDownFrame ~= floor ifTrue:[		floor addChild: footFrame.	].	downPosition _ pos.	downPosition y: (downPosition y-height).	footFrame translation: downPosition.	lastDownPosition _ footFrame globalPosition.	lastDownFrame _ floor.	trans x: trans x+transFloor x y: trans y z: trans z+ transFloor z.	self translation = trans ifFalse: [		self translation: trans.	].! !!TAvatar methodsFor: 'transform' stamp: 'das 7/21/2004 14:49'!enter: aTSpace	| oldRoot newRoot tfm |	oldRoot _ self root.	newRoot _ aTSpace.	oldRoot ifNotNil:[oldRoot removeChild: self.].	newRoot addChild: self.	self frameChanged.	tfm := aTSpace dropInFrame.	tfm ifNotNil:[		self localTransform: tfm clone.].! !!TAvatar methodsFor: 'transform' stamp: 'ar 10/4/2004 13:21'!fall	| trans ht transFloor downPosition floor dist pos |	self future: 50.0 perform:#fall.	floor _ downPointer selectedObject.	dist _  downPointer selectedDistance.	pos _ downPointer selectedFramePosition.	gotoCount ~= 0 ifTrue:[ ^ self doGoto].	sticky ifTrue:[^ self].	floor ifNotNil:[	floor isSolid ifTrue:[		trans _ self translation." ---- Calculate distance to the current floor."		dist = height ifFalse:[			ht _ trans y + height - dist.			trans y > ht ifTrue:[ trans y - ht > 0.5 ifTrue:[ ht _ trans y - 0.5.].].			trans y: ht]." ---- Calculate the floor frame position in the floor's local frame. "		transFloor _ footFrame globalPosition-lastDownPosition.		lastDownFrame ~= floor ifTrue:[			floor addChild: footFrame.			].		downPosition _ pos.		downPosition y: (downPosition y-height).		footFrame translation: downPosition.		lastDownPosition _ footFrame globalPosition.		lastDownFrame _ floor.		trans x: trans x+transFloor x y: trans y z: trans z+ transFloor z.		self translation = trans ifFalse: [			self translation: trans.			self localTransform:  self localTransform clone. ]	"why clone?"			].	].! !!TAvatar methodsFor: 'transform' stamp: 'das 7/14/2004 03:33'!forwardOnY	^ forwardOnY.! !!TAvatar methodsFor: 'transform' stamp: 'das 7/30/2004 10:01'!forwardOnY: foy	| trans |	trans _ B3DMatrix4x4 identity. 	trans translationX: 0.0 y:0.0 z: foy.	localTransform _ localTransform composeWith: trans.	self pitch > 0.001 ifTrue:[self pitch: self pitch * 0.8].	self frameChanged.! !!TAvatar methodsFor: 'transform' stamp: 'ar 10/1/2004 09:01'!goToPortal: aPortal transform: aTransform	| oldRoot aSpace |	oldRoot := self root.	aSpace := aPortal root.	self signal: #spaceLeave with: oldRoot.	oldRoot signal: #objectLeave with: self.	self parent removeChild: self.  "move out of space"	self localTransform: aTransform. "setup transform"	self yawTransform.	"self future: 0.0 perform: #addToNewSpace: withArguments: { aSpace }."	self addToNewSpace: aSpace.	"addChild: in the new space will force the necessary joins of the viewingParticipants"! !!TAvatar methodsFor: 'transform' stamp: 'das 7/14/2004 03:30'!goto: transform count: count" This is used to force the camera to move to a position/orientation. The final location is gotoTransform, and the number of interpolations is in gotoCount."	sticky _ true.	snapTrans _ self localTransform.	gotoTransform _ transform.	gotoCount _ count.! !!TAvatar methodsFor: 'transform' stamp: 'das 9/25/2004 14:17'!pointerTransform: transform	| p0 p1 at up side m |	pointer localTransform: transform.	pointer selectedFrame ifNotNil:[		p0 _ laser globalPosition.		p1 _ pointer selectedFrame globalTransform localPointToGlobal: pointer selectedPoint.		p0 _ self globalOrientation orthoNormInverse localPointToGlobal: (p0-p1).		at _ p0 normalized.		up _ 0@1@0.		side _ (at cross: up) normalized negated.		up _ (side cross: at) normalized negated.		m _ B3DMatrix4x4 identity.		m a11: side x.		m a21: side y.		m a31: side z.		m a12: up x.		m a22: up y.		m a32: up z.		m a13: at x.		m a23: at y.		m a33: at z.		laser orientation: m.		pointer isDown ifTrue:[laser length: p0 length] ifFalse:[laser length:0.5].	] ifNil:[		laser length: 0.5.		laser orientation:pointer orientation.		].				! !!TAvatar methodsFor: 'transform' stamp: 'DPR 8/15/2004 14:46'!skiddoo	self newRoot: goToPortal root newTransform: goToPortalTransform.	self yawTransform.	goToPortal _ nil.	goToPortalTransform _ nil.	newSpace _ true.! !!TAvatar methodsFor: 'transform' stamp: 'das 7/14/2004 03:32'!snapBack	self goto: snapTrans count: 6.	snapTrans _ nil.! !!TAvatar methodsFor: 'construction' stamp: 'ar 9/30/2004 13:40'!makePortal	| p1 win p2 trans spc |	spc _ self root.	trans _ self globalTransform translation + (self globalTransform orientation localPointToGlobal: (0@0@-8)).	trans _ self globalTransform copy translation: trans.	p2 _ TSpaceImposter new initializeWithSpace: spc transform: trans.	p1 _ TPortal new.	win _ self makeWindowInFront.	win contents: p1.	p1 linkPortal: p2.	self killPopup.! !!TAvatar methodsFor: 'construction' stamp: 'das 8/8/2004 00:08'!makeWindowInFront	"make a window in front of me"	| win |	win _ TWindow new.	win translation: (self translation - (self lookAt *6) - (0@0.5@0)).	win rotationAroundY: self yaw.	self root addChild: win.	^win.! !!TBillboard methodsFor: 'render' stamp: 'das 7/31/2004 11:35'!renderFrame: ogl parent: parent root: root	| cam mat pos out target dir sin angle |	cam := ogl camera.	cam ifNotNil:[		mat := self globalTransform.		pos := mat a14 @ mat a34.		out := (mat a13 @ mat a33) normalized.		mat := cam globalTransform.		target := mat a14 @ mat a34.		dir := (target - pos) normalized.		sin := dir crossProduct: out.		angle := (dir dotProduct: out) arcCos radiansToDegrees.		mat := B3DMatrix4x4 identity.		mat rotationAroundY: angle * sin sign.		self transformBy: mat.	].	^super renderFrame: ogl parent: parent root: root.! !!TBillboard methodsFor: 'render' stamp: 'das 7/31/2004 11:35'!renderFrame: ogl space: space	| cam mat pos out target dir sin angle |	cam := ogl camera.	cam ifNotNil:[		mat := self globalTransform.		pos := mat a14 @ mat a34.		out := (mat a13 @ mat a33) normalized.		mat := cam globalTransform.		target := mat a14 @ mat a34.		dir := (target - pos) normalized.		sin := dir crossProduct: out.		angle := (dir dotProduct: out) arcCos radiansToDegrees.		mat := B3DMatrix4x4 identity.		mat rotationAroundY: angle * sin sign.		self transformBy: mat.	].	^super renderFrame: ogl space: space.! !!TButton methodsFor: 'accessing' stamp: 'das 9/17/2002 01:22'!color: col	color _ col.	frame colorize: color.	frame2 ifNotNil:[frame2 colorize: color.].! !!TButton methodsFor: 'accessing' stamp: 'das 9/11/2002 12:12'!fadeDelay	^2500.0  "2.5 seconds"! !!TButton methodsFor: 'accessing' stamp: 'das 4/12/2003 12:39'!local:bool	local _ bool.! !!TButton methodsFor: 'accessing' stamp: 'das 9/11/2002 12:16'!persist	^ persist.! !!TButton methodsFor: 'accessing' stamp: 'das 4/11/2003 01:54'!spin: bool	spin _ bool.	doSpin _ 0.! !!TButton methodsFor: 'accessing' stamp: 'das 10/4/2002 19:00'!switch	^ switch.! !!TButton methodsFor: 'action' stamp: 'ar 9/30/2004 15:45'!disable	persist ifFalse:[		animateTime _ TeaTime now + self fadeDelay.].! !!TButton methodsFor: 'action' stamp: 'das 12/3/2002 13:54'!enable	self color: TButton overColor.	switch ifNil:[ frame solidVisibleTree: true. ] ifNotNil:[		frame solidVisibleTree: switch not.		frame2 solidVisibleTree: switch.		].	animateTime _ nil.! !!TButton methodsFor: 'action' stamp: 'DPR 5/19/2004 16:25'!fadeDelta	^125.0 "1/8 second"! !!TButton methodsFor: 'action' stamp: 'DPR 5/19/2004 16:31'!spinDelta	^125.0 "1/8 second"! !!TButton methodsFor: 'action' stamp: 'das 10/4/2002 18:57'!target2: trgt action2: act	target2 _ trgt.	action2 _ act.! !!TButton methodsFor: 'action' stamp: 'das 10/4/2002 18:57'!target: trgt action: act	target _ trgt.	action _ act.! !!TButton methodsFor: 'events' stamp: 'ar 10/4/2004 13:21'!doFade	"reduce color alpha"	| pct |	animateTime ifNil: [^self].	pct := color at: 4.	pct := pct - animateTime.	pct >= 0.0 ifTrue: [		color at: 4 put: pct.		self color: color.		self future: self fadeDelta perform: #doFade.	] ifFalse: [		frame solidVisibleTree: false. 		frame2 ifNotNil:[frame2 solidVisibleTree: false.].	]."	Croquet commit."! !!TButton methodsFor: 'events' stamp: 'das 10/4/2002 18:58'!handlesPointerDown: pointer	^ true.! !!TButton methodsFor: 'events' stamp: 'das 10/4/2002 18:58'!handlesPointerOver: pointer	^ true.! !!TButton methodsFor: 'events' stamp: 'das 6/21/2003 16:14'!persist: bool	persist _ bool.	persist ifTrue:[ 			self color: TButton overColor.		self enable.].	persist ifFalse:[self disable.].! !!TButton methodsFor: 'events' stamp: 'das 8/7/2004 17:30'!pointerDown: pointer 	self color: TButton downColor.	frame2 ifNotNil:[		switch ifNotNil:[			frame solidVisibleTree: switch not.			frame2 solidVisibleTree: switch.			] ifNil:[			frame solidVisibleTree: false.			frame2 solidVisibleTree: true.			].		].	^ true! !!TButton methodsFor: 'events' stamp: 'ar 9/30/2004 15:09'!pointerEnter: pointer	self enable.	self color: TButton hiliteColor.	spin ifTrue:[		deltaSpin _ -1.		doSpin _ doSpin + deltaSpin.	].	^ true.! !!TButton methodsFor: 'events' stamp: 'ar 9/30/2004 15:05'!pointerLeave: pointer 	self disable.	persist ifTrue:[self color: TButton overColor.]	ifFalse:[self color: TButton normColor.].	spin ifTrue:[		doSpin > -180 ifTrue:[			deltaSpin _ deltaSpin negated.].		].	^ true! !!TButton methodsFor: 'events' stamp: 'ar 9/30/2004 15:05'!pointerMove: pointer	pointer doSelect: true.	(pointer pointerPickTree: self) ifTrue:[ 		self color: TButton downColor.		switch ifNotNil:[			frame solidVisibleTree: switch.			frame2 solidVisibleTree: switch not.		] ifNil:[			frame2 ifNotNil:[				frame solidVisibleTree: false.				frame2 solidVisibleTree: true. 			].		].	] ifFalse:[ 		self color: TButton hiliteColor. 		switch ifNotNil:[			frame solidVisibleTree: switch not.			frame2 solidVisibleTree: switch.		] ifNil:[			frame2 ifNotNil:[				frame solidVisibleTree: true.				frame2 solidVisibleTree: false. 			].		].	].	pointer doSelect: false.	^ true.! !!TButton methodsFor: 'events' stamp: 'ar 9/30/2004 15:05'!pointerOver: pointer	^ true.! !!TButton methodsFor: 'events' stamp: 'das 9/28/2004 16:28'!pointerUp: pointer	| |	pointer doSelect: true.	pointer selectedDistance: Float infinity.	(pointer pointerPickTree: self) ifTrue:[		switch ifNotNil:[			local ifFalse:[self meta switch: switch not.]			ifTrue:[self switch: switch not.].			switch ifTrue:[target ifNotNil:[ target perform: action with: pointer.].] 			ifFalse:[				target2 ifNotNil:[ target2 perform: action2 with: pointer.].].		] 		ifNil:[			target ifNotNil:[ target perform: action with:pointer.].			frame solidVisibleTree: true.			frame2 ifNotNil:[ frame2 solidVisibleTree: false.].			].		] ifFalse:[			switch ifNotNil:[				frame solidVisibleTree: switch not.				frame2 solidVisibleTree: switch.			]ifNil:[				frame solidVisibleTree: true.				frame2 ifNotNil:[ frame2 solidVisibleTree: false.].			].		].	pointer doSelect: false.	persist ifTrue:[ self color: TButton overColor] ifFalse:[self color: TButton normColor].	^ true.! !!TButton methodsFor: 'events' stamp: 'ar 9/30/2004 15:06'!switch: bool	switch _ bool.	(frame visibleTree or:[frame2 visibleTree])ifTrue:[		frame solidVisibleTree: switch not.		frame2 solidVisibleTree: switch.	].! !!TButton methodsFor: 'initialize' stamp: 'ar 9/30/2004 13:08'!initializeSwitchWithFrame: fr frame2: fr2	frame _ fr.	frame2 _ fr2.	frame objectOwner: self.	frame2 objectOwner: self.	self addChild: frame.	self addChild: frame2.	self color: TButton normColor.	persist _ false.	frame solidVisibleTree: false.	frame2 solidVisibleTree: false.	animateTime _ nil.	switch _ false.	enable _ false.	spin _ false.	local _ false.	^self! !!TButton methodsFor: 'initialize' stamp: 'ar 9/30/2004 13:08'!initializeWithFrame: fr	frame _ fr.	frame ifNotNil:[ frame objectOwner: self.].	self addChild: frame.	self color: TButton normColor.	persist _ false.	frame solidVisibleTree: false.	animateTime _ nil.	enable _ false.	switch _ nil.	spin _ false.	local _ false.	^self! !!TButton methodsFor: 'initialize' stamp: 'ar 9/30/2004 13:08'!initializeWithFrame: fr frame2: fr2		frame _ fr.	frame2 _ fr2.	frame objectOwner: self.	frame2 objectOwner: self.	self addChild: frame.	self addChild: frame2.	self color: TButton normColor.	persist _ false.	frame solidVisibleTree: false.	frame2 solidVisibleTree: false.	animateTime _ nil.	switch _ nil.	enable _ false.	spin _ false.	local _ false.	^self! !!TButton methodsFor: 'testing' stamp: 'das 10/4/2002 18:57'!isComponent	^ true.! !!TButton methodsFor: 'testing' stamp: 'das 10/4/2002 18:57'!isSolid	^ false.! !!TButton methodsFor: 'stepping' stamp: 'das 4/16/2003 21:18'!stepAt: msecs	"interpolate color"	| timeLeft |	persist ifFalse:[		animateTime ifNotNil: [			timeLeft _ animateTime - msecs.			timeLeft <= 0 ifTrue: [ 				animateTime _ nil. 				frame solidVisibleTree: false. 				frame2 ifNotNil:[frame2 solidVisibleTree: false. ].]			ifFalse: [ color at: 4 put: timeLeft asFloat / self fadeDelay.].			self color: color.].] ifTrue:[		].	spin ifTrue:[ doSpin ~= 0 ifTrue:[ 		doSpin _ doSpin + deltaSpin. 		doSpin < -360 ifTrue:[doSpin _ 0.].		self rotationAroundY: doSpin.].].! !!TButton methodsFor: 'stepping' stamp: 'ar 10/4/2004 15:31'!wantsSteps	^true! !!TCADObject methodsFor: 'initialize' stamp: 'das 7/31/2004 09:42'!initialize	| cube pic |	super initialize.	path _ OrderedCollection new.	path add: (selectedPlane _ (TCAD2D new)).	self addChild: selectedPlane.	cube _ TCube new.	cube extent: 0.2@0.2@0.2.	pic _ TTexture new				initializeWithFileName: 'gridIcon.png'				mipmap: true				shrinkFit: false.	cube texture: pic.	extend _ TButton new initializeWithFrame: cube.	extendDistance _ 1.5.	extend translation: 0@0@extendDistance.	extend persist: true.	extend objectOwner: self.	extend target: self action: #extend:.	selectedPlane addChild: extend.	! !!TCADObject methodsFor: 'actions' stamp: 'das 10/30/2003 23:28'!doExtend: newPlane	| trans plane lastPlane |	plane _ newPlane.	lastPlane _ path last.	trans _ self relativeTransform: lastPlane .	trans translation: trans translation + (trans column3 * extendDistance).	lastPlane removeChild: extend.	path add: plane.	plane localTransform: trans.	plane addChild: extend.	self addChild: plane.	plane paths: lastPlane paths copy.	plane min: lastPlane min copy.	plane max: lastPlane max copy.	plane previousPlane: lastPlane.	lastPlane nextPlane: plane.			! !!TCADObject methodsFor: 'actions' stamp: 'das 10/3/2004 01:13'!extend	| newPlane |	newPlane _ TCAD2D new.	self meta doExtend: newPlane.	newPlane meta select.! !!TCADObject methodsFor: 'actions' stamp: 'das 7/31/2004 09:47'!extend: ptr	| newPlane |	newPlane _ TCAD2D new.	self doExtend: newPlane.	newPlane select.! !!TCADObject methodsFor: 'actions' stamp: 'das 10/30/2003 14:19'!reselect: pln	selectedPlane parent delete.	selectedPlane unselect.	selectedPlane _ pln.! !!TCADObject methodsFor: 'actions' stamp: 'das 3/10/2004 22:09'!selected: plane	plane = selectedPlane ifFalse:[		self reselect: plane.		TEditBox3D new initializeWithContents: plane.		].! !!TCADObject methodsFor: 'testing' stamp: 'das 10/19/2003 16:16'!isComponent	^true.! !!TCADObject methodsFor: 'accessing' stamp: 'das 10/30/2003 23:42'!selectedPlane	^ selectedPlane.! !!TCamera methodsFor: 'accessing' stamp: 'ar 10/4/2004 13:46'!aspect	^(self bounds width/ self bounds height) asFloat.! !!TCamera methodsFor: 'accessing' stamp: 'das 8/7/2004 23:51'!avatar	^ nil.! !!TCamera methodsFor: 'accessing' stamp: 'ar 10/1/2004 13:43'!bounds	bounds ifNotNil:[ ^ bounds.].	^ 0@0 corner: (viewPort bottomRight-viewPort topLeft).! !!TCamera methodsFor: 'accessing' stamp: 'das 9/23/2002 11:27'!bounds:bnds	bounds _ bnds.	! !!TCamera methodsFor: 'accessing' stamp: 'das 5/16/2002 14:19'!clipPlanes	^ clipPlanes.! !!TCamera methodsFor: 'accessing' stamp: 'das 5/16/2002 16:16'!clipPlanes: cp		cp ifNotNil:[		clipPlanes _ cp.].! !!TCamera methodsFor: 'accessing' stamp: 'das 7/19/2004 19:05'!currentSpace	^currentSpace.! !!TCamera methodsFor: 'accessing' stamp: 'das 7/19/2004 19:05'!currentSpace: cs	currentSpace _ cs.! !!TCamera methodsFor: 'accessing' stamp: 'das 8/1/2004 16:01'!debugOverlay	^ nil.! !!TCamera methodsFor: 'accessing' stamp: 'das 8/25/2004 13:43'!exportOn: exporter	self error:'Cannot export cameras'! !!TCamera methodsFor: 'accessing' stamp: 'ar 9/7/2002 14:51'!hasAlpha	^ viewClip.! !!TCamera methodsFor: 'accessing'!inPortal	^ inPortal.! !!TCamera methodsFor: 'accessing' stamp: 'das 8/5/2004 09:14'!inPortal: bool"bool ifTrue:[Transcript show:'+'.]ifFalse:[Transcript show:'-';cr.]."	inPortal _ bool.! !!TCamera methodsFor: 'accessing'!killFrame	^ killFrame.! !!TCamera methodsFor: 'accessing' stamp: 'das 12/21/2003 13:45'!killFrame: bool"Flag to let the system know not to reveal this frame, either because it is dirty or incomplete. Supresses the swapBuffer call."	killFrame _ bool.! !!TCamera methodsFor: 'accessing' stamp: 'das 12/13/2002 10:23'!outVector	^ self globalTransform column3.	! !!TCamera methodsFor: 'accessing' stamp: 'ar 10/10/2002 16:11'!pitch	^self pitchYawRoll x! !!TCamera methodsFor: 'accessing' stamp: 'das 12/26/2003 12:22'!pointer	^ nil.! !!TCamera methodsFor: 'accessing' stamp: 'das 2/17/2004 09:13'!pointer: pntr	^ nil.! !!TCamera methodsFor: 'accessing'!portalClip	^ portalClip.! !!TCamera methodsFor: 'accessing' stamp: 'das 7/10/2002 14:57'!portalClip: pc	portalClip _ pc.	portalClip ifNotNil:[		portalPlane _ (B3DVector3 x: portalClip a13  y:portalClip a23  z: portalClip a33) negated.].! !!TCamera methodsFor: 'accessing' stamp: 'ar 10/10/2002 16:11'!roll	^self pitchYawRoll z! !!TCamera methodsFor: 'accessing' stamp: 'ar 10/10/2002 16:18'!roll: r	| angles |	angles := self pitchYawRoll.	angles z: r.	self pitchYawRoll: angles.! !!TCamera methodsFor: 'accessing' stamp: 'das 7/19/2004 21:29'!root	^ currentSpace.! !!TCamera methodsFor: 'accessing' stamp: 'das 12/13/2002 10:23'!sideVector	^ self globalTransform column1	! !!TCamera methodsFor: 'accessing'!texture	^ texture.! !!TCamera methodsFor: 'accessing'!texture: txtr	texture _ txtr.! !!TCamera methodsFor: 'accessing' stamp: 'das 12/13/2002 10:22'!upVector	^ self globalTransform column2.	! !!TCamera methodsFor: 'accessing'!viewAngle	^ viewAngle.! !!TCamera methodsFor: 'accessing' stamp: 'das 12/21/2003 12:39'!viewAngle: va	viewAngle _ va.! !!TCamera methodsFor: 'accessing'!viewClip	^ viewClip.! !!TCamera methodsFor: 'accessing'!viewClip: bool	viewClip _ bool.! !!TCamera methodsFor: 'accessing' stamp: 'das 5/20/2002 19:48'!viewPort 	^ viewPort.! !!TCamera methodsFor: 'accessing' stamp: 'ar 10/10/2002 16:12'!yaw	^self pitchYawRoll y! !!TCamera methodsFor: 'accessing' stamp: 'ar 10/10/2002 16:18'!yaw: y	| angles |	angles := self pitchYawRoll.	angles y: y.	self pitchYawRoll: angles.! !!TCamera methodsFor: 'accessing'!zFar	^ zFar.! !!TCamera methodsFor: 'accessing' stamp: 'das 12/21/2003 12:39'!zFar: zf	zFar _ zf.! !!TCamera methodsFor: 'accessing'!zNear	^ zNear.! !!TCamera methodsFor: 'accessing' stamp: 'das 12/21/2003 12:39'!zNear: zn	zNear _ zn.! !!TCamera methodsFor: 'accessing' stamp: 'das 5/20/2002 18:06'!zScreen	^ zScreen.! !!TCamera methodsFor: 'accessing' stamp: 'das 7/31/2004 12:16'!zScreen: zs	zScreen _ zs.! !!TCamera methodsFor: 'transform'!clipPlanesTransform	^ clipPlanesTransform.! !!TCamera methodsFor: 'transform'!clipPlanesTransform: cpt	clipPlanesTransform _ cpt.! !!TCamera methodsFor: 'transform' stamp: 'das 12/20/2003 15:08'!doScale: scale	frameChildren ifNotNil:[		frameChildren do:[ :fc | fc scale: scale.]].! !!TCamera methodsFor: 'transform' stamp: 'DPR 1/9/2004 14:05'!scale: scale	self doScale: scale.! !!TCamera methodsFor: 'transform' stamp: 'ar 9/19/2002 17:43'!transformClipPlanes	|  trans |	clipPlanesTransform _ Array new: 4.	trans _ self globalOrientation.	1 to: 4 do: [:index | 		clipPlanesTransform at: index put: (trans localPointToGlobal: (clipPlanes at: index))].	! !!TCamera methodsFor: 'transform' stamp: 'das 12/20/2003 14:58'!updateTransform! !!TCamera methodsFor: 'initialize' stamp: 'das 12/21/2003 12:08'!frustumChanged! !!TCamera methodsFor: 'initialize' stamp: 'das 12/21/2003 13:43'!initClipPlanes	| aspect |	aspect _ self aspect. 	length _ 1.0/(((viewAngle/2.0)*(Float pi/180.0))tan).	clipPlanes _ B3DVector3Array ofSize: 4.		clipPlanes at: 1 put: (B3DVector3 x: 0.0 y: length  z: 1)normalize negated.	clipPlanes at: 2 put: (B3DVector3 x: 0.0 y: length negated z: 1)normalize negated.	clipPlanes at: 3 put: (B3DVector3 x: length y:0.0 z: aspect)normalize negated.	clipPlanes at: 4 put: (B3DVector3 x: length negated y:0.0 z: aspect)normalize negated.! !!TCamera methodsFor: 'initialize' stamp: 'ar 10/1/2004 13:43'!initFrustum: ogl	| radians bnds |	bnds _ self bounds.	radians _ (viewAngle/2.0)*(Float pi/180.0).	ogl initFrustum: viewAngle bounds: ((bnds left@(viewPort height - bnds bottom)) corner: (bnds right @ (viewPort height - bnds top))) zNear: zNear zFar: zFar.	zScreen _ (bnds height/2.0) / (radians tan).	self frustumChanged.! !!TCamera methodsFor: 'initialize' stamp: 'ar 9/30/2004 13:08'!initializeWithViewPort: vp	viewPort _ vp.	viewAngle _ 45.0.	zNear _ 0.5.	zScreen _ 0.5. "give it any value - initFrustum gives it a real value"	zFar _ 1500.0.	localTransform _ B3DMatrix4x4 identity.	self singleParent: true.	viewClip _ true.	self initClipPlanes.	inPortal _ false.	killFrame _ false.	self visible: false.	^self! !!TCamera methodsFor: 'render' stamp: 'das 7/28/2004 10:46'!postRender! !!TCamera methodsFor: 'render' stamp: 'das 7/28/2004 10:45'!preRender! !!TCamera methodsFor: 'render' stamp: 'das 8/9/2004 22:50'!render: ogl	| vert origin scale sLength sAspect |"This is deprecated code for sure, as there is no longer any way for a camera to render itself, but you never know if you will need to be able to visualize the viewport of a camera and this does just that."	ogl glDisable: GLCullFace.	origin _ B3DVector3 new.	vert _ B3DVector3 new.	scale _ 1.	sLength _ scale * length negated.	sAspect _ scale * self aspect.	ogl glBegin: GLTriangles.	ogl glNormal3fv: ((clipPlanes at:1) negated).	ogl glVertex3fv: origin.	vert x: sAspect y: scale z: sLength.	ogl glVertex3fv: vert.	vert x: sAspect negated y:  scale z: sLength.	ogl glVertex3fv: vert.	ogl glNormal3fv: ((clipPlanes at:2) negated).	ogl glVertex3fv: origin.	vert x: sAspect negated y:  scale negated z: sLength.	ogl glVertex3fv: vert.	vert x: sAspect y: scale negated z: sLength.	ogl glVertex3fv: vert.	ogl glNormal3fv: ((clipPlanes at:3) negated).	ogl glVertex3fv: origin.	vert x: sAspect y: scale negated z: sLength.	ogl glVertex3fv: vert.	vert x: sAspect y:  scale z: sLength.	ogl glVertex3fv: vert.	ogl glNormal3fv: ((clipPlanes at:4) negated).	ogl glVertex3fv: origin.	vert x: sAspect negated y:  scale z: sLength.	ogl glVertex3fv: vert.	vert x: sAspect negated y: scale negated z: sLength.	ogl glVertex3fv: vert.	ogl glEnd.	ogl setCull.	texture ifNotNil:[		texture enable: ogl.		ogl glBegin: GLQuads;				glNormal3f: 0.0 with: 0.0 with: -1.0;				glTexCoord2f:0.0 with: 0.0;					glVertex3f: sAspect negated with: scale with: sLength;				glTexCoord2f:1.0 with:0.0;					glVertex3f: sAspect with: scale with: sLength;				glTexCoord2f:1.0 with:1.0;					glVertex3f: sAspect with: scale negated with: sLength;				glTexCoord2f:0.0 with:1.0;					glVertex3f: sAspect negated with: scale negated with:sLength;			 glEnd.		texture disable: ogl.].! !!TCamera methodsFor: 'render' stamp: 'das 3/12/2004 13:35'!renderAlpha: ogl	| vert origin scale sLength sAspect |	ogl glDisable: GLCullFace.	origin _ B3DVector3 new.	vert _ B3DVector3 new.		scale _ 20.	sLength _ scale * length negated.	sAspect _ scale * self aspect.	ogl glBegin: GLTriangles.	ogl glNormal3fv: (clipPlanes at:1) negated.	ogl glVertex3fv: origin.	vert x: sAspect y: scale z: sLength.	ogl glVertex3fv: vert.	vert x: sAspect negated y:  scale z: sLength.	ogl glVertex3fv: vert.	ogl glNormal3fv: (clipPlanes at:2) negated.	ogl glVertex3fv: origin.	vert x: sAspect negated y:  scale negated z: sLength.	ogl glVertex3fv: vert.	vert x: sAspect y: scale negated z: sLength.	ogl glVertex3fv: vert.	ogl glNormal3fv: (clipPlanes at:3) negated.	ogl glVertex3fv: origin.	vert x: sAspect y: scale negated z: sLength.	ogl glVertex3fv: vert.	vert x: sAspect y:  scale z: sLength.	ogl glVertex3fv: vert.	ogl glNormal3fv: (clipPlanes at:4) negated.	ogl glVertex3fv: origin.	vert x: sAspect negated y:  scale z: sLength.	ogl glVertex3fv: vert.	vert x: sAspect negated y: scale negated z: sLength.	ogl glVertex3fv: vert.	ogl glEnd.	ogl setCull.! !!TCamera methodsFor: 'render' stamp: 'das 9/3/2004 05:22'!renderOverlay: ogl! !!TCamera methodsFor: 'render' stamp: 'ar 9/30/2004 16:53'!renderView: ogl	self preRender.	ogl camera: self.	ogl reset.	ogl glEnable: GLDepthTest.	ogl beginFrame: TeaTime now asFloat.	ogl glEnable: GLLighting.	"------ set up the view frustum ------"	self initFrustum: ogl. 	currentSpace renderClear: ogl.	currentSpace renderSpace: ogl.	self renderOverlay: ogl.	ogl endFrame.	self postRender.! !!TCamera methodsFor: 'render' stamp: 'ar 10/25/2002 23:03'!teleportTo: newTransform in: newSpace	"Should be done better. Oh well..."	self localTransform: newTransform.	self enter: newSpace.! !!TCamera methodsFor: 'render' stamp: 'ar 9/30/2004 16:32'!testBounds: bnds	| position pposition d cp fsi |	bnds ifNil: [^ true].	position _ bnds globalPosition - self globalPosition."------- test to the near and far clip planes -------"	d _ (self lookAt dot: position) negated.	fsi _ CroquetGlobals frameScaleInverse.	d + bnds radius < (zNear*fsi) ifTrue:[^ false].	d - bnds radius > (zFar*fsi) ifTrue:[^false].	1 to: 4 do:[:i|		cp := clipPlanesTransform at: i.		(0 > ((cp dot: position)+bnds radius)) ifTrue:[ ^ false.]].	" portalClip is the clipping plane of the portal if we happen to be rendering inside of one. "	portalClip ifNotNil:[		pposition _ bnds globalPosition - portalClip translation.		0 > ((portalPlane dot: pposition)+ bnds radius) ifTrue:[ ^ false].		].^ true! !!TCamera methodsFor: 'render' stamp: 'ar 9/30/2004 16:32'!testSphere: pos radius: radius	| pposition position plane d  fsi |	position _ pos - self globalPosition."------- test to the near and far clip planes -------"	plane _ self lookAt.	d _ ( plane dot: position ) negated.	fsi _ CroquetGlobals frameScaleInverse.	d + radius < (zNear*fsi) ifTrue:[^ false].	d - radius > (zFar*fsi) ifTrue:[^false]."------- test to the four clip planes -------"	1 to: 4		do: [:index | 0 > (((clipPlanesTransform at:index)								dot: position) + radius)				ifTrue: [^ false]].	" portalClip is the clipping plane of the portal if we happen to be rendering inside of one. "	portalClip ifNotNil:[		pposition _ position - portalClip translation.		plane _ B3DVector3 x: portalClip a13 negated y:portalClip a23 negated z: portalClip a33 negated.		0 > ((plane dot: pposition)+ radius) ifTrue:[^ false].	].	^ true! !!TCamera methodsFor: 'testing'!isCamera	^ true.! !!TCamera methodsFor: 'toys' stamp: 'das 7/15/2002 20:18'!jump	self translation: self translation + (B3DVector3 x: 0 y: 20 z: 0).! !!TCamera methodsFor: '*Jana-Script' stamp: 'ar 5/5/2003 00:06'!isPointerDown	"Answer whether the pointer is currently pressed on aFrame"	^self pointer isPointerDown! !!TCamera methodsFor: '*Jana-Script' stamp: 'jh 5/5/2003 19:01'!isPointerDownOn: aFrame	"Answer whether the pointer is currently pressed on aFrame"	^self pointer isPointerDownOn: aFrame! !!TClock methodsFor: 'initialize' stamp: 'DPR 5/20/2004 11:02'!initialize	| mat |	super initialize.	lastPositionUpdate _ 0.0.	face _ TCylinder new.	face topRadius: 0.5.	face baseRadius: 0.6.	face capped: true.	face height: 0.1.	face slices: 24.	face rotationAroundX: 90.0.	face objectOwner: self.	self addChild: face.	mat _ TMaterial new.	mat ambientColor: #(0.5 0.7 0.7 0.5) asFloatArray.	mat diffuseColor: #(0.5 0.7 0.7 0.5) asFloatArray.	face material: mat.	hour _ TCube new.	hour extent: (B3DVector3 x:0.05 y: 0.35 z: 0.01).	hour location: (B3DVector3 x: 0.0 y:0.16 z:0.12).	self addChild: hour.	mat _ TMaterial new.	mat ambientColor: #(0.02 0.04 0.04 1.0) asFloatArray.	mat diffuseColor: #(0.02 0.04 0.04 1.0) asFloatArray.	hour material: mat.		minute _ TCube new.	minute extent: (B3DVector3 x:0.05 y: 0.47 z: 0.01).	minute location: (B3DVector3 x: 0.0 y:0.22 z:0.11).	self addChild: minute.	minute material: mat.	second _ TCube new.	second extent: (B3DVector3 x:0.02 y: 0.5 z: 0.01).	second location: (B3DVector3 x: 0.0 y:0.23 z:0.13).	self addChild: second.	mat _ TMaterial new.	mat ambientColor: #(1.0 0.05 0.05 1.0) asFloatArray.	mat diffuseColor: #(1.0 0.05 0.05 1.0) asFloatArray.	second material: mat.	^self! !!TClock methodsFor: 'testing' stamp: 'das 6/25/2002 16:35'!isComponent	^ true.! !!TClock methodsFor: 'stepping' stamp: 'ar 9/30/2004 14:49'!syncHands	| pHour pMin pSec time now |	now _ TeaTime now asFloat.	now < (lastPositionUpdate + 1000.0) ifTrue: [^self].	lastPositionUpdate _ now.	time _ Time now.	pHour _ -360.0 * (time hours + (time minutes/60.0))/12.0.	hour rotationAroundZ: pHour.	pMin _ -360.0 * time minutes / 60.0.	minute rotationAroundZ: pMin.	pSec _ -360.0 * time seconds / 60.0.	second rotationAroundZ: pSec.! !!TClock methodsFor: 'render' stamp: 'DPR 5/20/2004 11:02'!renderFrame: ogl parent: parent root: root	self syncHands.	^ super renderFrame: ogl parent: parent root: root.! !!TEditBox methodsFor: 'accessing' stamp: 'DPR 1/9/2004 14:05'!contents: conts	| parentFrame extent |	contents _ conts.	box _ contents boundingBox copy.	parentFrame _ contents parent.	self localTransform: conts localTransform.	self translation: self translation + (self orientation localPointToGlobal:box center).	contents localTransform: B3DMatrix4x4 identity.	contents translation: (box center negated).	extent _ box extent.	box min: (extent/-2.0).	box max: (extent/2.0).	parentFrame replaceChild: contents with: self.	self addChild: conts.	scaleContents _ 1.0.	self update.! !!TEditBox methodsFor: 'accessing' stamp: 'das 5/22/2003 12:51'!scale: sc	box scale: sc."	contents scale: sc."	self update.! !!TEditBox methodsFor: 'accessing' stamp: 'das 5/24/2003 15:13'!selectedPoint: sp	selectedPoint _ sp.! !!TEditBox methodsFor: 'actions' stamp: 'DPR 1/9/2004 14:05'!delete	| |	contents localTransform: (self localTransform composeWith: contents localTransform).	self parent replaceChild: self with: contents.! !!TEditBox methodsFor: 'actions' stamp: 'DPR 1/9/2004 14:05'!dragBox: pointer	| norm sp sf |	sf _ selectedFrame translation.	pointer shiftPressed ifTrue:[ 		sf x ~= 0 ifTrue:[ norm _ B3DVector3 x:0 y:1 z:0].		sf y ~= 0 ifTrue:[norm _ B3DVector3 x:0 y:0 z:1].		sf z ~= 0 ifTrue:[norm _ B3DVector3 x:0 y:1 z:0].		] ifFalse:[norm _ sf normalized.].	sp _ selectedFrame localTransform localPointToGlobal: selectedPoint.	(pointer frame: self pickPlane: sp normal: norm) ifTrue:[		self translation: self translation +			(self orientation localPointToGlobal: (pointer selectedPoint-sp)).].! !!TEditBox methodsFor: 'actions' stamp: 'DPR 1/9/2004 14:05'!resizeBox: pointer"This needs to be fixed - since the plane does not go through the center of the cube, there is a limit to how small this can get in any one motion. The advantage is this keeps us from getting too small."	| len1 len2  norm sp sc|	norm _ (pointer camera frameLookAt: self) negated.	sp _ selectedFrame localTransform localPointToGlobal: selectedPoint.	(pointer frame: self pickPlane: sp normal: norm) ifTrue:[		len1 _ sp length.		len2 _ pointer selectedPoint length.		len1 = 0.0 ifTrue:[^ false.].		sc _ len2/len1.		self scale: sc.		scaleContents _ scaleContents * sc.		selectedPoint _ (selectedFrame localTransform orthoNormInverse localPointToGlobal: pointer selectedPoint).		^ true.].	^ false.! !!TEditBox methodsFor: 'actions' stamp: 'DPR 1/9/2004 14:05'!rotateBoxX: pointer	| len radius delta deltaLoc spto spfrom theta trans |	" Rotate around the x-axis "	len _ selectedFrame extent x/2.0.	len _ len max: 100.0.	radius _ selectedFrame location length.	(pointer frame: self pickCylinderFrom: ( B3DVector3 x: len  y: 0 z: 0)		to:( B3DVector3 x: len negated y: 0 z: 0) radius: radius) 	ifFalse:["we are not on the cylinder anymore...."		delta _ 2*radius.		(pointer framePointer row2 dot: (pointer framePosition))  > 0 			ifFalse:[  delta _ delta negated.].		deltaLoc _ pointer framePointer row2 * delta.		(pointer frame: self pickCylinderFrom: (B3DVector3 x: len  y: deltaLoc y z: deltaLoc z)			to: (B3DVector3 x: len negated y: deltaLoc y z: deltaLoc z) radius: radius)				ifFalse:[lastSpin _ nil. ^ false.].		spto _ pointer selectedPoint copy- deltaLoc.		spto x: 0			y: spto y negated			z: spto z negated.			]	ifTrue: [spto _ pointer selectedPoint copy.].	spfrom _ selectedPoint copy.	spfrom x: 0.0.	spfrom normalize.	spto x: 0.0.	spto normalize.	theta _ ((spfrom y * spto z) - (spto y * spfrom z))"/selectedRadiusSquared".	theta < -1.0 ifTrue:[theta_ -1.0].	theta > 1.0 ifTrue:[theta _ 1.0].	theta _ theta arcSin radiansToDegrees/2.0.	lastSpin _ B3DMatrix4x4 identity rotationAroundX: theta.	trans _ self translation.	self translationX: 0.0 y:0.0 z:0.0.	self localTransform: (self localTransform composeWith: lastSpin).	self translation: trans.	self localTransform: localTransform clone.	^ true.! !!TEditBox methodsFor: 'actions' stamp: 'DPR 1/9/2004 14:05'!rotateBoxY: pointer	| trans spfrom spto deltaLoc theta radius len delta |		" Rotate around the y-axis "		len _ selectedFrame extent y/2.0.		len _ len max: 100.0.		radius _ selectedFrame location length.		(pointer frame: self pickCylinderFrom: (B3DVector3 x: 0.0 y: len z: 0.0)				to: (B3DVector3 x: 0.0 y: len negated z: 0.0) radius: radius)			ifFalse: [ "we are not on the cylinder anymore...."			delta _ 2*radius.			(pointer framePointer row1 dot: (pointer framePosition)) > 0				ifFalse:[ delta _ delta negated ].			deltaLoc _ pointer framePointer row1 * delta.			(pointer frame: self pickCylinderFrom: (B3DVector3 x: deltaLoc x y: len z: deltaLoc z )				to: (B3DVector3 x: deltaLoc x y: len negated z: deltaLoc z) radius: radius)				ifFalse:[lastSpin _ nil. ^ false.].			spto _ pointer selectedPoint copy- deltaLoc.			spto x: spto x negated				y: 0				z: spto z negated.			]	ifTrue: [spto _ pointer selectedPoint copy.].	spfrom _ selectedPoint copy.	spfrom y: 0.0.	spfrom normalize.	spto y: 0.0.	spto normalize.	theta _ ((spfrom z * spto x) - (spto z * spfrom x))"/selectedRadiusSquared".	theta < -1.0 ifTrue:[theta_ -1.0].	theta > 1.0 ifTrue:[theta _ 1.0].	theta _ theta arcSin radiansToDegrees/2.0.	lastSpin _ B3DMatrix4x4 identity rotationAroundY: theta.	trans _ self translation.	self translationX: 0.0 y:0.0 z:0.0.	self localTransform: (self localTransform composeWith: lastSpin).	self translation: trans.	self localTransform: localTransform clone.	^ true.! !!TEditBox methodsFor: 'actions' stamp: 'DPR 1/9/2004 14:05'!rotateBoxZ: pointer	| delta trans spfrom spto deltaLoc theta radius len |		" Rotate around the z-axis "		len _ selectedFrame extent z/2.0.		len _ len max: 100.0.		radius _ selectedFrame location length.		(pointer frame: self pickCylinderFrom: (B3DVector3 x: 0.0 y: 0.0 z: len)				to: (B3DVector3 x: 0.0 y: 0.0 z: len negated) radius: radius)			ifFalse: [ "we are not on the cylinder anymore...."			delta _ 2*radius.			(pointer framePointer row2 dot: (pointer framePosition))  > 0 				ifFalse:[  delta _ delta negated. ].			deltaLoc _ pointer framePointer row2 * delta.			(pointer frame: self pickCylinderFrom: (B3DVector3 x: deltaLoc x y: deltaLoc y z: len)				to: (B3DVector3 x: deltaLoc x y: deltaLoc y z: len negated) radius: radius)				ifFalse:[lastSpin _ nil. ^ false.].			spto _ pointer selectedPoint copy- deltaLoc.			spto x: spto x negated				y: spto y negated				z: 0.			]	ifTrue: [spto _ pointer selectedPoint copy.].	spfrom _ selectedPoint copy.	spfrom z: 0.0.	spfrom normalize.	spto z: 0.0.	spto normalize.	theta _ ((spfrom x * spto y) - (spto x * spfrom y))"/selectedRadiusSquared".	theta < -1.0 ifTrue:[theta_ -1.0].	theta > 1.0 ifTrue:[theta _ 1.0].	theta _ theta arcSin radiansToDegrees/2.0.	lastSpin _ B3DMatrix4x4 identity rotationAroundZ: theta.	trans _ self translation.	self translationX: 0.0 y:0.0 z:0.0.	self localTransform: (self localTransform composeWith: lastSpin).	self translation: trans.	self localTransform: localTransform clone.	^ true.! !!TEditBox methodsFor: 'actions' stamp: 'das 2/20/2004 10:40'!selectChild	| eb |	contents frameChildren ifNotNil:[		contents frameChildren size > 0 ifTrue:[			eb_ TEditBox new.			eb contents: (contents frameChildren at: 1).			self delete.			].		].! !!TEditBox methodsFor: 'actions' stamp: 'das 2/20/2004 10:40'!selectLeftSibling	|  siblings previous eb |	siblings _ self parent frameChildren.	siblings size > 1 ifTrue:[		previous _ siblings previous: self.		self delete.		eb _ TEditBox new. 		eb contents: previous .		].! !!TEditBox methodsFor: 'actions' stamp: 'das 2/20/2004 10:40'!selectParent	| par eb |	self parent ifNotNil: [ "we are the root"		self parent ~= self root ifTrue:[ " don't select the root, as that would be really hard to edit"		par _ self parent.		self delete.		eb _ TEditBox new.		eb contents: par.		].	].		! !!TEditBox methodsFor: 'actions' stamp: 'das 2/20/2004 10:40'!selectRightSibling	|  siblings next eb |	siblings _ self parent frameChildren.	siblings size > 1 ifTrue:[		next _ siblings next: self.		self delete.		eb _ TEditBox new.		eb contents: next .		].! !!TEditBox methodsFor: 'events' stamp: 'das 5/22/2003 19:10'!handlesKeyboard: pointer	^ true.! !!TEditBox methodsFor: 'events' stamp: 'das 5/18/2003 00:25'!handlesPointerDown: pointer	^ true.! !!TEditBox methodsFor: 'events' stamp: 'das 5/18/2003 00:25'!handlesPointerOver: pointer	^ true.! !!TEditBox methodsFor: 'events' stamp: 'das 5/24/2003 19:07'!keyDown: pointer	| c spin |	c _ pointer event2D keyCharacter.	c = $x ifTrue:[ spin _ B3DMatrix4x4 identity rotationAroundX: -1.0].	c = $X ifTrue:[ spin _ B3DMatrix4x4 identity rotationAroundX: 1.0].	c = $y ifTrue:[ spin _ B3DMatrix4x4 identity rotationAroundY: -1.0].	c = $Y ifTrue:[ spin _ B3DMatrix4x4 identity rotationAroundY: 1.0].	c = $z ifTrue:[ spin _ B3DMatrix4x4 identity rotationAroundZ: -1.0].	c = $Z ifTrue:[ spin _ B3DMatrix4x4 identity rotationAroundZ: 1.0].	c = $d ifTrue:[self meta delete.].	pointer event2D keyValue= 28 ifTrue:[ self selectLeftSibling. ]. "left arrow"	pointer event2D keyValue= 29 ifTrue:[ self selectRightSibling.]. "right arrow"	pointer event2D keyValue= 30 ifTrue:[ self selectParent. ]. "up arrow"	pointer event2D keyValue= 31 ifTrue:[ self selectChild. ]. "down arrow"	spin ifNotNil:[self meta localTransform: (self localTransform composeWith: spin) ].	^ true.! !!TEditBox methodsFor: 'events' stamp: 'DPR 7/5/2004 19:57'!keyStroke: pointer	| c spin |	c _ pointer event2D keyCharacter.	c = $x ifTrue:[ spin _ B3DMatrix4x4 identity rotationAroundX: -1.0].	c = $X ifTrue:[ spin _ B3DMatrix4x4 identity rotationAroundX: 1.0].	c = $y ifTrue:[ spin _ B3DMatrix4x4 identity rotationAroundY: -1.0].	c = $Y ifTrue:[ spin _ B3DMatrix4x4 identity rotationAroundY: 1.0].	c = $z ifTrue:[ spin _ B3DMatrix4x4 identity rotationAroundZ: -1.0].	c = $Z ifTrue:[ spin _ B3DMatrix4x4 identity rotationAroundZ: 1.0].	c = $d ifTrue:[self delete.].	pointer event2D keyValue= 28 ifTrue:[ self selectLeftSibling. ]. "left arrow"	pointer event2D keyValue= 29 ifTrue:[ self selectRightSibling.]. "right arrow"	pointer event2D keyValue= 30 ifTrue:[ self selectParent. ]. "up arrow"	pointer event2D keyValue= 31 ifTrue:[ self selectChild. ]. "down arrow"	spin ifNotNil:[self localTransform: (self localTransform composeWith: spin) ].	^ true.! !!TEditBox methodsFor: 'events' stamp: 'das 5/19/2003 10:59'!pointerDown: pointer	selectedFrame _ pointer selectedFrame.	selectedPoint _ pointer selectedPoint.	^ true.! !!TEditBox methodsFor: 'events' stamp: 'das 5/22/2003 00:50'!pointerEnter: pointer	selectedFrame _ pointer selectedFrame."	selectedFrame material: matOver."	^ true.! !!TEditBox methodsFor: 'events' stamp: 'das 5/19/2003 10:59'!pointerMove: pointer	self perform: selectedFrame objectName with: pointer.! !!TEditBox methodsFor: 'events' stamp: 'DPR 1/9/2004 14:05'!pointerUp: pointer	scaleContents ~= 1.0 ifTrue:[		contents scale: scaleContents.		self selectedPoint: selectedPoint.		scaleContents _ 1.0.].	^ true.! !!TEditBox methodsFor: 'initialize' stamp: 'ar 9/30/2004 13:09'!initializeWithContents: conts	| parentFrame extent txtr |	contents _ conts.	box _ contents boundingBox copy.	txtr _ TTexture				new initializeWithFileName: 'box.png'				mipmap: true				shrinkFit: false.	matNorm _ TMaterial new.	matNorm ambientColor: #(0.5 0.7 0.7 0.5) asFloatArray.	matNorm diffuseColor: #(0.5 0.7 0.7 0.5) asFloatArray.	matNorm texture: txtr.	matCorner _ TMaterial new.	matCorner ambientColor: #(0.9 0.9 0.3 0.9) asFloatArray.	matCorner diffuseColor: #(0.9 0.9 0.3 0.9) asFloatArray.	matCorner texture: txtr.	matEdge _ TMaterial new.	matEdge ambientColor: #(1.0 0.4 0.4 0.9) asFloatArray.	matEdge diffuseColor: #(1.0 0.4 0.4 0.9) asFloatArray.	matEdge texture: txtr.	matHilite _ TMaterial new.	matHilite ambientColor: #(1.0 1.0 0.2 0.5) asFloatArray.	matHilite diffuseColor: #(1.0 1.0 0.2 0.5) asFloatArray.	matOver _ TMaterial new.	matOver ambientColor: #(0.2 0.5 1.0 0.8) asFloatArray.	matOver diffuseColor: #(0.2 0.5 1.0 0.8) asFloatArray.	self makeCorners.	self makeEdges.	self makeSides.	parentFrame _ contents parent.	self localTransform: conts localTransform.	self translation: self translation + (self orientation localPointToGlobal:box center).	contents localTransform: B3DMatrix4x4 identity.	contents translation: (box center negated).	extent _ box extent.	box min: (extent/-2.0).	box max: (extent/2.0).	parentFrame replaceChild: contents with: self.	self addChild: conts.	scaleContents _ 1.0.	self update.	^self! !!TEditBox methodsFor: 'initialize' stamp: 'das 2/20/2004 10:39'!makeCorners	| c |	corners _ OrderedCollection ofSize: 8.	1 to: 8 do:[:index |		c _ TCube new.		c material: matCorner.		c solid: false.		corners at: index put: c.		self addChild: c.		c objectOwner: self.		c objectName: #corner.		].! !!TEditBox methodsFor: 'initialize' stamp: 'das 2/20/2004 10:40'!makeEdges	| e |	edges _ OrderedCollection ofSize: 12.	1 to: 12 do:[:index |		e _ TCube new.		e material: matEdge.		e solid: false.		e objectOwner: self.		self addChild: e.		edges at: index put: e.		].! !!TEditBox methodsFor: 'initialize' stamp: 'das 2/20/2004 10:40'!makeSides	| s |	sides _ OrderedCollection ofSize: 6.	1 to: 6 do:[:index |		s _ TRectangle new.		s material: matNorm.		s solid: false.		s objectOwner: self.		s objectName: #side.		self addChild: s.		sides at: index put: s.		].	(sides at: 1)rotationAroundX:-90.	(sides at: 2)rotationAroundX: 90.	(sides at: 3)rotationAroundY:-90.	(sides at: 4)rotationAroundY: 90.	(sides at: 5)rotationAroundY:180.! !!TEditBox methodsFor: 'testing' stamp: 'das 5/19/2003 10:54'!isComponent	^ true.! !!TEditBox methodsFor: 'transform' stamp: 'das 6/28/2003 09:03'!update	| mn mx sz counter cc |	mn _ box min.	mx _ box max.	edgeScale _ (1@1@1)*((mx-mn)max/20.0).	cc _ edgeScale x/2.0.	sz_ (mx - mn max: (cc@cc@cc))/2.0.	mn _ box center - sz.	mx _ box center + sz.	counter _ 1.	{mn x. mx x} do:[:xx |	{mn y. mx y} do:[:yy |	{mn z. mx z} do:[:zz |		(corners at: counter) extent: edgeScale.		(corners at: counter) location: xx@yy@zz.		(corners at: counter) objectName: #resizeBox: .		counter _ counter + 1.		]]].	self updateEdge: (edges at: 1) from: (mn x @ mn y @ (mn z+cc)) to:(mn x @ mn y @ (mx z-cc))		message: #rotateBoxZ: .	self updateEdge: (edges at: 2) from: ((mn x+cc) @ mn y @ mx z) to:((mx x-cc) @ mn y @ mx z)		message: #rotateBoxX: .	self updateEdge: (edges at: 3) from: (mx x @ mn y @ (mx z-cc)) to:(mx x @ mn y @ (mn z+cc))		message: #rotateBoxZ: .	self updateEdge: (edges at: 4) from: ((mx x-cc) @ mn y @ mn z) to:((mn x+cc) @ mn y @ mn z)		message: #rotateBoxX: .	self updateEdge: (edges at: 5) from: (mn x @ mx y @ (mn z+cc)) to:(mn x @ mx y @ (mx z-cc))		message: #rotateBoxZ: .	self updateEdge: (edges at: 6) from: ((mn x+cc) @ mx y @ mx z) to:((mx x-cc) @ mx y @ mx z)		message: #rotateBoxX: .	self updateEdge: (edges at: 7) from: (mx x @ mx y @ (mx z-cc)) to:(mx x @ mx y @ (mn z+cc))		message: #rotateBoxZ: .	self updateEdge: (edges at: 8) from: ((mx x-cc) @ mx y @ mn z) to:((mn x+cc) @ mx y @ mn z)		message: #rotateBoxX: .	self updateEdge: (edges at: 9) from: (mn x @ (mn y+cc) @ mn z) to:(mn x @ (mx y-cc) @ mn z)		message: #rotateBoxY: .	self updateEdge: (edges at: 10) from: (mn x @ (mn y+cc) @ mx z) to:(mn x @ (mx y-cc) @ mx z)		message: #rotateBoxY: .	self updateEdge: (edges at: 11) from: (mx x @ (mn y+cc) @ mx z) to:(mx x @ (mx y-cc) @ mx z)		message: #rotateBoxY: .	self updateEdge: (edges at: 12) from: (mx x @ (mn y+cc) @ mn z) to:(mx x @ (mx y-cc) @ mn z)		message: #rotateBoxY: .	cc_ cc*2.	(sides at: 1) extent: (mx x-mn x-cc)@(mx z - mn z-cc).	(sides at: 1) translation:  box center+(0@mx y@0).	(sides at: 2) extent: (mx x-mn x-cc)@(mx z - mn z-cc).	(sides at: 2) translation:  box center+(0@mn y@0).	(sides at: 3) extent: (mx z-mn z-cc)@(mx y - mn y-cc).	(sides at: 3) translation:  box center+(mn x@0@0).	(sides at: 4) extent: (mx z-mn z-cc)@(mx y - mn y-cc).	(sides at: 4) translation:  box center+(mx x@0@0).	(sides at: 5) extent: (mx x-mn x-cc)@(mx y - mn y-cc).	(sides at: 5) translation:  box center+(0@0@mn z).	(sides at: 6) extent: (mx x-mn x-cc)@(mx y - mn y-cc).	(sides at: 6) translation: box center+(0@0@mx z).	sides do:[:s | s objectName: #dragBox: ].! !!TEditBox methodsFor: 'transform' stamp: 'das 6/28/2003 09:03'!updateEdge: edge from: from to: to message: msg	| scale center |	scale _ (from - to) abs max: edgeScale.	center _ (from + to)/2.0.	edge extent: scale.	edge location: center.	edge objectName: msg.! !!TEscalator methodsFor: 'initialize' stamp: 'ar 9/30/2004 13:09'!initializeWithTreads: nt	treadHeight _ 0.4.	numTreads _ nt.	speed _ 0.02.	texture _ TTexture				new initializeWithFileName: 'tread.bmp'				mipmap: true				shrinkFit: false.	texture uvScale: 2@1.	self makeTreads.	^self		! !!TEscalator methodsFor: 'initialize' stamp: 'das 2/20/2004 10:40'!makeTreads	| tread |	self removeAll.	1 to: numTreads do:[ :i |		tread _ TCube new.		tread extentX:4.0 y:0.1 z:1.0.		tread translationX: 0 y: 0.8 * i z: 0.8*i.		tread singleParent: true.		tread texture: texture.		self addChild: tread.].! !!TEscalator methodsFor: 'testing'!isComponent	^ true.! !!TEscalator methodsFor: 'accessing'!numTreads	^ numTreads.! !!TEscalator methodsFor: 'accessing'!numTreads: nt	numTreads _ nt.	self makeTreads.! !!TEscalator methodsFor: 'accessing'!speed	^ speed.! !!TEscalator methodsFor: 'accessing'!speed: spd	speed _ spd.! !!TEscalator methodsFor: 'stepping' stamp: 'ar 10/4/2004 13:37'!stepAt: now	| trans distance maxD |	distance _ speed * (now - self lastStepTime) asFloat / 20.0.	maxD _ (self frameChildren size * treadHeight).	self frameChildren do:[:tr |		trans _ tr translation.		"adjust translation into range"		trans y: (trans y + distance) \\ maxD.		trans z: (trans z + distance) \\ maxD.		tr translation: trans.	].	! !!TEscalator methodsFor: 'stepping' stamp: 'ar 10/4/2004 13:32'!wantsSteps	^true! !!TEscalator methodsFor: 'render' stamp: 'ar 10/4/2004 13:31'!renderFrame: ogl parent: parent root: root	"self roll."	^ super renderFrame: ogl parent: parent root: root.! !!TLaser methodsFor: 'accessing' stamp: 'das 3/9/2004 13:59'!addAttachment: att	attachment _ att.	self addChild: att.! !!TLaser methodsFor: 'accessing' stamp: 'DPR 5/29/2004 11:39'!color	^color.! !!TLaser methodsFor: 'accessing' stamp: 'DPR 5/29/2004 11:39'!color: col	color _ col copy.	color at: 4 put: 0.35.	glowMaterial ambientColor: color.	glowMaterial diffuseColor: color.	glowPointMaterial ambientColor: color.	glowPointMaterial diffuseColor: color.! !!TLaser methodsFor: 'accessing' stamp: 'das 8/3/2004 10:07'!initialize	| glow |	super initialize.	arrowLength _ 0.5.	radius _ 0.025.	length _ 1.0.	color _ #(5.0 0.0 0.1 0.35).	shaft _ TGroup new.	shaft rotationAroundX: -90.0.	self addChild: shaft.	point _ TGroup new.	point rotationAroundX: -90.0.	point translationX: 0.0 y:0.0 z:arrowLength-length.	self addChild: point.	glowMaterial _ TMaterial new.	glowMaterial ambientColor: color asFloatArray.	glowMaterial diffuseColor: color asFloatArray.	glowMaterial texture:( TTexture				new initializeWithFileName: 'neonGlow.png'				mipmap: true				shrinkFit: false).	glowMaterial textureMode: GLModulate.	glowMaterial cullFace: false.	glowPointMaterial _ TMaterial new.	glowPointMaterial ambientColor: color asFloatArray.	glowPointMaterial diffuseColor: color asFloatArray.	glowPointMaterial texture:( TTexture				new initializeWithFileName: 'neonGlowPoint.png'				mipmap: true				shrinkFit: false).	glowPointMaterial textureMode: GLModulate.	glowPointMaterial cullFace: false.	1 to: 4 do:[ :i |	glow _ TTriangle new.	glow v1: (B3DVector3 x:0 y: arrowLength z:0)			   v2: (B3DVector3 x:radius*5 y: -0.1 z: 0)			   v3: (B3DVector3 x:radius*-5 y: -0.1 z: 0).	glow material: glowPointMaterial.	glow rotationAroundY: 45.0 * i.	point addChild: glow.	glow _ TRectangle new.	glow extent: (radius*6)@(length - arrowLength).	glow location: (B3DVector3 x:0 y: (length-arrowLength)/2.0 z:0.0).	glow material: glowMaterial.	glow rotationAroundY: 45.0 * i.	shaft addChild: glow.].	self solidTree: false.	spell _ nil.	^self! !!TLaser methodsFor: 'accessing' stamp: 'das 6/17/2003 20:00'!length: ln 	ln > 0 ifTrue:[	length _ ln.	point translationX: 0.0 y: 0.0 z: arrowLength - length.	shaft frameChildren do:[ :glow |		glow extent: radius * 6 @ (0.2 + length - arrowLength).		glow location: (B3DVector3 x: 0 y: length - arrowLength / 2.0 z: 0.0).		].].	spell ifNotNil:[spell translation:(B3DVector3 x:0 y: 0 z: length negated).].! !!TLaser methodsFor: 'accessing' stamp: 'das 3/9/2004 14:00'!removeAttachment	self removeChild: attachment.	attachment _ nil.! !!TLaser methodsFor: 'accessing' stamp: 'das 9/14/2002 00:17'!scale: scale	super scale: scale.	arrowLength _ scale * arrowLength.	radius _ scale * radius.	length _ scale * length.! !!TLaser methodsFor: 'accessing' stamp: 'das 2/17/2004 17:27'!setSpell: bool	bool ifTrue:[		spell _ TParticle new initializeWithSize: 30.		spell translation: (B3DVector3 x:0 y:0 z: length negated).		spell setPositionRangeMin: (0@0@0) max: (0@0@0).		spell setVelocityRangeMin:(-0.7@1@-0.7) max:(0.7@3@0.7).		spell setLifetimeRange: (700 to: 1200).		spell startColor: (B3DColor4 r:1.0  g:1.0 b:0.2 a:0.5).		self addChild: spell.		]	ifFalse:[		self removeChild: spell.		spell _ nil.].! !!TLaser methodsFor: 'events' stamp: 'DPR 1/9/2004 14:05'!pointerDown: pointer	self length: pointer selectedDistance.! !!TLaser methodsFor: 'events' stamp: 'DPR 1/9/2004 14:05'!pointerMove: pointer	self length: pointer selectedDistance.! !!TLaser methodsFor: 'events' stamp: 'DPR 1/9/2004 14:05'!pointerUp: pointer	self length: 1.0.! !!TLazySusan methodsFor: 'events'!contents	^ contents.! !!TLazySusan methodsFor: 'events'!contents: cnt	contents ifNotNil:[		self removeChild: contents.].	contents _ cnt.	contents material: matNorm.	contents objectOwner: self.	self addChild: contents.! !!TLazySusan methodsFor: 'events'!handlesKeyboard: pointer	^ true.! !!TLazySusan methodsFor: 'events'!handlesPointerDown: pointer	^ true.! !!TLazySusan methodsFor: 'events'!handlesPointerOver: pointer	^ true.! !!TLazySusan methodsFor: 'events'!keyDown: pointer		| c |	c_pointer event2D keyCharacter.	c _ c asInteger - $0 asInteger.	(c >=0 and: [c<=9]) ifTrue:[contents value: c.].	^ true.! !!TLazySusan methodsFor: 'events' stamp: 'DPR 7/5/2004 19:59'!keyStroke: pointer		| c |	c_pointer event2D keyCharacter.	c _ c asInteger - $0 asInteger.	(c >=0 and: [c<=9]) ifTrue:[contents value: c.].	^ true.! !!TLazySusan methodsFor: 'events' stamp: 'DPR 1/9/2004 14:05'!pointerDown: pointer"	dalpha _ dalpha negated."	pointer event2D shiftPressed ifTrue:[].	selectedPoint _ pointer selectedPoint.	tinyCube translation: selectedPoint.	tinyCube visible: true.	matDown ifNotNil:[		contents material: matDown.		contents materialAlpha: nil.].	cameraNorm _ (pointer camera frameLookAt: self) negated.	selectedNorm _ pointer selectedNormal.	selectedRadiusSquared _ selectedPoint dot: selectedPoint.	self spin: nil.	self localTransform: self localTransform.	^ true.! !!TLazySusan methodsFor: 'events'!pointerEnter: pointer	matOver ifNotNil:[		contents material: matOver.].	^ true.! !!TLazySusan methodsFor: 'events'!pointerLeave: pointer 	matNorm ifNotNil:[		contents material: matNorm.].	^ true! !!TLazySusan methodsFor: 'events' stamp: 'DPR 1/9/2004 14:05'!pointerMove: pointer	| delta trans spfrom spto deltaLoc theta radius |	pointer event2D shiftPressed ifTrue:[		(pointer frame: self pickPlane: selectedPoint normal: cameraNorm) ifTrue:[			delta _ selectedPoint - pointer selectedPoint.			self translation: (self translation - (self orientation localPointToGlobal: delta)).		^ true.]. ^ false.].		" Rotate around the y-axis "		radius _ selectedRadiusSquared sqrt.		(pointer frame: self pickCylinderFrom: (B3DVector3 x: 0.0 y: 100.0 z: 0.0)				to: (B3DVector3 x: 0.0 y: -100.0 z: 0.0) radius: radius)			ifFalse: [ "we are not on the cylinder anymore...."			delta _ 2*radius.			(pointer framePointer row1 dot: (pointer framePosition))  > 0 				ifFalse:[  delta _ delta negated.].			deltaLoc _ pointer framePointer row1 * delta.			(pointer frame: self pickCylinderFrom: (B3DVector3 x: deltaLoc x y: 100.0 z: deltaLoc z)				to: (B3DVector3 x: deltaLoc x y: -100.0 z: deltaLoc z) radius: radius)				ifFalse:[^ false.].			spto _ pointer selectedPoint copy- deltaLoc.			spto x: spto x negated				y: 0				z: spto z negated.			]	ifTrue: [spto _ pointer selectedPoint copy.].	spfrom _ selectedPoint copy.	spfrom y: 0.0.	spfrom normalize.	spto y: 0.0.	spto normalize.	theta _ ((spfrom z * spto x) - (spto z * spfrom x))"/selectedRadiusSquared".	theta < -1.0 ifTrue:[theta_ -1.0].	theta > 1.0 ifTrue:[theta _ 1.0].	theta _ theta arcSin radiansToDegrees/2.0.	lastSpin _ B3DMatrix4x4 identity rotationAroundY: theta.	trans _ self translation.	self translationX: 0.0 y:0.0 z:0.0.	self localTransform: (self localTransform composeWith: lastSpin).	self translation: trans.	self localTransform: localTransform clone.	^ true.! !!TLazySusan methodsFor: 'events'!pointerOver: pointer! !!TLazySusan methodsFor: 'events' stamp: 'DPR 1/9/2004 14:05'!pointerUp: pointer	matNorm ifNotNil:[contents material: matNorm.].	tinyCube visible: false.	self spin: lastSpin.	lastSpin _  nil.	^ true.! !!TLazySusan methodsFor: 'initialize' stamp: 'das 2/20/2004 10:42'!initialize	| matTiny |	super initialize.	matNorm _ TMaterial new.	matNorm ambientColor: #(0.5 0.7 0.7 0.5) asFloatArray.	matNorm diffuseColor: #(0.5 0.7 0.7 0.5) asFloatArray.	matOver _ TMaterial new.	matOver ambientColor: #(0.2 0.5 1.0 0.8) asFloatArray.	matOver diffuseColor: #(0.2 0.5 1.0 0.8) asFloatArray.	matDown _ TMaterial new.	matDown ambientColor: #(0.2 1.0 0.5 1.0) asFloatArray.	matDown diffuseColor: #(0.2 1.0 0.5 1.0) asFloatArray.	tinyCube _ TCube new.	tinyCube extentX: 0.1 y: 0.1 z: 0.1.	tinyCube visible: false.	matTiny _ TMaterial new.	matTiny ambientColor: #(1.0 1.0 0.2 1.0) asFloatArray.	matTiny diffuseColor: #(1.0 1.0 0.2 1.0) asFloatArray.	tinyCube material: matTiny.	tinyCube objectOwner: self.	self addChild: tinyCube.	^self! !!TLazySusan methodsFor: 'testing'!isComponent	^ true.! !!TLazySusan methodsFor: 'accessing'!matDown		^ matDown.! !!TLazySusan methodsFor: 'accessing'!matDown: md		matDown_ md.! !!TLazySusan methodsFor: 'accessing'!matNil	matOver _ nil.	matDown _ nil.	matNorm _ nil.! !!TLazySusan methodsFor: 'accessing'!matNorm		^ matNorm.! !!TLazySusan methodsFor: 'accessing'!matNorm: mn		matNorm _ mn.! !!TLazySusan methodsFor: 'accessing'!matOver		^ matOver.! !!TLazySusan methodsFor: 'accessing'!matOver: mo		matOver_ mo.! !!TLazySusan methodsFor: 'accessing'!spin	^spin! !!TLazySusan methodsFor: 'accessing'!spin: aNumber	spin _ aNumber.! !!TLazySusan methodsFor: 'stepping' stamp: 'DPR 9/3/2002 15:31'!stepAt: msecs	| trans ticks transform |"hack approximation:  spin as many times as there would have been 20 msec ticks in the last time interval"		spin ifNotNil:[ 		ticks _ (msecs // 20) - (self lastStepTime // 20).		trans _ self translation.		self translationX: 0.0 y:0.0 z:0.0.		transform _ self localTransform.		( ticks > 0 ) ifTrue: [ transform _ transform composeWith: spin times: ticks.].		self localTransform: transform.		self translation: trans.	].! !!TLazySusan methodsFor: 'stepping'!wantsSteps	^ true.! !!TLeaf methodsFor: 'construction' stamp: 'das 6/30/2004 11:18'!createPrimitive: ogl" override this method to specify how the object should be constructed."! !!TLeaf methodsFor: 'construction' stamp: 'das 6/30/2004 11:19'!destroyPrimitive: ogl	"override this method for destroying the object"! !!TLeaf methodsFor: 'initialize' stamp: 'das 6/30/2004 11:20'!initialize	super initialize.	childPrimitives _ OrderedCollection new.	parentPrimitives _ OrderedCollection new.	timeStamp _ 0.	valid _ false.	isStatic _ true.! !!TLeaf methodsFor: 'accessing' stamp: 'das 6/30/2004 11:17'!addChild: prim"When we add a new primitive to this object, we need to add all of it's component primitive objects to ensure that their frameNumber is properly updated when we use this. Further, we need to tell the child primitives that they are being used somewhere else so that when they are invalidated, they can invalidate the entire tree."	childPrimitives add: prim.	prim addParent: self.! !!TLeaf methodsFor: 'accessing' stamp: 'das 6/30/2004 11:17'!addParent: parent"see #addChild: comment."	parentPrimitives add: parent.! !!TLeaf methodsFor: 'accessing' stamp: 'das 6/30/2004 11:17'!isStatic		^ isStatic.! !!TLeaf methodsFor: 'accessing' stamp: 'das 6/30/2004 11:17'!setStatic: static		isStatic _ static.! !!TLeaf methodsFor: 'accessing' stamp: 'das 6/30/2004 11:17'!valid	^ valid.! !!TLeaf methodsFor: 'accessing' stamp: 'das 6/30/2004 11:18'!valid: bool	valid _ bool.! !!TForm methodsFor: 'import/export' stamp: 'ar 10/1/2004 15:03'!doneLoading: aLocator	| myForm |	myForm := 	[Form fromFileNamed: aLocator localFileName] on: Error do:[:ex| CroquetData logError: ex. ex return: nil].	myForm ifNil:[^self].	(myForm asFormOfDepth: 32) displayScaledOn: form.	extension = #colorKey ifTrue:[ form colorKeyAlpha.].	self invalidate: form boundingBox.	fileName := aLocator localFileName.! !!TForm methodsFor: 'import/export' stamp: 'ar 10/1/2004 15:10'!postImportFrom: importer	super postImportFrom: importer.	^CroquetGlobals textureAt: locator ifAbsentPut:[		importer ifNotNil:[			locator ifNotNil:[				importer download: locator whenFinishedSend: #doneLoading: to: self.				form fillWhite.			].		].		self invalidate: form boundingBox.		self.].! !!TForm methodsFor: 'import/export' stamp: 'das 7/1/2004 09:12'!prepareToExportOn: exporter	super prepareToExportOn: exporter.	exporter ifNil:[^self].	locator := exporter addFileResource: fileName locator: locator.	locator ifNotNil:[		fileName := nil.		form := Form extent: form extent depth: form nativeDepth bits: nil.	].! !!TForm methodsFor: 'accessing' stamp: 'das 6/30/2004 11:29'!bMipmap	^ bMipmap.! !!TForm methodsFor: 'accessing' stamp: 'das 6/30/2004 11:29'!extension	^ extension.! !!TForm methodsFor: 'accessing' stamp: 'das 6/30/2004 11:29'!extent	^ extent.! !!TForm methodsFor: 'accessing' stamp: 'das 6/30/2004 11:29'!fileName	^ fileName.! !!TForm methodsFor: 'accessing' stamp: 'das 6/30/2004 11:30'!form	^form.! !!TForm methodsFor: 'accessing' stamp: 'ar 10/1/2004 15:04'!invalidate: ur	updateRect _ updateRect ifNil:[ur] ifNotNil:[updateRect quickMerge: ur].! !!TForm methodsFor: 'accessing' stamp: 'das 7/1/2004 09:04'!isLoaded	locator ifNil:[^true].	^fileName notNil! !!TForm methodsFor: 'accessing' stamp: 'das 7/1/2004 09:50'!isStatic: bool	self isStatic = bool ifTrue:[^ self].	isStatic _ bool.! !!TForm methodsFor: 'accessing' stamp: 'das 6/30/2004 11:30'!magFilter	^GLLinear! !!TForm methodsFor: 'accessing' stamp: 'das 6/30/2004 11:30'!minFilter	^bMipmap ifTrue:[GLLinearMipmapLinear] ifFalse:[GLLinear]! !!TForm methodsFor: 'accessing' stamp: 'ar 10/1/2004 08:10'!printOn: aStream	fileName ifNil:[aStream nextPutAll: 'TForm[Dynamic Texture]'] 	ifNotNil:		[aStream nextPutAll: 'TForm[', self fileName, ']'.].	"aStream nextPutAll:'<', self croquetUID asString,'>'."! !!TForm methodsFor: 'accessing' stamp: 'das 7/1/2004 09:30'!resetUpdateRect	updateRect _ nil.! !!TForm methodsFor: 'accessing' stamp: 'das 6/30/2004 11:30'!scaleTexture: oldForm to: scaledSize	| mmForm |	oldForm extent = scaledSize ifTrue:[^oldForm].	mmForm := Form extent: scaledSize depth: 32.	(WarpBlt current toForm: mmForm)		sourceForm: form destRect: mmForm boundingBox;		combinationRule: 3;		cellSize: 2;		warpBits.	^mmForm! !!TForm methodsFor: 'accessing' stamp: 'das 7/1/2004 09:32'!shrinkFit^ bShrinkFit.! !!TForm methodsFor: 'accessing' stamp: 'das 7/1/2004 09:32'!shrinkFit: bSFbShrinkFit _ bSF.! !!TForm methodsFor: 'accessing' stamp: 'ar 10/1/2004 15:28'!target	^GLTexture2d! !!TForm methodsFor: 'accessing' stamp: 'ar 10/1/2004 15:17'!textureForm	^form! !!TForm methodsFor: 'accessing' stamp: 'das 9/2/2004 10:18'!thumb	^ thumb.! !!TForm methodsFor: 'accessing' stamp: 'das 7/8/2004 18:50'!trueExtent	^ form extent.! !!TForm methodsFor: 'accessing' stamp: 'ar 10/1/2004 15:03'!updateAll	self invalidate: form boundingBox.! !!TForm methodsFor: 'accessing' stamp: 'ar 10/1/2004 15:03'!updateArea: aRectangle with: aForm	"the form contains new data to copy into the rectangle area specified"	| fixBlt |	fixBlt := BitBlt toForm: aForm.	fixBlt combinationRule: 40 "fixAlpha:with:".	fixBlt halftoneForm: (Bitmap with: 16rFF000000).	fixBlt destRect: fixBlt clipRect; copyBits.	form copy: aRectangle from: 0@0 in: aForm rule: Form over.	self invalidate: aRectangle.	! !!TForm methodsFor: 'accessing' stamp: 'das 7/1/2004 09:35'!updateRect	^ updateRect.! !!TForm methodsFor: 'initialize' stamp: 'das 7/1/2004 12:50'!calcMemUsed	memUsed _ form extent area*4.	bMipmap ifTrue:[memUsed _ memUsed + (memUsed//3)].! !!TForm methodsFor: 'initialize' stamp: 'das 6/30/2004 11:29'!initialize: fName form: baseForm mipmap: bMM shrinkFit: bSF extension: ext	bMipmap _ bMM.	bShrinkFit _ bSF.	fileName _ fName.	isStatic _ fName isNil.	extension _ ext.	self setupForm: baseForm.! !!TForm methodsFor: 'initialize' stamp: 'das 9/2/2004 09:34'!initialize: fName form: baseForm mipmap: bMM shrinkFit: bSF extension: ext thumb: thmbBool	bMipmap _ bMM.	bShrinkFit _ bSF.	fileName _ fName.	isStatic _ fName isNil.	extension _ ext.	self setupForm: baseForm thumb: thmbBool.! !!TForm methodsFor: 'initialize' stamp: 'ar 9/30/2004 16:34'!setupForm: baseForm	| aForm size tsize |	aForm _ baseForm.	extent _ baseForm extent. "before we scale it down"	aForm depth = 32 ifFalse: [aForm _ aForm asFormOfDepth: 32.].	size _ aForm width @ aForm height.	bShrinkFit		ifTrue:[size := size asSmallerPowerOfTwo]		ifFalse: [size := size asLargerPowerOfTwo].	size = aForm extent ifTrue:[form _ aForm]		ifFalse:[	form := Form extent: size depth: 32.				aForm displayScaledOn: form].tsize_ (size*32 / (size x max: size y)) asLargerPowerOfTwo.thumb _ Form extent:tsize depth:32.aForm displayScaledOn:thumb.	extension = #colorKeyZero ifTrue:[form colorKeyZero. ^self].	extension = #colorKey ifTrue:[form colorKeyAlpha. ^self].	form fixAlpha.	self updateAll.	self calcMemUsed.! !!TForm methodsFor: 'initialize' stamp: 'das 9/2/2004 10:22'!setupForm: baseForm thumb: thmbBool	| aForm size tsize |	aForm _ baseForm.	extent _ baseForm extent. "before we scale it down"	aForm depth = 32 ifFalse: [aForm _ aForm asFormOfDepth: 32.].	size _ aForm width @ aForm height.	bShrinkFit		ifTrue:[size := size asSmallerPowerOfTwo]		ifFalse: [size := size asLargerPowerOfTwo].	size = aForm extent ifTrue:[form _ aForm]		ifFalse:[	form := Form extent: size depth: 32.				aForm displayScaledOn: form].	extension = #colorKeyZero ifTrue:[form colorKeyZero. ^self].	extension = #colorKey ifTrue:[form colorKeyAlpha. ^self].	form fixAlpha.thmbBool ifTrue:[	tsize_ (size*32/size max) asLargerPowerOfTwo.	thumb _ Form extent:tsize depth:32.	form displayScaledOn:thumb.	].	self updateAll.	self calcMemUsed.! !!TLife methodsFor: 'accessing'!cellX	^ cellX.! !!TLife methodsFor: 'accessing'!cellX: x cellY: y	cellX _ x.	cellY _ y.! !!TLife methodsFor: 'accessing'!cellY	^ cellY.! !!TLife methodsFor: 'accessing'!texture	^ texture.! !!TLife methodsFor: 'accessing'!texture: txtr	texture_ txtr.! !!TLife methodsFor: 'render' stamp: 'das 7/1/2004 00:35'!render: ogl	| centerX centerY scale  |	texture ifNotNil:[texture enable: ogl].	centerX _ cellX/2.0.	centerY _ cellY/2.0.	scale _ cube scale.	changed ifTrue:[ 		matrix _ Matrix[cellX, cellY] define:[:i :j | (2 atRandom - 1)].		matrix2 _ Matrix[cellX, cellY] fill: 0.		changed _ false.]	ifFalse:		[		matrix2[(2 to: cellX-1), (2 to: cellY-1)] _ [:i :j | matrix[(i-1 to: i+1), (j-1 to: j+1)]sum sum-matrix[i,j]].		matrix[(2 to: cellX-1), (2 to: cellY-1)] _ [:i :j | matrix2[i,j]=3 			ifTrue:[1] 			ifFalse:[matrix2[i, j]=2 				ifTrue:[matrix2[i,j]]				ifFalse:[0]]].		matrix[1,#all] _ matrix[(cellX-1),#all].		matrix[cellX,#all] _ matrix[2,#all].		matrix[#all,1] _ matrix[#all, (cellY-1)].		matrix[#all,cellY] _ matrix[#all,2].		].	1 to: cellX do:[ :i |		1 to: cellY do: [ :j |			matrix[i ,j] = 1 ifTrue:[ 				cube locationX: scale*(i-centerX) y: scale*(j-centerY) z:0.0. 				cube render.]]].	texture ifNotNil:[self texture disable: ogl.]! !!TLight methodsFor: 'accessing'!ambientColor	^ ambientColor.! !!TLight methodsFor: 'accessing'!ambientColor: color	ambientColor _ color.! !!TLight methodsFor: 'accessing'!diffuseColor	^ diffuseColor.! !!TLight methodsFor: 'accessing'!diffuseColor: color	diffuseColor _ color.! !!TLight methodsFor: 'accessing' stamp: 'das 9/4/2002 14:53'!distance	^ distance.! !!TLight methodsFor: 'accessing' stamp: 'das 9/4/2002 14:53'!distance: dist	distance _ dist.! !!TLight methodsFor: 'accessing'!global	^ local not.! !!TLight methodsFor: 'accessing'!global: boolGlobal	local _ boolGlobal not.! !!TLight methodsFor: 'accessing'!local	^ local! !!TLight methodsFor: 'accessing'!local: boolLocal	local _ boolLocal.! !!TLight methodsFor: 'accessing'!specularColor	^ specularColor.! !!TLight methodsFor: 'accessing'!specularColor: color	specularColor _ color.! !!TLight methodsFor: 'accessing'!spotCutoff	^ spotCutoff.! !!TLight methodsFor: 'accessing'!spotCutoff: sc	spotCutoff _ sc.! !!TLight methodsFor: 'accessing'!spotDirection	^ spotDirection.! !!TLight methodsFor: 'accessing'!spotDirection: sd	spotDirection _ sd.! !!TLight methodsFor: 'accessing'!spotExponent	^ spotExponent.! !!TLight methodsFor: 'accessing'!spotExponent: se	spotExponent _ se.! !!TLight methodsFor: 'accessing'!type	^ type.! !!TLight methodsFor: 'accessing' stamp: 'das 9/5/2002 17:09'!type: tp	| |		tp = type ifTrue:[ ^ self ].	type _ tp."	pos _ self positionV."	tp = #directional ifTrue:[		position _ #(0 -1.0 0 0) asFloatArray.		] 		ifFalse:[	tp = #point ifTrue:[		position _ #(0 0 0 1) asFloatArray.		] ifFalse:[	tp = #spot ifTrue:[		position _ #(0 -1.0 0 1) asFloatArray.	]]]."	self positionV: pos."	self removeAll.	renderObject _ nil.	! !!TLight methodsFor: 'render' stamp: 'das 3/12/2004 13:39'!enable: ogl index: lNum" lNum initial value must be 1."	| glLight |	glLight _ GLLight0 + lNum - 1.	ogl glPushMatrix;		glMultMatrixf: self globalTransform transposed;		glLightfv: glLight with: GLPosition with: position.	type = #spot ifTrue:[ 		ogl glLightfv: glLight with: GLSpotDirection with: #(0 1.0 0)asFloatArray;			glLightfv: glLight with: GLSpotExponent with: spotExponent;			glLightfv: glLight with: GLSpotCutoff with: spotCutoff.		] ifFalse:[		ogl glLightf: glLight with: GLSpotCutoff with: 180.0.		"ogl glLightfv: glLight with: GLSpotDirection with: #(0 0 0)asFloatArray;			glLightf: glLight with: GLSpotExponent with: 0.0."		].	ogl glLightfv: glLight with: GLAmbient with: ambientColor;		glLightfv: glLight with: GLDiffuse with: diffuseColor;		glLightfv: glLight with: GLSpecular with: specularColor;		glEnable: glLight;		glPopMatrix.! !!TLight methodsFor: 'render' stamp: 'das 3/12/2004 13:39'!enable: ogl index: lNum scaled: scale" lNum initial value must be 1."	| glLight |	glLight _ GLLight0 + lNum - 1.	ogl glPushMatrix;		glMultMatrixf: self globalTransform transposed;		glLightfv: glLight with: GLPosition with: position;		glLightfv: glLight with: GLAmbient with: (ambientColor*scale);		glLightfv: glLight with: GLDiffuse with: (diffuseColor*scale);		glLightfv: glLight with: GLSpecular with: (specularColor*scale);		glEnable: glLight;		glPopMatrix.! !!TLight methodsFor: 'render' stamp: 'das 3/12/2004 13:39'!render: ogl	ogl glPushMatrix.	ogl 		glRotatef: 270.0 		with: 1.0		with: 0.0		with: 0.0.	"	local ifTrue:[]."	renderObject ifNil:[		type = #point ifTrue:[ self renderPoint].			type = #directional ifTrue:[ self renderDirectional].		type = #spot ifTrue:[ self renderSpot]]. 	ogl glPopMatrix.! !!TLight methodsFor: 'render' stamp: 'das 3/12/2004 13:39'!renderAlpha: ogl	"self render: space."! !!TLight methodsFor: 'render' stamp: 'das 2/20/2004 10:42'!renderDirectional	| part |	" This renders a visual representation of a directional light. This is used to orient the light."	renderObject _ TGroup new.	renderObject objectOwner: nil.	part _ TCylinder new.	part topRadius: 0.0.	part baseRadius: 0.5.	part height: 0.5.		part objectOwner: nil.	renderObject addChild: part.	part _ TCylinder new.	part baseRadius: 0.25.	part topRadius: 0.25.	part height: 0.5.	part translationX: 0.0 y: -0.5 z:0.0.	part objectOwner: nil.	renderObject addChild: part.	self addChild: renderObject.! !!TLight methodsFor: 'render' stamp: 'das 2/20/2004 10:42'!renderPoint	" This renders a visual representation of a point light source. This is used to orient the light."	renderObject _ TSphere new.	renderObject objectOwner: self.	renderObject radius: 0.5.	renderObject objectOwner: self objectOwner.	self addChild: renderObject.! !!TLight methodsFor: 'render' stamp: 'das 2/20/2004 10:42'!renderSpot	| part |	" This renders a visual representation of a spot light. This is used to orient the light."	renderObject _ TGroup new.	renderObject objectOwner: nil.	part _ TCylinder new.	part objectOwner: nil.	part topRadius: 0.5.	part baseRadius: 0.25.	part height: 0.75.			renderObject addChild: part.	part _ TCylinder new.	part baseRadius: 0.25.	part topRadius: 0.25.	part height: 0.5.	part translationX: 0.0 y: -0.5 z:0.0.	part objectOwner: nil.	renderObject addChild: part.	self addChild: renderObject.! !!TLight methodsFor: 'events' stamp: 'das 6/13/2002 13:56'!handlesKeyboard: ptr	^true.! !!TLight methodsFor: 'events' stamp: 'das 9/5/2002 11:29'!keyDown: ptr	| c |	c _ ptr event2D keyCharacter.	c = $p ifTrue:[ self type: #point.].	c = $d ifTrue:[ self type: #directional.].	c = $s ifTrue:[ self type: #spot.].! !!TLight methodsFor: 'events' stamp: 'DPR 7/5/2004 19:59'!keyStroke: ptr	| c |	c _ ptr event2D keyCharacter.	c = $p ifTrue:[ self type: #point.].	c = $d ifTrue:[ self type: #directional.].	c = $s ifTrue:[ self type: #spot.].! !!TLight methodsFor: 'initialize' stamp: 'das 2/17/2004 15:30'!initialize	"default is a directional light - if w is non-zero then it is a positional"	super initialize.		self singleParent: true.	position _ #(0 -1.0 0 0.0) asFloatArray.	ambientColor _ #(0.7 0.7 0.7 1.0) asFloatArray.	diffuseColor _ #(0.7 0.7 0.7 0.5) asFloatArray.	specularColor _ #(0.5 0.5 0.5 0.5) asFloatArray.	spotDirection _ #(0.0 0.0 -1.0) asFloatArray.	spotExponent _ 10.0.	spotCutoff _ 15.0.	type _ #directional.	local _ false.	^self! !!TLight methodsFor: 'testing' stamp: 'das 6/13/2002 13:55'!isComponent	^ true.! !!TLight methodsFor: 'testing'!isLight	^ true.! !!TLink methodsFor: 'accessing' stamp: 'das 8/28/2002 08:14'!addForce: f	mass ifNotNil:[	force _ force + f.].! !!TLink methodsFor: 'accessing' stamp: 'das 8/25/2002 10:59'!gravity: g	gravity _ g.! !!TLink methodsFor: 'accessing' stamp: 'das 8/26/2002 12:11'!kSpring	^ kSpring.! !!TLink methodsFor: 'accessing' stamp: 'das 8/26/2002 12:12'!kSpring: k	kSpring _ k.! !!TLink methodsFor: 'accessing' stamp: 'das 8/29/2002 09:10'!link		^ link.! !!TLink methodsFor: 'accessing' stamp: 'das 8/25/2002 10:59'!link: lnk	link _ lnk.! !!TLink methodsFor: 'accessing' stamp: 'das 8/26/2002 12:08'!mass	^ mass.! !!TLink methodsFor: 'accessing' stamp: 'das 8/26/2002 12:09'!mass: m	mass _ m.! !!TLink methodsFor: 'events' stamp: 'das 8/25/2002 09:49'!handlesPointerDown: pointer	^ true.! !!TLink methodsFor: 'events' stamp: 'DPR 1/9/2004 14:05'!pointerDown: pointer	selectedPoint _ pointer selectedPoint.	cameraNorm _ (pointer camera frameLookAt: self) negated.	self localTransform: self localTransform.	^ true.! !!TLink methodsFor: 'events' stamp: 'DPR 1/9/2004 14:05'!pointerMove: pointer	| delta |	(pointer frame: self pickPlane: selectedPoint normal: cameraNorm) ifTrue:[		delta _ selectedPoint - pointer selectedPoint.		self translation: (self translation - (self orientation localPointToGlobal: delta)).		^ true.]. ! !!TLink methodsFor: 'initialize' stamp: 'ar 9/30/2004 13:09'!initializeWithFrame: frame	frame objectOwner: self.	self addChild: frame.	mass _ 1.5.	gravity _ B3DVector3 x: 0 y:-1.0 z:0.	force _ B3DVector3 x:0 y:0 z:0.	velocity _ B3DVector3 x: 0 y: 0 z: 0.	springLength _ 0.1.	deltaTime _ 0.0.	kSpring _ 200.0.	^self! !!TLink methodsFor: 'testing' stamp: 'das 8/25/2002 09:48'!isComponent	^ true.! !!TLink methodsFor: 'render' stamp: 'das 5/10/2004 15:39'!renderFrame: ogl parent: parent root: root	| delta dt |	mass ifNotNil:[		dt _ deltaTime < 20 ifTrue:[deltaTime] ifFalse:[20].		velocity _ velocity + ((force/ mass) * dt).		delta _ velocity * dt.		velocity _ velocity * 0.96.		self translation: (self translation + delta).		force _ B3DVector3 new.].	^ super renderFrame: ogl parent: parent root: root.! !!TLink methodsFor: 'render' stamp: 'das 3/12/2004 13:39'!renderFrame: ogl space: space	| delta dt |	mass ifNotNil:[		dt _ deltaTime < 20 ifTrue:[deltaTime] ifFalse:[20].		velocity _ velocity + ((force/ mass) * dt).		delta _ velocity * dt.		velocity _ velocity * 0.96.		self translation: (self translation + delta).		force _ B3DVector3 new.].	^ super renderFrame: ogl space: space.! !!TLink methodsFor: 'stepping' stamp: 'DPR 2/18/2004 13:51'!step	| springForce tv tl dv |	deltaTime _ self stepTime/2500.0. gravity _ B3DVector3 x:0 y:-5 z:0.kSpring _ 500.0.	link ifNotNil:[		mass ifNotNil:[ self addForce: gravity*mass. ].		tv _ (link globalPosition - self globalPosition).		tl _ tv length.		dv _ tv * (1-(springLength/tl)).		springForce _ dv * kSpring.		self addForce: springForce.		link addForce: springForce negated.		].				! !!TLink methodsFor: 'stepping' stamp: 'das 8/29/2002 09:11'!stepAt: msecs	| springForce tv tl dv |	deltaTime _ msecs - self lastStepTime/2500.0. gravity _ B3DVector3 x:0 y:-5 z:0.kSpring _ 500.0.	link ifNotNil:[		mass ifNotNil:[ self addForce: gravity*mass. ].		tv _ (link globalPosition - self globalPosition).		tl _ tv length.		dv _ tv * (1-(springLength/tl)).		springForce _ dv * kSpring.		self addForce: springForce.		link addForce: springForce negated.		].				! !!TLink methodsFor: 'stepping' stamp: 'das 8/25/2002 09:56'!wantsSteps	^ true.! !!TLoad3DSMax methodsFor: 'convert'!aliasIndexToArray: ai	| alias |	alias _ IntegerArray ofSize: ai size.	1 to: ai size do:[ :i |		(ai at: i) ifNil:[alias at: i put: 0.] 				ifNotNil:[alias at: i put: (ai at: i).].		].	^ alias.! !!TLoad3DSMax methodsFor: 'convert' stamp: 'yo 9/20/2003 11:43'!basicCalcFaceNormals"Calculate the normal for each primitive (simple vertex index) face."	| v1 v2 v count faceNormals |	faceNormals _ B3DVector3Array  new: (faces size//3).	count _ 1.	1 to: faceNormals size do:[   :i |		v1 _ (vertices at:(faces at: count)+1) - (vertices at: (faces at: count+1)+1).		v2 _ (vertices at:(faces at: count+1)+1) - (vertices at: (faces at: count+2)+1).		v _ v1 cross: v2.		v length = 0.0 ifFalse:[ v_ v normalized.].		faceNormals at: i put: v.		count _ count+3.].	^ faceNormals.! !!TLoad3DSMax methodsFor: 'convert' stamp: 'yo 9/20/2003 11:44'!basicCalcVertexNormals: faceNormals"Calculate the normal for each face vertex."	| vertexNormals vertexCount iCount faceIndex1 faceIndex2 fv1 fv2 edges index1 |"Initialize the vertexNormals with the owning face normal."	vertexNormals _ B3DVector3Array  new: (faces size).	vertexCount _ IntegerArray new: (faces size).	iCount _ 1.	1 to: faces size by: 3 do:[ :i |		vertexNormals at: i put: (faceNormals at: iCount).		vertexNormals at: i+1 put: (faceNormals at: iCount).		vertexNormals at: i+2 put: (faceNormals at: iCount).		iCount _ iCount+1.]."vertexCount is set to zero at the moment. It should be 1, but we know that it is always 1 greater than whatever our end result will be below."	"self halt."	1 to: faces size do:[:i |		i+1 to: faces size do:[:j |			(faces at: i) = (faces at: j) ifTrue:[				faceIndex1 _ 1 + ((i-1)//3).				faceIndex2 _ 1 + ((j-1)//3).				(self testNorm: (faceNormals at: faceIndex1) norm: (faceNormals at: faceIndex2))					ifTrue:[						vertexNormals at: i put: ((vertexNormals at: i) + (faceNormals at: faceIndex2)).						vertexCount at: i put: 1+ (vertexCount at: i).						vertexNormals at: j put: ((vertexNormals at: j) + (faceNormals at: faceIndex1)).						vertexCount at: j put: 1+ ( vertexCount at: j).						].				].			].		].false ifTrue:["Build an edge dictionary"	edges _ Dictionary new.	1 to: faces size by: 3 do:[ :i |		edges at: (faces at:i)@(faces at:i+1) put: i@(i+1).		edges at: (faces at: i+1)@(faces at: i+2) put: (i+1)@(i+2).		edges at: (faces at: i+2)@(faces at: i) put: (i+2)@i]."Now match edges"	faceIndex2 _ 1.	1 to: faces size by: 3 do:[ :i |		index1 _ edges at: ((faces at:i+1)@(faces at:i)) ifAbsent:[ nil ].		index1 ifNotNil:[ fv1 _ i+1. fv2 _ i.] ifNil:[			index1 _ edges at: ((faces at: i+2)@(faces at: i+1)) ifAbsent:[ nil. ].			index1 ifNotNil:[ fv1 _ i+2. fv2 _ i+1.] ifNil:[				index1 _ edges at: ((faces at: i)@ (faces at: i+2)) ifAbsent:[ nil. ].				index1 ifNotNil:[fv1 _ i. fv2 _ i+2.].			].].		index1 ifNotNil:[			faceIndex1 _ 1+((index1 x-1)//3).			(self testNorm: (faceNormals at: faceIndex1) norm:(faceNormals at: faceIndex2))				ifTrue:[					vertexNormals at: fv1 put: ((vertexNormals at: fv1) + (faceNormals at: faceIndex1)).					vertexNormals at: fv2 put: ((vertexNormals at: fv2) + (faceNormals at: faceIndex1)).					vertexCount at: fv1 put: 1+(vertexCount at: fv1).					vertexCount at: fv2 put: 1+(vertexCount at: fv2).					fv1 _ index1 x.					fv2 _ index1 y.					vertexNormals at: fv1 put: ((vertexNormals at: fv1) + (faceNormals at: faceIndex2)).					vertexNormals at: fv2 put: ((vertexNormals at: fv2) + (faceNormals at: faceIndex2)).].					vertexCount at: fv1 put: 1+(vertexCount at: fv1).					vertexCount at: fv2 put: 1+(vertexCount at: fv2).				].								faceIndex2 _ faceIndex2 + 1.		].]." Calculate the average normal and normalize."	1 to: vertexNormals size do:[ :i |		(vertexNormals at: i) length = 0.0 ifFalse:[		vertexNormals at:i put: ((vertexNormals at: i)/(1.0 + (vertexCount at: i)))normalized.].].	^ vertexNormals.! !!TLoad3DSMax methodsFor: 'convert' stamp: 'ar 9/30/2004 19:24'!calcFaceNormals"Calculate the normal for each primitive (simple vertex index) face."	| faceNormals count v1 v2 v |	faceNormals _ B3DVector3Array  new: (faces size//3).	(self primCalcFaceNormals: vertices faces: faces faceNormals: faceNormals) 		ifNotNil:[^faceNormals].	count _ 1.	1 to: faceNormals size do:[   :i |		v1 _ (vertices at:(faces at: count)+1) - (vertices at: (faces at: count+1)+1).		v2 _ (vertices at:(faces at: count+1)+1) - (vertices at: (faces at: count+2)+1).		v _ v1 cross: v2.		v length = 0.0 ifFalse:[ v_ v normalized.].		faceNormals at: i put: v.		count _ count+3.].	^ faceNormals.! !!TLoad3DSMax methodsFor: 'convert' stamp: 'das 4/4/2002 03:29'!calcTextureVertices" This is a somewhat naive fix to the texture transform issue. Be aware that I am not checking for shared texture coordinates. This means that if two textures share the same uv coordinate before the transform but not after, we have a problem. I don't know what 3DS Max does, so I will deal with it when I find the problem."	| tv ml counter tv2 fvi avi ai found oc |	ml _ materialList at: 1+ materialRef.	ml subMaterialList ifNotNil:[ ml _ ml subMaterialList.] 	ifNil:[		oc _ OrderedCollection new.		oc add: ml.		ml _ oc.		].	tv _ B3DVector2Array ofSize: tfaces size.	1 to: tfaces size do:[ :i |		counter _ 1+(i-1//3).				tv at: i put: (self textureTransform: (tvertices at: 1+(tfaces at: i)) 			material: (ml at: 1+((matIndex at: counter)\\ml size))).		].	tv2 _ OrderedCollection ofSize: tvertices size.	ai _ OrderedCollection ofSize: tvertices size.	1 to: tfaces size do:[ :i | 		found _ false.		fvi _ 1+ (tfaces at: i).		avi _ fvi.		[ found ] whileFalse:[			"Anything already in this slot?"			(tv2 at: avi) ifNil:[				tv2 at: avi put: (tv at:i).				tfaces at: i put: avi -1.				found _ true.].			"Is it the same thing we already have?"			found ifFalse:[				(tv2 at: avi) = ( tv at: i) ifTrue:[					tfaces at: i put: avi-1.					found _ true.].].			"There is something already there, but it is the wrong thing, we need an alias"			found ifFalse:[				(ai at: avi) ifNil:[					ai add: nil.					tv2 add: (tv at: i).					tfaces at: i put: (tv2 size -1). "index of new element - 1"					ai at: avi put: tv2 size. "pointer to new element"					found _ true.] 				"The alias was full, check the next alias."				ifNotNil:[ avi _ ai at: avi.].].].].	" Convert array."	tvertices _ B3DVector2Array ofSize: tv2 size.	1 to: tv2 size do:[ :i | (tv2 at: i) ifNotNil:[ tvertices at: i put: (tv2 at: i).].].				! !!TLoad3DSMax methodsFor: 'convert' stamp: 'ar 9/30/2004 19:25'!calcVertexNormals: faceNormals"Calculate the normal for each face vertex."	| vertexNormals vertexCount iCount faceIndex1 faceIndex2 edges index1 fv1 fv2 |"Initialize the vertexNormals with the owning face normal."	vertexNormals _ B3DVector3Array  new: (faces size).	vertexCount _ IntegerArray new: (faces size).	(self primCalcVertexNormals: vertexNormals vertexCount: vertexCount faces: faces faceNormals: faceNormals shadeAngleCos: shadeAngleCos)		ifNotNil:[^vertexNormals].	vertexNormals _ B3DVector3Array  new: (faces size).	vertexCount _ IntegerArray new: (faces size).	iCount _ 1.	1 to: faces size by: 3 do:[ :i |		vertexNormals at: i put: (faceNormals at: iCount).		vertexNormals at: i+1 put: (faceNormals at: iCount).		vertexNormals at: i+2 put: (faceNormals at: iCount).		iCount _ iCount+1.]."vertexCount is set to zero at the moment. It should be 1, but we know that it is always 1 greater than whatever our end result will be below."	1 to: faces size do:[:i |		i+1 to: faces size do:[:j |			(faces at: i) = (faces at: j) ifTrue:[				faceIndex1 _ 1 + ((i-1)//3).				faceIndex2 _ 1 + ((j-1)//3).				(self testNorm: (faceNormals at: faceIndex1) norm: (faceNormals at: faceIndex2))					ifTrue:[						vertexNormals at: i put: ((vertexNormals at: i) + (faceNormals at: faceIndex2)).						vertexCount at: i put: 1+ (vertexCount at: i).						vertexNormals at: j put: ((vertexNormals at: j) + (faceNormals at: faceIndex1)).						vertexCount at: j put: 1+ ( vertexCount at: j).						].				].			].		].false ifTrue:["Build an edge dictionary"	edges _ Dictionary new.	1 to: faces size by: 3 do:[ :i |		edges at: (faces at:i)@(faces at:i+1) put: i@(i+1).		edges at: (faces at: i+1)@(faces at: i+2) put: (i+1)@(i+2).		edges at: (faces at: i+2)@(faces at: i) put: (i+2)@i]."Now match edges"	faceIndex2 _ 1.	1 to: faces size by: 3 do:[ :i |		index1 _ edges at: ((faces at:i+1)@(faces at:i)) ifAbsent:[ nil ].		index1 ifNotNil:[ fv1 _ i+1. fv2 _ i.] ifNil:[			index1 _ edges at: ((faces at: i+2)@(faces at: i+1)) ifAbsent:[ nil. ].			index1 ifNotNil:[ fv1 _ i+2. fv2 _ i+1.] ifNil:[				index1 _ edges at: ((faces at: i)@ (faces at: i+2)) ifAbsent:[ nil. ].				index1 ifNotNil:[fv1 _ i. fv2 _ i+2.].			].].		index1 ifNotNil:[			faceIndex1 _ 1+((index1 x-1)//3).			(self testNorm: (faceNormals at: faceIndex1) norm:(faceNormals at: faceIndex2))				ifTrue:[					vertexNormals at: fv1 put: ((vertexNormals at: fv1) + (faceNormals at: faceIndex1)).					vertexNormals at: fv2 put: ((vertexNormals at: fv2) + (faceNormals at: faceIndex1)).					vertexCount at: fv1 put: 1+(vertexCount at: fv1).					vertexCount at: fv2 put: 1+(vertexCount at: fv2).					fv1 _ index1 x.					fv2 _ index1 y.					vertexNormals at: fv1 put: ((vertexNormals at: fv1) + (faceNormals at: faceIndex2)).					vertexNormals at: fv2 put: ((vertexNormals at: fv2) + (faceNormals at: faceIndex2)).].					vertexCount at: fv1 put: 1+(vertexCount at: fv1).					vertexCount at: fv2 put: 1+(vertexCount at: fv2).				].								faceIndex2 _ faceIndex2 + 1.		].]." Calculate the average normal and normalize."	1 to: vertexNormals size do:[ :i |		(vertexNormals at: i) length = 0.0 ifFalse:[		vertexNormals at:i put: ((vertexNormals at: i)/(1.0 + (vertexCount at: i)))normalized.].].	^ vertexNormals.! !!TLoad3DSMax methodsFor: 'convert' stamp: 'das 4/4/2002 01:40'!facesToFaceGroup: fcs materials: mi	| groups count mIndex gIndex |	" This method creates an OrderedCollection of alternating material indices followed by the face group."	groups _ OrderedCollection new.	count _ 1.	1 to: fcs size by: 3 do:[ :i |		mIndex _ 1+ (mi at: count).		count _ count+1.		gIndex _ 0.		" Which material group do I belong to?"		1 to: groups size by: 2 do:[ :j |			(mIndex = (groups at: j)) ifTrue:[gIndex _j].].		"No such material group, we need to add a new one."		gIndex = 0 ifTrue:[ 			groups add: mIndex. 			groups add: OrderedCollection new. 			gIndex _ groups size -1.].		gIndex _ gIndex+1.		(groups at: gIndex) add: (fcs at:i).		(groups at: gIndex) add: (fcs at: i+1).		(groups at: gIndex) add: (fcs at: i+2).].				1 to: groups size by: 2 do:[ :i |		groups at: i+1 put:(groups at: i+1) asIntegerArray.].	^ groups.! !!TLoad3DSMax methodsFor: 'convert' stamp: 'das 10/22/2002 14:30'!makeHelperObject: tree	| field fieldName name start end |	1 to: tree size by: 2 do:[ :i |		fieldName _ tree at: i.		field _ tree at: i+1.		fieldName = #TNodeName ifTrue:[			start _ field findDelimiters: '"' startingAt: 1.			end _ field findDelimiters: '"' startingAt: start+1.			name _ (field copyFrom: start+1 to: end-1).			].		fieldName = #TNodeTm ifTrue:[			transform _ self makeTransform: field.			].		].	^ name.		! !!TLoad3DSMax methodsFor: 'convert' stamp: 'ar 9/30/2004 19:24'!primCalcFaceNormals: argVertices faces: argFaces faceNormals: argFaceNormals	<primitive: 'primitiveCalcFaceNormals' module: 'TLoad3DSMaxPlugin'>	^ nil	"TLoad3DSMaxPlugin doPrimitive: 'primCalcFaceNormals:faces:faceNormals:' withArguments: {argVertices. argFaces. argFaceNormals}."! !!TLoad3DSMax methodsFor: 'convert' stamp: 'ar 9/30/2004 19:25'!primCalcVertexNormals: argVertexNormals vertexCount: argVertexCount faces: argFaces faceNormals: argFaceNormals shadeAngleCos: shadeAngleCosValue	<primitive: 'primitiveCalcVertexNormals' module: 'TLoad3DSMaxPlugin'>	^ nil	"TLoad3DSMaxPlugin doPrimitive: 'primCalcVertexNormals:vertexCount:faces:faceNormals:shadeAngleCos:' withArguments: {argVertexNormals. argVertexCount. argFaces. argFaceNormals. shadeAngleCosValue}."! !!TLoad3DSMax methodsFor: 'convert' stamp: 'das 2/17/2004 15:45'!reconstruct"This method figures out how to reconstruct the mesh based solely upon the face information - material, vertex indices, vertex normals, and texture indices. It creates a group of sub-meshes which are then properly rendered. I realize that this could and should be broken down into many smaller methods, but I don't want to deal with creating throw-away classes that would only be used to help this method. On the other hand, I am very aware that there is a limit on the actual size of a method, so I might have to anyway."	| faceNormals vertexFaceNormals vi ai ti mi vNorm fvi tvi avi mvi counter found faceGroup mm |" First, make the face normals and vertex normals. "	faceNormals _ self calcFaceNormals.	vertexFaceNormals _ self calcVertexNormals: faceNormals.	"self halt."	tfaces ifNotNil:[self calcTextureVertices.]."Faces now include the following information:	- 1 Material index - matIndex	- 3 Vertex indices - faces	- 3 Vertex normals - vertexFaceNormals	- 3 texture indices - tfacesWe build a new group of submeshes.We first look at sub-groups according to materials. Then we compare vertices to build the final face tables.A vertex is considered equal iff the index, normal, and texture index are identical. Otherwise, it must be aliased."vi _ OrderedCollection ofSize: vertices size.ai _ OrderedCollection ofSize: vertices size.ti _ OrderedCollection ofSize: vertices size.mi _ OrderedCollection ofSize: vertices size.vNorm _ OrderedCollection ofSize: vertices size.1 to: faces size do:[ :i |	found _ false.	fvi _ 1+ (faces at: i).	avi _ fvi.	tfaces ifNotNil:[tvi _ 1 + (tfaces at: i).] ifNil:[tvi _ 1.].	counter _ 1+(i-1//3).	mvi _ matIndex at: counter.	[found] whileFalse:[		"Anything already in this slot?"		(vi at: avi) ifNil:[			vi at: avi put: fvi.			ti at: avi put: tvi.			vNorm at: avi put: (vertexFaceNormals at: i).			mi at: avi put: mvi.			found _ true.].		"Is what is there already the same as whet we have?"		found ifFalse:[			((vi at: avi) = fvi and:[				(ti at: avi) = tvi and:[					(mi at: avi) = mvi and:[						self compare: (vNorm at: avi) and: (vertexFaceNormals at: i) within:0.0001.]]]) ifTrue:[							faces at: i put: (avi-1).							found _ true.].].		" There is something already there, but it is the wrong thing, we need an alias."		found ifFalse:[			(ai at: avi) ifNil:[				ai add: nil.				vi add: fvi.				ti add: tvi.				vNorm add: (vertexFaceNormals at: i).				mi add: mvi.				ai at: avi put: vi size.				faces at: i put: (vi size)-1.				found _ true.] ifNotNil:[					avi _ ai at: avi.].].].]."The following commented out code fragment does the naive job of just adding all of the face information without looking for redundency. It is commented out because IT SHOULD NOT BE USED!! It is here just for reference, because someday, someone will get totally lost in what is going on here and this is a quick and dirty way to simplify the problem. The results are wrong of course, but at least it is a start.-------1 to: faces size do:[ :i |							vi add: 1+ (faces at:i).	tfaces ifNotNil:[ ti add: 1 +( tfaces at: i). ] ifNil:[ ti add: 1.].	vNorm add: (vertexFaceNormals at: i).	faces at: i put: i-1.].-------""Now clean up the arrays and convert them. The arrays I need to construct here are:	vertexArray - the actual 3D vertex array including aliases.	aliasArray - the alias index array - this will be used for vector based animations	vertexNorms - the vertex normals	textureArray - the u,v texture coordinate arraywhich are all the same length, and	faceGroup - the collection of all faceGroups - check the associated material for alphas.	"	vi _ self vertexIndexToArray: vi.	ai _ self aliasIndexToArray: ai.	vNorm _ self vertNormToArray: vNorm.	tfaces ifNotNil:[ti _ self textureIndexToArray: ti.] ifNil:[ ti _ nil.].		faceGroup _ self facesToFaceGroup: faces materials: matIndex.	mm _ TMesh new initializeWithVertices: vi alias: ai norms: vNorm textureUV: ti faceGroups: faceGroup material: (materialRef ifNotNil:[materialList at: 1+materialRef]).    	mm localTransform: self localTransform.	mm objectName: self objectName.	^ mm.! !!TLoad3DSMax methodsFor: 'convert'!textureIndexToArray: ti	|textureArray|	textureArray _ B3DVector2Array ofSize: ti size.	1 to: ti size do:[ :i |		(ti at: i) ifNotNil:[			textureArray at: i put: (tvertices at: (ti at:i)).]		ifNil:[			textureArray at: i put: B3DVector2 new.].		].	^ textureArray.! !!TLoad3DSMax methodsFor: 'convert' stamp: 'das 4/4/2002 02:05'!textureTransform: tuv material: mat	| uv |	uv _ tuv.	mat texture ifNotNil:[		"Magic mumbo jumbo goes here. Trial and error, and some intuition go a long way."		uv _ Point x: (uv x - 0.5 - mat uvOffset x) y: (uv y - 0.5 + mat uvOffset y).		"uv _ uv asPoint - 0.5 + mat uvOffset."		mat uvAngle = 0.0 ifFalse:[			uv _ uv rotateBy: mat uvAngle about: 0@0.].		uv _ mat uvScale * uv + 0.5.		].	^ B3DVector2 x: uv x y: uv y.! !!TLoad3DSMax methodsFor: 'convert'!vertNormToArray: vi	| vertexNormals |	vertexNormals _ B3DVector3Array ofSize: vi size.	1 to: vi size do:[ :i |		(vi at: i) ifNil:[			vertexNormals at: i put: (B3DVector3 new).]		ifNotNil:[			vertexNormals at: i put: (vi at: i).].		].	^ vertexNormals.					! !!TLoad3DSMax methodsFor: 'convert'!vertexIndexToArray: vi	| vertexArray |	vertexArray _ B3DVector3Array ofSize: (vi size).	1 to: vi size do:[ :i |		(vi at: i) ifNil:[			vertexArray at: i put: B3DVector3 new.]		ifNotNil:[			vertexArray at: i put: (vertices at: (vi at: i)).			].		].	^ vertexArray.! !!TLoad3DSMax methodsFor: 'parse'!compare: v1 and: v2 within: epsilon	| delta |	delta _ v1-v2.	delta x abs > epsilon ifTrue:[^ false].	delta y abs > epsilon ifTrue:[^ false].	delta z abs > epsilon ifTrue:[^ false].	^ true.! !!TLoad3DSMax methodsFor: 'parse' stamp: 'tak 6/22/2004 21:31'!convertTName: aString 	"(self new convertTName: 'SCENE_BACKGROUND_STATIC') = #TSceneBackgroundStatic"	| strm start end str |	strm _ WriteStream				on: (String new: 20).	strm nextPut: $T.	"Because this is Tea and because some field start with  	numbers."	start _ 1.	[start <= aString size]		whileTrue: [end _ (aString						indexOf: $_						startingAt: start						ifAbsent: [aString size + 1])						- 1.			str _ aString copyFrom: start to: end.			str translateToLowercase.			str at: 1 put: str first asUppercase.			strm nextPutAll: str.			start _ end + 2].	^ strm contents asSymbol! !!TLoad3DSMax methodsFor: 'parse' stamp: 'das 2/20/2004 10:42'!makeGeometry: tree	| tframe field fieldName start end children isMesh mesh |	isMesh _ false.	children _ OrderedCollection new.	1 to: tree size by: 2 do:[ :i |		fieldName _ tree at: i.		field _ tree at: i+1.		fieldName = #THelperobject ifTrue:[			tframe _ TGroup new.			tframe objectName: (self makeHelperObject: field).			tframe localTransform: transform.			].		fieldName = #TNodeName ifTrue:[ 			start _ field findDelimiters: '"' startingAt: 1.			end _ field findDelimiters: '"' startingAt: start+1.			self objectName: (field copyFrom: start+1 to: end-1).].		fieldName = #TNodeTm ifTrue:[ self localTransform: (self makeTransform: field).].		fieldName = #TMesh ifTrue:[ 			self makeMesh: field.			vertices size > 0 ifTrue:[isMesh _ true.].			].		fieldName = #TMaterialRef ifTrue:[ materialRef _ self makeNumber: field.]. ].		isMesh ifTrue:[ mesh _ self reconstruct.] 			    ifFalse:[ mesh _ TGroup new.						mesh objectName: (self objectName).						mesh localTransform: self localTransform.].		children do:[ :c | mesh addChild: c].		^ mesh.		! !!TLoad3DSMax methodsFor: 'parse' stamp: 'das 2/20/2004 10:42'!makeGroup: tree	| field fieldName tframe |	tframe _ TGroup new.	1 to: tree size by: 2 do:[ :i |		fieldName _ tree at: i.		field _ tree at: i+1.		fieldName = #THelperobject ifTrue:[			tframe objectName: (self makeHelperObject: field).			tframe localTransform: transform.			].		fieldName = #TGroup ifTrue:[			tframe addChild: (self makeGroup: field).			].		fieldName = #TGeomobject ifTrue:[			tframe addChild: (self makeGeometry: field).			].		].	^ tframe.		! !!TLoad3DSMax methodsFor: 'parse' stamp: 'DPR 2/17/2004 12:29'!makeMap: tree	| txtr fieldName field fname uOffset vOffset uTiling vTiling angle start end name extend |" Create a texture based upon information found in the material field."	extend _ nil.	uOffset _ 0.0.	vOffset _ 0.0.	uTiling _ 1.0.	vTiling _ 1.0.	angle _ 0.0.	1 to: tree size by: 2 do:[:i |		fieldName _ tree at: i.		field _ tree at: i+1.		fieldName = #TBitmap ifTrue:[ 			start _ field findDelimiters:'"' startingAt: 1.			end _ field findDelimiters: '"' startingAt: start+1.			fname _ field copyFrom: start+1 to: end-1.].		fieldName = #TUvwUOffset ifTrue:[ uOffset _ self makeNumber: field.].		fieldName = #TUvwVOffset ifTrue:[ vOffset _ self makeNumber: field.].		fieldName = #TUvwUTiling ifTrue:[ uTiling _ self makeNumber: field.].		fieldName = #TUvwVTiling ifTrue:[ vTiling _ self makeNumber: field.].		fieldName = #TUvwAngle ifTrue:[ angle _ self makeNumber: field.].		fieldName = #TMapName ifTrue:[ name _ field. 				start _ name findDelimiters:'$' startingAt: 1.				start < (name size-1) ifTrue:[					(name at:(start+1))=$c ifTrue:[extend _ #colorKey.].					(name at:(start+1))=$a ifTrue:[extend _ #alpha].					(name at:(start+1))=$f ifTrue:[extend _ #fullBright].				].].		].	"get file name from full path name - assumes file is a Windows file name"	fname _ fname reverse.	end _ fname findDelimiters:'\:'startingAt: 1.	fname _ (fname copyFrom: 1 to: end-1) reverse.	fname ifNil:[^fname].	txtr _ TTexture new initializeWithFileName: (FileDirectory pathFrom: { filePath . fname }) mipmap: true shrinkFit: true extension: extend.	txtr uvAngle: angle.	txtr uvOffset: uOffset@vOffset.	txtr uvScale: uTiling@vTiling.	txtr objectName: name.	^ txtr.		! !!TLoad3DSMax methodsFor: 'parse' stamp: 'das 2/20/2004 10:42'!makeMaterial: tree	| fieldName field material ambient diffuse specular shininess alpha txtr subMaterialList twoSided |	alpha _ 1.0.	shininess _ 50.0.	material _ TMaterial new.	twoSided _ false.	1 to: tree size by: 2 do:[:i |		fieldName _ tree at: i.		field _ tree at: i+1.		txtr _ nil.		fieldName = #TMaterialName ifTrue:[material objectName: field.].		fieldName = #TMaterialClass ifTrue:["unused"].		fieldName = #TMaterialAmbient ifTrue:[ambient _ self makeNumberArray: field.].		fieldName = #TMaterialDiffuse ifTrue:[diffuse _ self makeNumberArray: field].		fieldName = #TMaterialSpecular ifTrue:[specular _ self makeNumberArray: field].		fieldName = #TMaterialShine ifTrue:[shininess _ self makeNumber: field].		fieldName = #TMaterialShinestrength ifTrue:["unused"].		fieldName = #TMaterialTransparency ifTrue:[alpha _ 1.0 - (self makeNumber: field)].		fieldName = #TMaterialWiresize ifTrue:["unused"].		fieldName = #TMaterialShading ifTrue:["unused"].		fieldName = #TMaterialXpFalloff ifTrue:["unused"].		fieldName = #TMaterialSoften ifTrue:["unused"].		fieldName = #TMaterialXpType ifTrue:["unused"].		fieldName = #TMapDiffuse ifTrue:[ txtr _ self makeMap: field.].		fieldName = #TNumsubmtls ifTrue:[ subMaterialList _ OrderedCollection new.].		fieldName = #TSubmaterial ifTrue:[ subMaterialList add: (self makeMaterial:field) ].		fieldName = #TMaterialTwosided ifTrue:[ twoSided _ true. ].		].	ambient ifNotNil:[		ambient add: alpha.		material ambientColor: ambient asFloatArray.		].	diffuse ifNotNil:[		diffuse add: alpha.		material diffuseColor: diffuse asFloatArray.		].	specular ifNotNil:[		specular add: 1.0.		material specularColor: specular asFloatArray.].	material shininess: shininess.	txtr ifNotNil:[		material texture: txtr.		txtr extension = #fullBright ifTrue:[material textureMode: GLReplace.]			ifFalse:[ material textureMode: textureMode.].		(txtr extension = #colorKey or:[txtr extension = #alpha])ifTrue:[			material hasAlpha ifFalse:[ 				material ambientColor:(material ambientColor * 0.99)]].		material uvAngle: txtr uvAngle.		material uvOffset: txtr uvOffset.		material uvScale: txtr uvScale.		].	material subMaterialList: subMaterialList.	twoSided ifTrue:[ material cullFace: false].	^ material.! !!TLoad3DSMax methodsFor: 'parse'!makeMaterials: tree	| count |	count _ 0.	((tree at: 1) = #TMaterialCount) ifTrue:[ count _ (tree at: 2) asNumber].	count <= 0 ifTrue:[^self].	materialList _ OrderedCollection new.	1 to: count do:		[ :i | 			(tree at: 1+(i * 2)) = #TMaterial ifTrue:[ 				materialList add: (self makeMaterial: (tree at: 2+(i*2))).].].! !!TLoad3DSMax methodsFor: 'parse' stamp: 'das 11/15/2002 14:07'!makeMesh: tree	| fieldName field numVertices numFaces numTVertex numTVFaces tarray count matCount tv  |	tvertices _ nil.	tfaces _ nil.	1 to: tree size by: 2 do:[:i |		fieldName _ tree at: i.		field _ tree at: i+1.				fieldName = #TMeshNumvertex ifTrue:[ 			numVertices _ self makeNumber: field.			vertices _ B3DVector3Array new: numVertices. ].		fieldName = #TMeshNumfaces ifTrue:[			numFaces _ self makeNumber: field.			faces _ IntegerArray ofSize: (numFaces*3).			matIndex _ IntegerArray ofSize: numFaces.].		fieldName = #TMeshVertexList ifTrue:[ 			field ifNotNil:[				count _ 1.				1 to: field size by: 2 do:[ :j |					tarray _ self makeNumberArray: (field at:(j+1)).					tarray _ (B3DVector3 x:(tarray at: 2) y: (tarray at: 4) z:(tarray at: 3)negated)*scale.					vertices at: count put: tarray.					count _ count+1.					].				].			.].		fieldName = #TMeshFaceList ifTrue:[			count _ 1.			matCount _ 1.			1 to: field size by: 6 do:[:j|				tarray _ self makeNumberArray: (field at: (j+1)).				faces at: count  put: (tarray at: 2).				faces at: count+1 put: (tarray at: 3).				faces at: count+2 put: (tarray at: 4).				count _ count+3.				matIndex at: matCount put:(self makeNumber: (field at: (j+5))).				matCount _ matCount + 1.				.].			].		fieldName = #TMeshNumtvertex ifTrue:[			numTVertex _ self makeNumber:field.			tvertices _ B3DVector2Array new: numTVertex. ]. 		fieldName = #TMeshTvertlist ifTrue:[			count _ 1.			1 to: field size by: 2 do:[ :j |				tarray _ self makeNumberArray: (field at:(j+1)).				tv _ (B3DVector2 x:(tarray at:2) y:1-(tarray at:3)).				tvertices at: count put: tv.				count _ count+1.				].			].		fieldName = #TMeshNumtvfaces ifTrue:[			numTVFaces _ self makeNumber: field.			tfaces _ IntegerArray ofSize:(numTVFaces*3). ].		fieldName = #TMeshTfacelist ifTrue:[			count _ 1.			1 to: field size by:2 do: [ :j |				tarray _ self makeNumberArray: (field at: (j+1)).				tfaces at: count put: (tarray at: 2).				tfaces at: count+1 put: (tarray at: 3).				tfaces at: count+2 put: (tarray at: 4).				count _ count+3.				].			].		].! !!TLoad3DSMax methodsFor: 'parse' stamp: 'das 8/17/2002 15:35'!makeNodeName: tree	| field fieldName name start end |	1 to: tree size by: 2 do:[ :i |		fieldName _ tree at: i.		field _ tree at: i+1.		fieldName = #TNodeName ifTrue:[			start _ field findDelimiters: '"' startingAt: 1.			end _ field findDelimiters: '"' startingAt: start+1.			name _ (field copyFrom: start+1 to: end-1).			].		].	^ name.		! !!TLoad3DSMax methodsFor: 'parse'!makeNumber: string	| start end substr|		start _ 1.	end _ 1.		start _ string findDelimiters: '1234567890-.' startingAt: end.	end _ string findDelimiters: (' ',Character tab asString) startingAt: start.	substr _ string copyFrom:start to: end-1.	^ substr asNumber.! !!TLoad3DSMax methodsFor: 'parse' stamp: 'yo 9/23/2003 18:54'!makeNumberArray: string	| start farray parseStream |	parseStream := ReadStream on: string.		farray _ OrderedCollection new.	"For rapidly finding the numeric entries"	"set1 := ByteArray new: 256.	'1234567890-.' do:[:ch| set1 at: ch asciiValue+1 put: 1].	set2 := ByteArray new: 256.	set2 at: Character space asciiValue+1 put: 1.	set2 at: Character tab asciiValue+1 put: 1."	start := 0.	[start _ string indexOfAnyOf: NumberSet startingAt: start+1 ifAbsent: [0]."start := String findFirstInString: string inSet: set1 startingAt: start+1."	start = 0] whileFalse:[		parseStream position: start-1.		farray add: (Number readFrom: parseStream).		start := parseStream position+1.	].	^ farray.! !!TLoad3DSMax methodsFor: 'parse' stamp: 'das 11/15/2002 15:05'!makeTransform: tree	| field fieldName matrix v mOffset start end m90 |	matrix _ B3DMatrix4x4 identity.	1 to: tree size by: 2 do:[ :i |		fieldName _ tree at: i.		field _ tree at: i+1.		fieldName = #TNodeName ifTrue:[ "I put this here because groups don't give me a node name."			start _ field findDelimiters: '"' startingAt: 1.			end _ field findDelimiters: '"' startingAt: start+1.			self objectName: (field copyFrom: start+1 to: end-1).].		fieldName = #TTmRow0 ifTrue:[ 			v _ self makeNumberArray: field. 			matrix a11: (v at: 1).			matrix a21: (v at: 2).			matrix a31: (v at: 3).].		fieldName = #TTmRow1 ifTrue:[						v _ self makeNumberArray: field. 			matrix a12: (v at: 1).			matrix a22: (v at: 2).			matrix a32: (v at: 3).].		fieldName = #TTmRow2 ifTrue:[			v _ self makeNumberArray: field. 			matrix a13: (v at: 1).			matrix a23: (v at: 2).			matrix a33: (v at: 3).].		fieldName = #TTmRow3 ifTrue:[ "********TRANSLATION FIELD******"			v _ self makeNumberArray: field. 			matrix a14: (v at: 1) * scale.			matrix a24: (v at: 2) * scale.			matrix a34: (v at: 3) * scale .].		fieldName = #TTmScale ifTrue:[ "*********SCALE FIELD************"			v _ self makeNumberArray: field.			v at: 1 put:(1.0/v at:1).			v at: 2 put:(1.0/v at:2).			v at: 3 put:(1.0/v at:3).			matrix a11: matrix a11*(v at:1).			matrix a21: matrix a21*(v at:1).			matrix a31: matrix a31*(v at:1).			matrix a12: matrix a12*(v at:2).			matrix a22: matrix a22*(v at:2).			matrix a32: matrix a32*(v at:2).			matrix a13: matrix a13*(v at:3).			matrix a23: matrix a23*(v at:3).			matrix a33: matrix a33*(v at:3).			]." I am not sure if I need this next matrix or not."		fieldName = #TNodeObjectoffset ifTrue:[ 			mOffset _ self makeTransform: field.			].].	m90 _ B3DMatrix4x4 identity rotationAroundX:-90.	matrix _ (m90 composeWith: matrix) composeWith: m90 orthoNormInverse."	^ B3DMatrix4x4 identity translation: (matrix translation)."	^ matrix.! !!TLoad3DSMax methodsFor: 'parse' stamp: 'tak 6/22/2004 21:30'!nextFieldOn: aStream 	| name value |	name _ self				convertTName: (self nextTokenTo: DelimSet2 on: aStream).	value _ self nextTokenTo: DelimSet1 on: aStream.	^ Array with: name with: value withBlanksTrimmed! !!TLoad3DSMax methodsFor: 'parse' stamp: 'tak 6/22/2004 22:57'!nextOn: aStream 	"Answer pair of {name. value}. name is a Symbol and value is a String.  	First character of name is $*, all rest string is stored into value.  	If name is not found, name is set as nil.  	Answer nil if end of file"	[aheadChar		ifNil: [^ Array with: #EOF with: nil].	aheadChar = $*		ifTrue: [^ self nextFieldOn: aStream].	aheadChar = ${		ifTrue: [self nextTokenTo: DelimSet1 on: aStream.			^ Array with: #BEGIN with: nil].	aheadChar = $}		ifTrue: [self nextTokenTo: DelimSet1 on: aStream.			^ Array with: #END with: nil].	"Skip dirt"	self nextTokenTo: DelimSet1 on: aStream] repeat! !!TLoad3DSMax methodsFor: 'parse' stamp: 'tak 6/22/2004 18:58'!nextTokenTo: aCharactorSet on: aStream 	"Fetch until one of the delimiter characters occured. The delimiter is  	stored into aheadChar"	| result |	aStream atEnd		ifTrue: [aheadChar _ nil.			^ ''].	result _ aStream upToAnyOf: aCharactorSet.	aheadChar _ result last.	^ result allButLast! !!TLoad3DSMax methodsFor: 'parse' stamp: 'tak 6/23/2004 10:28'!parse: aStream 	^ self parse: aStream announcing: 'Parsing 3DS Max data...'! !!TLoad3DSMax methodsFor: 'parse' stamp: 'tak 6/23/2004 10:28'!parse: aStream announcing: announcement	self reset.	announcement		displayProgressAt: Sensor cursorPoint		from: 0		to: aStream size		during: [:bar | ^ self parseTree: aStream bar: bar]! !!TLoad3DSMax methodsFor: 'parse' stamp: 'tak 6/23/2004 10:29'!parseFileNamed: fName 	"MessageTally spyOn: [self new parseFileNamed: (FileDirectory  	pathFrom: {FileDirectory default pathName. 'Content'. 'Plateau'.  	'HPdemo.ASE'})]"	| fileStream string |	fileStream _ (CrLfFileStream readOnlyFileNamed: fName) ascii.	[string _ fileStream next: fileStream size]		ensure: [fileStream close].	^ self parse: string readStream announcing: 'Parsing ' , fName , ' ...'! !!TLoad3DSMax methodsFor: 'parse' stamp: 'tak 6/22/2004 16:42'!parseOld: string	| tloc nloc tn name tree |	tree _ nil. "just to show this is accidental"	tloc _ string indexOfAnyOf: DelimSet1 startingAt: stringLoc ifAbsent:[string size+1].	stringLoc _ tloc+1." ---- Is this a label?  If not, then we are poorly formed. Bail as best you can."	(string at: tloc) = $* ifTrue:[		tree _ OrderedCollection new." ---- Loop Here ---- "		[stringLoc < string size] whileTrue:[" ---- Find the field name or end of block or end of file."			tloc _ string indexOfAnyOf: DelimSet2 startingAt: stringLoc ifAbsent:[string size+1].			(string at: tloc) = $} ifTrue:[ stringLoc _ tloc + 1. ^tree. ].			tloc >= string size ifTrue:[^tree.].			(string at: tloc) = ${ ifTrue:[^tree.].			tn _ string copyFrom: stringLoc to: (tloc-1).			name _ 'T'. "Because this is Tea and because some field start with numbers."			(tn findTokens: '_')do:[ :tkn | name _ name, (tkn asLowercase capitalized)].			name _ name asSymbol.			tree add: name." ---- Find the data."			stringLoc _ tloc+1.			tloc _ string indexOfAnyOf: DelimSet1 startingAt: stringLoc ifAbsent:[string size+1]." ---- End of file."			tloc > string size ifTrue:[ 				tree add: (string copyFrom:stringLoc to: (tloc-1)). 				stringLoc _ tloc. 				^tree.]." ---- Found a new name or end of block- everything in between the last one and this must be useful."			((string at: tloc) = $* or:[(string at: tloc)= $}])ifTrue:[ 				nloc _ string indexOf: Character cr startingAt: stringLoc ifAbsent:[string size+1].				nloc > tloc ifTrue:[nloc _ tloc].				stringLoc <= (nloc-1) ifTrue:[					tree add: (string copyFrom: stringLoc to: (nloc-1)).]				ifFalse: [					tree add:''].				(string at: tloc)=$} ifTrue:[stringLoc _ tloc. ^tree].				stringLoc _ tloc+1.				]." ---- Found a block - recurse."			(string at: tloc) = ${ ifTrue: [				stringLoc _ tloc+1. 				tree add: (self parseOld: string).	" ---- Find the next name."				stringLoc _ string indexOfAnyOf: DelimSet3 startingAt: stringLoc+1 ifAbsent:[string size+1].				stringLoc > string size ifTrue:[^tree].				(string at: stringLoc) = $} ifTrue:[stringLoc _ stringLoc+1. ^tree ].				stringLoc _ stringLoc+1.				].			].		].	^tree.! !!TLoad3DSMax methodsFor: 'parse' stamp: 'tak 6/23/2004 09:59'!parseOldFileNamed: fName 	"MessageTally spyOn: [self new parseOldFileNamed: 	(FileDirectory pathFrom: {FileDirectory default pathName. 'Content'. 	'Plateau'. 'HPdemo.ASE'})]	"	| fileStream string |	fileStream _ (CrLfFileStream readOnlyFileNamed: fName) ascii.	[string _ fileStream next: fileStream size]		ensure: [fileStream close].	stringLoc _ 1.	^ self parseOld: string! !!TLoad3DSMax methodsFor: 'parse' stamp: 'tak 6/23/2004 10:13'!parseTree: aStream bar: bar 	| pair name value tree |	bar value: aStream position.	tree _ OrderedCollection new.	[pair _ self nextOn: aStream.	name _ pair first.	value _ pair second.	name = #EOF		ifTrue: [^ tree].	name = #BEGIN		ifTrue: ["Override last value"			tree				at: tree size				put: (self parseTree: aStream bar: bar)]		ifFalse: [name = #END				ifTrue: [^ tree]				ifFalse: [tree add: name.					tree add: value]]] repeat! !!TLoad3DSMax methodsFor: 'parse'!showTree: tree	self showTree: tree depth: 0.! !!TLoad3DSMax methodsFor: 'parse'!showTree: tree depth: depth	| label |	tree class = OrderedCollection ifTrue:[	1 to: tree size by: 2 do:[:i |		1 to: depth do:[ :j | Transcript show:'---|'.].		label _ tree at: i.		Transcript show: (tree at: i) asString; cr.		label = #TMeshVertexList ifFalse:[		label = #TMeshFaceList ifFalse:[		label = #TMeshTvertlist ifFalse:[		label = #TMeshTfacelist ifFalse:[		label = #TSubmaterial ifFalse:[		self showTree: (tree at:(i+1)) depth: depth+1.].].].].].].].! !!TLoad3DSMax methodsFor: 'parse'!testNorm: n1 norm: n2 	" Test to see if the angle between the surfaces of n1 and n2 is greater than the shade angle, which is equivalent to being less than the cos of the shade angle. This means that we look at the negative of the dot product because the cos between the normals is the negative of the cos of the angle between the surfaces."	^ (n1 dot: n2) negated < shadeAngleCos.! !!TLoad3DSMax methodsFor: 'accessing'!frame	frame class = TMesh ifTrue:[^ frame.].	frame frameChildren ifNotNil:[		frame frameChildren size = 1 ifTrue:[ ^ frame frameChildren at: 1. ].].	^ frame.! !!TLoad3DSMax methodsFor: 'accessing'!scale	^ scale.! !!TLoad3DSMax methodsFor: 'accessing'!scale: scl	scale _ scl.! !!TLoad3DSMax methodsFor: 'accessing'!shadeAngle	^ shadeAngle radiansToDegrees.! !!TLoad3DSMax methodsFor: 'accessing'!shadeAngle: angle	shadeAngle _ angle degreesToRadians.	shadeAngleCos _ shadeAngle cos.! !!TLoad3DSMax methodsFor: 'initialize' stamp: 'DPR 8/21/2003 17:13'!initializeWithFileName: fName 		^self initializeWithFileName: fName scale: 1.0 shadeAngle: 90.1 textureMode: GLModulate! !!TLoad3DSMax methodsFor: 'initialize' stamp: 'DPR 8/21/2003 17:13'!initializeWithFileName: fName scale: scl		^self initializeWithFileName: fName scale: scl shadeAngle: 90.1 textureMode: GLModulate! !!TLoad3DSMax methodsFor: 'initialize' stamp: 'DPR 8/21/2003 17:13'!initializeWithFileName: fName scale: scl shadeAngle: angle		^self initializeWithFileName: fName scale: scl shadeAngle: angle textureMode: GLModulate.! !!TLoad3DSMax methodsFor: 'initialize' stamp: 'tak 6/23/2004 11:00'!initializeWithFileName: fName scale: scl shadeAngle: angle textureMode: txtrMd		| fieldName field parseTree mesh fileName |	scale _ scl.	textureMode _ txtrMd.	"get full path name of file, and path of directory containing it"	fileName _ CroquetData findContentFileName: fName.	filePath _ FileDirectory dirPathFor: fileName.	parseTree _ self parseFileNamed: fName.	self shadeAngle: angle. "Use degrees, but convert to radians"	frame _ TGroup new.	1 to: parseTree size by: 2 do:[ :i |		fieldName _ parseTree at: i.		field _ parseTree at: i+1.		fieldName = #T3dsmaxAsciiexport ifTrue:[ " unused "].		fieldName = #TComment ifTrue:[" unused "].		fieldName = #TScene ifTrue:[" unused "].		fieldName = #TMaterialList ifTrue:[ self makeMaterials: field ].		fieldName = #TGeomobject ifTrue:[ 			mesh _ (self makeGeometry: field).			frame addChild: mesh.].		fieldName = #TGroup ifTrue:[ 			mesh _ (self makeGroup: field). 			frame addChild: mesh.].		].	frame frameChildren size = 1 ifTrue:[		frame _ frame frameChildren at: 1.		].	frame prune.	frame forceGlobalToLocal."	frame collapse."	^self! !!TLoad3DSMax methodsFor: 'initialize' stamp: 'tak 6/22/2004 22:50'!reset	stringLoc _ 1.	aheadChar _ $ . "anything ok"! !!TLoadMDL methodsFor: 'parsing' stamp: 'das 2/20/2004 10:42'!buildMesh: vertices faces: faces normals: vtxNormals textureUV: vtxTexCoords textureMap: txtr	| mat mesh |	vertices ifNil:[^nil].	faces ifNil:[^nil].	vertices size < 3 ifTrue:[^nil].	faces size < 1 ifTrue:[^nil].	mat := TMaterial new.	mat ambientColor: #(0.9 0.9 0.9 1) asFloatArray.	mat diffuseColor: #(0.9 0.9 0.9 1) asFloatArray.	txtr ifNotNil:[		mat texture: txtr.		mat textureMode: GLModulate.	].	vertices *= self scaleFactor.	mesh := TMesh new initializeWithVertices: vertices		alias: nil 		norms: vtxNormals 		textureUV: vtxTexCoords		faceGroups: {1. faces} 		material: mat.	^mesh! !!TLoadMDL methodsFor: 'parsing' stamp: 'ar 10/12/2002 00:31'!fixTransformsIn: anActor	"Traverse anActor and all its children checking for non-orthonormal transforms.	Move these down until we get to the leaves and there transform the meshes (if any)."	| tfm offset rowX rowY rowZ scaleX scaleY scaleZ scale |	tfm := anActor localTransform copy.	"Check if the transform is *really* weird"	(tfm a41 = 0.0 and:[tfm a42 = 0.0 and:[tfm a43 = 0.0 and:[tfm a44 = 1.0]]]) ifFalse:[		self error: 'Cannot fix transform'.	].	"Remember offset of the transform"	offset := tfm translation.	tfm translation: 0@0@0.	"Compute unit vectors to see if their length changes"	rowX := tfm localPointToGlobal: 1@0@0.	rowY := tfm localPointToGlobal: 0@1@0.	rowZ := tfm localPointToGlobal: 0@0@1.	"Normalize"	scaleX := 1.0 / rowX length.	rowX *= scaleX.	scaleY := 1.0 / rowY length.	rowY *= scaleY.	scaleZ := 1.0 / rowZ length.	rowZ *= scaleZ.	"Orthogonalize (later...)"	(rowX dot: rowY) < 0.01 ifFalse:[self error: 'Not orthogonal'].	(rowY dot: rowZ) < 0.01 ifFalse:[self error: 'Not orthogonal'].	(rowZ dot: rowX) < 0.01 ifFalse:[self error: 'Not orthogonal'].	"Create new orthonormal transform"	tfm := B3DMatrix4x4 identity.	tfm a11: rowX x; a12: rowX y; a13: rowX z.	tfm a21: rowY x; a22: rowY y; a23: rowY z.	tfm a31: rowZ x; a32: rowZ y; a33: rowZ z.	tfm translation: offset.	anActor localTransform: tfm.	"See if this a mesh"	(anActor isKindOf: TMesh) ifTrue:[		"Then rescale its vertices"		scale := scaleX@scaleY@scaleZ negated.		anActor vertices: (anActor vertices collect:[:vtx| vtx * scale]).		anActor normals: (anActor normals collect:[:vtx| vtx x @ vtx y @ vtx z negated]).		"And compute the bound spheres"		anActor initBounds.	].	"Scale children (using a matrix since we'll orthonormalize them later) and recurse"	scale := B3DMatrix4x4 withScale: scaleX@scaleY@scaleZ.	anActor frameChildren ifNotNil:[		anActor frameChildren do:[:child|			child translation: child translation x negated@ child translation y @ child translation z negated.			child localTransform: (scale composeWith: child localTransform).			self fixTransformsIn: child.		].	].! !!TLoadMDL methodsFor: 'parsing' stamp: 'ar 10/8/2002 02:35'!getChildNamed: childName from: parent	| theChild nameParts |	(parent objectName sameAs: childName) ifTrue: [ ^parent].	nameParts _ childName findTokens: ' '.	(nameParts first sameAs: parent objectName) ifTrue: [nameParts removeFirst].	theChild _ parent.	nameParts do: [:aName|		theChild := theChild frameChildren detect:[:any| any objectName sameAs: aName].	].	^ theChild.! !!TLoadMDL methodsFor: 'parsing' stamp: 'das 2/17/2004 16:41'!loadMeshFromFile: meshFile texture: textureName	"Load this object's mesh from the specified file"	| words texture |	textureName ifNotNil:[		texture := TTexture new initializeWithFileName: textureName.	].	meshFile ifNil:[^nil].	words _ (meshFile findTokens: #.).	((words last) = 'vfb') 		ifTrue: [^self parseVFBFile: meshFile texture: texture].	((words last) = 'obj') 		ifTrue: [^self parseOBJFile: meshFile texture: texture].	^nil! !!TLoadMDL methodsFor: 'parsing' stamp: 'das 2/20/2004 10:43'!parseFileNamed: filename	"Creates a new actor using the specification from the given file"	| aFile words line startSubstr index parent name texture meshFile matrix baseActor newActor fileVersion pos |	words _ (filename findTokens: #.).	aFile _ (CrLfFileStream readOnlyFileNamed: filename) ascii.	"Check what version this mdl file is"	line _ aFile upTo: (Character cr).	line _ aFile upTo: (Character cr).	line _ aFile upTo: (Character cr).	((line truncateTo: 7) = 'version')		ifTrue: [ fileVersion _ 1 ]		ifFalse: [ fileVersion _ 0 ].	[ line _ aFile upTo: (Character cr).	aFile atEnd] whileFalse:[		words _ line findTokens: '='.		"See if we're creating a new object"		(((words size) > 1) and: [ ((words at: 2) beginsWith: ' _MakeObject')			or: [ (words at: 2) beginsWith: ' Alice.MakeObject' ] ]) ifTrue: [			(fileVersion = 0) ifTrue: [				words _ line findTokens: #,.				parent _ (words at: 2) withBlanksTrimmed.				name _ (((words at: 3) withBlanksTrimmed) findBetweenSubStrs: '"') at: 1.			] ifFalse: [				name _ (words at: 1) truncateTo: (((words at: 1) size) - 1).				parent _ ((words at: 3) findTokens: #,) at: 1.			].			"Now pull in the texture to use"			startSubstr _ name , '.SetTexture'.			pos _ aFile position.			texture := nil.			[aFile atEnd or:[texture notNil]] whileFalse:[				line _ aFile upTo: (Character cr).				(line beginsWith: startSubstr) ifTrue:[					texture _ (line findBetweenSubStrs: '"') at: 2.					texture _ (aFile directory pathName), FileDirectory slash, texture]].			texture ifNil:[aFile position: pos].			"Read the composite matrix to use"			startSubstr _ name , '._SetLocalTransformation'.			pos _ aFile position.			matrix := nil.			[aFile atEnd or:[matrix notNil]] whileFalse:[				line _ aFile upTo: (Character cr).				(line beginsWith: startSubstr) ifTrue:[					matrix _ B3DMatrix4x4 new.					words _ line findBetweenSubStrs: ',()'.					words removeAllSuchThat: [:str | str = ' '].					index _ words size - 15.					1 to: 4 do:[:j|						1 to: 4 do:[:i|							matrix at: i at: j put: 								((words at: index) withBlanksTrimmed) asNumber.							index _ index + 1.]].				].			].			matrix ifNil:[aFile position: pos].			"Read the mesh file to use"			startSubstr _ 'LoadGeometry'.			pos _ aFile position.			meshFile := nil.			[aFile atEnd or:[meshFile notNil]] whileFalse:[				line _ aFile upTo: (Character cr).				(line beginsWith: startSubstr) ifTrue:[					meshFile _ (line findBetweenSubStrs: '"') at: 2.					meshFile _ (aFile directory pathName), FileDirectory slash, meshFile.				].			].			meshFile ifNil:[aFile position: pos].			"Now build the actor name"			words _ name findTokens: '.'.			name _ words last.			name at: 1 put: ((name at: 1) asLowercase).			"Now build the parent name"			parent _ parent copyReplaceAll: '.' with: ' '.			"Now create the object"			(parent = 'None') ifTrue: [				baseActor := self loadMeshFromFile: meshFile texture: texture.				baseActor ifNil:[					baseActor := TFrame new.					baseActor visible: false].				baseActor objectName: name.				matrix ifNotNil:[baseActor localTransform: matrix].				baseActor translation: baseActor translation * self scaleFactor.				baseActor solid: false.				"end base actor creation"			] ifFalse: [				newActor := self loadMeshFromFile: meshFile texture: texture.				newActor ifNil:[					newActor := TFrame new.					newActor visible: false].				newActor objectOwner: baseActor.				newActor objectName: name.				parent _ self getChildNamed: parent from: baseActor.				parent addChild: newActor.				matrix ifNotNil:[newActor localTransform: matrix].				newActor translation: newActor translation * self scaleFactor.				newActor solid: false.				"end new actor with parent"			].		"end MakeObject parsing"		].	]. "end file parsing"	aFile close.	self fixTransformsIn: baseActor.	^baseActor! !!TLoadMDL methodsFor: 'parsing' stamp: 'ar 10/8/2002 16:01'!parseOBJFile: filename texture: txtr	"Read in a mesh from the obj file"	| aFile pos line words oldWords triple vCount fCount index vertices vtxTexCoords vtxNormals faces u v |	aFile _ (CrLfFileStream readOnlyFileNamed: filename) ascii.	line _ aFile upTo: (Character cr).	words _ line findTokens: ' '.	vCount _ 0.	"Count the vertices"	[ (words at: 1) = 'v' ] whileTrue: [		vCount _ vCount + 1.		line _ aFile upTo: (Character cr).		words _ line findTokens: ' '.	].	"Now reset the file and grab the actual data"	aFile position: 0.	"Create the vertex array"	vertices _ B3DVector3Array new: vCount.	"Read in the vertices"	line _ aFile upTo: (Character cr).	words _ line findTokens: ' '.	index _ 1.	[ (words at: 1) = 'v' ] whileTrue: [ 		vertices at: index put:				(B3DVector3 x: ((words at: 2) asNumber)							y: ((words at: 3) asNumber)							z: ((words at: 4) asNumber)).		index _ index + 1.		line _ aFile upTo: (Character cr).		words _ line findTokens: ' '.	].	"Read in the texture coordinates"	index _ 1.	vtxTexCoords _ B3DTexture2Array new: vCount.	[ (words at: 1) = 'vt' ] whileTrue: [		u _ (words at: 2) asNumber.		v _ (words at: 3) asNumber.		v := 1.0 + (0.0 - v).		vtxTexCoords at: index put: (B3DVector2 u: u v: v).		index _ index + 1.		line _ aFile upTo: (Character cr).	 	words _ line findTokens: ' '.	].	"Read in the normals"	index _ 1.	vtxNormals _ B3DVector3Array new: vCount.	[ (words at: 1) = 'vn' ] whileTrue: [		vtxNormals at: index					put: (B3DVector3 x: ((words at: 2) asNumber)									 y: ((words at: 3) asNumber)									 z: ((words at: 4) asNumber)).		index _ index + 1.		line _ aFile upTo: (Character cr).	 	words _ line findTokens: ' '.	].	pos _ aFile position.	oldWords _ words.	"Count the faces"	fCount _ 0.	[ (words size) > 0 ] whileTrue: [		((words at: 1) = 'f') ifTrue: [fCount _ fCount + 1 ].		line _ aFile upTo: (Character cr).		words _ line findTokens: ' '.	].	"Create the faces array"	faces _ WriteStream on: (IntegerArray new: fCount*3).	aFile position: pos.	words _ oldWords.	"Read in the faces"	[ (words size) > 0 ] whileTrue: [		((words at: 1) = 'f') ifTrue: [ 			triple _ (words at: 2) findTokens: '/'.			faces nextPut: (triple at: 1) asNumber.			triple _ (words at: 3) findTokens: '/'.			faces nextPut: (triple at: 1) asNumber.			triple _ (words at: 4) findTokens: '/'.			faces nextPut: (triple at: 1) asNumber.		].		line _ aFile upTo: (Character cr).	 	words _ line findTokens: ' '.	].	faces := faces contents.	aFile close.	^self buildMesh: vertices faces: faces normals: vtxNormals textureUV: vtxTexCoords textureMap: txtr.! !!TLoadMDL methodsFor: 'parsing' stamp: 'ar 10/12/2002 00:34'!parseVFBFile: filename texture: txtr	"Read in a mesh from the vfb file"	| aFile w x y z bytes version vCount fCount verticesPerFace vertices vtxNormals vtxTexCoords faces |		aFile _ (StandardFileStream readOnlyFileNamed: filename) binary.	"Read in the version number"	bytes _ aFile next: 4.	version _ bytes unsignedLongAt: 1 bigEndian: false.	(version = 1) ifTrue: [		"Read in the number of vertices"		bytes _ aFile next: 4.		vCount _ bytes unsignedLongAt: 1 bigEndian: false.	] ifFalse: [		vCount _ version.		version _ 0.	].	(vCount <= 0) ifTrue: [		aFile close.		^nil	].	vertices _ B3DVector3Array new: vCount.	vtxNormals _ B3DVector3Array new: vCount.	vtxTexCoords _ B3DTexture2Array new: vCount.	"Read in the vertices"	1 to: vCount do: [:i | bytes _ aFile next: 32.		x _ Float fromIEEE32Bit: (bytes unsignedLongAt: 1 bigEndian: false).		y _ Float fromIEEE32Bit: (bytes unsignedLongAt: 5 bigEndian: false).		z _ Float fromIEEE32Bit: (bytes unsignedLongAt: 9 bigEndian: false).		vertices at: i put: (B3DVector3 x: (x negated) y: y z: z).		x _ Float fromIEEE32Bit: (bytes unsignedLongAt: 13 bigEndian: false).		y _ Float fromIEEE32Bit: (bytes unsignedLongAt: 17 bigEndian: false).		z _ Float fromIEEE32Bit: (bytes unsignedLongAt: 21 bigEndian: false).		vtxNormals at: i put: (B3DVector3 x: (x negated) y: y z: z).		x _ Float fromIEEE32Bit: (bytes unsignedLongAt: 25 bigEndian: false).		y _ Float fromIEEE32Bit: (bytes unsignedLongAt: 29 bigEndian: false).		y := 1.0 + (0.0 - y).		vtxTexCoords at: i put: (B3DVector2 u: x v: y).	].	"Read in the number of faces"	bytes _ aFile next: 4.	fCount _ bytes unsignedLongAt: 1 bigEndian: false.	(fCount <= 0) ifTrue: [		aFile close.		^nil].	"Read past the faceDataCount value"	aFile next: 4.	(version = 0) 		ifTrue: [ verticesPerFace _ 0. ] 		ifFalse: [bytes _ aFile next: 4.				verticesPerFace _ bytes unsignedLongAt: 1 bigEndian: false].	(verticesPerFace = 0) ifTrue: [		faces _ WriteStream on: (IntegerArray new: fCount*3).		1 to: fCount do: [: i |			bytes _ aFile next: 4.			w _ bytes unsignedLongAt: 1 bigEndian: false.			(w = 3) ifTrue: [				bytes _ aFile next: 4.				x _ (bytes unsignedLongAt: 1 bigEndian: false).				bytes _ aFile next: 4.				y _ (bytes unsignedLongAt: 1 bigEndian: false).				bytes _ aFile next: 4.				z _ (bytes unsignedLongAt: 1 bigEndian: false).				faces nextPut: z; nextPut: y; nextPut: x.			] ifFalse: [				1 to: w do: [: j | aFile next: 4]			].		].		faces := faces contents.	].	aFile close.	^self buildMesh: vertices faces: faces normals: vtxNormals textureUV: vtxTexCoords textureMap: txtr.! !!TLoadMDL methodsFor: 'parsing' stamp: 'ar 10/8/2002 09:55'!scaleFactor	^3! !!TMaterial methodsFor: 'accessing'!ambientColor	^ ambientColor.! !!TMaterial methodsFor: 'accessing' stamp: 'das 2/6/2003 06:47'!ambientColor: ac	ambientColor _ ac asFloatArray.! !!TMaterial methodsFor: 'accessing' stamp: 'das 3/9/2004 14:38'!boundSphere	boundSphere ifNil:[	boundSphere _ TBoundSphere localPosition: 0@0@0 radius: scale.	boundSphere frame: self.].	^ boundSphere.! !!TMaterial methodsFor: 'accessing' stamp: 'ar 7/21/2002 20:23'!color: aColor	ambientColor _ {aColor red. aColor green. aColor blue. aColor alpha} asFloatArray.	diffuseColor _ ambientColor copy.! !!TMaterial methodsFor: 'accessing'!cullFace	^ cullFace.! !!TMaterial methodsFor: 'accessing' stamp: 'das 7/22/2003 16:08'!cullFace: bool	cullFace _ bool.! !!TMaterial methodsFor: 'accessing'!diffuseColor	^ diffuseColor.! !!TMaterial methodsFor: 'accessing' stamp: 'das 2/6/2003 06:48'!diffuseColor: dc	diffuseColor _ dc asFloatArray.! !!TMaterial methodsFor: 'accessing'!emissiveColor	^ emissiveColor.! !!TMaterial methodsFor: 'accessing' stamp: 'das 2/6/2003 06:49'!emissiveColor: ec	emissiveColor _ ec asFloatArray.! !!TMaterial methodsFor: 'accessing'!flipFace	^ flipFace.! !!TMaterial methodsFor: 'accessing'!flipFace: bool	flipFace _ bool.! !!TMaterial methodsFor: 'accessing'!fullBright	^ fullBright.! !!TMaterial methodsFor: 'accessing'!fullBright: bool	fullBright _ bool.! !!TMaterial methodsFor: 'accessing' stamp: 'das 12/20/2002 12:23'!hasAlpha	(ambientColor at: 4) < 1.0 ifTrue: [^ true].	(diffuseColor at: 4) < 1.0 ifTrue: [^ true].	transparency < 1.0 ifTrue:[^ true].	^ false.! !!TMaterial methodsFor: 'accessing' stamp: 'das 3/9/2004 14:39'!scale: scl	super scale: scl.	scale _ scl.	boundSphere ifNotNil:[		boundSphere _ TBoundSphere localPosition:0@0@0 radius: scale.		boundSphere objectOwner: self.	].! !!TMaterial methodsFor: 'accessing'!shininess		^ shininess.! !!TMaterial methodsFor: 'accessing'!shininess: s	shininess _ s.! !!TMaterial methodsFor: 'accessing'!specularColor	^ specularColor.! !!TMaterial methodsFor: 'accessing' stamp: 'das 2/6/2003 06:46'!specularColor: sc	specularColor _ sc asFloatArray.! !!TMaterial methodsFor: 'accessing'!subMaterialList	^ subMaterialList.! !!TMaterial methodsFor: 'accessing'!subMaterialList: sml	subMaterialList _ sml.! !!TMaterial methodsFor: 'accessing'!texture	^ texture.! !!TMaterial methodsFor: 'accessing'!texture: txtr	texture _ txtr.! !!TMaterial methodsFor: 'accessing'!textureMode	^ textureMode.! !!TMaterial methodsFor: 'accessing'!textureMode: tm	textureMode _ tm.! !!TMaterial methodsFor: 'accessing' stamp: 'das 12/20/2002 12:22'!transparency	^ transparency.! !!TMaterial methodsFor: 'accessing' stamp: 'das 12/20/2002 12:22'!transparency: trans	transparency _ trans.! !!TMaterial methodsFor: 'accessing' stamp: 'das 4/3/2002 16:50'!uvAngle	^ uvAngle! !!TMaterial methodsFor: 'accessing' stamp: 'das 4/3/2002 16:50'!uvAngle: uva	uvAngle _ uva.! !!TMaterial methodsFor: 'accessing' stamp: 'das 4/3/2002 16:51'!uvOffset	^ uvOffset! !!TMaterial methodsFor: 'accessing' stamp: 'das 4/3/2002 16:51'!uvOffset: uvo	uvOffset _ uvo.! !!TMaterial methodsFor: 'accessing' stamp: 'das 4/3/2002 16:49'!uvScale 	^ uvScale.! !!TMaterial methodsFor: 'accessing' stamp: 'das 4/3/2002 16:50'!uvScale: uvs	uvScale _ uvs.! !!TMaterial methodsFor: 'render' stamp: 'das 3/12/2004 13:39'!disable: ogl	fullBright ifTrue:[		ogl glEnable: GLLighting.]	ifFalse:[			"	ogl glPopAttrib."		ogl glMaterialfv: GLFront with: GLSpecular with: DefaultSpecular.		ogl glMaterialfv: GLFront with: GLDiffuse with: DefaultDiffuse.		ogl glMaterialfv: GLFront with: GLAmbient with: DefaultAmbient.		ogl glMaterialfv: GLFront with: GLEmission with:  DefaultEmission.		ogl glMaterialfv: GLFront with: GLShininess with: DefaultShininess.		].	texture ifNotNil:[		texture disable: ogl.		ogl glTexEnvi: GLTextureEnv with: GLTextureEnvMode with: GLModulate.		].	ogl setCull.! !!TMaterial methodsFor: 'render' stamp: 'das 6/30/2004 23:37'!enable: ogl	| trans |	fullBright ifTrue:[		ogl glDisable: GLLighting.		ogl glColor4fv: diffuseColor.		"ogl glColor3fv: DefaultWhite."		]	ifFalse:[	"	ogl glPushAttrib: GLCurrentBit."		transparency = 1.0 ifTrue:[			ogl glMaterialfv: GLFront with: GLSpecular with: specularColor;				glMaterialfv: GLFront with: GLDiffuse with: diffuseColor;				glMaterialfv: GLFront with: GLAmbient with: ambientColor;				glMaterialfv: GLFront with: GLEmission with: emissiveColor;				glMaterialfv: GLFront with: GLShininess with: shininess.		]		ifFalse:[			trans _ #(1 1 1 1) asFloatArray.			trans at: 4 put: transparency.			ogl glMaterialfv: GLFront with: GLSpecular with: specularColor*trans;				glMaterialfv: GLFront with: GLDiffuse with: diffuseColor*trans;				glMaterialfv: GLFront with: GLAmbient with: ambientColor*trans;				glMaterialfv: GLFront with: GLEmission with: emissiveColor*trans;				glMaterialfv: GLFront with: GLShininess with: shininess.		].	].	texture ifNotNil:[		texture enable: ogl.		ogl glTexEnvi: GLTextureEnv with: GLTextureEnvMode with: textureMode. 		].	cullFace ifFalse:[ ogl glDisable: GLCullFace.].	flipFace ifTrue:[ ogl flipFace.].! !!TMaterial methodsFor: 'render' stamp: 'das 3/12/2004 13:40'!render: ogl	self hasAlpha ifFalse:[		ogl glPushMatrix.		renderObject ifNil: [ renderObject _ TTeapot new. renderObject scale: scale.].		self enable: ogl.		renderObject render: ogl.		ogl glPopMatrix.].! !!TMaterial methodsFor: 'render' stamp: 'das 3/12/2004 13:40'!renderAlpha: ogl	ogl glPushMatrix.	renderObject ifNil: [ renderObject _ TTeapot new. ].	self enable: ogl.	renderObject render: ogl.	self disable: ogl.	ogl glPopMatrix.! !!TMaterial methodsFor: 'initialize' stamp: 'das 2/17/2004 15:35'!initialize	super initialize.		self ambientColor: #(0.5 0.5 0.5 0.5) asFloatArray.	self diffuseColor: #(0.5 0.5 0.5 0.5) asFloatArray.	self specularColor: #(0.9 0.9 1.0 1.0) asFloatArray.	self emissiveColor: #(0.0 0.0 0.0 1.0) asFloatArray.	shininess _ 50.0.	cullFace _ true.	flipFace _ false.	fullBright _ false.	textureMode _ GLModulate.	visible _ true.	scale _ 1.0.	transparency _ 1.0.	^self! !!TMaterial methodsFor: 'copying' stamp: 'DPR 1/9/2004 14:05'!postCopy	super postCopy.	ambientColor _ ambientColor copy.	diffuseColor _ diffuseColor copy.	specularColor _ specularColor copy.	emissiveColor _ emissiveColor copy.	subMaterialList ifNotNil:[		subMaterialList _ subMaterialList collect:[:mat| mat copy].	].	^self! !!TMesh methodsFor: 'render' stamp: 'das 7/10/2003 21:27'!boundSphere	boundsChanged ifTrue:[		self initBounds. 		boundsChanged _ false.		].	^ boundSphere.! !!TMesh methodsFor: 'render' stamp: 'das 7/27/2003 15:06'!disableCaching	cachingEnabled _ false.	cachingAlphaEnabled _ false.! !!TMesh methodsFor: 'render' stamp: 'das 7/27/2003 15:07'!enableCaching	cachingEnabled _ true.	cachingAlphaEnabled _ true.! !!TMesh methodsFor: 'render' stamp: 'das 7/27/2003 14:39'!hasAlpha	^ alpha.! !!TMesh methodsFor: 'render' stamp: 'das 3/12/2004 13:42'!oldRender: ogl	self opaque ifTrue:[		(cachingEnabled = true) ifFalse:[			(glListID notNil and:[ glInstance = ogl instance]) ifTrue:[				ogl glDeleteLists: glListID with: 1.				ogl unregisterList: self.				].			glListID _ nil.			cachingEnabled = #reset ifTrue:[ cachingEnabled _ true.].			^self renderPrimitive: ogl alpha: false.		].		"if there is a cached list and ogl has not changed, call it"		(glListID notNil and: [glInstance = ogl instance]) ifTrue:[			ogl glCallList: glListID.		] ifFalse:[			glListID _ ogl glGenLists: 1.			ogl registerList: glListID range: 1 owner: self.			glInstance _ nil.			ogl glNewList: glListID with: GLCompileAndExecute.			self renderPrimitive: ogl alpha: false.			"See if current display list completed correctly.			If any other has been constructed in the mean time			defer this lists creation until the next rendering loop."			(ogl glGetInteger: GLListIndex) = glListID ifTrue:[glInstance _ ogl instance].			ogl glEndList.		].	].! !!TMesh methodsFor: 'render' stamp: 'das 3/12/2004 13:42'!oldRenderAlpha: ogl	(cachingAlphaEnabled = true) ifFalse:[		(glListAlphaID notNil and:[ glInstance = ogl instance]) ifTrue:[			ogl glDeleteLists: glListAlphaID with: 1.			ogl unregisterList: self.			].		glListAlphaID _ nil.		cachingAlphaEnabled = #reset ifTrue:[ cachingAlphaEnabled _ true.].		^self renderPrimitive: ogl alpha: true.	].	"if there is a cached list and ogl has not changed, call it"	(glListAlphaID notNil and: [glInstance = ogl instance]) ifTrue:[		ogl glCallList: glListAlphaID.	] ifFalse:[		glListAlphaID _ ogl glGenLists: 1.		ogl registerList: glListAlphaID range: 1 owner: self.		glInstance _ nil.		ogl glNewList: glListAlphaID with: GLCompileAndExecute.		self renderPrimitive: ogl alpha: true.		"See if current display list completed correctly.		If any other has been constructed in the mean time		defer this lists creation until the next rendering loop."		(ogl glGetInteger: GLListIndex) = glListAlphaID ifTrue:[glInstance _ ogl instance].		ogl glEndList.	].! !!TMesh methodsFor: 'render' stamp: 'das 3/12/2004 13:42'!render: ogl	^self renderPrimitive: ogl alpha: false.! !!TMesh methodsFor: 'render' stamp: 'das 8/4/2004 23:22'!renderAlpha: ogl	^self renderPrimitive: ogl alpha: true.! !!TMesh methodsFor: 'render' stamp: 'ar 2/18/2003 21:06'!renderPrimitive: space	self renderPrimitive: space alpha: false.	"boundSphere renderBoundSphere: self."! !!TMesh methodsFor: 'render' stamp: 'das 3/12/2004 13:43'!renderPrimitive: ogl alpha: alphaPass	| lastMat nextMat |	lastMat := nil.	1 to: faceGroups size by: 2 do:[ :i |		nextMat _ materialList at: (faceGroups at: i).		nextMat hasAlpha = alphaPass ifTrue:[			nextMat == lastMat ifFalse:[				lastMat ifNotNil:[lastMat disable: ogl].				nextMat enable: ogl.				lastMat := nextMat.			].			ogl drawIndexedTriangles: (faceGroups at: i+1) 				vertices: vertices 				normals: vtxNormals 				colors: nil texCoords: textureUV.		].	].	lastMat ifNotNil:[lastMat disable: ogl]."	boundSphere renderBox: self."! !!TMesh methodsFor: 'render' stamp: 'das 7/27/2003 15:07'!resetCaching	cachingEnabled _ #reset.	cachingAlphaEnabled _ #reset.! !!TMesh methodsFor: 'accessing'!boundsChanged	boundsChanged _ true.! !!TMesh methodsFor: 'accessing' stamp: 'das 4/25/2002 10:12'!boundsDepth	^ boundsDepth.! !!TMesh methodsFor: 'accessing' stamp: 'das 5/11/2002 15:05'!boundsDepth: depth	boundsDepth _ depth.	frameChildren ifNotNil:[ frameChildren do:[ :fc | fc boundsDepth: depth].].	self boundsChanged.! !!TMesh methodsFor: 'accessing' stamp: 'das 12/29/2002 14:10'!collapse"Forces all frames to identity transform while retaining translation, and pushes the previous transform to the frame children. This is used primarily for meshes and their supporting groups."	| orient|	orient _ self orientation.	1 to: vertices size do:[ :index |		vertices at: index put:(orient localPointToGlobal: (vertices at: index)).].	1 to: vtxNormals size do:[ :index |		vtxNormals at: index put:(orient localPointToGlobal:( vtxNormals at: index)).].	super collapse.! !!TMesh methodsFor: 'accessing' stamp: 'das 7/28/2003 11:53'!colorize: col	self materialList do:[ :ml |		ml ambientColor: col.		ml diffuseColor: col.		ml textureMode: GLModulate.		].	self resetCaching.	self checkAlpha.	frameChildren ifNotNil:[frameChildren do:[ :fc | fc colorize: col].].! !!TMesh methodsFor: 'accessing' stamp: 'ar 6/23/2002 02:07'!faceGroupsDo: aBlock	1 to: faceGroups size by: 2 do:[ :i | aBlock value: (faceGroups at: i+1)].! !!TMesh methodsFor: 'accessing' stamp: 'das 11/23/2002 12:22'!forceGlobalToLocal"This is used by TMesh where we assume that the imported vertices are pre-transformed and we want to put them back into their untransformed state. Only TMesh will probably need this, but TMeshes can have TGroups which don't know what to do."	| invMat invOrient |	frameChildren ifNotNil:[ frameChildren do:[ :fc | fc forceGlobalToLocal.]].	invMat _ self localTransform orthoNormInverse.	invOrient _ self orientation orthoNormInverse.	1 to: vertices size do:[ :index | 		vertices at: index put:(invMat localPointToGlobal: (vertices at: index)).].	1 to: vtxNormals size do:[ :index |		vtxNormals at: index put:(invOrient localPointToGlobal: (vtxNormals at: index)).].	frameParent ifNotNil:[		self localTransform: (			frameParent localTransform orthoNormInverse composeWith: self localTransform).		].! !!TMesh methodsFor: 'accessing' stamp: 'das 4/18/2003 19:04'!frameBox	"Answer the local bounding box of this frame"	boundsChanged ifTrue:[self initBounds].	boundSphere ifNil:[^super frameBox].	^boundSphere box ifNil:[super frameBox]! !!TMesh methodsFor: 'accessing' stamp: 'das 4/15/2003 17:12'!fullBright: bool	super fullBright: bool.	materialList ifNotNil:[ materialList do:[ :ml | ml fullBright: bool]].! !!TMesh methodsFor: 'accessing' stamp: 'ar 9/7/2002 14:52'!hasAlpha: bool	alpha _ bool.! !!TMesh methodsFor: 'accessing' stamp: 'das 5/1/2002 13:54'!inertiaTensor	| it |	it _ TTensor initialize.	1 to: faceGroups size by: 2 do:[:i |		it addFaces: (faceGroups at: i+1) vertices: vertices.].	^ it.	! !!TMesh methodsFor: 'accessing' stamp: 'das 5/1/2002 21:41'!isSolid	^ solid! !!TMesh methodsFor: 'accessing' stamp: 'ar 10/26/2002 20:19'!material	^materialList first! !!TMesh methodsFor: 'accessing' stamp: 'ar 10/26/2002 20:19'!material: aMaterial	materialList at: 1 put: aMaterial! !!TMesh methodsFor: 'accessing'!materialList	^ materialList.! !!TMesh methodsFor: 'accessing'!materialList: ml	materialList _ ml.	self checkAlpha.! !!TMesh methodsFor: 'accessing' stamp: 'ar 10/12/2002 00:30'!normals	^vtxNormals! !!TMesh methodsFor: 'accessing' stamp: 'ar 10/12/2002 00:31'!normals: normals	vtxNormals := normals! !!TMesh methodsFor: 'accessing' stamp: 'das 7/10/2002 17:16'!opaque	^ opaque.! !!TMesh methodsFor: 'accessing' stamp: 'das 7/10/2002 17:16'!opaque: bool	opaque _ bool.! !!TMesh methodsFor: 'accessing' stamp: 'abc 7/31/2002 17:11'!pick: pointer" We are here because we already picked the top level boundSphere, so we know that is true. Now what we need to test against the hierarchy, which will return a list of faces if true - otherwise, it will return nil."	^ boundSphere pickChildren: pointer.! !!TMesh methodsFor: 'accessing' stamp: 'yo 9/24/2003 11:30'!scale: scale	vertices *= scale.	super scale: scale.	self scaleBounds: scale.	"self boundsChanged."! !!TMesh methodsFor: 'accessing' stamp: 'yo 9/24/2003 11:29'!scaleBounds: scale	boundSphere ifNil: [self boundsChanged. ^ self].	boundSphere scale: scale.! !!TMesh methodsFor: 'accessing' stamp: 'das 8/4/2004 23:17'!transparency: trans	self materialList do:[ :ml |		ml transparency: trans.		].	self checkAlpha.	frameChildren ifNotNil:[frameChildren do:[ :fc | fc transparency: trans].].! !!TMesh methodsFor: 'accessing' stamp: 'ar 6/22/2002 16:58'!vertices	^vertices! !!TMesh methodsFor: 'accessing' stamp: 'das 7/15/2002 20:14'!vertices: verts	vertices _ verts.! !!TMesh methodsFor: 'initialize' stamp: 'das 8/4/2004 23:20'!checkAlpha	opaque _ false.	alpha _ false.	1 to: faceGroups size by: 2 do:[:i |		((materialList at:(faceGroups at: i)) hasAlpha) ifTrue: [ self hasAlpha: true. ] ifFalse:[ self opaque: true.].		].	boundMaterial ifNotNil:[self hasAlpha: true].! !!TMesh methodsFor: 'initialize' stamp: 'DPR 1/9/2004 14:05'!initBounds	boundsDepth = 0 ifTrue:[		boundSphere _ TBoundSphere mtfBall: vertices. ]	ifFalse:[		faceGroups size = 2 ifTrue:[				boundSphere _ 			TBoundSphere calcTree: vertices faces: (faceGroups at: 2) depth: boundsDepth. ] 		ifFalse:[			boundSphere _ TBoundSphere mtfBall: vertices.			1 to: faceGroups size by: 2 do:[ :i || child |				child _ 				TBoundSphere calcTree: vertices faces: (faceGroups at: i+1) depth: boundsDepth-1.				boundSphere addChild: child.].			].].	boundSphere frame: self.	boundsChanged _ false.! !!TMesh methodsFor: 'initialize' stamp: 'ar 9/30/2004 13:09'!initializeWithVertices: v alias: a norms: n textureUV: tuv faceGroups: fg material: ml 	| mat |	vertices _ v.	alias _ a.	vtxNormals _ n.	textureUV _ tuv.	faceGroups _ fg.	alpha_ false.	opaque _ false.	mat _ ml.	mat ifNil:[ 		mat _ TMaterial new.		mat ambientColor: #(1.0 0.2 0.2 0.5) asFloatArray.		 ].	mat subMaterialList ifNotNil:[ materialList _ mat subMaterialList. ]	ifNil:[		materialList _ OrderedCollection new.		materialList add: mat.		1 to: faceGroups size by: 2 do:[ :i |			faceGroups at: i put: 1. ].].	1 to: faceGroups size by: 2 do:[:i |		faceGroups at: i put: 1+(((faceGroups at: i)-1)\\materialList size).		((materialList at:(faceGroups at: i)) hasAlpha) ifTrue: [ self hasAlpha: true.] ifFalse:[ self opaque: true].		].	self optimizeFaceGroups.	boundsDepth _ 2. "must always be a mimimum of 1 - the top sphere, and at least one recursion."	self boundsChanged.	glListID _ nil.	glListAlphaID _ nil.	self enableCaching."	This code is used to test the bounds sphere.""	boundMaterial _ TMaterial new.	boundMaterial ambientColor: #(0.7  0.2 0.1 0.3)asFloatArray.	boundMaterial diffuseColor: #(0.7  0.2 0.1 0.3)asFloatArray.	alpha _ true."	^self! !!TMesh methodsFor: 'initialize' stamp: 'ar 1/2/2003 04:52'!optimizeFaceGroups	"Optimize the face groups to minimize state changes"	| matList faces index |	matList := IdentityDictionary new.	1 to: faceGroups size by: 2 do:[:i|		index := faceGroups at: i.		faces := faceGroups at: i+1.		matList at: index put: ((matList at: index ifAbsent:[#()]) copyWith: faces).	].	index := 0.	matList keysAndValuesDo:[:mIndex :fList|		fList do:[:fGroup|			faceGroups at: (index := index+1) put: mIndex.			faceGroups at: (index := index+1) put: fGroup.		].	].! !!TMesh methodsFor: 'initialize' stamp: 'ar 6/26/2002 16:50'!validateFaceGroups	"Check to see if all face groups are valid. For debugging only."	| vtxSize face |	vtxSize := vertices size.	vtxNormals ifNotNil:[		vtxNormals size = vertices size ifFalse:[self error:'normal size mismatch'].	].	textureUV ifNotNil:[		textureUV size = vertices size ifFalse:[self error:'texture size mismatch'].	].	self faceGroupsDo:[:fg|		fg basicSize \\ 3 = 0 ifFalse:[self error:'Face group not divisable by 3'].		1 to: fg basicSize do:[:i|			face := fg basicAt: i.			(face >= 0 and:[face < vtxSize]) ifFalse:[self error:'Vertex out of range'].		].	].! !!TMesh methodsFor: 'collision' stamp: 'das 5/11/2002 15:07'!collideFloor: floor	(self boundSphere globalPosition y)-floor > boundSphere radius ifTrue:[ ^ nil ].	^ boundSphere collideFloor: floor transform: self globalTransform.! !!TMesh methodsFor: 'collision' stamp: 'das 5/8/2002 12:29'!collidePlane: normal offset: offset	| tNormal tOffset |" Simple test in world coordinates:"	(boundSphere globalPosition dot: normal)-offset > boundSphere radius ifTrue:[ ^ nil ]."Put the global coordinates of the plane into the local coordinate frame."	tNormal _ self globalOrientation orthoNormInverse localPointToGlobal: normal.	tOffset _ (tNormal dot: (self globalTransform orthoNormInverse localPointToGlobal: (normal*offset))).	^ boundSphere collidePlane: tNormal offset: tOffset.! !!TMesh methodsFor: 'testing' stamp: 'das 4/10/2003 23:15'!isMesh	^ true.! !!TMesh methodsFor: 'copying' stamp: 'DPR 1/9/2004 14:05'!postCopy	super postCopy.	materialList ifNotNil:[		materialList _ materialList collect:[:mat| mat copy].	].	self vertices: vertices copy.	self boundsChanged.	glListID _ nil.	glListAlphaID _ nil.	self enableCaching.	^ self.! !!TMesh methodsFor: 'fileIn/Out' stamp: 'das 7/28/2003 11:48'!postImportFrom: importer	super postImportFrom: importer.	glListID _ nil.	glListAlphaID _ nil.	self enableCaching.! !!TMesh methodsFor: 'fileIn/Out' stamp: 'das 7/10/2003 20:43'!prepareToExportOn: exporter	super prepareToExportOn: exporter.! !!TMorphMonitor methodsFor: 'initialize' stamp: 'ar 10/1/2004 08:12'!eventsTo: aTMorphic	"set where our texture updates go to"	eventsTo := aTMorphic.	aTMorphic morphMonitor: self.	"aTMorphic future: 0.0 perform: #morphMonitor: withArguments: { self }."	self sendTextureUpdate.! !!TMorphMonitor methodsFor: 'initialize' stamp: 'ar 10/4/2004 14:22'!initializeWithWorld: aProjName extent:  worldExtent	| proj |	aProjName ifNotNil:[		proj _ (Project named: aProjName).		proj ifNotNil:[world _ proj world].		world ifNotNil:[world viewBox: (0@0 extent: worldExtent)].	].	world ifNil:[		world _ PasteUpMorph newBounds: (0@0 extent: worldExtent).		world borderWidth: 0.		world beWorldForProject: nil.		world viewBox: world bounds.	].	form _ (Form extent: world extent depth: 32).	world canvas: (TWorldCanvas on: self).	world fullDrawOn: world canvas.	world canvas finish.	hands _ WeakKeyDictionary new.	^self! !!TMorphMonitor methodsFor: 'drag-drop' stamp: 'ar 10/1/2004 08:23'!initiateWorldDrag: pointer	"Check if this world's primary hand (the one controlled by the local user) is holding anything. If so, transfer it up to the root world so we can drop it into some other world later on."	| hand morph |	hand _ self handOfPointer: pointer ifAbsent:[^self].	hand hasSubmorphs ifFalse:[^self].	morph _ hand firstSubmorph.	morph delete.	morph setProperty: #offsetToHandInTMorphic toValue: (morph position - hand position).	CroquetGlobals acrossWorldsStuff at: pointer put: morph.! !!TMorphMonitor methodsFor: 'drag-drop' stamp: 'ar 10/1/2004 08:23'!initiateWorldDrop: pointer	"The hand of the given pointer just dragged some stuff out of the receiver. 	Make sure we got it. At some point we'll need a good place to store that stuff but right now we'll just do the Simplest Thing That Could Possibly Work (tm)."	| hand morph offset |	hand _ self handOfPointer: pointer.	morph _ CroquetGlobals acrossWorldsStuff removeKey: pointer ifAbsent:[^self].	hand attachMorph: morph.	offset _ morph valueOfProperty: #offsetToHandInTMorphic ifAbsent:[0@0].	morph position: hand position + offset.! !!TMorphMonitor methodsFor: 'accessing' stamp: 'das 8/15/2004 19:48'!addMorph: mrph	world addMorph: mrph.! !!TMorphMonitor methodsFor: 'accessing' stamp: 'DPR 5/23/2004 13:14'!addMorphCentered: mrph	world addMorphCentered: mrph.! !!TMorphMonitor methodsFor: 'accessing' stamp: 'DPR 5/26/2004 17:23'!canvasForm	^form.! !!TMorphMonitor methodsFor: 'accessing' stamp: 'DPR 5/23/2004 13:14'!color: clr	world color: clr.! !!TMorphMonitor methodsFor: 'accessing' stamp: 'DPR 5/23/2004 13:14'!world	^world! !!TMorphMonitor methodsFor: 'events' stamp: 'DPR 7/8/2004 23:01'!destroyHand: pointer	| hand |	hand _ self handOfPointer: pointer ifAbsent: [^self].	hands removeKey: pointer.	world removeHand: hand.! !!TMorphMonitor methodsFor: 'events' stamp: 'DPR 7/8/2004 22:59'!handOfPointer: pointer	| hand |	^hands at: pointer ifAbsentPut:[		hand _ THandMorph new.		world addHand: hand.		hand		]! !!TMorphMonitor methodsFor: 'events' stamp: 'DPR 7/8/2004 22:57'!handOfPointer: pointer ifAbsent: aBlock	^hands at: pointer ifAbsent: aBlock.! !!TMorphMonitor methodsFor: 'events' stamp: 'ar 10/1/2004 09:57'!handleEvent2D: someEvent pointer: pointer	| aHand priorHand |	aHand _ self handOfPointer: pointer.	someEvent setHand: aHand.priorHand _ ActiveHand.ActiveHand _ aHand.	[aHand handleEvent: someEvent] on: RequestProjectOwner do:[:ex| ex resume: self].ActiveHand  _ priorHand.! !!TMorphMonitor methodsFor: 'events' stamp: 'DPR 5/23/2004 14:34'!pointerEnter: pointer	self handOfPointer: pointer.	"Note: must be done *after* hand got created"	self initiateWorldDrop: pointer.! !!TMorphMonitor methodsFor: 'events' stamp: 'DPR 5/23/2004 14:34'!pointerLeave: pointer	"Note: Must be done *before* hand is destroyed."	self initiateWorldDrag: pointer.	self destroyHand: pointer.! !!TMorphMonitor methodsFor: 'events' stamp: 'ar 10/1/2004 07:56'!stepMorph	| |	world ifNil: [^self].	"if croquet running late by more than one step time, skip steps"	"tardiness _ Croquet tardiness.	tardiness < 67.0 ifTrue: [ tardiness _ 0.0. ].	stepDelta _ 67.0 + tardiness.	self future: stepDelta deferRelative: stepDelta perform: #stepMorph."	[world runLocalStepMethods] on: RequestProjectOwner do:[:ex| ex resume: self].! !!TMorphMonitor methodsFor: 'as yet unclassified' stamp: 'DPR 5/23/2004 14:18'!close	world := nil.	eventsTo := nil.! !!TMorphMonitor methodsFor: 'as yet unclassified' stamp: 'DPR 8/10/2004 17:12'!sendDamage: aRect	eventsTo ifNotNil: [eventsTo future: 0.0 perform: #updateArea:with: withArguments: { aRect . form contentsOfArea: aRect }.].! !!TMorphMonitor methodsFor: 'as yet unclassified' stamp: 'ar 10/4/2004 14:22'!sendTextureUpdate	eventsTo ifNil: [^self]."	self future: 125.0 deferRelative: 125.0 perform: #sendTextureUpdate."	world ifNil:[^self].	[world runLocalStepMethods] on: RequestProjectOwner do:[:ex| ex resume: self].	world canvas ifNil:[world canvas: (TWorldCanvas on: self)].	world privateOuterDisplayWorld.! !!TMorphMonitor methodsFor: 'project switches' stamp: 'DPR 5/26/2004 17:22'!enter: returnFlag project: aProject	| oldProject |	oldProject := world project.	aProject == oldProject ifTrue:[^self].	aProject mayEnterTeaProject ifFalse:[^self].	world canvas: nil.	oldProject leaveTeaProject.	aProject enterTeaProject.	world := aProject world.	world viewBox: (0@0 extent: form extent "* self uvScale").	world canvas: (TWorldCanvas on: self).	world fullDrawOn: world canvas.	world canvas finish.! !!TMyCube methodsFor: 'events' stamp: 'das 1/23/2004 00:48'!handlesPointerDown: pointer	^ true.! !!TMyCube methodsFor: 'events' stamp: 'das 1/23/2004 00:55'!pick: pointer	^ true.! !!TMyCube methodsFor: 'events' stamp: 'das 1/23/2004 02:13'!pointerDown: pointer	move := move not.	^ true.! !!TMyCube methodsFor: 'initialize' stamp: 'das 2/17/2004 17:06'!initialize	super initialize.	txtr := TTexture				new initializeWithFileName: 'rchecker.bmp'				mipmap: true				shrinkFit: false.	boundSphere := TBoundSphere localPosition: (0@0@0) radius: (3.0 sqrt).	boundSphere frame: self.	move := false.! !!TMyCube methodsFor: 'testing' stamp: 'das 1/23/2004 00:43'!isComponent	^ true.! !!TMyCube methodsFor: 'render' stamp: 'das 7/1/2004 00:35'!render: ogl	| dx dy dz |	move ifTrue:[ self update ].	dx := 1.0.	dy := 1.0.	dz := 1.0.		txtr ifNotNil:[txtr enable: ogl].	ogl glBegin( GLQuads ).	ogl glNormal3f( 0.0, 0.0, 1.0).	ogl glTexCoord2f(0.0, 0.0). "1"	ogl glVertex3f( dx negated, dy, dz ).	ogl glTexCoord2f( 0.0, 1.0).	"2"	ogl glVertex3f( dx negated, dy negated, dz ).	ogl glTexCoord2f( 1.0, 1.0).	"3"	ogl glVertex3f( dx, dy negated, dz ).	ogl glTexCoord2f(1.0, 0.0).	"4"	ogl glVertex3f( dx, dy, dz ).	ogl glNormal3f( 0.0, 0.0, -1.0).	ogl glTexCoord2f(0.0, 0.0). "1"	ogl glVertex3f( dx, dy, dz negated ).	ogl glTexCoord2f(0.0, 1.0).	"2"	ogl glVertex3f( dx, dy negated, dz negated ).	ogl glTexCoord2f( 1.0, 1.0).	"3"	ogl glVertex3f( dx negated, dy negated, dz negated ).	ogl glTexCoord2f(1.0, 0.0).	"4"	ogl glVertex3f( dx negated, dy, dz negated ).	ogl glNormal3f( 1.0, 0.0, 0.0).	ogl glTexCoord2f(0.0, 0.0). "1"	ogl glVertex3f( dx, dy, dz ).	ogl glTexCoord2f(0.0, 1.0).	"2"	ogl glVertex3f( dx, dy negated, dz ).	ogl glTexCoord2f( 1.0, 1.0).	"3"	ogl glVertex3f( dx, dy negated, dz negated).	ogl glTexCoord2f(1.0, 0.0).	"4"	ogl glVertex3f( dx, dy, dz negated).	ogl glNormal3f( -1.0, 0.0, 0.0).	ogl glTexCoord2f(0.0, 0.0). "1"	ogl glVertex3f( dx negated, dy, dz negated).	ogl glTexCoord2f(0.0, 1.0).	"2"	ogl glVertex3f( dx negated, dy negated, dz negated).	ogl glTexCoord2f( 1.0, 1.0).	"3"	ogl glVertex3f( dx negated, dy negated, dz ).	ogl glTexCoord2f(1.0, 0.0).	"4"	ogl glVertex3f( dx negated, dy, dz ).	ogl glNormal3f( 0.0, 1.0, 0.0).	ogl glTexCoord2f(0.0, 0.0). "1"	ogl glVertex3f( dx, dy, dz ).	ogl glTexCoord2f(0.0, 1.0).	"2"	ogl glVertex3f( dx, dy, dz negated).	ogl glTexCoord2f( 1.0, 1.0).	"3"	ogl glVertex3f( dx negated, dy, dz negated).	ogl glTexCoord2f(1.0, 0.0).	"4"	ogl glVertex3f( dx negated, dy, dz ).	ogl glNormal3f( 0.0, -1.0, 0.0).	ogl glTexCoord2f(0.0, 0.0). "1"	ogl glVertex3f( dx negated, dy negated, dz negated).	ogl glTexCoord2f(0.0, 1.0).	"2"	ogl glVertex3f( dx, dy negated, dz negated).	ogl glTexCoord2f( 1.0, 1.0).	"3"	ogl glVertex3f( dx, dy negated, dz ).	ogl glTexCoord2f(1.0, 0.0).	"4"	ogl glVertex3f( dx negated, dy negated, dz ).	ogl glEnd.	txtr ifNotNil:[txtr disable: ogl.].! !!TMyCube methodsFor: 'accessing' stamp: 'das 1/23/2004 00:32'!boundSphere	^ boundSphere.! !!TMyCube methodsFor: 'simulation' stamp: 'ar 9/30/2004 14:54'!update	| t delta |	t := TeaTime now asFloat/1000.0.	delta := 3 * (t sin @ t cos @ (t sin * t cos)).	self translation: delta.! !!TObject class methodsFor: 'accessing' stamp: 'ar 9/16/2004 16:16'!howToPassAsArgument	^#passByReference:! !!TObject class methodsFor: 'accessing' stamp: 'ar 10/2/2004 08:29'!new	" create a veiled instance in the current CroquetProcess's CroquetWorld"	^self basicNew		initialize. "public constructor"! !!TFrame class methodsFor: 'class initialization' stamp: 'ar 9/7/2002 19:22'!initialize	"TFrame initialize"	self initializeIcons.! !!TFrame class methodsFor: 'class initialization' stamp: 'ar 9/7/2002 19:30'!initializeIcons	"TFrame initializeIcons"	"Initialize script icons"	| icon iconClass iconName iconFile |	{		{TFrame. 'frame8.gif'}.		{TWindow. 'window8.gif'}.		{TCamera. 'cam8.gif'}.		{TSpinner. 'spin8.gif'}.		{TLight. 'light8.gif'}.	} do:[:spec|		iconClass := spec first.		iconName := spec last.		iconFile := [(FileDirectory default directoryNamed: 'icons') readOnlyFileNamed: iconName]			on: Error do:[:ex| ex return: nil].		iconFile ifNotNil:[			icon := Form fromBinaryStream: iconFile.			icon mapColor: Color white to: Color transparent.			iconFile close.			iconClass scriptIcon: icon.		].	].! !!TFrame class methodsFor: 'accessing' stamp: 'ar 9/7/2002 19:17'!scriptIcon	scriptIcon ifNotNil:[^scriptIcon].	self == TFrame ifFalse:[^self superclass scriptIcon].	"TFrame *must* have an icon"	scriptIcon := Form extent: 11@11 depth: 8.	scriptIcon getCanvas drawString: '?' at: 0@0.	^scriptIcon! !!TFrame class methodsFor: 'accessing' stamp: 'ar 9/7/2002 19:18'!scriptIcon: aForm	scriptIcon := aForm.! !!TButton class methodsFor: 'accessing' stamp: 'das 9/11/2002 11:31'!downColor		^ #(0.2 1.0 0.5 0.8) asFloatArray.! !!TButton class methodsFor: 'accessing' stamp: 'das 9/11/2002 11:35'!hiliteColor		^ #(1.0 1.0 0.2 0.5) asFloatArray.! !!TButton class methodsFor: 'accessing' stamp: 'das 9/11/2002 11:30'!normColor		^ #(0.5 0.7 0.7 0.5) asFloatArray.! !!TButton class methodsFor: 'accessing' stamp: 'das 9/11/2002 11:30'!overColor		^ #(0.2 0.5 1.0 0.8) asFloatArray.! !!TEditBox class methodsFor: 'instance creation' stamp: 'das 2/17/2004 17:24'!castSpell: pointer	| sf |	sf _ pointer  selectedFrame ifNil:[^ nil].	^self new initializeWithContents: sf.! !!TForm class methodsFor: 'instance creation' stamp: 'das 7/4/2004 21:21'!defaultForm	^DefaultForm ifNotNil:[DefaultForm] ifNil:[DefaultForm _ Form extent: 64@64 depth: 32 bits: (Base64MimeConverter mimeDecode:   '8AAS/wAAAQf/AQEBFv8AAAEH/wABARL/AAABB/8BAAEK/wAAAQf/AAEBCv8AAAEH/wARAAr/AAABE/8BAAD/AAEA/wAAAf8SAAAS/wAAAQf/AAEAEv8AAAEH/xEAAAr/AAABB/8BAAAO/wAAARv/AQAA/wAAAf8BAAH/AAAB/wEBAP8BAAAW/wAAAQf/AQABRv8AAAEP/wEAAP8AAAH/EhEQDv8AAAEH/wEAACr/AAABB/8BAAAi/wAAAQ//AQAA/wAAAf8BAAES/wAAAQf/AQAAIv8AAAEH/wEAADL/AAABB/8REREa/wAAAQf/AQEBFv8AAAEX/wEAAf8AAAH/AAEA/wAAAf8BAAAK/wAAAQf/AQAQGv8AAAEH/wABARL/AAABB/8AAQIW/wAAAQf/AAEBKv8AAAEH/wEAAF7/AAABC/8BAAD/AAEBHv8AAAEH/wABEwr/AAABCv8BAABP/wAAAf8BAAH/AAAB/wERAf8iAQD/ZgAB/6oAAP+qAAH/qwAB/6oAAf+qAAD/vAAA/7sAAf+qAAH/ZgAA/zMAAf8hAAH/AAAB/wEAAQr/AAABE/8RAAD/AAEA/wAAAf8BAQES/wAAARP/AQAA/wABAf8AAAH/AQECQv8AAAEH/wEAARL/AAABB/8BAAEe/wAAAQv/MwAA/1QAAAr/AAABF/8BEQH/AAAB/xEAAP9mAAD/uwAACv+qAAEH/6sBAQr/qgAAK/+qAQH/mQAA/7sBAf9WAAD/EQAA/wAAAf8BAAD/AQAB/wEAAP8SERIK/wAAARP/AAEB/wABAP8AAAH/AQAAXv8AAAEP/wEAAf8AAAH/AQABCv8AAAE//wEAAf8AAAH/AAEA/wAAAf8iAAD/dwAA/7wBAP+ZAAD/ACIA/yIiIv8AEQH/AAAB/xEQEv+IAAD/ugAACv+qAAEf/6sBAf+qAAD/qQAA/6oAAf+qAAL/uwAB/1UAABb/AAABD/8RERH/AAAB/wEBARb/AAABB/8AAQBO/wAAAQv/AQAB/wEBARL/AAABB/8AAAIK/wAAATP/AQAA/1UAAP+7AQD/uwAA/7wAAP+YAAD/AAAi/yIiIf8AAAH/AAEA/wAAAf93AQAK/6sAAD//qgAB/6sAAf+qAQD/qgAA/6oBAv+pAAH/qwEB/1UAAP8AAAH/AAEC/wABAf8AAAH/AAEA/3cAAv8AEQEK/wAAAQf/AQAAEv8AAAEP/wEAAP8AAAH/AQAAQv8AAAEP/wEAAP8AAAH/AAEADv8AAAEv/wEBAf8hAAD/VQEA/4gAAP+pAQH/mAAA/7sAAf+rAAD/mQAz/xEAAP8BAAAO/wAAAWP/iAAA/7sAAP+qAAH/qgAA/7sAAf+YAAD/qwAA/7wBAv+ZAAD/qgAA/1UAAP8BAAD/AQAB/wAAAf8AAQH/AQAB/6sBAP+qAAD/qQAB/2YAAP8hAAD/AAAB/wABAP8RAQAO/wAAAQf/EQABKv8AAAEH/wEAABr/AAABD/8BAAD/AAAB/wEAAAr/AAABF/9FAAH/iAEA/7sAAf+qAAH/uwAACv+qAAEX/7oAAP+qAAH/AAEA/wEAAf8BAAAK/wAAAUP/dgAA/6oAAP+qAQD/qgAA/6oAAf+qAQD/qgAA/6oBAf+qAQL/qgAB/1UAAf8AAQD/EQAA/wEAAP8AAAH/EQAADv+qAAAr/5kAAP+rAAH/EQAB/wAAAf8AAQH/AAAB/wEAAP8AAAH/AREB/wABARL/AAABB/8BAAEK/wAAAQ//AQAA/wABAP8BAAAK/wAAAQr/AQAACv8AAAEL/wEAAP8BAQAK/wEAAAr/AAABD/8BEQH/IgAB/1UAAQr/dgAAE/+qAQH/mQAA/6oAAv8BAQAO/wAAAR//AQAA/3cAAP+qAAD/qQAB/6oAAf+qAQD/qgEBCv+rAAEX/7kAAP+8AQH/VQAB/wAAAf8AABEK/wAAAQf/EQAACv+qAAA3/6oAAf+aAAH/qgAA/1YAAP8iAAD/AQAA/wAAAf8AAQD/AAAB/xEREv8RERD/AAAB/xARERb/AAABD/8BAAD/AAAB/wABAAr/AAABCv8BAAAO/wAAAQ//AQAA/wABAP8AAAEO/wABAAf/AAABCv8BAAAT/yEAAP9UAAH/ZgAB/6oAAA7/AAABa/8AAQH/AQAB/3cAAP+qAAD/qQAB/6sAAf+qAAH/qgAA/6oAAf+rAAD/ugAA/7sAAf9VAAD/AQAB/wEAEf8BAAD/AAAB/xIAAf+qAAD/qwAA/6oAAP+7AAD/mQAA/6oAAf9VAAD/IgAACv8AAAEL/wEAAf8REhEO/wAAAQv/ERER/wEAABL/AAABB/8AAQAS/wAAAQr/AQAAGv8AAAEL/wAAEv8BAQEK/wAAASP/AAEA/wAAAf8BAAH/ABAA/yIAAP8AAAH/AQAB/wEAAAr/AAABG/+7AAD/mAAA/6oAAv+rAAH/qgAB/6oAAgr/uwABE/+pAAH/qgAB/1QBAP8iAAAO/wAAATf/IgAA/5kAAP+qAAD/qgAC/6oAAP+ZAAD/qgAA/6oBAP+aADT/MwAA/wABAP8BAAD/IgABDv8AAAEH/wABAAr/AAABE/8BAAD/AAAB/wEAAP8AAQAO/wAAAQf/AQAAEv8AAAEH/wABAAr/AAABCv8AAQAS/wAAAQf/AQEBDv8AAAEP/wEAAf8AAAH/ERESCv8AAAFX/xEREf8SERL/IQAA/1UAAP93AAD/mQAA/6oAAf+8AAH/qgAB/7sAAf+IAAD/EhIS/wAAAf8QERH/AAAR/wEAEf+ZADT/qwAB/4gAAP+YAAD/uwEBCv+qAAEj/7sAAP+IAAD/IgAB/wAAAf8AACL/EBER/xEAAP8RAAEe/wAAAQ//AQAA/wAAAf8BAAAi/wAAARv/AAEA/wAAAf8AAQD/AAAC/wEAAP8AAQEK/wAAAQf/ISIiDv8AAAEH/xEQEQr/AAABh/8REA//ERER/wEAAf8RAAD/EAAA/yEAAf9EAAH/RAAA/3YAAf+IAAD/iQAA/4gAAP8AAAH/EhER/wAAAf8BAAD/dwAA/6oAAf+pAAH/uwAB/7sBAf+pAAD/qwAC/6oAAP+HAAD/VQAA/1YAAP8AACL/AAAB/xAAAP8RAAD/AQAA/wEAAQr/AAABD/8BAAD/AAEC/wEAAQr/AAABCv8BAAFD/xEREP8AEQD/EBIR/yIiIv8RERD/ISIh/1UBAP+aADL/iAAA/3cAAf94AAH/VQEA/yIiI/8SAAD/EhAS/xEAAAr/ERERB/8AACIS/wAAATf/EQAB/wEAAf8AAAH/AAEA/wEBAP8BAAH/AAAB/wARAP8iAAD/QwAA/0QAAP8AAAH/EgAACv8RAAAz/2YAAf+ZAAD/qwAB/5kAAP+7AAD/qwAB/6sAAP+qAAH/mQAA/6sAAf+IAAH/MgABCv8AAAET/yEAAP8SERL/EgAA/xEAAA7/AAABP/8BAAH/AAAB/xIREf8REhH/EhES/xEREP8iAAD/EhIQ/xEREv8SERH/AAAR/yIAAP+HAAD/qgEB/7sBAQr/mQAAF/+qAAD/ZgAB/2YBAP8zAAD/MwABCv8AAAEH/wABAQ7/AAABL/8BABL/EQAB/xAAAP8RAAD/AAAj/wABAP8AAAH/AAAR/wERAP8AAAH/ERIREv8RAABD/1UAAP+HAAD/uwEA/6oAAf+qAAD/uwAB/6sBAf+qAQD/mAAA/6sAAP+pAAD/dwAB/yIAAf8QAAD/AAEA/yIAAAr/AAABF/8BAAD/AAAB/wEBAP8AAAH/AAEADv8AAAEP/wEAAf92AAD/AAABCv8BAAAK/wAAAS//dgAA/6oAAP+qAAH/qwAB/6sAAv+7AAD/qgAA/4gAAP+IAAL/dwAA/0QAACb/AAABB/8BAAAS/wAAAQf/AQAADv8AAAEP/wARAP8BABL/ABEACv8RAABL/yMAAf+IAAD/RAAA/3cAAP+7AQD/vAEB/6oAAP+rAAD/uwAA/1UAAP8SAAD/AAEB/xEREf8SAAH/EAAA/wAAEf8AAAH/AQACCv8AAAEf/wEAAP8AAQH/AAAB/wABAP93AAD/AAEA/wEBAA7/AAABI/93AAD/qgAA/6kAAP+rAAH/qgAB/7sAAP+qAQH/qwABCv+qAAAH/3cAABb/AAABB/8RAAAK/wABAA//AAAB/xEBAP8BAAAO/wAAAQr/AQAAX/8AAQD/AAAB/wABEf8AARD/AAAB/wERAf8AAAH/ABEA/wABAP8SERH/AAAB/wERAP8iAAD/RAAB/3YAAP+qAAD/VQAA/yIAAP8AAAH/ERER/xAAAf8SERH/AAARCv8AAAEf/wABAP8AAAH/AAAS/wAAAf8AABH/IgAA/5kAMw7/AAABK/8iAAH/AAAB/xEQEf+ZAAD/qwAB/6oBAf+ZAAD/ugAA/6oAAP+rAAEK/5kAAA//qwAB/xEAAP8REBEK/wAAARP/EQAB/4cAAP+8AAH/mAAACv+ZAAAf/4cAAP9VAAD/MwAA/xEAAP8AAAH/AAAi/xEAABL/AAABL/8AAQD/EBEQ/yEAAP8iAAH/EQAA/wARAP8AAAH/ABEB/wEAAP8AAAH/MwAACv9EAAA7/yIAAP8iAAH/IyIi/xEAAP8BABL/EQAA/wEAAP8SEBL/ERER/xEREv8AAQH/ACIA/1YBAf+qAAEK/wAAAT//AREA/wAAEv8AAAH/IgAA/6oAAP+rAAD/qwEB/6oBAP+6AAD/qgAA/6sAAP+qAQD/uwAB/6sAAf8iAAEK/xERETv/EBAQ/xEREf9VAAH/qQEA/7oAAP+qAAD/qwAA/7wBAf+HAAD/iAEA/4cAAP9VAAH/VQAA/4gAAQ7/AAABL/8RERH/AAEA/wEAAf8SEBH/AAAh/xASEf8RERD/AAAB/yIiIv8SERD/ERERDv8AAAEH/wEBAAr/AQABCv8BAAAP/wEBAP8AAAH/AQAADv8AAAEb/1UAAP+HAAD/ugAA/wAAAf8BAAD/IgAACv8AAAEL/wAAEf+qAAAK/6oAARP/qwAC/7oAAP+rAAH/qwACCv+qAAEL/6oAAP9UAAAK/xEREhP/ERER/xEQEf9VAAD/qQABDv+7AAAK/6sBAQr/uwAAE/+rAQD/qgAA/4gAAP8QEhEK/wAAAR//EBIS/wAAEv8SEBL/ERIS/wAAI/8AAAH/EREQDv8AAAEH/wEAAQr/AAABB/8BAAAO/wAAATf/IQAA/wAAAf8BAAD/AQAB/wEAAP8AAAH/AQAA/xAAAP9VAAD/qgAB/7sAAf8iAQH/AQAAEv8AAAE7/5gAAP+rAAH/qgAA/6oAAf+qAAD/qQAA/6oAAf+7AAD/qwEB/6oAAf+IAAD/EQAA/xESEv8RERIK/xEREQf/lwAACv+qAAEv/7sAAP+rAAD/qwAB/6oAAP+YAAD/qgAB/6sBAf+YAAD/IgAA/wAAAf8BAAAK/wAAARf/AQEB/zMAAf8hAAD/AQAA/xEAABb/AAABE/8BAAH/AAAB/wAQAf8RAAEK/wAAAQf/EQAAFv8AAAEK/4gAACP/qgAB/7sAAP94AAD/EQAA/wEAAP8BABD/AAEB/wAAAQ7/qgAAg/+rAQH/mQEA/7wBAf+qAAH/mQAA/6oAAP+rAAH/qQAC/0UAAf8iAAD/EBER/xEREv8iAAD/VAAA/6oAAv+rAAD/ugEA/6oAAP+qAAH/mQAA/6sAAf+8AAD/uwAA/7sBAf9mADT/IwAB/wAAAf8RAAD/AAAB/wABAP93AAD/qgAACv+7AAAj/4kAAP9WAAH/VQAA/yIAAf8RAAD/AQAB/wAAAf8AABIW/wAAAQr/AAEAN/8AAAH/AQAB/wEAAP8AARH/AREA/yEAAP9EAAD/ASIA/wAAAf8iIiH/AAAB/wABAP+ZAAAK/6oAASv/qwAB/6oBAf+rAAH/qgAA/6sAAf+rAQD/qgEA/6sAAf+HAAD/ERAQCv8AAAEK/yIAADv/iQAA/7sAAP+rAAH/qwAA/6oAAP+qAQH/uwEC/6kAAP+qAAH/uwAA/3cAAP93AQD/ERER/wEAAAr/AAABP/8AEQD/VgAA/7sAAP+8AAD/qgAC/6oAAP+8AAD/uwAA/4gAAP9VAQD/VAAA/yEAAP8AAAH/AQAA/wAAAQr/AQABM/8AAAH/ERER/yIjIf8QERH/AAAB/yIhIv8AACL/EBES/xEREP8RERH/AQAB/yEhIgr/AAABF/8zAAD/iAAA/6sAAf+qAQD/ugAACv+qAAEX/7sBAP+rAAH/qQAA/6sAAP+HAAAO/wAAARP/IgAA/yMAAP9EAAH/vAABCv+qAAEr/6oBAf+qAAD/uwAB/6wAAf+ZAAD/qwAC/6kAAP+rAAH/IgAA/xEAAA7/AAABE/8hAAD/uwAA/7wAAf+pAAAK/6oAACP/uwAB/6kAAP+qAQH/qgAA/3YAAP9VAAD/AAAB/wEAAAr/AAABB/8RERAK/xERERf/EREQ/xIREf8BAAD/AAEA/xEREQr/AAABC/8CAAD/AAARCv8AAAE3/yIAAP9EAAD/RQAB/7sAAP+8AAH/qwEB/6oBAf+8AAH/mAAA/6kAAP+qAAD/hwAA/wABAAr/AAABF/8iAAD/ERER/yIAAP+qAAH/vAAADv+qAAAz/6sAAf+qAAD/qgAB/6oAAv+qAAD/qgEA/3cAAP8hAAD/AQEB/wABAf8AAAH/IgAACv+IAAAf/6oAAf+qAQD/qgAB/6oAAP+7AAH/qwAC/6oAAAr/mQAAEv8AAAET/zMAM/8iIiH/IiIi/yEAAAr/ERARZ/8iIiL/IyIi/xEREv8jISP/EBER/wAiAP8RERH/EhES/xESEP8iIiL/EhES/xEREv8zAAH/VQAB/1UAAP93AAH/mAAy/7sAAf+7AAD/qwAA/1UAAP8SERH/ERER/xEREP8REREK/1UAAHf/qwAB/5kAAP+7AQH/mgA0/5kAAP+qAAD/qgAB/7wAAP+6AQD/qQAA/6sAAf9lAAD/EhER/xIREP8iIiL/MwAA/yIiIv9UAAD/qgAB/7sAAP+6AAD/uwEB/5gzAP+qAQL/qgAA/5kAAP+8AAD/EREP/xIREQr/ERERF/8AAAH/AQAA/wAAAf8jAAH/EAAACv8BAAAO/wAAAQr/AQAAD/8AAAH/AQEA/wEAASb/AAABD/8AABH/hwAA/1UAAAr/ABEBDv8AAAEn/wEAAP+qAAH/qgAA/6kAAP+aAAD/vAAA/7sAAP+7AAH/vAAACv+ZAAAL/6kAAP+IAAEO/wAAAQf/AQAACv8AAAE3/1QAAP+qAAH/qgAA/6oBAf+qAAH/qgAA/6sAAP+rAAH/qwAA/xAAAf8SAQD/EhAR/xEREQr/AAABD/8BAAH/iAAA/2cAAQr/RAAAB/8iAAAK/xEAAAv/AAAB/wEBABL/AAABB/8CAAEO/wAAATv/AQAA/wAAAf8BAQH/AAAB/wEAEf8SAAD/EBER/wARAf8AAAH/EAAA/xABAP8AAAH/AQAC/4gBAAr/qgABB/+ZAQAO/7sAAB//qgAB/6oBAP+7AQH/ugAA/6oBAP94AAD/EgAACv8AAAEH/wEAAQr/AAABCv+qAAEK/6kAASf/qwAA/6oBAf+pAAD/qgEB/yIAAP8iISH/EBAR/xEQEf8RAAAK/wAAARP/mQA0/7sAAP+rAAD/qQAADv+ZAAAb/3cAAP9UAAD/AQAB/wABAP8AEQD/AAEBDv8AAAEH/wEAAAr/AAABF/8BAAH/AAEA/wEBAf8BAAD/ABEBCv8AAAEL/yIAAP8QAAAK/xEAABv/NAAB/3cAAP92AAH/mTMz/4cAAP+IAAAO/6oAATv/ugAA/6oAAf+ZAAD/qgAA/2cAAP8iAAD/ERAQ/xIAAf8RERH/EBAR/yMAAP+IAAD/iAAB/5gAAA7/qgABB/+YAAAK/wAQAB//EAEA/wAAAf8RAAD/AQAA/wAAAf+aAAD/qgABCv+7AAAb/5kAAP+qAAD/vAAB/5kAAP9mAAH/AAASDv8AAAEP/xIREv8iAAH/EQAAEv8AAAGX/wEAAP8AAAH/EhER/wEAAf8BAAD/AAAB/yIAAP8AAAH/IgAB/wARAf8BAAD/EAAA/wAQAP8SAAD/MwAA/2YAAP+IAAD/mQAA/6oAAP+rAQH/qgAB/5gAAP+rAAD/qgEA/1UAAP8BIgD/ERER/xAREf8zAAD/ERES/xESEv9VAAD/mQAB/7sAAP+aAAH/vAAB/5kAAA7/AAABF/8RAAD/AAAB/wEAAP8AAAH/mQAADv+7AAAj/6oAAP+qAAH/qgAA/6sAAP+rAQH/AAAB/wAAAv8AAREK/wAAASP/MgAA/7oAAP93AAD/iAAA/zIAAP8RAAD/AAAB/wAAIgr/AAABCv8BAAAS/wAAARv/ERES/xEREP8RERH/IgAA/wEBI/8REBEK/xERESv/IyIj/xEREf8SERH/MwAA/0UAAP92AQD/iQAA/3YAAP8AAAH/EQAADv8AAAEP/xEREf8zAAH/RAEACv+7AAAT/6kAAf8BABL/AAAB/xEAABL/AAABV/+ZAAD/qgAB/6oAAP+qAAH/qgAA/6oAAf+6AAD/qwAA/6oAAf8QAAD/AQAA/xEREv8AAAH/ERES/xEQEf+rAAH/vAAA/4gBAP+ZAAD/iAAA/6kAAAr/IQAAB/8AAQAK/wAAASf/AAAS/xAREf8RERL/EhER/yIiIv8SEBL/ERER/wABAf8SAAAK/wAAAQr/AQABK/8AAAH/EhES/xEAAP8BAAD/EgAB/zMAAP9UAAD/EQAA/wAAAf8REBEO/wAAATf/AAEB/xEREf9EAAD/uwAA/6oAAP8AAQH/AAAB/xEQEf8AAAH/IiIh/yMhIf8iISH/mQAADv+7AAAf/6oBAf+rAAH/qgEB/6oAAf+ZAQD/qwAB/xIREQr/IiIjS/8RERH/EhEQ/5gAAP+pAQH/qwAB/5oAAP+qAQH/uwAA/7sAAf+qAQL/qgAB/5kAAP+YAAD/ZwA1/yMiIv8jISL/IiIj/wAAIgr/ERERD/8QERH/AAEi/xAREgr/AAABG/8BAAH/AAEB/wEAAf8AAAH/EhIR/wEAAQr/IgAAP/8REhH/AAER/xEAAP8BEAD/AREA/xIAAP8REBH/EQAA/xIBAf9VAAD/ZwA0/xEREP8AAAH/AQAA/xEAAAr/AAABD/8BAAD/dwAA/6sAAAr/qgABM/+rAAL/qgAC/6oAAP+rAAH/vAAA/3cAAP8iAAD/IiIj/yIiIv8hIiH/ERES/4cAAAr/qgAAL/+pAAD/qwAB/6oAAP+qAAH/uwAA/6oAAf+qAQH/qgAB/6oBAf8zADT/IwACCv8AAAET/xEREf8AAAH/AAAR/xIREgr/ERERDv8AAAEH/wEAABL/AAABB/8SEhEK/wAAAS//IyIi/xEAAP8iIiL/IyEi/yIiIf8iIiL/AAEA/wAAAf8BIgH/AQAA/wEAAQ7/AAABE/8AAQD/AAAB/3gAAP+qAQEO/6oAAAf/qwECCv+qAAEj/6sAAv+rAAH/VQAA/yMiI/8AAAH/AQAA/wAAAf8zAAAK/6sBAS//qgAB/6oAAP+rAQD/qwAC/7sAAP+qAAD/qwAC/6kAAP+qAAD/ugAA/zMAARb/AAABD/9VAAD/RQAA/0MAAAr/AAABB/8AAQAK/wEAAAr/AAABCv8BAAAK/wAAAQ//EQAA/wAAAf8BAAAK/wAAAQf/AAARGv8AAAEX/wEAAP8SERH/IiIi/xIREf94AAEK/6sAASf/qQAB/6sAAf+rAQH/qgEA/6sAAf+rAAD/mAAA/2cANf8iAQEK/wAAAXf/AQAA/wEQAP9EAQD/qwEB/6oBAf+YAAD/qgAB/6sAAf+ZAAD/qgEB/6oAAP+7AAD/qgAB/7sAAP+JAAL/IQAB/wAAAf8AAQD/AAAB/wABAP8AAAH/RQAB/4gAAP+JAAH/VQAA/1YAAf8BAAD/AAAB/wEBAAr/AAABF/8BAQH/AAEB/wEAAP8AAAH/AAEAFv8AAAEH/yEAABb/AAABF/8iIiH/ERAQ/wEAI/8zMwD/mQAzCv+ZAACX/5gAAP+qAAH/qwEB/7sBAP+ZAAD/ugAA/7wAAf9mMwD/AgEC/xEREf8RERD/AAAB/yEAAf+rAQD/qwEB/6oAAP+JAAD/iAEB/7wAAf+sAAH/qgAB/6oAAP+qAAH/mQAA/6sAAf+HAAD/VgEA/wABAP8BEQH/EQAA/wEAAP8AAAH/VAAA/7wAAP+rAAH/mQAA/6oAAQr/mQAAF/+rAAH/iQAB/2YAAP8hAAD/IgAAFv8AAAEb/wEAAf8AAAH/EgEB/wABIv8RAAD/AAARCv8AAAEf/wEAAf8BAAD/AAAB/wEAAP9VAAH/hwAA/4gAAAr/qwABB/+rAAAK/6sAARP/qgAA/6sAAf+IAAH/EQAACv8AAAEj/wABEv8RAQD/EQAA/6oAAP+rAAH/qgAB/6kAAf+rAAEK/6oAARv/qgAA/6sAAv+qAQH/qQAA/6oAAf9mAQIK/wAAAQv/EQAA/xAREAr/AAABP/9VAAD/iQAA/6oAAf+rAAL/qQAA/6oAAv+qAAD/qwAA/6sAAf+IAAD/mAAA/3cAAf9EAAD/QwAA/xAAABb/AAABC/8AASL/AAACGv8AAAEK/wERAEv/AQAS/zMAAv9WAQH/eAAB/6oAAP+rAAH/qwAC/6sBAf+8AAH/EQAA/wEBAf8AAAH/AQEA/xEREP8RERL/dwAA/6oAAP+qAQAK/6oAAA//qQAB/6sAAf+pAAEO/6oAAQr/qQAAE/8iAAH/AAAB/wEAAP8SAAAK/wAAASf/EhER/1UBAP+7AQH/qgAC/6oAAf+rAAD/qgAA/6wBAv+qAQIK/6oAARf/qwAA/6oAAP+IAAD/hwAA/4gAAAr/RAAAC/8QAAD/AAEAEv8AAAEP/wABAf8AAAH/AQABEv8AAAFj/wEAAf8BARP/IgAA/zMzAP8zAAL/iAAA/4gAAf+ZAAD/dwAB/3cAAP8RAAD/EBEQ/yIAAf8RAAD/VQAA/5oANP+7AAD/qwAC/5oAAP+rAAH/uwAB/7wAAP+qAAD/qQABCv+qAAB7/6sAAP+rAAH/VAAA/xEREf8AAAH/EgAA/xEAAP8AAAH/IgAA/1UAAP+ZAAH/uwAB/6oAAP+qAAH/mgAA/6kBAf+qAQD/qwAB/6oAAf+rAAH/qgAA/5gAAP+ZAAD/ugAA/7wAAP+IAAD/ZwAz/wABAf8AAAH/AAAQDv8AAAG7/wEAAf8AAAH/AAAQ/wIBEf8AAAH/AQER/wAAAf8BAAD/AAAB/wAAEf8AEQD/IgAA/0QAAP9mAAD/RQAA/yIAAf8RAAH/EQAA/xAAAP8RERH/ZgAC/6oAAf+qAQH/qgAB/6oAAP+rAAH/qgAB/5kAAP+7AAH/qgAA/6sAAf+YAAD/qwEA/3YAAP9FAAD/EQAA/wAAAf8SEhH/AAAB/xEQEf8RERH/RQAA/5kzAP+rAAD/qgAA/6sAAA7/qgABM/+ZAAD/uwAB/6oAAP+qAAH/qwAB/6oAAP+qAQH/iAAA/zMAAP8AARH/ABIA/wEAAQr/ERERO/8BAQD/ERER/xERD/8BAAH/AQEB/xEQEf8SERH/AAEA/xIREf8iIiL/ERES/yEiIf8iIiL/ARIBCv8RERFj/wEAAf8iIiL/EBIR/xEREv8iIiP/MwAA/yIiI/+pAAD/qgAB/6sAAP+qAAD/qgEA/6oAAP+rAAD/vAAA/7sAAP+qAAD/qwAA/6sAAf+IAAD/VAAB/wAiAP8BABD/EhERCv8AAAEf/xEREf8yADP/dwAA/7sAAf+pAAH/qQAA/6oAAgr/qgABCv+rAAAL/6oAAf+rAAEK/6oAACf/ZgEB/yIiI/8QEhD/IiIh/yMiIf8jIiT/AQAA/wAAAf8BAAAO/wAAARv/AQAA/wEAAf8AAAH/AQAA/wAAAf8SERIO/wAAARP/AQAB/wAAAf8AAQH/IyIjCv8AAAFX/yEiIv8QAAH/IiEh/wAAEf9GAAH/VgAA/3cAAP+IAAD/qQAB/7oAAP+7AAD/qgAB/6oBAf+rAAD/qgAB/7sAAP+6AAD/ACIA/wARAP8AABL/IiIiCv8AAAEr/wERAf8SAAD/VQAA/6oAAf+7AAD/qwAB/6oBAP+ZAAD/qwAB/6oBAQr/qgAAI/+qAAH/qwAA/zMzAP8RERH/EhER/yIhIv8iIiP/ERERDv8AAAEK/wEAAB//AAAB/zMAAP9mAAH/MwAA/yIAAP8AAQH/AgABIv8AAAET/yIAAf8AAAH/EBER/wEAAAr/IgAACv8QEREP/yMAAP9VAAD/iAABCv+IAAAL/6sAAP+7AQEK/6oAAQf/qgAACv+IAABj/zQAAP8BAAH/AQEB/xEREP8jAAH/EREQ/xEREf9mADP/mQAA/6oAAf+rAAD/mQAA/7wBAP+8AAH/uwAB/5gAAP+IAAD/hwAA/yIBAf8RERH/AAEj/xEAAf8AACL/ERESDv8AAAEH/wEAAQr/AAABK/8iAAD/mAAA/4gAAP92AAD/ZgAB/2YAAv8jAAH/IgAA/xEAAP8AAAEK/wEAARP/AREB/wAAAf8AABL/AAESDv8AAAF//wAAI/8AAAH/AQAA/wAAEP8AEQD/AREA/xIAAP8iAAH/ZgAA/3cAAP+HAAD/qgAA/5kAAP+7AQD/vAAB/2UAAP8RERH/ERES/yMiI/8iIiL/IyEh/yIiIf8zMwD/VQEB/5kAAP+8AAH/mQAA/6oAAP+8AAH/uwAA/7wAAAr/dwAAG/8AAAH/AAAR/xEQEf8AAAH/IwAC/xAREQ7/AAABB/8BAAAO/wAAAT//VgAB/6sAAP+qAAD/vAAB/5oAAP+pAQH/iAAA/2YAAf9WAAH/EAAA/wARAP8AAAH/AQAA/wAAAf8BAAEK/wAAAQf/AAEACv8AAAEP/wEAAP8AAQD/AQABCv8AAAFD/yMiIv8RERH/IiMj/yMiI/8iIiH/IiIi/yIiI/9VAAD/iAAA/0UBAP8hIyL/EREQ/yMAAf8RERL/EhIQ/xEREQr/AAABO/8BEQD/dwAA/6oAAf+qAQH/qgAA/5kAAP8iAAD/ABEB/xEREP8RERL/ERIR/wAAAf8SERL/ERESHv8AAAEb/xIAAv+rAAD/qgAC/7wAAf+rAAH/qQABCv+qAAEf/6sAAP+pAAD/qgAA/1UAAP9EAAD/ERER/wEAAAr/AAABB/8AACEO/wEAACf/AAAB/xEREf8AAAH/AAEA/yMiIv8RERD/IiIi/yMjIv8iISIK/yIjIgf/EQAACv8iAAAb/xEREf8REBH/EQAA/xESEf8QERH/ERERCv8AAAE7/wAAEv8SAAD/qgAA/6sAAf+qAAD/mQAA/xEBAP8AACL/EREQ/xEAAP8RERH/AQAA/wAAIv8SERIi/wAAASf/hwAA/4gAAP+qAAD/uwAA/5oAAf+qAAD/qgAB/7wAAf+qAQAK/6oBAT//uwAA/7sAAf9mAAD/IQAA/yIiI/8jIiH/MwAy/yIjIv8jIiP/IiIi/yIiIf8RERH/EBEQ/xIREf8AEQEK/wAAAQr/AAAQC/8BAAD/ERARCv8BAAFj/xEREP8AASL/IQAA/xEREf8RERD/IgAC/xESEf8SERH/EhES/wERAf8AABL/IAAA/0MAAP9VAQL/AAAR/xEREf8AACL/IgAA/wABIv8AEQD/EBEQ/xEAAP8AAAH/AAEACv8AAAEH/wABARL/AAABF/8RERH/vAAA/7sAAP+qAQD/qwABCv+qAAAX/7sBAP+YAAD/iAAB/6oBAf+qAAAK/4gAAC//IiMj/yMjIv8AACP/AAAB/xEQEf8iIiT/MgAy/wEAAP8BAAH/AQAi/wAAIQr/AAABC/8AEQD/AAARCv8AAAEn/xEREf8RERD/AAEh/wAAIv8RERL/AAAB/wEAAf8RERH/AAAiCv8REREL/xAREP8AAQAK/wAAASf/AAAj/wAAAf8AACH/ABEA/xAREf8REBD/ERER/wEBEf8QERES/wAAAQf/ERERDv8AAAEb/wEAAf8REBH/ZwAA/7sAAf+rAAH/qwAACv+qAAFn/6kAAP+qAAD/qgAC/6oAAP+qAQH/uwAA/4gAAP8hAAD/AAAR/wAAI/8AAAH/EBEQ/wAAEf8iAAD/dgAA/6oAAP93AAD/VgEA/yMAAf8AACH/ABEA/wEAEv8RERL/AAAR/wAAEAr/AAABCv8AASMK/wAAAQv/EhER/xEREQr/AAABB/8SEREO/wAAAQf/AAARCv8AAAEH/wAAIQr/ERERi/8RERL/ERAQ/xERE/8AAQD/AQAC/wAAAf8iIiP/ERER/xESEP8SEBD/IiIi/xAREP8SEBH/MwEA/2YAAf+7AAH/qgAB/6oAAP+qAQD/qgEB/6kBAv+rAQH/qQAA/6oBAf+7AAH/qgAB/0QAAP8BIgD/AREA/wEAAP8SERL/AQAS/wAAAf92AQAK/4gAACP/uwAA/3cAAP94AAD/ZQAA/6oAAP8REBH/IgAA/wABEQ7/AAABZ/8RERD/AQAB/wAAAf8RERD/ERER/wAAAf8AAQD/EhER/xEREv8AAQD/AAAB/xIREf8BASP/AAAB/wAAIf8AAQH/ERER/wEAEf8SERH/EREQ/yIiIv8jISL/ISIh/wAzMv8hIiMK/yEiIYP/IiIk/yIiIv8AIgD/ERES/wAAI/94AAH/qQAA/7sAAf+6AAD/qQAA/6sAAf+7AQD/qwAB/6oAAf+YAAD/uwAA/6oAAP+ZAAD/QwAA/wARAf8QERH/ERAR/xEREf8QERH/ACEA/2cAM/+ZAAD/mAAA/6oAAf+ZAAD/mAAA/6oAARL/mQAAC/9WAQH/MwABCv8AASIL/xEREf8AABEK/xEREVP/AQEi/xIREv8RERL/ERER/wEANP8RERH/EBEQ/xEREv8RERH/EhAS/xAREP8PERD/ERES/yEiIv8QERH/ERIR/yIiI/8iIiL/IyIi/xEREAr/IiIiB/8iIiEK/yEiIkv/IyIh/yIiIv+qAAL/qQAA/6oAAP+pAAL/qQAB/7sAAP+ZAAD/qgAB/6oAAv+pAAH/qgAB/4gAAP8RERH/EBER/wAAEP8hIiIO/yIiIh//VQEA/4kAAP+7AAD/ugAA/6oAAf+rAAH/qgABCv+qAAAP/6kAAP+qAAD/rAAACv+IAAAH/1UBABL/IiIiH/8BNDT/IiIi/yMjI/8RERH/AAAi/yIiIv8AADQK/yIiIhf/IiIk/yIiIf8hISH/AAAB/wEAAAr/AQABCv8AAAEP/xEREv8AEQD/IyIiCv8iIiIj/wAAIv8AAAH/AAEA/zIAAP+IAQD/uwAB/5gAAP+rAAEK/7sAAAf/qgABDv+qAAAn/5gAAP8jIiP/IiIi/wAAAf8iIiH/ERIQ/xIQEf8AAAH/ERERCv93AAAL/5oAAP+qAAAK/6oAAUP/qQAB/6sAAf+pAAD/qwEB/5kAAP+pAAD/ugEB/6oAAP93AAH/IiIj/yMiI/8BASP/AAAh/yIiIv8RERD/EBERCv8RERIf/wARAP8iIiL/ISIi/yMiI/8iIiH/EREQ/wABAQr/AAABB/8AASIK/wAAEhv/AAER/wABIv8AAAH/AAAR/wARAP8AASIK/wAAImf/ABAA/xEREv9nAAH/uwAA/5gAAP+qAQL/vAEB/6sAAv+pAAH/qwAA/6oAAP+qAAH/uwAB/4gAAP+HAAD/EhER/yEAAf8AABH/AAAS/xIAAP8AAAH/IyIi/7wAAP+qAAH/qwAACv+qAAAT/6sAAP+qAAD/qgAB/6kAAAr/mQAAR/93AAD/EBES/wASAv8AACH/EREQ/wAAI/8BACP/ABIB/wARAv8AASP/AQAi/wARAP8AADP/ABIB/wARAf8AASL/AAAjDv8AAAEX/wERAP8AABL/AAAR/wAAIf8BEgEK/wAAEif/AQEj/wARAP8BAAH/AAAB/wAAEf8AEQD/IgAB/zMAAP+ZAAAK/6oAAQf/qQAACv+ZAAAL/7wAAf+ZAAAK/6oAAUf/iAAA/zMAM/8AASL/ERAQ/xEREf8SERL/ERIR/xIAAP80ADP/mQAA/6oBAf+qAAH/mQAA/7sAAP+ZAAD/ugAA/6kAAQr/dwAAR/8zAAD/ERES/wEiAP8REhL/AAAh/xERE/8RERL/AAAi/wAAM/8AEAH/ACIA/wAAM/8AEQD/AREA/wERAv8AEQH/ABEAEv8AAAEP/xEREv8RERH/AQAQCv8AABEK/wAAIs//AAAR/xIREf8QERH/AAAh/wAAAf8BAAH/AQAA/wAAEf9VAAD/VQAB/5kAAP+8AAH/qgAB/6oAAP+rAQH/qwEA/6sAAf+qAAD/dwAB/xIREf8REBH/IiIi/xEREf8hIiH/ERIR/wEAAP8AARD/ERER/4gAAP+pAAH/qgAA/4cAAP9VAAH/hwAA/xEREf8SERL/EhER/yIjIv8BABH/ERER/xESEv8SERH/ERER/xAREf8RERH/EBIR/xESEv8AASP/EhER/wARAf8BIgEK/wARABL/AAABD/8QEhH/EREQ/wAAEgr/AAAiC/8AACP/AAAiCv8AASJX/xEQEf8AACP/ABEA/wABIv8AAQD/AQAR/wEhAP8RERD/DxAR/2YBAf92AAD/qgAA/6kBAP+qAQD/qwAB/6oAAP+qAAH/RAEA/yMiIv8jISH/EhESCv8iIyIv/xEREf8AABH/ERIS/wAiAP9mAAH/VAAA/xIREv8RERD/AQEi/xEREf8QEREK/yIiIhf/IiEi/yIiI/8iIiT/EBES/xIREQr/ERERJ/8RERD/EhES/xAREf8REhP/ASIA/wAiAP8AEQD/ABAC/wEAAAr/AAABG/8AASL/AAEj/wAAIf8AACL/ABEA/wABIgr/AAAiE/8AEQH/ABEA/wAQAP8AACIK/xERESf/ACIA/wAAM/8AEQD/AAAB/xESEf8SAAD/ERER/yIAAf9nADQK/4gAAA//uwAA/5kAAP+qAAEK/6oAACP/VQAA/yMjIv8BABH/EAEA/yIjI/8REhH/ERAR/xAREAr/AAAiV/8AIQD/ACMA/xEREf8REBD/EQAA/xEREP8RERH/IiEj/wEAIv8jIiP/AAAi/wEAI/8hIiP/IgEB/yIAAP8QERH/ERIS/wAAIv8AEQD/AQAj/wAjAA7/AAABJ/8AEAH/ABEA/wERAP8AACL/AQA1/xEREf8AACH/EhEQ/wABIgr/AAAjDv8RERE3/wAAEv8AAAH/ABEA/xIREf8AACL/ABEA/wAAEv8AASL/ARIA/yIhIv9FAAH/ZgAA/5kAMgr/dwAAC/94AAD/ZwAzCv8RERBz/xIREv8AACL/AAAj/xEREf8BARL/AAAh/wABIv8RERH/AQAz/wAAI/8RERL/AQA1/xEREf8iIyL/IiIi/wAAI/8BACP/ERES/xEREf8REhL/ERER/xEREv8SERH/AQEz/wEAI/8BACL/ADMz/wAiAAr/AAABD/8AAQD/EBER/xEREQr/EREQU/8AEQD/AAAi/wABIv8QERH/AAEj/xEREf8QERD/AAEi/wEAAP8RERH/EREQ/xEREv8QERL/EhER/xEREf8BARH/ERER/wAAI/8BEAD/ERESCv8AAAEH/wERAAr/ERERg/8RERD/IgAB/xEREP8RERH/ERIR/xIREv8RERH/EhES/xEQEf8AABD/EBER/xIREv8RERH/AQAi/xEREf8jIiL/AQEi/xEREP8TERL/IiIh/xEQEf8RERD/ERES/xEREf8iISH/IiIi/wAAI/8RAAD/IiIi/wAAEf8BACL/ISIiDv8AAAE3/xEREv8AACL/EhER/xEREf8AEQD/ABEB/wERAf8REBH/AQAj/xESEv8REhD/AREC/wAAIgr/AAEiF/8SEhD/AAAj/xEREv8AACH/AAARCv8AACJH/wIRAf8AACL/AAEi/xIQEP8AACT/ERES/xISEf8RERL/ERER/xEREP8REhD/ERER/xAREv8iIiL/IyIh/xESEv8QEREK/wARAAr/AAAiB/8REREK/wAAIgr/EhERo/8jIiL/EBER/xEREv8REBD/IyIi/wABIv8iIiP/IiIi/wEBNP8iIiL/AAAi/wABRP8jIiL/AAAB/wABAP8AAAH/ABEA/wAiAP8BIgD/EREQ/wIANf8AIgD/EREQ/wAAIf8BMzP/ABEA/wAhAP8AACH/EhEQ/xIREf8AASL/ASIA/wIRAf8AEAD/ACIA/wEAM/8AEQD/AREB/wAAM/8AIgAK/xERETP/ADMz/wEAI/8AACH/ERAP/wAAIf8RERH/IiIh/wAAI/8hIiL/IiIi/xESEf8BADMK/xERESf/EBES/wAAM/8QERL/ACIA/wAAIf8BASP/EhES/xIREf8BADMO/yIiIif/ISIi/yIiIv8hIiL/ATRm/yIiI/8AMzT/AQFF/yIiIv8ANDM=' as: String) asByteArray].! !!TForm class methodsFor: 'instance creation' stamp: 'ar 9/30/2004 16:30'!defaultTForm	| tform |	tform _ CroquetGlobals textureAt: 'default' ifAbsentPut:[		TForm fromForm: TForm defaultForm mipmap: true shrinkFit: true extension: nil.].	^ tform.! !!TForm class methodsFor: 'instance creation' stamp: 'ar 10/4/2004 14:17'!fromFileNamed: fName mipmap: bMM shrinkFit: bSF extension: ext	| file form tform |	file _ CroquetData findTextureFileName: fName.	file ifNil:[ 		Transcript show: 'DEFAULT TEXTURE...Check file name:', fName;cr.		tform _ CroquetGlobals textureAt: 'default' ifAbsentPut:[			form _ TForm defaultForm.			tform _ TForm fromForm: form mipmap: bMM shrinkFit: bSF extension: ext.			].		^ tform.		].	^CroquetGlobals textureAt: file ifAbsentPut:[		form _ Form fromFileNamed: file.		form ifNotNil:[			tform_ TForm new initialize: file form: form mipmap: bMM shrinkFit: bSF extension: ext.			] ifNil:[				Transcript show: 'DEFAULT TEXTURE...Check file names!!';cr.				tform _ CroquetGlobals textureAt: 'default' ifAbsentPut:[					form _ TForm defaultForm.					tform _ TForm fromForm: form mipmap: bMM shrinkFit: bSF extension: ext.				].			].		tform.		].! !!TForm class methodsFor: 'instance creation' stamp: 'das 6/30/2004 11:40'!fromForm: baseForm mipmap: bMM shrinkFit: bSF extension: ext	^ self new initialize: nil form: baseForm mipmap: bMM shrinkFit: bSF extension: ext.	! !!TLoad3DSMax class methodsFor: 'class initialization' stamp: 'ar 7/19/2002 21:28'!findFileName: fName	| path |	(FileStream isAFileNamed: fName) ifTrue:[^ fName].	path := FileDirectory pathFrom: {FileDirectory default pathName. fName}.	(FileStream isAFileNamed: path) ifTrue:[^path].	path := FileDirectory pathFrom: {FileDirectory default pathName. 'Content'. fName}.	(FileStream isAFileNamed: path) ifTrue:[^path].	^ nil.! !!TLoad3DSMax class methodsFor: 'class initialization' stamp: 'yo 9/20/2003 12:18'!initialize	"TLoad3DSMax initialize"	DelimSet1 := CharacterSet newFrom: '*{}'.	DelimSet2 := CharacterSet newFrom: ' {}	',Character cr asString.	DelimSet3 := CharacterSet newFrom: '*}'.	NumberSet _ CharacterSet newFrom: '1234567890-.'.	WhiteSpaceSet _  CharacterSet newFrom: (Array with: Character space with: Character tab).! !!TMaterial class methodsFor: 'class initialization' stamp: 'ar 4/4/2002 23:39'!initialize	"TMaterial initialize"	DefaultSpecular _ #(0.9 0.9 0.9 1.0) asFloatArray.	DefaultDiffuse _ #(0.5 0.5 0.5 1.0) asFloatArray.	DefaultAmbient _ #(0.5 0.5 0.5 1.0) asFloatArray.	DefaultEmission _  #(0.0 0.0 0.0 1.0) asFloatArray.	DefaultShininess _ 0.0.	DefaultWhite _ #(1 1 1) asFloatArray.! !!TMesh class methodsFor: 'instance creation' stamp: 'ar 9/30/2004 12:35'!initializeWithVertices: v alias: a norms: n textureUV: tuv faceGroups: fg material: ml 		^ self new initializeWithVertices: v alias: a norms: n textureUV: tuv faceGroups: fg material: ml.	! !!TMorphMonitor class methodsFor: 'as yet unclassified' stamp: 'ar 9/30/2004 09:41'!createLocalProjectWithExtent: anExtent initialMorph: aMorph	"must be created in home tea party"	| newWorld |	newWorld _ TMorphMonitor new initializeWithWorld: nil extent: anExtent.	aMorph ifNotNil: [		newWorld world color: aMorph color.		newWorld world addMorphCentered: aMorph.	].	^newWorld.! !!TOverlayButtons methodsFor: 'initialize' stamp: 'das 7/31/2004 09:43'!camera: camera	phone target: camera action: #startChat:.	phone target2: camera action2: #endChat:.	snapCamera target: camera action: #snapshot:.	ctrl target: camera action: #openHalo:.! !!TOverlayButtons methodsFor: 'initialize' stamp: 'das 2/17/2004 09:38'!frustumChanged: cam	| bnds |	bnds _ cam bounds.	phone ifNotNil:[ 		phone translationX: 2.5*bnds width/cam zScreen y: 0.0 * bnds height/cam zScreen z: -6.0.].	snapCamera ifNotNil:[		snapCamera translationX: 2.5*bnds width/cam zScreen y: 2.7 * bnds height/cam zScreen z: -6.0.].	! !!TOverlayButtons methodsFor: 'initialize' stamp: 'ar 10/2/2004 08:07'!initialize	| tframe tframe2 receiver path light ctrlFrame |	super initialize.	path _ {FileDirectory default pathName. 'Content'. 'Widgets'}.	space _ TSpace new.	camLoc _ TGroup new.	space addChild: camLoc.	light _ TLight new.	light translationX: -10 y:0.0 z: 0.0.	light rotationAroundZ: 110.	light addRotationAroundY:-10.	camLoc addChild: light.	tframe _ TWidget createNewWithUrl:'http://www.reed.com/TeaLand/widgets/phone.tea'		fileName:(path, { 'phone.ASE'}) scale: 1.0.	tframe2 _ TWidget createNewWithUrl:'http://www.reed.com/TeaLand/widgets/phone.tea'		fileName:(path, {  'phone.ASE'}) scale: 1.0.	receiver _ (tframe2 find:[ :frm | frm objectName = 'receiver' ]) at: 2.	receiver translationX:-0.125 y:0 z: -0.125.	receiver rotationAroundY: 30.	phone _ TButton new initializeSwitchWithFrame: tframe frame2: tframe2.	phone translationX: -2 y: 0 z: -5.	phone persist: true.	phone spin: true.	phone local: true.	camLoc addChild: phone.	phone fullBright: true.	tframe _ TWidget createNewWithUrl:'http://www.reed.com/TeaLand/widgets/cameraSnap.tea'		fileName:(path, {  'camera.ASE'}) scale:0.4.	snapCamera _ TButton new initializeWithFrame: tframe."	cameraButton rotationAroundY:180."	snapCamera persist: true.	snapCamera translationX: -2 y: 0 z: -5.	snapCamera fullBright: true.	snapCamera spin: true.	camLoc addChild: snapCamera.	ctrlFrame _ TTorus new.	ctrlFrame radius: 0.15.	ctrlFrame innerRadius: 0.075.	ctrlFrame segments: 10.	ctrlFrame texture: (TTexture new initializeWithFileName: 'squeaklogo2.bmp').	ctrl _ TButton new initializeWithFrame: ctrlFrame.	ctrl persist: true.	ctrl spin: false.	ctrl fullBright: true.	ctrl rotationAroundX: 140.	ctrl translationX: -2.5 y: 1.8 z: -5.	camLoc addChild: ctrl.	camLoc addChild: TCrosshair new.! !!TOverlayButtons methodsFor: 'render' stamp: 'das 7/31/2004 11:37'!renderOverlay: ogl	| ac currentFrame currentDistance |	ac _ ogl camera.	camLoc localTransform: ac globalTransform." Save the current frame and current distance if we don't find one of the buttons."	currentFrame _ ac pointer selectedFrame.	currentDistance _ ac pointer selectedDistance.	ac pointer selectedDistance: Float infinity.	space renderSpace: ogl."If this is still the same frame as before, restore the distance value."	ac pointer selectedFrame = currentFrame ifTrue:[		ac pointer selectedDistance: currentDistance].! !!TOverlayButtons methodsFor: 'popups' stamp: 'das 8/7/2004 18:02'!killPopup	popup killWindow.	popup _ nil.! !!TOverlayButtons methodsFor: 'popups' stamp: 'DPR 7/14/2004 17:09'!makeBoxButton	| mesh cube pic bttn |	mesh _ TGroup new.	cube _ TCube new.	cube extentX: 1.0 y:0.5 z:0.8.	pic _ TTexture				new initializeWithFileName: 'box.png'				mipmap: true				shrinkFit: false.	cube texture: pic.	mesh addChild: cube.	bttn _ TButton new initializeWithFrame: mesh.	bttn persist: true.	bttn spin: true.	^ bttn.! !!TOverlayButtons methodsFor: 'popups' stamp: 'ar 10/1/2004 12:18'!makeCAD: ptr	| cad |	cad _ TCADObject meta new.	cad meta translationX: 0 y: 0.0 z: -8.0.	ptr avatar meta addChild: cad.	cad meta releaseToRoot.	TEditBox3D meta new initializeWithContents: cad selectedPlane.	popup doKillWindow.	^cad! !!TOverlayButtons methodsFor: 'popups' stamp: 'ar 10/1/2004 19:53'!makeCADButton	| pic mat bttn |	pic _ TTexture new				initializeWithFileName: 'gridIcon.png'				mipmap: true				shrinkFit: false.	mat _ TMaterial new.	mat ambientColor: TButton overColor.	mat diffuseColor: TButton overColor.	pic material: mat.	pic extent: 0.8@0.8.	pic translationX:0 y:0 z:0.0.	bttn _ TButton new initializeWithFrame: pic.	bttn persist: true.	bttn target: self action: #makeCAD:.	bttn spin: true.	^ bttn.! !!TOverlayButtons methodsFor: 'popups' stamp: 'DPR 7/14/2004 21:44'!makeEditBox	self killPopup.! !!TOverlayButtons methodsFor: 'popups' stamp: 'ar 9/30/2004 16:11'!makeEditBoxButton	|  cube pic bttn |	cube _ TCube new.	cube extentX: 1.0 y:1.0 z:0.5.	pic _ TTexture new				initializeWithFileName: 'editBox.png'				mipmap: true				shrinkFit: false.	cube texture: pic."	bttn _ TSpellBox new initializeWithFrame: cube class: TEditBox3D.	bttn target: self action: #makeEditBox.	bttn persist: true.	bttn spin: true."	bttn _ TButton new initializeWithFrame: cube.	bttn persist: true.	bttn spin: true.	^ bttn.! !!TOverlayButtons methodsFor: 'popups' stamp: 'ar 10/4/2004 15:36'!makeExit: ptr! !!TOverlayButtons methodsFor: 'popups' stamp: 'das 7/31/2004 09:43'!makeExitButton	| pic mat bttn |	pic _ TTexture				new initializeWithFileName: 'exit.png'				mipmap: true				shrinkFit: false.	mat _ TMaterial new.	mat ambientColor: TButton overColor.	mat diffuseColor: TButton overColor.	pic scale: 0.6.	pic material: mat.	pic translationX:0 y:0 z:0.1.	bttn _ TButton new initializeWithFrame: pic.	bttn persist: true.	bttn target: self action: #makeExit:.	bttn spin: true.	^ bttn.! !!TOverlayButtons methodsFor: 'popups' stamp: 'ar 10/1/2004 12:19'!makePopup	| tframe |	popup ifNotNil:[		(popup isChild: camLoc) ifTrue:[ self killPopup. popup _ nil. ^self.].		].	tframe _ TButtonHolder new.	tframe addChild: self makeEditBoxButton.	tframe addChild: self makeBoxButton.	tframe addChild: self makeXTerminalButton.	tframe addChild: self makePortalButton.	tframe addChild: self makePortal3DButton.	tframe addChild: self makeWireFilterButton.	tframe addChild: self makeExitButton.	tframe addChild: self makeCADButton.	popup _ TWindow new.	popup translationX: 0 y: 0.0 z: -6.0.	popup contents3D: tframe.	popup radius: 0.1.	popup fullBright: true.	camLoc addChild: popup.	popup grabButton: true.! !!TOverlayButtons methodsFor: 'popups' stamp: 'das 10/3/2004 01:26'!makePortal3D: ptr	| win portal scroller root |	root _ ptr avatar root.	portal_ TPortal3D meta new initializeWithSpace: root.	"set the initial offset value to the location of the activeCamera, but about two/thirds of the way down the window."	portal meta offset: ptr avatar globalPosition negated - (0@((portal extent y/ portal scale)/6.0)@0).	scroller _ TScrollBox3D meta new initializeWithContents: portal.	win _ ptr avatar meta makeWindowInFront.	win meta contents3D: scroller.	self killPopup.! !!TOverlayButtons methodsFor: 'popups' stamp: 'das 7/31/2004 09:43'!makePortal3DButton	| mesh winFrame rect pic mat pyramid bttn |	mesh _ TGroup new.	winFrame _ (TWindowFrame new).	winFrame doInside: true.	mesh addChild: winFrame.	mat _ TMaterial new.	mat ambientColor: TButton overColor.	mat diffuseColor: TButton overColor.	pic _ TTexture				new initializeWithFileName: 'box.png'				mipmap: true				shrinkFit: false.	rect _ TRectangle new.	rect texture: pic.	rect material: mat.	rect extent: winFrame extent.	rect translationX: 0 y: -1.0 z:0.	rect rotationAroundX: -90.	mesh addChild: rect.	rect _ TRectangle new.	rect texture: pic.	rect material: mat.	rect extent: winFrame extent.	mesh addChild: rect.		pyramid _ TCylinder new.	pyramid height: 1.	pyramid baseRadius: 0.5.	pyramid topRadius: 0.0.	pyramid translationX: -1.0 y: -1.0 z: 1.0.	pyramid material: mat.	mesh addChild: pyramid.	bttn _ TButton new initializeWithFrame: mesh.	bttn target: self action: #makePortal3D:.	bttn persist: true.	bttn spin: true.	^ bttn.! !!TOverlayButtons methodsFor: 'popups' stamp: 'ar 9/30/2004 13:47'!makePortal: ptr	| p1 win p2 trans spc |	spc _ ptr avatar root.	trans _ ptr avatar globalTransform translation + (ptr avatar globalTransform orientation localPointToGlobal: (0@0@-8)).	trans _ ptr avatar globalTransform copy translation: trans.	p2 _ TSpaceImposter new initializeWithSpace: spc transform: trans.	p1 _ TPortal new.	win _ ptr avatar makeWindowInFront.	win contents: p1.	p1 linkPortal: p2.	self killPopup.! !!TOverlayButtons methodsFor: 'popups' stamp: 'das 7/31/2004 09:43'!makePortalButton	| mesh winFrame pic mat bttn |	mesh _ TGroup new.	winFrame _ (TWindowFrame new).	mesh addChild: winFrame.	pic _ TTexture				new initializeWithFileName: 'box.png'				mipmap: true				shrinkFit: false.	pic translationX: 0 y: 0 z: 0.25.	mat _ TMaterial new.	mat ambientColor: TButton overColor.	mat diffuseColor: TButton overColor.	pic material: mat.	pic extent: winFrame extent.	winFrame extent: pic extent.	mesh addChild: pic.	bttn _ TButton new initializeWithFrame: mesh.	bttn persist: true.	bttn spin: true.	bttn target: self action: #makePortal:.	^ bttn.! !!TOverlayButtons methodsFor: 'popups' stamp: 'das 10/3/2004 22:50'!makeWireFilter: ptr	| win p |	p _ TWirePortal meta new.	win _ ptr avatar meta makeWindowInFront.	win meta contents: p.	p meta linkPortal: win rectBack.	self killPopup.! !!TOverlayButtons methodsFor: 'popups' stamp: 'das 8/12/2004 14:32'!makeWireFilterButton	| mesh winFrame pic mat bttn |	mesh _ TGroup new.	winFrame _ (TWindowFrame new).	mesh addChild: winFrame.	pic _ (TTexture new initializeWithFileName: 'box.png'				mipmap: true				shrinkFit: false) copy.	pic translationX: 0 y: 0 z: 0.25.	mat _ TMaterial new.	mat ambientColor: TButton overColor.	mat diffuseColor: TButton overColor.	pic material: mat.	pic extent: winFrame extent.	winFrame extent: pic extent.	mesh addChild: pic.	bttn _ TButton new initializeWithFrame: mesh.	bttn persist: true.	bttn spin: true.	bttn target: self action: #makeWireFilter:.	^ bttn.! !!TOverlayButtons methodsFor: 'popups' stamp: 'das 7/31/2004 11:06'!makeX: ptr display: displayName	self makeX: ptr display: displayName window: nil.! !!TOverlayButtons methodsFor: 'popups' stamp: 'ar 9/30/2004 09:46'!makeX: ptr display: displayName window: windowName	| win txwin xlightpipe |	"start a monitor using lightpipe in the home tea party of this machine"	xlightpipe _ TXLightPipe new.	txwin _ TXWindow new initializeOpaque: true extent: 512@512.	xlightpipe monitorXDisplay: displayName window: windowName eventsTo: txwin.	win _ ptr avatar makeWindowInFront.	win contents:txwin.! !!TOverlayButtons methodsFor: 'popups' stamp: 'DPR 7/14/2004 21:43'!makeXDisplay: displayName	self makeXDisplay: displayName window: nil.! !!TOverlayButtons methodsFor: 'popups' stamp: 'ar 9/30/2004 13:48'!makeXDisplay: displayName window: windowName	| win txwin xlightpipe |	"start a monitor using lightpipe in the home tea party of this machine"	xlightpipe _ TXLightPipe new.	txwin _ TXWindow new initializeOpaque: true extent: 512@512.	xlightpipe monitorXDisplay: displayName window: windowName eventsTo: txwin.	win _ TWindow new.	win translation: (self translation - (self lookAt *6) - (0@0.5@0)).	win rotationAroundY: self yaw.	self root addChild: win.	win contents: txwin.! !!TOverlayButtons methodsFor: 'popups' stamp: 'DPR 7/14/2004 21:43'!makeXTerminal	"here we need to make an X terminal that can be opened"	"since this user is the one who must connect it up, we can use a regular Morph	to capture the display id, eventually.  For now, just assume a display ID of :1"	self makeXDisplay: ':1'.	self killPopup.! !!TOverlayButtons methodsFor: 'popups' stamp: 'das 7/31/2004 11:08'!makeXTerminal: ptr	"here we need to make an X terminal that can be opened"	"since this user is the one who must connect it up, we can use a regular Morph	to capture the display id, eventually.  For now, just assume a display ID of :1"	self makeX: ptr display: ':1'.	self killPopup.! !!TOverlayButtons methodsFor: 'popups' stamp: 'das 7/31/2004 09:43'!makeXTerminalButton	| pic bttn mesh cube |	mesh _ TGroup new.	cube _ TCube new.	cube extentX: 1.0 y:1.0 z:0.5.	pic _ TTexture				new initializeWithFileName: 'xwin.png'				mipmap: true				shrinkFit: false.	cube texture: pic.	mesh addChild: cube.	bttn _ TButton new initializeWithFrame: mesh.	bttn persist: true.	bttn target: self action: #makeXTerminal:.	bttn spin: true.	^ bttn.! !!TOverlayRearView methodsFor: 'render' stamp: 'das 7/31/2004 11:37'!renderOverlay: ogl	| ac trans |	ac _ ogl camera.	camera translation: ac globalPosition copy.	camera rotationAroundY:ac yaw+180.	camera initClipPlanes.	camera currentSpace: ac root.	trans _ camera localTransform.	trans a11: trans a11 negated.	trans a21: trans a21 negated.	trans a31: trans a31 negated.	ogl flipFace.		ac avatar root doRender: ogl camera: camera.	ogl flipFace.! !!TOverlayRearView methodsFor: 'initialize' stamp: 'das 2/17/2004 13:40'!frustumChanged: cam	| bnds w h tl |	bnds _ cam bounds.	w _ bnds width/3.0.	h _ bnds height/6.0.	tl _ w@(h/6.0).	bounds _ tl corner: (tl+(w@h)).	camera bounds: bounds.	camera viewAngle: 45. ! !!TOverlayRearView methodsFor: 'initialize' stamp: 'das 8/5/2004 09:16'!initialize: vp	camera _ TCamera new initializeWithViewPort: vp.	camera viewAngle: 45.	camera inPortal: true.! !!TPainter methodsFor: 'actions' stamp: 'ar 6/17/2003 00:38'!acceptSketch: aForm from: sketchEditor	| rot |	ActiveHand lastEvent shiftPressed ifFalse:[		rot := 0.		leftButton label = 'Left' ifTrue:[rot := 0].		leftButton label = 'Forward' ifTrue:[rot := 90].		leftButton label = 'Right' ifTrue:[rot := 180].		leftButton label = 'Back' ifTrue:[rot := 270].		window owner 			makePoohObjectFrom: aForm 			player: repaintedPlayer			rotateBy: rot			replaceOldCostume: replaceOldCostume.	] ifTrue:[		window owner 			popUpBillboard: aForm 			player: repaintedPlayer	].	self close.! !!TPainter methodsFor: 'actions' stamp: 'ar 10/15/2002 23:01'!leftButtonScript	| labels newLabel |	labels := #('Left' 'Forward' 'Right' 'Back').	newLabel :=  labels atWrap: (labels indexOf: leftButton label) + 1.	leftButton label: newLabel.	newLabel :=  labels atWrap: (labels indexOf: newLabel) + 2.	rightButton label: newLabel.	leftButton align:  leftButton fullBounds bottomLeft with: editor bounds bottomLeft.	rightButton align: rightButton fullBounds bottomRight with: editor bounds bottomRight.! !!TPainter methodsFor: 'actions' stamp: 'jh 5/19/2003 23:17'!repaint: aPlayer replaceOldCostume: aBoolean	editor repaint: aPlayer sketch.	repaintedPlayer := aPlayer.	replaceOldCostume := aBoolean.! !!TPainter methodsFor: 'actions' stamp: 'ar 10/15/2002 23:01'!rightButtonScript	| labels newLabel |	labels := #('Left' 'Forward' 'Right' 'Back').	newLabel :=  labels atWrap: (labels indexOf: rightButton label) + 1.	rightButton label: newLabel.	newLabel :=  labels atWrap: (labels indexOf: newLabel) + 2.	leftButton label: newLabel.	leftButton align:  leftButton fullBounds bottomLeft with: editor bounds bottomLeft.	rightButton align: rightButton fullBounds bottomRight with: editor bounds bottomRight.! !!TPainter methodsFor: 'library' stamp: 'ar 6/17/2003 01:05'!initiateSaveImage	WorldState addDeferredUIMessage:[self saveImage]! !!TPainter methodsFor: 'library' stamp: 'ar 6/17/2003 01:01'!libraryDirectory	^FileDirectory default directoryNamed: 'Sketches'! !!TPainter methodsFor: 'library' stamp: 'ar 6/17/2003 01:09'!makeLibrary	| sketchList cc top scroller button |	sketchLib ifNotNil:[		sketchLib delete.		sketchLib := nil.		window extent: window content submorphBounds extent.		^self].	cc := (Color r: 0.7 g: 0.7 b: 0.4).	top := sketchLib := Morph new.	top color: (Color white mixed: 0.4 with: cc).	top borderStyle: (BorderStyle complexAltInset width: 3).	top borderStyle baseColor: cc.	top extent: window content width @ 84.	top layoutPolicy: TableLayout new.	top listDirection: #leftToRight.	top hResizing: #spaceFill; vResizing: #shrinkWrap.	window addMorphBack: top.	scroller := TransformMorph new.	scroller color: Color transparent.	scroller height: 84.	scroller width: (window content innerBounds width truncateTo: 68) + 2.	"scroller hResizing: #spaceFill."	scroller clipSubmorphs: true.	top addMorphBack: scroller.	button := self makeButton:'<'. button layoutInset: 0.	button wrapCentering: #center.	button fillStyle direction: 0@80.	button hResizing: #spaceFill; vResizing: #spaceFill.	self startScript: #scrollBack: withArguments:{scroller} when:{button. #fire}.	top addMorphFront: button.	button := self makeButton:'>'. button layoutInset: 0.	button hResizing: #spaceFill; vResizing: #spaceFill.	button wrapCentering: #center.	button fillStyle direction: 0@80.	self startScript: #scrollForward: withArguments:{scroller} when:{button. #fire}.	top addMorphBack: button.	sketchList := Morph new color: Color transparent.	sketchList layoutPolicy: TableLayout new.	sketchList listDirection: #leftToRight.	sketchList hResizing: #shrinkWrap; vResizing: #shrinkWrap.	sketchList layoutInset: 2@4; cellInset: 2.	scroller addMorphBack: sketchList.	self waitTick.	self startScript: #updateLibrary: withArguments:{sketchList}.! !!TPainter methodsFor: 'library' stamp: 'ar 6/17/2003 00:43'!makeLibraryButtonFrom: file	| form holder cc sketch label colorKey |	cc := (Color r: 0.7 g: 0.7 b: 0.4).	form := Form fromBinaryStream: file.	colorKey := form colorAt: 0@0.	colorKey = Color transparent ifFalse:[		form replaceColor: colorKey withColor: Color transparent.	].	holder := Morph new color: (Color white mixed: 0.7 with: cc).	holder extent: 66@76.	holder borderStyle: (BorderStyle width: 1 color: Color black).	holder clipSubmorphs: true.	holder cornerStyle: #rounded.	sketch := SketchMorph withForm: form.	sketch extent: sketch extent * (64.0 / (form width max: form height)).	sketch position: 64 - sketch extent // 2 + 1.	holder addMorphBack: sketch.	label := StringMorph contents: (file localName allButLast: 4).	label width < sketch width ifTrue:[		label align: label bounds bottomCenter with: holder innerBounds bottomCenter.	] ifFalse:[		label align: label bounds bottomLeft with: holder innerBounds bottomLeft.	].	holder addMorphBack: label.	holder on: #mouseDown send: #mouseDownSketch:from: to: self.	holder on: #mouseUp send: #mouseUpSketch:from: to: self.	^holder! !!TPainter methodsFor: 'library' stamp: 'ar 6/16/2003 22:51'!mouseDownSketch: evt from: holder	| cc |	cc := (Color r: 0.7 g: 0.7 b: 0.4).	holder color: cc.! !!TPainter methodsFor: 'library' stamp: 'ar 6/16/2003 22:52'!mouseUpSketch: evt from: holder	| cc |	cc := (Color r: 0.7 g: 0.7 b: 0.4).	holder color: (Color white mixed: 0.7 with: cc).	editor repaint: holder firstSubmorph form.! !!TPainter methodsFor: 'library' stamp: 'ar 6/17/2003 00:55'!saveImage	"Save this guy"	| type aForm fileName file writer |	aForm := editor paintingForm ifNil:[^self].	aForm colorCount <= 256 ifTrue:[type := '.gif'] ifFalse:[type := '.bmp'].	fileName := 'Sketch'.	[fileName := FillInTheBlankMorph request: 'Please enter the name' initialAnswer: fileName centerAt: window bounds center.	fileName isEmptyOrNil ifTrue:[^self].	[file := self libraryDirectory newFileNamed: fileName, type] 		on: FileExistsException do:[:ex| ex return: nil].	file == nil] whileTrue:[self inform: 'Error: ', fileName,' already exists'].	[aForm := editor paintingForm.	aForm colorAt: 0@0 put: Color transparent. "color key"	type = '.gif' 		ifTrue:[writer := GIFReadWriter]		ifFalse:[writer := BMPReadWriter].	writer putForm: aForm onStream: file.	] ensure: file close.! !!TPainter methodsFor: 'library' stamp: 'ar 6/16/2003 23:24'!scrollBack: aScroller	aScroller hasSubmorphs ifFalse:[^self].	aScroller offset: ((aScroller offset x - 68 max: 0) truncateTo: 68) @ 0.! !!TPainter methodsFor: 'library' stamp: 'ar 6/16/2003 23:21'!scrollForward: aScroller	aScroller hasSubmorphs ifFalse:[^self].	aScroller offset: (aScroller offset x + 68 min: aScroller submorphBounds width) @ 0.! !!TPainter methodsFor: 'library' stamp: 'ar 6/17/2003 01:01'!updateLibrary: sketchList	| dir extensions files file holder |	dir := self libraryDirectory.	extensions := #('.gif' '.bmp' '.jpg' '.png').	files := dir fileNames select:[:fName|				extensions anySatisfy:[:ext| fName endsWith: ext].	].	files := files sort.	files do:[:fName|		file := dir readOnlyFileNamed: fName.		[holder := self makeLibraryButtonFrom: file] ensure:[file close].		sketchList addMorphBack: holder.		self waitTick.	].! !!TPainter methodsFor: 'initialize' stamp: 'ar 10/15/2002 18:51'!makeButton: label	| button |	button := TButtonMorph new.	button label: label.	button fullBounds.	button vResizing: #rigid.	^button! !!TPainter methodsFor: 'initialize' stamp: 'ar 10/15/2002 22:38'!makeButtonRow: ww	| buttonRow cc button |	cc := (Color r: 0.7 g: 0.7 b: 0.4).	buttonRow := Morph new.	buttonRow borderStyle: (BorderStyle complexAltInset width: 2).	buttonRow borderStyle baseColor: cc.	buttonRow color: Color transparent. "(Color white alpha: 0.5)."	buttonRow layoutPolicy: TableLayout new.	buttonRow listDirection: #leftToRight.	buttonRow height: 25.	leftButton := button := self makeButton: 'Left'.	self runScript: #leftButtonScript when:{leftButton. #fire}.	button addMorphFront: (LineMorph arrowFrom: 20@0 to: 0@0 width: 2).	button hResizing: #rigid; width: 100.	buttonRow addMorphBack: button.	button := self makeButton: '... More stuff...'.	button hResizing: #spaceFill.	buttonRow addMorphBack: button.	rightButton := button := self makeButton: 'Right'.	self runScript: #rightButtonScript when:{rightButton. #fire}.	button addMorphBack: (LineMorph arrowFrom: 0@0 to: 20@0 width: 2).	button hResizing: #rigid; width: 100.	buttonRow addMorphBack: button.	button := self makeButton: 'Expert'.	button hResizing: #rigid; width: ww.	buttonRow addMorphBack: button.	^buttonRow! !!TPainter methodsFor: 'initialize' stamp: 'ar 6/17/2003 00:36'!makeControlButton: aLabel after: prevButton	| button label |	button := window frame buildWindowButton: nil.	label := StringMorph contents: aLabel.	label emphasis: 1.	aLabel size > 1 ifTrue:[button width: label width + 10].	button addMorphCentered: label.	window frame addMorph: button after: prevButton.	button color: window frame closeButton color.	^button! !!TPainter methodsFor: 'initialize' stamp: 'ar 6/17/2003 01:05'!makeControlButtons	| button |	window frame collapseButton delete.	"window frame addMorphBack: window frame closeButton."	button := self makeControlButton: '?' after: window frame closeButton.	self startScript: #makeLibrary when:{button. #fire}.	button := self makeControlButton: 'save' after: button.	self startScript: #initiateSaveImage when:{button. #fire}.	"button := self makeControlButton: '<' after: window frame alphaSlider.	self startScript: #gotoPrevCostume when:{button. #fire}.	button := self makeControlButton: '+' after: button.	self startScript: #insertCostume when:{button. #fire}.	button := self makeControlButton: '>' after: button.	self startScript: #gotoNextCostume when:{button. #fire}."! !!TPainter methodsFor: 'initialize' stamp: 'ar 10/15/2002 23:02'!makeInplaceArrows	| cc |	cc := Color black.	leftButton := self makeButton: 'Left'.	leftButton beBordered.	leftButton labelColor: cc; highlightColor: Color black.	leftButton listDirection: #topToBottom; cellPositioning: #topLeft.	self runScript: #leftButtonScript when:{leftButton. #fire}.	leftButton borderWidth: 0; color: Color transparent.	leftButton addMorphFront: (LineMorph arrowFrom: 20@0 to: 0@0 width: 2 color: cc).	rightButton := self makeButton: 'Right'.	rightButton beBordered.	rightButton labelColor: cc; highlightColor: Color black.	rightButton listDirection: #topToBottom; cellPositioning: #topRight.	rightButton borderWidth: 0; color: Color transparent.	self runScript: #rightButtonScript when:{rightButton. #fire}.	rightButton addMorphFront: (LineMorph arrowFrom: 0@0 to: 20@0 width: 2 color: cc).! !!TPainter methodsFor: 'initialize' stamp: 'ar 10/15/2002 23:01'!makePainter	| box cc paintArea content boxHolder buttonRow |	cc := (Color r: 0.7 g: 0.7 b: 0.4).	content := window content.	boxHolder := Morph new color: (Color white mixed: 0.4 with: cc).	box := PaintBoxMorph new.	boxHolder extent: box width @ content innerBounds height.	boxHolder addMorph: box.	box position: boxHolder extent - box fullBounds extent // 2.	boxHolder position: content innerBounds topRight - (box width @ 0).	content addMorph: boxHolder.	paintArea := Morph new.	paintArea position: content position.	paintArea extent: content extent - (box width@0).	paintArea borderStyle: (BorderStyle complexAltInset width: 3).	paintArea borderStyle baseColor: cc.	paintArea color: Color transparent. "(Color white alpha: 0.5)."	content addMorphBack: paintArea.	editor := TSketchEditorMorph new.	editor teapot: self.	editor color: Color transparent.	editor bounds: paintArea innerBounds.	box focusMorph: editor.	paintArea addMorphFront: editor.false ifTrue:[	buttonRow := self makeButtonRow: boxHolder width.	buttonRow width: content innerBounds width.	buttonRow position: paintArea bottomLeft.	content addMorphBack: buttonRow.] ifFalse:[	self makeInplaceArrows.	editor addMorph: leftButton.	editor addMorph: rightButton.	leftButton align:  leftButton fullBounds bottomLeft with: editor bounds bottomLeft.	rightButton align: rightButton fullBounds bottomRight with: editor bounds bottomRight.].! !!TPainter methodsFor: 'initialize' stamp: 'ar 6/16/2003 23:43'!open	window := TWindowMorph new.	window model: self.	window frame expandButton delete.	window frame alphaSlider hResizing: #spaceFill.	window model: self.	window windowColor: self windowColor.	window label: 'Tea Paint'.	window extent: 440@350.	window fullBounds.	self makePainter.	self makeControlButtons.	World addMorphFront: window.	^window! !!TParticle methodsFor: 'accessing' stamp: 'das 3/9/2004 14:03'!addAttractor: attr	attractors add: attr.		attrArray ifNil:[		attrArray _ B3DVector3Array new: size.		lengthArray _ FloatArray new: size.		].! !!TParticle methodsFor: 'accessing' stamp: 'das 2/10/2003 12:26'!billBoard: bool	billBoard _ bool.! !!TParticle methodsFor: 'accessing' stamp: 'das 2/10/2003 23:08'!endColor	^ endColor.! !!TParticle methodsFor: 'accessing' stamp: 'das 2/12/2003 23:41'!endColor: col"This requires either a B3DVector4 or a B3DColor4 "	endColor _ col.	self updateVars.! !!TParticle methodsFor: 'accessing' stamp: 'das 3/9/2004 14:11'!hasAttractor: attr	attractors do:[:a | a = attr ifTrue:[^ true]].		^ false.! !!TParticle methodsFor: 'accessing' stamp: 'das 12/21/2002 22:15'!material	^ material.! !!TParticle methodsFor: 'accessing' stamp: 'das 12/21/2002 22:14'!material: mat	material _ mat.! !!TParticle methodsFor: 'accessing' stamp: 'das 3/9/2004 14:13'!removeAttractor: attr	attractors remove: attr.	! !!TParticle methodsFor: 'accessing' stamp: 'das 12/21/2002 21:56'!setAccelerationRangeMin: min max: max	accelerationRange _ TBox min: min max: max.! !!TParticle methodsFor: 'accessing' stamp: 'das 2/12/2003 23:32'!setLifetimeFrom: from to: to	lifetimeRange _ from to: to.	1 to: size do:[:index | pLifetime at: index put: (lifetimeRange max atRandom).].	self updateVars.! !!TParticle methodsFor: 'accessing' stamp: 'das 2/12/2003 23:32'!setLifetimeRange: range	lifetimeRange _ range.	1 to: size do:[:index | pLifetime at: index put: (lifetimeRange max atRandom).].	self updateVars.! !!TParticle methodsFor: 'accessing' stamp: 'das 12/21/2002 21:56'!setPositionRangeMin: min max: max	positionRange _ TBox min: min max: max.! !!TParticle methodsFor: 'accessing' stamp: 'das 12/21/2002 21:56'!setVelocityRangeMin: min max: max	velocityRange _ TBox min: min max: max.! !!TParticle methodsFor: 'accessing' stamp: 'das 2/10/2003 23:08'!startColor	^ startColor.! !!TParticle methodsFor: 'accessing' stamp: 'das 2/12/2003 23:41'!startColor: col"This requires either a B3DVector4 or a B3DColor4 "	startColor _ col.	self updateVars.! !!TParticle methodsFor: 'accessing' stamp: 'das 5/23/2003 00:37'!updateVars	| |	maxTime _ lifetimeRange max.	endColor ifNotNil:[		pColor ifNil:[ pColor _ B3DColor4Array new: size.					pDeltaColor _ B3DColor4Array new: size.				].		].	material ambientColor: startColor.	material diffuseColor: startColor.! !!TParticle methodsFor: 'initialize' stamp: 'DPR 1/9/2004 14:05'!boundSphere	| vbox bb |	boundsChanged ifTrue:[		boundBox _ positionRange copy.		vbox _ velocityRange copy.		lifetimeRange max timesRepeat:[			bb _ boundBox addBox: (vbox * 0.001).			boundBox _ boundBox unionBox: bb.			vbox _ vbox addBox: (accelerationRange * 0.001).			].		boundSphere _ TBoundSphere localPosition: boundBox center radius: (boundBox diagonal/2.0).		boundSphere frame: self.		boundsChanged _ false.		].	^ boundSphere.! !!TParticle methodsFor: 'initialize' stamp: 'das 2/10/2003 06:49'!boundsChanged	boundsChanged _ true.! !!TParticle methodsFor: 'initialize' stamp: 'ar 9/30/2004 13:10'!initializeWithSize: sz	size _ sz.	pPosition _ B3DVector3Array new: sz.	pLastPosition _ B3DVector3Array new: sz.	pVelocity _ B3DVector3Array new: sz.	pAcceleration _ B3DVector3Array new: sz.	pLifetime _ FloatArray new: sz.	pColor _ nil.	pDeltaColor _ nil.	startColor _ B3DColor4 r:1.0  g:1.0 b:1.0 a:0.9.	endColor _ nil. "default is to not change the color of particles over their lifetimes."	material _ TMaterial new.	material ambientColor: startColor.	material diffuseColor: startColor.	material fullBright: true.	self setPositionRangeMin:(-0.1@-0.1@-0.1) max: (0.1@0.1@0.1).	self setVelocityRangeMin:(-1.2@6.4@-1.2) max:(1.2@9.6@1.2).	self setAccelerationRangeMin:(0@-10@0) max:(0@-8@0).	self setLifetimeRange: (1500 to: 2000).	maxTime _ lifetimeRange max.	deltaTime _ 0.	billBoard _ true.	self updateVars.	self boundsChanged.	globalVelocity _ 0@0@0.	lastStepTime _ 0.0.	lastGlobalPosition _ nil.	attractors _ OrderedCollection new.	^self! !!TParticle methodsFor: 'render' stamp: 'ar 10/3/2004 13:00'!determinePosition	| msecs tt |	msecs _ (tt _ TeaTime now asFloat) - (lastStepTime asFloat).	msecs = 0 ifTrue: [^self].	deltaTime _ msecs.	lastStepTime _ tt.	lastGlobalPosition ifNotNil:[		globalVelocity _ (self globalPosition - lastGlobalPosition)/msecs * 1000.0.		].	lastGlobalPosition _ self globalPosition.! !!TParticle methodsFor: 'render' stamp: 'das 3/12/2004 13:49'!doRender: ogl		| secs transfer go |	material enable: ogl.	ogl glPointSize: 2.0. "	ogl	glBegin: GLPoints."	ogl glPushMatrix.	globalPosition _ self globalPosition.	ogl glMultMatrixf: self globalTransform orthoNormInverse transposed.	pLifetime -= deltaTime.	secs _ deltaTime/1000.0.	secs _ secs min: 0.1.	attractors size > 0 ifTrue:[self doAttractors: secs].	pPosition replaceFrom: 1 to: pPosition size with: pLastPosition startingAt: 1.	pPosition += (pVelocity * secs).	pVelocity += (pAcceleration * secs).	go _ self globalOrientation.	tpr _ go localBoxToGlobal: positionRange.	tvr _ go localBoxToGlobal: velocityRange.	tar _ go localBoxToGlobal: accelerationRange.	ogl glLineWidth: 2.0.	material enable: ogl.	ogl glColor3fv: material ambientColor.	1 to: size do:[:index |		ogl	glBegin: GLLineStrip;			glVertex3fv: (pPosition at: index);			glVertex3fv:(pLastPosition at: index);			glEnd.		(pLifetime at: index) < 0.0 ifTrue:[self regenerate: index.].		].	material disable: ogl.	transfer _ pPosition.	pPosition _ pLastPosition.	pLastPosition _ transfer.	ogl glPopMatrix.! !!TParticle methodsFor: 'render' stamp: 'das 3/12/2004 13:49'!doRenderColor: ogl		| secs transfer go |	material enable: ogl.	ogl glPointSize: 2.0. 	ogl glPushMatrix.	globalPosition _ self globalPosition.	ogl glMultMatrixf: self globalTransform orthoNormInverse transposed.	pLifetime -= deltaTime.	secs _ deltaTime/1000.0.	secs _ secs min: 0.1.	attractors size > 0 ifTrue:[self doAttractors: secs].	pPosition replaceFrom: 1 to: pPosition size with: pLastPosition startingAt: 1.	pPosition += (pVelocity * secs).	pVelocity += (pAcceleration * secs).	go _ self globalOrientation.	tpr _ go localBoxToGlobal: positionRange.	tvr _ go localBoxToGlobal: velocityRange.	tar _ go localBoxToGlobal: accelerationRange.	pColor -= pDeltaColor*deltaTime.	ogl glLineWidth: 2.0.	1 to: size do:[:index |		ogl	glColor3fv: (pColor at: index);			glBegin: GLLineStrip;			glVertex3fv: (pPosition at: index);			glVertex3fv:(pLastPosition at: index);			glEnd.		(pLifetime at: index) < 0.0 ifTrue:[self regenerate: index.].		]."Transcript show: (self globalOrientation orthoNormInverse localPointToGlobal:globalVelocity); cr."	ogl glLineWidth: 2.0.	material disable: ogl.	transfer _ pPosition.	pPosition _ pLastPosition.	pLastPosition _ transfer.	ogl glPopMatrix.! !!TParticle methodsFor: 'render' stamp: 'das 6/5/2003 00:10'!hasAlpha	^ true.! !!TParticle methodsFor: 'render' stamp: 'das 3/9/2004 14:10'!regenerate: index	| lt |	lt _ lifetimeRange atRandom asFloat.	pLifetime at: index put: lt.	pPosition at: index put: (tpr atRandom: 1000)+globalPosition.	pVelocity at: index put: (tvr atRandom: 1000)+globalVelocity.	pAcceleration at: index put: (tar atRandom: 1000).	pColor ifNotNil:[		pColor at: index put: startColor.		pDeltaColor at: index put: (startColor - endColor)/lt.		]."	a _ Float pi*(500-(1000 atRandom))/500.0.	x _ a cos.	z _ a sin.	a _ Float pi*(500-(1000 atRandom))/1000.0.	x2 _ a cos.	gp _ (attractors at: 1) globalPosition.	r_1.0+(attractors at:1)radius.	x_ x*x2*r.	y _ a sin*r.	z_ z*x2*r.	pPosition at: index put:gp+(x@y@z)."	! !!TParticle methodsFor: 'render' stamp: 'DPR 5/12/2004 14:36'!render: space	self hasAlpha ifFalse:[		self determinePosition.		pColor			ifNil:[self doRender: space]			ifNotNil:[self doRenderColor: space]		].	! !!TParticle methodsFor: 'render' stamp: 'DPR 5/12/2004 14:37'!renderAlpha: ogl	self determinePosition.		self doRender: ogl	! !!TParticle methodsFor: 'testing' stamp: 'das 12/21/2002 18:40'!isComponent	^ true.! !!TParticle methodsFor: 'stepping' stamp: 'das 3/9/2004 14:06'!doAttractors: secs	| loc v n |	attractors do:[:attr |  		attr hard ifTrue:[			loc_attr globalPosition.			1 to: size do:[:index | attrArray at: index put: loc.].			attrArray -= pLastPosition.			attrArray squaredLengthInto: lengthArray.			attrArray divideByArray: (lengthArray sqrted).			1 to: size do:[:index | 				(lengthArray at: index)<attr radiusSquared ifTrue:[ 					v _ pVelocity at: index.								n _ attrArray at: index.					pVelocity at:index put: v-(2*n*(v dot: n)).					attrArray at: index put: (0.0@0.0@0.0). "This sets force inside sphere to 0"				].			].			attrArray divideByArray: lengthArray.			attrArray *= (attr mass*secs).			pVelocity += attrArray.		]ifFalse:[			loc_attr globalPosition.			1 to: size do:[:index | attrArray at: index put: loc.].			attrArray -= pLastPosition.			attrArray squaredLengthInto: lengthArray.			attrArray divideByArray: (lengthArray sqrted).			1 to: size do:[:index | 				(lengthArray at: index)<attr radiusSquared ifTrue:[ 				((lengthArray at: index))<(attr radiusSquared) ifTrue:[pLifetime at: index put:-1.]				ifFalse:[					v _ pVelocity at: index.								n _ attrArray at: index.					pLastPosition at:index put: loc-(n*attr radius).					attrArray at: index put: (0.0@0.0@0.0). 				].				].			].			attrArray divideByArray: lengthArray.			attrArray *= (attr mass*secs).			pVelocity += attrArray.		].	].! !!TParticle methodsFor: 'stepping' stamp: 'das 9/18/2003 10:55'!stepAt: currentTime	| msecs |	msecs _ (currentTime - self lastStepTime)asFloat.	deltaTime _ msecs.	lastGlobalPosition ifNotNil:[		globalVelocity _ (self globalPosition - lastGlobalPosition)/msecs * 1000.0.		].	lastGlobalPosition _ self globalPosition.! !!TParticle methodsFor: 'stepping' stamp: 'das 12/21/2002 18:25'!wantsSteps	^ true.! !!TParticle class methodsFor: 'instance creation' stamp: 'ar 9/30/2004 12:39'!initializeWithSize: sz	^ self new initializeWithSize: sz! !!TParticleTxtr methodsFor: 'initialize' stamp: 'das 1/23/2003 12:29'!addTexture: txtr	pTexture ifNil:[ textures _ OrderedCollection new.					pTexture _ OrderedCollection ofSize: size.					1 to: size do:[:index | pTexture at: index put: txtr.].					].	textures add: txtr.! !!TParticleTxtr methodsFor: 'render' stamp: 'das 7/31/2004 11:37'!doRender: ogl	| pt secs mat yaw lt  |	endColor ifNotNil:[^ self doRenderColor: ogl].	pLifetime -= deltaTime.	secs _ deltaTime/1000.0.	secs _ secs min: 0.1.	pPosition += (pVelocity * secs).	pVelocity += (pAcceleration * secs).	mat := B3DMatrix4x4 identity.	material enable: ogl.	billBoard ifTrue:[		yaw _ self globalYaw - ogl camera globalYaw.		mat rotationAroundY: yaw negated.		].	1 to: size do:[:index |		pt _ pTexture at: index.		mat translation: (pPosition at: index).		ogl glPushMatrix; 			glMultMatrixf: mat transposed. 		pt renderPrimitive: ogl.		ogl glPopMatrix.				(pLifetime at: index) < 0.0 ifTrue:[			lt _ lifetimeRange atRandom asFloat.			pLifetime at: index put: lt.			pPosition at: index put: (positionRange atRandom: 1000).			pVelocity at: index put: (velocityRange atRandom: 1000).			pAcceleration at: index put: (accelerationRange atRandom: 1000).			pTexture at: index put: (textures atRandom).			].		].	material disable: ogl.! !!TParticleTxtr methodsFor: 'render' stamp: 'das 7/31/2004 11:37'!doRenderColor: ogl	| pt secs mat yaw lt |	pLifetime -= deltaTime.	secs _ deltaTime/1000.0.	secs _ secs min: 0.1.	pPosition += (pVelocity * secs).	pVelocity += (pAcceleration * secs).	pColor -= (pDeltaColor*deltaTime).	mat := B3DMatrix4x4 identity.	material enable: ogl.	billBoard ifTrue:[		yaw _ self globalYaw - ogl camera globalYaw.		mat rotationAroundY: yaw negated.		].	1 to: size do:[:index |		pt _ pTexture at: index.		mat translation: (pPosition at: index).		ogl glPushMatrix. 		ogl glMultMatrixf: mat transposed. 		ogl glColor4fv: (pColor at: index).		pt renderPrimitive: ogl.		ogl glPopMatrix.				(pLifetime at: index) < 0.0 ifTrue:[			lt _ lifetimeRange atRandom asFloat.			pLifetime at: index put: lt.			pPosition at: index put: (positionRange atRandom: 1000).			pVelocity at: index put: (velocityRange atRandom: 1000).			pAcceleration at: index put: (accelerationRange atRandom: 1000).			pTexture at: index put: (textures atRandom).			pColor at: index put: startColor.			pDeltaColor at: index put: startColor-endColor/lt.			].		].	material disable: ogl.! !!TParticleTxtr methodsFor: 'render' stamp: 'das 3/9/2004 14:15'!hasAlpha	^ true.! !!TPatch methodsFor: 'as yet unclassified'!mirrorX" answer a copy of the reciever where the patch is mirrored around the x-axis "" reverse every four elements three member (vector) elements and negate the first (x) value."	| n result |	n _ self size.	result _ self species new: n.	1 to: n by: 12 do:[ :base | 		0 to: 11 by: 3 do:[ :vindex | result at: base + (9 - vindex) put: (self at: base+vindex) negated.									result at: base + (9 - vindex) + 1 put: (self at: base + vindex + 1).									result at: base + (9 - vindex) + 2 put: (self at: base + vindex + 2)]].	^ result.! !!TPatch methodsFor: 'as yet unclassified'!mirrorY" answer a copy of the reciever where the patch is mirrored around the y-axis "" reverse every four elements three member (vector) elements and negate the second (y) value."	| n result |	n _ self size.	result _ self species new: n.	1 to: n by: 12 do:[ :base | 		0 to: 11 by: 3 do:[ :vindex | result at: base + (9 - vindex) put: (self at: base+vindex).									result at: base + (9 - vindex) + 1 put: (self at: base + vindex + 1) negated.									result at: base + (9 - vindex) + 2 put: (self at: base + vindex + 2)]].	^ result.! !!TPatch methodsFor: 'as yet unclassified'!mirrorZ" answer a copy of the reciever where the patch is mirrored around the z-axis "" reverse every four elements three member (vector) elements and negate the second (z) value."	| n result |	n _ self size.	result _ self species new: n.	1 to: n by: 12 do:[ :base | 		0 to: 11 by: 3 do:[ :vindex | result at: base + (9 - vindex) put: (self at: base+vindex).									result at: base + (9 - vindex) + 1 put: (self at: base + vindex + 1) .									result at: base + (9 - vindex) + 2 put: (self at: base + vindex + 2) negated]].	^ result.! !!TPatch methodsFor: 'as yet unclassified'!patch: patch vertex: vertpatch doWithIndex: 	[:pIndex :index || i j | 		i _  (index-1) * 3.		j _ pIndex * 3. 		1 to: 3 do: [:k |			self at: i+k put: (vert at: j+k).]]! !!TPatch class methodsFor: 'class initialization' stamp: 'bf 9/14/2004 15:04'!initialize	"register myself with DataStream"	DataStream initialize! !!TPatch class methodsFor: 'as yet unclassified'!new	^self ofSize: 4*4*3.! !!TPath methodsFor: 'accessing' stamp: 'das 1/28/2004 01:21'!box	^ box.! !!TPath methodsFor: 'accessing' stamp: 'ar 10/1/2004 12:56'!gridPath	| control sp gp |	box _ TBox new.	gp _ OrderedCollection new.	1 to: splines size - 1 by: 3 do:[:index | 		control _ OrderedCollection new.		0 to: 3 do:[ :cindex | 			control add: (splines at: index+cindex).			box growVertex: (splines at: index + cindex)		].		sp _ Bezier3Segment initializeFrom: control.		0 to: resolution-1 do:[ :res | gp add: (sp valueAt: res * resInverse)].		index = (splines size - 3) ifTrue:[ gp add: (sp valueAt:1.0)].	].	gridPath _ B3DVector3Array new: gp size.	1 to: gp size do:[:index | gridPath at: index put:(gp at: index).].	^ gridPath.! !!TPath methodsFor: 'accessing' stamp: 'das 10/24/2003 13:01'!nextSpline: ns	nextSpline _ ns.	self update.! !!TPath methodsFor: 'accessing' stamp: 'das 10/24/2003 12:10'!scale: scl	splines _ splines * scl.	self update.! !!TPath methodsFor: 'initialize' stamp: 'das 3/10/2004 22:08'!initializeWithSpline: spln	splines _ spln.	self resolution:4.	thisSpline _ self.	self update.! !!TPath methodsFor: 'initialize' stamp: 'das 10/23/2003 19:25'!postCopy	super postCopy.	splines _ splines copy.	previousSpline _ thisSpline.	thisSpline _ self.	previousSpline nextSpline: self.! !!TPath methodsFor: 'initialize' stamp: 'das 10/23/2003 15:16'!resolution: rval	resolution _ rval.	resInverse _ 1.0/resolution.! !!TPath methodsFor: 'initialize' stamp: 'das 10/24/2003 13:51'!update	" recreate the spline surfaces between thisSpline and nextSpline using via1 and via2"	| transform quatIdentity quat translate d m1 m2 gp1 gp2 res2 resInv2 sp gridPath2 |	gp1 _ self gridPath.	1 to: gridPath size do:[:index | gridPath at: index put: (gp1 at: index).].	nextSpline ifNotNil:[		transform _ self relativeTransform: nextSpline.		quatIdentity _ B3DRotation identity.		quat _ transform asQuaternion.		translate _ transform translation.		d _ translate length / 3.0.		m1 _ (quatIdentity slerpTo: quat at: 0.3333) asMatrix4x4.		m1 translation: (0@0@d).		m2 _ (quatIdentity slerpTo: quat at: 0.6666) asMatrix4x4.		m2 translation:translate-(transform column3 * d).		gp2 _ nextSpline gridPath.		via1 _ B3DVector3Array new: gp1 size.		via2 _ B3DVector3Array new: gp1 size.		gridPath2 _ B3DVector3Array new: gp1 size.		m1 quickTransformV3ArrayFrom: gp1 + (gp2-gp1*0.3333) to: via1.		m2 quickTransformV3ArrayFrom: gp1 + (gp2-gp1*0.6666) to: via2.		transform quickTransformV3ArrayFrom: gp2 to: gridPath2.		gp2 _ gridPath2.		res2 _ resolution * 2.		resInv2 _ 1.0/res2.		vertices _ OrderedCollection new.		1 to: gp1 size do:[:index | 			sp _ Bezier3Segment from: (gp1 at: index) via: (via1 at: index) and: (via2 at: index) to: (gp2 at: index).			0 to: res2 do:[ :res | vertices add:(sp valueAt: res* resInv2).].		].	vHeight _ res2+1.	vLength _ gp1 size.	].	! !!TPath methodsFor: 'events' stamp: 'das 10/24/2003 13:15'!parentChanged: frame	self update.	previousSpline ifNotNil:[previousSpline update].! !!TPath methodsFor: 'render' stamp: 'das 7/31/2004 11:38'!render: ogl	(ogl camera globalPosition - self globalPosition) length < 4 ifTrue:[ ogl glLineWidth: 2.0. ]		ifFalse:[ ogl glLineWidth: 1.0].	ogl glDisable: GLLighting.	ogl glDisable: GLCullFace.	ogl glColor3fv: #(0 0 1.0)asFloatArray.	ogl glBegin: GLLineStrip.	gridPath do:[ :gp | ogl glVertex3fv: gp.]. 	ogl glEnd.nextSpline ifNotNil:["	ogl glBegin: GLLineStrip.	via1 do:[ :gp | ogl glVertex3fv: gp.]. 	ogl glEnd.	ogl glBegin: GLLineStrip.	via2 do:[ :gp | ogl glVertex3fv: gp.]. 	ogl glEnd."	0 to: vLength-1 do:[ :vl | 		ogl glBegin: GLLineStrip.		1 to: vHeight do:[ :vh |			ogl glVertex3fv: (vertices at: vl * vHeight + vh).		].		ogl glEnd."		vl ~= (vLength-1) ifTrue:[			ogl glBegin: GLLineStrip.			1 to: vHeight do:[:vh |				ogl glVertex3fv: (vertices at: vl * vHeight + vh).				ogl glVertex3fv: (vertices at: vl+1 * vHeight + vh).			].			ogl glEnd.		]."	].	1 to: vHeight do:[:vh |		ogl glBegin: GLLineStrip.		0 to: vLength-1 do:[:vl |			ogl glVertex3fv: (vertices at: vl * vHeight + vh).		].		ogl glEnd.	].]."	ogl glColor3fv: #(1.0 0 0.0)asFloatArray.	ogl glBegin: GLLineStrip.	spline do:[:control| 		ogl glVertex3fv: (control at: 1).		ogl glVertex3fv: (control at: 2).		ogl glVertex3fv: (control at: 3).		ogl glVertex3fv: (control at: 4).		]. 	ogl glEnd."	ogl glEnable: GLLighting.! !!TPhysicsEngine methodsFor: 'accessing' stamp: 'DPR 1/9/2004 14:05'!addChild: child	super addChild: child.	child objectOwner: self.! !!TPhysicsEngine methodsFor: 'accessing' stamp: 'das 5/7/2002 02:15'!floor: flr	floor _ flr.! !!TPhysicsEngine methodsFor: 'events' stamp: 'das 5/1/2002 17:07'!handlesPointerDown: pointer	^ true.! !!TPhysicsEngine methodsFor: 'events' stamp: 'das 5/11/2002 14:41'!pointerDown: pointer	| rb |	rb _ pointer selectedParent.	rb impulse: (rb globalOrientation localPointToGlobal: pointer selectedPointAt) at: (rb globalTransform localPointToGlobal:pointer selectedPoint).! !!TPhysicsEngine methodsFor: 'initialize' stamp: 'das 2/17/2004 15:52'!initialize	super initialize.	gravity _  (B3DVector3 x: 0.0 y: -9.80665 * 100.0 z: 0.0).	gravity _ B3DVector3 new. " no gravity for now"t1 _ 0.t2 _ 0.	^self.! !!TPhysicsEngine methodsFor: 'testing' stamp: 'das 5/1/2002 11:32'!isComponent	^ true.! !!TPhysicsEngine methodsFor: 'stepping' stamp: 'das 5/14/2002 10:48'!step	| collision c2 tm counter |counter _ 1000.	frameChildren ifNotNil:[		frameChildren do:[ :rb |			rb isRigidBody ifTrue:[				rb computeForce: gravity delta: 0.01.				rb integrate: 0.01.].			].		floor ifNotNil:[			frameChildren do:[ :rb |				rb isRigidBody ifTrue:[					collision _ rb collideFloor: floor.false ifTrue:[					tm _ (Time millisecondsToRun:[counter timesRepeat:[collision _ rb collideFloor: floor]] ).					t1 _ t1 + tm.					Transcript show: tm; show:':'.].					collision ifNotNil:[						"c2 _ rb frame globalTransform orthoNormInverse localPointToGlobal: collision.				collision x:c2 x. collision y: c2 y.  collision z: c2 z."						"Transcript show: 'floor:'; show: collision; cr. "						"floor _ nil."						"rb allStop. 						rb frame translation: 							(rb frame translation + (B3DVector3 x:0 y:4 z:0))."						].		false ifTrue:[								tm _ (Time millisecondsToRun:[counter timesRepeat:[						collision _ rb collidePlane: (B3DVector3 x:0 y:1 z:0) offset: -4.0.].]).					t2 _ t2+tm.					Transcript show:tm; cr.					collision ifNotNil:[						c2 _ rb frame globalTransform localPointToGlobal: collision.						collision x:c2 x. collision y: c2 y.  collision z: c2 z.						"Transcript show:'plane:'; show: collision; cr. "].].].].].].! !!TPhysicsEngine methodsFor: 'stepping' stamp: 'das 5/1/2002 11:33'!wantsSteps	^ true.! !!TPortal3D methodsFor: 'accessing' stamp: 'das 6/19/2003 22:50'!boundSphere	boundsChanged ifTrue:[		self initBounds. 		boundsChanged _ false.		].	^ boundSphere.! !!TPortal3D methodsFor: 'accessing' stamp: 'das 7/22/2003 20:54'!boundingBox	^ clipBox.! !!TPortal3D methodsFor: 'accessing' stamp: 'das 7/24/2003 14:50'!extent	| ext |	ext _ clipBox extent.	^ ext x@ ext y.! !!TPortal3D methodsFor: 'accessing' stamp: 'das 7/24/2003 15:08'!extent: ext	| clip clipN |	clip _ ext x/2.0.	clipN _ clip negated.	self translation:( B3DVector3 x:0 y:0 z:0 ).	clipBox _ TBox min: (B3DVector3 x:clipN y:clipN z:clipN) max: (B3DVector3 x:clip y: clip z: clip).	cube extent: clipBox extent.	! !!TPortal3D methodsFor: 'accessing' stamp: 'das 7/23/2003 12:44'!offset 	^ offset! !!TPortal3D methodsFor: 'accessing' stamp: 'das 7/23/2003 12:44'!offset: os	offset _ os.! !!TPortal3D methodsFor: 'accessing' stamp: 'das 5/31/2003 09:10'!scale	^ scale.! !!TPortal3D methodsFor: 'accessing' stamp: 'das 6/19/2003 09:14'!scale: scl	scale _ scl.	scaleInverse _ 1.0/scale.! !!TPortal3D methodsFor: 'accessing' stamp: 'das 6/18/2003 22:19'!space	^ toSpace.! !!TPortal3D methodsFor: 'accessing' stamp: 'das 6/18/2003 22:19'!space: spc	toSpace _ spc.! !!TPortal3D methodsFor: 'render' stamp: 'das 3/12/2004 13:56'!disableClipPlanes: ogl	ogl glDisable: GLClipPlane1.	ogl glDisable: GLClipPlane2.	ogl glDisable: GLClipPlane3.	ogl glDisable: GLClipPlane4.	ogl glDisable: GLClipPlane5.! !!TPortal3D methodsFor: 'render' stamp: 'das 3/12/2004 13:56'!enableClipPlanes: ogl	"------ enableClipPlanes is used to clip the TSpace inside the 3DPortal to a sub-cube inside the portal. This ensures that objects don't get rendered outside of the portal, which would look bad and be confusing.------"	| equation |"------ We need to do it this way, because Squeak does not directly support doubles and gllClipPlane requires an array of same. ------"	equation _ ExternalData fromHandle: (ExternalAddress allocate: 8*4) type:ExternalType double.		equation getHandle doubleAt: 1 put:  1.0.	equation getHandle doubleAt: 9 put: 0.0.	equation getHandle doubleAt: 17 put: 0.0.	equation getHandle doubleAt: 25 put: clipBox max x.	ogl glClipPlane: GLClipPlane1 with: equation.	ogl glEnable: GLClipPlane1.	equation getHandle doubleAt: 1 put: -1.0.	equation getHandle doubleAt: 9 put: 0.0.	equation getHandle doubleAt: 17 put: 0.0.	equation getHandle doubleAt: 25 put: clipBox min x negated.	ogl glClipPlane: GLClipPlane2 with: equation.	ogl glEnable: GLClipPlane2.	equation getHandle doubleAt: 1 put: 0.0.	equation getHandle doubleAt: 9 put: 0.0.	equation getHandle doubleAt: 17 put: 1.0.	equation getHandle doubleAt: 25 put: clipBox max z.	ogl glClipPlane: GLClipPlane3 with: equation.	ogl glEnable: GLClipPlane3.	equation getHandle doubleAt: 1 put: 0.0.	equation getHandle doubleAt: 9 put: 0.0.	equation getHandle doubleAt: 17 put: -1.0.	equation getHandle doubleAt: 25 put: clipBox min z negated.	ogl glClipPlane: GLClipPlane4 with: equation.	ogl glEnable: GLClipPlane4.	equation getHandle doubleAt: 1 put: 0.0.	equation getHandle doubleAt: 9 put: -1.0.	equation getHandle doubleAt: 17 put: 0.0.	equation getHandle doubleAt: 25 put: clipBox min y negated.	ogl glClipPlane: GLClipPlane5 with: equation.	ogl glEnable: GLClipPlane5.	equation free.! !!TPortal3D methodsFor: 'render' stamp: 'ar 9/30/2004 16:33'!render: ogl	| rval currentCameraTrans currentPointerTrans cpt ip ac ct globalTrans |	rval _ 0."Can't recurse into TPortal3D objects because of the limitation in number of clipping planes. Maybe if I figure out a different way to do it later..."	ogl inPortal3D ifTrue:[^ rval].	ogl inPortal3D: true.	toSpace ifNil:[^ 0 ].	inPortal ifTrue:[^ 0 ].	inPortal _ true.	ogl glPushMatrix. 	toSpace pushAlphaObjects.	self enableClipPlanes: ogl.	ac _ ogl camera.	ip _ ac inPortal.	ac inPortal: true.	cpt _ ac clipPlanesTransform.	ct _ toSpace currentTransform.	toSpace currentTransform: nil.	currentCameraTrans _ ac globalTransform copy.	ac  globalTransform: ((self globalTransform composeWith: (B3DMatrix4x4 identity translation: offset *scale))orthoNormInverse composeWith: ac globalTransform).	ac globalPosition: ac globalPosition/scale.	ac pointer ifNotNil:[		currentPointerTrans _ ac pointer globalTransform copy.		ac pointer globalTransform: (ac globalTransform composeWith: ac pointer localTransform).		ac downPointer setAutomatic: false.	].	ac transformClipPlanes.	CroquetGlobals frameScale: scale.	ogl glScalef: scale with: scale with: scale.	ogl glTranslatef: offset x with: offset y with: offset z.	rval _ toSpace renderFrame: ogl parent: toSpace root: toSpace.	toSpace hasAlphaObjectsToRender ifTrue:[		globalTrans _ B3DMatrix4x4 new.		ogl glGetFloatv: GLModelviewMatrix with: globalTrans.		globalTrans _ globalTrans transposed.		ogl glLoadMatrixf: globalTrans  transposed.		toSpace renderSpaceAlpha: ogl transform: (globalTrans inverseTransformation). 		].	CroquetGlobals frameScale: 1.0.	ac globalTransform: currentCameraTrans.	ac pointer ifNotNil:[		ac pointer globalTransform: currentPointerTrans.		ac downPointer setAutomatic: true.		].	ac clipPlanesTransform: cpt.	ac inPortal: ip.	toSpace currentTransform: ct.	self disableClipPlanes: ogl.	toSpace popAlphaObjects.	inPortal _ false.	ogl inPortal3D: false.	ogl glPopMatrix.	^ rval.! !!TPortal3D methodsFor: 'initialize' stamp: 'DPR 1/9/2004 14:05'!initBounds	boundSphere _ TBoundSphere localPosition: clipBox center radius: (clipBox diagonal)/2.	boundSphere frame: self.! !!TPortal3D methodsFor: 'initialize' stamp: 'das 2/20/2004 10:45'!initialize	| txtr mat |	super initialize.	inPortal _ false.	cube _ TCube new.	self addChild: cube.	txtr _ TTexture				new initializeWithFileName: 'box.png'				mipmap: true				shrinkFit: false.	mat _ TMaterial new.	mat ambientColor: #(0.5 0.7 0.7 0.05) asFloatArray.	mat diffuseColor: #(0.5 0.7 0.7 0.05) asFloatArray.	mat cullFace: false.	mat texture: txtr.	cube material: mat.	scale _ 0.05.	angle _ 0.0.	self objectName:'Portal3D'.	boundsChanged _ true.	offset _ B3DVector3 x: 0.0 y: 0.0 z: 0.0.	self extent:(B3DVector3 x:4 y:4 z:4).	^self! !!TPortal3D methodsFor: 'initialize' stamp: 'ar 9/30/2004 16:13'!initializeWithSpace: spc	toSpace _ spc.	^self! !!TPortal3D methodsFor: 'testing' stamp: 'das 6/1/2003 13:41'!isComponent	^ true.! !!TPortal3D methodsFor: 'stepping' stamp: 'das 6/19/2003 22:44'!stepAt: tm"	angle _ angle + 1.	self rotationAroundY: 0.	clipBox min x: -2.0.	offset x: 0.	scale _ 0.05."! !!TPortal3D methodsFor: 'stepping' stamp: 'DPR 2/18/2004 14:08'!wantsSteps	^ false.! !!TPrimitive methodsFor: 'render' stamp: 'das 3/12/2004 13:57'!boundSphere	| |	boundsChanged ifTrue:[		self initBounds. 		boundsChanged _ false.	"	ts _ TSphere initialize: ogl.		ts translation: boundSphere localPosition.		ts radius: boundSphere radius.		ts material: (TMaterial initialize: ogl).		ts boundSphere frame: nil.		ts segments: 4.		self removeAll.		self addChild: ts."		].	^ boundSphere.! !!TPrimitive methodsFor: 'render' stamp: 'ar 9/7/2002 14:52'!hasAlpha	" Does this object have an alpha channel to render? Return true if it does."	materialAlpha ifNotNil:[ ^ materialAlpha hasAlpha.].	^ false.! !!TPrimitive methodsFor: 'render' stamp: 'ar 9/7/2002 14:49'!opaque	" Does this object have an opaque channel to render? Return true if it does."	material ifNotNil:[ ^ (material hasAlpha) not .].	^ true.! !!TPrimitive methodsFor: 'render' stamp: 'das 7/1/2004 00:16'!render: ogl	self opaque ifTrue:[		material ifNotNil:[material enable: ogl.].		texture ifNotNil:[texture enable: ogl].		self renderPrimitiveCached: ogl.		material ifNotNil:[material disable: ogl.].		texture ifNotNil:[texture disable: ogl.].		].! !!TPrimitive methodsFor: 'render' stamp: 'das 7/1/2004 00:16'!renderAlpha: ogl	materialAlpha ifNotNil:[materialAlpha enable: ogl. ].	textureAlpha ifNotNil:[textureAlpha enable: ogl].	self renderPrimitiveCached: ogl.	materialAlpha ifNotNil:[materialAlpha disable: ogl.].	textureAlpha ifNotNil:[textureAlpha disable: ogl.].! !!TPrimitive methodsFor: 'render' stamp: 'das 3/12/2004 13:57'!renderPrimitive: ogl	super render: ogl! !!TPrimitive methodsFor: 'render' stamp: 'das 8/12/2004 11:45'!renderPrimitiveCached: ogl	ogl forceWire ifTrue:[^self renderPrimitive: ogl].	(cachingEnabled = true) ifFalse:[		(glListID notNil and:[ oglInstance = ogl instance]) ifTrue:[			ogl glDeleteLists: glListID with: 1.			ogl unregisterList: self.			].		glListID _ nil.		cachingEnabled = #reset ifTrue:[ cachingEnabled _ true.].		^self renderPrimitive: ogl.	].	"if there is a cached list and ogl has not changed, call it"	(glListID notNil and: [oglInstance = ogl instance]) ifTrue:[		ogl glCallList: glListID.	] ifFalse:[		glListID _ ogl glGenLists: 1.		ogl registerList: glListID range: 1 owner: self.		oglInstance _ nil.		ogl glNewList: glListID with: GLCompileAndExecute.		self renderPrimitive: ogl.		"See if current display list completed correctly.		If any other has been constructed in the mean time		defer this lists creation until the next rendering loop."		(ogl glGetInteger: GLListIndex) = glListID ifTrue:[oglInstance _ ogl instance].		ogl glEndList.	].! !!TPrimitive methodsFor: 'accessing' stamp: 'das 7/27/2003 12:31'!boundsChanged	boundsChanged _ true.	(cachingEnabled = true)ifTrue: [  self resetCaching. ]. "reset cache"! !!TPrimitive methodsFor: 'accessing' stamp: 'das 2/20/2004 10:45'!colorize: col	| mat |	mat _ TMaterial new.	mat ambientColor: col.	mat diffuseColor: col.	mat textureMode: GLModulate.	self material: mat.! !!TPrimitive methodsFor: 'accessing' stamp: 'das 7/27/2003 12:11'!disableCaching	cachingEnabled _ false.! !!TPrimitive methodsFor: 'accessing' stamp: 'DPR 3/27/2003 15:47'!enableCaching	cachingEnabled _ true.! !!TPrimitive methodsFor: 'accessing'!material	^ material.! !!TPrimitive methodsFor: 'accessing' stamp: 'ar 9/8/2002 18:42'!material: mat	mat ifNil:[^self].	material _ mat.	material ifNotNil:[		material hasAlpha ifTrue:[ self materialAlpha: mat.].].! !!TPrimitive methodsFor: 'accessing'!materialAlpha	^ materialAlpha.! !!TPrimitive methodsFor: 'accessing'!materialAlpha: mat	materialAlpha _ mat.! !!TPrimitive methodsFor: 'accessing' stamp: 'das 7/27/2003 12:17'!resetCaching	cachingEnabled _ #reset.! !!TPrimitive methodsFor: 'accessing'!texture	^ texture.! !!TPrimitive methodsFor: 'accessing'!texture: txtr	texture _ txtr.	textureAlpha _ txtr.! !!TPrimitive methodsFor: 'accessing'!textureAlpha	^ textureAlpha.! !!TPrimitive methodsFor: 'accessing'!textureAlpha: txtr	textureAlpha _ txtr.! !!TPrimitive methodsFor: 'accessing' stamp: 'das 12/20/2002 13:55'!transparency: trans	super transparency: trans.	material ifNotNil:[material transparency: trans].	materialAlpha ifNotNil:[materialAlpha transparency: trans.].! !!TPrimitive methodsFor: 'copying' stamp: 'das 7/10/2002 12:16'!copy	| c |	c _ super copy.	c boundsChanged.	^ c.! !!TPrimitive methodsFor: 'fileIn/Out' stamp: 'das 9/18/2002 02:51'!postImportFrom: importer	super postImportFrom: importer.	glListID ifNotNil:[		glListID := nil.		self enableCaching.	].	self boundsChanged. "so as to invalidate the cache"! !!TPrimitive methodsFor: 'initialize'!initBounds! !!TPrimitive methodsFor: 'initialize' stamp: 'das 2/17/2004 16:00'!initialize	super initialize.	boundsChanged _ true.	self enableCaching.	^self! !!TCube methodsFor: 'accessing' stamp: 'das 6/21/2003 20:31'!boxTop: top bottom: bottom	self extent: (top - bottom).	self location: (bottom + top)/2.0.	self boundsChanged.	changed _ true.! !!TCube methodsFor: 'accessing' stamp: 'das 2/20/2004 10:39'!colorize: col	| mat |	mat _ TMaterial new.	mat ambientColor: col.	mat diffuseColor: col.	mat textureMode: GLModulate.	self material: mat.! !!TCube methodsFor: 'accessing' stamp: 'das 6/21/2003 15:42'!extent	^ extent.! !!TCube methodsFor: 'accessing' stamp: 'das 6/21/2003 15:42'!extent: ext	extent _ ext.	self boundsChanged.	changed _ true.! !!TCube methodsFor: 'accessing' stamp: 'das 6/21/2003 15:44'!extentX: ex	extent x: ex.	self boundsChanged.	changed _ true.! !!TCube methodsFor: 'accessing' stamp: 'das 6/21/2003 15:43'!extentX: x y: y z: z	extent x:x y:y z:z.	self boundsChanged.	changed _ true.! !!TCube methodsFor: 'accessing' stamp: 'das 6/21/2003 15:43'!extentY: ey	extent y: ey.	self boundsChanged.	changed _ true.! !!TCube methodsFor: 'accessing' stamp: 'das 6/21/2003 15:43'!extentZ: ez	extent z: ez.	self boundsChanged.	changed _ true.! !!TCube methodsFor: 'accessing'!location	^ location.! !!TCube methodsFor: 'accessing'!location: loc	location _ loc.	self boundsChanged.! !!TCube methodsFor: 'accessing'!locationX: x y: y z: z	location x: x y: y z: z.	self boundsChanged.! !!TCube methodsFor: 'accessing' stamp: 'das 4/7/2002 14:10'!quadFaces	^ quadFaces.! !!TCube methodsFor: 'accessing' stamp: 'das 6/21/2003 15:58'!scale: scl	extent _ extent * scl.	self translation: scl * self translation.	self boundsChanged.	changed _ true.! !!TCube methodsFor: 'accessing' stamp: 'das 4/7/2002 14:09'!vertices	^ vertices.! !!TCube methodsFor: 'as yet unclassified' stamp: 'das 6/21/2003 15:41'!frameBox	"Answer the local bounding box of this frame"	^TBox origin: extent/-2.0 corner: extent/2.0.! !!TCube methodsFor: 'initialize' stamp: 'DPR 1/9/2004 14:05'!initBounds	boundSphere _ TBoundSphere localPosition: location radius: (extent length)/2.	boundSphere frame: self.! !!TCube methodsFor: 'initialize' stamp: 'das 2/17/2004 15:19'!initialize	super initialize.	extent _ B3DVector3 x: 1.0 y: 1.0 z: 1.0.	location _ B3DVector3 x: 0.0 y:0.0 z:0.0.	self initBounds.	changed _ true.	self update.	^self.! !!TCube methodsFor: 'initialize' stamp: 'das 6/21/2003 15:42'!update	| dx dy dz x y z |	dx _ extent x/2.0.	dy _ extent y/2.0.	dz _ extent z/2.0.	x _ location x.	y _ location y.	z _ location z.	vertices _ B3DVector3Array new: 8.	vertices at: 1 put: (B3DVector3 x: x+(dx negated) y: y+(dy negated) z: z+dz).	vertices at: 2 put: (B3DVector3 x: x+dx y: y+(dy negated) z: z+dz).	vertices at: 3 put: (B3DVector3 x: x+dx y: y+ dy z: z+dz).	vertices at: 4 put: (B3DVector3 x: x+(dx negated) y: y+dy z: z+dz).	dz _ dz negated.	vertices at: 5 put: (B3DVector3 x: x+(dx negated) y: y+(dy negated) z: z+dz).	vertices at: 6 put: (B3DVector3 x: x+dx y: y+(dy negated) z: z+dz).	vertices at: 7 put: (B3DVector3 x: x+dx y: y+ dy z: z+dz).	vertices at: 8 put: (B3DVector3 x: x+(dx negated) y: y+dy z: z+dz).	normals _ B3DVector3Array new: 6.	normals at: 1 put: (B3DVector3 x: 0.0 y: 0.0 z: 1.0).	normals at: 2 put: (B3DVector3 x: 0.0 y: 0.0 z: -1.0).	normals at: 3 put: (B3DVector3 x: 1.0 y: 0.0 z: 0.0).	normals at: 4 put: (B3DVector3 x: -1.0 y: 0.0 z: 0.0).	normals at: 5 put: (B3DVector3 x: 0.0 y: 1.0 z: 0.0).	normals at: 6 put: (B3DVector3 x: 0.0 y: -1.0 z: 0.0).	quadFaces _ #(1 2 3 4    8 7 6 5    2 6 7 3   1 4 8 5   4 3 7 8   1 5 6 2) asIntegerArray.	txtCoords _ B3DVector2Array new: 4.	txtCoords at: 1 put: (B3DVector2 x: 1.0 y: 0.0).	txtCoords at: 2 put: (B3DVector2 x: 0.0 y: 0.0).	txtCoords at: 3 put: (B3DVector2 x: 0.0 y: 1.0).	txtCoords at: 4 put: (B3DVector2 x: 1.0 y: 1.0).	changed _ false. ! !!TCube methodsFor: 'render'!pick: pointer	| faceCount |	faceCount _ 1.	normals do: [ :norm |			(pointer pickQuad: norm q1: (vertices at: (quadFaces at: faceCount))								q2: (vertices at: (quadFaces at: faceCount+1)) 								q3: (vertices at: (quadFaces at: faceCount+2))								q4: (vertices at: (quadFaces at: faceCount+3))) ifTrue:[^ true].		faceCount _ faceCount+4.].	^ false.! !!TCube methodsFor: 'render' stamp: 'das 3/12/2004 13:36'!renderPrimitive: ogl	| faceCount uv tc |	changed		ifTrue: [self update].	uv _ 1@1.	self texture ifNotNil:[uv _ self texture uvScale.].	faceCount _ 1.	ogl glBegin: GLQuads.	normals do:[ :norm |		ogl glNormal3fv: norm.		1 to: 4 do:[ :cnt |			tc _ (txtCoords at: cnt) copy.			tc x: (tc x*uv x) y:(tc y*uv y).			ogl glTexCoord2fv: tc;				glVertex3fv: (vertices at:(quadFaces at: faceCount)).			faceCount _ faceCount+1.].].	ogl glEnd. ! !!TCylinder methodsFor: 'accessing'!baseRadius	^ baseRadius.! !!TCylinder methodsFor: 'accessing'!baseRadius: br	baseRadius _ br.	self boundsChanged.! !!TCylinder methodsFor: 'accessing'!capped	^ capped.! !!TCylinder methodsFor: 'accessing'!capped: bool	capped _ bool.! !!TCylinder methodsFor: 'accessing' stamp: 'das 3/9/2004 14:33'!frameBox	| r |	r _ baseRadius> topRadius ifTrue:[baseRadius] ifFalse:[topRadius].	^ TBox min:(r negated@0.0@r negated) max:(r@height@r).! !!TCylinder methodsFor: 'accessing'!height	^ height.! !!TCylinder methodsFor: 'accessing'!height: ht	height _ ht.	self boundsChanged.! !!TCylinder methodsFor: 'accessing' stamp: 'das 6/21/2003 22:39'!scale: scl	self translation: (self translation * scl).	baseRadius _ baseRadius * scl.	topRadius _ topRadius * scl.	height _ height * scl.! !!TCylinder methodsFor: 'accessing'!slices	^ slices.! !!TCylinder methodsFor: 'accessing'!slices: sl	slices _ sl.! !!TCylinder methodsFor: 'accessing'!stacks	^ stacks.! !!TCylinder methodsFor: 'accessing'!stacks: st		stacks _ st.! !!TCylinder methodsFor: 'accessing'!topRadius	^ topRadius.! !!TCylinder methodsFor: 'accessing'!topRadius: tr	topRadius _ tr.	self boundsChanged.! !!TCylinder methodsFor: 'initialize' stamp: 'DPR 1/9/2004 14:05'!initBounds	| location radius h2 |	h2 _ height/2.0.	h2 _ h2*h2.	baseRadius < topRadius ifTrue:[radius _ topRadius*topRadius.] 							ifFalse:[radius _ baseRadius * baseRadius.].	radius _ (radius+h2) sqrt.	location _ B3DVector3 x:0.0 y: height/2.0 z:0.0.	boundSphere _ TBoundSphere localPosition: location radius: radius.	boundSphere frame: self.! !!TCylinder methodsFor: 'initialize' stamp: 'das 2/17/2004 15:23'!initialize	super initialize.	baseRadius _ 0.5.	topRadius _ 0.0. "default is a cone"	height _ 1.0.	slices _ 8.	stacks _ 4.	capped _ true.	^self.		! !!TCylinder methodsFor: 'render' stamp: 'das 9/6/2002 10:22'!pick: pointer	| r1 r2 |	(pointer pickCylinderFrom: B3DVector3 new radius: baseRadius 		to: (B3DVector3 x:0.0 y: height z: 0.0) radius: topRadius) ifTrue:[^ true] ifFalse:[			capped ifTrue:[				r1 _ pointer pickSphere: 					(B3DVector3 x:0.0 y: 0.0 z: 0.0) radiusSquared: baseRadius*baseRadius.				r2 _ pointer pickSphere: 					(B3DVector3 x:0.0 y: 0.0 z: height) radiusSquared: topRadius*topRadius.				^ r1 | r2.				].			^ false.].! !!TCylinder methodsFor: 'render' stamp: 'das 3/12/2004 13:36'!renderPrimitive: ogl	| ringSin ringCos pi2 ax norm vert hval vval dy m u v du dv rBase hBase rTop hTop |	ringSin _ FloatArray ofSize: slices+1.	ringCos _ FloatArray ofSize: slices+1.	vert _ B3DVector3 new.	norm _ B3DVector3 new.	pi2 _ Float pi *2.0.	1 to: slices do:[ :index | 		ax _ ((index) * pi2)/ slices.		ringSin at:index put: ax sin.		ringCos at:index put: ax cos.].	ringSin at: slices+1 put: (ringSin at: 1).	ringCos at: slices+1 put: (ringCos at: 1).	baseRadius = topRadius ifTrue:[dy _ 0.0. m _ 1.0]		ifFalse:[		dy _ height/(baseRadius-topRadius).		m _ 1/((1.0 + (dy*dy)) sqrt).		dy _ dy*m.].	hval _ height/stacks.	vval _ (baseRadius-topRadius)/stacks.	rBase _ baseRadius.	hBase _ 0.0.	rTop _ baseRadius - vval.	hTop _ hval.	du _ 1.0/slices.	dv _ 1.0/stacks.	v _ 0.0.true ifTrue:[	capped ifTrue:		[ baseRadius = 0.0 ifFalse:[ "make the bottom cap here" 				norm x: 0.0 y: -1.0 z: 0.0.			    	ogl glNormal3fv: norm.				ogl glBegin: GLTriangleFan.				1 to: slices do:[ :ih |					vert x: baseRadius* (ringSin at: 1+slices-ih) y:0.0 z: baseRadius*(ringCos at: 1+slices-ih).					ogl glVertex3fv: vert.].				ogl glEnd.				].		  topRadius = 0.0 ifFalse:[ "make top cap here" 				norm x: 0.0 y: 1.0 z: 0.0.			    	ogl glNormal3fv: norm.				ogl glBegin: GLTriangleFan.				1 to: slices do:[ :ih |					vert x: topRadius* (ringSin at: ih) y:height z: topRadius*(ringCos at: ih).					ogl glVertex3fv: vert.].				ogl glEnd.				].		].].	1 to: stacks do:[ :iv |		ogl glBegin: GLTriangleStrip.		u _ 0.0.		1 to: slices+1 do: [ :ih |			norm x:m * (ringSin at: ih) y: dy z: m*(ringCos at: ih).			ogl glNormal3fv: norm.			ogl glTexCoord2f: u with: 1-(v+dv).			vert x: rTop * (ringSin at: ih) y: hTop z: rTop *(ringCos at: ih).			ogl glVertex3fv: vert.			ogl glNormal3fv: norm.			ogl glTexCoord2f: u with: 1-v.			vert x: rBase * (ringSin at: ih) y: hBase z: rBase *(ringCos at: ih).			ogl glVertex3fv: vert.			u _ u+du.].			ogl glEnd.			v _ v+dv.			rBase _ rTop.			rTop _ rBase - vval.			hBase _ hTop.			hTop _ hBase + hval.].! !!TLinedCylinder methodsFor: 'as yet unclassified' stamp: 'DPR 5/29/2004 10:23'!render: ogl	ogl glDisable: GLCullFace.	super render: ogl.	ogl setCull.! !!TManifold methodsFor: 'accessing' stamp: 'abc 7/27/2002 15:31'!contents	^ contents.! !!TManifold methodsFor: 'accessing' stamp: 'abc 7/27/2002 15:32'!contents: cont	contents _ cont.! !!TManifold methodsFor: 'accessing' stamp: 'abc 7/27/2002 17:00'!extent		^ extent.! !!TManifold methodsFor: 'accessing' stamp: 'abc 7/27/2002 17:37'!extent: ext		extent _ ext.	self boundsChanged.! !!TManifold methodsFor: 'accessing' stamp: 'abc 7/27/2002 15:39'!scale	^ scale.! !!TManifold methodsFor: 'accessing' stamp: 'abc 7/27/2002 15:38'!scale: scl	scale _ scl.! !!TManifold methodsFor: 'accessing' stamp: 'abc 7/27/2002 18:37'!segments	^contents extent.! !!TManifold methodsFor: 'accessing' stamp: 'abc 7/27/2002 15:35'!spanSize	^ spanSize.! !!TManifold methodsFor: 'accessing' stamp: 'abc 7/27/2002 15:35'!spanSize: spnSz	spanSize _ spnSz.! !!TManifold methodsFor: 'accessing' stamp: 'abc 7/27/2002 15:39'!texture	^ texture.! !!TManifold methodsFor: 'accessing' stamp: 'abc 7/27/2002 15:39'!texture: txtr	texture _ txtr.! !!TManifold methodsFor: 'events' stamp: 'abc 7/27/2002 20:58'!handlesKeyboard: ptr	^true.! !!TManifold methodsFor: 'events' stamp: 'abc 7/28/2002 00:45'!keyDown: pointer	| c |	c _ pointer event2D keyCharacter.	c = $r ifTrue:[		contents startOver.		contents startRunning.		^ self.		].	c _ c asInteger - $0 asInteger.	(c >=0 and: [c<=9]) ifTrue:[contents criticalPoint: 60 * (4 raisedTo: c).].! !!TManifold methodsFor: 'events' stamp: 'DPR 7/5/2004 20:00'!keyStroke: pointer	| c |	c _ pointer event2D keyCharacter.	c = $r ifTrue:[		contents startOver.		contents startRunning.		^ self.		].	c _ c asInteger - $0 asInteger.	(c >=0 and: [c<=9]) ifTrue:[contents criticalPoint: 60 * (4 raisedTo: c).].! !!TManifold methodsFor: 'initialize' stamp: 'abc 7/27/2002 17:30'!initBounds	boundSphere _ TBoundSphere localPosition: (B3DVector3 new) radius: extent r / 2.	boundSphere frame: self.! !!TManifold methodsFor: 'initialize' stamp: 'ar 9/30/2004 13:09'!initializeWithContents: cont	contents _ cont.	spanSize _ 2.	scale _ 0.001.	extent _ 40.0@40.0.	self boundsChanged.	^self! !!TManifold methodsFor: 'testing' stamp: 'abc 7/27/2002 15:29'!isComponent	^ true.! !!TManifold methodsFor: 'render' stamp: 'abc 7/27/2002 21:02'!pick: pointer	^ true.! !!TManifold methodsFor: 'render' stamp: 'das 7/1/2004 00:35'!render: ogl	| tx ty tty ttx dx dy ddx ddy top bottom elements segments tl tr bl br |	texture ifNotNil: [ texture update. texture enable: ogl].	elements _ contents array.	segments _ self segments.	tx _ spanSize/(segments x-1.0).	ty _ spanSize/(segments y-1.0).	tty _ 0.	ddx _ extent x/-2.0.	ddy _ extent y/-2.0.	dx _ spanSize * extent x/segments x.	dy _ spanSize * extent y/segments y.	ogl glPushAttrib: (GLEnableBit bitOr: GLEvalBit);		glEnable: GLNormalize.	0 to: segments y - (spanSize+1) by: spanSize do:[ : yIndex |		top _ (yIndex * segments x) + 1.		bottom _ top + (spanSize*segments x).		ttx _ 0.		ddx _ extent x/-2.0.		ogl glBegin: GLTriangleStrip.		tl _ scale * (elements at: top).		bl _ scale * (elements at: bottom).		1 to: segments x-(spanSize+1) by: spanSize do:[: xIndex |			top _ top + spanSize.			bottom _ bottom + spanSize.			tr _ scale* (elements at: top).			br _ scale*(elements at: bottom).			ogl glTexCoord2f: ttx with: tty;				glNormal3f: bl-tl with: 0.5 with: tr-tl;				glVertex3f: ddx with: scale*(elements at: top) with: ddy;				glTexCoord2f: ttx with: tty+ty;				glNormal3f: bl-tl with: 0.5 with: br-bl;				glVertex3f: ddx with: scale*(elements at: bottom) with: ddy+dy.			tl _tr.			bl_br.			ttx _ ttx + tx.			ddx _ ddx + dx.			].		ogl glEnd.		tty _ tty+ty.		ddy _ ddy + dy.		].	ogl glPopAttrib.	texture ifNotNil:[texture disable: ogl.].! !!TManifold methodsFor: 'stepping' stamp: 'ar 9/30/2004 14:53'!step	"this is a quick hack.   The way this works is that it simulates steps at a 25 fps frame rate - 40 milliseconds per step - by calling the step method as many times as would have occurred since lastStepTime if the steps occur on 40 msec boundaries"	| nSteps msecs |	msecs _ TeaTime now asFloat.	nSteps _ (msecs // 40) - ((msecs - self stepTime) // 40).	[nSteps > 0] whileTrue: [ nSteps _ nSteps -1. self step ].! !!TManifold methodsFor: 'stepping' stamp: 'DPR 8/24/2002 16:24'!stepAt: msecs	"this is a quick hack.   The way this works is that it simulates steps at a 25 fps frame rate - 40 milliseconds per step - by calling the step method as many times as would have occurred since lastStepTime if the steps occur on 40 msec boundaries"	| nSteps |	nSteps _ (msecs // 40) - (self lastStepTime // 40).	[nSteps > 0] whileTrue: [ nSteps _ nSteps -1. self step ].! !!TManifold methodsFor: 'stepping' stamp: 'abc 7/27/2002 15:40'!wantsSteps	^ true.! !!TPrimitiveMesh methodsFor: 'render' stamp: 'das 6/21/2003 20:32'!boundsChanged	| box |	super boundsChanged.	myMesh ifNotNil:[		box := myMesh boundingBox.		myCube translation: box origin + box corner * 0.5.		myCube extent: box extent.		myCube update.	].! !!TPrimitiveMesh methodsFor: 'render' stamp: 'ar 9/8/2002 18:08'!pick: pointer	^myCube pick: pointer! !!TPrimitiveMesh methodsFor: 'render' stamp: 'das 3/12/2004 13:59'!renderPrimitive: ogl	myMesh ifNotNil:[myMesh renderOn: ogl].! !!TPrimitiveMesh methodsFor: 'accessing' stamp: 'DPR 1/9/2004 14:05'!initBounds	| box |	myMesh ifNil:[boundSphere _ nil. ^self].	box _ myMesh boundingBox.	boundSphere _ TBoundSphere localPosition:  (box origin + box corner) * 0.5 radius: (box corner - box origin) length * 0.5.	boundSphere frame: self.! !!TPrimitiveMesh methodsFor: 'accessing'!mesh	^myMesh! !!TPrimitiveMesh methodsFor: 'accessing'!mesh: aMesh	myMesh _ aMesh.	self boundsChanged.! !!TPrimitiveMesh methodsFor: 'accessing' stamp: 'ar 9/8/2002 17:31'!myCube	^myCube! !!TPrimitiveMesh methodsFor: 'initialize' stamp: 'das 2/20/2004 10:46'!initialize	super initialize.	myCube := TCube new.	myCube visible: false.	myCube objectOwner: self.	self addChild: myCube.	^self! !!TPrimitiveString methodsFor: 'accessing' stamp: 'ar 6/16/2002 00:06'!font	^font! !!TPrimitiveString methodsFor: 'accessing' stamp: 'ar 6/16/2002 00:06'!font: aFont	font := aFont.	self boundsChanged.! !!TPrimitiveString methodsFor: 'accessing' stamp: 'ar 6/15/2002 23:56'!string	^string! !!TPrimitiveString methodsFor: 'accessing' stamp: 'ar 6/23/2002 19:54'!string: aString	string := aString asString.	self boundsChanged.! !!TPrimitiveString methodsFor: 'accessing' stamp: 'ar 6/23/2002 19:53'!text	^string asText! !!TPrimitiveString methodsFor: 'accessing' stamp: 'ar 6/23/2002 19:54'!text: aText	string := aText asString.	self boundsChanged.! !!TPrimitiveString methodsFor: 'accessing' stamp: 'ar 6/23/2002 19:53'!textAlign	^align! !!TPrimitiveString methodsFor: 'accessing' stamp: 'ar 6/23/2002 19:53'!textAlign: aSymbol	align := aSymbol.	self boundsChanged.! !!TPrimitiveString methodsFor: 'accessing' stamp: 'ar 6/23/2002 19:53'!textColor	^color! !!TPrimitiveString methodsFor: 'accessing' stamp: 'ar 6/23/2002 19:53'!textColor: aColor	color := aColor.	self boundsChanged.! !!TPrimitiveString methodsFor: 'initialize' stamp: 'das 2/17/2004 16:01'!initialize	super initialize.	color := Color black.	^self! !!TPrimitiveString methodsFor: 'render' stamp: 'das 3/12/2004 13:59'!renderPrimitive: ogl	string ifNil:[^self].	ogl drawString: string at: 0@0@0 font: font color: color align: align.! !!TPrimitiveText methodsFor: 'render' stamp: 'ar 6/23/2002 21:09'!boundsChanged	super boundsChanged.	paragraph := NewParagraph new.	paragraph wantsColumnBreaks: false.	paragraph compose: text style: textStyle copy from: 1 in: (textBounds ifNil:[0@0 extent: 99999@99999])! !!TPrimitiveText methodsFor: 'render' stamp: 'das 3/12/2004 13:59'!renderPrimitive: ogl	| box |	box := self textBounds outsetBy: textInset.	ogl 		glDisable: GLLighting;		drawStringRect: box at: 0@0@0 color: Color white align: textAlign;		frameStringRect: box at: 0@0@0 color: Color black align: textAlign;	"	drawString: text asString at: 0@0@0 font: nil color: textColor align: textAlign;"		drawParagraph: paragraph color: textColor at: 0@0@0 align: textAlign;		glEnable: GLLighting.! !!TPrimitiveText methodsFor: 'initialize' stamp: 'das 2/17/2004 16:01'!initialize	super initialize.	textColor := Color black.	textStyle := TextStyle default.	textInset := 3@3.	"textBounds := 0@0 extent: 100@50."	self text: ''.	^self! !!TPrimitiveText methodsFor: 'accessing' stamp: 'ar 6/23/2002 19:22'!text	^text! !!TPrimitiveText methodsFor: 'accessing' stamp: 'ar 6/23/2002 19:27'!text: aText	text := aText asText.	self boundsChanged.! !!TPrimitiveText methodsFor: 'accessing' stamp: 'ar 6/23/2002 19:28'!textAlign	^textAlign! !!TPrimitiveText methodsFor: 'accessing' stamp: 'ar 6/23/2002 19:28'!textAlign: aSymbol	textAlign := aSymbol.	self boundsChanged.! !!TPrimitiveText methodsFor: 'accessing' stamp: 'ar 6/23/2002 21:09'!textBounds	^textBounds ifNil:[paragraph bounds]! !!TPrimitiveText methodsFor: 'accessing' stamp: 'ar 6/23/2002 19:24'!textBounds: aRectangle	textBounds := aRectangle.	self boundsChanged.! !!TPrimitiveText methodsFor: 'accessing' stamp: 'ar 6/23/2002 19:24'!textColor	^textColor! !!TPrimitiveText methodsFor: 'accessing' stamp: 'ar 6/23/2002 19:24'!textColor: aColor	textColor := aColor.	self boundsChanged.! !!TQuad methodsFor: 'initialize' stamp: 'DPR 1/9/2004 14:05'!initBounds	boundSphere _ TBoundSphere mtfBall: vertices.	boundSphere frame: self.	normal _ (((vertices at: 2)-(vertices at: 1)) cross: ((vertices at: 3)- (vertices at: 2))) normalized.! !!TQuad methodsFor: 'initialize' stamp: 'das 2/17/2004 16:02'!initialize	super initialize.	vertices _ B3DVector3Array ofSize: 4.	vertices at: 1 put:(B3DVector3 x: -0.5 y:0.5 z: 0.0).	vertices at: 2 put:(B3DVector3 x: -0.5 y:-0.5 z: 0.0).	vertices at: 3 put:(B3DVector3 x: 0.5 y:-0.5 z:0.0).	vertices at: 4 put:(B3DVector3 x: 0.5 y:0.5 z:0.0).	self initBounds.	^self! !!TQuad methodsFor: 'render' stamp: 'das 7/6/2002 12:16'!pick: pointer	^ pointer pickQuad: normal		q1: (vertices at: 1)		q2: (vertices at: 2)		q3: (vertices at: 3)		q4: (vertices at: 4).! !!TQuad methodsFor: 'render' stamp: 'das 3/12/2004 13:59'!renderPrimitive: ogl	ogl		glBegin: GLQuads;			glNormal3fv: normal;			glTexCoord2f:0.0 with: 0.0;	glVertex3fv: (vertices at: 1);			glTexCoord2f:1.0 with:0.0;	glVertex3fv: (vertices at: 2);			glTexCoord2f:1.0 with:1.0;	glVertex3fv: (vertices at: 3);			glTexCoord2f:0.0 with:1.0;	glVertex3fv: (vertices at: 4);		glEnd.! !!TQuad methodsFor: 'accessing' stamp: 'das 7/6/2002 12:10'!v1: v1 v2: v2 v3: v3 v4: v4	vertices at: 1 put: v1.	vertices at: 2 put: v2.	vertices at: 3 put: v3.	vertices at: 4 put: v4.	normal _ nil.	self boundsChanged.! !!TQuadTree methodsFor: 'accessing' stamp: 'das 6/29/2002 16:10'!add: bdSph" Adds the boundSphere to the octree/quadtree."	self add: bdSph depth: depth.! !!TQuadTree methodsFor: 'accessing' stamp: 'das 2/17/2004 16:08'!add: bndSph depth: dpth" Adds the boundSphere to the octree/quadtree."	| sphLoc |	sphLoc _ bndSph globalPosition.	inBox growVertex: sphLoc.	outBox _ outBox unionBox: 		(inBox unionSphere:bndSph globalPosition radius: bndSph radius).	radius _ outBox diagonal/2.0.	center _ outBox center."------ This is as deep as we go - add the sphere -------"	dpth = 0 ifTrue:[ 		self addSphere: bndSph. 		^ true. 		]."------ Will the sphere fit into this quad? ------"	bndSph radius > (quadSize/2.0) ifTrue:[  		self addSphere: bndSph. 		^ true.			]."------ Then which quad should it go into? ------ "	sphLoc x < center x ifTrue:[		sphLoc z < center z ifTrue:[ 			qtTL ifNil:[ qtTL _TQuadTree new initializeWithCorner: quadCorner size: quadSize depth: depth.].			^ qtTL add: bndSph depth: (dpth-1).			].		qtBL ifNil:[ 			qtBL _ TQuadTree new initializeWithCorner: (quadCorner+(B3DVector3 x:0 y:0 z:quadSize)) size: quadSize depth: depth.].			^ qtBL add: bndSph depth: (dpth-1).		].	sphLoc z < center z ifTrue:[		qtTR ifNil:[ 			qtTR _TQuadTree new initializeWithCorner: (quadCorner+(B3DVector3 x:quadSize y:0 z:0)) size: quadSize depth: depth.].		^ qtTR add: bndSph depth: (dpth-1).		].	qtBR ifNil:[		qtBR _TQuadTree new initializeWithCorner: (quadCorner+(B3DVector3 x:quadSize y:0 z:quadSize)) size: quadSize depth: depth.].	^ qtBR add: bndSph depth: (dpth-1).	! !!TQuadTree methodsFor: 'accessing' stamp: 'das 6/22/2002 01:13'!addSphere: bs	spheres ifNil:[spheres _ OrderedCollection new.].	spheres add: bs.! !!TQuadTree methodsFor: 'accessing' stamp: 'das 6/29/2002 14:30'!boundSphere	^ boundSphere.! !!TQuadTree methodsFor: 'accessing' stamp: 'das 7/11/2003 11:32'!globalTransformUpdate	self reinstall.! !!TQuadTree methodsFor: 'accessing' stamp: 'das 6/29/2002 16:52'!outBox	^ outBox.! !!TQuadTree methodsFor: 'accessing' stamp: 'das 12/3/2002 10:09'!quadOn	^ quadOn.! !!TQuadTree methodsFor: 'accessing' stamp: 'das 12/3/2002 10:09'!quadOn: bool	"Turn the quadtree rendering on/off"	quadOn _ bool.! !!TQuadTree methodsFor: 'events' stamp: 'das 6/27/2002 17:08'!handlesPointerDown: pointer	^ true.! !!TQuadTree methodsFor: 'events' stamp: 'das 6/30/2002 03:07'!pointerDown: pointer	^ true.! !!TQuadTree methodsFor: 'events' stamp: 'das 7/10/2003 21:49'!wantsSteps	^ true.! !!TQuadTree methodsFor: 'render' stamp: 'ar 9/7/2002 14:52'!hasAlpha	^ false.! !!TQuadTree methodsFor: 'render' stamp: 'das 12/30/2002 17:18'!pickFloor: pointer	^ self quadPickFloor: pointer location: pointer framePosition.	! !!TQuadTree methodsFor: 'render' stamp: 'das 1/2/2003 10:33'!quadPickFloor: pointer location: location	| d rval |		(outBox pointOverBox: location) ifFalse:[^ false.].	rval _ false.	spheres ifNotNil:[		spheres do:[ : sp |			sp frame isSolid ifTrue:[				d _ (sp globalPosition - pointer globalPosition) abs.				( d x < sp radius and: [d z < sp radius]) ifTrue:[					(pointer pickDownSphere: sp) ifTrue:[						(pointer pointerPickFloor: sp frame) ifTrue:[rval _ true].						].					].				].			].		].			qtTL ifNotNil:[(qtTL quadPickFloor: pointer location: location) ifTrue:[rval _ true].].	qtBL ifNotNil:[(qtBL quadPickFloor: pointer location: location) ifTrue:[rval _ true].].	qtTR ifNotNil:[(qtTR quadPickFloor: pointer location: location) ifTrue:[rval _ true].].	qtBR ifNotNil:[(qtBR quadPickFloor: pointer location: location) ifTrue:[rval _ true].].	^ rval.! !!TQuadTree methodsFor: 'render' stamp: 'das 3/12/2004 14:00'!renderAlpha: ogl"	| mat |	ogl glDisable: GLCullFace.	mat _ TMaterial initialize: cWorld.	mat ambientColor: #(0.7  0.2 0.1 0.3)asFloatArray.	mat diffuseColor: #(0.7  0.2 0.1 0.3)asFloatArray.	mat enable: ogl.	ogl renderBox: box.	qtTL ifNotNil:[ qtTL renderAlpha: ogl.].	qtTR ifNotNil:[ qtTR renderAlpha: ogl.].	qtBL ifNotNil:[ qtBL renderAlpha: ogl.].	qtBR ifNotNil:[ qtBR renderAlpha: ogl.].	ogl setCull."! !!TQuadTree methodsFor: 'render' stamp: 'DPR 7/6/2004 16:01'!renderFrame: ogl parent: parent root: root	| count |	quadOn ifFalse:[^ super renderFrame: ogl parent: parent root: root.]. "Traditional rendering method - used for testing and picking"	frameChanged ifTrue:[ 		super renderFrame: ogl parent: parent root: root. 		frameChanged ifTrue:[self reinstall.].		frameChanged _ false.		^0.		].	" something of a problem - Quadtrees do not lend themselves to standard picking using this method."	root testRayFramesQuadTree: self. 	ogl glPushMatrix.	count _ self renderTree: ogl root: root.	ogl glPopMatrix."------ This is just test code to see where the quads really are. ------""	self alpha ifTrue: [ 		space addAlpha: 		(TRenderAlpha object: self 			transform: space currentTransform clone			distance: (ogl activeCamera globalPosition - space currentTranslation ) squaredLength			parent: space currentParent).]."	^ count.! !!TQuadTree methodsFor: 'render' stamp: 'DPR 7/6/2004 16:02'!renderFrame: ogl space: space	| count |	quadOn ifFalse:[^ super renderFrame: ogl space: space.]. "Traditional rendering method - used for testing and picking"	frameChanged ifTrue:[ 		super renderFrame: ogl space: space. 		frameChanged ifTrue:[self reinstall.].		frameChanged _ false.		^0.		].	" something of a problem - Quadtrees do not lend themselves to standard picking using this method."	space testRayFramesQuadTree: self.	ogl glPushMatrix.	count _ self renderTree: ogl space: space.	ogl glPopMatrix."------ This is just test code to see where the quads really are. ------""	self alpha ifTrue: [ 		space addAlpha: 		(TRenderAlpha object: self 			transform: space currentTransform clone			distance: (ogl activeCamera globalPosition - space currentTranslation ) squaredLength			parent: space currentParent).]."	^ count.! !!TQuadTree methodsFor: 'render' stamp: 'das 7/31/2004 11:39'!renderTree: ogl root: root	| count globalTrans ac |	ac _ ogl camera.	count _ 0.	"is this inside the viewing pyramid?"	(ac testSphere: center radius: radius) ifTrue:[		spheres ifNotNil:[			spheres do:[:sp | 				(ac testBounds: sp) ifTrue:[					ogl glPushMatrix.					ogl glMultMatrixf: sp frame globalTransform transposed.					sp frame render: ogl. 					count _ count + 1.					sp frame hasAlpha ifTrue: [ 						globalTrans _ B3DMatrix4x4 new.						ogl glGetFloatv: GLModelviewMatrix with: globalTrans.						root addAlphaObject: sp frame 							transform: globalTrans							distance: (ac globalPosition - 								sp globalPosition) squaredLength							parent: sp frame parent.						].					ogl glPopMatrix.					].				].			].		qtTL ifNotNil:[ count _ count + (qtTL renderTree: ogl root: root).].		qtTR ifNotNil:[ count _ count + (qtTR renderTree: ogl root: root).].		qtBL ifNotNil:[ count _ count + (qtBL renderTree: ogl root: root).].		qtBR ifNotNil:[ count _ count + (qtBR renderTree: ogl root: root).].		].	^ count.! !!TQuadTree methodsFor: 'render' stamp: 'das 7/31/2004 11:39'!renderTree: ogl space: space	| count globalTrans ac |	ac _ ogl camera.	count _ 0.	"is this inside the viewing pyramid?"	(ac testSphere: center radius: radius) ifTrue:[		spheres ifNotNil:[			spheres do:[:sp | 				(ac testBounds: sp) ifTrue:[					ogl glPushMatrix.					ogl glMultMatrixf: sp frame globalTransform transposed.					sp frame render: ogl. 					count _ count + 1.					sp frame hasAlpha ifTrue: [ 						globalTrans _ B3DMatrix4x4 new.						ogl glGetFloatv: GLModelviewMatrix with: globalTrans.						space addAlphaObject: sp frame 							transform: globalTrans							distance: (ac globalPosition - 								sp globalPosition) squaredLength							parent: sp frame parent.						].					ogl glPopMatrix.					].				].			].		qtTL ifNotNil:[ count _ count + (qtTL renderTree: ogl space: space).].		qtTR ifNotNil:[ count _ count + (qtTR renderTree: ogl space: space).].		qtBL ifNotNil:[ count _ count + (qtBL renderTree: ogl space: space).].		qtBR ifNotNil:[ count _ count + (qtBR renderTree: ogl space: space).].		].	^ count.! !!TQuadTree methodsFor: 'initialize' stamp: 'das 2/20/2004 11:03'!initializeWithCorner: crnr size: sz depth: dpth	|  cornerMax |	self initialize.	quadSize _ sz/2.0.	quadCorner _ crnr clone.	quadCorner y: Float infinity.	cornerMax _ crnr + sz.	cornerMax y: Float infinity negated.	inBox _ TBox new. "min: corner max:cornerMax."	outBox _ TBox new.	quadCenter _ quadCorner + (quadSize/2.0).	radius _ 0.	self visible: false.	depth _ dpth.	self quadOn: true.	^self! !!TQuadTree methodsFor: 'initialize' stamp: 'das 2/17/2004 16:06'!initializeWithFrame: frame	self initialize.	self addChild: frame.	frame objectOwner: self.	self visible: false.	self quadOn: true.	^self! !!TQuadTree methodsFor: 'initialize' stamp: 'ar 9/30/2004 16:13'!initializeWithSpace: space frame: frame	| ext rad |	space addChild: self.	self addChild: frame.	frame objectOwner: self.	frameChildren do:[ :fc | fc frameChanged.].	rad _ frame octreeRadius.	inBox _ frame octreeBox.	outBox _ TBox new.	quadCenter _ inBox center."----- size is 1/2 of the length of a quadtree side. -----"	ext _ inBox extent.	quadSize _ ext x > ext z ifTrue:[ ext x ] ifFalse:[ext z].	"size _ size > ext y ifTrue:[ size ] ifFalse:[ext y]. don't need for quadtrees"	quadSize _ quadSize/2.0.	quadSize < rad ifTrue:[ quadSize _ rad.].	quadCorner _ quadCenter - quadSize.	radius _ 0.0.	depth _ 5.	self visible: false.	frameChildren do:[ :fc |			fc octreeSieve: self.].	boundSphere _ TBoundSphere localPosition: outBox center radius: outBox diagonal/2.0.	boundSphere frame: self.	self quadOn: true.	^self! !!TQuadTree methodsFor: 'initialize' stamp: 'das 2/20/2004 11:03'!reinstall	| frame rad ext |	frame _ frameChildren at: 1.	rad _ frame octreeRadius.	inBox _ frame octreeBox.	outBox _ TBox new.	quadCenter _ inBox center.	qtTL_ nil.	qtTR_ nil.	qtBL_ nil.	qtBR_ nil.	spheres _ nil."----- size is 1/2 of the length of a quadtree side. -----"	ext _ inBox extent.	quadSize _ ext x > ext z ifTrue:[ ext x ] ifFalse:[ext z].	"size _ size > ext y ifTrue:[ size ] ifFalse:[ext y]. don't need for quadtrees"	quadSize _ quadSize/2.0.	quadSize < rad ifTrue:[ quadSize _ rad.].	quadCorner _ quadCenter - quadSize.	radius _ 0.0.	depth _ 5.	self visible: false.	frameChildren do:[ :fc |			fc octreeSieve: self.].	boundSphere _ TBoundSphere localPosition: outBox center radius: outBox diagonal/2.0.	boundSphere frame: self.! !!TQuadTree methodsFor: 'testing' stamp: 'das 7/11/2003 10:08'!isComponent	^ false.! !!TRay methodsFor: 'accessing' stamp: 'das 12/30/2002 16:27'!automatic	^ automatic.! !!TRay methodsFor: 'accessing' stamp: 'DPR 7/13/2004 09:55'!copiedSelection	| result |	result _ selection copy.	^result.! !!TRay methodsFor: 'accessing'!currentFrame	^ currentFrame.! !!TRay methodsFor: 'accessing'!currentFrame: cf	currentFrame _ cf.	framePointer _ nil. " framePointer is now invalidated, so clear it "	framePosition _ nil. " framePosition is also crap."! !!TRay methodsFor: 'accessing'!doSelect	^ doSelect.! !!TRay methodsFor: 'accessing' stamp: 'das 12/14/2002 12:16'!doSelect: bool"Turns the ray test on/off so that the ray test will be focused on a selected item. This is done when we have a mouseDown and want to track the selected object."	doSelect _ bool.! !!TRay methodsFor: 'accessing' stamp: 'das 11/9/2002 16:23'!downRay	^ downRay.! !!TRay methodsFor: 'accessing' stamp: 'das 11/9/2002 16:23'!downRay: bool	downRay _ bool.! !!TRay methodsFor: 'accessing' stamp: 'das 8/12/2002 16:28'!framePointer	| inv |	framePointer ifNil:[		currentFrame ifNotNil:[			inv _ currentFrame inverseGlobalTransform.			self framePosition: (inv localPointToGlobal: self globalPosition).].			self framePointerTrans: currentFrame globalOrientation.		].	^ framePointer.! !!TRay methodsFor: 'accessing'!framePointer: fp		framePointer _ fp.! !!TRay methodsFor: 'accessing' stamp: 'das 8/12/2002 16:27'!framePointerTrans: trans	" convert from global to local target frame coordinates. "	framePointer _ self globalTransform transposed composeWith: trans.! !!TRay methodsFor: 'accessing'!framePosition	self framePointer.	^ framePosition.! !!TRay methodsFor: 'accessing'!framePosition: fp	framePosition _ fp.! !!TRay methodsFor: 'accessing' stamp: 'ar 6/13/2003 19:56'!lastSelection	^lastSelection! !!TRay methodsFor: 'accessing' stamp: 'das 6/18/2003 13:35'!maxDistance	^ maxDistance.! !!TRay methodsFor: 'accessing' stamp: 'das 6/18/2003 13:35'!maxDistance: md	maxDistance _ md.	maxDistanceSquared _ md*md.! !!TRay methodsFor: 'accessing' stamp: 'das 6/10/2003 11:11'!minDistance	^ minDistance.! !!TRay methodsFor: 'accessing' stamp: 'das 6/10/2003 11:26'!minDistance: md	minDistance _ md.	minDistanceSquared _ md*md.! !!TRay methodsFor: 'accessing' stamp: 'DPR 7/13/2004 10:00'!resetSelected	| lastFrame frame |	frame := self selectedObject.	lastFrame := self lastSelection object.	doSelect ifTrue:[	lastFrame ~= frame ifTrue:[" ------ pointer has left the lastFrame "		lastFrame ifNotNil:[			lastFrame isComponent ifTrue:[				(lastFrame handlesPointerOver: self) ifTrue:[					lastFrame pointerLeave: self.					].				].			]." ------ pointer has entered the frame "		frame ifNotNil:[			frame isComponent ifTrue:[				(frame handlesPointerOver: self) ifTrue: [					frame pointerEnter: self.				].			].		].	] ifFalse: [" ------ pointer is still inside the same object "		frame ifNotNil:[			(frame handlesPointerOver: self) ifTrue: [				frame pointerOver: self.			].		].	].	lastSelection := selection.	selection := TSelection new.	selection distance: Float infinity.	] ifFalse: [	currentFrame _ self selectedFrame.	framePosition _ nil.	framePointer _ nil.].	self maxDistance: Float infinity.! !!TRay methodsFor: 'accessing' stamp: 'DPR 7/13/2004 10:01'!resetTotal	lastSelection := TSelection new.	selection := TSelection new.	selection distance: Float infinity.	self maxDistance: Float infinity.! !!TRay methodsFor: 'accessing' stamp: 'ar 6/13/2003 19:43'!selected	^selection copy! !!TRay methodsFor: 'accessing' stamp: 'DPR 7/13/2004 10:01'!selected: sel	selection := sel.! !!TRay methodsFor: 'accessing' stamp: 'das 6/17/2003 19:38'!selectedDistance		^ selection distance.! !!TRay methodsFor: 'accessing' stamp: 'ar 9/30/2004 16:33'!selectedDistance: dist	selection distance: dist* CroquetGlobals frameScale.! !!TRay methodsFor: 'accessing' stamp: 'das 6/17/2003 19:38'!selectedDistanceSquared		^ selection distanceSquared.! !!TRay methodsFor: 'accessing' stamp: 'ar 9/30/2004 16:33'!selectedDistanceSquared: dist	selection distanceSquared: dist* CroquetGlobals frameScaleSquared.! !!TRay methodsFor: 'accessing' stamp: 'ar 6/13/2003 19:51'!selectedFrame	^ selection frame! !!TRay methodsFor: 'accessing' stamp: 'ar 6/13/2003 19:51'!selectedFrame: sf	selection frame: sf! !!TRay methodsFor: 'accessing' stamp: 'ar 6/13/2003 19:52'!selectedFramePosition	^selection framePosition.! !!TRay methodsFor: 'accessing' stamp: 'ar 6/13/2003 19:52'!selectedFramePosition: sfp	selection framePosition: sfp.! !!TRay methodsFor: 'accessing' stamp: 'ar 6/13/2003 19:53'!selectedIndex	^ selection index! !!TRay methodsFor: 'accessing' stamp: 'ar 6/13/2003 19:53'!selectedIndex: si	selection index: si! !!TRay methodsFor: 'accessing' stamp: 'ar 6/13/2003 19:54'!selectedNormal	^ selection normal! !!TRay methodsFor: 'accessing' stamp: 'ar 6/13/2003 19:53'!selectedNormal: sn	selection normal: sn.! !!TRay methodsFor: 'accessing' stamp: 'ar 6/13/2003 19:42'!selectedObject	^ selection object! !!TRay methodsFor: 'accessing' stamp: 'ar 6/13/2003 19:44'!selectedObject: so	selection object: so.! !!TRay methodsFor: 'accessing' stamp: 'ar 6/13/2003 19:52'!selectedParent	^ selection parent! !!TRay methodsFor: 'accessing' stamp: 'ar 6/13/2003 19:52'!selectedParent: sp	selection parent: sp.! !!TRay methodsFor: 'accessing' stamp: 'das 6/17/2003 19:39'!selectedParentTransform	^ selection parentTransform.! !!TRay methodsFor: 'accessing' stamp: 'das 6/17/2003 19:39'!selectedParentTransform: spt	selection parentTransform: spt.! !!TRay methodsFor: 'accessing' stamp: 'ar 6/13/2003 19:53'!selectedPoint	^ selection point! !!TRay methodsFor: 'accessing' stamp: 'ar 6/13/2003 19:53'!selectedPoint: sp	selection point: sp.! !!TRay methodsFor: 'accessing' stamp: 'ar 6/13/2003 19:52'!selectedPointAt	^ (self selectedPoint - self selectedFramePosition)normalized.! !!TRay methodsFor: 'accessing' stamp: 'ar 6/13/2003 22:39'!selectedTriangle	^selection triangle! !!TRay methodsFor: 'accessing' stamp: 'ar 6/13/2003 22:40'!selectedTriangle: aTriangle	selection triangle: aTriangle! !!TRay methodsFor: 'accessing' stamp: 'DPR 7/13/2004 10:01'!selection	^selection! !!TRay methodsFor: 'accessing' stamp: 'das 9/25/2004 13:57'!selection: newSelection	lastSelection _ selection.	selection_ newSelection.! !!TRay methodsFor: 'accessing' stamp: 'das 12/30/2002 16:28'!setAutomatic: bool	automatic _ bool.! !!TRay methodsFor: 'accessing'!sphereDistSquared	^ sphereDistSquared.! !!TRay methodsFor: 'accessing'!sphereDistSquared: sds	sphereDistSquared _ sds.! !!TRay methodsFor: 'accessing' stamp: 'das 8/12/2002 21:38'!testDistance	^ testDistance.! !!TRay methodsFor: 'accessing' stamp: 'das 8/12/2002 21:39'!testDistance: bool	testDistance _ bool.! !!TRay methodsFor: 'accessing' stamp: 'ar 9/30/2004 16:33'!testSelectedDistance: dist 	| scaledDistance |	self testDistance ifFalse:[ ^ true. "don't test, just say yes."].	dist < 0  ifTrue:[^ false.].	scaledDistance _ dist * CroquetGlobals frameScale.	selection distance < scaledDistance ifTrue:[^ false ]. "we already have a closer point."	minDistance > scaledDistance ifTrue:[^ false.]. "this is too close"	maxDistance < scaledDistance ifTrue:[^ false.]. "this is too far"	^ true.! !!TRay methodsFor: 'accessing' stamp: 'ar 9/30/2004 16:33'!testSelectedDistanceSquared: dist	| scaledDistance |	self testDistance ifFalse:[ ^ true. "don't test, just say yes."].	scaledDistance _ CroquetGlobals frameScaleSquared * dist.	selection distanceSquared < scaledDistance ifTrue:[^ false ]. "we already have a closer point."	minDistanceSquared > scaledDistance ifTrue:[^ false]. "this choice is too close "	maxDistanceSquared < scaledDistance ifTrue:[^ false]. "this choice is too far "	^ true.! !!TRay methodsFor: 'picking' stamp: 'das 8/12/2002 21:40'!frame: frame pickCylinderFrom: pnt1 radius: rad1 to: pnt2 radius: rad2	| rval |	self testDistance: false.	self currentFrame: frame. 	rval _ self pickCylinderFrom: pnt1 radius: rad1 to: pnt2 radius: rad2.	self testDistance: true.	^ rval.! !!TRay methodsFor: 'picking' stamp: 'das 8/12/2002 21:41'!frame: frame pickCylinderFrom: pnt1 to: pnt2 radius: rad	| rval |	self testDistance: false.	self currentFrame: frame. 	rval _ self pickCylinderFrom: pnt1 to: pnt2 radius: rad.	self testDistance: true.	^ rval.! !!TRay methodsFor: 'picking' stamp: 'das 8/12/2002 21:41'!frame: frame pickPlane: position normal: normal	| rval |	self testDistance: false.	self currentFrame: frame. 	rval _ self pickPlane: position normal: normal.	self testDistance: true.	^ rval.! !!TRay methodsFor: 'picking' stamp: 'das 8/12/2002 21:40'!frame: frame pickQuad: norm q1: p1 q2: p2 q3: p3 q4: p4	| rval |	self testDistance: false.	self currentFrame: frame. 	rval _ self pickQuad: norm q1: p1 q2: p2 q3: p3 q4: p4.	self testDistance: true.	^ rval.! !!TRay methodsFor: 'picking' stamp: 'das 8/12/2002 21:42'!frame: frame pickQuad: p1 q2: p2 q3: p3 q4: p4	| rval |	self testDistance: false.	self currentFrame: frame. 	rval _ self pickQuad: p1 q2: p2 q3: p3 q4: p4.	self testDistance: true.	^ rval.! !!TRay methodsFor: 'picking' stamp: 'das 8/12/2002 21:42'!frame: frame pickSphere: loc radiusSquared: rs	| rval |		self testDistance: false.	self currentFrame: frame.	rval _ self pickSphere: loc radiusSquared: rs.	self testDistance: true.	^ rval! !!TRay methodsFor: 'picking' stamp: 'das 8/12/2002 21:42'!frame: frame pickTriangle: p1 tri: p2 tri: p3	| rval |	self testDistance: false.	self currentFrame: frame. 	rval _ self pickTriangle: p1 tri: p2 tri: p3.	self testDistance: true.	^ rval.! !!TRay methodsFor: 'picking' stamp: 'das 8/12/2002 21:43'!frame: frame pickTriangle: norm tri: p1 tri: p2 tri: p3	| rval |	self testDistance: false.	self currentFrame: frame. 	rval _ self pickTriangle: norm tri: p1 tri: p2 tri: p3.	self testDistance: true.	^ rval.! !!TRay methodsFor: 'picking' stamp: 'das 7/11/2003 12:30'!globalTransformUpdate		|trans|	downRay ifTrue:[		trans _ globalPosition.		globalTransform _ TDownRay clone.		globalTransform translation: trans.	].! !!TRay methodsFor: 'picking' stamp: 'das 1/2/2003 10:33'!pick: bnds	| position |	bnds ifNil:[^ false ].	bnds frame ifNotNil:[		bnds frame isSolid ifTrue:[			self downRay ifFalse:[ self pointerPick: bnds.] 			ifTrue:[				position _ (bnds globalPosition - self globalPosition).				position *= position.				(position x + position z < bnds radiusSquared) ifTrue:[					(self pickDownSphere: bnds) ifTrue:[						(self pointerPickFloor: bnds frame) ifTrue:[ ^ true. ].					].				].			].		].	].	^ false.! !!TRay methodsFor: 'picking' stamp: 'das 6/18/2003 21:18'!pickBoundSphere: bnds 	| position dp d gpAt |	gpAt _ self globalTransform column3.	position _ bnds globalPosition - self globalPosition.	dp _ position - ((gpAt dot: position)*gpAt).	d _ dp dot: dp.	d < bnds radiusSquared ifTrue:[		self sphereDistSquared: d.		^ true.].	^ false.! !!TRay methodsFor: 'picking' stamp: 'das 12/2/2002 00:21'!pickCylinderFrom: pnt1 radius: rad1 to: pnt2 radius: rad2	| p1 p2 r1 r2 vn lv lx dx pv n nvn pd v ht cosCone cosPlane ip d1 d2 dd |	rad1 = rad2 ifTrue: [ 	"right cylinder"	^ self pickCylinderFrom: pnt1 to: pnt2 radius: rad1.	]	ifFalse: [ "cone"" Figure out where the vertex is.	r1,r2 - top and bottom radii. r2 > r1	p1,p2 - top and bottom center points.	v - vertex of the cone	ht - true height of the cone	vn - vertex normal (up-down normal)	n - normal plane vector	nvn - vertex normal dot with plane normal	ip - actual intersection point"	rad2 < rad1 ifTrue:[		r1 _ rad2.		r2 _ rad1.		p1 _ pnt2 - self framePosition.			p2 _ pnt1 - self framePosition.]	ifFalse:[		r1 _ rad1.		r2 _ rad2.		p1 _ pnt1 - self framePosition.		p2 _ pnt2 - self framePosition.].	rad1 = 0 ifTrue:[ 		v _ p1.		ht _ (p1- p2) length.		vn _ (p2 - p1) normalized.		] 	ifFalse:[		vn _ (p2 - p1) normalized.		pd _ (p1-p2)length.		ht _ (r2*pd)/(r2-r1).		v _ p2 - (vn * ht).		]." Calculate the plane that cuts the cone. This is from Graphics Gems V pg 227."	n _ self framePointer row3 cross: v.	lv _ n length.	lv = 0 ifTrue:[^ false.] ifFalse:[ n _ n/lv.]." We hit the vertex point."	(n dot: n)=0 ifTrue:[		ip _ v.]	ifFalse:[" Test the plane to see if it intersects the cone."		cosCone _ ht/(((ht*ht) + (r2*r2))sqrt).		nvn _ n dot: vn.		cosPlane _ (1- (nvn * nvn)) sqrt.		cosCone > cosPlane ifTrue:[ ^ false. "no intersection."].		lx _ n dot: (p2-v). " distance of p2 from plane "		dx _ (lx*lx)/ht. " difference in height of closest point to p2"		lv _ (p2-v) - (n * lx). " actual location of closest point of p2 to plane "		pv _ v+ (lv * (ht/(ht-dx))). " location of this point on the plane defined by p2. "		dx_((r2*r2)-((pv-p2)squaredLength))sqrt. " distance from pv to r2 on circle at p2"		pv _ pv + (dx * ((n cross: vn) normalized)).		pv_(pv-v)normalized. "vector from v ON THE CYLINDER"		d1 _ self framePointer row3.		d2 _ pv.		dd _ d1 cross: d2.		dx _ dd dot: dd.		dx = 0 ifTrue:[^false].		dx _ ( (v cross: d2) dot: dd )/dx.		(self testSelectedDistance: dx abs) ifFalse:[^ false].		ip _ self framePosition + (d1*dx).		]." Now that we (finally) have ip - the intersection of the pointer with the -infinite- cylinder, we need to test to see if it is between the top and bottom planes,"	((ip - pnt1) dot: vn)*((ip-pnt2) dot: vn) > 0 ifTrue:[ 		"the point is outside the bounds"		^ false.].	self selectedPoint: ip.	self selectedDistance: dx abs.	^ true.	].			! !!TRay methodsFor: 'picking' stamp: 'ar 6/13/2003 20:16'!pickCylinderFrom: pnt1 to: pnt2 radius: rad	| p1 p2 pd d ps s pn pa dd ip |" 	p1, p2 axis points of the cylinder relative to the framePosition.	pd - the cutting plane. The ray is on this plane, which is parallel to the cylinder axis.	d - distance of plane from cylinder axis.	s - distance from d point (p1 + d*p) to cylinder surface.	ps - vector on plane, perpendicular to axis.	pn - normal vector.	ip - selected point"	p1 _ pnt1 - self framePosition.	p2 _ pnt2 - self framePosition." Calculate the cutting plane between the ray and parallel to the axis of the cylinder. "	pd _ (self framePointer row3 cross: (p1-p2))." Test if we ray is parallel to axis."	(pd dot: pd)=0 ifTrue:[ ^ false.].	pd normalize." Test to see if the plane (and hence the ray) distance is less than the rad distance to the center of the cylinder."	d _ pd dot: p1.	d abs >rad ifTrue:[ ^ false.]. " Calculate the perpendicular normal to the axis on the plane."	s _ ((rad*rad)-(d*d))sqrt.	ps _ ((p1-p2) cross: pd) normalized." Calculate the normal on the cylinder at the intersection point."	pn _ ((s*ps)-(d*pd)).	" Now we just calculate the intersections between two lines."	p1 _ p1 + pn.	p2 _ p2 + pn.	pn normalize.	pa _ (p2-p1) normalized." We know that the two lines can't be parallel because we tested earlier."	dd _ (self framePointer row3) cross: pa.		s_ (((p1 cross: pa) dot: dd)/(dd dot: dd)).	ip _ framePointer row3 * s." Test if we are between the two ends of the cylinder."	((ip-p1) dot: pa)*((ip-p2) dot: pa)>0 ifTrue:[		"The point is outside the bounds"		^ false.].	s _ s abs.	(self testSelectedDistance: s) ifFalse:[^false].	self selectedDistance: s.	self selectedPoint: (ip + self framePosition).	self selectedNormal: pn.	^ true.		! !!TRay methodsFor: 'picking' stamp: 'das 8/11/2002 17:00'!pickDownSphere: bnds 	| position |	position _ bnds globalPosition - self globalPosition.	^ (((position x *position x) + (position z*position z)) < bnds radiusSquared).! !!TRay methodsFor: 'picking' stamp: 'das 8/26/2002 14:53'!pickFrame: framePtr tri: p1 tri: p2 tri: p3" This method works by using the orthogonal picking matrix as orthogonal planes going through the origin at 'origin'. The points of the triangle are tested to the two planes orthoganal to the direction of picking. If they are on either side of both planes, then there is a very high probability that our picking ray interesects the triangle, and we do the actual calculation of the intersection point. Note the comments below. I use a vertical bar to indicate which side of the plane a point is on.  ***** p1 p2 | ***** means that p1 and p2 are on the same side, ***** p1 | p2 ***** indicates that they are on opposite sides. p1 is always on the left side, because it is the first one I test. This really just means - same side as p1 - no meaning other than that. This can be optimized for tri-strips, tri-fans, and even full face based meshes. When I have the time... "	| d1 d2 d3 pp1 pp2 dd1 dd2 xPlane yPlane  |			xPlane _ framePtr row1.	d1 _ xPlane dot: p1.	d2 _ xPlane dot: p2.	d3 _ xPlane dot: p3.	dd1 _ d1*d2.	dd2 _ d1*d3." test if all points are on the same side of the x plane."	dd1 < 0 ifFalse:[ 				"***** p1 p2 |  *****"		dd2 < 0  ifFalse:[  ^ false		"***** p1 p2 p3 | *****" ] 				ifTrue:[ 			"***** p1 p2 | p3 *****"						pp1 _ p1 + ((p3-p1) * d1/(d1-d3)).						pp2 _ p2 + ((p3-p2) * d2/(d2-d3)).]]		ifTrue:[ 				"***** p1 | p2 *****"			dd2 < 0  ifTrue:[ 		"***** p1 | p2 p3 *****" 						pp1 _ p1 + ((p2-p1) * d1/(d1-d2)).						pp2 _ p1 + ((p3-p1) * d1/(d1-d3)).] 					ifFalse:[ 		"***** p1 p3 | p2 *****"						pp1 _ p1 + ((p2-p1) * d1/(d1-d2)).						pp2 _ p3 + ((p2-p3) * d3/(d3-d2)).].]." At this point, the triangle is intersected by the x plane and we know where. If both points are on the same side of the y plane, we are done. "	yPlane _ framePtr row2.	d1 _ yPlane dot: pp1.	d2 _ yPlane dot: pp2." test if both points are on the same side of the y plane."	d1 * d2 < 0 ifFalse:[ 	 ^ false ].	pp1 _ pp1 + ((pp2-pp1) *  d1/ (d1-d2)).	d1 _ pp1 squaredLength.	(self testSelectedDistanceSquared: d1) ifTrue:		[			self selectedDistanceSquared: d1.			self selectedPoint: pp1.			^ true.		].	^ false.				! !!TRay methodsFor: 'picking' stamp: 'das 6/24/2002 18:26'!pickLocalBoundSphere: bnds 	| lpAt position dp dd |	lpAt _ self framePointer row3.	position _ bnds localPosition - self framePosition." project center of sphere onto the ray"	dp _ position - (lpAt * (lpAt dot: position)).	dd _ dp dot: dp." distance of ray to center - if greater than radius, return false, otherwise, the ray intersects."	^ (dd < bnds radiusSquared)! !!TRay methodsFor: 'picking'!pickLocalNorm: norm 	^ (self framePointer row3 dot: norm) < 0.! !!TRay methodsFor: 'picking' stamp: 'ar 6/13/2003 20:16'!pickPlane: position normal: normal	| div sp d |	div _ normal dot: self framePointer row3. 	div = 0 ifTrue:[ ^ false ].	d _ ((position-self framePosition) dot: normal)/div.	sp_ self framePosition +  (self framePointer row3 * d).		(self testSelectedDistance: d) ifFalse:[^false].	self selectedDistance: d.	self selectedPoint: sp.	self selectedNormal: normal.	^ true.! !!TRay methodsFor: 'picking' stamp: 'das 6/30/2002 14:29'!pickQuad: norm q1: p1 q2: p2 q3: p3 q4: p4	| pointAt po1 po2 po3 po4 d1 d2 d3 d4 |	pointAt _ self framePointer row3.	norm ifNotNil:[		((pointAt dot: norm) < 0) ifTrue:[^ false ].].	po1 _ self framePosition - p1.	po2 _ self framePosition - p2.	po3 _ self framePosition - p3.	po4 _ self framePosition - p4.	d1 _ pointAt dot: po1.	d2 _ pointAt dot: po2.	d3 _ pointAt dot: po3.	d4 _ pointAt dot: po4." Are any of the points actually in front of the pointer?"	d1 < 0 ifTrue:[		d2 < 0 ifTrue:[			d3 < 0 ifTrue:[				d4 < 0 ifTrue:[^ false.]]]]."	(norm dot: po1) > 0 ifTrue:[ ^ false.]."" If all of the points are further than the current selected distance, then we are done."	(self testSelectedDistance: d1) ifFalse:[	(self testSelectedDistance: d2) ifFalse:[	(self testSelectedDistance: d3) ifFalse:[	(self testSelectedDistance: d4) ifFalse:[^ false]]]]." At some point, I need to write a special pickFrame for quads, because I calculate one of the vertices twice this way. In Squeak, every cycle counts!!."  	(self pickFrame: self framePointer tri: po1 tri: po2 tri: po3) ifFalse:[ 		(self pickFrame: self framePointer tri: po3 tri: po4 tri: po1) ifFalse:[^ false]].	self selectedPoint: (self framePosition - self selectedPoint).	self selectedNormal: norm.	^ true.	! !!TRay methodsFor: 'picking'!pickQuad: p1 q2: p2 q3: p3 q4: p4	^ self pickQuad: nil q1: p1 q2: p2 q3: p3 q4: p4.	! !!TRay methodsFor: 'picking' stamp: 'das 9/5/2002 17:22'!pickSphere: loc radiusSquared: rs	| p dp d dd c |" This method is used to find the surface of the actual sphere, not just determine if the pointer intersects it."	rs = 0.0 ifTrue:[^ false.].	p _ loc - self framePosition.	" project center of sphere onto the ray"	dp _ self framePointer row3 * (self framePointer row3 dot: p).	dd _ dp - p." distance of ray to center - if greater than radius, exit"	d _ dd dot: dd.	d > rs ifTrue:[^false.]." calculate the point on the sphere"	c _ (rs-d)sqrt.	dp _ dp + (c * self framePointer row3).	d _ dp dot: dp." if it is closer than the current selected object, save and calc norm."	(self testSelectedDistanceSquared: d) ifTrue: [		self selectedDistanceSquared: d.		self selectedPoint: (self framePosition + dp).		self selectedNormal: (self selectedPoint - loc) normalized.		^ true.				].	^ false.! !!TRay methodsFor: 'picking'!pickTriangle: p1 tri: p2 tri: p3	^ self pickTriangle: nil tri: p1 tri: p2 tri: p3.! !!TRay methodsFor: 'picking' stamp: 'ar 6/13/2003 22:42'!pickTriangle: norm tri: p1 tri: p2 tri: p3	| pointAt po1 po2 po3 d1 d2 d3 |	pointAt _ self framePointer row3.	norm ifNotNil:[		((pointAt dot: norm) < 0) ifTrue:[^ false ].].	po1 _ self framePosition - p1.	po2 _ self framePosition - p2.	po3 _ self framePosition - p3." Are any of the points actually in front of the pointer?"	d1 _ pointAt dot: po1.	d2 _ pointAt dot: po2.	d3 _ pointAt dot: po3.	d1 < 0 ifTrue:[		d2< 0 ifTrue:[			d3 < 0 ifTrue:[^ false.]]]." If all of the points are further than the current selected distance, then we are done."	(self testSelectedDistance: d1) ifFalse:[	(self testSelectedDistance: d2) ifFalse:[	(self testSelectedDistance: d3) ifFalse:[^ false]]].	(self pickFrame: self framePointer tri: po1 tri: po2 tri: po3) ifTrue: [		self selectedPoint: (self framePosition - self selectedPoint).		self selectedNormal: norm.		self selectedTriangle: (Array with: p1 with: p2 with: p3).		^ true.].	 ^ false.! !!TRay methodsFor: 'picking' stamp: 'ar 6/13/2003 22:41'!pickTriangles: vertices list: triList	"Pick an indexed triangle array"	| pointAt po1 po2 po3 d1 d2 d3 fp index v0 v1 v2 |	fp := self framePosition.	pointAt _ self framePointer row3.	index := 0.	[index < triList size] whileTrue:[		v0 := vertices at: (triList at: (index := index+1))+1.		v1 := vertices at: (triList at: (index := index+1))+1.		v2 := vertices at: (triList at: (index := index+1))+1.		po1 := fp - v0.		po2 := fp - v1.		po3 := fp - v2.		"Are any of the points actually in front of the pointer?"		d1 _ pointAt dot: po1.		d2 _ pointAt dot: po2.		d3 _ pointAt dot: po3.		(d1 >= 0.0 or:[d2 >= 0.0 or:[d3 >= 0.0]]) ifTrue:[			" If all of the points are further than the current selected distance, then we are done."			((self testSelectedDistance: d1) or:[				(self testSelectedDistance: d2) or:[					(self testSelectedDistance: d3)]]) ifTrue:[				(self pickFrame: self framePointer tri: po1 tri: po2 tri: po3) ifTrue: [					self selectedPoint: (self framePosition - self selectedPoint).					self selectedNormal: nil.					self selectedTriangle: (Array with: v0 with: v1 with: v2).					^ true.				].			].		].	].	^false! !!TRay methodsFor: 'picking' stamp: 'ar 9/30/2004 16:33'!pointerPick: bnds	| position frame gpAt dp d |	doSelect ifTrue:[		bnds ifNil:[^ false.].		bnds frame objectOwner isComponent ifTrue:[			position _ bnds globalPosition - self globalPosition.			self selectedDistance > ((position length - bnds radius) * CroquetGlobals frameScale) ifTrue:[				gpAt _ self globalTransform column3.				dp _ position - ((gpAt dot: position)*gpAt).				d _ dp dot: dp.				d < bnds radiusSquared ifFalse:[ ^ false ].				self sphereDistSquared: d.				frame _ bnds frame.				self currentFrame: frame.				(frame pick: self) ifTrue:[					self selectedPoint ifNil:[self selectedPoint: B3DVector3 new.].					self selectedFrame: frame.					self selectedParent: frame parent.					self selectedFramePosition:  self framePosition.					self selectedObject: frame objectOwner.					self selectedParentTransform: self parent globalTransform.					^ true.					].				].			].		].	^ false.! !!TRay methodsFor: 'picking' stamp: 'DPR 1/9/2004 14:05'!pointerPickFloor: frame		self currentFrame: frame.	(frame pickFloor: self) ifTrue:[		self selectedFrame: frame.		self selectedParent: frame parent.		self selectedFramePosition:  self framePosition.		self selectedObject: frame objectOwner.		^ true.		].	^ false.! !!TRay methodsFor: 'picking' stamp: 'das 1/30/2003 16:42'!pointerPickTree: frame	frame visible ifTrue:[(self pointerPick: frame boundSphere) ifTrue:[^ true].].	frame frameChildren ifNotNil:[		frame frameChildren do:[ :fc | (self pointerPickTree: fc) ifTrue:[^ true.].].].	^ false.! !!TRay methodsFor: 'picking' stamp: 'DPR 1/9/2004 14:05'!portalTest: frame at: at	| rval saveFP up side |	saveFP _ framePointer.	rval _ false.	up _ B3DVector3 x: 0.0 y:1.0 z:0.0.	side _ (up cross: at) normalized.	up _ (at cross: side) normalized.	framePointer _ B3DMatrix4x4 identity.	framePointer at: 1 at: 1 put: side x.	framePointer at: 1 at: 2 put: side y.	framePointer at: 1 at: 3 put: side z.	framePointer at: 2 at: 1 put: up x.	framePointer at: 2 at: 2 put: up y.	framePointer at: 2 at: 3 put: up z.	framePointer at: 3 at: 1 put: at x.	framePointer at: 3 at: 2 put: at y.	framePointer at: 3 at: 3 put: at z.	self testDistance: false.	(frame pick: self) ifTrue:[ rval _ true.].	self testDistance: true.	framePointer _ saveFP.	^ rval.! !!TRay methodsFor: 'initialize' stamp: 'DPR 7/13/2004 09:56'!initialize	super initialize.	selection := TSelection new.	lastSelection := TSelection new.	self doSelect: true.	self testDistance: true.	self visible: false.	self downRay: false.	self resetSelected.	self setAutomatic: true.	self minDistance: 0.0.	self maxDistance: Float infinity.	^self! !!TRay methodsFor: 'testing' stamp: 'das 11/9/2002 15:03'!isRay	^ true.! !!TPointer methodsFor: 'accessing' stamp: 'das 7/31/2004 11:47'!avatar	^ avatar.! !!TPointer methodsFor: 'accessing' stamp: 'das 7/31/2004 11:47'!avatar: av	avatar _ av.! !!TPointer methodsFor: 'accessing' stamp: 'das 7/31/2004 12:51'!camera	^ pseudoCamera. "This is not the real camera, just has copies of key values"! !!TPointer methodsFor: 'accessing' stamp: 'das 7/31/2004 12:51'!camera: cm	pseudoCamera _ cm.! !!TPointer methodsFor: 'accessing' stamp: 'das 9/25/2004 17:14'!cameraTransform: ct	selection cameraTransform: ct.! !!TPointer methodsFor: 'accessing' stamp: 'das 8/3/2004 10:25'!isDown	^ isDown.! !!TPointer methodsFor: 'accessing' stamp: 'DPR 7/10/2003 22:14'!localTransform: trans	super localTransform: trans.	tool ifNotNil:[ tool localTransform: trans.].! !!TPointer methodsFor: 'accessing' stamp: 'das 8/11/2002 14:47'!pointerXY	^ pointerXY.! !!TPointer methodsFor: 'accessing' stamp: 'das 8/11/2002 14:47'!pointerXY: pnt	pointerXY _ pnt.! !!TPointer methodsFor: 'accessing' stamp: 'das 9/25/2004 18:17'!setDown: dn	isDown _ dn.! !!TPointer methodsFor: 'accessing' stamp: 'DPR 7/10/2003 22:14'!setSpell: sc	spellClass _ sc.	tool ifNotNil:[tool setSpell: true].! !!TPointer methodsFor: 'accessing' stamp: 'das 8/11/2002 15:44'!tool	^ tool.! !!TPointer methodsFor: 'accessing' stamp: 'das 8/11/2002 15:44'!tool: tl	tool ifNotNil:[self removeChild: tool].	tool _ tl.	tool ifNotNil:[self addChild: tool].! !!TPointer methodsFor: 'events' stamp: 'ar 10/8/2002 17:17'!controlKeyPressed	^event2D controlKeyPressed! !!TPointer methodsFor: 'events' stamp: 'das 8/11/2002 15:28'!event2D	^ event2D.! !!TPointer methodsFor: 'events' stamp: 'das 8/11/2002 15:28'!event2D: e2d	event2D _ e2d.! !!TPointer methodsFor: 'events' stamp: 'DPR 6/1/2004 10:57'!keyDown: evt	| frame |	self event2D: evt.	(frame := self selectedObject) ifNotNil:[		frame isComponent ifTrue:[			(frame handlesKeyboard: self) ifTrue:[				keySelectedObject _ frame.				frame keyDown: self.			].		.].	].! !!TPointer methodsFor: 'events' stamp: 'DPR 7/5/2004 20:01'!keyStroke: evt	| frame |	self event2D: evt.	(frame := self selectedObject) ifNotNil:[		frame isComponent ifTrue:[			(frame handlesKeyboard: self) ifTrue:[				keySelectedObject _ frame.				frame keyDown: self.			].		.].	].! !!TPointer methodsFor: 'events' stamp: 'das 8/11/2002 15:39'!keyUp: evt		self event2D: evt.	keySelectedObject ifNotNil:[		keySelectedObject isComponent ifTrue:[			(keySelectedObject handlesKeyboard: self) ifTrue:[				keySelectedObject keyUp: self.				keySelectedObject _ nil.			]]]."	doSelect _ false."! !!TPointer methodsFor: 'events' stamp: 'das 8/8/2004 00:20'!pointerDown: evt	| frame |	self signal: #pointerDown with: self.	self event2D: evt.	isDown := true.	(frame := self selectedObject) ifNotNil:[		spellClass ifNil:[			frame isComponent ifTrue:[				(frame handlesPointerDown: self) ifTrue:[					isDown _ true.					tool ifNotNil:[tool pointerDown: self.].					frame pointerDown: self.]] 			ifFalse:[ ^ false.].			]		].	doSelect _ false. "don't select anything while the pointer is down."	frame ifNil:[ ^ false.].	^ true.! !!TPointer methodsFor: 'events' stamp: 'ar 6/13/2003 19:47'!pointerEnter: evt	| frame |	self event2D: evt.	(frame := self selectedObject) ifNotNil:[		frame isComponent ifTrue:[			(frame handlesPointerOver: self) ifTrue:[				frame pointerEnter: self.]]].! !!TPointer methodsFor: 'events' stamp: 'ar 6/13/2003 19:46'!pointerLeave: evt	| frame |	self event2D: evt.	(frame := self selectedObject) ifNotNil:[		frame isComponent ifTrue:[			(frame handlesPointerOver: self) ifTrue:[				frame pointerLeave: self.]]].! !!TPointer methodsFor: 'events' stamp: 'das 6/18/2003 14:03'!pointerMove: evt	| cf frame gt spt |	self signal: #pointerMove with: self.	self event2D: evt.	(frame := self selectedObject) ifNotNil:[		frame isComponent ifTrue:[			(frame handlesPointerDown: self) ifTrue:[				self testDistance: false.				cf _ self currentFrame.				cf ifNotNil:[					cf pick: self.].				tool ifNotNil:[tool pointerMove: self.].				(spt _ self selectedParentTransform) ifNotNil:[					gt _ self globalTransform.					self globalTransform: (spt composeWith: (self localTransform)).					frame pointerMove: self.					self globalTransform: gt.] 				ifNil: [ frame pointerMove: self.].				self currentFrame: cf.				self testDistance: true.]]]."	popUpUp ifTrue:[		selectedObject _ nil.		self pointerPick: popUp.		selectedObject = lastSelectedObject ifTrue:[			selectedObject = popUp ifTrue:[popUp pointerOver: self].]		ifFalse:[				Smalltalk beep.				lastSelectedObject _ selectedObject.				selectedObject = popUp ifTrue:[popUp pointerEnter: self].				lastSelectedObject = popUp ifTrue:[popUp pointerLeave: self].].]."! !!TPointer methodsFor: 'events' stamp: 'ar 6/13/2003 19:51'!pointerOver: evt	| frame |	self event2D: evt.	doSelect ifTrue:[	(frame := self selectedObject) ifNotNil:[		frame isComponent ifTrue:[			(frame handlesPointerOver: self) ifTrue:[				frame pointerOver: self.]]]].! !!TPointer methodsFor: 'events' stamp: 'DPR 7/10/2003 22:14'!pointerUp: evt	| frame |	self signal: #pointerUp with: self.	self event2D: evt.	spellClass ifNotNil:["need to test that the pointer is still over the object we are about to select here"		spellClass castSpell: self.		spellClass _ nil.		tool ifNotNil:[tool setSpell: false.].		doSelect _ true.		self resetTotal.		^ false.		].	isDown ifTrue:[		isDown _ false.		(frame := self selectedObject) ifNotNil:[			frame isComponent ifTrue:[				(frame handlesPointerDown: self) ifTrue:[					isDown _ false.					tool ifNotNil:[tool pointerUp:[self.].].					frame pointerUp: self.]]]].	doSelect _ true.	self resetTotal.! !!TPointer methodsFor: 'events' stamp: 'ar 10/8/2002 17:17'!shiftPressed	^event2D shiftPressed! !!TPointer methodsFor: 'events' stamp: 'ar 6/13/2003 19:46'!wantsKeyboard: evt	| frame |	(frame := self selectedObject) ifNotNil:[		frame isComponent ifTrue:[			(frame handlesKeyboard: self) ifTrue:[^true]]].	^false! !!TPointer methodsFor: 'initialize' stamp: 'das 2/17/2004 13:21'!calcTransform: bounds z: zScreen	| bCenter at up side cpointer |" x and y are negated on purpose. Why? Because the z value should actually be negated as it is referring to a position in front of the camera (in the negative z direction) but anyone trying to do the math for TPointer will probably want to use a positive direction vector. OK? Get it? Essentially the math is wrong, but it is consistent. "	bCenter _ bounds center.	at _ (B3DVector3				x: bCenter x - pointerXY x				y: pointerXY y - bCenter y				z: zScreen ) normalized.	up _ B3DVector3 x: 0.0 y:1.0 z:0.0.	side _ (up cross: at) normalized.	up _ (at cross: side) normalized.	cpointer _ B3DMatrix4x4 identity.	cpointer at: 1 at: 1 put: side x.	cpointer at: 1 at: 2 put: side y.	cpointer at: 1 at: 3 put: side z.	cpointer at: 2 at: 1 put: up x.	cpointer at: 2 at: 2 put: up y.	cpointer at: 2 at: 3 put: up z.	cpointer at: 3 at: 1 put: at x.	cpointer at: 3 at: 2 put: at y.	cpointer at: 3 at: 3 put: at z.	self localTransform: cpointer transposed.! !!TPointer methodsFor: 'initialize' stamp: 'das 9/25/2004 17:53'!initialize	super initialize.	isDown _ false.	self visible: false.	^self! !!TPointer methodsFor: 'testing' stamp: 'das 12/1/2002 22:06'!isRay"----- don't want to treat this is a normal ray because there is (usually) only one and it relies on the frustum culling where the base TRay objects are tested against everything -----"	^ false.! !!TPointer methodsFor: 'fileIn/Out' stamp: 'das 8/11/2002 22:42'!prepareToExportOn: exporter	super prepareToExportOn: exporter.	event2D := nil.! !!TPointer methodsFor: '*Jana-Script' stamp: 'ar 5/5/2003 00:06'!isPointerDown	^isDown! !!TPointer methodsFor: '*Jana-Script' stamp: 'ar 6/13/2003 19:49'!isPointerDownOn: aFrame	isDown ifFalse:[^false].	^self selectedObject == aFrame! !!TRay class methodsFor: 'class initialization' stamp: 'das 12/14/2002 16:40'!initialize	TDownRay _ B3DMatrix4x4 identity rotationAroundX: -90.! !!TRectangle methodsFor: 'accessing'!aspect	^ aspect.! !!TRectangle methodsFor: 'accessing'!aspect: asp	aspect _ asp.! !!TRectangle methodsFor: 'accessing'!aspectFixed	^ aspectFixed.! !!TRectangle methodsFor: 'accessing'!aspectFixed: bool	aspectFixed _ bool.! !!TRectangle methodsFor: 'accessing'!extent	^ extent.! !!TRectangle methodsFor: 'accessing'!extent: ext	aspectFixed ifTrue:[	 (extent x - ext x)abs > (extent y - ext y) abs ifTrue:[			extent _ (ext x) @ (ext x * aspect).] 		ifFalse:[			extent _ ext y/aspect @ ext y.].		]	ifFalse: [	extent _ ext.].	self boundsChanged.! !!TRectangle methodsFor: 'accessing' stamp: 'das 3/4/2004 22:13'!extentRect: extRect	self extent: (extRect extent).	self location: (extRect center - (extRect extent/2.0))@0.0.! !!TRectangle methodsFor: 'accessing' stamp: 'das 7/22/2003 19:34'!flip: bool	flip _ bool.	flip ifFalse:[norm _ (B3DVector3  x:0.0 y:0.0 z:1.0) ]	ifTrue:[norm _ (B3DVector3  x:0.0 y:0.0 z:-1.0)].! !!TRectangle methodsFor: 'accessing' stamp: 'das 6/21/2003 21:58'!frameBox	"Answer the local bounding box of this frame"	^TBox origin: (B3DVector3 x: extent x/-2.0 y: extent y/-2.0 z:0.0) 		corner: (B3DVector3 x: extent x/2.0 y: extent y/2.0 z:0.0) .! !!TRectangle methodsFor: 'accessing'!location	^ location.! !!TRectangle methodsFor: 'accessing'!location: loc	location _ loc.	self boundsChanged.! !!TRectangle methodsFor: 'accessing' stamp: 'das 7/22/2003 19:35'!normal: n	norm _ n.! !!TRectangle methodsFor: 'accessing' stamp: 'das 6/21/2003 22:41'!scale: scl	self translation: self translation * scl.	self extent: extent * scl.! !!TRectangle methodsFor: 'initialize' stamp: 'das 3/10/2004 14:35'!initBounds	boundSphere _ TBoundSphere localPosition: location radius: extent asPoint r / 2.	boundSphere frame: self! !!TRectangle methodsFor: 'initialize' stamp: 'das 2/17/2004 16:09'!initialize	super initialize.	location _ B3DVector3 x: 0.0 y:0.0 z:0.0.	extent _ Point x: 1 y: 1. " x-y extent of the rect."	self flip: false.	aspectFixed _ false.	aspect _ 1.0.	self initBounds.	^self! !!TRectangle methodsFor: 'render' stamp: 'das 7/22/2003 19:35'!pick: pointer	| dx dy |	dx _ self extent x/2.	dy _ self extent y/2.	flip ifFalse:[	^ pointer pickQuad: norm		q1: (B3DVector3 x: location x + dx negated y: location y + dy z: location z)		q2: (B3DVector3 x: location x + dx negated y: location y + dy negated z: location z)		q3: (B3DVector3 x: location x + dx y: location y + dy negated z: location z)		q4: (B3DVector3 x: location x + dx y: location y + dy z: location z).		]	ifTrue:[	^ pointer pickQuad: norm		q1: (B3DVector3 x: location x + dx y: location y + dy z: location z)		q2: (B3DVector3 x: location x + dx y: location y + dy negated z: location z)		q3: (B3DVector3 x: location x + dx negated y: location y + dy negated z: location z)		q4: (B3DVector3 x: location x + dx negated y: location y + dy z: location z).]! !!TRectangle methodsFor: 'render' stamp: 'das 3/12/2004 14:00'!renderPrimitive: ogl	| dx dy uv |	dx _ self extent x/2.	dy _ self extent y/2.	ogl glBegin: GLQuads.	texture ifNotNil:[ uv _ texture uvScale.]	ifNil:[uv_ 1.0@1.0.].	flip ifFalse:[ 		ogl glNormal3f: 0.0 with: 0.0 with: 1.0;			glTexCoord2f:0.0 with: 0.0;	"1"			glVertex3f: location x + dx negated with: location y + dy with: location z;			glTexCoord2f:0.0 with: uv y;	"2"			glVertex3f: location x + dx negated with: location y + dy negated with:location z;			glTexCoord2f:uv x with: uv y;	"3"			glVertex3f: location x + dx with: location y + dy negated with: location z;			glTexCoord2f:uv x with:0.0;	"4"			glVertex3f: location x + dx with: location y + dy with: location z.]	ifTrue:[		ogl glNormal3f: 0.0 with: 0.0 with: -1.0;			glTexCoord2f:uv x with:0.0;	"4"			glVertex3f: location x + dx with: location y + dy with: location z;			glTexCoord2f:uv x with:uv y;	"3"			glVertex3f: location x + dx with: location y + dy negated with: location z;			glTexCoord2f:0.0 with:uv y;	"2"			glVertex3f: location x + dx negated with: location y + dy negated with:location z;			glTexCoord2f:0.0 with: 0.0;	"1"			glVertex3f: location x + dx negated with: location y + dy with: location z.].	ogl	glEnd.! !!TButtonHolder methodsFor: 'accessing' stamp: 'das 6/21/2003 13:14'!addChild: bttn	| size box scale |	box _ bttn boundingBox.	scale _ 0.8/(box extentMax).	bttn scale: scale.	super addChild: bttn.	size _ (frameChildren size)sqrt.	self extent: ((size+1)@size).! !!TButtonHolder methodsFor: 'accessing' stamp: 'das 6/21/2003 10:46'!extent: ext	| dx dy ddx ddy topCorner box |	dx _ ext x//1. dx _ 3.	dx < 1 ifTrue: [ dx _ 1.].	dy _ frameChildren size // dx.	dx*dy < frameChildren size ifTrue:[dy _ dy + 1.].	extent _ (dx asFloat)@(dy asFloat).	topCorner _ (extent x/-2.0 + 0.5)@(extent y/2.0 - 0.5).	frameChildren doWithIndex:[ :fc :index |		ddx _ (index-1\\dx).		ddy _ (index-1//dx) negated.		box _ fc boundingBox.		fc translationX: topCorner x + ddx-box center x y: topCorner y + ddy-box center y z:0.0.		].! !!TButtonHolder methodsFor: 'initialize' stamp: 'das 8/7/2004 17:36'!initialize	super initialize.	extent _ 2.0@1.0.	self solid: false.	^self! !!TButtonHolder methodsFor: 'scriptThis' stamp: 'das 7/31/2004 10:57'!makeNewSpace: ptr	| sp2 light tframe p1 win p2 |	sp2 _ TSpace new.	sp2 color:  (Color				r: 0.2				g: 0.25				b: 0.6).		sp2 url: 'http://www.reed.com/TeaLand/spaces/newSpace.tea'."Add a light to the world "	light _ TLight new.	tframe _ TSpinner new.	tframe translationX: -10 y:0.0 z: 0.0.	tframe rotationAroundZ: 120.	tframe addRotationAroundY:-10.	tframe matNil.	tframe contents: light.	sp2 addChild: tframe.	self makeFloor: sp2 fileName:'stone.bmp'.	p1 _ TPortal new.	win _ TWindow new.	win translationX: 0 y: 0.0 z: -3.0.	win contents: p1.	ptr avatar addChild: win.	win releaseWindow.	p2 _ TPortal new.	win _ TWindow new.	win rotationAroundY: 225.	win translationX: 40.0 y:2.0 z: 40.0.	win contents: p2.	sp2 addChild: win.	p1 linkPortal: p2.	^sp2! !!TButtonHolder methodsFor: 'render' stamp: 'das 6/21/2003 16:09'!material: mat! !!TButtonHolder methodsFor: 'render' stamp: 'das 3/9/2004 15:14'!pick: pointer	^ false."	^super pick: pointer."! !!TButtonHolder methodsFor: 'render' stamp: 'das 3/12/2004 13:34'!render: ogl	"do nothing."! !!TButtonHolder methodsFor: 'render' stamp: 'das 3/12/2004 13:34'!renderAlpha: ogl	"do nothing."	super renderAlpha: ogl.! !!TPortal methodsFor: 'accessing' stamp: 'das 4/29/2002 19:29'!blocked	^ blocked.! !!TPortal methodsFor: 'accessing' stamp: 'das 4/29/2002 19:29'!blocked: bl	blocked _ bl.! !!TPortal methodsFor: 'accessing' stamp: 'das 7/14/2002 12:25'!cameraDistance	^ cameraDistance.! !!TPortal methodsFor: 'accessing' stamp: 'das 7/14/2002 12:25'!cameraDistance: cd	cameraDistance _ cd.! !!TPortal methodsFor: 'accessing' stamp: 'ar 9/7/2002 14:52'!hasAlpha	^ true.! !!TPortal methodsFor: 'accessing'!inside	^ inside.! !!TPortal methodsFor: 'accessing' stamp: 'DPR 1/9/2004 14:05'!linkPortal: tp	self toPortal: tp.	tp isPortal ifTrue:[tp toPortal: self.].! !!TPortal methodsFor: 'accessing'!lookAt	| mat |	mat _ self globalTransform.	^ B3DVector3 x:  mat a13 y: mat a23 z: mat a33.! !!TPortal methodsFor: 'accessing'!material: mat! !!TPortal methodsFor: 'accessing'!outVector	^ outVector.! !!TPortal methodsFor: 'accessing'!outVector: ov	outVector _ ov.! !!TPortal methodsFor: 'accessing' stamp: 'das 7/31/2004 11:38'!portalToScreen: ogl rect: rect	| thumbCam ac trans spc rval |	" Put a camera into the proper location in the space. "		spc _ self root.	ac _ ogl camera.	thumbCam _ TCamera new initializeWithViewPort: ac viewPort.	spc addChild: thumbCam.	thumbCam viewAngle: 45.0. "90 degree field of view"	thumbCam inPortal: true.	thumbCam bounds: rect.	trans _ self globalTransform copy. "place it in the same location as the portal"	trans row1: (trans row1 negated).	trans row3: (trans row3 negated).	thumbCam localTransform: trans.	ogl camera: thumbCam.	self visible: false.	thumbCam initFrustum: ogl.	rval _ spc doRender: ogl.	self visible: true.	spc removeChild: thumbCam.	ogl camera: ac.	ac initFrustum: ogl.	^ rval.! !!TPortal methodsFor: 'accessing' stamp: 'ar 9/30/2004 13:57'!testEnter: avatar	| delta m1 m2 trans saveFP ray |"testEnter: is used to determine if the camera moves through the plane of the portal.  DAS""Croquet world activeCamera isRemoteControl ifTrue:[^ false.]."blocked ifFalse:[ " The portal is open to enter (assuming the following is true...)"	self = toPortal ifFalse:[ " This is not a mirror"	toPortal = toPortal root ifFalse:[		ray _ TRay new.		ray globalTransform: avatar globalTransform.		ray currentFrame: self.		lastCameraPosition ifNotNil:[ " We have been here before"		lastCameraPosition z > 0 ifTrue: [ " We were somewhere in front of the portal"			delta _  (lastCameraPosition - ray framePosition).			ray framePosition z < 0 ifTrue:[				saveFP _ ray framePosition.				ray framePosition: lastCameraPosition.				(ray portalTest: self at: delta) ifTrue:[						m1 _ self globalTransform.						m2 _ toPortal globalMatrixOut.						trans _ m2 composeWith: m1 orthoNormInverse.						trans _ trans composeWith: avatar globalTransform.						avatar future: 0.0 perform: #goToPortal:transform: withArguments: { toPortal . trans }.						"orient _ trans clone.						orient translation: (B3DVector3 new).						v _ trans row3.						v x > 0 ifTrue:[rotY _ v z arcCos radiansToDegrees negated] ifFalse:							[rotY _ v z arcCos radiansToDegrees.].						ac yaw: rotY."						"Croquet world activeCamera killFrame: true."						lastCameraPosition _ nil.						"ac overlay: self."						^ true.				].			ray framePosition: saveFP.			].].].	lastCameraPosition _ ray framePosition.	].].].	^ false.! !!TPortal methodsFor: 'accessing'!toPortal	^ toPortal.! !!TPortal methodsFor: 'accessing' stamp: 'ar 9/30/2004 16:27'!toPortal: tp	"tell target that everyone viewing us is going to be viewing him"	toPortal _ tp.! !!TPortal methodsFor: 'accessing' stamp: 'das 8/27/2004 08:40'!toPortalRoot	^ toPortal root.! !!TPortal methodsFor: 'accessing' stamp: 'DPR 2/15/2004 18:02'!visible: aBool	super visible: aBool.	(self visible and:[locator notNil and:[locator isLoaded not]]) ifTrue:[		CroquetData download: locator whenFinishedSend: #doneLoading: to: self	].! !!TPortal methodsFor: 'render' stamp: 'das 3/12/2004 13:52'!disableClipPlane: ogl		ogl glDisable: GLClipPlane0.! !!TPortal methodsFor: 'render' stamp: 'das 3/12/2004 13:52'!enableClipPlane: ogl	"------ enableClipPlane is used to clip the TSpace to the front face of the portal. This ensures that objects don't get rendered in front of the portal, which would look bad and be confusing.------"	| equation |		"equation _ FloatArray ofSize: 4.	equation at:1 put: outVector x.	equation at:2 put: outVector y.	equation at:3 put: outVector z.	equation at:4 put: 0.0.""------ We need to do it this way, because Squeak does not directly support doubles and gllClipPlane requires an array of same. ------"true ifTrue:[	equation _ ExternalData fromHandle: (ExternalAddress allocate: 8*4) type:ExternalType double.	equation getHandle doubleAt: 1 put: outVector x.	equation getHandle doubleAt: 9 put: outVector y.	equation getHandle doubleAt: 17 put: outVector z.	equation getHandle doubleAt: 25 put: 0.0."	equation getHandle doubleAt: 1 put: 0.0.	equation getHandle doubleAt: 9 put: 0.0.	equation getHandle doubleAt: 17 put: 1.0.	equation getHandle doubleAt: 25 put: 0.0."	ogl		glPushMatrix;		glMultMatrixf: self globalTransform transposed;		glClipPlane: GLClipPlane0 with: equation;		glEnable: GLClipPlane0;		glPopMatrix.	equation free.]! !!TPortal methodsFor: 'render' stamp: 'das 3/12/2004 13:56'!render: ogl	" Don't do anything ."! !!TPortal methodsFor: 'render' stamp: 'das 8/12/2004 11:43'!render: ogl depth: depth	| trans m2 toSpace gt containerPortal portalClip color clipPlanes renderedObjects ac saveSelected saveDoSelect saveMinDistance portalDistance saveForceWire |" This method is the recursive portal renderer. enter refers to the renderer entering the portal. If you want the camera entering check out TPortal>>testEnter: ac."	renderedObjects _ 1. "We are also rendering the portal."" ------- We keep track of which portal we are currently working in to avoid a tight recursion error,where the portal re-enters itself to render. It is (somewhat) OK to re-enter from another portal. This is equivalent to a mirror in a mirror situation. Here we need to keep a count of the re-entries.------""	toPortal visibleTree ifFalse:[ ^0 ]. ""The portal is not visible on the other side."	toSpace _ toPortal root.	toSpace = toPortal ifTrue:[ ^0 ]. "The portal is not installed on the other side!!"	containerPortal _ ogl currentPortal.	ogl currentPortal: self." ------ For rendering the portal ONLY - we turn off depth testing. We just want to write into the stencil buffer here and set the color of the toSpace. Depth testing is turned back on before we recurse into the connected portal.------"	gt _ self globalTransform. 	depth = 1 ifTrue:[ogl glEnable: GLStencilTest.].	ogl glPushMatrix. 	ogl glMultMatrixf: gt transposed.	ogl glDisable: GLDepthTest. " ------ Paint the portal with the color of the TSpace ------ "	ogl glDisable: GLLighting.	color _ B3DVector3 x: toSpace color red y: toSpace color green z: toSpace color blue.	ogl glColor3fv: color.	ogl glStencilFunc:GLEqual with:depth-1 with: -1.	ogl glStencilOp:GLKeep with:GLKeep with:GLIncr." ------ Render the stencil here. ------ "	saveForceWire _ ogl forceWire.	ogl forceWire:false.	self renderPortal: ogl.	ogl forceWire: saveForceWire.	ogl glStencilFunc: GLEqual with: depth with: -1.	ogl glStencilOp: GLKeep with: GLKeep with: GLKeep.	ogl glEnable: GLDepthTest.	ogl glEnable: GLLighting.	ogl glPopMatrix.	ogl glPushMatrix."	m1 _ self globalTransform."	toPortal isPortal ifTrue:[m2 _ toPortal globalMatrixOut.] ifFalse:[m2 _ toPortal globalTransform.]." ------- For simplicity - and because I can't think of a good reason not to do this - if a portal points back to itself, it is considered to be a mirror. Note that we flip the directions of the polyon tests as well. This is restored at the end. We are inverting the x-coordinate of the matrix here. ------" 	self = toPortal ifTrue:[		m2 a11: m2 a11 negated.		m2 a21: m2 a21 negated.		m2 a31: m2 a31 negated.		ogl flipFace.].	ac _ ogl camera.	ac pointer ifNotNil:[		saveSelected _ ac pointer copiedSelection.		saveMinDistance _ ac pointer minDistance.		saveDoSelect _ ac pointer doSelect.		(ac pointer pointerPick: self boundSphere) ifTrue:[				portalDistance _ ac pointer selectedDistance.				ac pointer minDistance: portalDistance.			] ifFalse:[ 				portalDistance _ Float infinity.				ac pointer doSelect: false.			].		ac pointer selected: saveSelected.	].	portalClip _ac portalClip.	ac portalClip: m2." ------ This math is simply: 			m1 = trans*m2			m1 * m2**-1 = trans * m2 * m2**-1			m1 * m2**-1 = trans.  We then replace the transform matrix of the TCamera with the appropriate transform, which places the TCamera into the correct position in the new space.------"	clipPlanes _ ac clipPlanes.	ac clipPlanes: (self initClipPlanes: ac globalTransform mirror: ogl isMirror).self = toPortal ifTrue:[ ogl mirrorFlip.].	trans _ m2 composeWith: gt orthoNormInverse.	ac globalTransform:		(trans composeWith: ac globalTransform).	ac pointer ifNotNil:[		ac pointer globalTransform: 			(ac globalTransform composeWith: ac pointer localTransform).		].	renderedObjects _ renderedObjects + (toSpace renderSpace: ogl port: toPortal depth: depth+1). "<------ Render TSpace here!! -------"	ac clipPlanes: clipPlanes.	inside _ false.	self = toPortal ifTrue:[ogl flipFace. ogl mirrorFlip.].	ogl glPopMatrix." ------ Just in case we jumped into a portal, restore the stencil depth ------"	ogl glStencilFunc: GLLequal with: depth-1 with: -1.	ogl glStencilOp: GLKeep with: GLKeep with: GLKeep."------ Render the front face invisibly to set the z-buffer to ensure nothing bleeds into the portal space from our space. ------"				ogl glPushMatrix.	ogl glPolygonOffset: 2.1 with: 4.0.	ogl glEnable: GLPolygonOffsetFill.	ogl glColorMask: GLFalse with: GLFalse with: GLFalse with: GLFalse.	ogl glMultMatrixf: gt transposed.	ogl forceWire: false.	self renderPortal: ogl.	ogl forceWire: saveForceWire.	ogl glColorMask:GLTrue with: GLTrue with:GLTrue with:GLTrue.	ogl glDisable: GLPolygonOffsetFill.	ogl glPopMatrix.	depth = 1 ifTrue:[ogl glDisable: GLStencilTest.].	ogl currentPortal: containerPortal.	ac portalClip: portalClip.	ac pointer ifNotNil:[		ac pointer doSelect: saveDoSelect.		ac pointer minDistance: saveMinDistance.		ac pointer maxDistance: (ac pointer maxDistance min: portalDistance).		].	^ renderedObjects.! !!TPortal methodsFor: 'render' stamp: 'das 3/12/2004 13:56'!renderAlpha: ogl	" Don't do anything ."! !!TPortal methodsFor: 'render' stamp: 'das 11/11/2002 15:52'!renderPortal: space	^ super renderPrimitive: space.! !!TPortal methodsFor: 'fileIn/Out' stamp: 'DPR 9/5/2004 13:59'!doneLoading: aLocator	| space |	space := CroquetData loadLocator: aLocator.	(space isKindOf: TSpace) ifFalse:[^self]. "??? DPR"	space ifNotNil:[		toPortal := toPortal croquetDecode: nil.	].! !!TPortal methodsFor: 'fileIn/Out' stamp: 'DPR 1/9/2004 14:05'!postImportFrom: importer	super postImportFrom: importer.	toPortal ifNil:[toPortal := self].	(self visible and:[locator notNil]) ifTrue:[importer download: locator whenFinishedSend: #doneLoading: to: self].! !!TPortal methodsFor: 'fileIn/Out' stamp: 'DPR 8/18/2003 11:16'!prepareToExportOn: exporter	super prepareToExportOn: exporter.	locator := toPortal root locator.	toPortal := toPortal croquetEncode.! !!TPortal methodsFor: 'transform' stamp: 'das 7/28/2003 14:55'!initClipPlanes: camTrans mirror: mirror	| clip dx dy trans v1 v2 v3 v4 |"calculate the four camera clipping planes based upon the location of the portal relative to the camera. camTrans is the cameras global transform matrix. If any part of the portal is behind the camera, revert to the current clipping planes."	clip _ B3DVector3Array ofSize: 4.		dx _ self extent x/2.	dy _ self extent y/2.	trans _ camTrans orthoNormInverse composeWith: self globalTransform.	v1 _ trans localPointToGlobal:(B3DVector3 x: location x + dx negated y: location y + dy z: location z).	v1 z > 0.0 ifTrue:[^ nil.].	v2 _ trans localPointToGlobal:(B3DVector3 x: location x + dx negated y: location y + dy negated z:location z).	v2 z > 0.0 ifTrue:[^ nil.].	v3 _ trans localPointToGlobal:(B3DVector3 x: location x + dx y: location y + dy negated z: location z).	v3 z > 0.0 ifTrue:[ ^ nil.].	v4 _ trans localPointToGlobal:(B3DVector3 x: location x + dx y: location y + dy z: location z).	v4 z > 0.0 ifTrue:[ ^ nil.].		mirror ifFalse:[		clip at: 1 put: ((v2 cross: v1) normalized).		clip at: 2 put: ((v3 cross: v2) normalized).		clip at: 3 put: ((v4 cross: v3) normalized).		clip at: 4 put: ((v1 cross: v4) normalized).	] ifTrue: [		clip at: 1 put: ((v1 cross: v2) normalized).		clip at: 2 put: ((v2 cross: v3) normalized).		clip at: 3 put: ((v3 cross: v4) normalized).		clip at: 4 put: ((v4 cross: v1) normalized).	].	^ clip.! !!TPortal methodsFor: 'initialize' stamp: 'das 2/20/2004 10:45'!initialize 	| mat |	super initialize.	outVector _ B3DVector3 x: 0.0 y:0.0 z:1.0.	mat _ TMaterial new.	mat ambientColor:#(0.5 0.5 0.5 0.0) asFloatArray.	mat diffuseColor:#(0.5 0.5 0.5 0.0) asFloatArray.	super material: mat.	toPortal _ self.	inside _ false.	self initBounds.	self objectName:'portal'.	blocked _ false. 	^self! !!TPortal methodsFor: 'testing'!isPortal	^ true.! !!TPortal methodsFor: 'testing' stamp: 'das 4/29/2002 21:48'!isSolid 	^ false.! !!TPortal methodsFor: 'terminate' stamp: 'das 10/2/2002 20:54'!kill	toPortal ifNotNil:[		toPortal ~= self ifTrue:[			toPortal isPortal ifTrue:[				toPortal toPortal: toPortal.].].].! !!TRenderAlpha methodsFor: 'accessing'!distance	^ distance.! !!TRenderAlpha methodsFor: 'accessing'!object: obj transform: trans distance: dist parent: par	tObject _ obj.	transform _ trans.	distance _ dist.	parent _ par.	^ self.! !!TRenderAlpha methodsFor: 'accessing'!parent	^ parent.! !!TRenderAlpha methodsFor: 'accessing'!tObject	^ tObject.! !!TRenderAlpha methodsFor: 'accessing'!transform	^ transform.! !!TRenderAlpha class methodsFor: 'instance creation'!object: obj transform: trans distance: dist parent: par	^ self new object: obj transform: trans distance: dist parent: par.! !!TResourceLoader methodsFor: 'accessing' stamp: 'ar 6/6/2002 16:34'!add: req	mutex critical:[queue add: req].! !!TResourceLoader methodsFor: 'accessing' stamp: 'ar 6/6/2002 13:07'!addAll: aCollection	mutex critical:[queue addAll: aCollection].! !!TResourceLoader methodsFor: 'accessing' stamp: 'ar 6/12/2002 05:25'!currentUrl	^currentUrl! !!TResourceLoader methodsFor: 'accessing' stamp: 'ar 6/6/2002 16:34'!download: aLocator whenFinishedSend: aSelector to: anObject	self add: {aLocator. anObject. aSelector}! !!TResourceLoader methodsFor: 'initialize' stamp: 'ar 6/6/2002 20:47'!initialize	mutex := Semaphore forMutualExclusion.	queue := Heap new sortBlock:[:a1 :a2| a1 first resourceFileSize <= a2 first resourceFileSize].	msgQueue := OrderedCollection new.	loader := HTTPLoader default.! !!TResourceLoader methodsFor: 'testing' stamp: 'ar 6/6/2002 20:46'!isDone	^mutex critical:[request == nil and:[queue isEmpty and:[msgQueue isEmpty]]].! !!TResourceLoader methodsFor: 'loading' stamp: 'ar 6/12/2002 05:25'!load: locator	| file req stream fileName |	currentUrl := locator urlString.	fileName := self class fileNameFromUrl: locator urlString.	file := [FileStream readOnlyFileNamed: fileName] 			on: FileDoesNotExistException 			do:[:ex| ex return: nil].	file ifNotNil:[		locator localFileName: fileName.		file close.		^self].	req _ HTTPLoader httpRequestClass for: locator urlString in: loader.	loader addRequest: req.	stream := req contentStream.	file := [FileStream newFileNamed: fileName] on: Error do:[:ex| ex return: nil].	file ifNil:[^nil].	file nextPutAll: stream contents.	file close.	stream close.	locator localFileName: fileName.! !!TResourceLoader methodsFor: 'loading' stamp: 'ar 6/12/2002 05:25'!runLoaderProcess	| loc rcvr sel msg |	[mutex critical:[request := queue isEmpty ifTrue:[nil] ifFalse:[queue removeFirst]].	request == nil] whileFalse:[		loc := request first.		rcvr := request second.		sel := request third.		self load: loc.		(rcvr == nil or:[sel == nil]) 			ifFalse:[msg := MessageSend receiver: rcvr selector: sel argument: loc].		mutex critical:[msgQueue add: msg].	].	loaderProcess := nil.! !!TResourceLoader methodsFor: 'loading' stamp: 'ar 6/6/2002 20:45'!startDownload	loaderProcess := [self runLoaderProcess] newProcess.	loaderProcess priority: Processor userInterruptPriority.	loaderProcess resume.! !!TResourceLoader methodsFor: 'loading' stamp: 'ar 6/12/2002 05:27'!step	| msg |	mutex critical:[msg := msgQueue isEmpty ifTrue:[nil] ifFalse:[msgQueue removeFirst]].	msg == nil ifFalse:[		currentUrl := msg arguments first urlString.		^msg value].	loaderProcess == nil ifTrue:[		queue isEmpty ifFalse:[self startDownload].	].! !!TResourceLoader methodsFor: 'loading' stamp: 'ar 6/16/2002 18:44'!stepFor: msecs	| deadline |	deadline := Time millisecondClockValue + msecs.	[self step.	self isDone or:[Time millisecondClockValue >= deadline]] whileFalse.! !!TResourceLoader class methodsFor: 'utilities' stamp: 'ar 6/6/2002 17:19'!cacheDirectory	^FileDirectory default directoryNamed:'data'.! !!TResourceLoader class methodsFor: 'utilities' stamp: 'ar 6/6/2002 17:19'!fileNameFromUrl: urlString	| url dir path |	url := urlString asUrl.	dir := self cacheDirectory.	dir := dir directoryNamed: url authority.	path := url path.	path size > 1 ifTrue:[		path allButLast do:[:part| dir := dir directoryNamed: part].	].	dir assureExistence.	^dir fullNameFor: path last! !!TResourceLoader class methodsFor: 'instance creation' stamp: 'ar 6/6/2002 13:31'!new	^super new initialize! !!TRigidBody methodsFor: 'accessing' stamp: 'das 5/7/2002 02:35'!allStop	self velocity: B3DVector3 new.	self angularMomentum: B3DVector3 new.! !!TRigidBody methodsFor: 'accessing' stamp: 'das 5/1/2002 15:57'!angularMomentum	^ angularMomentum.! !!TRigidBody methodsFor: 'accessing' stamp: 'das 5/1/2002 15:57'!angularMomentum: am	angularMomentum _ am.! !!TRigidBody methodsFor: 'accessing' stamp: 'das 5/3/2002 15:09'!centerMass	^ centerMass.! !!TRigidBody methodsFor: 'accessing' stamp: 'das 5/11/2002 14:20'!centerMassWorld	^ centerMassWorld.! !!TRigidBody methodsFor: 'accessing' stamp: 'das 5/7/2002 02:48'!frame	^ frame.! !!TRigidBody methodsFor: 'accessing' stamp: 'das 5/1/2002 15:56'!velocity	^ velocity.! !!TRigidBody methodsFor: 'accessing' stamp: 'das 5/1/2002 15:56'!velocity: v	velocity _ v.! !!TRigidBody methodsFor: 'collision' stamp: 'das 5/7/2002 02:12'!collideFloor: floor 	^ frame collideFloor: floor! !!TRigidBody methodsFor: 'collision' stamp: 'das 5/7/2002 12:34'!collidePlane: normal offset: offset	^ frame collidePlane: normal offset: offset.! !!TRigidBody methodsFor: 'compute' stamp: 'das 5/1/2002 16:01'!computeForce: f delta: deltaTime	force _ force + (f*mass)."	force _ force - (dampingLinear * mass * velocity).	torque _ torque - (dampingAngular * angularMomentum)."	! !!TRigidBody methodsFor: 'compute' stamp: 'das 5/11/2002 14:35'!globalTransformUpdate	" This is actually called when the globalTransform needs to be updated because the frame has changed. This means that we only recalculate centerMassWorld as necessary."	centerMassWorld _ globalTransform localPointToGlobal: centerMass.! !!TRigidBody methodsFor: 'compute' stamp: 'das 5/11/2002 14:45'!impulse: impulse at: r	| rc |	rc _ r-self centerMassWorld.	velocity _ velocity + (impulse * oneOverMass).	angularMomentum _ angularMomentum + (rc cross: impulse).! !!TRigidBody methodsFor: 'compute' stamp: 'das 5/16/2002 11:12'!integrate: deltaTime	| position orientation av angularVelocity |"	energy = 0.0 ifTrue:[^ self]."		position _ self translation.	orientation _ self orientation.	velocity _ force * oneOverMass * deltaTime + velocity.	position _ velocity * deltaTime + position.	angularMomentum _ torque * deltaTime + angularMomentum.	inverseWorldInertiaTensor _ (orientation orthoNormInverse composedWithLocal:		inverseInertiaTensor) composedWithLocal: orientation.	angularVelocity _  inverseWorldInertiaTensor localPointToGlobal: angularMomentum.	av _ deltaTime * angularVelocity.	orientation _ orientation + (orientation composedWithLocal: (B3DMatrix4x4 skew: av)).	orientation _ self orthoNormalize: orientation.	self orientation: orientation.	self translation: position.	torque _ B3DVector3 new.	force _ B3DVector3 new.! !!TRigidBody methodsFor: 'compute' stamp: 'das 5/1/2002 14:07'!orthoNormalize: mat	| rmat r1 r2 r3 |	rmat _ B3DMatrix4x4 new.	r1 _ mat row1.	r2 _ mat row2.	r3 _ mat row3.	r1 _ r1 normalize.	r3 _ (r1 cross: r2)normalize.	r2 _ (r3 cross: r1)normalize.		rmat a11: r1 x.	rmat a12: r1 y.	rmat a13: r1 z.	rmat a21: r2 x.	rmat a22: r2 y.	rmat a23: r2 z.	rmat a31: r3 x.	rmat a32: r3 y.	rmat a33: r3 z.	rmat a44: 1.0.	^ rmat.	! !!TRigidBody methodsFor: 'initialize' stamp: 'ar 9/30/2004 13:10'!initializeWithFrame: frm mass: ms	| it |" This object can only have one frame associated with it as the rigid body object for now. #addChild: should not be used."	self singleParent: true.	frame _ frm.	frm objectOwner: nil. "This forces the pointer to look at the parent for objectOwner."	self addChild: frame.	mass _ ms.	it _ frame inertiaTensor.	it ifNotNil:[		it mass: ms.		inertiaTensor _ it result." The inertiaTensor is not a homogeneous matrix (I don't think), so I can't just flip axes here. Doesn't matter anyway, as this is only done in initialize."		inverseInertiaTensor _ inertiaTensor inverseTransformation.		centerMass _ it centerMass.		oneOverMass _ 1.0/mass.].		velocity _ B3DVector3 new.	momentum _ B3DVector3 new.	force _ B3DVector3 new.	torque _ B3DVector3 new.	angularMomentum _ B3DVector3 new.	dampingLinear _ 0.5.	dampingAngular _2.0.	energy _ 0.	self visible: false.	^self! !!TRigidBody methodsFor: 'testing' stamp: 'das 5/14/2002 10:39'!isRigidBody	^ true.! !!TRover methodsFor: 'events' stamp: 'das 12/10/2002 14:47'!handlesKeyboard: pointer^ true.! !!TRover methodsFor: 'events' stamp: 'das 10/27/2002 23:59'!handlesPointerDown: pointer	^ true.! !!TRover methodsFor: 'events' stamp: 'das 9/23/2003 07:26'!keyDown: pointer	| c |	c _ pointer event2D keyCharacter.	c = $f ifTrue:[ "move forward" 		self meta setSpeed: (speed + deltaSpeed).		inControl _ true.		].	c = $b ifTrue:[ "move backwards" 		self meta setSpeed: (speed - deltaSpeed).		inControl _ true.		].	c = $l ifTrue:[ "turn left" 		self meta setTurn: (turn + 1).		inControl _ true.		].	c = $r ifTrue:[ "turn right" 		self meta setTurn: (turn - 1).		inControl _ true.		].	pointer event2D keyValue = 32 ifTrue:[ "stop" 		self meta stop.		inControl _ true.		].! !!TRover methodsFor: 'events' stamp: 'DPR 7/5/2004 20:01'!keyStroke: pointer	| c |	c _ pointer event2D keyValue.	c = 30 ifTrue:[ "move forward" 		self setSpeed: (speed + deltaSpeed).		inControl _ true.		].	c = 31 ifTrue:[ "move backwards" 		self setSpeed: (speed - deltaSpeed).		inControl _ true.		].	c = 28 ifTrue:[ "turn left" 		self setTurn: (turn + 1).		inControl _ true.		].	c = 29 ifTrue:[ "turn right" 		self setTurn: (turn - 1).		inControl _ true.		].	c = 32 ifTrue:[ "stop" 		self stop.		inControl _ true.		].! !!TRover methodsFor: 'events' stamp: 'das 7/31/2004 11:15'!pointerDown: pointer	| trns av |	av _ pointer avatar.	(av isChild: self root) ifTrue:[		trns _ self globalTransform orthoNormInverse composeWith: av globalTransform.		av downPointer setAutomatic: false.		av parent removeChild: av.		self addChild: av.		av localTransform: trns.		] ifFalse:[		(av isChild: self) ifTrue:[			av downPointer setAutomatic: false.			av parent removeChild: av.			body addChild: av.			av localTransform: (B3DMatrix4x4 identity).			av translation: (B3DVector3 x:-6 y: 2 z: 0).			av rotationAroundY: -90.			] ifFalse:[ 			(av isChild: body) ifTrue:[			av translationX: -6 y:2 z: -0.1.			av localTransform:av globalTransform.			av downPointer setAutomatic: true.			av parent removeChild: av.			self root addChild: av.			]		]	].	^ true.! !!TRover methodsFor: 'events' stamp: 'das 12/9/2002 11:03'!pointerUp: pointer	^ true.! !!TRover methodsFor: 'initialize' stamp: 'ar 10/3/2004 11:09'!initialize	| tframe ray |	super initialize.	tframe _ CroquetData loadURL: 'http://www.reed.com/TeaLand/spaces/marsRover.tea'.	tframe ifNil:[		tframe _ (TLoad3DSMax new initializeWithFileName: (FileDirectory pathFrom: {FileDirectory default pathName. 'Content'. 'Mars'. 'rover.ASE'}) scale: 0.05) frame.		tframe translationX: 0 y:0 z:0.		tframe collapse.		tframe boundsDepth: 2.		tframe initBounds.		TExporter export: tframe asBinary:'http://www.reed.com/TeaLand/spaces/marsRover.tea'.		].	self addChild: tframe.	tframe objectOwner: self.	body _ (tframe find:[:frm | frm objectName = 'RoverBody']) at: 1.	wheels _ OrderedCollection new.	wheels add: ((tframe find:[:frm | frm objectName = 'LFWheel']) at: 1).	wheels add: ((tframe find:[:frm | frm objectName = 'LMWheel']) at: 1).	wheels add: ((tframe find:[:frm | frm objectName = 'LRWheel']) at: 1).	wheels add: ((tframe find:[:frm | frm objectName = 'RFWheel']) at: 1).	wheels add: ((tframe find:[:frm | frm objectName = 'RMWheel']) at: 1).	wheels add: ((tframe find:[:frm | frm objectName = 'RRWheel']) at: 1).	wheelRays _ OrderedCollection new.	wheels do:[ :w | 		w solid: false.		ray _ TRay new.		ray downRay: true.		wheelRays add: ray.		w parent addChild: ray.		]. 	frontTurn _ OrderedCollection new.	frontTurn add:((tframe find:[:frm | frm objectName = 'LFrtWhlAssembly']) at: 1).	frontTurn add:((tframe find:[:frm | frm objectName = 'RFrtWhlAssembly']) at: 1).	rearTurn _ OrderedCollection new.	rearTurn add:((tframe find:[:frm | frm objectName = 'LRearWhlAssembly']) at: 1).	rearTurn add:((tframe find:[:frm | frm objectName = 'RRearWhlAssembly']) at: 1).	leftFrontPair _ ((tframe find:[:frm | frm objectName = 'LFrtWheelPair']) at: 1).	rightFrontPair  _ ((tframe find:[:frm | frm objectName = 'RFrtWheelPair']) at: 1).	leftSide _ OrderedCollection new.	leftSide add:((tframe find:[:frm | frm objectName = 'LFrontWheelGroup']) at: 1).	leftSide add:((tframe find:[:frm | frm objectName = 'LRearWheelGroup']) at: 1).	rightSide _ OrderedCollection new.	rightSide add:((tframe find:[:frm | frm objectName = 'RFrontWheelGroup']) at: 1).	rightSide add:((tframe find:[:frm | frm objectName = 'RRearWheelGroup']) at: 1).	wheelRadius _ (wheels at: 1)frameBox extent x/2.0.	wheelBase _ ((wheels at: 1) globalPosition - (wheels at: 3) globalPosition) length.	axleLength _((wheels at: 1) globalPosition - (wheels at: 4) globalPosition) length.	speed _ 0.0.	wheelRotSpeed _ 0.0.	wheelAngle _ 0.0.	deltaSpeed _ 0.05.	turn _ 0.0.	turnAngle _ 0.	turnSpeed _ 0.0.	v1 _ (wheels at: 1) globalPosition - (wheels at: 2) globalPosition.	v2 _ leftFrontPair globalPosition - (wheels at:2) globalPosition.	v3 _ leftFrontPair globalPosition - (wheels at:3) globalPosition.	vlr _ (leftSide at: 1) globalPosition - (rightSide at: 1) globalPosition.	trans _ 50.	inControl _ false.! !!TRover methodsFor: 'testing' stamp: 'das 8/18/2002 23:27'!isComponent	^ true.! !!TRover methodsFor: 'accessing' stamp: 'das 1/30/2003 08:33'!setSpeed: spd	speed _ spd.	speed abs < (deltaSpeed/2.0) ifTrue:[speed _ 0.0].	wheelRotSpeed _ (speed/wheelRadius) radiansToDegrees negated.	self updateTurn.	inControl _ false.! !!TRover methodsFor: 'accessing' stamp: 'das 1/30/2003 08:47'!setTurn: trn	turn _ trn.	turn > 45 ifTrue:[turn _ 45].	turn < -45 ifTrue:[turn _ -45].	frontTurn do:[ :ft | ft rotationAroundY: turn.].	rearTurn do:[ :ft | ft rotationAroundY:( turn negated)].	self updateTurn.	inControl _ false.! !!TRover methodsFor: 'accessing' stamp: 'das 1/30/2003 08:34'!stop	speed _ 0.0.	wheelRotSpeed _ 0.0.	turnSpeed _ 0.0.	self updateTurn.	inControl _ false.! !!TRover methodsFor: 'accessing' stamp: 'das 1/30/2003 08:34'!turnAngle	^ turnAngle.! !!TRover methodsFor: 'accessing' stamp: 'das 1/30/2003 08:34'!turnAngle: ta	turnAngle _ ta.	self rotationAroundY: ta.! !!TRover methodsFor: 'accessing' stamp: 'das 1/30/2003 08:38'!updateTurn	| turnRadius |	turn = 0 ifTrue:[turnSpeed _ 0.] ifFalse:[		turn > 0 ifTrue:[ turnRadius _ (wheelBase/2.0) * ((90-turn) degreesToRadians tan).]		ifFalse:[turnRadius _ (wheelBase/2.0) * ((90+turn) degreesToRadians tan negated).].		turnSpeed _ (speed/turnRadius) radiansToDegrees.		].! !!TRover methodsFor: 'stepping' stamp: 'ar 9/30/2004 09:14'!stepAt: currentTime	| yloc a1 a2 dv py secs |		lastTime ifNil:[ lastTime _ currentTime. updateTime _ currentTime. ^ self.].	secs _ (currentTime - lastTime) asFloat /1000.0.	lastTime _ currentTime.	"frameNumber =  lastFrameNumber ifTrue:[^ self.].	lastFrameNumber _ frameNumber."speed ~= 0.0 ifTrue:[	wheelAngle _ wheelAngle + (wheelRotSpeed * secs).	turnAngle _ turnAngle + (turnSpeed * secs).	turnAngle > 360 ifTrue:[ turnAngle _ turnAngle - 360.].	turnAngle < 0 ifTrue:[ turnAngle _ turnAngle + 360].	wheels do:[ :w | w rotationAroundZ: wheelAngle.].	self translation: self translation+(self globalTransform column1*speed*secs).	self rotationAroundY: turnAngle.	(wheelRays at:1) selectedDistance ~= Float infinity ifTrue:[		yloc _ Array ofSize: 6.		1 to: 6 do:[:index |			yloc at: index put: ((wheels at: index) globalPosition y) - 				((wheelRays at: index) selectedDistance - wheelRadius).].				dv _ v1 copy.		dv y: (yloc at:2) -(yloc at:1).		a1 _ v1 angleTo: dv.		dv y > v1 y ifTrue:[a1 _ a1 negated].		py _ (yloc at: 2) + (v2 x * (a1 sin)) + (v2 y * (a1 cos)).		dv _ v3 copy.		dv y: py - (yloc at: 3).		a2 _ v3 angleTo: dv.		dv y < v3 y ifTrue:[ a2 _ a2 negated].		a1 _ (a1 - a2) radiansToDegrees.		a2 _ a2 radiansToDegrees.		leftFrontPair rotationAroundZ:  a1.		(leftSide at: 1) rotationAroundZ: a2.		(leftSide at: 2) rotationAroundZ: a2.		dv _ v1 copy.		dv y: (yloc at:5) -(yloc at:4).		a1 _ v1 angleTo: dv.		dv y > v1 y ifTrue:[a1 _ a1 negated].		py _ (yloc at: 5) + (v2 x * (a1 sin)) + (v2 y * (a1 cos)).		dv _ v3 copy.		dv y: py - (yloc at: 6).		a2 _ v3 angleTo: dv.		dv y < v3 y ifTrue:[ a2 _ a2 negated].		a1 _ (a1 - a2) radiansToDegrees.		a2 _ a2 radiansToDegrees.		rightFrontPair rotationAroundZ:  a1.		(rightSide at: 1) rotationAroundZ: a2.		(rightSide at: 2) rotationAroundZ: a2.		py _ (wheelRays at: 3) selectedDistance + ((wheelRays at:6) selectedDistance)/2.0.		self translation: (self translation - (0@(py - wheelRadius)@0)).		].	inControl ifTrue:[ updateTime+500 < currentTime ifTrue:[			self metaSend turnAngle: turnAngle.			self metaSend setSpeed: speed.			self metaSend localTransform: self localTransform.			updateTime _ currentTime.			].		].	].! !!TRover methodsFor: 'stepping' stamp: 'das 8/18/2002 23:41'!wantsSteps	^ true.! !!TSampledSound methodsFor: 'accessing' stamp: 'das 4/12/2003 22:38'!addSoundBuffer: data at: deltaMSecs stereo: stereoFlag samplingRate: samplingRate codec: codecClass	| buffer doStart |	(deltaMSecs <= frameTime and:[ buffers size > 0]) ifTrue:[ ^0]. "you are late..."	mySound ifNil:[		baseSamplingRate _ samplingRate.		mySound := SampledSound samples: #() samplingRate: samplingRate.	].	codecClass 		ifNil:[buffer := SoundBuffer fromByteArray: data]		ifNotNil:[			codec class ~= codecClass ifTrue:[ codec _ codecClass new.].			buffer := codec decodeCompressedDataNoReset: data.			].	doStart := false.	mutex critical:[		self isPlaying ifFalse:[			buffers removeAll.			doStart := true].		buffers add: (deltaMSecs -> buffer)].	doStart ifTrue:[self play].	buffers size printString displayAt: 0@60.	^ buffer meterLevel.	! !!TSampledSound methodsFor: 'accessing' stamp: 'das 4/13/2003 00:55'!currentSound	^ mySound.! !!TSampledSound methodsFor: 'accessing' stamp: 'das 4/13/2003 00:56'!currentSound: cs	mySound _ cs.! !!TSampledSound methodsFor: 'accessing' stamp: 'das 4/13/2003 01:40'!nextSound	| next accelerator |	next _ nil.	mutex critical:[buffers size = 0 ifFalse:[next := buffers removeFirst]].	next ifNotNil:[		accelerator _ 1.00 + (0.01*buffers size).		frameTime := next key.		next := next value.		next := SampledSound samples: next samplingRate: accelerator * baseSamplingRate.		].	^ next.! !!TSampledSound methodsFor: 'sound generation' stamp: 'ar 3/12/2002 22:36'!doControl	super doControl.	mySound ifNotNil:[mySound doControl].! !!TSampledSound methodsFor: 'sound generation' stamp: 'das 4/13/2003 19:22'!mixSampleCount: sampleCount into: aSoundBuffer startingAt: startIndex leftVol: leftVol rightVol: rightVol	| finalIndex index remaining count |	self currentSound isNil ifTrue:[ ^ self ].	finalIndex _ (startIndex + sampleCount) - 1.	index _ startIndex.	[index <= finalIndex] whileTrue: [		[self currentSound isNil ifTrue:[ ^ self ].		(remaining _ self currentSound samplesRemaining) <=0]			whileTrue:[self currentSound: self nextSound.].		count _ (finalIndex - index) + 1.		remaining < count ifTrue:[ count _ remaining ].		self currentSound mixSampleCount: count into: aSoundBuffer startingAt: index leftVol: leftVol rightVol: rightVol.	index _ index + count].	! !!TSampledSound methodsFor: 'sound generation' stamp: 'das 4/13/2003 13:03'!reset	super reset.	mySound ifNotNil:[mySound reset].! !!TSampledSound methodsFor: 'sound generation' stamp: 'das 4/13/2003 13:01'!testCount: sampleCount	counter ifNil:[counter _ 0].	max ifNil:[max _ 0].	min ifNil:[min _ 32768].	counter _ counter + 1.	max _ max + sampleCount.	seconds < Time millisecondClockValue ifTrue:[		'-----' displayAt: 0@75.		(counter printString) displayAt: 0@90.		max printString displayAt: 0@105.		Time millisecondClockValue printString displayAt: 0@120.		max _ 0.		seconds _ Time millisecondClockValue+1000.		counter < 9 ifTrue:[min_ min+1].		min printString displayAt: 0@135.		counter _ 0.		].! !!TSampledSound methodsFor: 'initialize' stamp: 'ar 3/12/2002 22:34'!initialize	super initialize.	frameTime := 0.	buffers := SortedCollection sortBlock:[:a1 :a2| a1 key <= a2 key].	mutex := Semaphore forMutualExclusion.! !!TScriptorWrapper methodsFor: 'accessing' stamp: 'ar 10/2/2004 19:51'!addMenuItemsTo: aMenu! !!TScriptorWrapper methodsFor: 'accessing' stamp: 'ar 10/3/2004 10:04'!asString	^item objectName! !!TScriptorWrapper methodsFor: 'accessing' stamp: 'ar 10/2/2004 19:53'!contents	^Array streamContents:[:s|		item frameChildren ifNotNilDo:[:fc| fc do:[:frame| s nextPut: (self class with: frame model: model)]].	].! !!TScriptorWrapper methodsFor: 'accessing' stamp: 'ar 10/11/2002 01:57'!dropObject	^item! !!TScriptorWrapper methodsFor: 'accessing' stamp: 'ar 10/11/2002 02:05'!dropType	^#dropFrameRef:! !!TScriptorWrapper methodsFor: 'accessing' stamp: 'ar 9/13/2002 22:06'!frame	^item! !!TScriptorWrapper methodsFor: 'accessing' stamp: 'ar 10/2/2004 19:54'!hasContents	item frameChildren isEmptyOrNil ifFalse:[^true].	^false! !!TScriptorWrapper methodsFor: 'accessing' stamp: 'ar 9/7/2002 19:15'!icon	^item scriptIcon! !!TScriptorWrapper methodsFor: 'accessing' stamp: 'ar 9/7/2002 19:15'!iconSize	^item scriptIcon extent! !!TScriptorWrapper methodsFor: 'accessing' stamp: 'ar 9/13/2002 22:05'!item	^item! !!TScrollBox3D methodsFor: 'actions' stamp: 'das 8/9/2003 11:46'!calcRotateDimension	| dir  |	dir _ (selectedFrame translation cross: boxPoint) abs .	radius _ boxPoint length.	dir x > dir y ifTrue:[		dir x > dir z ifTrue:[ selectedAction _ #rotateBoxX:. ] ifFalse:[  selectedAction _ #rotateBoxZ:]	]ifFalse:[		dir y > dir z ifTrue:[selectedAction _ #rotateBoxY:. ] ifFalse:[ selectedAction _ #rotateBoxZ:]	].! !!TScrollBox3D methodsFor: 'actions' stamp: 'das 8/5/2003 15:58'!delete	self outOfBox.! !!TScrollBox3D methodsFor: 'actions' stamp: 'das 8/1/2003 12:00'!doCorner: pointer	(pointer frame: selectedFrame pickPlane: selectedPoint normal: (B3DVector3 x:0 y:0 z: 1)) 	ifTrue:[		shiftPressed ifTrue:[^ self scaleBox: pointer.]		ifFalse:[^ self moveBox: pointer.].		].	^ false.! !!TScrollBox3D methodsFor: 'actions' stamp: 'das 7/31/2003 21:51'!doEdge: pointer	shiftPressed ifTrue:[^ false.]	ifFalse:[^ self rotateBox: pointer.].! !!TScrollBox3D methodsFor: 'actions' stamp: 'das 8/5/2003 16:00'!intoBox	| parentFrame |	parentFrame _ contents parent.	self localTransform: contents localTransform.	self translation: self translation + (self orientation localPointToGlobal:box center).	contents localTransform: B3DMatrix4x4 identity.	contents translation: (box center negated).	parentFrame ifNotNil:[		parentFrame replaceChild: contents with: self.].! !!TScrollBox3D methodsFor: 'actions' stamp: 'das 3/10/2004 22:12'!moveBox: pointer	| delta |	delta _ pointer selectedPoint - selectedPoint."delta is currently defined in terms of the selectedFrame - need to convert to this frame"	delta _ selectedFrame orientation localPointToGlobal: delta.	selectedFrame translation: selectedFrame translation + delta.	contents offset: (contents offset + (delta/contents scale)).	^ true.! !!TScrollBox3D methodsFor: 'actions' stamp: 'das 8/5/2003 15:58'!outOfBox	contents localTransform: (self localTransform composeWith: contents localTransform).	self parent replaceChild: self with: contents.! !!TScrollBox3D methodsFor: 'actions' stamp: 'das 8/1/2003 12:50'!rotateBox: pointer	| dir |	dir _ (selectedFrame translation cross: boxPoint) abs .	radius _ boxPoint length.	dir x > dir y ifTrue:[		dir x > dir z ifTrue:[ self rotateBoxX: pointer. ] ifFalse:[ self rotateBoxZ: pointer]	]ifFalse:[		dir y > dir z ifTrue:[ self rotateBoxY: pointer. ] ifFalse:[ self rotateBoxZ: pointer]	].! !!TScrollBox3D methodsFor: 'actions' stamp: 'das 8/8/2004 00:00'!rotateBoxX: pointer	| len delta deltaLoc spto spfrom theta trans |	" Rotate around the x-axis "	len _ 100.	(pointer frame: self pickCylinderFrom: ( B3DVector3 x: len  y: 0 z: 0)		to:( B3DVector3 x: len negated y: 0 z: 0) radius: radius) 	ifFalse:["we are not on the cylinder anymore...."		delta _ 2*radius.		(pointer framePointer row2 dot: (pointer framePosition))  > 0 			ifFalse:[  delta _ delta negated.].		deltaLoc _ pointer framePointer row2 * delta.		(pointer frame: self pickCylinderFrom: (B3DVector3 x: len  y: deltaLoc y z: deltaLoc z)			to: (B3DVector3 x: len negated y: deltaLoc y z: deltaLoc z) radius: radius)				ifFalse:[lastSpin _ nil. ^ false.].		spto _ pointer selectedPoint copy- deltaLoc.		spto x: 0			y: spto y negated			z: spto z negated.			]	ifTrue: [spto _ pointer selectedPoint copy.].	rotPoint ifNil:[		rotPoint _ spto. 		(rotPoint - boxPoint) length >0.01 ifTrue:[rotateDirection _ -1.0.] ifFalse:[rotateDirection _ 1.0.].	].	spfrom _ rotPoint copy.	spfrom x: 0.0.	spfrom normalize.	spto x: 0.0.	spto normalize.	theta _ ((spfrom y * spto z) - (spto y * spfrom z))"/selectedRadiusSquared".	theta < -1.0 ifTrue:[theta_ -1.0].	theta > 1.0 ifTrue:[theta _ 1.0].	theta _ theta arcSin radiansToDegrees/2.0.	lastSpin _ B3DMatrix4x4 identity rotationAroundX: theta.	trans _ self translation.	self translationX: 0.0 y:0.0 z:0.0.	self localTransform: (self localTransform composeWith: lastSpin).	self translation: trans.	self localTransform: localTransform clone.	^ true.! !!TScrollBox3D methodsFor: 'actions' stamp: 'das 8/8/2004 00:00'!rotateBoxY: pointer	| trans spfrom spto deltaLoc theta len delta |		" Rotate around the y-axis "		len _ 100.0.		(pointer frame: self pickCylinderFrom: (B3DVector3 x: 0.0 y: len z: 0.0)				to: (B3DVector3 x: 0.0 y: len negated z: 0.0) radius: radius)			ifFalse: [ "we are not on the cylinder anymore...."			delta _ 2*radius.			(pointer framePointer row1 dot: (pointer framePosition)) > 0				ifFalse:[ delta _ delta negated ].			deltaLoc _ pointer framePointer row1 * delta.			(pointer frame: self pickCylinderFrom: (B3DVector3 x: deltaLoc x y: len z: deltaLoc z )				to: (B3DVector3 x: deltaLoc x y: len negated z: deltaLoc z) radius: radius)				ifFalse:[lastSpin _ nil. ^ false.].			spto _ pointer selectedPoint copy- deltaLoc.			spto x: spto x negated				y: 0				z: spto z negated.			]	ifTrue: [spto _ pointer selectedPoint copy.].	rotPoint ifNil:[		rotPoint _ spto. 		(rotPoint - boxPoint) length >0.01 ifTrue:[rotateDirection _ -1.0.] ifFalse:[rotateDirection _ 1.0.].	].	spfrom _ rotPoint copy.	spfrom y: 0.0.	spfrom normalize.	spto y: 0.0.	spto normalize.	theta _ ((spfrom z * spto x) - (spto z * spfrom x))"/selectedRadiusSquared".	theta < -1.0 ifTrue:[theta_ -1.0].	theta > 1.0 ifTrue:[theta _ 1.0].	theta _ theta arcSin radiansToDegrees/2.0.	lastSpin _ B3DMatrix4x4 identity rotationAroundY: theta.	trans _ self translation.	self translationX: 0.0 y:0.0 z:0.0.	self localTransform: (self localTransform composeWith: lastSpin).	self translation: trans.	self localTransform: localTransform clone.	^ true.! !!TScrollBox3D methodsFor: 'actions' stamp: 'das 8/8/2004 00:00'!rotateBoxZ: pointer	| delta trans spfrom spto deltaLoc theta len |		" Rotate around the z-axis "		len _ 100.0.		(pointer frame: self pickCylinderFrom: (B3DVector3 x: 0.0 y: 0.0 z: len)				to: (B3DVector3 x: 0.0 y: 0.0 z: len negated) radius: radius)			ifFalse: [ "we are not on the cylinder anymore...."			delta _ 2*radius.			(pointer framePointer row2 dot: (pointer framePosition))  > 0 				ifFalse:[  delta _ delta negated. ].			deltaLoc _ pointer framePointer row2 * delta.			(pointer frame: self pickCylinderFrom: (B3DVector3 x: deltaLoc x y: deltaLoc y z: len)				to: (B3DVector3 x: deltaLoc x y: deltaLoc y z: len negated) radius: radius)				ifFalse:[lastSpin _ nil. ^ false.].			spto _ pointer selectedPoint copy- deltaLoc.			spto x: spto x negated				y: spto y negated				z: 0.			]	ifTrue: [spto _ pointer selectedPoint copy.].	rotPoint ifNil:[		rotPoint _ spto. 		(rotPoint - boxPoint) length >0.01 ifTrue:[rotateDirection _ -1.0.] ifFalse:[rotateDirection _ 1.0.].	].	spfrom _ rotPoint copy.	spfrom z: 0.0.	spfrom normalize.	spto z: 0.0.	spto normalize.	theta _ ((spfrom x * spto y) - (spto x * spfrom y))"/selectedRadiusSquared".	theta < -1.0 ifTrue:[theta_ -1.0].	theta > 1.0 ifTrue:[theta _ 1.0].	theta _ theta arcSin radiansToDegrees/2.0.	lastSpin _ B3DMatrix4x4 identity rotationAroundZ: theta.	trans _ self translation.	self translationX: 0.0 y:0.0 z:0.0.	self localTransform: (self localTransform composeWith: lastSpin).	self translation: trans.	self localTransform: localTransform clone.	^ true.! !!TScrollBox3D methodsFor: 'actions' stamp: 'das 3/10/2004 22:12'!scaleBox: pointer	| mn fc sp mnBase scl |	sp _ pointer selectedPoint abs.		selectedPoint _ selectedPoint abs.	mn _ sp x min: sp y.	mnBase _ selectedPoint x min: selectedPoint y.	scl _ mn/mnBase.	newScale _ scl * newScale.	newScale < 0.1 ifTrue:[newScale _ 0.1].	selectedPoint _ sp.	fc _ selectedFrame frameChildren.	1 to: 8 do:[:index | (fc at: index) translation: (basePosition at: index) *newScale.].	deferScale ifFalse:[contents scale: baseScale *newScale].	^ true.! !!TScrollBox3D methodsFor: 'events' stamp: 'das 10/21/2003 16:05'!child: frame	super changed: frame.	changed _ true.! !!TScrollBox3D methodsFor: 'events' stamp: 'das 7/22/2003 16:53'!handlesPointerDown: pointer	^ true.! !!TScrollBox3D methodsFor: 'events' stamp: 'das 7/22/2003 16:53'!handlesPointerOver: pointer	^ true.! !!TScrollBox3D methodsFor: 'events' stamp: 'das 8/9/2003 11:45'!pointerDown: pointer	shiftPressed _ pointer shiftPressed.	selectedFrame _ pointer selectedFrame parent.	selectedPoint _ pointer selectedPoint + pointer selectedFrame translation.	selectedAction _ pointer selectedFrame objectName.	boxPoint _ (selectedFrame localTransform localPointToGlobal: selectedPoint).		selectedAction = #doEdge: ifTrue:[ rotPoint _ nil. self calcRotateDimension.].	basePosition _ selectedFrame frameChildren collect:[:fc | fc translation.].	baseLength _ selectedPoint length.	baseScale _ contents scale.	newScale _ 1.0.	selectedFrame frameChildren do:[:fc | fc material: matDown.].	^ true.! !!TScrollBox3D methodsFor: 'events' stamp: 'das 7/23/2003 18:00'!pointerEnter: pointer	selectedFrame _ pointer selectedFrame parent.	selectedFrame frameChildren do:[:fc | fc material: matHilite.].	^ true.! !!TScrollBox3D methodsFor: 'events' stamp: 'das 7/23/2003 18:02'!pointerLeave: pointer	selectedFrame frameChildren do:[:fc | fc material: matOver.].	^ true.! !!TScrollBox3D methodsFor: 'events' stamp: 'das 10/23/2003 14:11'!pointerMove: pointer	selectedAction ifNotNil:[ 		self perform: selectedAction with: pointer. 		self parentChanged: contents.		^ true.		].	^ false.! !!TScrollBox3D methodsFor: 'events' stamp: 'das 7/22/2003 22:22'!pointerOver: pointer	selectedFrame = pointer selectedFrame ifFalse:[		self pointerLeave: pointer.		self pointerEnter: pointer.].	^ true.! !!TScrollBox3D methodsFor: 'events' stamp: 'das 10/23/2003 14:12'!pointerUp: pointer	selectedFrame frameChildren do:[:fc | fc material: matOver.].	deferScale ifTrue:[newScale ~= 1.0 ifTrue:[		contents scale: baseScale *newScale.	 	box _ contents boundingBox copy.	]].	self parentChanged: contents.	changed _ true.	selectedAction _ nil.	^ true.! !!TScrollBox3D methodsFor: 'initialize' stamp: 'das 8/5/2003 16:11'!contents: conts	| extent |	contents _ conts.	box _ contents boundingBox copy.	self intoBox.	extent _ box extent.	box min: (extent/-2.0).	box max: (extent/2.0).	self addChild: conts.	scaleContents _ 1.0.	selectedAction _ nil.	changed _ true.! !!TScrollBox3D methodsFor: 'initialize' stamp: 'das 3/10/2004 22:19'!initialize	| txtr |	super initialize.	txtr _ TTexture new				initializeWithFileName: 'box.png'				mipmap: true				shrinkFit: false.	matHilite _ TMaterial new.	matHilite ambientColor: TButton hiliteColor.	matHilite diffuseColor: TButton hiliteColor.	matHilite cullFace: false.	matHilite texture: txtr.	matOver _ TMaterial new.	matOver ambientColor: TButton overColor.	matOver diffuseColor: TButton overColor.	matOver cullFace: false.	matOver texture: txtr.	matDown _ TMaterial new.	matDown ambientColor: TButton downColor.	matDown diffuseColor: TButton downColor.	matDown cullFace: false.	matDown texture: txtr.	deferScale _ false.	self makeSides.	changed _ true.! !!TScrollBox3D methodsFor: 'initialize' stamp: 'das 3/10/2004 23:31'!initializeWithContents: conts	| extent |	contents _ conts.	box _ contents boundingBox copy.	self intoBox.	extent _ box extent.	box min: (extent/-2.0).	box max: (extent/2.0).	self addChild: conts.	scaleContents _ 1.0.	selectedAction _ nil.	changed _ true.! !!TScrollBox3D methodsFor: 'initialize' stamp: 'das 3/10/2004 22:26'!makeSides	| s g |	sides _ OrderedCollection ofSize: 6.	1 to: 6 do:[: groupIndex |		g _ TGroup new.		1 to: 8 do:[:index |					s _ TRectangle new.			s material: matOver.			s solid: false.			s normal: nil. " this allows the user to select from both sides"			s objectOwner: self.			index <= 4 ifTrue:[ s objectName: #doCorner:.]			ifFalse:[s objectName: #doEdge:.].			g addChild: s.			].		sides at: groupIndex put: g.		self addChild: g.		].	(sides at: 1)rotationAroundX:-90.	(sides at: 2)rotationAroundX: 90.	(sides at: 3)rotationAroundY:-90.	(sides at: 4)rotationAroundY: 90.	(sides at: 5)rotationAroundY:180.! !!TScrollBox3D methodsFor: 'initialize' stamp: 'das 10/17/2003 18:03'!update	| mn mx scale corner extent center delta | self outOfBox.self intoBox.	box _ contents boundingBox.	mn _ box min.	mx _ box max.	scale _ 25.0.	corner _ (mx-mn).	extent _ box extentMax/scale.	corner _ (corner-extent)/2.0.	corner _ corner max: extent@extent@extent.	mx _ mx max: (box center + ((extent@extent@extent)*1.5)).	mn _ mn min: (box center -((extent@extent@extent)*1.5)).	delta _ mx-mn/2.0.	center _ box center+contents translation.	(sides at: 1) translation:  center+(0@delta y@0).	(sides at: 2) translation:  center-(0@delta y@0).	(sides at: 3) translation:  center+(delta x@0@0).	(sides at: 4) translation:  center-(delta x@0@0).	(sides at: 5) translation:  center+(0@0@delta z).	(sides at: 6) translation:  center-(0@0@delta z).{ 	corner x@corner z@0. 	corner x@corner z@0. 	corner z@corner y@0. 	corner z@corner y@0.	corner x@corner y@0.	corner x@corner y@0. }	doWithIndex:[ :crnr : index| | group |		group _ sides at: index.		group frameChildren do:[ :fc | fc extent: extent@extent.].		(group frameChildren at: 1) translation: (crnr x@crnr y@0).		(group frameChildren at: 2) translation: (crnr x@crnr y negated@0).		(group frameChildren at: 3) translation: (crnr x negated@crnr y@0).		(group frameChildren at: 4) translation: (crnr x negated@crnr y negated@0).		(group frameChildren at: 5) translation: (crnr x @ 0 @ 0).		(group frameChildren at: 6) translation: (0 @ crnr y @ 0).		(group frameChildren at: 7) translation: (crnr x negated@ 0 @ 0).		(group frameChildren at: 8) translation: (0 @ crnr y negated @ 0).		].! !!TScrollBox3D methodsFor: 'accessing' stamp: 'das 8/5/2003 16:10'!changed	changed _ true.! !!TScrollBox3D methodsFor: 'accessing' stamp: 'das 8/1/2003 22:00'!deferScale: bool	deferScale _ bool.! !!TScrollBox3D methodsFor: 'accessing' stamp: 'das 7/22/2003 15:04'!extent	contents ifNotNil:[ ^ contents extent ].	^ nil.! !!TScrollBox3D methodsFor: 'accessing' stamp: 'das 8/5/2003 16:12'!extent: ext	contents ifNotNil:[ 		contents extent: ext.		box _ contents boundingBox.].	changed _ true.! !!TScrollBox3D methodsFor: 'accessing' stamp: 'das 7/22/2003 17:04'!material: mat	" do nothing - this is my material - you can't set it externally"! !!TScrollBox3D methodsFor: 'render' stamp: 'das 5/10/2004 15:43'!renderFrame: ogl parent: parent root: root	changed ifTrue:[self update. changed _ false.].	^ super renderFrame: ogl parent: parent root: root.! !!TScrollBox3D methodsFor: 'render' stamp: 'das 3/12/2004 14:00'!renderFrame: ogl space: space	changed ifTrue:[self update. changed _ false.].	^ super renderFrame: ogl space: space.! !!TScrollBox3D methodsFor: 'testing' stamp: 'das 7/22/2003 15:30'!isComponent	^ true.! !!TEditBox3D methodsFor: 'actions' stamp: 'das 3/10/2004 22:10'!moveBox: pointer		self translation: self translation +			(self orientation localPointToGlobal: (selectedFrame orientation localPointToGlobal: pointer selectedPoint-selectedPoint)).! !!TEditBox3D methodsFor: 'actions' stamp: 'das 3/10/2004 22:11'!resizeBox: pointer"This needs to be fixed - since the plane does not go through the center of the cube, there is a limit to how small this can get in any one motion. The advantage is this keeps us from getting too small."	| len1 len2  norm sp sc|	norm _ (pointer camera frameLookAt: self) negated.	sp _ selectedFrame localTransform localPointToGlobal: selectedPoint.	(pointer frame: self pickPlane: sp normal: norm) ifTrue:[		len1 _ sp length.		len2 _ pointer selectedPoint length.		len1 = 0.0 ifTrue:[^ false.].		sc _ len2/len1.		self scale: sc.		scaleContents _ scaleContents * sc.		selectedPoint _ (selectedFrame localTransform orthoNormInverse localPointToGlobal: pointer selectedPoint).		^ true.].	^ false.! !!TEditBox3D methodsFor: 'actions' stamp: 'das 3/10/2004 22:11'!selectChild	| eb |	contents frameChildren ifNotNil:[		contents frameChildren size > 0 ifTrue:[			eb_ TEditBox3D new.			eb meta contents: (contents frameChildren at: 1).			self meta delete.			].		].! !!TEditBox3D methodsFor: 'actions' stamp: 'das 3/10/2004 22:11'!selectLeftSibling	|  siblings previous eb |	siblings _ self parent frameChildren.	siblings size > 1 ifTrue:[		previous _ siblings previous: self.		self delete.		eb _ TEditBox3D new. 		eb contents: previous .		].! !!TEditBox3D methodsFor: 'actions' stamp: 'das 3/10/2004 22:11'!selectParent	| par eb |	self parent ifNotNil: [ "we are the root"		self parent ~= self root ifTrue:[ " don't select the root, as that would be really hard to edit"		par _ self parent.		self delete.		eb _ TEditBox3D new.		eb contents: par.		].	].		! !!TEditBox3D methodsFor: 'actions' stamp: 'das 3/10/2004 22:11'!selectRightSibling	|  siblings next eb |	siblings _ self parent frameChildren.	siblings size > 1 ifTrue:[		next _ siblings next: self.		self delete.		eb _ TEditBox3D new.		eb meta contents: next .		].! !!TEditBox3D methodsFor: 'events' stamp: 'das 5/22/2003 19:10'!handlesKeyboard: pointer	^ true.! !!TEditBox3D methodsFor: 'events' stamp: 'das 8/1/2003 18:47'!keyDown: pointer	| c |	c _ pointer event2D keyCharacter.	c = $d ifTrue:[self meta delete.].	pointer event2D keyValue= 28 ifTrue:[ self selectLeftSibling. ]. "left arrow"	pointer event2D keyValue= 29 ifTrue:[ self selectRightSibling.]. "right arrow"	pointer event2D keyValue= 30 ifTrue:[ self selectParent. ]. "up arrow"	pointer event2D keyValue= 31 ifTrue:[ self selectChild. ]. "down arrow"	^ true.! !!TEditBox3D methodsFor: 'events' stamp: 'DPR 7/5/2004 19:57'!keyStroke: pointer	| c |	c _ pointer event2D keyCharacter.	c = $d ifTrue:[self delete.].	pointer event2D keyValue= 28 ifTrue:[ self selectLeftSibling. ]. "left arrow"	pointer event2D keyValue= 29 ifTrue:[ self selectRightSibling.]. "right arrow"	pointer event2D keyValue= 30 ifTrue:[ self selectParent. ]. "up arrow"	pointer event2D keyValue= 31 ifTrue:[ self selectChild. ]. "down arrow"	^ true.! !!TEditBox3D methodsFor: 'accessing' stamp: 'das 10/23/2003 14:12'!scale: sc	box scale: sc."	contents scale: sc."	self update.	self parentChanged: contents.! !!TEditBox3D methodsFor: 'accessing' stamp: 'das 5/24/2003 15:13'!selectedPoint: sp	selectedPoint _ sp.! !!TEditBox3D methodsFor: 'initialize' stamp: 'das 3/10/2004 22:16'!initialize	super initialize.	self deferScale: false.! !!TEditBox3D methodsFor: 'initialize' stamp: 'ar 10/1/2004 12:55'!initializeWithContents: conts	| parentFrame extent txtr |	contents _ conts.	box _ contents boundingBox copy.	txtr _ TTexture				new initializeWithFileName: 'box.png'				mipmap: true				shrinkFit: false.	matNorm _ TMaterial new.	matNorm ambientColor: #(0.5 0.7 0.7 0.5) asFloatArray.	matNorm diffuseColor: #(0.5 0.7 0.7 0.5) asFloatArray.	matNorm texture: txtr.	matCorner _ TMaterial new.	matCorner ambientColor: #(0.9 0.9 0.3 0.9) asFloatArray.	matCorner diffuseColor: #(0.9 0.9 0.3 0.9) asFloatArray.	matCorner texture: txtr.	matEdge _ TMaterial new.	matEdge ambientColor: #(1.0 0.4 0.4 0.9) asFloatArray.	matEdge diffuseColor: #(1.0 0.4 0.4 0.9) asFloatArray.	matEdge texture: txtr.	matHilite _ TMaterial new.	matHilite ambientColor: #(1.0 1.0 0.2 0.5) asFloatArray.	matHilite diffuseColor: #(1.0 1.0 0.2 0.5) asFloatArray.	matOver _ TMaterial new.	matOver ambientColor: #(0.2 0.5 1.0 0.8) asFloatArray.	matOver diffuseColor: #(0.2 0.5 1.0 0.8) asFloatArray.	"self makeCorners."	"self makeEdges."	self makeSides.	parentFrame _ contents parent.	self localTransform: conts localTransform.	self translation: self translation + (self orientation localPointToGlobal:box center).	contents localTransform: B3DMatrix4x4 identity.	contents translation: (box center negated).	extent _ box extent.	box min: (extent/-2.0).	box max: (extent/2.0).	parentFrame replaceChild: contents with: self.	self addChild: conts.	scaleContents _ 1.0.	self update.	^self! !!TEditBox3D class methodsFor: 'instance creation' stamp: 'das 3/10/2004 22:12'!castSpell: pointer	| rval |	pointer selectedFrame ifNil:[^ nil].	rval _ self new.	rval contents: pointer selectedFrame.	^ rval.! !!TSelection methodsFor: 'accessing' stamp: 'das 10/3/2004 16:39'!cameraTransform	^ cameraTransform.! !!TSelection methodsFor: 'accessing' stamp: 'das 10/3/2004 16:39'!cameraTransform: ct	cameraTransform _ ct.! !!TSelection methodsFor: 'accessing' stamp: 'das 6/17/2003 19:30'!distance	^ distance.! !!TSelection methodsFor: 'accessing' stamp: 'das 6/17/2003 19:30'!distance: dist	distance _ dist.	distanceSquared _ distance*distance.! !!TSelection methodsFor: 'accessing' stamp: 'das 6/17/2003 19:30'!distanceSquared	^ distanceSquared.! !!TSelection methodsFor: 'accessing' stamp: 'das 6/17/2003 19:30'!distanceSquared: distSq	distanceSquared _ distSq.	distance _ distanceSquared sqrt.! !!TSelection methodsFor: 'accessing' stamp: 'ar 6/13/2003 19:36'!frame	^frame! !!TSelection methodsFor: 'accessing' stamp: 'ar 6/13/2003 19:36'!frame: aFrame	frame := aFrame! !!TSelection methodsFor: 'accessing' stamp: 'ar 6/13/2003 19:39'!framePosition	^framePosition! !!TSelection methodsFor: 'accessing' stamp: 'ar 6/13/2003 19:39'!framePosition: aPoint	framePosition := aPoint! !!TSelection methodsFor: 'accessing' stamp: 'ar 6/13/2003 19:36'!index	^index! !!TSelection methodsFor: 'accessing' stamp: 'ar 6/13/2003 19:36'!index: aNumber	index := aNumber! !!TSelection methodsFor: 'accessing' stamp: 'ar 6/13/2003 19:36'!normal	^normal! !!TSelection methodsFor: 'accessing' stamp: 'ar 6/13/2003 19:36'!normal: aVector	normal := aVector! !!TSelection methodsFor: 'accessing' stamp: 'ar 6/13/2003 19:35'!object	^object! !!TSelection methodsFor: 'accessing' stamp: 'ar 6/13/2003 19:35'!object: anObject	object := anObject! !!TSelection methodsFor: 'accessing' stamp: 'ar 6/13/2003 19:38'!parent	^parent! !!TSelection methodsFor: 'accessing' stamp: 'ar 6/13/2003 19:38'!parent: aFrame	parent := aFrame! !!TSelection methodsFor: 'accessing' stamp: 'das 6/17/2003 19:31'!parentTransform	^ parentTransform.! !!TSelection methodsFor: 'accessing' stamp: 'das 6/17/2003 19:30'!parentTransform: pt	parentTransform _ pt.! !!TSelection methodsFor: 'accessing' stamp: 'ar 6/13/2003 19:36'!point	^point! !!TSelection methodsFor: 'accessing' stamp: 'ar 6/13/2003 19:37'!point: aVector	point := aVector! !!TSelection methodsFor: 'accessing' stamp: 'ar 6/13/2003 22:39'!triangle	^triangle! !!TSelection methodsFor: 'accessing' stamp: 'ar 6/13/2003 22:39'!triangle: anArray	triangle := anArray! !!TSelectionTracker methodsFor: 'render' stamp: 'das 7/31/2004 11:39'!renderFrame: ogl parent: parent root: root	| sel tfm axis angle select dir tri acPointer |	acPointer _ ogl camera pointer.	acPointer ifNil:[^self].	select := acPointer doSelect.	sel := acPointer lastSelection.	frame := sel frame ifNil:[^0].	position := sel point ifNil:[^0].	normal := sel normal.	normal ifNil:[		tri := sel triangle ifNil:[^0].		normal := ((tri at: 2) - (tri at: 1)) cross: ((tri at: 3) - (tri at: 2)).		normal safelyNormalize.	].	tfm := frame globalTransform.	position := tfm localPointToGlobal: position.	normal := tfm localDirToGlobal: normal.	normal safelyNormalize.	dir := 0@0@1.	angle := (normal dot: dir).	(angle = 1.0 or:[angle = -1.0]) ifTrue:[		axis := 0@1@0.	] ifFalse:[		axis := normal cross: dir.		axis safelyNormalize.	].	angle := angle arcCos radiansToDegrees negated.	self orientation: (B3DRotation axis: axis angle: angle) asMatrix4x4.	self translation: position.	"Do not pick while rendering the tracker"	^[acPointer doSelect: false.	super renderFrame: ogl parent: parent root: root] ensure:[		acPointer doSelect: select.	].! !!TSelectionTracker methodsFor: 'render' stamp: 'das 7/31/2004 11:39'!renderFrame: ogl space: sp	| sel tfm axis angle select dir tri acPointer |	acPointer _ ogl camera pointer.	acPointer ifNil:[^self].	select := acPointer doSelect.	sel := acPointer lastSelection.	frame := sel frame ifNil:[^0].	position := sel point ifNil:[^0].	normal := sel normal.	normal ifNil:[		tri := sel triangle ifNil:[^0].		normal := ((tri at: 2) - (tri at: 1)) cross: ((tri at: 3) - (tri at: 2)).		normal safelyNormalize.	].	tfm := frame globalTransform.	position := tfm localPointToGlobal: position.	normal := tfm localDirToGlobal: normal.	normal safelyNormalize.	dir := 0@0@1.	angle := (normal dot: dir).	(angle = 1.0 or:[angle = -1.0]) ifTrue:[		axis := 0@1@0.	] ifFalse:[		axis := normal cross: dir.		axis safelyNormalize.	].	angle := angle arcCos radiansToDegrees negated.	self orientation: (B3DRotation axis: axis angle: angle) asMatrix4x4.	self translation: position.	"Do not pick while rendering the tracker"	^[acPointer doSelect: false.	super renderFrame: ogl space: sp] ensure:[		acPointer doSelect: select.	].! !!TSierpinski methodsFor: 'accessing'!depth	^ depth.! !!TSierpinski methodsFor: 'accessing' stamp: 'das 5/14/2003 16:42'!depth: dp	depth _ dp.	depth <=0 ifTrue:[depth _ 1].	changed _ true.	self disableCaching.! !!TSierpinski methodsFor: 'accessing'!scale	^ scale.! !!TSierpinski methodsFor: 'accessing'!scale: sc	scale _ sc.	changed _  true.	self boundsChanged.! !!TSierpinski methodsFor: 'accessing' stamp: 'DPR 1/9/2004 14:05'!value: val	val isInteger ifTrue:[		(val >=1 and: [val <= 7]) ifTrue: [		self depth: val.].].! !!TSierpinski methodsFor: 'events' stamp: 'das 6/13/2002 13:40'!handlesKeyboard: ptr	^true.! !!TSierpinski methodsFor: 'events' stamp: 'das 6/13/2002 13:40'!keyDown: pointer	| c |	c _ pointer event2D keyCharacter.	c _ c asInteger - $0 asInteger.	(c >=0 and: [c<=9]) ifTrue:[self value: c.].! !!TSierpinski methodsFor: 'events' stamp: 'DPR 7/5/2004 20:01'!keyStroke: pointer	| c |	c _ pointer event2D keyCharacter.	c _ c asInteger - $0 asInteger.	(c >=0 and: [c<=9]) ifTrue:[self value: c.].! !!TSierpinski methodsFor: 'initialize' stamp: 'das 2/17/2004 17:07'!initialize	super initialize.		depth _ 4.	scale _ 1.0.	changed _ true.	self update.	^self! !!TSierpinski methodsFor: 'initialize'!split: ind depth: dp	 | c indexArray b1 b2 b3 b4 b5 b6|		0 = (dp - 1) ifTrue: [		surface1 at: sIndex put: (ind at: 1). 		surface1 at: sIndex+1 put: (ind at: 2). 		surface1 at: sIndex+2 put: (ind at: 3).		surface2 at: sIndex put: (ind at: 1).		surface2 at: sIndex+1 put: (ind at: 3). 		surface2 at: sIndex+2 put: (ind at: 4).		surface3 at: sIndex put: (ind at: 1). 		surface3 at: sIndex+1 put: (ind at: 4). 		surface3 at: sIndex+2 put: (ind at: 2).		surface4 at: sIndex put: (ind at: 4). 		surface4 at: sIndex+1 put: (ind at: 3). 		surface4 at: sIndex+2 put: (ind at: 2). 		sIndex _ sIndex+3.] 			ifFalse: [		indexArray _ IntegerArray ofSize: 4.		" Make all of the new points "		c _ ((vertices at: (ind at: 1))+(vertices at: (ind at: 2)))/2.0.		b1 _ vIndex. vertices at: vIndex put: c. vIndex _ vIndex + 1.		c _ ((vertices at: (ind at: 1))+(vertices at: (ind at: 3)))/2.0.		b2 _ vIndex. vertices at: vIndex put: c. vIndex _ vIndex + 1.		c _ ((vertices at: (ind at: 1))+(vertices at: (ind at: 4)))/2.0.		b3 _ vIndex. vertices at: vIndex put: c. vIndex _ vIndex + 1.		c _ ((vertices at: (ind at: 2))+(vertices at: (ind at: 3)))/2.0.		b4 _ vIndex. vertices at: vIndex put: c. vIndex _ vIndex + 1.		c _ ((vertices at: (ind at: 3))+(vertices at: (ind at: 4)))/2.0.		b5 _ vIndex. vertices at: vIndex put: c. vIndex _ vIndex + 1.		c _ ((vertices at: (ind at: 4))+(vertices at: (ind at: 2)))/2.0.		b6 _ vIndex. vertices at: vIndex put: c. vIndex _ vIndex + 1.		indexArray at: 1 put: (ind at: 1).		indexArray at: 2 put: b1.		indexArray at: 3 put: b2.		indexArray at: 4 put: b3.		self split: indexArray depth: dp-1.		indexArray at: 1 put: b1.		indexArray at: 2 put: (ind at: 2).		indexArray at: 3 put: b4.		indexArray at: 4 put: b6.		self split: indexArray depth: dp-1.		indexArray at: 1 put: b2.		indexArray at: 2 put: b4.		indexArray at: 3 put: (ind at: 3).		indexArray at: 4 put: b5.		self split: indexArray depth: dp-1.		indexArray at: 1 put: b3.		indexArray at: 2 put: b6.		indexArray at: 3 put: b5.		indexArray at: 4 put: (ind at: 4).		self split: indexArray depth: dp-1.		]! !!TSierpinski methodsFor: 'initialize' stamp: 'das 5/10/2004 16:23'!update	| sigma h v c d n1 n2 |	" This method gets called when anything is changed."	surface1 _ IntegerArray ofSize: 3*(4 raisedTo: (depth-1)).	surface2 _ IntegerArray ofSize: 3*(4 raisedTo: (depth-1)).	surface3 _ IntegerArray ofSize: 3*(4 raisedTo: (depth-1)).	surface4 _ IntegerArray ofSize: 3*(4 raisedTo: (depth-1)).	sigma _ 0.	1 to: depth do:[ :i | sigma _ sigma + (4 raisedTo: i)].	vertices _ B3DVector3Array new: 4+(6*sigma).		h _ (1- (0.5*0.5))sqrt.	c _ (0.5*0.5)/h.	v _ (1- ((h-c)*(h-c)))sqrt.	d _ (c*v)/h.	vertices at: 1 put: scale * (B3DVector3 x: -0.5 y: d negated z: c negated).	vertices at: 2 put: scale * (B3DVector3 x: 0.5 y: d negated z: c negated).	vertices at: 3 put: scale * (B3DVector3 x: 0.0 y: d negated z: h-c).	vertices at: 4 put: scale * (B3DVector3 x: 0.0 y: v-d z: 0.0).	vIndex _ 5.	sIndex _ 1.	self split: #(1 2 3 4) depth: depth.	normals _ B3DVector3Array new: 4.	n1 _ (vertices at: (surface1 at:2)) - (vertices at: (surface1 at: 1)).	n2 _ (vertices at: (surface1 at:3)) - (vertices at: (surface1 at: 1)).	normals at: 1 put: ((n1 cross: n2) normalized).	n1 _ (vertices at: (surface2 at:2)) - (vertices at: (surface2 at: 1)).	n2 _ (vertices at: (surface2 at:3)) - (vertices at: (surface2 at: 1)).	normals at: 2 put:  ((n1 cross: n2) normalized).	n1 _ (vertices at: (surface3 at:2)) - (vertices at: (surface3 at: 1)).	n2 _ (vertices at: (surface3 at:3)) - (vertices at: (surface3 at: 1)).	normals at: 3 put:  ((n1 cross: n2) normalized).	n1 _ (vertices at: (surface4 at:2)) - (vertices at: (surface4 at: 1)).	n2 _ (vertices at: (surface4 at:3)) - (vertices at: (surface4 at: 1)).	normals at: 4 put:  ((n1 cross: n2) normalized).	boundSphere _ TBoundSphere localPosition: (B3DVector3 x:0.0 y:0.0 z:0.0) radius: scale*(v-d).	boundSphere frame: self.	self boundsChanged.	changed _ false.! !!TSierpinski methodsFor: 'testing' stamp: 'das 6/13/2002 13:42'!isComponent	^ true.! !!TSierpinski methodsFor: 'render' stamp: 'das 4/15/2002 19:18'!pick: pointer	(pointer pickTriangle: (normals at: 1) 		tri: (vertices at: 3) 		tri: (vertices at: 2)		tri: (vertices at: 1)) ifTrue:[ ^ true. ].	(pointer pickTriangle: (normals at: 2) 		tri: (vertices at: 4) 		tri: (vertices at: 3)		tri: (vertices at: 1)) ifTrue:[ ^ true. ].	(pointer pickTriangle: (normals at: 3) 		tri: (vertices at: 2) 		tri: (vertices at: 4)		tri: (vertices at: 1)) ifTrue:[ ^ true ].	(pointer pickTriangle: (normals at: 4) 		tri: (vertices at: 2) 		tri: (vertices at: 3)		tri: (vertices at: 4)) ifTrue:[ ^ true. ].	^ false.! !!TSierpinski methodsFor: 'render' stamp: 'das 3/12/2004 14:01'!renderPrimitive: ogl	changed		ifTrue: [self update].	ogl glEnableClientState: GLVertexArray.	ogl		glVertexPointer: 3		with: GLFloat		with: 0		with: vertices."	norm _ (vertices				at: (surface1 at: 1))				cross: (vertices						at: (surface1 at: 2)) normalized."	ogl glNormal3fv: (normals at: 1);		glDrawElements: GLTriangles		with: sIndex - 1		with: GLUnsignedInt		with: surface1 - 1."	norm _ (vertices				at: (surface2 at: 1))				cross: (vertices						at: (surface2 at: 2)) normalized."	ogl glNormal3fv: (normals at: 2);		glDrawElements: GLTriangles		with: sIndex - 1		with: GLUnsignedInt		with: surface2 - 1."	norm _ (vertices				at: (surface3 at: 1))				cross: (vertices						at: (surface3 at: 2)) normalized."	ogl glNormal3fv: (normals at: 3);		glDrawElements: GLTriangles		with: sIndex - 1		with: GLUnsignedInt		with: surface3 - 1."	norm _ (vertices				at: (surface4 at: 1))				cross: (vertices						at: (surface4 at: 2)) normalized."	ogl glNormal3fv: (normals at: 4);		glDrawElements: GLTriangles		with: sIndex - 1		with: GLUnsignedInt		with: surface4 - 1.	ogl glDisableClientState: GLVertexArray.! !!TSimpleSpin methodsFor: 'as yet unclassified' stamp: 'das 9/29/2003 10:57'!contents: cnt	contents ifNotNil:[		self removeChild: contents.].	contents _ cnt.	contents objectOwner: self.	self addChild: contents.! !!TSimpleSpin methodsFor: 'as yet unclassified' stamp: 'das 9/29/2003 10:49'!handlesPointerDown: pointer	^ true.! !!TSimpleSpin methodsFor: 'as yet unclassified' stamp: 'das 9/29/2003 10:49'!isComponent	^ true.! !!TSimpleSpin methodsFor: 'as yet unclassified' stamp: 'das 9/29/2003 10:52'!pointerUp: pointer	self meta setSpinning: isSpinning not.	^ true.! !!TSimpleSpin methodsFor: 'as yet unclassified' stamp: 'das 9/29/2003 10:52'!setSpinning: bool	isSpinning _ bool.! !!TSimpleSpin methodsFor: 'as yet unclassified' stamp: 'das 9/29/2003 10:56'!stepAt: msecs	| secs |	isSpinning ifTrue:[		secs _ (msecs - self lastStepTime)asFloat/1000.0.		angle _ angle + (secs*10).		self rotationAroundY: angle.		].! !!TSimpleSpin methodsFor: 'as yet unclassified' stamp: 'das 9/29/2003 10:52'!wantsSteps	^ true.! !!TSketchButtonMorph methodsFor: 'as yet unclassified' stamp: 'ar 10/8/2002 23:04'!containsPoint: aPoint	^self bounds containsPoint: aPoint! !!TSketchEditorMorph methodsFor: 'accessing' stamp: 'ar 6/16/2003 23:37'!accept	| newForm newBox |	teapot ifNil:[^self].	newBox _ Rectangle origin: (0@0) extent: (paintingForm extent).	newForm _ 	Form extent: newBox extent depth: paintingForm depth.	newForm copyBits: newBox from: paintingForm at: 0@0		clippingBox: newForm boundingBox rule: Form over fillColor: nil.	newForm isAllWhite ifTrue: [^self cancel].	teapot acceptSketch: newForm from: self.! !!TSketchEditorMorph methodsFor: 'accessing' stamp: 'ar 8/20/2002 02:09'!action	^self valueOfProperty: #action! !!TSketchEditorMorph methodsFor: 'accessing' stamp: 'ar 8/20/2002 02:09'!action: anAction	^self setProperty: #action toValue: anAction! !!TSketchEditorMorph methodsFor: 'accessing' stamp: 'ar 8/20/2002 02:10'!brush	^self valueOfProperty: #brush! !!TSketchEditorMorph methodsFor: 'accessing' stamp: 'ar 8/20/2002 02:10'!brush: anObject	^self setProperty: #brush toValue: anObject! !!TSketchEditorMorph methodsFor: 'accessing' stamp: 'ar 10/12/2002 23:48'!cancel	teapot ifNil:[^self].	^teapot close.! !!TSketchEditorMorph methodsFor: 'accessing' stamp: 'ar 8/20/2002 02:10'!lastEvent	^self valueOfProperty: #lastEvent! !!TSketchEditorMorph methodsFor: 'accessing' stamp: 'ar 8/20/2002 02:09'!lastEvent: anObject	^self setProperty: #lastEvent toValue: anObject! !!TSketchEditorMorph methodsFor: 'accessing' stamp: 'ar 6/17/2003 00:51'!paintingForm	| newForm newBox |	paintingForm ifNil:[^nil].	newBox _ Rectangle origin: (0@0) extent: (paintingForm extent).	newForm _ 	Form extent: newBox extent depth: paintingForm depth.	newForm copyBits: newBox from: paintingForm at: 0@0		clippingBox: newForm boundingBox rule: Form over fillColor: nil.	newForm isAllWhite ifTrue: [^nil].	^newForm! !!TSketchEditorMorph methodsFor: 'accessing' stamp: 'ar 8/20/2002 02:08'!paintingFormPen	^self valueOfProperty: #paintingFormPen! !!TSketchEditorMorph methodsFor: 'accessing' stamp: 'ar 8/20/2002 02:08'!paintingFormPen: aPen	self setProperty: #paintingFormPen toValue: aPen! !!TSketchEditorMorph methodsFor: 'accessing' stamp: 'ar 8/20/2002 02:02'!palette	^palette! !!TSketchEditorMorph methodsFor: 'accessing' stamp: 'ar 8/20/2002 13:38'!teapot	^teapot! !!TSketchEditorMorph methodsFor: 'accessing' stamp: 'ar 8/20/2002 13:38'!teapot: aMorph	teapot := aMorph! !!TSketchEditorMorph methodsFor: 'palette handling' stamp: 'ar 8/20/2002 13:35'!cancelPainting: aPaintBoxMorph evt: evt	"Undo the operation after user issued #cancel in aPaintBoxMorph"	self cancel.! !!TSketchEditorMorph methodsFor: 'palette handling' stamp: 'ar 8/20/2002 02:05'!clearPainting: aPaintBoxMorph	"Clear the image after user issued #clear in aPaintBoxMorph"	^self clear! !!TSketchEditorMorph methodsFor: 'palette handling' stamp: 'ar 8/20/2002 02:31'!paintBoxChanged: arguments! !!TSketchEditorMorph methodsFor: 'palette handling' stamp: 'ar 8/20/2002 02:14'!paletteAttached: aPaintBoxMorph	"A new palette has been attached to the receiver."	palette := aPaintBoxMorph.! !!TSketchEditorMorph methodsFor: 'palette handling' stamp: 'ar 8/20/2002 02:06'!paletteDetached: aPaintBoxMorph	"The palette has been detached to the receiver.	Don't know what to do here...."! !!TSketchEditorMorph methodsFor: 'palette handling' stamp: 'ar 8/20/2002 13:35'!savePainting: aPaintBoxMorph evt: evt	"Save the image after user issued #keep in aPaintBoxMorph"	self accept.! !!TSketchEditorMorph methodsFor: 'palette handling' stamp: 'ar 8/20/2002 02:06'!undoPainting: aPaintBoxMorph evt: evt	"Undo the operation after user issued #undo in aPaintBoxMorph"! !!TSketchEditorMorph methodsFor: 'painting' stamp: 'ar 8/20/2002 02:24'!clear	"wipe out all the paint"	paintingForm fillWithColor: Color transparent.	self invalidRect: bounds.! !!TSketchEditorMorph methodsFor: 'painting' stamp: 'ar 8/20/2002 02:03'!erase: evt	"Pen is set up to draw transparent squares"	self paint: evt! !!TSketchEditorMorph methodsFor: 'painting' stamp: 'ar 8/20/2002 02:17'!erasePrep: evt	"Transparent paint, square brush.  Be careful not to let this be undone by asking palette for brush and color."	| size pfPen myBrush |	pfPen _ self paintingFormPen.	size _ (palette getNib) width.	self brush: (myBrush _ Form extent: size@size depth: 1).	myBrush offset: (0@0) - (myBrush extent // 2).	myBrush fillWithColor: Color black.	pfPen sourceForm: myBrush.	"transparent"	pfPen combinationRule: Form erase1bitShape.	pfPen color: Color black.! !!TSketchEditorMorph methodsFor: 'painting' stamp: 'ar 6/19/2003 23:21'!fill: evt 	"Find the area that is the same color as where you clicked. Fill it with 	the current paint color."	| box |	evt isMouseUp		ifFalse: [^ self].	palette recentColor: palette getColor.	"Only fill upon mouseUp"	"would like to only invalidate the area changed, but can't find out what it is."	Cursor execute		showWhile: [			box _ paintingForm				floodFill: palette getColor				at: evt cursorPoint - bounds origin.			self invalidRect: (box translateBy: bounds origin)]! !!TSketchEditorMorph methodsFor: 'painting' stamp: 'ar 9/19/2002 15:59'!paint: evt	"While the mouse is down, lay down paint, but only within window bounds.	 11/28/96 sw: no longer stop painting when pen strays out of window; once it comes back in, resume painting rather than waiting for a mouse up"	|  pfPen myBrush lastPoint dirtyRect trail nextPoint |	pfPen _ self paintingFormPen.	myBrush _ palette getNib.	lastPoint _ pfPen location.	dirtyRect _ lastPoint + myBrush offset extent: myBrush extent.	evt isMouseMove 		ifTrue:[trail := evt trail copyWith: evt position]		ifFalse:[trail := Array with: evt position].	1 to: trail size do:[:i|		nextPoint _ (trail at: i) - bounds origin.		pfPen goto: nextPoint.		dirtyRect _ dirtyRect merge: (nextPoint + myBrush offset extent: myBrush extent).		lastPoint _ nextPoint.	].	self invalidRect: (dirtyRect translateBy: bounds origin).! !!TSketchEditorMorph methodsFor: 'painting' stamp: 'ar 8/20/2002 02:22'!prepareToPaint: evt	"Figure out what the current brush, fill, etc is.  Return an action to take every mouseMove.  Set up instance variable and pens.  Prep for normal painting is inlined here.  tk 6/14/97 21:11"	| specialMode pfPen cColor cNib myBrush |	paintingForm ifNil:[		paintingForm _ Form extent: bounds extent depth: 32.	].	"Install the brush, color, (replace mode), and cursor."	specialMode _ palette action. 	cColor  _ palette getColor.	cNib _ palette getNib.	self brush: (myBrush _ cNib).	self paintingFormPen: (pfPen _ Pen newOnForm: paintingForm).	formCanvas _ paintingForm getCanvas.	"remember to change when undo"	formCanvas _ formCanvas		copyOrigin: self topLeft negated		clipRect: (0@0 extent: bounds extent).	specialMode == #paint: ifTrue: [		"get it to one bit depth.  For speed, instead of going through a colorMap every time ."		self brush: (myBrush _ Form extent: myBrush extent depth: 1).		myBrush offset: (0@0) - (myBrush extent // 2).		cNib displayOn: myBrush at: (0@0 - cNib offset).		pfPen sourceForm: myBrush.		pfPen combinationRule: Form paint.		pfPen color: cColor.		cColor isTransparent ifTrue: [			pfPen combinationRule: Form erase1bitShape.			pfPen color: Color black].		^ #paint:].	specialMode == #erase: ifTrue: [		self erasePrep: evt.		^ #erase:].	(self respondsTo: specialMode) 		ifTrue: [^ specialMode]	"fill: areaFill: pickup: (in mouseUp:) 				rect: ellipse: line: polygon: star:"		ifFalse: ["Don't recognise the command"			palette setAction: #paint: evt: evt.	"set it to Paint"			^ self prepareToPaint: evt].! !!TSketchEditorMorph methodsFor: 'painting' stamp: 'ar 6/17/2003 00:05'!repaint: aForm	paintingForm ifNil:[		paintingForm _ Form extent: bounds extent depth: 32.	] ifNotNil:[		paintingForm fillColor: Color transparent.	].	aForm displayOn: paintingForm at: (paintingForm extent - aForm extent // 2).	self changed.! !!TSketchEditorMorph methodsFor: 'painting' stamp: 'ar 8/20/2002 02:11'!undo: evt	"revert to a previous state.  "	| temp poly |	self flag: #bob.		"what is undo in multihand environment?"	undoBuffer ifNil: [^ self beep].	"nothing to go back to"	(poly _ self valueOfProperty: #polygon) ifNotNil:		[poly delete.		self setProperty: #polygon toValue: nil.		^ self].	temp _ paintingForm.	paintingForm _ undoBuffer.	undoBuffer _ temp.		"can get back to what you had by undoing again"	(self paintingFormPen ) setDestForm: paintingForm.	formCanvas _ paintingForm getCanvas.	"used for lines, ovals, etc."	formCanvas _ formCanvas		copyOrigin: self topLeft negated		clipRect: (0@0 extent: bounds extent).	self render: bounds.! !!TSketchEditorMorph methodsFor: 'drawing' stamp: 'ar 8/20/2002 02:01'!drawOn: aCanvas	"Put the painting on the display"	color isTransparent ifFalse: [		aCanvas fillRectangle: bounds color: color	].	paintingForm ifNotNil: [		aCanvas paintImage: paintingForm at: bounds origin]. ! !!TSketchEditorMorph methodsFor: 'drawing' stamp: 'ar 8/20/2002 02:01'!handlesMouseDown: evt	^ true! !!TSketchEditorMorph methodsFor: 'drawing' stamp: 'ar 8/20/2002 02:02'!handlesMouseOver: evt	^true! !!TSketchEditorMorph methodsFor: 'drawing' stamp: 'ar 8/20/2002 02:02'!handlesMouseOverDragging: evt	^true! !!TSketchEditorMorph methodsFor: 'drawing' stamp: 'ar 8/20/2002 02:20'!mouseDown: evt	"Start a new stroke.  Check if any palette setting have changed.  6/11/97 20:30 tk"	| cur pfPen myAction |	self prepareToPaint: evt.	"verify that we are in a good state"	pfPen _ self paintingFormPen.	undoBuffer _ paintingForm deepCopy.	"know we will draw something"	pfPen place: (evt cursorPoint - bounds origin).	myAction _ palette action.	myAction == #paint: ifTrue:[		palette recentColor: palette getColor].		"origin point for pickup: rect: ellispe: polygon: line: star:.  Always take it."	myAction == #pickup: ifTrue: [		cur _ Cursor corner clone.		cur offset: 0@0  "cur offset abs".		evt hand showTemporaryCursor: cur].	myAction == #polygon: ifTrue: [self polyNew: evt].	"a mode lets you drag vertices"	self mouseMove: evt.! !!TSketchEditorMorph methodsFor: 'drawing' stamp: 'ar 8/20/2002 02:40'!mouseEnter: evt	"Set the cursor.  Reread colors if embedded editable polygon needs it."	| poly cColor |	super mouseEnter: evt.	"evt hand showTemporaryCursor: palette plainCursor."	palette getSpecial == #polygon: ifFalse: [^self].	(poly _ self valueOfProperty: #polygon) ifNil: [^ self].	cColor _ palette getColor.	poly color: cColor; borderWidth: 1.	poly changed.! !!TSketchEditorMorph methodsFor: 'drawing' stamp: 'ar 8/20/2002 02:01'!mouseEnterDragging: evt	"Test button state elsewhere if at all"	^ self mouseEnter: evt! !!TSketchEditorMorph methodsFor: 'drawing' stamp: 'ar 8/20/2002 02:01'!mouseLeave: evt	"Revert to the normal hand cursor."	super mouseLeave: evt.	evt hand showTemporaryCursor: nil.  "back to normal"	"If this is modified to close down the SketchEditorMorph in any way, watch out for how it is called when entering a rotationButton and a scaleButton."! !!TSketchEditorMorph methodsFor: 'drawing' stamp: 'ar 8/20/2002 02:02'!mouseLeaveDragging: evt	"Test button state elsewhere if at all"	^ self mouseLeave: evt! !!TSketchEditorMorph methodsFor: 'drawing' stamp: 'ar 8/20/2002 02:15'!mouseMove: evt	"In the middle of drawing a stroke.  6/11/97 19:51 tk"	| pt priorEvt |	WorldState canSurrenderToOS: false.		"we want maximum responsiveness"	pt _ evt cursorPoint.	priorEvt _ self lastEvent.	(priorEvt ~~ nil and: [pt = priorEvt cursorPoint]) ifTrue: [^ self].	self perform: (palette action) with: evt.		"Each action must do invalidRect:"	self lastEvent: evt.	false ifTrue: ["So senders will find the things performed here"		self paint: nil; fill: nil; erase: nil; pickup: nil; stamp: nil.		self rect: nil; ellipse: nil; polygon: nil; line: nil; star: nil].! !!TSketchEditorMorph methodsFor: 'drawing' stamp: 'ar 8/20/2002 02:18'!mouseUp: evt	| myAction |	"Do nothing except those that work on mouseUp."	myAction _ palette action.	myAction == #fill: ifTrue: [		self perform: myAction with: evt.		"Each action must do invalidRect:"		].	myAction == #pickup: ifTrue: [		self pickupMouseUp: evt].	myAction == #polygon: ifTrue: [self polyEdit: evt].	"a mode lets you drag vertices"	self lastEvent: nil.! !!TSkyBox methodsFor: 'initialize' stamp: 'ar 9/30/2004 13:10'!initializeWithFileName: fname	|  txtr mat scale shrink sc dy |	sc _ 10.	scale _128 * sc.	dy _ 0.	shrink _ 8 * sc.	mat _ TMaterial new.	mat fullBright: true.	mat ambientColor: #(1.0 1.0 1.0 1.0)asFloatArray.	mat diffuseColor: #(1.0 1.0 1.0 1.0)asFloatArray.	mat emissiveColor: #(1.0 1.0 1.0 1.0)asFloatArray.	txtr _ TTexture				new initializeWithFileName: 'SkyBox', fname, 'BK.bmp'				mipmap: false				shrinkFit: false.	txtr extent: scale@scale.	txtr translationX: 0.0 y:dy z: (scale-shrink) negated/2.0.	txtr material: mat.	txtr materialAlpha: nil.	self addChild: txtr.	txtr _ TTexture				new initializeWithFileName: 'SkyBox', fname, 'LF.bmp'				mipmap: false				shrinkFit: false.	txtr extent: scale@scale.	txtr rotationAroundY: 90.	txtr translationX: (scale-shrink)/2.0 negated y:dy z: 0.0.	txtr material: mat.	txtr materialAlpha: nil.	self addChild: txtr.	txtr _ TTexture				new initializeWithFileName: 'SkyBox', fname, 'RT.bmp'				mipmap: false				shrinkFit: false.	txtr extent: scale@scale.	txtr rotationAroundY: -90.	txtr translationX: (scale-shrink)/2.0 y:dy z: 0.0.	txtr material: mat.	txtr materialAlpha: nil.	self addChild: txtr.	txtr _ TTexture				new initializeWithFileName: 'SkyBox', fname, 'FR.bmp'				mipmap: false				shrinkFit: false.	txtr extent: scale@scale.	txtr rotationAroundY: 180.	txtr translationX: 0.0 y:dy z: (scale-shrink)/2.	txtr material: mat.	txtr materialAlpha: nil.	self addChild: txtr.	txtr _ TTexture				new initializeWithFileName: 'SkyBox', fname, 'UP.bmp'				mipmap: false				shrinkFit: false.	txtr extent: scale@scale.	txtr rotationAroundX: 90.	txtr translationX: 0.0 y: ((scale-shrink)/2) + (dy)z: 0.0.	txtr material: mat.	txtr materialAlpha: nil.	self addChild: txtr.	self solidTree: false.	dalpha _ 0.02.	^self! !!TSkyBox methodsFor: 'testing'!isComponent	^ true.! !!TSkyBox methodsFor: 'stepping' stamp: 'DPR 9/7/2002 15:55'!stepAt: msecs	"rotation is dalpha units per 20 milliseconds, and we assume start at zero clock time" 	self rotationAroundY: (msecs asFloat/20.0) * dalpha.! !!TSkyBox methodsFor: 'stepping'!wantsSteps	^  true.! !!TSnapshot methodsFor: 'render' stamp: 'das 10/1/2002 17:06'!drawOn: aCanvas	self framesToDwell > 0 ifTrue:[		thumbnail ifNotNil:[ super drawOn: aCanvas.].]. ! !!TSnapshot methodsFor: 'render' stamp: 'ar 10/1/2004 13:46'!glRenderOn: ogl	| trans bnds size max scale width height form sketchForm camera |	self isInWorld ifFalse:[^self].	camera _ TCamera new initializeWithViewPort: ogl viewport.	camera viewAngle: 45. 	camera inPortal: true. "don't bother checking height and stuff."	thumbnail ifNil:[		bnds _ (0@0 corner: 128@96).		camera bounds: bnds.		trans _ globalTransform copy.		camera localTransform: trans.		thumbnail _ root snapShot: ogl camera: camera. 		size _ owner owner largeExtent.		max _ thumbnail width max: thumbnail height.		scale _ size x / max.		width _ (thumbnail width * scale) truncated.		height _ (thumbnail height * scale) truncated.		form _ Form extent: width@height depth: 16.		thumbnail displayScaledOn: form.		sketchForm _ Form extent: size depth: form depth.		form displayOn: sketchForm at: sketchForm extent - form extent // (2@1) rule: Form paint.		"self drawName: item name on: sketchForm."		self form: sketchForm.		^  self.].	self framesToDwell = 0 ifTrue:[self changed.].	self framesToDwell <= 0 ifTrue:[		bnds _self bounds.		bnds _ (self bounds topLeft - ogl viewport topLeft + (0@32)) corner: (self bounds bottomRight - ogl viewport topLeft).		camera bounds: bnds.		trans _ globalTransform copy.		camera localTransform: trans.		root clearRender: ogl camera: camera.	].! !!TSnapshot methodsFor: 'accessor' stamp: 'das 10/3/2002 10:16'!globalMatrixOut	^ globalTransform.! !!TSnapshot methodsFor: 'accessor' stamp: 'das 10/3/2002 10:13'!globalTransform	^ globalTransform.! !!TSnapshot methodsFor: 'accessor' stamp: 'das 9/27/2002 01:06'!location	^ tLocation.! !!TSnapshot methodsFor: 'accessor' stamp: 'das 9/27/2002 02:21'!name	^ self location urlString. "This is the URL to the associated root TSpace."! !!TSnapshot methodsFor: 'accessor' stamp: 'das 10/2/2002 21:56'!root	^ root.! !!TSnapshot methodsFor: 'accessor' stamp: 'das 9/27/2002 01:06'!thumbnail		^ thumbnail.! !!TSnapshot methodsFor: 'accessor' stamp: 'das 9/27/2002 01:07'!time	^ tTime.! !!TSnapshot methodsFor: 'accessor' stamp: 'das 9/27/2002 07:45'!url	^ self location urlString. "This is the URL to the associated root TSpace."! !!TSnapshot methodsFor: 'initialize' stamp: 'ar 10/1/2004 13:29'!initializeWithFrame: frm	frame _ frm.	root _ frame root.	frame isPortal ifTrue:[		globalTransform _ frame globalMatrixOut.]	ifFalse:[		globalTransform _ frame globalTransform.].	tTime _ TeaTime now.	tLocation _ frame root locator.	CroquetGlobals snapshots add: self.! !!TSnapshot methodsFor: 'initialize' stamp: 'ar 10/1/2004 13:11'!initializeWithFrame: frm transform: trans	self initializeWithFrame: frm.	globalTransform _ trans.! !!TSnapshot methodsFor: 'testing' stamp: 'DPR 5/12/2003 21:46'!isCamera	^ false.! !!TSnapshot methodsFor: 'testing' stamp: 'das 10/3/2002 10:16'!isPortal	^ false.! !!TSnapshot methodsFor: 'testing' stamp: 'das 8/27/2004 08:11'!isSpace	^ false.! !!TSnapshot methodsFor: 'dropping/grabbing' stamp: 'tak 5/21/2004 11:28'!dragToSpace	ActiveHand grabMorph: self clone! !!TSocket methodsFor: 'connection open/close' stamp: 'ar 2/7/2004 02:11'!accept	"Accept a connection from the receiver socket.	Return a new socket that is connected to the client"	^TSocket acceptFrom: self.! !!TSocket methodsFor: 'connection open/close' stamp: 'ar 2/7/2004 02:08'!close	"Close this connection gracefully. For TCP, this sends a close request, but the stream remains open until the other side also closes it."	self primSocketCloseConnection: socketHandle.  "close this end"! !!TSocket methodsFor: 'connection open/close' stamp: 'ar 2/7/2004 02:08'!closeAndDestroy	"First, try to close this connection gracefully. If the close attempt fails or times out, abort the connection. In either case, destroy the socket. Do nothing if the socket has already been destroyed (i.e., if its socketHandle is nil)."	self closeAndDestroy: 20.! !!TSocket methodsFor: 'connection open/close' stamp: 'ar 2/7/2004 02:11'!closeAndDestroy: timeoutSeconds	"First, try to close this connection gracefully. If the close attempt fails or times out, abort the connection. In either case, destroy the socket. Do nothing if the socket has already been destroyed (i.e., if its socketHandle is nil)."	socketHandle = nil		ifFalse: [			self isConnected ifTrue: [				self close.  "close this end"				(self waitForDisconnectionUntil: (TSocket deadlineSecs: timeoutSeconds))					ifFalse: [						"if the other end doesn't close soon, just abort the connection"						self primSocketAbortConnection: socketHandle]].			self destroy].! !!TSocket methodsFor: 'connection open/close' stamp: 'ar 2/7/2004 02:08'!connectTo: hostAddress port: port	"Initiate a connection to the given port at the given host address. This operation will return immediately; follow it with waitForConnectionUntil: to wait until the connection is established."	| status |	status _ self primSocketConnectionStatus: socketHandle.	(status == Unconnected)		ifFalse: [self error: 'Socket status must Unconnected before opening a new connection'].	self primSocket: socketHandle connectTo: hostAddress port: port.! !!TSocket methodsFor: 'connection open/close' stamp: 'ar 2/7/2004 02:08'!disconnect	"Break this connection, no matter what state it is in. Data that has been sent but not received will be lost."	self primSocketAbortConnection: socketHandle.! !!TSocket methodsFor: 'connection open/close' stamp: 'ar 2/7/2004 02:08'!listenOn: port	"Listen for a connection on the given port. This operation will return immediately; follow it with waitForConnectionUntil: to wait until a connection is established."	| status |	status _ self primSocketConnectionStatus: socketHandle.	(status == Unconnected)		ifFalse: [self error: 'Socket status must Unconnected before listening for a new connection'].	self primSocket: socketHandle listenOn: port.! !!TSocket methodsFor: 'connection open/close' stamp: 'ar 2/7/2004 02:08'!listenOn: portNumber backlogSize: backlog	"Listen for a connection on the given port.	If this method succeeds, #accept may be used to establish a new connection"	| status |	status _ self primSocketConnectionStatus: socketHandle.	(status == Unconnected)		ifFalse: [self error: 'Socket status must Unconnected before listening for a new connection'].	self primSocket: socketHandle listenOn: portNumber backlogSize: backlog.! !!TSocket methodsFor: 'initialize-destroy' stamp: 'ar 2/7/2004 02:08'!acceptFrom: aSocket	"Initialize a new socket handle from an accept call"	| semaIndex readSemaIndex writeSemaIndex |	primitiveOnlySupportsOneSemaphore _ false.	semaphore _ Semaphore new.	readSemaphore _ Semaphore new.	writeSemaphore _ Semaphore new.	semaIndex _ Smalltalk registerExternalObject: semaphore.	readSemaIndex _ Smalltalk registerExternalObject: readSemaphore.	writeSemaIndex _ Smalltalk registerExternalObject: writeSemaphore.	socketHandle _ self primAcceptFrom: aSocket socketHandle						receiveBufferSize: 8000						sendBufSize: 8000						semaIndex: semaIndex						readSemaIndex: readSemaIndex						writeSemaIndex: writeSemaIndex.	socketHandle = nil ifTrue: [  "socket creation failed"		Smalltalk unregisterExternalObject: semaphore.		Smalltalk unregisterExternalObject: readSemaphore.		Smalltalk unregisterExternalObject: writeSemaphore.		readSemaphore _ writeSemaphore _ semaphore _ nil	] ifFalse:[self register].! !!TSocket methodsFor: 'initialize-destroy' stamp: 'ar 2/7/2004 02:08'!destroy	"Destroy this socket. Its connection, if any, is aborted and its resources are freed. Do nothing if the socket has already been destroyed (i.e., if its socketHandle is nil)."	socketHandle = nil ifFalse: 		[self isValid ifTrue: [self primSocketDestroy: socketHandle].		signalDispatcher ifNotNil: [			signalDispatcher terminate.			signalDispatcher _ nil.		].		Smalltalk unregisterExternalObject: semaphore.		Smalltalk unregisterExternalObject: readSemaphore.		Smalltalk unregisterExternalObject: writeSemaphore.		socketHandle _ nil.		readSemaphore _ writeSemaphore _ semaphore _ nil.		self unregister].! !!TSocket methodsFor: 'initialize-destroy' stamp: 'ar 2/7/2004 02:08'!initialize: socketType	"Initialize a new socket handle. If socket creation fails, socketHandle will be set to nil."	| semaIndex readSemaIndex writeSemaIndex |	primitiveOnlySupportsOneSemaphore _ false.	semaphore _ Semaphore new.	readSemaphore _ Semaphore new.	writeSemaphore _ Semaphore new.	semaIndex _ Smalltalk registerExternalObject: semaphore.	readSemaIndex _ Smalltalk registerExternalObject: readSemaphore.	writeSemaIndex _ Smalltalk registerExternalObject: writeSemaphore.	socketHandle _		self primSocketCreateNetwork: 0			type: socketType			receiveBufferSize: 8000			sendBufSize: 8000			semaIndex: semaIndex			readSemaIndex: readSemaIndex			writeSemaIndex: writeSemaIndex.	socketHandle = nil ifTrue: [  "socket creation failed"		Smalltalk unregisterExternalObject: semaphore.		Smalltalk unregisterExternalObject: readSemaphore.		Smalltalk unregisterExternalObject: writeSemaphore.		readSemaphore _ writeSemaphore _ semaphore _ nil	] ifFalse:[self register].! !!TSocket methodsFor: 'accessing' stamp: 'ar 2/7/2004 02:08'!address	"Shortcut"	^self localAddress! !!TSocket methodsFor: 'accessing' stamp: 'ar 2/7/2004 02:11'!localAddress	self waitForConnectionUntil: TSocket standardDeadline.	self isConnected ifFalse: [^ByteArray new: 4].	^ self primSocketLocalAddress: socketHandle! !!TSocket methodsFor: 'accessing' stamp: 'ar 2/7/2004 02:11'!localPort	self waitForConnectionUntil: TSocket standardDeadline.	self isConnected ifFalse: [^0 ].	^ self primSocketLocalPort: socketHandle! !!TSocket methodsFor: 'accessing' stamp: 'ar 2/7/2004 02:08'!peerName	"Return the name of the host I'm connected to, or nil if its name isn't known to the domain name server or the request times out."	"Note: Slow. Calls the domain name server, taking up to 20 seconds to time out. Even when sucessful, delays of up to 13 seconds have been observed during periods of high network load." 	^ NetNameResolver		nameForAddress: self remoteAddress		timeout: 20! !!TSocket methodsFor: 'accessing' stamp: 'ar 2/7/2004 02:08'!port	"Shortcut"	^self localPort! !!TSocket methodsFor: 'accessing' stamp: 'ar 2/7/2004 02:08'!primitiveOnlySupportsOneSemaphore	^primitiveOnlySupportsOneSemaphore! !!TSocket methodsFor: 'accessing' stamp: 'ar 2/7/2004 02:08'!readSemaphore	"primitiveOnlySupportsOneSemaphore ifTrue: [^semaphore]."	^readSemaphore! !!TSocket methodsFor: 'accessing' stamp: 'ar 2/7/2004 02:08'!remoteAddress	^ self primSocketRemoteAddress: socketHandle! !!TSocket methodsFor: 'accessing' stamp: 'ar 2/7/2004 02:08'!remotePort	^ self primSocketRemotePort: socketHandle! !!TSocket methodsFor: 'accessing' stamp: 'ar 2/7/2004 02:08'!socketHandle	^socketHandle! !!TSocket methodsFor: 'accessing' stamp: 'ar 2/7/2004 02:08'!writeSemaphore	"primitiveOnlySupportsOneSemaphore ifTrue: 		[^Delay forMilliseconds: 5]."	^writeSemaphore! !!TSocket methodsFor: 'queries' stamp: 'ar 2/7/2004 02:08'!dataAvailable	"Return true if this socket has unread received data."	socketHandle == nil ifTrue: [^ false].	^ self primSocketReceiveDataAvailable: socketHandle! !!TSocket methodsFor: 'queries' stamp: 'ar 2/7/2004 02:08'!isConnected	"Return true if this socket is connected."	socketHandle == nil ifTrue: [^ false].	^ (self primSocketConnectionStatus: socketHandle) == Connected! !!TSocket methodsFor: 'queries' stamp: 'ar 2/7/2004 02:08'!isOtherEndClosed	"Return true if this socket had the other end closed."	socketHandle == nil ifTrue: [^ false].	^ (self primSocketConnectionStatus: socketHandle) == OtherEndClosed! !!TSocket methodsFor: 'queries' stamp: 'ar 2/7/2004 02:08'!isThisEndClosed	"Return true if this socket had the this end closed."	socketHandle == nil ifTrue: [^ false].	^ (self primSocketConnectionStatus: socketHandle) == ThisEndClosed! !!TSocket methodsFor: 'queries' stamp: 'ar 2/7/2004 02:08'!isUnconnected	"Return true if this socket's state is Unconnected."	socketHandle == nil ifTrue: [^ false].	^ (self primSocketConnectionStatus: socketHandle) == Unconnected! !!TSocket methodsFor: 'queries' stamp: 'ar 2/7/2004 02:08'!isUnconnectedOrInvalid	"Return true if this socket is completely disconnected or is invalid."	| status |	socketHandle == nil ifTrue: [^ true].	status _ self primSocketConnectionStatus: socketHandle.	^ (status = Unconnected) | (status = InvalidSocket)! !!TSocket methodsFor: 'queries' stamp: 'ar 2/7/2004 02:08'!isValid	"Return true if this socket contains a valid, non-nil socket handle."	| status |	socketHandle == nil ifTrue: [^ false].	status _ self primSocketConnectionStatus: socketHandle.	^ status ~= InvalidSocket! !!TSocket methodsFor: 'queries' stamp: 'ar 2/7/2004 02:08'!isWaitingForConnection	"Return true if this socket is waiting for a connection."	socketHandle == nil ifTrue: [^ false].	^ (self primSocketConnectionStatus: socketHandle) == WaitingForConnection! !!TSocket methodsFor: 'queries' stamp: 'ar 2/7/2004 02:08'!sendDone	"Return true if the most recent send operation on this socket has completed."	socketHandle == nil ifTrue: [^ false].	^ self primSocketSendDone: socketHandle! !!TSocket methodsFor: 'queries' stamp: 'ar 2/7/2004 02:08'!socketError	^self primSocketError: socketHandle! !!TSocket methodsFor: 'queries' stamp: 'ar 2/7/2004 02:08'!statusString	"Return a string describing the status of this socket."	| status |	socketHandle == nil ifTrue: [^ 'destroyed'].	status _ self primSocketConnectionStatus: socketHandle.	status = InvalidSocket ifTrue: [^ 'invalidSocketHandle'].	status = Unconnected ifTrue: [^ 'unconnected'].	status = WaitingForConnection ifTrue: [^ 'waitingForConnection'].	status = Connected ifTrue: [^ 'connected'].	status = OtherEndClosed ifTrue: [^ 'otherEndClosedButNotThisEnd'].	status = ThisEndClosed ifTrue: [^ 'thisEndClosedButNotOtherEnd'].	^ 'unknown socket status'! !!TSocket methodsFor: 'sending-receiving' stamp: 'ar 2/7/2004 02:08'!discardReceivedData	"Discard any data received up until now, and return the number of bytes discarded."	| buf totalBytesDiscarded |	buf _ String new: 10000.	totalBytesDiscarded _ 0.	[self isConnected and: [self dataAvailable]] whileTrue: [		totalBytesDiscarded _			totalBytesDiscarded + (self receiveDataInto: buf)].	^ totalBytesDiscarded! !!TSocket methodsFor: 'sending-receiving' stamp: 'ar 2/7/2004 02:11'!getData	"Get some data"	| buf bytesRead |	(self waitForDataUntil: TSocket standardDeadline) ifFalse: [self error: 'getData timeout'].	buf _ String new: 4000.	bytesRead _ self primSocket: socketHandle receiveDataInto: buf startingAt: 1 count: buf size.	^ buf copyFrom: 1 to: bytesRead! !!TSocket methodsFor: 'sending-receiving' stamp: 'ar 2/7/2004 02:11'!readInto: aStringOrByteArray startingAt: aNumber	"Read data into the given buffer starting at the given index and return the number of bytes received. Note the given buffer may be only partially filled by the received data."	(self waitForDataUntil: TSocket standardDeadline) ifFalse: [self error: 'receive timeout'].	^ self primSocket: socketHandle		receiveDataInto: aStringOrByteArray		startingAt: aNumber		count: aStringOrByteArray size - aNumber + 1! !!TSocket methodsFor: 'sending-receiving' stamp: 'ar 2/7/2004 02:08'!receiveDataInto: aStringOrByteArray	"Receive data into the given buffer and return the number of bytes received. Note the given buffer may be only partially filled by the received data."	^ self primSocket: socketHandle		receiveDataInto: aStringOrByteArray		startingAt: 1		count: aStringOrByteArray size! !!TSocket methodsFor: 'sending-receiving' stamp: 'ar 2/7/2004 02:08'!semaphore	primitiveOnlySupportsOneSemaphore ifTrue: [^connectSemaphore].	^semaphore! !!TSocket methodsFor: 'sending-receiving' stamp: 'ar 2/7/2004 02:11'!sendData: aStringOrByteArray	"Send all of the data in the given array, even if it requires multiple calls to send it all. Return the number of bytes sent."	"An experimental version use on slow lines: Longer timeout and smaller writes to try to avoid spurious timeouts."	| bytesSent bytesToSend count |	bytesToSend _ aStringOrByteArray size.	bytesSent _ 0.	bytesToSend = 0 ifTrue: [^0].	[ count _ self primSocket: socketHandle						sendData: aStringOrByteArray						startIndex: bytesSent + 1						count: (bytesToSend - bytesSent min: 5000).						bytesSent _ bytesSent + count.	  bytesSent < bytesToSend]		whileTrue: [			(self waitForSendDoneUntil: (TSocket deadlineSecs: 60))				ifFalse: [self error: 'send data timeout; data not sent'].			].	^ bytesSent! !!TSocket methodsFor: 'sending-receiving' stamp: 'ar 2/7/2004 02:08'!sendData: buffer count: n	"Send the amount of data from the given buffer"	| sent |	sent _ 0.	[sent < n] whileTrue:[		sent _ sent + (self sendSomeData: buffer startIndex: sent+1 count: (n-sent))].! !!TSocket methodsFor: 'sending-receiving' stamp: 'ar 2/7/2004 02:08'!sendSomeData: aStringOrByteArray	"Send as much of the given data as possible and answer the number of bytes actually sent."	"Note: This operation may have to be repeated multiple times to send a large amount of data."	^ self		sendSomeData: aStringOrByteArray		startIndex: 1		count: aStringOrByteArray size! !!TSocket methodsFor: 'sending-receiving' stamp: 'ar 2/7/2004 02:08'!sendSomeData: aStringOrByteArray startIndex: startIndex	"Send as much of the given data as possible starting at the given index. Answer the number of bytes actually sent."	"Note: This operation may have to be repeated multiple times to send a large amount of data."	^ self		sendSomeData: aStringOrByteArray		startIndex: startIndex		count: (aStringOrByteArray size - startIndex + 1)! !!TSocket methodsFor: 'sending-receiving' stamp: 'ar 2/7/2004 02:11'!sendSomeData: aStringOrByteArray startIndex: startIndex count: count	"Send up to count bytes of the given data starting at the given index. Answer the number of bytes actually sent."	"Note: This operation may have to be repeated multiple times to send a large amount of data."	| bytesSent |	"try sending without waiting first"	bytesSent _ self primSocket: socketHandle				sendData: aStringOrByteArray				startIndex: startIndex				count: count.     bytesSent= 0 ifTrue: [		(self waitForSendDoneUntil: (TSocket deadlineSecs: 20))			ifTrue: [				bytesSent _ self primSocket: socketHandle					sendData: aStringOrByteArray					startIndex: startIndex					count: count]			ifFalse: [self error: 'send data timeout; data not sent'].].	^ bytesSent! !!TSocket methodsFor: 'emulate semaphores' stamp: 'ar 2/7/2004 02:08'!emulateAcceptFrom: aHandle receiveBufferSize: rcvBufSize sendBufSize: sndBufSize semaIndex: semaIndex readSemaIndex: aReadSema writeSemaIndex: aWriteSema	| rVal |	rVal _ self primAcceptFrom: aHandle receiveBufferSize: rcvBufSize sendBufSize: sndBufSize semaIndex: semaIndex.	rVal ifNil: [^nil].	self runSignalDispatcher. "sets up a process to simulate the 3 semaphores"	^rVal! !!TSocket methodsFor: 'emulate semaphores' stamp: 'ar 2/7/2004 02:08'!emulateSocketCreateNetwork: netType type: socketType receiveBufferSize: rcvBufSize sendBufSize: sendBufSize semaIndex: semaIndex readSemaIndex: aReadSema writeSemaIndex: aWriteSema	"See comment in primSocketCreateNetwork: with one semaIndex. However you should know that some implementations	ignore the buffer size and this interface supports three semaphores,  one for open/close/listen and the other two for	reading and writing"	| rVal |	rVal _ self primSocketCreateNetwork: netType			type: socketType			receiveBufferSize: rcvBufSize			sendBufSize: sendBufSize			semaIndex: semaIndex.	rVal ifNil: [^nil].	self runSignalDispatcher. "sets up a process to simulate the 3 semaphores"	^rVal! !!TSocket methodsFor: 'emulate semaphores' stamp: 'ar 2/7/2004 02:08'!runSignalDispatcher	"sets up a process to simulate the 3 semaphores"	signalDispatcher ifNotNil: [^self].	connectSemaphore _ Semaphore new..	signalDispatcher _ [ 		[semaphore wait.			" signal all waiters, because we don't know which one is waiting"			" could be more efficient, because each waiter gets excess signals"			readSemaphore signal.			writeSemaphore signal.			connectSemaphore signal.		] repeat.	] newProcess.	signalDispatcher priority: Processor lowIOPriority.	signalDispatcher resume.! !!TSocket methodsFor: 'finalization' stamp: 'ar 2/7/2004 02:08'!finalize	self primSocketDestroyGently: socketHandle.	signalDispatcher ifNotNil: [		signalDispatcher terminate.		signalDispatcher _ nil.	].	Smalltalk unregisterExternalObject: semaphore.	Smalltalk unregisterExternalObject: readSemaphore.	Smalltalk unregisterExternalObject: writeSemaphore.! !!TSocket methodsFor: 'other' stamp: 'ar 2/7/2004 02:08'!getOption: aName 	"Get options on this socket, see Unix man pages for values for 	sockets, IP, TCP, UDP. IE SO_KEEPALIVE	returns an array, element one is an status number (0 ok, -1 read only option)	element two is the resulting of the requested option"	(socketHandle == nil or: [self isValid not])		ifTrue: [self error: 'Socket status must valid before getting an option'].	^self primSocket: socketHandle getOption: aName"| foo options |Socket initializeNetwork.foo _ Socket newTCP.foo connectTo: (NetNameResolver addressFromString: '192.168.1.1') port: 80.foo waitForConnectionUntil: (Socket standardDeadline).options _ {'SO_DEBUG'. 'SO_REUSEADDR'. 'SO_REUSEPORT'. 'SO_DONTROUTE'.'SO_BROADCAST'. 'SO_SNDBUF'. 'SO_RCVBUF'. 'SO_KEEPALIVE'.'SO_OOBINLINE'. 'SO_PRIORITY'. 'SO_LINGER'. 'SO_RCVLOWAT'.'SO_SNDLOWAT'. 'IP_TTL'. 'IP_HDRINCL'. 'IP_RCVOPTS'.'IP_RCVDSTADDR'. 'IP_MULTICAST_IF'. 'IP_MULTICAST_TTL'.'IP_MULTICAST_LOOP'. 'UDP_CHECKSUM'. 'TCP_MAXSEG'.'TCP_NODELAY'. 'TCP_ABORT_THRESHOLD'. 'TCP_CONN_NOTIFY_THRESHOLD'. 'TCP_CONN_ABORT_THRESHOLD'. 'TCP_NOTIFY_THRESHOLD'.'TCP_URGENT_PTR_TYPE'}.1 to: options size do: [:i | | fum |	fum _foo getOption: (options at: i).	Transcript show: (options at: i),fum printString;cr].foo _ Socket newUDP.foo setPeer: (NetNameResolver addressFromString: '192.168.1.9') port: 7.foo waitForConnectionUntil: (Socket standardDeadline).1 to: options size do: [:i | | fum |	fum _foo getOption: (options at: i).	Transcript show: (options at: i),fum printString;cr]."! !!TSocket methodsFor: 'other' stamp: 'ar 2/7/2004 02:11'!getResponseNoLF	"Get the response to the last command."	| buf response bytesRead c lf |	(self waitForDataUntil: (TSocket deadlineSecs: 20)) ifFalse: [		self error: 'getResponse timeout'].	lf _ Character lf.	buf _ String new: 1000.	response _ WriteStream on: ''.	[self dataAvailable] whileTrue: [		bytesRead _ self primSocket: socketHandle receiveDataInto: buf startingAt: 1 count: buf size.		1 to: bytesRead do: [ :i |			(c _ buf at: i) ~= lf ifTrue: [response nextPut: c]]].	^ response contents! !!TSocket methodsFor: 'other' stamp: 'ar 2/7/2004 02:08'!setOption: aName value: aValue 	| value |	"setup options on this socket, see Unix man pages for values for 	sockets, IP, TCP, UDP. IE SO_KEEPALIVE	returns an array, element one is the error number	element two is the resulting of the negotiated value.	See getOption for list of keys"	(socketHandle == nil or: [self isValid not])		ifTrue: [self error: 'Socket status must valid before setting an option'].	value _ aValue asString.	aValue == true ifTrue: [value _ '1'].	aValue == false ifTrue: [value _ '0'].	^ self primSocket: socketHandle setOption: aName value: value! !!TSocket methodsFor: 'primitives' stamp: 'ar 2/7/2004 02:08'!primAcceptFrom: aHandle receiveBufferSize: rcvBufSize sendBufSize: sndBufSize semaIndex: semaIndex	"Create and return a new socket handle based on accepting the connection from the given listening socket"	<primitive: 'primitiveSocketAccept' module: 'SocketPlugin'>	^self primitiveFailed! !!TSocket methodsFor: 'primitives' stamp: 'ar 2/7/2004 02:08'!primAcceptFrom: aHandle receiveBufferSize: rcvBufSize sendBufSize: sndBufSize semaIndex: semaIndex readSemaIndex: aReadSema writeSemaIndex: aWriteSema	"Create and return a new socket handle based on accepting the connection from the given listening socket"	<primitive: 'primitiveSocketAccept3Semaphores' module: 'SocketPlugin'>	primitiveOnlySupportsOneSemaphore _ true.	^self emulateAcceptFrom: aHandle receiveBufferSize: rcvBufSize sendBufSize: sndBufSize semaIndex: semaIndex readSemaIndex: aReadSema writeSemaIndex: aWriteSema! !!TSocket methodsFor: 'primitives' stamp: 'ar 2/7/2004 02:08'!primSocket: socketID connectTo: hostAddress port: port	"Attempt to establish a connection to the given port of the given host. This is an asynchronous call; query the socket status to discover if and when the connection is actually completed."	<primitive: 'primitiveSocketConnectToPort' module: 'SocketPlugin'>	self primitiveFailed! !!TSocket methodsFor: 'primitives' stamp: 'ar 2/7/2004 02:08'!primSocket: socketID getOption: aString 	"Get some option information on this socket. Refer to the UNIX 	man pages for valid SO, TCP, IP, UDP options. In case of doubt	refer to the source code.	TCP_NODELAY, SO_KEEPALIVE are valid options for example	returns an array containing the error code and the option value"	<primitive: 'primitiveSocketGetOptions' module: 'SocketPlugin'>	self primitiveFailed! !!TSocket methodsFor: 'primitives' stamp: 'ar 2/7/2004 02:08'!primSocket: socketID listenOn: port	"Listen for a connection on the given port. This is an asynchronous call; query the socket status to discover if and when the connection is actually completed."	<primitive: 'primitiveSocketListenWithOrWithoutBacklog' module: 'SocketPlugin'>	self primitiveFailed! !!TSocket methodsFor: 'primitives' stamp: 'ar 2/7/2004 02:08'!primSocket: aHandle listenOn: portNumber backlogSize: backlog	"Primitive. Set up the socket to listen on the given port.	Will be used in conjunction with #accept only."	<primitive: 'primitiveSocketListenWithOrWithoutBacklog' module: 'SocketPlugin'>	self destroy. "Accept not supported so clean up"! !!TSocket methodsFor: 'primitives' stamp: 'ar 2/7/2004 02:08'!primSocket: socketID receiveDataInto: aStringOrByteArray startingAt: startIndex count: count	"Receive data from the given socket into the given array starting at the given index. Return the number of bytes read or zero if no data is available."	<primitive: 'primitiveSocketReceiveDataBufCount' module: 'SocketPlugin'>	self primitiveFailed! !!TSocket methodsFor: 'primitives' stamp: 'ar 2/7/2004 02:08'!primSocket: socketID receiveUDPDataInto: aStringOrByteArray startingAt: startIndex count: count	"Receive data from the given socket into the given array starting at the given index. 	Return an Array containing the amount read, the host address byte array, the host port, and the more flag"	<primitive: 'primitiveSocketReceiveUDPDataBufCount' module: 'SocketPlugin'>	self primitiveFailed! !!TSocket methodsFor: 'primitives' stamp: 'ar 2/7/2004 02:08'!primSocket: socketID sendData: aStringOrByteArray startIndex: startIndex count: count	"Send data to the remote host through the given socket starting with the given byte index of the given byte array. The data sent is 'pushed' immediately. Return the number of bytes of data actually sent; any remaining data should be re-submitted for sending after the current send operation has completed."	"Note: In general, it many take several sendData calls to transmit a large data array since the data is sent in send-buffer-sized chunks. The size of the send buffer is determined when the socket is created."	<primitive: 'primitiveSocketSendDataBufCount' module: 'SocketPlugin'>	self primitiveFailed! !!TSocket methodsFor: 'primitives' stamp: 'ar 2/7/2004 02:08'!primSocket: socketID sendUDPData: aStringOrByteArray toHost: hostAddress  port: portNumber startIndex: startIndex count: count	"Send data to the remote host through the given socket starting with the given byte index of the given byte array. The data sent is 'pushed' immediately. Return the number of bytes of data actually sent; any remaining data should be re-submitted for sending after the current send operation has completed."	"Note: In general, it many take several sendData calls to transmit a large data array since the data is sent in send-buffer-sized chunks. The size of the send buffer is determined when the socket is created."	<primitive:  'primitiveSocketSendUDPDataBufCount' module: 'SocketPlugin'>	self primitiveFailed! !!TSocket methodsFor: 'primitives' stamp: 'ar 2/7/2004 02:08'!primSocket: socketID setOption: aString value: aStringValue	"Set some option information on this socket. Refer to the UNIX 	man pages for valid SO, TCP, IP, UDP options. In case of doubt	refer to the source code.	TCP_NODELAY, SO_KEEPALIVE are valid options for example	returns an array containing the error code and the negotiated value"	<primitive: 'primitiveSocketSetOptions' module: 'SocketPlugin'>	^nil! !!TSocket methodsFor: 'primitives' stamp: 'ar 2/7/2004 02:08'!primSocket: socketID setPort: port	"Set the local port associated with a UDP socket.	Note: this primitive is overloaded.  The primitive will not fail on a TCP socket, but	the effects will not be what was desired.  Best solution would be to split Socket into	two subclasses, TCPSocket and UDPSocket."	<primitive: 'primitiveSocketListenWithOrWithoutBacklog' module: 'SocketPlugin'>	self primitiveFailed! !!TSocket methodsFor: 'primitives' stamp: 'ar 2/7/2004 02:08'!primSocketAbortConnection: socketID	"Terminate the connection on the given port immediately without going through the normal close sequence. This is an asynchronous call; query the socket status to discover if and when the connection is actually terminated."	<primitive: 'primitiveSocketAbortConnection' module: 'SocketPlugin'>	self primitiveFailed! !!TSocket methodsFor: 'primitives' stamp: 'ar 2/7/2004 02:08'!primSocketCloseConnection: socketID	"Close the connection on the given port. The remote end is informed that this end has closed and will do no further sends. This is an asynchronous call; query the socket status to discover if and when the connection is actually closed."	<primitive: 'primitiveSocketCloseConnection' module: 'SocketPlugin'>	self primitiveFailed! !!TSocket methodsFor: 'primitives' stamp: 'ar 2/7/2004 02:08'!primSocketConnectionStatus: socketID	"Return an integer reflecting the connection status of this socket. For a list of possible values, see the comment in the 'initialize' method of this class. If the primitive fails, return a status indicating that the socket handle is no longer valid, perhaps because the Squeak image was saved and restored since the socket was created. (Sockets do not survive snapshots.)"	<primitive: 'primitiveSocketConnectionStatus' module: 'SocketPlugin'>	^ InvalidSocket! !!TSocket methodsFor: 'primitives' stamp: 'ar 2/7/2004 02:08'!primSocketCreateNetwork: netType type: socketType receiveBufferSize: rcvBufSize sendBufSize: sendBufSize semaIndex: semaIndex	"Return a new socket handle for a socket of the given type and buffer sizes. Return nil if socket creation fails.	The netType parameter is platform dependent and can be used to encode both the protocol type (IP, Xerox XNS, etc.) and/or the physical network interface to use if this host is connected to multiple networks. A zero netType means to use IP protocols and the primary (or only) network interface.	The socketType parameter specifies:		0	reliable stream socket (TCP if the protocol is IP)		1	unreliable datagram socket (UDP if the protocol is IP)	The buffer size parameters allow performance to be tuned to the application. For example, a larger receive buffer should be used when the application expects to be receiving large amounts of data, especially from a host that is far away. These values are considered requests only; the underlying implementation will ensure that the buffer sizes actually used are within allowable bounds. Note that memory may be limited, so an application that keeps many sockets open should use smaller buffer sizes. Note the macintosh implementation ignores this buffer size. Also see setOption to get/set socket buffer sizes which allows you to set/get the current buffer sizes for reading and writing. 	If semaIndex is > 0, it is taken to be the index of a Semaphore in the external objects array to be associated with this socket. This semaphore will be signalled when the socket status changes, such as when data arrives or a send completes. All processes waiting on the semaphore will be awoken for each such event; each process must then query the socket state to figure out if the conditions they are waiting for have been met. For example, a process waiting to send some data can see if the last send has completed."	<primitive: 'primitiveSocketCreate' module: 'SocketPlugin'>	^ nil  "socket creation failed"! !!TSocket methodsFor: 'primitives' stamp: 'ar 2/7/2004 02:08'!primSocketCreateNetwork: netType type: socketType receiveBufferSize: rcvBufSize sendBufSize: sendBufSize semaIndex: semaIndex readSemaIndex: aReadSema writeSemaIndex: aWriteSema	"See comment in primSocketCreateNetwork: with one semaIndex. However you should know that some implementations	ignore the buffer size and this interface supports three semaphores,  one for open/close/listen and the other two for	reading and writing"	<primitive: 'primitiveSocketCreate3Semaphores' module: 'SocketPlugin'>	primitiveOnlySupportsOneSemaphore _ true.	^ self emulateSocketCreateNetwork: netType			type: socketType			receiveBufferSize: rcvBufSize			sendBufSize: sendBufSize			semaIndex: semaIndex			readSemaIndex: aReadSema			writeSemaIndex: aWriteSema! !!TSocket methodsFor: 'primitives' stamp: 'ar 2/7/2004 02:08'!primSocketDestroy: socketID	"Release the resources associated with this socket. If a connection is open, it is aborted."	<primitive: 'primitiveSocketDestroy' module: 'SocketPlugin'>	self primitiveFailed! !!TSocket methodsFor: 'primitives' stamp: 'ar 2/7/2004 02:08'!primSocketDestroyGently: socketID	"Release the resources associated with this socket. If a connection is open, it is aborted.	Do not fail if the receiver is already closed."	<primitive: 'primitiveSocketDestroy' module: 'SocketPlugin'>! !!TSocket methodsFor: 'primitives' stamp: 'ar 2/7/2004 02:08'!primSocketError: socketID	"Return an integer encoding the most recent error on this socket. Zero means no error."	<primitive: 'primitiveSocketError' module: 'SocketPlugin'>	self primitiveFailed! !!TSocket methodsFor: 'primitives' stamp: 'ar 2/7/2004 02:08'!primSocketLocalAddress: socketID	"Return the local host address for this socket."	<primitive: 'primitiveSocketLocalAddress' module: 'SocketPlugin'>	self primitiveFailed! !!TSocket methodsFor: 'primitives' stamp: 'ar 2/7/2004 02:08'!primSocketLocalPort: socketID	"Return the local port for this socket, or zero if no port has yet been assigned."	<primitive: 'primitiveSocketLocalPort' module: 'SocketPlugin'>	self primitiveFailed! !!TSocket methodsFor: 'primitives' stamp: 'ar 2/7/2004 02:08'!primSocketReceiveDataAvailable: socketID	"Return true if data may be available for reading from the current socket."	<primitive: 'primitiveSocketReceiveDataAvailable' module: 'SocketPlugin'>	self primitiveFailed! !!TSocket methodsFor: 'primitives' stamp: 'ar 2/7/2004 02:08'!primSocketRemoteAddress: socketID	"Return the remote host address for this socket, or zero if no connection has been made."	<primitive: 'primitiveSocketRemoteAddress' module: 'SocketPlugin'>	self primitiveFailed! !!TSocket methodsFor: 'primitives' stamp: 'ar 2/7/2004 02:08'!primSocketRemotePort: socketID	"Return the remote port for this socket, or zero if no connection has been made."	<primitive: 'primitiveSocketRemotePort' module: 'SocketPlugin'>	self primitiveFailed! !!TSocket methodsFor: 'primitives' stamp: 'ar 2/7/2004 02:08'!primSocketSendDone: socketID	"Return true if there is no send in progress on the current socket."	<primitive: 'primitiveSocketSendDone' module: 'SocketPlugin'>	self primitiveFailed! !!TSocket methodsFor: 'printing' stamp: 'ar 2/7/2004 02:08'!printOn: aStream	super printOn: aStream.	aStream nextPutAll: '[', self statusString, ']'.! !!TSocket methodsFor: 'datagrams' stamp: 'ar 2/7/2004 02:08'!receiveDataInto: aStringOrByteArray fromHost: hostAddress port: portNumber	| datagram |	"Receive a UDP packet from the given hostAddress/portNumber, storing the data in the given buffer, and return the number of bytes received. Note the given buffer may be only partially filled by the received data."	primitiveOnlySupportsOneSemaphore ifTrue:		[self setPeer: hostAddress port: portNumber.		^self receiveDataInto: aStringOrByteArray].	[true] whileTrue: 		[datagram _ self receiveUDPDataInto: aStringOrByteArray.		((datagram at: 2) = hostAddress and: [(datagram at: 3) = portNumber]) 			ifTrue: [^datagram at: 1]			ifFalse: [^0]]! !!TSocket methodsFor: 'datagrams' stamp: 'ar 2/7/2004 02:08'!receiveUDPDataInto: aStringOrByteArray	"Receive UDP data into the given buffer and return the number of bytes received. Note the given buffer may be only partially filled by the received data. What is returned is an array, the first element is the bytes read, the second the sending bytearray address, the third the senders port, the fourth, true if more of the datagram awaits reading"	^ self primSocket: socketHandle		receiveUDPDataInto: aStringOrByteArray		startingAt: 1		count: aStringOrByteArray size! !!TSocket methodsFor: 'datagrams' stamp: 'ar 2/7/2004 02:08'!sendData: aStringOrByteArray toHost: hostAddress port: portNumber	"Send a UDP packet containing the given data to the specified host/port."	primitiveOnlySupportsOneSemaphore ifTrue:		[self setPeer: hostAddress port: portNumber.		^self sendData: aStringOrByteArray].	^self sendUDPData: aStringOrByteArray toHost: hostAddress port: portNumber! !!TSocket methodsFor: 'datagrams' stamp: 'ar 2/7/2004 02:11'!sendUDPData: aStringOrByteArray toHost: hostAddress port: portNumber	"Send a UDP packet containing the given data to the specified host/port."	| bytesToSend bytesSent count |	bytesToSend _ aStringOrByteArray size.	bytesSent _ 0.	[bytesSent < bytesToSend] whileTrue: [		(self waitForSendDoneUntil: (TSocket deadlineSecs: 20))			ifFalse: [self error: 'send data timeout; data not sent'].		count _ self primSocket: socketHandle			sendUDPData: aStringOrByteArray			toHost: hostAddress			port: portNumber			startIndex: bytesSent + 1			count: bytesToSend - bytesSent.		bytesSent _ bytesSent + count].	^ bytesSent! !!TSocket methodsFor: 'datagrams' stamp: 'ar 2/7/2004 02:08'!setPeer: hostAddress port: port	"Set the default send/recv address."	self primSocket: socketHandle connectTo: hostAddress port: port.! !!TSocket methodsFor: 'datagrams' stamp: 'ar 2/7/2004 02:08'!setPort: port	"Associate a local port number with a UDP socket.  Not applicable to TCP sockets."	self primSocket: socketHandle setPort: port.! !!TSocket methodsFor: 'registry' stamp: 'ar 2/7/2004 02:08'!register	^self class register: self! !!TSocket methodsFor: 'registry' stamp: 'ar 2/7/2004 02:08'!unregister	^self class unregister: self! !!TSocket methodsFor: 'waiting' stamp: 'ar 2/7/2004 02:08'!waitForAcceptUntil: deadLine	"Wait and accept an incoming connection"	self waitForConnectionUntil: deadLine.	^self isConnected		ifTrue:[self accept]		ifFalse:[nil]! !!TSocket methodsFor: 'waiting' stamp: 'ar 2/7/2004 02:08'!waitForConnectionUntil: deadline	"Wait up until the given deadline for a connection to be established. Return true if it is established by the deadline, false if not."	| status |	status _ self primSocketConnectionStatus: socketHandle.	[(status = WaitingForConnection) and: [Time millisecondClockValue < deadline]]		whileTrue: [			self semaphore waitTimeoutMSecs: (deadline - Time millisecondClockValue).			status _ self primSocketConnectionStatus: socketHandle].	^ status = Connected! !!TSocket methodsFor: 'waiting' stamp: 'ar 2/7/2004 02:08'!waitForDataUntil: deadline	"Wait up until the given deadline for data to arrive. Return true if data arrives by the deadline, false if not."	| dataArrived |	[self isConnected & 	 (dataArrived _ self primSocketReceiveDataAvailable: socketHandle) not			"Connection end and final data can happen fast, so test in this order"		and: [Time millisecondClockValue < deadline]] whileTrue: [			self readSemaphore waitTimeoutMSecs: (deadline - Time millisecondClockValue)].	^ dataArrived! !!TSocket methodsFor: 'waiting' stamp: 'ar 2/7/2004 02:08'!waitForDisconnectionUntil: deadline	"Wait up until the given deadline for the the connection to be broken. Return true if it is broken by the deadline, false if not."	"Note: The client should know the the connect is really going to be closed (e.g., because he has called 'close' to send a close request to the other end) before calling this method.JMM 00/5/17 note that other end can close which will terminate wait"	| extraBytes status |	extraBytes _ 0.	status _ self primSocketConnectionStatus: socketHandle.	[((status = Connected) or: [(status = ThisEndClosed)]) and:	 [Time millisecondClockValue < deadline]] whileTrue: [		self dataAvailable			ifTrue: [extraBytes _ extraBytes + self discardReceivedData].		self semaphore waitTimeoutMSecs: (deadline - Time millisecondClockValue).		status _ self primSocketConnectionStatus: socketHandle].	extraBytes > 0		ifTrue: [self inform: 'Discarded ', extraBytes printString, ' bytes while closing connection.'].	^ status ~= Connected! !!TSocket methodsFor: 'waiting' stamp: 'ar 2/7/2004 02:08'!waitForSendDoneUntil: deadline	"Wait up until the given deadline for the current send operation to complete. Return true if it completes by the deadline, false if not."	| sendDone |	[self isConnected & (sendDone _ self primSocketSendDone: socketHandle) not			"Connection end and final data can happen fast, so test in this order"		and: [Time millisecondClockValue < deadline]] whileTrue: [			self writeSemaphore waitTimeoutMSecs: (deadline - Time millisecondClockValue)].	^ sendDone! !!TSocket class methodsFor: 'instance creation' stamp: 'ar 2/7/2004 02:08'!acceptFrom: aSocket	^[ super new acceptFrom: aSocket ]		repeatWithGCIf: [ :sock | sock isValid not ]! !!TSocket class methodsFor: 'instance creation' stamp: 'ar 2/7/2004 02:08'!createIfFail: failBlock	"Attempt to create a new socket. If successful, return the new socket. Otherwise, return the result of evaluating the given block. Socket creation can fail if the network isn't available or if there are not sufficient resources available to create another socket."	"Note: The default creates a TCP socket"	^self tcpCreateIfFail: failBlock! !!TSocket class methodsFor: 'instance creation' stamp: 'ar 2/7/2004 02:08'!new	"Return a new, unconnected Socket. Note that since socket creation may fail, it is safer to use the method createIfFail: to handle such failures gracefully; this method is primarily for backward compatibility and may be disallowed in a future release."	"Note: The default creates a TCP socket - this is also backward compatibility."	^self newTCP! !!TSocket class methodsFor: 'instance creation' stamp: 'ar 2/7/2004 02:08'!newTCP	"Create a socket and initialise it for TCP"	^[ super new initialize: TCPSocketType ]		repeatWithGCIf: [ :socket | socket isValid not ]! !!TSocket class methodsFor: 'instance creation' stamp: 'ar 2/7/2004 02:08'!newUDP	"Create a socket and initialise it for UDP"	^[ super new initialize: UDPSocketType ]		repeatWithGCIf: [ :socket | socket isValid not ]! !!TSocket class methodsFor: 'instance creation' stamp: 'ar 2/7/2004 02:08'!tcpCreateIfFail: failBlock	"Attempt to create a new socket. If successful, return the new socket. Otherwise, return the result of evaluating the given block. Socket creation can fail if the network isn't available or if there are not sufficient resources available to create another socket."	| sock |	sock _ super new initialize: TCPSocketType.	sock isValid ifFalse: [^ failBlock value].	^ sock! !!TSocket class methodsFor: 'instance creation' stamp: 'ar 2/7/2004 02:08'!udpCreateIfFail: failBlock	"Attempt to create a new socket. If successful, return the new socket. Otherwise, return the result of evaluating the given block. Socket creation can fail if the network isn't available or if there are not sufficient resources available to create another socket."	| sock |	sock _ super new initialize: UDPSocketType.	sock isValid ifFalse: [^ failBlock value].	^ sock! !!TSocket class methodsFor: 'examples' stamp: 'ar 2/7/2004 02:12'!clientServerTestUDP	"TSocket clientServerTestUDP"	"Performa 6400/200, Linux-PPC 2.1.24:		client/server UDP test done; time = 2820		2500 packets, 10000000 bytes sent (3546 kBytes/sec)		2500 packets, 10000000 bytes received (3546 kBytes/sec)		4000 bytes/packet, 886 packets/sec, 0 packets dropped"	| sock1 sock2 bytesToSend sendBuf receiveBuf done bytesSent bytesReceived packetsSent packetsReceived t |	Transcript show: 'starting client/server UDP test'; cr.	Transcript show: 'initializing network ... '.	TSocket initializeNetworkIfFail: [^Transcript show:'failed'].	Transcript show:'ok';cr.	Transcript show: 'creating endpoints'; cr.	sock1 _ TSocket newUDP.	"the sender"	sock2 _ TSocket newUDP.	"the recipient"	sock2 setPort: 54321.	sock1 setPeer: (NetNameResolver localHostAddress) port: (sock2 port).	Transcript show: 'endpoints created'; cr.	bytesToSend _ 10000000.	sendBuf _ String new: 4000 withAll: $x.	receiveBuf _ String new: 50000.	done _ false.	bytesSent _ bytesReceived _ packetsSent _ packetsReceived _ 0.	t _ Time millisecondsToRun: [		[done] whileFalse: [			(sock1 sendDone and: [bytesSent < bytesToSend]) ifTrue: [				packetsSent _ packetsSent + 1.				bytesSent _ bytesSent + (sock1 sendData: sendBuf)].			sock2 dataAvailable ifTrue: [				packetsReceived _ packetsReceived + 1.				bytesReceived _ bytesReceived +					(sock2 receiveDataInto: receiveBuf)].			done _ (bytesSent >= bytesToSend)].		sock1 waitForSendDoneUntil: self standardDeadline.		bytesReceived _ bytesReceived + sock2 discardReceivedData].	Transcript show: 'closing endpoints'; cr.	sock1 close.	sock2 close.	sock1 destroy.	sock2 destroy.	Transcript show: 'client/server UDP test done; time = ', t printString; cr.	Transcript show: packetsSent printString, ' packets, ',						bytesSent printString, ' bytes sent (',						(bytesSent * 1000 // t) printString, ' Bytes/sec)'; cr.	Transcript show: packetsReceived printString, ' packets, ',						bytesReceived printString, ' bytes received (',						(bytesReceived * 1000 // t) printString, ' Bytes/sec)'; cr.	Transcript show: (bytesSent // packetsSent) printString, ' bytes/packet, ',						(packetsReceived * 1000 // t) printString, ' packets/sec, ',						(packetsSent - packetsReceived) printString, ' packets dropped'; cr.! !!TSocket class methodsFor: 'examples' stamp: 'ar 2/7/2004 02:12'!clientServerTestUDP2	"TSocket clientServerTestUDP2"	| sock1 sock2 bytesToSend sendBuf receiveBuf done bytesSent bytesReceived packetsSent packetsReceived t datagramInfo |	Transcript show: 'starting client/server UDP test'; cr.	Transcript show: 'initializing network ... '.	TSocket initializeNetworkIfFail: [^Transcript show:'failed'].	Transcript show:'ok';cr.	Transcript show: 'creating endpoints'; cr.	sock1 _ TSocket newUDP.	"the sender"	sock2 _ TSocket newUDP.	"the recipient"	sock2 setPort: 54321.	Transcript show: 'endpoints created'; cr.	bytesToSend _ 100000000.	sendBuf _ String new: 4000 withAll: $x.	receiveBuf _ String new: 2000.	done _ false.	bytesSent _ bytesReceived _ packetsSent _ packetsReceived _ 0.	t _ Time millisecondsToRun: [		[done] whileFalse: [			(sock1 sendDone and: [bytesSent < bytesToSend]) ifTrue: [				packetsSent _ packetsSent + 1.				bytesSent _ bytesSent + (sock1 sendData: sendBuf toHost: (NetNameResolver localHostAddress) port: (sock2 port))].				sock2 dataAvailable ifTrue: [				packetsReceived _ packetsReceived + 1.				datagramInfo _ sock2 receiveUDPDataInto: receiveBuf.				bytesReceived _ bytesReceived + (datagramInfo at: 1)].			done _ (bytesSent >= bytesToSend)].		sock1 waitForSendDoneUntil: self standardDeadline.		bytesReceived _ bytesReceived + sock2 discardReceivedData].	Transcript show: 'closing endpoints'; cr.	sock1 close.	sock2 close.	sock1 destroy.	sock2 destroy.	Transcript show: 'client/server UDP test done; time = ', t printString; cr.	Transcript show: packetsSent printString, ' packets, ',						bytesSent printString, ' bytes sent (',						(bytesSent * 1000 // t) printString, ' Bytes/sec)'; cr.	Transcript show: packetsReceived printString, ' packets, ',						bytesReceived printString, ' bytes received (',						(bytesReceived * 1000 // t) printString, ' Bytes/sec)'; cr.	Transcript show: (bytesSent // packetsSent) printString, ' bytes/packet, ',						(packetsReceived * 1000 // t) printString, ' packets/sec, ',						(packetsSent - packetsReceived) printString, ' packets dropped'; cr.! !!TSocket class methodsFor: 'examples' stamp: 'ar 2/7/2004 02:13'!remoteTestClientTCP	"FIRST start up another image, and execute: TSocket remoteTestServerTCP.	THEN come back to this image and execute:"			"TSocket remoteTestClientTCP"	"Performa 6400/200, Linux-PPC 2.1.24, both images on same CPU:		remoteClient TCP test done; time = 5680		250 packets, 1000000 bytes sent (176 kBytes/sec)		60 packets, 1000000 bytes received (176 kBytes/sec)"	| socket bytesToSend sendBuf receiveBuf done bytesSent bytesReceived packetsSent packetsReceived t serverName |	Transcript show: 'starting client/server TCP test'; cr.	Transcript show: 'initializing network ... '.	TSocket initializeNetworkIfFail: [^Transcript show:'failed'].	Transcript show:'ok';cr.	socket _ TSocket newTCP.	serverName _ FillInTheBlank		request: 'What is your remote Test Server?'		initialAnswer: ''.	socket connectTo: (NetNameResolver addressFromString: serverName) port: 54321.	socket waitForConnectionUntil: TSocket standardDeadline.	Transcript show: 'client endpoint created'; cr.	bytesToSend _ 1000000.	sendBuf _ String new: 4000 withAll: $x.	receiveBuf _ String new: 50000.	done _ false.	bytesSent _ bytesReceived _ packetsSent _ packetsReceived _ 0.	t _ Time millisecondsToRun: [		[done] whileFalse:			[(socket sendDone and: [bytesSent < bytesToSend]) ifTrue:				[packetsSent _ packetsSent + 1.				bytesSent _ bytesSent + (socket sendData: sendBuf)].			socket dataAvailable ifTrue:				[packetsReceived _ packetsReceived + 1.				bytesReceived _ bytesReceived + (socket receiveDataInto: receiveBuf)].			done _ (bytesSent >= bytesToSend)].		[bytesReceived < bytesToSend] whileTrue:			[socket dataAvailable ifTrue:				[packetsReceived _ packetsReceived + 1.				bytesReceived _ bytesReceived + (socket receiveDataInto: receiveBuf)]]].	socket closeAndDestroy.	Transcript show: 'remoteClient TCP test done; time = ', t printString; cr.	Transcript show: packetsSent printString, ' packets, ',						bytesSent printString, ' bytes sent (',						(bytesSent * 1000 // t) printString, ' bytes/sec)'; cr.	Transcript show: packetsReceived printString, ' packets, ',						bytesReceived printString, ' bytes received (',						(bytesReceived * 1000 // t) printString, ' bytes/sec)'; cr.! !!TSocket class methodsFor: 'examples' stamp: 'ar 2/7/2004 02:13'!remoteTestClientTCPOpenClose1000	"TSocket remoteTestClientTCPOpenClose1000"	| number t1 socket serverName |	Transcript show: 'starting client/server TCP test'; cr.	Transcript show: 'initializing network ... '.	TSocket initializeNetworkIfFail: [^Transcript show:'failed'].	Transcript show:'ok';cr.	number _ 1000.	serverName _ FillInTheBlank		request: 'What is your remote Test Server?'		initialAnswer: ''.	t1 _ Time millisecondsToRun: 		[number timesRepeat: 		[socket _ TSocket newTCP.		socket connectTo: (NetNameResolver addressFromString: serverName) port: 54321.		socket waitForConnectionUntil: TSocket standardDeadline.		socket closeAndDestroy]].	Transcript cr;show: 'connects/close per second ', ((number/t1*1000.0) printString); cr.! !!TSocket class methodsFor: 'examples' stamp: 'ar 2/7/2004 02:13'!remoteTestClientTCPOpenClosePutGet	"TSocket remoteTestClientTCPOpenClosePutGet"	| checkLength number bytesExpected sendBuf receiveBuf t1 socket bytesReceived serverName | 	Transcript show: 'starting client/server TCP test'; cr.	Transcript show: 'initializing network ... '.	TSocket initializeNetworkIfFail: [^Transcript show:'failed'].	Transcript show:'ok';cr.	serverName _ FillInTheBlank		request: 'What is your remote Test Server?'		initialAnswer: ''.	number _ 1000.		bytesExpected _ 20000.	sendBuf _ String new: 80 withAll: $x.	receiveBuf _ String new: 50000.	t1 _ Time millisecondsToRun: 		[number timesRepeat: 		[socket _ TSocket newTCP.		socket connectTo: (NetNameResolver addressFromString: serverName) port: 54321.		socket waitForConnectionUntil: TSocket standardDeadline.		socket sendData: sendBuf.		socket waitForSendDoneUntil: (TSocket deadlineSecs: 5).		socket waitForDataUntil: (TSocket deadlineSecs: 5).		bytesReceived _ 0.		[bytesReceived < bytesExpected] whileTrue:			[checkLength _ socket receiveDataInto: receiveBuf.			bytesReceived _ bytesReceived + checkLength].		socket closeAndDestroy]].	Transcript cr;show: 'connects/get/put/close per second ', ((number/t1*1000.0) printString); cr.! !!TSocket class methodsFor: 'examples' stamp: 'ar 2/7/2004 02:13'!remoteTestClientUDP	"FIRST start up another image, and execute: TSocket remoteTestServerUDP.	THEN come back to this image and execute:"			"TSocket remoteTestClientUDP"	"Performa 6400/200, Linux-PPC 2.1.24:		remoteClient UDP test done; time = 4580		2500 packets, 10000000 bytes sent (2183 kBytes/sec)		180 packets, 720000 bytes received (157 kBytes/sec)		4000 bytes/packet, 39 packets/sec, 2320 packets dropped"	| socket bytesToSend sendBuf receiveBuf done bytesSent bytesReceived packetsSent packetsReceived t serverName |	Transcript show: 'starting client/server UDP test'; cr.	Transcript show: 'initializing network ... '.	TSocket initializeNetworkIfFail: [^Transcript show:'failed'].	Transcript show:'ok';cr.	serverName _ FillInTheBlank		request: 'What is your remote Test Server?'		initialAnswer: ''.	socket _ TSocket newUDP.	socket setPeer: (NetNameResolver addressFromString: serverName) port: 54321.	Transcript show: 'client endpoint created'; cr.	bytesToSend _ 10000000.	sendBuf _ String new: 4000 withAll: $x.	receiveBuf _ String new: 4000.	done _ false.	bytesSent _ bytesReceived _ packetsSent _ packetsReceived _ 0.	t _ Time millisecondsToRun: [		[done] whileFalse:			[(socket sendDone and: [bytesSent < bytesToSend]) ifTrue:				[packetsSent _ packetsSent + 1.				bytesSent _ bytesSent + (socket sendData: sendBuf)].			socket dataAvailable ifTrue:				[packetsReceived _ packetsReceived + 1.				bytesReceived _ bytesReceived + (socket receiveDataInto: receiveBuf)].			done _ (bytesSent >= bytesToSend)].	[socket waitForDataUntil: (TSocket deadlineSecs: 1).	socket dataAvailable] whileTrue:		[packetsReceived _ packetsReceived + 1.		bytesReceived _ bytesReceived + (socket receiveDataInto: receiveBuf)]].	socket closeAndDestroy.	Transcript show: 'remoteClient UDP test done; time = ', t printString; cr.	Transcript show: packetsSent printString, ' packets, ',						bytesSent printString, ' bytes sent (',						(bytesSent * 1000 // t) printString, ' bytes/sec)'; cr.	Transcript show: packetsReceived printString, ' packets, ',						bytesReceived printString, ' bytes received (',						(bytesReceived * 1000 // t) printString, ' bytes/sec)'; cr.	Transcript show: (bytesSent // packetsSent) printString, ' bytes/packet, ',						(packetsReceived * 1000 // t) printString, ' packets/sec, ',						(packetsSent - packetsReceived) printString, ' packets dropped'; cr.! !!TSocket class methodsFor: 'examples' stamp: 'ar 2/7/2004 02:14'!remoteTestServerTCP	"See remoteTestClientTCP for instructions on running this method."	"TSocket remoteTestServerTCP"	| socket buffer n |	Transcript show: 'initializing network ... '.	TSocket initializeNetworkIfFail: [^Transcript show:'failed'].	Transcript show:'ok';cr.	socket _ TSocket newTCP.	socket listenOn: 54321.	Transcript show: 'server endpoint created -- run client test in other image'; cr.	buffer _ String new: 4000.	socket waitForConnectionUntil: self standardDeadline.	[socket isConnected] whileTrue: [		socket dataAvailable ifTrue:			[n _ socket	receiveDataInto: buffer.			socket sendData: buffer count: n]].	socket closeAndDestroy.	Transcript cr; show: 'server endpoint destroyed'; cr.! !!TSocket class methodsFor: 'examples' stamp: 'ar 2/7/2004 02:14'!remoteTestServerTCPOpenClose1000	"The version of #remoteTestServerTCPOpenClose1000 using the BSD style accept() mechanism."	"TSocket remoteTestServerTCPOpenClose1000"	| socket server |	Transcript show: 'initializing network ... '.	TSocket initializeNetworkIfFail: [^Transcript show:'failed'].	Transcript show:'ok';cr.	server _ TSocket newTCP.	server listenOn: 54321 backlogSize: 20.	server isValid ifFalse:[self error:'Accept() is not supported'].	Transcript show: 'server endpoint created -- run client test in other image'; cr.	1000 timesRepeat: 		[socket _ server waitForAcceptUntil: (TSocket deadlineSecs: 300).		socket closeAndDestroy].	server closeAndDestroy.	Transcript cr; show: 'server endpoint destroyed'; cr.! !!TSocket class methodsFor: 'examples' stamp: 'ar 2/7/2004 02:14'!remoteTestServerTCPOpenClosePutGet		"The version of #remoteTestServerTCPOpenClosePutGet using the BSD style accept() mechanism."	"TSocket remoteTestServerTCPOpenClosePutGet"	| socket server bytesIWantToSend bytesExpected receiveBuf sendBuf checkLength |	Transcript show: 'initializing network ... '.	TSocket initializeNetworkIfFail: [^Transcript show:'failed'].	Transcript show:'ok';cr.	server _ TSocket newTCP.	server listenOn: 54321 backlogSize: 20.	server isValid ifFalse:[self error:'Accept() is not supported'].	Transcript show: 'server endpoint created -- run client test in other image'; cr.	bytesIWantToSend _ 20000.	bytesExpected _ 80.	receiveBuf _ String new: 40000.	sendBuf _ String new: bytesIWantToSend withAll: $x.	1000 timesRepeat: 		[socket _ server waitForAcceptUntil: (TSocket deadlineSecs: 300).		socket waitForDataUntil: (TSocket deadlineSecs: 5).		checkLength _ socket receiveDataInto: receiveBuf.		(checkLength ~= bytesExpected) ifTrue: [self halt].		socket sendData: sendBuf.		socket waitForSendDoneUntil: (TSocket deadlineSecs: 5).				socket closeAndDestroy].	server closeAndDestroy.	Transcript cr; show: 'server endpoint destroyed'; cr.! !!TSocket class methodsFor: 'examples' stamp: 'ar 2/7/2004 02:14'!remoteTestServerTCPUsingAccept	"The version of #remoteTestServer using the BSD style accept() mechanism."	"TSocket remoteTestServerTCPUsingAccept"	| socket buffer n server |	Transcript show: 'initializing network ... '.	TSocket initializeNetworkIfFail: [^Transcript show:'failed'].	Transcript show:'ok';cr.	server _ TSocket newTCP.	server listenOn: 54321 backlogSize: 4.	server isValid ifFalse:[self error:'Accept() is not supported'].	Transcript show: 'server endpoint created -- run client test in other image'; cr.	buffer _ String new: 40000.	10 timesRepeat: 		[socket _ server waitForAcceptUntil: (self deadlineSecs: 300).		[socket isConnected] whileTrue: [ 			socket dataAvailable ifTrue:				[n _ socket	receiveDataInto: buffer.				socket sendData: buffer count: n]]].	socket closeAndDestroy.	server closeAndDestroy.	Transcript cr; show: 'server endpoint destroyed'; cr.! !!TSocket class methodsFor: 'examples' stamp: 'ar 2/7/2004 02:14'!remoteTestServerUDP	"See remoteTestClientUDP for instructions on running this method."	"TSocket remoteTestServerUDP"	| socket buffer n |	Transcript show: 'initializing network ... '.	TSocket initializeNetworkIfFail: [^Transcript show:'failed'].	Transcript show:'ok';cr.	socket _ TSocket newUDP.	socket setPort: 54321.	Transcript show: 'server endpoint created -- run client test in other image'; cr.	buffer _ String new: 4000.	[true] whileTrue: [		socket dataAvailable ifTrue:			[n _ socket	receiveDataInto: buffer.				socket sendData: buffer count: n]].! !!TSocket class methodsFor: 'examples' stamp: 'ar 2/7/2004 02:14'!remoteTestServerUDP2	"See remoteTestClientUDP for instructions on running this method."	"TSocket remoteTestServerUDP2"	| socket buffer datagramInfo |	Transcript show: 'initializing network ... '.	TSocket initializeNetworkIfFail: [^Transcript show:'failed'].	Transcript show:'ok';cr.	socket _ TSocket newUDP.	socket setPort: 54321.	Transcript show: 'server endpoint created -- run client test in other image'; cr.	buffer _ String new: 65000.	[true] whileTrue: [		socket dataAvailable ifTrue:			[datagramInfo _ socket receiveUDPDataInto: buffer. 			Transcript show: datagramInfo printString;cr.				socket sendData: buffer count: (datagramInfo at: 1)]].! !!TSocket class methodsFor: 'examples' stamp: 'ar 2/7/2004 02:15'!remoteTestSinkTCP	"See sendTest for instructions on running this method."	"TSocket remoteTestSinkTCP"	| socket buffer n |	Transcript show: 'initializing network ... '.	TSocket initializeNetworkIfFail: [^Transcript show:'failed'].	Transcript show:'ok';cr.	socket _ TSocket newTCP.	socket listenOn: 9.	Transcript show: 'server endpoint created -- run client test in other image'; cr.	buffer _ String new: 64000.	socket waitForConnectionUntil: self standardDeadline.	[socket isConnected] whileTrue: [		socket dataAvailable ifTrue:			[n _ socket	receiveDataInto: buffer]].	socket closeAndDestroy.	Transcript cr; show: 'sink endpoint destroyed'; cr.! !!TSocket class methodsFor: 'examples' stamp: 'ar 2/7/2004 02:15'!timeTest	"TSocket timeTest"	| serverName serverAddr s |	Transcript show: 'initializing network ... '.	TSocket initializeNetworkIfFail: [^Transcript show:'failed'].	Transcript show:'ok';cr.	serverName _ FillInTheBlank		request: 'What is your time server?'		initialAnswer: 'localhost'.	serverName isEmpty ifTrue: [^ Transcript show: 'never mind'; cr].	serverAddr _ NetNameResolver addressForName: serverName timeout: 10.	serverAddr = nil ifTrue: [self error: 'Could not find the address for ', serverName].	s _ TSocket new.	Transcript show: '---------- Connecting ----------'; cr.	s connectTo: serverAddr port: 13.  "13 is the 'daytime' port number"	s waitForConnectionUntil: (self deadlineSecs: 1).	Transcript show: 'the time server reports: ' , s getResponseNoLF.	s closeAndDestroy.	Transcript show: '---------- Connection Closed ----------'; cr.! !!TSocket class methodsFor: 'examples' stamp: 'ar 2/7/2004 02:15'!timeTestUDP	"TSocket timeTestUDP"	| serverName serverAddr s |	Transcript show: 'initializing network ... '.	TSocket initializeNetworkIfFail: [^Transcript show:'failed'].	Transcript show:'ok';cr.	serverName _ FillInTheBlank		request: 'What is your time server?'		initialAnswer: 'localhost'.	serverName isEmpty ifTrue: [^ Transcript show: 'never mind'; cr].	serverAddr _ NetNameResolver addressForName: serverName timeout: 10.	serverAddr = nil ifTrue: [self error: 'Could not find the address for ', serverName].	s _ TSocket newUDP.		"a 'random' port number will be allocated by the system"	"Send a packet to the daytime port and it will reply with the current date."	Transcript show: '---------- Sending datagram from port ' , s port printString , ' ----------'; cr.	s sendData: '!!' toHost: serverAddr port: 13.	"13 is the daytime service"	Transcript show: 'the time server reports: ' , s getResponseNoLF.	s closeAndDestroy.	Transcript show: '---------- TSocket closed ----------'; cr.! !!TSocket class methodsFor: 'examples' stamp: 'ar 2/7/2004 02:15'!timeTestUDP2	"TSocket timeTestUDP2"	| serverName serverAddr s |	Transcript show: 'initializing network ... '.	TSocket initializeNetworkIfFail: [^Transcript show:'failed'].	Transcript show:'ok';cr.	serverName _ FillInTheBlank		request: 'What is your time server?'		initialAnswer: 'localhost'.	serverName isEmpty ifTrue: [^ Transcript show: 'never mind'; cr].	serverAddr _ NetNameResolver addressForName: serverName timeout: 10.	serverAddr = nil ifTrue: [self error: 'Could not find the address for ', serverName].	s _ TSocket newUDP.	"The following associates a port with the UDP socket, but does NOT create a connectable endpoint"	s setPort: 54321.	"Send a packet to the daytime port and it will reply with the current date."	Transcript show: '---------- Sending datagram from port ' , s port printString , ' ----------'; cr.	s sendData: '!!' toHost: serverAddr port: 13.	Transcript show: 'the time server reports: ' , s getResponseNoLF.	s closeAndDestroy.	Transcript show: '---------- TSocket closed ----------'; cr.! !!TSocket class methodsFor: 'examples' stamp: 'ar 2/7/2004 02:15'!timeTestUDP3	"TSocket timeTestUDP3"	| serverName serverAddr s |	Transcript show: 'initializing network ... '.	TSocket initializeNetworkIfFail: [^Transcript show:'failed'].	Transcript show:'ok';cr.	serverName _ FillInTheBlank		request: 'What is your time server?'		initialAnswer: 'localhost'.	serverName isEmpty ifTrue: [^ Transcript show: 'never mind'; cr].	serverAddr _ NetNameResolver addressForName: serverName timeout: 10.	serverAddr = nil ifTrue: [self error: 'Could not find the address for ', serverName].	s _ TSocket newUDP.	"The following associates a port with the UDP socket, but does NOT create a connectable endpoint"	s setPort: (TSocket wildcardPort).		"explicitly request a default port number"	"Send a packet to the daytime port and it will reply with the current date."	Transcript show: '---------- Sending datagram from port ' , s port printString , ' ----------'; cr.	s sendData: '!!' toHost: serverAddr port: 13.	Transcript show: 'the time server reports: ' , s getResponseNoLF.	s closeAndDestroy.	Transcript show: '---------- TSocket closed ----------'; cr.! !!TSocket class methodsFor: 'utilities' stamp: 'ar 2/7/2004 02:08'!deadServer	^ DeadServer! !!TSocket class methodsFor: 'utilities' stamp: 'ar 2/7/2004 02:08'!deadServer: aStringOrNil	"Keep the machine name of the most recently encoutered non-responding machine.  Next time the user can move it to the last in a list of servers to try."	DeadServer _ aStringOrNil! !!TSocket class methodsFor: 'utilities' stamp: 'ar 2/7/2004 02:08'!deadlineSecs: secs	"Return a deadline time the given number of seconds from now."	^ Time millisecondClockValue + (secs * 1000)! !!TSocket class methodsFor: 'utilities' stamp: 'ar 2/7/2004 02:08'!nameForWellKnownTCPPort: portNum	"Answer the name for the given well-known TCP port number. Answer a string containing the port number if it isn't well-known."	| portList entry |	portList _ #(		(7 'echo') (9 'discard') (13 'time') (19 'characterGenerator')		(21 'ftp') (23 'telnet') (25 'smtp')		(80 'http') (110 'pop3') (119 'nntp')).	entry _ portList detect: [:pair | pair first = portNum] ifNone: [^ 'port-', portNum printString].	^ entry last! !!TSocket class methodsFor: 'utilities' stamp: 'ar 2/7/2004 02:12'!ping: hostName	"Ping the given host. Useful for checking network connectivity. The host must be running a TCP echo server."	"TSocket ping: 'squeak.cs.uiuc.edu'"	| tcpPort sock serverAddr startTime echoTime |	tcpPort _ 7.  "7 = echo port, 13 = time port, 19 = character generator port"	TSocket initializeNetwork.	serverAddr _ NetNameResolver addressForName: hostName timeout: 10.	serverAddr = nil ifTrue: [		^ self inform: 'Could not find an address for ', hostName].	sock _ TSocket new.	sock connectTo: serverAddr port: tcpPort.	[sock waitForConnectionUntil: (TSocket deadlineSecs: 10).	 sock isConnected] whileFalse: [		(self confirm: 'Continue to wait for connection to ', hostName, '?') ifFalse: [			sock destroy.			^ self]].	sock sendData: 'echo!!'.	startTime _ Time millisecondClockValue.	[sock waitForDataUntil: (TSocket deadlineSecs: 15).	 sock dataAvailable] whileFalse: [		(self confirm: 'Packet sent but no echo yet; keep waiting?') ifFalse: [			sock destroy.			^ self]].	echoTime _ Time millisecondClockValue - startTime.	sock destroy.	self inform: hostName, ' responded in ', echoTime printString, ' milliseconds'.! !!TSocket class methodsFor: 'utilities' stamp: 'ar 2/7/2004 02:12'!pingPorts: portList on: hostName timeOutSecs: timeOutSecs	"Attempt to connect to each of the given sockets on the given host. Wait at most timeOutSecs for the connections to be established. Answer an array of strings indicating the available ports."	"TSocket pingPorts: #(7 13 19 21 23 25 80 110 119) on: 'squeak.cs.uiuc.edu' timeOutSecs: 15"	| serverAddr sockets sock deadline done unconnectedCount connectedCount waitingCount result |	TSocket initializeNetwork.	serverAddr _ NetNameResolver addressForName: hostName timeout: 10.	serverAddr = nil ifTrue: [		self inform: 'Could not find an address for ', hostName.		^ #()].	sockets _ portList collect: [:portNum |		sock _ TSocket new.		sock connectTo: serverAddr port: portNum].	deadline _ self deadlineSecs: timeOutSecs.	done _ false.	[done] whileFalse: [		unconnectedCount _ 0.		connectedCount _ 0.		waitingCount _ 0.		sockets do: [:s |			s isUnconnectedOrInvalid				ifTrue: [unconnectedCount _ unconnectedCount + 1]				ifFalse: [					s isConnected ifTrue: [connectedCount _ connectedCount + 1].					s isWaitingForConnection ifTrue: [waitingCount _ waitingCount + 1]]].		waitingCount = 0 ifTrue: [done _ true].		connectedCount = sockets size ifTrue: [done _ true].		Time millisecondClockValue > deadline ifTrue: [done _ true]].	result _ (sockets select: [:s | s isConnected])		collect: [:s | self nameForWellKnownTCPPort: s remotePort].	sockets do: [:s | s destroy].	^ result! !!TSocket class methodsFor: 'utilities' stamp: 'ar 2/7/2004 02:12'!pingPortsOn: hostName	"Attempt to connect to a set of well-known sockets on the given host, and answer the names of the available ports."	"TSocket pingPortsOn: 'www.disney.com'"	^ TSocket		pingPorts: #(7 13 19 21 23 25 80 110 119)		on: hostName		timeOutSecs: 20! !!TSocket class methodsFor: 'utilities' stamp: 'ar 2/7/2004 02:08'!standardDeadline	"Return a default deadline time some seconds into the future."	^ self deadlineSecs: 45! !!TSocket class methodsFor: 'utilities' stamp: 'ar 2/7/2004 02:08'!wildcardAddress	"Answer a don't-care address for use with UDP sockets."	^ByteArray new: 4		"0.0.0.0"! !!TSocket class methodsFor: 'utilities' stamp: 'ar 2/7/2004 02:08'!wildcardPort	"Answer a don't-care port for use with UDP sockets.  (The system will allocate an	unused port number to the socket.)"	^0! !!TSocket class methodsFor: 'network initialization' stamp: 'ar 2/7/2004 02:12'!ensureNetworkConnected	"Try to ensure that an intermittent network connection, such as a dialup or ISDN line, is actually connected. This is necessary to make sure a server is visible in order to accept an incoming connection."	"TSocket ensureNetworkConnected"	TSocket initializeNetwork.	Utilities		informUser: 'Contacting domain name server...'		during: [			NetNameResolver				addressForName: 'bogusNameToForceDNSToBeConsulted.org'				timeout: 30].! !!TSocket class methodsFor: 'network initialization' stamp: 'ar 2/7/2004 02:57'!initializeNetwork	"Initialize the network drivers and the NetNameResolver. Do nothing if the network is already initialized."	"Note: The network must be re-initialized every time Squeak starts up, so applications that persist across snapshots should be prepared to re-initialize the network as needed. Such applications should call 'TSocket initializeNetwork' before every network transaction. "	NetNameResolver initializeNetwork! !!TSocket class methodsFor: 'network initialization' stamp: 'ar 2/7/2004 02:58'!initializeNetworkIfFail: failBlock	"Initialize the network drivers. Do nothing if the network is already initialized. Evaluate the given block if network initialization fails, perhaps because this computer isn't currently connected to a network."	| failed |	[failed := false.	NetNameResolver initializeNetwork] on: Error do:[:ex| failed := true. ex return: nil].	failed ifTrue:[^failBlock value]! !!TSocket class methodsFor: 'class initialization' stamp: 'ar 2/7/2004 02:08'!initialize	"Socket initialize"	"Socket Types"	TCPSocketType _ 0.	UDPSocketType _ 1.	"Socket Status Values"	InvalidSocket _ -1.	Unconnected _ 0.	WaitingForConnection _ 1.	Connected _ 2.	OtherEndClosed _ 3.	ThisEndClosed _ 4.	RegistryThreshold _ 100. "# of sockets"! !!TSocket class methodsFor: 'tests' stamp: 'ar 2/7/2004 02:12'!loopbackTest	"Send data from one socket to another on the local machine. Tests most of the socket primitives."	"100 timesRepeat: [TSocket loopbackTest]"	| sock1 sock2 bytesToSend sendBuf receiveBuf done bytesSent bytesReceived t extraBytes packetsSent packetsRead |	Transcript cr; show: 'starting loopback test'; cr.	Transcript show: '---------- Connecting ----------'; cr.	TSocket initializeNetwork.	sock1 _ TSocket new.	sock2 _ TSocket new.	sock1 listenOn: 54321.	sock2 connectTo: (NetNameResolver localHostAddress) port: 54321.	sock1 waitForConnectionUntil: self standardDeadline.	sock2 waitForConnectionUntil: self standardDeadline.	(sock1 isConnected) ifFalse: [self error: 'sock1 not connected'].	(sock2 isConnected) ifFalse: [self error: 'sock2 not connected'].	Transcript show: 'connection established'; cr.	bytesToSend _ 5000000.	sendBuf _ String new: 5000 withAll: $x.	receiveBuf _ String new: 50000.	done _ false.	packetsSent _ packetsRead _ bytesSent _ bytesReceived _ 0.	t _ Time millisecondsToRun: [		[done] whileFalse: [			(sock1 sendDone and: [bytesSent < bytesToSend]) ifTrue: [				packetsSent _ packetsSent + 1.				bytesSent _ bytesSent + (sock1 sendSomeData: sendBuf)].			sock2 dataAvailable ifTrue: [				packetsRead _ packetsRead + 1.				bytesReceived _ bytesReceived +					(sock2 receiveDataInto: receiveBuf)].			done _ (bytesSent >= bytesToSend) and: [bytesReceived = bytesSent]]].		Transcript show: 'closing connection'; cr.	sock1 waitForSendDoneUntil: self standardDeadline.	sock1 close.	sock2 waitForDisconnectionUntil: self standardDeadline.	extraBytes _ sock2 discardReceivedData.	extraBytes > 0 ifTrue: [		Transcript show: ' *** received ', extraBytes size printString, ' extra bytes ***'; cr.	].	sock2 close.	sock1 waitForDisconnectionUntil: self standardDeadline.	(sock1 isUnconnectedOrInvalid) ifFalse: [self error: 'sock1 not closed'].	(sock2 isUnconnectedOrInvalid) ifFalse: [self error: 'sock2 not closed'].	Transcript show: '---------- Connection Closed ----------'; cr.	sock1 destroy.	sock2 destroy.	Transcript show: 'loopback test done; time = ', t printString; cr.	Transcript show: ((bytesToSend asFloat / t) roundTo: 0.01) printString, ' 1000Bytes/sec'; cr.	Transcript endEntry.! !!TSocket class methodsFor: 'tests' stamp: 'ar 2/7/2004 02:08'!newAcceptCheck"Socket newAcceptCheck"	| socket |	self initializeNetwork.	socket _ self newTCP.	socket listenOn: 44444 backlogSize: 4.	socket isValid ifTrue: [		self inform: 'Everything looks OK for the BSD style accept()'	] ifFalse: [		self inform: 'It appears that you DO NOT have support for the BSD style accept()'	].	socket destroy.! !!TSocket class methodsFor: 'tests' stamp: 'ar 2/7/2004 02:15'!sendTest	"Send data to the 'discard' socket of the given host. Tests the speed of one-way data transfers across the network to the given host. Note that many host hosts do not run a discard server."	"TSocket sendTest"	| sock bytesToSend sendBuf bytesSent t serverName serverAddr |	Transcript cr; show: 'starting send test'; cr.	TSocket initializeNetwork.	serverName _ FillInTheBlank		request: 'What is the destination server?'		initialAnswer: 'create.ucsb.edu'.	serverAddr _ NetNameResolver addressForName: serverName timeout: 10.	serverAddr = nil ifTrue: [^ self inform: 'Could not find an address for ', serverName].	sock _ TSocket new.	Transcript show: '---------- Connecting ----------'; cr.	sock connectTo: serverAddr port: 9.	sock waitForConnectionUntil: self standardDeadline.	(sock isConnected) ifFalse: [		sock destroy.		^ self inform: 'could not connect'].	Transcript show: 'connection established; sending data'; cr.	bytesToSend _ 1000000.	sendBuf _ String new: 64*1024 withAll: $x.	bytesSent _ 0.	t _ Time millisecondsToRun: [		[bytesSent < bytesToSend] whileTrue: [			sock sendDone ifTrue: [				bytesSent _ bytesSent + (sock sendSomeData: sendBuf)]]].	sock waitForSendDoneUntil: self standardDeadline.	sock destroy.	Transcript show: '---------- Connection Closed ----------'; cr.	Transcript show: 'send test done; time = ', t printString; cr.	Transcript show: ((bytesToSend asFloat / t) roundTo: 0.01) printString, ' 1000Bytes/sec'; cr.	Transcript endEntry.! !!TSocket class methodsFor: 'registry' stamp: 'ar 2/7/2004 02:08'!register: anObject	WeakArray isFinalizationSupported ifFalse:[^anObject].	self registry add: anObject! !!TSocket class methodsFor: 'registry' stamp: 'ar 2/7/2004 02:08'!registry	WeakArray isFinalizationSupported ifFalse:[^nil].	^Registry isNil		ifTrue:[Registry := WeakRegistry new]		ifFalse:[Registry].! !!TSocket class methodsFor: 'registry' stamp: 'ar 2/7/2004 02:08'!registryThreshold	"Return the registry threshold above which socket creation may fail due to too many already open sockets. If the threshold is reached, a full GC will be issued if the creation of a socket fails."	^RegistryThreshold! !!TSocket class methodsFor: 'registry' stamp: 'ar 2/7/2004 02:08'!registryThreshold: aNumber	"Return the registry threshold above which socket creation may fail due to too many already open sockets. If the threshold is reached, a full GC will be issued if the creation of a socket fails."	RegistryThreshold _ aNumber! !!TSocket class methodsFor: 'registry' stamp: 'ar 2/7/2004 02:08'!unregister: anObject	WeakArray isFinalizationSupported ifFalse:[^anObject].	self registry remove: anObject ifAbsent:[]! !!TSolar methodsFor: 'events' stamp: 'das 9/21/2003 19:58'!handlesKeyboard: pointer^ true.! !!TSolar methodsFor: 'events' stamp: 'das 9/7/2003 13:47'!handlesPointerDown: pointer	^ true.! !!TSolar methodsFor: 'events' stamp: 'das 9/22/2003 12:50'!keyDown: pointer	| c |	c _ pointer event2D keyCharacter.	c = $g ifTrue:[(wind hasAttractor: earthGravity) ifTrue:[ self meta gravityOff.] 			ifFalse:[self meta gravityOn. ].].	c = $h ifTrue:[(wind hasAttractor: lowPressure) ifTrue:[ self meta lowPressureOff.]			ifFalse:[ self meta lowPressureOn.].].	c = $s ifTrue:[spinning ifTrue:[self meta spinningOff] ifFalse:[self meta spinningOn].].	c = $w ifTrue:[wideSpread ifTrue:[self meta wideSpreadOff] ifFalse:[self meta wideSpreadOn.].].! !!TSolar methodsFor: 'events' stamp: 'ar 9/30/2004 14:03'!pointerUp: ptr	| trns ac |	ac := ptr avatar.	(ac isChild: earthFrame) ifFalse:[		trns _ earthFrame globalTransform orthoNormInverse composeWith: ac globalTransform.		ac downPointer setAutomatic: false.		ac parent meta removeChild: ac.		earthFrame meta addChild: ac.		ac meta localTransform: trns.	] ifTrue:[		ac meta localTransform:ac globalTransform.		ac downPointer meta setAutomatic: true.		ac parent meta removeChild: ac.		self root meta addChild: ac.	].	^ true.! !!TSolar methodsFor: 'initialize' stamp: 'ar 10/2/2004 08:07'!initialize	| txtr mat tframe |	super initialize.	earth _ TSphere new.	earth objectOwner: self.	earth radius: 80.0.	earth segments: 40.	txtr _ TTexture new initializeWithFileName: 'graph256x128.bmp'.	mat _ TMaterial new.	mat texture: txtr.	mat ambientColor: #(1 1 1 1)asFloatArray.	mat diffuseColor: #(1 1 1 1)asFloatArray.	mat specularColor: #(0.1 0.1 0.1 1)asFloatArray.	mat shininess: 0.1.	earth material: mat.	earthFrame _ TGroup new.	earthFrame translation:(30@0@-120).	earth translation:(30@0@-120).	self addChild:earth.	self addChild: earthFrame.	tframe _ TSphere new.	tframe radius: (earth radius/5).	tframe texture: txtr.	tframe _ TSphere new.	tframe radius: (earth radius/10).	tframe texture: txtr.	wind _ TParticle new initializeWithSize: 1000.	wind startColor: (B3DColor4 r:1.0  g:0.2 b:0.2 a:1.0).	wind endColor: (B3DColor4 r:0.0  g:0.2 b:1.0 a:1.0).	wind setPositionRangeMin:(0@-0.1@-0.1) max: (0@0.1@0.1).	wind setVelocityRangeMin:(0@20@0) max:(0@20@0).	wind setAccelerationRangeMin:(0@0@0) max:(0@0@0).	wind setLifetimeRange: (10000 to: 15000).	tframe _ TSphere new.	tframe radius: earth radius/20.0.	txtr _ TTexture new initializeWithFileName: 'checker.png'.	tframe texture:txtr.	windButton _ TButton new initializeWithFrame: tframe.	windButton translation: ((earth radius+3)@0@0).	windButton persist: true.	earth addChild: windButton.	earthGravity _ TAttractor new.	earthGravity radius: earth radius+2.	earthGravity mass: 700000.0.	earth addChild: earthGravity.		lowPressure _ TAttractor new.	lowPressure radius: 10.0.	lowPressure mass: 15000.0.	lowPressure translation:(earth radius+3.0) * ((1@1@0) normalized).	lowPressure hard: false.	earth addChild: lowPressure.	earthRot _ 0.	tilt _ B3DMatrix4x4 identity rotationAroundZ: 23.45.	earthRot _ 0.0.	moon _ TSphere new.	moon radius: (earth radius *0.27).	moon segments: 30.	txtr _ TTexture new initializeWithFileName: 'moon.png'.	mat _ TMaterial new.	mat texture: txtr.	mat ambientColor: #(1 1 1 1)asFloatArray.	mat diffuseColor: #(1 1 1 1)asFloatArray.	mat specularColor: #(0.1 0.1 0.1 1)asFloatArray.	mat shininess: 0.1.	moon material:mat.	moon translation: (70@0@100).	self addChild: moon.	moonGravity _ TAttractor new.	moonGravity radius: moon radius.	moonGravity mass: 100000.0.	moon addChild: moonGravity.	spinning _ false.	wideSpread _ false.	! !!TSolar methodsFor: 'testing' stamp: 'das 9/22/2003 12:43'!isComponent	^ true.! !!TSolar methodsFor: 'buttonEvents' stamp: 'ar 9/30/2004 14:01'!buttonTool	(wind hasAttractor: earthGravity) ifTrue:[ self gravityOff.].	(wind hasAttractor: moonGravity) ifTrue:[ wind removeAttractor: moonGravity.].	(wind hasAttractor: lowPressure) ifTrue:[ self lowPressureOff.].	earth removeChild: windButton.	wind addAttractor: moonGravity.	wind addAttractor: earthGravity.	wind setVelocityRangeMin:(0@80@0) max:(0@80@0).	windButton rotationAroundX: -90.	windButton translation:(0@0@-30).	"self activeCamera pointer tool addAttachment: windButton."! !!TSolar methodsFor: 'buttonEvents' stamp: 'das 9/22/2003 05:47'!gravityOff	wind removeAttractor: earthGravity.	(wind hasAttractor: lowPressure)ifTrue:[self lowPressureOff].! !!TSolar methodsFor: 'buttonEvents' stamp: 'das 9/22/2003 06:43'!gravityOn	wind addAttractor: earthGravity.! !!TSolar methodsFor: 'buttonEvents' stamp: 'das 9/22/2003 05:46'!lowPressureOff	wind removeAttractor: lowPressure.! !!TSolar methodsFor: 'buttonEvents' stamp: 'das 9/22/2003 05:47'!lowPressureOn	wind addAttractor: lowPressure.	(wind hasAttractor: earthGravity)ifFalse:[self gravityOn].! !!TSolar methodsFor: 'buttonEvents' stamp: 'das 9/22/2003 05:47'!spinningOff	spinning _ false.! !!TSolar methodsFor: 'buttonEvents' stamp: 'das 9/22/2003 05:47'!spinningOn	spinning _ true.! !!TSolar methodsFor: 'buttonEvents' stamp: 'das 9/23/2003 07:34'!wideSpreadOff	wideSpread _ false.	wind setVelocityRangeMin:(0@20@0) max:(0@20@0).! !!TSolar methodsFor: 'buttonEvents' stamp: 'das 9/23/2003 07:34'!wideSpreadOn	wideSpread _ true.	wind setVelocityRangeMin:(0@0@-10) max:(0@20@10).! !!TSolar methodsFor: 'stepping' stamp: 'das 9/21/2003 20:23'!stepAt: currentTime	| trans rot msecs |	msecs _ (currentTime - self lastStepTime)asFloat.	spinning ifTrue:[		earthRot _ earthRot+(25.0*msecs/1000.0).		trans _ earth translation.		rot _ B3DMatrix4x4 identity rotationAroundY: earthRot.		"earth localTransform: (tilt composeWith: rot)."		earth localTransform: rot.		earthFrame localTransform: rot.		earth translation: trans.		earthFrame translation: trans.	].! !!TSolar methodsFor: 'stepping' stamp: 'das 9/22/2003 12:44'!wantsSteps	^ true.! !!TSpace methodsFor: 'accessing'!addAlpha: ao	alphaObjects class == Array ifTrue:[^self].alphaObjects add: ao.! !!TSpace methodsFor: 'accessing' stamp: 'DPR 7/7/2004 16:11'!addAlphaObject: anObject transform: aTransform distance: aDistance parent: aParent	alphaObjects class == Array ifTrue:[^self].	alphaObjects add: (TRenderAlpha object: anObject transform: aTransform distance: aDistance parent: aParent).! !!TSpace methodsFor: 'accessing' stamp: 'das 6/19/2003 08:13'!alphaObjects	^ alphaObjects.! !!TSpace methodsFor: 'accessing' stamp: 'das 6/19/2003 08:13'!alphaObjects: ao	alphaObjects _ ao.! !!TSpace methodsFor: 'accessing'!color	^ color.! !!TSpace methodsFor: 'accessing'!color: clr	color _ clr.! !!TSpace methodsFor: 'accessing'!cullBackFaces	^ cullBackFaces.! !!TSpace methodsFor: 'accessing'!cullBackFaces: bool	cullBackFaces _ bool.! !!TSpace methodsFor: 'accessing' stamp: 'das 6/19/2003 09:32'!currentCameraTransform	^ currentCameraTransform.! !!TSpace methodsFor: 'accessing'!currentParent	^ currentParent.! !!TSpace methodsFor: 'accessing'!currentParent: cp	currentParent _ cp.! !!TSpace methodsFor: 'accessing'!currentTransform	^ currentTransform.! !!TSpace methodsFor: 'accessing' stamp: 'das 12/4/2002 13:09'!currentTransform: ct	currentTransform _ ct.! !!TSpace methodsFor: 'accessing' stamp: 'das 4/29/2002 18:50'!currentTranslation		currentTransform ifNotNil:[^ currentTransform translation]	ifNil:[^ B3DVector3 new.].! !!TSpace methodsFor: 'accessing' stamp: 'ar 6/7/2002 22:09'!dropInFrame	^dropInFrame! !!TSpace methodsFor: 'accessing' stamp: 'ar 6/7/2002 22:09'!dropInFrame: aFrame	dropInFrame := aFrame! !!TSpace methodsFor: 'accessing' stamp: 'ar 6/6/2002 16:59'!locator	"Return a locator telling us where to find this guy on the net"	^locator! !!TSpace methodsFor: 'accessing' stamp: 'das 12/1/2002 22:18'!rayFrames	^ rayFrames.! !!TSpace methodsFor: 'accessing' stamp: 'das 12/2/2002 00:55'!testRays	 ^ testRays.! !!TSpace methodsFor: 'accessing' stamp: 'das 12/3/2002 09:33'!testRays: bool " This is to turn off testing if we re-enter the same space. I should only test once. "	testRays _ bool.! !!TSpace methodsFor: 'accessing' stamp: 'ar 6/6/2002 16:59'!url	^locator ifNotNil:[locator urlString]! !!TSpace methodsFor: 'accessing' stamp: 'DPR 1/5/2004 15:48'!url: aString	locator ifNil:[locator := ResourceLocator new].	locator urlString: aString.	locator resourceFileSize: SmallInteger maxVal.! !!TSpace methodsFor: 'frameManagement'!addLightFrame: ltfrm	lightFrames add: ltfrm.! !!TSpace methodsFor: 'frameManagement'!addPortalFrame: prtlFrm	portalFrames add: prtlFrm.! !!TSpace methodsFor: 'frameManagement' stamp: 'das 11/9/2002 15:01'!addRayFrame: rayfrm	rayFrames add: rayfrm.! !!TSpace methodsFor: 'frameManagement' stamp: 'ar 10/8/2002 11:53'!removeLightFrame: ltfrm	lightFrames remove: ltfrm ifAbsent:[]."	lightFrames doWithIndex:[ :lf :i| lf = ltfrm ifTrue: [lightFrames remove: i]]."! !!TSpace methodsFor: 'frameManagement' stamp: 'das 7/11/2002 01:42'!removePortalFrame: prtlFrm	portalFrames remove: prtlFrm.	"portalFrames doWithIndex:[ :pf :i| pf = prtlFrm ifTrue: [portalFrames remove: i]]."! !!TSpace methodsFor: 'frameManagement' stamp: 'das 11/9/2002 15:01'!removeRayFrame: rayfrm	rayFrames remove: rayfrm ifAbsent:[].! !!TSpace methodsFor: 'ambient sound'!ambientSound	^ambientSound! !!TSpace methodsFor: 'ambient sound'!ambientSound: aSound	ambientSound _ aSound.! !!TSpace methodsFor: 'ambient sound' stamp: 'DPR 5/27/2004 10:19'!ambientSoundFadeFrom: startVolume to: endVolume duration: msec	| steps stepSize |	steps := (msec / 20.0) asInteger.	steps <= 0 ifTrue: [^self].	stepSize := (endVolume - startVolume) / steps.	stepSize = 0.0 ifTrue: [^self].	self ambientSoundFadeVolume: startVolume stepSize: stepSize forSteps: steps finalVolume: endVolume.! !!TSpace methodsFor: 'ambient sound' stamp: 'DPR 5/27/2004 09:21'!ambientSoundFadeVolume: startVolume stepSize: stepSize forSteps: steps finalVolume: endVolume	steps = 0 ifTrue: [ ambientSound volume: endVolume. ^self ].	ambientSound volume: startVolume.	self future: 20.0 deferRelative: 20.0		perform: #ambientSoundFadeVolume:stepSize:forSteps:finalVolume:		withArguments: { startVolume + stepSize . stepSize . steps - 1 . endVolume }.! !!TSpace methodsFor: 'ambient sound' stamp: 'DPR 5/27/2004 09:03'!ambientSoundPauseComplete	ambientSound pause.	ambientSound volume: 0.0.! !!TSpace methodsFor: 'ambient sound' stamp: 'das 6/21/2002 12:42'!ambientSoundPlaying	ambientSound ifNotNil:[^ambientSound isPlaying.].	^ false.! !!TSpace methodsFor: 'ambient sound' stamp: 'ar 10/4/2004 13:22'!pauseAmbientSound	"this is really a fade and pause"	ambientSound ifNil:[^self].	self ambientSoundFadeFrom: ambientSound volume to: 0.0 duration: 1000.0.	self future: 1000.0 perform: #ambientSoundPauseComplete.! !!TSpace methodsFor: 'ambient sound' stamp: 'ar 6/6/2002 15:26'!playAmbientSound: aBool	aBool 		ifTrue:[self startAmbientSound] 		ifFalse:[self stopAmbientSound].! !!TSpace methodsFor: 'ambient sound' stamp: 'DPR 5/27/2004 08:56'!resumeAmbientSound	| volume |	ambientSound ifNil:[^self].	volume _ 0.8.	ambientSound reset.	ambientSound volume: 0.	ambientSound resumePlaying.	self ambientSoundFadeFrom: 0.0 to: volume duration: 1000.0.! !!TSpace methodsFor: 'ambient sound' stamp: 'das 5/11/2004 14:36'!startAmbientSound	ambientSound ifNotNil:[		ambientSound isLoaded ifFalse:[^self].		ambientSound resumePlaying].! !!TSpace methodsFor: 'ambient sound' stamp: 'ar 6/6/2002 15:27'!stopAmbientSound	ambientSound ifNotNil:[		ambientSound isLoaded ifFalse:[^self].		ambientSound pause].! !!TSpace methodsFor: 'ambient sound' stamp: 'ar 10/4/2004 13:22'!switchToAmbientSoundFrom: prevSpace	self future: 1000.0 perform: #resumeAmbientSound.	prevSpace pauseAmbientSound.! !!TSpace methodsFor: 'render' stamp: 'das 7/31/2004 11:40'!clearRender: ogl camera: cam"	ogl glClearColor: self color red with: self color green with: self color blue with: 1.0.	ogl glClear: (GLColorBufferBit bitOr: (GLDepthBufferBit bitOr: GLStencilBufferBit))."	ogl glClear: ((GLDepthBufferBit bitOr: GLStencilBufferBit)).	ogl glEnable: GLLighting.	self doRender: ogl camera: cam."	Croquet world activeCamera killFrame: true. "	ogl camera initFrustum: ogl.	ogl glEnable: GLLighting.! !!TSpace methodsFor: 'render' stamp: 'das 7/31/2004 11:40'!doRender: ogl	^ self renderSpace: ogl port: ogl camera depth: 1.! !!TSpace methodsFor: 'render' stamp: 'ar 9/30/2004 15:24'!doRender: ogl camera: atCam	| ac h v |	self addChild: atCam.	atCam currentSpace: self.	ac _ ogl camera.	atCam initFrustum: ogl." add the background poly, as we can't clear "	h _ atCam bounds width/2.0.	v _ atCam bounds height/2.0.	ogl glDepthMask: GLFalse; " set depth buffer to not write. "		glDisable: GLLighting;		glColor3f: self color red with: self color green with: self color blue;		glBegin: GLPolygon;		glVertex3f:  h negated with: v with:atCam zScreen negated;		glVertex3f: h with: v with:atCam zScreen negated;		glVertex3f: h with:v negated  with:atCam zScreen negated;		glVertex3f: h negated with: v negated  with:atCam zScreen negated;		glEnd;		glDepthMask: GLTrue; 		glEnable: GLLighting.	ogl camera: atCam.	self doRender: ogl.	ogl camera: ac.! !!TSpace methodsFor: 'render' stamp: 'das 10/18/2002 21:43'!forceAlpha	^ false.! !!TSpace methodsFor: 'render' stamp: 'DPR 7/7/2004 16:27'!hasAlphaObjectsToRender	^(alphaObjects size ~= 0 or: [self forceAlpha])! !!TSpace methodsFor: 'render' stamp: 'ar 10/2/2004 07:52'!makeThumbnailOf: aFrame extent: thumbExtent	"Create a thumbnail of the given frame"	| distance camera extent box tfm oldTransform thumb |	oldTransform := aFrame localTransform.	[		aFrame localTransform: B3DMatrix4x4 identity.		box := aFrame boundingBox.		extent := box extent.		distance := (extent x max: extent y) max: extent z.		distance := distance * 1.8.		distance > 3000 ifTrue:[distance := 0].		"set to zero"		tfm := B3DMatrix4x4 withOffset: box center negated.		"turn to camera"		tfm := (B3DRotation angle: -135 axis: 0@1@0) asMatrix4x4 composeWith: tfm.		"move it away"		tfm := (B3DMatrix4x4 withOffset: 0@0@distance negated) composeWith: tfm.		aFrame localTransform: tfm.		camera _ TCamera new initializeWithViewPort: CroquetGlobals activeCamera viewPort.		camera viewAngle: 45.0.		camera inPortal: true. "don't bother checking height and stuff."		camera bounds: (0@0 extent: thumbExtent).		camera translationX: 0 y: 0 z: 0.		thumb := self makeThumbnailOf: aFrame using: camera.	] ensure:[aFrame localTransform: oldTransform].	^thumb! !!TSpace methodsFor: 'render' stamp: 'ar 10/2/2004 16:19'!makeThumbnailOf: aFrame using: aCamera	"Create a snapshot of the given object using aCamera"	| oldChildren ogl |	ogl _ CroquetGlobals ogl.	ogl glClearColor: 0.0 with: 0.0 with: 0.0 with: 0.0.	ogl glClear: (GLColorBufferBit bitOr: (GLDepthBufferBit bitOr: GLStencilBufferBit)).	ogl glEnable: GLLighting.	ogl camera: aCamera.	oldChildren := frameChildren.	aCamera inPortal:true.	[		frameChildren := OrderedCollection with: aFrame.		self renderSpace: ogl port: aCamera depth: 1.	] ensure:[		frameChildren := oldChildren.	].	^ogl screenShot: aCamera bounds.! !!TSpace methodsFor: 'render' stamp: 'DPR 7/7/2004 16:21'!popAlphaObjects	"restore alpha objects saved while recursively rendering (in TPortal3D)"	alphaObjects _ savedAlphaObjects removeLast.	! !!TSpace methodsFor: 'render' stamp: 'DPR 7/7/2004 16:19'!pushAlphaObjects	"temporarily save alpha objects while recursively rendering (in TPortal3D)"	savedAlphaObjects add: alphaObjects.	alphaObjects _ OrderedCollection new: 0.	! !!TSpace methodsFor: 'render' stamp: 'ar 9/30/2004 15:26'!render: ogl thumbnailOf: aFrame using: aCamera	"Create a snapshot of the given object using aCamera"	| oldChildren |	ogl glClearColor: 0.0 with: 0.0 with: 0.0 with: 0.0.	ogl glClear: (GLColorBufferBit bitOr: (GLDepthBufferBit bitOr: GLStencilBufferBit)).	ogl glEnable: GLLighting.	ogl camera: aCamera.	oldChildren := frameChildren.	aCamera inPortal:true.	[		frameChildren := OrderedCollection with: aFrame.		aCamera initFrustum: ogl.		self doRender: ogl.	] ensure:[		frameChildren := oldChildren.	].	ogl camera killFrame: true; initFrustum: ogl.	^ogl screenShot: aCamera bounds! !!TSpace methodsFor: 'render' stamp: 'das 3/12/2004 14:01'!renderClear: ogl	ogl glClearColor: self color red with: self color green with: self color blue with: 1.0.	ogl glClear: (GLColorBufferBit bitOr: (GLDepthBufferBit bitOr: GLStencilBufferBit)).! !!TSpace methodsFor: 'render' stamp: 'das 7/31/2004 11:42'!renderSpace: ogl	| delta ac |	ac _ ogl camera."----- test if enter the portal here -----"	portalFrames do: [ :pf | 		 "------ is the portal visible? ------"		pf visible ifTrue:[ 		" ------ portal near avatar?-----"			delta _ ac avatar globalTransform translation - 				pf globalTransform translation.			delta squaredLength < pf boundSphere radiusSquared ifTrue:[				(pf testEnter: ac avatar) ifTrue:[^ self.].	].].].	^self renderSpace: ogl port: ac depth: 1.! !!TSpace methodsFor: 'render' stamp: 'das 7/31/2004 11:42'!renderSpace: ogl port: viewPort depth: depth	| currentCamTrans currentPointerTrans currentCameraInv cpt ip renderPortals delta renderedObjects tstRays ac |	ac _ ogl camera."------ The TSpace render method makes two passes. The first pass is used to render the non-alpha objects and to find the alpha objects. The alpha objects and their transforms are put into the SortedCollection alphaObjects. This array is sorted by distance using the bounding spheres of the objects and the second render pass using the renderAlpha method is made in using this sorted order from furthest to closest.------""------ reset the rayframes if this is the first time through...."	timeStamp ~= ogl timeStamp ifTrue:[ 		tstRays _ true.		timeStamp _ ogl timeStamp.		rayFrames do:[ :rf | rf resetSelected.].] ifFalse:[ tstRays _ false.].	renderedObjects _ 0.	ac transformClipPlanes.	cpt _ ac clipPlanesTransform.	currentCamTrans _ ac globalTransform copy.	ac pointer ifNotNil:[currentPointerTrans _ ac pointer globalTransform copy.].	currentCameraInv _ currentCamTrans orthoNormInverse.	ogl glLoadMatrixf: currentCameraInv transposed."------ The portals will have to be sorted here.... ------""------ Render the portals from back to front. ------"	ogl maxPortalDepth > depth ifTrue:[		renderPortals _ OrderedCollection new.	portalFrames do: [ :pf | 		" ------ don't recurse into yourself - very bad!! ------"		ogl currentPortal ~= pf ifTrue:[ 		 " ------ is the portal even visible? ------""xyzzy		pf visible: true."		pf visible ifTrue:[ 		" ------ portal facing camera?-----"		delta _ ac globalTransform translation - pf globalTransform translation.		(delta dot: pf lookAt) > 0 ifTrue:[		"------- is the portal inside the view frustum? ------"		pf boundSphere transform: pf globalTransform.		(ac testBounds: pf boundSphere) ifTrue:[			pf cameraDistance: delta squaredLength.			renderPortals add: pf.			]. "(ac testBounds: pf boundSphere) ifTrue:"		]. "(delta dot: pf lookAt)>0 ifTrue:"		]. "pf visible"		]. "ogl currentPortal = pf ifFalse:"		]. "portalFrames do:"		(renderPortals asArray sort:[:a1 :a2| a1 cameraDistance < a2 cameraDistance]) do: [:pf | 			ip _ ac inPortal.			ac inPortal: true.			renderedObjects _ renderedObjects + (pf render: ogl depth: depth). 			ac inPortal: ip.			" ------ restore the camera for the next go round ------ "			ac globalTransform: currentCamTrans.			ac clipPlanesTransform: cpt.].		]. "ogl maxPortalDepth > depth ifTrue:" "------ restore camera position and set up clip planes in this pose.------"	ac pointer ifNotNil:[ac pointer globalTransform: currentPointerTrans.].	ogl glLoadMatrixf: currentCameraInv transposed."------ Once we have rendered all of the subportals, if this is a portal, set its clip plane so that we don't render objects in front of the portal.------"	viewPort isPortal ifTrue:[ viewPort enableClipPlane: ogl].	" create a new array "		alphaObjects _ OrderedCollection new: 0. 	" turn on the lights and setup the fog "	self setupLights: ogl.	fogOn ifTrue:[ self setupFog: ogl. ].	" cull back faces if necessary."	self setCull: ogl.	tstRays ifTrue:[ self testRays: true.]."------ Render non-alpha geometry. While we are at it, find the alpha geometry for the next pass. All TFrames know how to do this, including TSpace. TSpace is a root frame (there is no THE root frame in TEA) so we need only call the TSpace >> renderFrame message to render everything inside of this. ------"	renderedObjects _ renderedObjects + (self renderFrame: ogl parent: self root: self).	"------ If there are any alpha objects, set render mode to alpha blending and make a second pass. Use alphaLength because alphaObjects size may be bigger than the actual objects rendered. ------"	(alphaObjects size ~= 0 or:[self forceAlpha])ifTrue:[		self renderSpaceAlpha: ogl transform: currentCamTrans.		].	0 to: 7 do:[ :index | 	ogl glDisable: GLLight0 + index.].	ogl glDisable: GLCullFace.	viewPort isPortal ifTrue:[viewPort disableClipPlane:ogl.].	fogOn ifTrue:[ ogl glDisable: GLFog.].	self testRays: false.	^ renderedObjects. "Return the number of objects we have rendered."! !!TSpace methodsFor: 'render' stamp: 'das 3/12/2004 14:02'!renderSpaceAlpha: ogl transform: currentCamTrans		| saveTransform |	saveTransform _ self currentTransform.	ogl glPushMatrix.	ogl glMultMatrixf: currentCamTrans transposed.	self setupAlpha: ogl."------ Sort the alphaObjects by distance - furthest first ------"	(alphaObjects asArray sort:[:a1 :a2|  a1 distance > a2 distance]) do: [:aObject | 		ogl glPushMatrix.		self currentTransform: aObject transform.		aObject transform ifNotNil:[			ogl glMultMatrixf: aObject transform.].		self currentParent: aObject parent.		aObject tObject renderAlpha: ogl.		ogl glPopMatrix.		].	self currentTransform: saveTransform."------ Set render mode back to original state. ------"	self currentParent: nil.	ogl glPopMatrix.	self restoreFromAlpha: ogl.! !!TSpace methodsFor: 'render' stamp: 'das 3/12/2004 14:02'!restoreFromAlpha: ogl	 ogl glDepthMask: GLTrue.	ogl glDisable: GLBlend.! !!TSpace methodsFor: 'render' stamp: 'das 3/12/2004 14:02'!setCull: ogl	self cullBackFaces ifTrue: [ogl glEnable: GLCullFace; glFrontFace: ogl frontFace.]	ifFalse: [ogl glDisable: GLCullFace.].! !!TSpace methodsFor: 'render' stamp: 'das 3/12/2004 14:02'!setupAlpha: ogl	ogl glEnable: GLBlend.	ogl glDepthMask: GLFalse. " set depth buffer to read only. "	ogl glBlendFunc: GLSrcAlpha with: GLOneMinusSrcAlpha.! !!TSpace methodsFor: 'render' stamp: 'das 3/12/2004 14:02'!setupFog: ogl	ogl		glEnable: GLFog;		glFogi: GLFogMode with: GLExp;		glFogfv: GLFogColor with:  (self fogColor asB3DColor);		glFogf: GLFogDensity with: fogDensity;		glHint: GLFogHint with: GLDontCare;		glFogf: GLFogStart with: fogStart;		glFogf: GLFogEnd with: fogEnd.! !!TSpace methodsFor: 'render' stamp: 'das 8/7/2004 14:22'!setupLights: ogl" Enable the closest six lights at full strength, set the next two as a ratio if distance squared, and ignore the rest. The ratios would work as follows:		distanceRatio _ 0.5 * furthest distance/closest distance.This guarantees the following:		distanceRatio is always less than 1.0.		if the two values are very close to each other, then the ratio is about 0.5 : 0.5.		if one is much closer than the other, then the ratio approaches 0.0 : 1.0."	| sortedFrames distanceRatio |	lightFrames size <= 8 ifTrue:[		lightFrames doWithIndex: [ :lf :i | lf enable: ogl index: i ].] 	ifFalse:[		lightFrames do:[ :lf | 			lf distance: (ogl camera globalPosition - lf globalPosition ) squaredLength.].		sortedFrames _ lightFrames sort:[ :a1 :a2 | a1 distance > a2 distance].		1 to: 6 do:[ :index | (sortedFrames at: index) enable: ogl index: index.].		distanceRatio _ 0.5* ((sortedFrames at: 8) distance)/((sortedFrames at: 7) distance).		(sortedFrames at: 7) enable: ogl index: 7 scaled: 1-distanceRatio.		(sortedFrames at: 8) enable: ogl index: 8 scaled: distanceRatio.	].! !!TSpace methodsFor: 'render' stamp: 'das 7/31/2004 11:43'!snapShot: ogl camera: cam	| rval saveSpace |	ogl glClearColor: self color red with: self color green with: self color blue with: 1.0.	ogl glClear: (GLColorBufferBit bitOr: (GLDepthBufferBit bitOr: GLStencilBufferBit)).	ogl glEnable: GLDepthTest.	self restoreFromAlpha: ogl.	ogl glDepthFunc: GLLess.	ogl glEnable: GLLighting.	saveSpace _ cam currentSpace.	cam currentSpace: self.	self doRender: ogl camera: cam.	ogl camera		killFrame: true; 		initFrustum: ogl.	ogl glEnable: GLLighting.	rval _ ogl screenShot: cam bounds.	cam currentSpace: saveSpace.	^ rval.! !!TSpace methodsFor: 'render' stamp: 'das 7/31/2004 11:43'!snapShot: ogl rectangle: rect atLoc: transform view: vAngle	| thumbCam trans |	" Put a camera into the proper location in the space. "		thumbCam _ TCamera new initializeWithViewPort: ogl camera viewPort.	thumbCam viewAngle: vAngle. 	thumbCam inPortal: true. "don't bother checking height and stuff."	thumbCam bounds: rect.	trans _ transform copy."---- flip the orientation 180 degrees from the direction of the transform matrix.---""	trans row1: (trans row1 negated).	trans row3: (trans row3 negated)."	thumbCam localTransform: trans.	thumbCam initClipPlanes.	^ self snapShot: ogl camera: thumbCam.! !!TSpace methodsFor: 'render' stamp: 'DPR 7/6/2004 15:47'!testRayFrames: bs	testRays ifTrue:[ rayFrames do:[ :rf | rf automatic ifTrue:[rf pick: bs.].].].! !!TSpace methodsFor: 'render' stamp: 'DPR 7/6/2004 16:00'!testRayFramesQuadTree: qt	testRays ifTrue:[ rayFrames do:[ :rf | (rf automatic and:[rf downRay]) ifTrue: [		rf currentFrame: qt.		qt quadPickFloor: rf location: rf globalPosition ].].].! !!TSpace methodsFor: 'properties' stamp: 'ar 10/28/2002 00:10'!eventsGenerated	^super eventsGenerated, #(		objectEnter objectLeave	)! !!TSpace methodsFor: 'fog properties' stamp: 'ar 10/26/2002 22:33'!fogColor	^color! !!TSpace methodsFor: 'fog properties' stamp: 'ar 10/26/2002 22:33'!fogColor: newColor	self color: newColor.! !!TSpace methodsFor: 'fog properties' stamp: 'ar 9/9/2002 14:22'!fogDensity	^ fogDensity.! !!TSpace methodsFor: 'fog properties' stamp: 'ar 9/9/2002 14:22'!fogDensity: fd	fogDensity _ fd.! !!TSpace methodsFor: 'fog properties' stamp: 'ar 9/9/2002 14:22'!fogEnd	^ fogEnd.! !!TSpace methodsFor: 'fog properties' stamp: 'ar 9/9/2002 14:22'!fogEnd: fe	fogEnd _ fe.! !!TSpace methodsFor: 'fog properties' stamp: 'ar 9/9/2002 14:22'!fogOn	^ fogOn.! !!TSpace methodsFor: 'fog properties' stamp: 'ar 9/9/2002 14:22'!fogOn: bool	fogOn _ bool.! !!TSpace methodsFor: 'fog properties' stamp: 'ar 9/9/2002 14:22'!fogStart	^ fogStart.! !!TSpace methodsFor: 'fog properties' stamp: 'ar 9/9/2002 14:22'!fogStart: fs	fogStart_ fs.! !!TSpace methodsFor: 'initialize' stamp: 'DPR 9/4/2004 18:14'!initialize	super initialize.	self color: (Color r: 0.7 g: 0.9 b: 1.0).		lightFrames _ OrderedCollection new: 0.	portalFrames _ OrderedCollection new: 0.	viewingParticipants _ IdentitySet new. "faster lookups than OrderedCollection"	rayFrames _ OrderedCollection new: 0.	savedAlphaObjects _ OrderedCollection new: 0. "alpha save stack"	alphaObjects _ OrderedCollection new: 0.	cullBackFaces _ true.	fogOn _ false.	fogStart _ 1.0.	fogEnd _ 100.0.	fogDensity _ 0.05.	testRays _ false.	^self! !!TSpace methodsFor: 'initialize' stamp: 'das 9/23/2004 16:00'!initializeInPlace: aCroquetPlace	croquetPlace _ aCroquetPlace.! !!TSpace methodsFor: 'testing' stamp: 'das 6/3/2003 21:50'!isSpace	^ true.! !!TSpace methodsFor: 'fileIn/Out' stamp: 'das 12/1/2002 12:38'!prepareToExportOn: exporter	super prepareToExportOn: exporter.	alphaObjects := nil.	currentParent := nil.! !!TCausticSpace methodsFor: 'render' stamp: 'das 10/18/2002 21:44'!forceAlpha 	^ true.! !!TCausticSpace methodsFor: 'render' stamp: 'das 7/31/2004 11:36'!restoreFromAlpha: ogl	| inPortal ac |	ac _ ogl camera.	inPortal _ ac inPortal.	ac inPortal: true.	self renderFrame: ogl parent: self root: self.	ac inPortal: inPortal.	counter ifNil:[^self].	ogl		glDepthMask: GLTrue;		glDisable: GLBlend;		glDepthFunc: GLLess;		glEnable: GLLighting;		glDisable: GLTextureGenS;		glDisable: GLTextureGenT;		changeTexture: true.	(caustics at: counter) disable: ogl.	counter _ counter + 1.	counter = 33 ifTrue:[counter _ 1.].! !!TCausticSpace methodsFor: 'render' stamp: 'das 7/1/2004 00:34'!setupAlpha: ogl	| sPlane tPlane saveTransform |	self disableCachingTree.	saveTransform _ self currentTransform.	ogl glEnable: GLBlend.	ogl glDepthMask: GLTrue. " set depth buffer to read only. "	ogl glBlendFunc: GLSrcAlpha with: GLOneMinusSrcAlpha.	(alphaObjects asArray sort:[:a1 :a2|  a1 distance > a2 distance]) do: [:aObject | 		ogl glPushMatrix.		self currentTransform: aObject transform.		aObject transform ifNotNil:[			ogl glMultMatrixf: aObject transform.].		self currentParent: aObject parent.		aObject tObject renderAlpha: ogl.		ogl glPopMatrix.		].	self currentTransform: saveTransform.	counter ifNil:[		(caustics anySatisfy:[:tex| tex isLoaded not]) ifTrue:[^self].		counter := 1.	].	sPlane _ #( 0.05  0.03 0.0 0.0 ) asFloatArray.	tPlane _ #( 0.0  0.03  0.05  0.0 ) asFloatArray.	sPlane _ sPlane * 4.0.	tPlane _ tPlane * 4.0.	ogl glEnable: GLBlend. 	ogl glDepthMask: GLFalse. " set depth buffer to read only. "     ogl glDepthFunc: GLEqual.	ogl glBlendFunc: GLZero with: GLSrcColor.    " ogl glBlendFunc: GLZero with: GLSrcColor."	ogl  glColor3f: 1.0 with: 1.0 with: 1.0.	ogl glDisable: GLLighting.    ogl glTexGeni: GLS with: GLTextureGenMode with: GLObjectLinear.    ogl glTexGeni: GLT with: GLTextureGenMode with: GLObjectLinear.    ogl glTexGenfv: GLS with: GLObjectPlane with: sPlane.    ogl glTexGenfv: GLT with: GLObjectPlane with: tPlane.    ogl glEnable: GLTextureGenS.    ogl glEnable: GLTextureGenT.	(caustics at: counter) enable: ogl.	ogl changeTexture: false.! !!TCausticSpace methodsFor: 'initialize' stamp: 'DPR 5/27/2004 09:55'!initialize	| caust fname |	super initialize.	counter _ 1.	caustics _ OrderedCollection new: 0. 	0 to: 31 do:[ :i |	fname _ 'caust'.	i<10 ifTrue:[fname_ fname,'0'.].	fname _ fname, i asString, '.BMP'.	caust _ TTexture				new initializeWithFileName: fname				mipmap: true				shrinkFit: false.	caustics add: caust.].! !!TCausticSpace methodsFor: 'fileIn/Out' stamp: 'ar 6/6/2002 20:27'!postImportFrom: importer	super postImportFrom: importer.	counter := nil. "so we know we need to check for caustics loading"! !!TSpaceBrowser methodsFor: 'menus' stamp: 'ar 10/10/2002 18:48'!addVariableIn: owner	owner addVariable.! !!TSpaceBrowser methodsFor: 'menus' stamp: 'ar 10/1/2004 14:17'!browseSelected	| selected newBrowser newWindow |	selected := self selectedFrame ifNil:[^self].	newBrowser := TSpaceBrowser new.	newWindow := newBrowser open.	newBrowser avatar: avatar.	newBrowser topFrame: selected.	window ifNil:[^self].	window owner addMorph: newWindow.	newWindow position: window position + 20.	^newWindow! !!TSpaceBrowser methodsFor: 'menus' stamp: 'das 1/4/2003 21:18'!destroyObject: anObject	anObject meta destroy.	self changed: #treeList.! !!TSpaceBrowser methodsFor: 'menus' stamp: 'ar 10/10/2002 18:48'!editScript: aSelector in: owner! !!TSpaceBrowser methodsFor: 'menus' stamp: 'ar 10/1/2004 14:17'!goNearSelected	| selected |	selected := self selectedFrame ifNil:[^self].	selected == avatar ifTrue:[^self].	avatar startScript:[		avatar turnTo: selected speed: 4.		avatar move: #forward distance: (selected distanceTo: avatar) - 10].! !!TSpaceBrowser methodsFor: 'menus' stamp: 'ar 10/12/2002 19:39'!removeBehavior: aBehavior	aBehavior detach.	self changed: #treeList.! !!TSpaceBrowser methodsFor: 'menus' stamp: 'ar 10/10/2002 18:49'!renameScript: aSelector in: owner	owner renameScript: aSelector.	self changed: #treeList.! !!TSpaceBrowser methodsFor: 'menus' stamp: 'das 1/5/2003 13:44'!stopScript: aSelector in: owner	owner meta stopScript: aSelector.	self changed: #treeList.! !!TSpaceBrowser methodsFor: 'menus' stamp: 'ar 10/2/2004 20:32'!treeMenu: aMenu	| menu |	aMenu defaultTarget: self.	self selectedFrame ifNotNil:[		aMenu addList: #(			-			('go  near'	#goNearSelected)			('turn to'	#turnToSelected)			-			"('destroy'	#destroySelected)"		).	].	self selectedFrameWrapper ifNotNil:[		self selectedFrameWrapper addMenuItemsTo: aMenu.	].	menu := MenuMorph new defaultTarget: self.	menu addList: #(		('browse'	#browseSelected)		('inspect'	#inspectSelected)	).	aMenu add: 'debug' subMenu: menu.	^aMenu! !!TSpaceBrowser methodsFor: 'menus' stamp: 'ar 10/1/2004 14:16'!turnToSelected	| selected  |	selected := self selectedFrame ifNil:[^self].	selected == avatar ifTrue:[^self].	avatar startScript:[avatar turnTo: selected speed: 4].! !!TSpaceBrowser methodsFor: 'initialize' stamp: 'ar 10/1/2004 14:19'!avatar: atar	avatar := atar.	self step.! !!TSpaceBrowser methodsFor: 'initialize' stamp: 'ar 10/10/2002 22:55'!buildTreeList	^(treePane := SimpleHierarchicalListMorphWithIcon		on: self		list: #treeList		selected: #selectedFrameWrapper		changeSelected: #selectedFrameWrapper:		menu: #treeMenu:		keystroke: nil) 	autoDeselect: true;	dragEnabled: true;	selectionHighlightColor: Color white;		borderStyle: ((BorderStyle inset) width: 1)! !!TSpaceBrowser methodsFor: 'initialize' stamp: 'ar 10/1/2004 14:17'!camera: ac	self avatar: ac avatar! !!TSpaceBrowser methodsFor: 'initialize' stamp: 'ar 10/25/2002 23:21'!open	| pref1 pref2 |	pref1 := Preferences inboardScrollbars.	pref2 := Preferences scrollBarsOnRight.	Preferences setPreference: #inboardScrollbars toValue: true.	Preferences setPreference: #scrollBarsOnRight toValue: true.	window := TWindowMorph new.	window model: self.	window frame alphaSlider hResizing: #spaceFill.	window model: self.	window content addMorph: (self buildTreeList) frame: (0@0 corner: 1@1).	window windowColor: self windowColor.	window label: 'Tea Browser'.	window extent: 180@250.	self runScript: #step when:{window. #step}.	Preferences setPreference: #inboardScrollbars toValue: pref1.	Preferences setPreference: #scrollBarsOnRight toValue: pref2.	World addMorphFront: window.	^window! !!TSpaceBrowser methodsFor: 'initialize' stamp: 'ar 9/8/2002 03:08'!windowColor	^Color blue! !!TSpaceBrowser methodsFor: 'stuff' stamp: 'ar 10/11/2002 02:04'!dragItemMorph: itemMorph from: aListMorph	| ddm |	ddm _ TransferMorph 		withPassenger: (itemMorph complexContents dropObject) 		from: aListMorph.	ddm dragTransferType: (itemMorph complexContents dropType).	^ddm! !!TSpaceBrowser methodsFor: 'stuff' stamp: 'ar 10/11/2002 01:56'!dragPassengerFor: item inMorph: dragSource 	^item complexContents dropObject! !!TSpaceBrowser methodsFor: 'stuff' stamp: 'ar 10/11/2002 02:02'!dragTransferTypeForMorph: dragSource! !!TSpaceBrowser methodsFor: 'stuff' stamp: 'ar 9/12/2002 17:48'!wantsDroppedMorph: transferMorph event: anEvent inMorph: destinationLM 	"We are only interested in TransferMorphs as wrappers for             	informations. If their content is really interesting for us, will             	determined later in >>acceptDroppingMorph:event:."	^true! !!TSpaceBrowser methodsFor: 'accessing' stamp: 'ar 9/8/2002 17:34'!inspectSelected	self selectedFrame inspect! !!TSpaceBrowser methodsFor: 'accessing' stamp: 'ar 9/13/2002 22:06'!selectedFrame	^selectedFrameWrapper ifNotNil:[selectedFrameWrapper frame]! !!TSpaceBrowser methodsFor: 'accessing' stamp: 'ar 9/8/2002 02:19'!selectedFrameWrapper	^selectedFrameWrapper! !!TSpaceBrowser methodsFor: 'accessing' stamp: 'ar 9/8/2002 02:48'!selectedFrameWrapper: aWrapper	selectedFrameWrapper := aWrapper.	self changed: #selectedFrameWrapper.	self signal: #selectedFrameChanged with: (self selectedFrame ifNil:[topFrame ifNil:[rootFrame]]).! !!TSpaceBrowser methodsFor: 'accessing' stamp: 'ar 10/10/2002 11:49'!selectedObject	^selectedFrameWrapper ifNotNil:[selectedFrameWrapper withoutListWrapper]! !!TSpaceBrowser methodsFor: 'accessing' stamp: 'ar 10/1/2004 14:15'!step	avatar ifNil:[^self].	avatar root == rootFrame ifFalse:[		rootFrame := avatar root.		self selectedFrameWrapper: nil.		self topFrame: topFrame.		treePane ifNotNil:[treePane addAlarm: #expandFirst after: 0]. "<-- ugly hack"		self changed: #treeList].! !!TSpaceBrowser methodsFor: 'accessing' stamp: 'ar 9/8/2002 02:34'!topFrame	^topFrame! !!TSpaceBrowser methodsFor: 'accessing' stamp: 'ar 10/4/2004 13:34'!topFrame: aFrame	topFrame := aFrame.	self changed: #treeList.	window ifNotNil:[window label: (topFrame ifNil:[rootFrame]) objectName].! !!TSpaceBrowser methodsFor: 'accessing' stamp: 'ar 10/1/2004 14:16'!treeList	avatar ifNil:[^#()].	topFrame ifNotNil:[^{TScriptorWrapper with: topFrame model: self}].	rootFrame ifNil:[rootFrame := avatar root].	^{TScriptorWrapper with: rootFrame model: self}	"^rootFrame frameChildren asArray collect:[:frame| TScriptorWrapper with: frame model: self]."! !!TSpaceImposter methodsFor: 'initialize' stamp: 'ar 10/4/2004 16:10'!generateView: spc transFrom: tf transTo: tt extent: ext	| ogl rect form txtr shrink smallForm file |	ogl _ CroquetGlobals theTeapotMorph ogl.	ogl ifNotNil: [		"We render 4x larger than we use, because we want to sample it down. This gives us a		 nicer picture with fewer pixelated artifacts."		rect _ 0@0corner:(pixWidth@pixWidth)*4.		form _ spc snapShot: ogl rectangle:rect atLoc: tf view: 90.		]		ifNil: [		file _ CroquetData findTextureFileName: 'checker.bmp'.		form _ Form fromFileNamed: file.		].	smallForm _ Form extent: pixWidth@pixWidth depth: 16.	form displayScaledOn: smallForm.	txtr _ TTexture new initializeWithForm: smallForm mipmap: true shrinkFit: false.	txtr material: material.	txtr extent: ext@ext.	txtr localTransform: tt.	txtr solid: false.	shrink _ (pixWidth - 1)/pixWidth.	txtr translation:  (tt localPointToGlobal: 0@0@((shrink*ext/-2.0))).	box addChild: txtr.! !!TSpaceImposter methodsFor: 'initialize' stamp: 'ar 9/30/2004 13:10'!initializeWithSpace: spc transform: transform	| ext tt trans orient |	material _ TMaterial new.	material fullBright: true.	material ambientColor: #(1.0 1.0 1.0 1.0)asFloatArray.	material diffuseColor: #(1.0 1.0 1.0 1.0)asFloatArray.	material emissiveColor: #(1.0 1.0 1.0 1.0)asFloatArray.	ext _ 164.	pixWidth _ 64.	space _ TSpace new.	space addChild: self.	box _ TGroup new.	box rotationAroundY:180.	space addChild: box.	trans _ transform translation.	orient _ transform orientation.	self renderOffscreen: [	self generateView: spc transFrom: transform transTo: B3DMatrix4x4 identity extent: ext.	tt _ B3DMatrix4x4 identity rotationAroundY:90.	self generateView: spc transFrom: ((orient composeWith: tt) translation: trans) 		transTo: tt extent: ext.	tt _ B3DMatrix4x4 identity rotationAroundY:180.	self generateView: spc transFrom: ((orient composeWith: tt) translation: trans) 		transTo: tt extent: ext.	tt _ B3DMatrix4x4 identity rotationAroundY:270.	self generateView: spc transFrom: ((orient composeWith: tt) translation: trans) 		transTo: tt extent: ext.	tt _ B3DMatrix4x4 identity rotationAroundX:90.	self generateView: spc transFrom: ((orient composeWith: tt) translation: trans) 		transTo: tt extent: ext.	tt _ B3DMatrix4x4 identity rotationAroundX:-90.	self generateView: spc transFrom: ((orient composeWith: tt) translation: trans) 		transTo: tt extent: ext.	].! !!TSpaceImposter methodsFor: 'initialize' stamp: 'ar 10/4/2004 16:06'!renderOffscreen: aBlock	aBlock value.	"| ogl |	ogl _ Processor activeProcess croquetWorld renderer ogl.	ogl ifNotNil: [		ogl renderWait: aBlock.		]		ifNil: [		aBlock value.		]."! !!TSpeaker methodsFor: 'accessing' stamp: 'das 4/11/2003 10:36'!color: col	color _ col.	frame colorize: color.! !!TSpeaker methodsFor: 'accessing' stamp: 'das 4/11/2003 10:36'!fadeDelay	^2500.0  "2.5 seconds"! !!TSpeaker methodsFor: 'action' stamp: 'ar 9/30/2004 15:11'!disable	animateTime _ TeaTime now + self fadeDelay.! !!TSpeaker methodsFor: 'action' stamp: 'das 4/11/2003 10:34'!enable	self color: TButton overColor.	frame solidVisibleTree: true. 	animateTime _ nil.! !!TSpeaker methodsFor: 'action' stamp: 'ar 9/30/2004 15:11'!signalVolume: str"	self color: TButton overColor copy."	self color: TButton hiliteColor copy.	frame solidVisibleTree: true. 	strength _ 0.25 + (2*str/ 32768.0).	strength > 0.99 ifTrue:[strength _ 0.99].	animateTime _ TeaTime now + self fadeDelay.	frame setAlpha: strength.! !!TSpeaker methodsFor: 'initialize' stamp: 'ar 9/30/2004 13:10'!initializeWithFrame: fr	frame _ fr.	frame ifNotNil:[ frame objectOwner: self.].	self addChild: frame.	self color: TButton normColor.	persist _ false.	frame solidVisibleTree: false.	animateTime _ nil.	enable _ false.	strength _ 1.0.	^self! !!TSpeaker methodsFor: 'testing' stamp: 'das 4/11/2003 10:33'!isComponent	^ true.! !!TSpeaker methodsFor: 'testing' stamp: 'das 4/11/2003 10:33'!isSolid	^ false.! !!TSpeaker methodsFor: 'stepping' stamp: 'ar 9/30/2004 15:10'!stepAt: msecs	"interpolate color"	| timeLeft |	animateTime ifNotNil: [		timeLeft _ animateTime - msecs.		timeLeft <= 0 ifTrue: [ 			animateTime _ nil. 			frame solidVisibleTree: false. 			]		ifFalse: [ color at: 4 put: strength * timeLeft asFloat / self fadeDelay.].		self color: color.		].! !!TSpeaker methodsFor: 'stepping' stamp: 'das 4/11/2003 10:36'!wantsSteps	^ true.! !!TSpellBox methodsFor: 'initialize' stamp: 'ar 9/30/2004 13:10'!initializeClass: class texture: txtr	| box |	box _ TCube new.	box texture: txtr.	box extent: (B3DVector3 x: 0.25 y: 0.25 z:0.25).	super initializeFrame: box.	self persist: true.	spellClass _ class.	^self! !!TSpellBox methodsFor: 'initialize' stamp: 'das 2/17/2004 16:29'!initializeWithFrame: frm class: class	super initializeWithFrame: frm.	spellClass _ class.	^self! !!TSpellBox methodsFor: 'events' stamp: 'das 5/23/2003 02:04'!pointerUp: pointer	(super pointerUp: pointer) ifTrue:[		pointer setSpell: spellClass.		].! !!TSphere methodsFor: 'accessing'!boundSphere	^ boundSphere.! !!TSphere methodsFor: 'accessing'!boundSphere: bndSphr	boundSphere _ bndSphr.! !!TSphere methodsFor: 'accessing'!localPosition	^ boundSphere localPosition.! !!TSphere methodsFor: 'accessing'!localPosition: pval	boundSphere localPosition: pval.	self boundsChanged.! !!TSphere methodsFor: 'accessing'!radius		^ boundSphere radius! !!TSphere methodsFor: 'accessing'!radius: rval	boundSphere radius: rval.	self boundsChanged.! !!TSphere methodsFor: 'accessing'!segments	^ segments! !!TSphere methodsFor: 'accessing'!segments: segs	segments _ segs! !!TSphere methodsFor: 'initialize' stamp: 'das 2/17/2004 16:30'!initialize	super initialize.	boundSphere _ TBoundSphere localPosition: (B3DVector3 new x:0.0 y:0.0 z:0.0) radius: 1.0.	boundSphere frame: self.	segments _ 10.	^self		! !!TSphere methodsFor: 'render'!pick: pointer	^ pointer pickSphere: self boundSphere localPosition 		radiusSquared: self boundSphere radiusSquared.! !!TSphere methodsFor: 'render' stamp: 'das 3/12/2004 14:02'!render: ogl sphere: bndSphr	| position radius ringSin ringCos pi2 seg2 vert rts rbs rtc rbc ax u du v dv |	position _ bndSphr localPosition.	radius _ bndSphr radius.	seg2 _ 1+ (segments * 2) .	ringSin _ FloatArray ofSize: seg2.	ringCos _ FloatArray ofSize: seg2.	vert _ B3DVector3 new.	pi2 _ Float pi *2.0.	1 to: seg2-1 do:[ :index | 		ax _ ((index) * pi2)/ (seg2-1).		ringSin at:index put: ax sin.		ringCos at:index put: ax cos.].	ringSin at: seg2 put: (ringSin at: 1).	ringCos at: seg2 put: (ringCos at: 1).	rts _ 0.0.	rtc _ 1.0.	rbs _ringSin at: 1.	rbc _ ringCos at: 1.	du _ 1.0/(seg2-1).	v _ 0.0.	dv _ 1.0/segments.	1 to: segments do:[ :iv |		ogl glBegin: GLTriangleStrip.		u _ 0.0.		1 to: seg2 do: [ :ih | 			vert x: rts*(ringSin at: ih) y: rtc z: rts*(ringCos at: ih).			ogl glNormal3fv: vert;				glTexCoord2f: u with: v;				glVertex3fv:  (vert * radius)+ position.			vert x: rbs*(ringSin at: ih) y: rbc z: rbs*(ringCos at: ih).			ogl glNormal3fv: vert;				glTexCoord2f: u with: v+dv;				glVertex3fv:  (vert * radius)+ position.			u_ u+du.].		v _ v+dv.		rts _ rbs.		rtc _ rbc.		rbs _ ringSin at: iv+1.		rbc _ ringCos at: iv+1.		ogl glEnd.].! !!TSphere methodsFor: 'render' stamp: 'das 3/12/2004 14:02'!renderPrimitive: ogl		self render: ogl sphere:boundSphere.! !!TSpinCube methodsFor: 'as yet unclassified' stamp: 'das 10/3/2004 14:03'!initialize	super initialize.	self spin: 0.! !!TSpinCube methodsFor: 'as yet unclassified' stamp: 'das 10/2/2004 17:30'!initialize: glX	super initialize: glX.	self spin: 0.! !!TSpinCube methodsFor: 'as yet unclassified' stamp: 'das 10/2/2004 17:13'!spin: ang	self rotationAroundY: ang.	self future:50 perform: #spin: withArguments: {ang+5}.! !!TSpinner methodsFor: 'events'!contents	^ contents.! !!TSpinner methodsFor: 'events' stamp: 'das 9/6/2004 20:49'!contents: cnt	contents ifNotNil:[		self removeChild: contents.].	contents _ cnt.	matNorm ifNotNil:[ contents material: matNorm. ].	contents objectOwner: self.	self addChild: contents.! !!TSpinner methodsFor: 'events' stamp: 'das 6/13/2002 13:41'!handlesKeyboard: pointer	^ contents handlesKeyboard: pointer.! !!TSpinner methodsFor: 'events'!handlesPointerDown: pointer	^ true.! !!TSpinner methodsFor: 'events'!handlesPointerOver: pointer	^ true.! !!TSpinner methodsFor: 'events'!pointerEnter: pointer	matOver ifNotNil:[		contents material: matOver.].	^ true.! !!TSpinner methodsFor: 'events'!pointerLeave: pointer 	matNorm ifNotNil:[		contents material: matNorm.].	^ true! !!TSpinner methodsFor: 'events' stamp: 'DPR 1/9/2004 14:05'!pointerMove: pointer	| delta trans |	pointer event2D shiftPressed ifTrue:[		(pointer frame: self pickPlane: selectedPoint normal: cameraNorm) ifTrue:[			delta _ selectedPoint - pointer selectedPoint.			self translation: (self translation - (self orientation localPointToGlobal: delta)).		^ true.]. ^ false.]."ROTATE AROUND"	pointer frame: self pickSphere: B3DVector3 new radiusSquared: selectedRadiusSquared.	lastSpin _ (self rotFromBallPoints: selectedPoint to: pointer selectedPoint) asMatrix4x4.		trans _ self translation.	self translationX: 0.0 y:0.0 z:0.0.	self localTransform: (self localTransform composeWith: lastSpin).	self translation: trans.	self localTransform: localTransform clone.	^ true.! !!TSpinner methodsFor: 'events'!pointerOver: pointer! !!TSpinner methodsFor: 'events' stamp: 'DPR 1/9/2004 14:05'!pointerUp: pointer	matNorm ifNotNil:[contents material: matNorm.].	tinyCube visible: false.	self spin: lastSpin.	lastSpin _  nil.	^ true.! !!TSpinner methodsFor: 'initialize' stamp: 'das 3/9/2004 14:44'!initialize	| matTiny |	super initialize.	matNorm _ TMaterial new.	matNorm ambientColor: #(0.5 0.7 0.7 0.5) asFloatArray.	matNorm diffuseColor: #(0.5 0.7 0.7 0.5) asFloatArray.	matOver _ TMaterial new.	matOver ambientColor: #(0.2 0.5 1.0 0.8) asFloatArray.	matOver diffuseColor: #(0.2 0.5 1.0 0.8) asFloatArray.	matDown _ TMaterial new.	matDown ambientColor: #(0.2 1.0 0.5 1.0) asFloatArray.	matDown diffuseColor: #(0.2 1.0 0.5 1.0) asFloatArray.	tinyCube _ TCube new.	tinyCube extentX: 0.05 y: 0.05 z: 0.05.	tinyCube visible: false.	matTiny _ TMaterial new.	matTiny ambientColor: #(1.0 1.0 0.2 1.0) asFloatArray.	matTiny diffuseColor: #(1.0 1.0 0.2 1.0) asFloatArray.	tinyCube material: matTiny.	tinyCube objectOwner: self.	self addChild: tinyCube.	^self! !!TSpinner methodsFor: 'initialize' stamp: 'das 6/13/2002 13:39'!keyDown: pointer		contents isComponent ifTrue:[ ^ contents keyDown: pointer.].	^ false.! !!TSpinner methodsFor: 'initialize' stamp: 'DPR 7/5/2004 20:02'!keyStroke: pointer		contents isComponent ifTrue:[ ^ contents keyStroke: pointer.].	^ false.! !!TSpinner methodsFor: 'initialize' stamp: 'DPR 1/9/2004 14:05'!pointerDown: pointer"	dalpha _ dalpha negated."	pointer event2D shiftPressed ifTrue:[].	selectedPoint _ pointer selectedPoint.	tinyCube translation: selectedPoint.	tinyCube visible: true.	matDown ifNotNil:[		contents material: matDown.		contents materialAlpha: nil.].	cameraNorm _ (pointer camera frameLookAt: self) negated.	selectedNorm _ pointer selectedNormal.	selectedRadiusSquared _ selectedPoint dot: selectedPoint.	self spin: nil.	self localTransform: self localTransform.	^ true.! !!TSpinner methodsFor: 'testing'!isComponent	^ true.! !!TSpinner methodsFor: 'accessing'!matDown		^ matDown.! !!TSpinner methodsFor: 'accessing'!matDown: md		matDown_ md.! !!TSpinner methodsFor: 'accessing'!matNil	matOver _ nil.	matDown _ nil.	matNorm _ nil.! !!TSpinner methodsFor: 'accessing'!matNorm		^ matNorm.! !!TSpinner methodsFor: 'accessing'!matNorm: mn		matNorm _ mn.! !!TSpinner methodsFor: 'accessing'!matOver		^ matOver.! !!TSpinner methodsFor: 'accessing'!matOver: mo		matOver_ mo.! !!TSpinner methodsFor: 'accessing'!spin	^spin! !!TSpinner methodsFor: 'accessing'!spin: aNumber	spin _ aNumber.! !!TSpinner methodsFor: 'stepping' stamp: 'das 9/22/2003 12:27'!stepAt: msecs	| trans ticks transform |"hack approximation:  spin as many times as there would have been 20 msec ticks in the last time interval"		spin ifNotNil:[ 		ticks _ (msecs - self lastStepTime // 20).		trans _ self translation.		self translationX: 0.0 y:0.0 z:0.0.		transform _ self localTransform.		( ticks > 0 ) ifTrue: [ transform _ transform composeWith: spin times: ticks.].		self localTransform: transform.		self translation: trans.	].! !!TSpinner methodsFor: 'stepping'!wantsSteps	^ true.! !!TSpreadSheet methodsFor: 'initialize' stamp: 'das 8/15/2004 19:48'!initialize	super initialize.	self initializeWithWorld: nil extent: 1024@768.	self color: Color transparent.	spreadSheet _ SpreadSheet new.	spreadSheet tSpreadSheet: self.	self addMorph: spreadSheet.! !!TSpreadSheet methodsFor: 'actions' stamp: 'ar 10/1/2004 12:45'!selectField: field	self selectFields: {field}.! !!TSpreadSheet methodsFor: 'actions' stamp: 'das 8/17/2004 12:43'!selectFields: fields	| val tfield |	tfield _ OrderedCollection new.	fields do:[ :field |		val _ field text asNumber.		val ifNotNil:[			tfield add: (field bounds->val).		].	].	eventsTo ifNotNil: [eventsTo future: 0.0 perform: #selectField: withArguments: { tfield }.].! !!TSpreadSheet methodsFor: 'actions' stamp: 'das 8/17/2004 13:01'!updateField: field	self sendDamage: field bounds.! !!TSuburban methodsFor: 'events' stamp: 'das 12/27/2002 14:48'!handlesKeyboard: pointer^ true.! !!TSuburban methodsFor: 'events' stamp: 'das 12/27/2002 14:48'!handlesPointerDown: pointer	^ true.! !!TSuburban methodsFor: 'events' stamp: 'ar 9/30/2004 16:14'!keyDown: pointer	| c tframe |	c _ pointer event2D keyValue.	c = 30 ifTrue:[ "move forward" 		self meta setSpeed: (speed + deltaSpeed).		inControl _ true.		].	c = 31 ifTrue:[ "move backwards" 		self meta setSpeed: (speed - deltaSpeed).		inControl _ true.		].	c = 28 ifTrue:[ "turn left" 		self meta setTurn: (turn + 1).		inControl _ true.		].	c = 29 ifTrue:[ "turn right" 		self meta setTurn: (turn - 1).		inControl _ true.		].	c = 32 ifTrue:[ "stop" 		self meta stop.		inControl _ true.		].	c = ($t asInteger) ifTrue:[ "transparency"		self meta switchTransparency.		inControl _ true.		].	c = ($c asInteger) ifTrue:[		tframe _ TSuburban meta new initializeWithTerrain: terrain.		tframe meta translation: (self translation)+(10@0@0).		self parent meta addChild: tframe.		].		! !!TSuburban methodsFor: 'events' stamp: 'DPR 7/5/2004 20:02'!keyStroke: pointer	| c tframe |	c _ pointer event2D keyValue.	c = 30 ifTrue:[ "move forward" 		self setSpeed: (speed + deltaSpeed).		inControl _ true.		].	c = 31 ifTrue:[ "move backwards" 		self setSpeed: (speed - deltaSpeed).		inControl _ true.		].	c = 28 ifTrue:[ "turn left" 		self setTurn: (turn + 1).		inControl _ true.		].	c = 29 ifTrue:[ "turn right" 		self setTurn: (turn - 1).		inControl _ true.		].	c = 32 ifTrue:[ "stop" 		self stop.		inControl _ true.		].	c = ($t asInteger) ifTrue:[ "transparency"		self switchTransparency.		inControl _ true.		].	c = ($c asInteger) ifTrue:[		tframe _ TSuburban new initializeWithTerrain: terrain.		tframe translation: (self translation)+(10@0@0).		self parent addChild: tframe.		].		! !!TSuburban methodsFor: 'events' stamp: 'ar 1/3/2003 13:44'!openLeftDoor: door	| evt |	door turn: #right turns: 0.2.	[evt := self waitUntil: #closeLeftDoor.	evt arguments first == door] whileFalse.	door turn: #left turns: 0.2.! !!TSuburban methodsFor: 'events' stamp: 'ar 1/3/2003 13:52'!openRightDoor: door	| evt |	door turn: #left turns: 0.2.	[evt := self waitUntil: #closeRightDoor.	evt arguments first == door] whileFalse.	door turn: #right turns: 0.2.! !!TSuburban methodsFor: 'events' stamp: 'das 7/31/2004 11:21'!pointerDown: pointer	| trns obj av |	obj := pointer selectedFrame.	obj ifNotNil:[		(obj objectName = 'LeftFrontDoor01') ifTrue:[			self startScript: #openRightDoor: withArguments:{obj parent}.			self signal: #closeRightDoor with: obj parent.			^true].		(obj objectName = 'SideDoor01') ifTrue:[			self startScript: #openRightDoor: withArguments:{obj parent}.			self signal: #closeRightDoor with: obj parent.			^true].		(obj objectName = 'LeftFrontDoor') ifTrue:[			self startScript: #openLeftDoor: withArguments:{obj parent}.			self signal: #closeLeftDoor with: obj parent.			^true].		(obj objectName = 'SideDoor03') ifTrue:[			self startScript: #openLeftDoor: withArguments:{obj parent}.			self signal: #closeLeftDoor with: obj parent.			^true].	].	av _ pointer avatar.	(av isChild: self root) ifTrue:[		trns _ self globalTransform orthoNormInverse composeWith: av globalTransform.		av downPointer setAutomatic: false.		av parent removeChild: av.		self addChild: av.		av localTransform: trns.		] ifFalse:[		(av isChild: self) ifTrue:[			av downPointer setAutomatic: false.			av parent removeChild: av.			car addChild: av.			av localTransform: (B3DMatrix4x4 identity).			av translation: (B3DVector3 x:-1.2 y: 1.6 z: -0.1).			] ifFalse:[ 			(av isChild: car) ifTrue:[			av translationX: -5 y:2 z: -0.1.			av localTransform:av globalTransform.			av downPointer setAutomatic: true.			av parent removeChild: av.			self root addChild: av.			]		]	].	^ true.! !!TSuburban methodsFor: 'events' stamp: 'das 12/27/2002 14:48'!pointerUp: pointer	^ true.! !!TSuburban methodsFor: 'initialize' stamp: 'DPR 5/18/2004 14:27'!initializeWithTerrain: ter	| ray |	super initialize.	terrain _ ter.	car _ (CroquetData loadURL: 'http://www.reed.com/TeaLand/spaces/theSuburban.tea' reuseExisting: false) .	car ifNil:[		car _ (TLoad3DSMax new initializeWithFileName: (FileDirectory pathFrom: {FileDirectory default pathName. 'Content'. 'Suburban'. 'Suburban.ASE'}) scale: 0.00125 ) frame.		car translationX: 0 y:0 z:0.		car boundsDepth: 3.		car initBounds.		TExporter export: car asBinary:'http://www.reed.com/TeaLand/spaces/theSuburban.tea'.		].	car collapse.		self addChild: car.	car objectOwner: self.	sensors _ OrderedCollection new.	car do:[ :frm | (frm objectName beginsWith:'$sensor') ifTrue: [		sensors add: frm. 		frm transparency: 0.0.		frm visible: false.		].].		wheels _ OrderedCollection new.	wheels add: ((car find:[:frm | frm objectName = 'TireFrontRight']) at: 1).	wheels add: ((car find:[:frm | frm objectName = 'TireFrontLeft']) at: 1).	wheels add: ((car find:[:frm | frm objectName = 'TireRearRight']) at: 1).	wheels add: ((car find:[:frm | frm objectName = 'TireRearLeft']) at: 1).	wheelRays _ OrderedCollection new.	wheels do:[ :w | 		w setSolid: false.		ray _ TRay new.		ray downRay: true.		ray translation: w globalPosition - self globalPosition.		wheelRays add: ray.		self addChild: ray.		ray setAutomatic: false.		]. 	wheelRadius _ (wheels at: 1)frameBox extent z/2.0.	wheelBase _ ((wheels at: 1) globalPosition - (wheels at: 3) globalPosition) length.	axleLength _((wheels at: 1) globalPosition - (wheels at: 2) globalPosition) length.	axles _ OrderedCollection new.	axles add: ((car find:[:frm | frm objectName = 'FrontRightWheelGroup']) at: 1).	axles add: ((car find:[:frm | frm objectName = 'FrontLeftWheelGroup']) at: 1).	axles add: ((car find:[:frm | frm objectName = 'RearRightWheelGroup']) at: 1).	axles add: ((car find:[:frm | frm objectName = 'RearLeftWheelGroup']) at: 1).	pivots _ OrderedCollection new.	pivots add: ((car find:[:frm | frm objectName = 'FrontRightTirePivot']) at: 1).	pivots add: ((car find:[:frm | frm objectName = 'FrontLeftTirePivot']) at: 1).	pivots add: ((car find:[:frm | frm objectName = 'RearRightTirePivot']) at: 1).	pivots add: ((car find:[:frm | frm objectName = 'RearLeftTirePivot']) at: 1).	frontTurn _ OrderedCollection new.	frontTurn add:((car find:[:frm | frm objectName = 'FrontRightTireSteer']) at: 1).	frontTurn add:((car find:[:frm | frm objectName = 'FrontLeftTireSteer']) at: 1)."	rearTurn _ OrderedCollection new.	rearTurn add:((car find:[:frm | frm objectName = 'LRearWhlAssembly']) at: 1).	rearTurn add:((car find:[:frm | frm objectName = 'RRearWhlAssembly']) at: 1).	leftFrontPair _ ((car find:[:frm | frm objectName = 'LFrtWheelPair']) at: 1).	rightFrontPair  _ ((car find:[:frm | frm objectName = 'RFrtWheelPair']) at: 1).	leftSide _ OrderedCollection new.	leftSide add:((car find:[:frm | frm objectName = 'LFrontWheelGroup']) at: 1).	leftSide add:((car find:[:frm | frm objectName = 'LRearWheelGroup']) at: 1).	rightSide _ OrderedCollection new.	rightSide add:((car find:[:frm | frm objectName = 'RFrontWheelGroup']) at: 1).	rightSide add:((car find:[:frm | frm objectName = 'LRearWheelGroup']) at: 1)."	speed _ 0.0.	wheelRotSpeed _ 0.0.	wheelAngle _ 0.0.	deltaSpeed _ 0.02.	turn _ 0.0.	turnAngle _ 0.	turnSpeed _ 0.0.	v1 _ ((wheelRays at: 1) translation) - ((wheelRays at: 4) translation).	v2 _ ((wheelRays at: 2) translation) - ((wheelRays at: 3) translation)."	v1 _ (wheels at: 1) globalPosition - (wheels at: 2) globalPosition.	v2 _ leftFrontPair globalPosition - (wheels at:2) globalPosition.	v3 _ leftFrontPair globalPosition - (wheels at:3) globalPosition.	vlr _ (leftSide at: 1) globalPosition - (rightSide at: 1) globalPosition."	maxTrans _ 20.	trans _ maxTrans.	deltaTrans _ 0.	inControl _ false.	^self! !!TSuburban methodsFor: 'testing' stamp: 'das 12/27/2002 14:48'!isComponent	^ true.! !!TSuburban methodsFor: 'accessing' stamp: 'das 1/3/2003 09:20'!setSpeed: spd	speed _ spd.	speed abs < (deltaSpeed/2.0) ifTrue:[speed _ 0.0].	wheelRotSpeed _ (speed/wheelRadius) radiansToDegrees negated.	self updateTurn.	inControl _ false.! !!TSuburban methodsFor: 'accessing' stamp: 'das 1/3/2003 09:32'!setTurn: trn	turn _ trn.	turn > 30 ifTrue:[turn _ 30].	turn < -30 ifTrue:[turn _ -30].	frontTurn do:[ :ft | ft rotationAroundY: turn.].	self updateTurn.	inControl _ false.! !!TSuburban methodsFor: 'accessing' stamp: 'das 1/3/2003 09:20'!stop	speed _ 0.0.	wheelRotSpeed _ 0.0.	turnSpeed _ 0.0.	self updateTurn.	inControl _ false.! !!TSuburban methodsFor: 'accessing' stamp: 'das 1/3/2003 09:20'!switchTransparency	trans = maxTrans ifTrue:[deltaTrans _ -1].	trans = (maxTrans//5) ifTrue:[deltaTrans _ 1].	inControl _ false.! !!TSuburban methodsFor: 'accessing' stamp: 'das 1/3/2003 07:42'!turnAngle	^ turnAngle.! !!TSuburban methodsFor: 'accessing' stamp: 'das 1/3/2003 09:14'!turnAngle: ta	turnAngle _ ta.	self rotationAroundY: ta.! !!TSuburban methodsFor: 'accessing' stamp: 'das 1/3/2003 09:13'!updateTurn	| turn2 turnRadius |	turn = 0 ifTrue:[turnSpeed _ 0.] ifFalse:[		turn2 _ turn/2.0.		turn2 > 0 ifTrue:[ turnRadius _ (wheelBase/2.0) * ((90-turn2) degreesToRadians tan).]		ifFalse:[turnRadius _ (wheelBase/2.0) * ((90+turn2) degreesToRadians tan negated).].		turnSpeed _ (speed/turnRadius) radiansToDegrees.		].! !!TSuburban methodsFor: 'stepping' stamp: 'ar 9/30/2004 15:10'!stepAt: currentTime	| tval yArray yTot y dv1 dv2 up side orient secs |"This is a quick and dirty method to get the vehicle to look about right as it moves over the terrain. Still have to deal with the shocks, but I think this is good enough for now."	lastTime ifNil:[ lastTime _ currentTime. updateTime _ currentTime. ^ self.].	secs _ (currentTime - lastTime) asFloat /1000.0.	lastTime _ currentTime."	frameNumber =  lastFrameNumber ifTrue:[^ self.].	lastFrameNumber _ frameNumber."speed ~= 0.0  ifTrue:[	wheelAngle _ wheelAngle + (wheelRotSpeed*secs).	turnAngle _ turnAngle + (turnSpeed*secs).	turnAngle > 360 ifTrue:[ turnAngle _ turnAngle - 360.].	turnAngle < 0 ifTrue:[ turnAngle _ turnAngle + 360].	wheels do:[ :w | w rotationAroundX: wheelAngle.].	self translation: self translation+(self globalTransform column3*speed negated*secs).	self rotationAroundY: turnAngle.	yArray _ Array ofSize: 4.	yTot _ 0.0.	wheelRays doWithIndex:[ :wr :index | 		wr resetTotal.		wr pointerPickFloor: terrain.		wr selectedDistance ~= Float infinity ifTrue:[			y _ wr selectedDistance - wheelRadius.			] ifFalse:[ y _ wheelRadius negated.].			yTot _ yTot + y.			yArray at: index put: y.		].	self translation: (self translation - (0.0@(yTot/4.0)@0.0)).	dv1 _ v1 copy.	dv1 y: (yArray at:1) - (yArray at: 4).	dv2 _ v2 copy.	dv2 y: (yArray at: 2) - (yArray at:3).	up _ (dv1 cross: dv2) normalized.	side _ (dv1 - dv2)normalized.	orient _ B3DMatrix4x4 new.		orient row1: side.	orient row2: up.	orient row3: (side  cross: up).	orient a44:1.0.	car orientation: orient.	]."	(wheelRays at:1) selectedDistance ~= Float infinity ifTrue:[		yloc _ Array ofSize: 6.		1 to: 6 do:[:index |			yloc at: index put: ((wheels at: index) globalPosition y) - 				((wheelRays at: index) selectedDistance - wheelRadius).].				dv _ v1 copy.		dv y: (yloc at:2) -(yloc at:1).		a1 _ v1 angleTo: dv.		dv y > v1 y ifTrue:[a1 _ a1 negated].		py _ (yloc at: 2) + (v2 x * (a1 sin)) + (v2 y * (a1 cos)).		dv _ v3 copy.		dv y: py - (yloc at: 3).		a2 _ v3 angleTo: dv.		dv y < v3 y ifTrue:[ a2 _ a2 negated].		a1 _ (a1 - a2) radiansToDegrees.		a2 _ a2 radiansToDegrees.		leftFrontPair rotationAroundZ:  a1.		(leftSide at: 1) rotationAroundZ: a2.		(leftSide at: 2) rotationAroundZ: a2.		dv _ v1 copy.		dv y: (yloc at:5) -(yloc at:4).		a1 _ v1 angleTo: dv.		dv y > v1 y ifTrue:[a1 _ a1 negated].		py _ (yloc at: 5) + (v2 x * (a1 sin)) + (v2 y * (a1 cos)).		dv _ v3 copy.		dv y: py - (yloc at: 6).		a2 _ v3 angleTo: dv.		dv y < v3 y ifTrue:[ a2 _ a2 negated].		a1 _ (a1 - a2) radiansToDegrees.		a2 _ a2 radiansToDegrees.		rightFrontPair rotationAroundZ:  a1.		(rightSide at: 1) rotationAroundZ: a2.		(rightSide at: 2) rotationAroundZ: a2.		py _ (wheelRays at: 3) selectedDistance + ((wheelRays at:6) selectedDistance)/2.0.		self translation: (self translation - (0@(py - wheelRadius)@0)).		]."	deltaTrans = 0 ifFalse:[		trans _ trans + deltaTrans.		tval _ trans/maxTrans asFloat.		self transparency: tval.		tval _ 1.0 - tval.		sensors do:[:s | s transparency: tval. tval = 0.0 ifFalse:[s visible:true.] ifTrue:[s visible: false]].		trans = (maxTrans//5) ifTrue:[deltaTrans _ 0].		trans = maxTrans ifTrue:[deltaTrans _ 0].		].	(currentTime - updateTime) asFloat > 500 ifTrue:[		updateTime _ currentTime.		inControl ifTrue:[ self metaSend localTransform: self localTransform].		].! !!TSuburban methodsFor: 'stepping' stamp: 'das 12/27/2002 14:48'!wantsSteps	^ true.! !!TSwarm methodsFor: 'initialize' stamp: 'das 2/20/2004 10:49'!initialize		| ray cone |	super initialize.	ray _ TRay new.	ray downRay: true."	ray rotationAroundX: -90."	self addChild: ray.	cone _ TCylinder new.	cone baseRadius: 0.	cone topRadius: 2.	cone height: 2.	cone translationX: 0 y:0 z: 0.001.	self addChild: cone.	^self! !!TSwarm methodsFor: 'testing' stamp: 'das 12/1/2002 14:48'!isComponent	^ true.! !!TTeapot methodsFor: 'render'!glTeapot: renderer gridSize: grid self glTeapot: renderer gridSize: grid scale: 0.5 type: GLFill.! !!TTeapot methodsFor: 'render'!glTeapot: renderer gridSize: grid scale: sc type: tp	| tex |	renderer glPushMatrix.	renderer 		glRotatef: 270.0 		with: 1.0		with: 0.0		with: 0.0.	renderer		glScalef: sc  * 0.28		with: sc * 0.28		with: sc * 0.28.	renderer		glTranslatef: 0 				with: 0 				with:  -1.5. 	tex _ #(0 0 1 0 0 1 1 1) asFloatArray." construction settings. "	renderer		glPushAttrib: (GLEnableBit bitOr: GLEvalBit).	renderer glEnable: GLAutoNormal.	renderer glEnable: GLNormalize.	renderer glEnable: GLMap2Vertex3. 	renderer glEnable: GLMap2TextureCoord2.	patches		do: [:p |    			renderer glMap2f: GLMap2TextureCoord2 				with: 0 with: 1 with: 2 with: 2 with: 0 with: 1 with: 4 with: 2 with: tex.			renderer				glMap2f: GLMap2Vertex3				with: 0				with: 1				with: 3				with: 4				with: 0				with: 1				with: 12				with: 4				with: p.			renderer				glMapGrid2f: grid				with: 0.0				with: 1.0				with: grid				with: 0.0				with: 1.0.			renderer				glEvalMesh2: tp				with: 0				with: grid				with: 0				with: grid].	renderer glPopMatrix.	renderer glPopAttrib.! !!TTeapot methodsFor: 'render' stamp: 'das 3/9/2004 14:47'!initBounds	| v v3 minCorner maxCorner center dimension radiusSquared testRad |	v _ self vertexData.	minCorner _ B3DVector3				x: Float infinity				y: Float infinity				z: Float infinity.	maxCorner _ B3DVector3				x: Float infinity negated				y: Float infinity negated				z: Float infinity negated.	dimension _ 1.	v do: [:vertex | 			dimension = 1				ifTrue: [vertex < minCorner x						ifTrue: [minCorner x: vertex].					vertex > maxCorner x						ifTrue: [maxCorner x: vertex].].			dimension = 2				ifTrue: [vertex < minCorner y						ifTrue: [minCorner y: vertex].					vertex > maxCorner y						ifTrue: [maxCorner y: vertex].].			dimension = 3				ifTrue: [vertex < minCorner z						ifTrue: [minCorner z: vertex].					vertex > maxCorner z						ifTrue: [maxCorner z: vertex].].			dimension _ dimension+1.			dimension = 4 ifTrue:[dimension _ 1].].	dimension = 1.	v3 _B3DVector3 new.	center _ (maxCorner + minCorner)/2.0.	radiusSquared _ 0.		v do: [:vertex |		dimension = 1 ifTrue:[v3 x: vertex.].		dimension = 2 ifTrue:[v3 y: vertex.].		dimension = 3 ifTrue:[v3 z: vertex.				testRad _ (v3-center)squaredLength.				radiusSquared < testRad ifTrue:[radiusSquared_testRad].].		dimension _ dimension+1.		dimension = 4 ifTrue:[dimension _ 1].].			boundSphere _ TBoundSphere localPosition: B3DVector3 new			radius: scale * 0.6 * 0.28 * (radiusSquared sqrt).	boundSphere frame: self.! !!TTeapot methodsFor: 'render'!pick: pointer	^ pointer pickSphere: self boundSphere localPosition 		radiusSquared: self boundSphere radiusSquared.! !!TTeapot methodsFor: 'render' stamp: 'das 3/12/2004 14:03'!renderPrimitive: ogl	| tex  |	ogl glPushMatrix.	ogl 		glRotatef: 270.0 		with: 1.0		with: 0.0		with: 0.0.	ogl		glScalef: scale  * 0.28		with: scale * 0.28		with: scale * 0.28.	ogl		glTranslatef: 0 				with: 0 				with:  -1.5. 	tex _ #(0 0 1 0 0 1 1 1) asFloatArray.		" construction settings. "	ogl		glPushAttrib: (GLEnableBit bitOr: GLEvalBit).	ogl glEnable: GLAutoNormal.	ogl glEnable: GLNormalize.	ogl glEnable: GLMap2Vertex3. 	ogl glEnable: GLMap2TextureCoord2.	patches		do: [:p |    			ogl glMap2f: GLMap2TextureCoord2 				with: 0 with: 1 with: 2 with: 2 with: 0 with: 1 with: 4 with: 2 with: tex.			ogl				glMap2f: GLMap2Vertex3				with: 1				with: 0				with: 3				with: 4				with: 0				with: 1				with: 12				with: 4				with: p.			ogl				glMapGrid2f: gridSize				with: 0.0				with: 1.0				with: gridSize				with: 0.0				with: 1.0.			ogl				glEvalMesh2: type				with: 0				with: gridSize				with: 0				with: gridSize].	ogl glPopMatrix.	ogl glPopAttrib.! !!TTeapot methodsFor: 'accessing'!gridSize	^ gridSize.! !!TTeapot methodsFor: 'accessing'!gridSize: gs	gridSize _ gs.! !!TTeapot methodsFor: 'accessing'!scale	^ scale.! !!TTeapot methodsFor: 'accessing'!scale: sc	scale _ sc.	self boundsChanged.! !!TTeapot methodsFor: 'accessing'!type	^ type.! !!TTeapot methodsFor: 'accessing'!type: tp	type _ tp.! !!TTeapot methodsFor: 'initialize' stamp: 'das 2/17/2004 16:31'!initialize	| glp v |	super initialize.	patches _ OrderedCollection new.	v_ self vertexData.	gridSize _ 10.	scale _ 0.5.	type _ GLFill.	(self patchData) doWithIndex: [:pdata :index| 		glp _ TPatch new. 		glp patch: pdata vertex: v.		patches add: glp.		patches add: glp mirrorY.		index <= 6 ifTrue:[		patches add: glp mirrorX.		patches add: glp mirrorX mirrorY.]].	^ self.		! !!TTeapot methodsFor: 'initialize'!patchData| p |p _ OrderedCollection new.p" rim"	add: #(102 103 104 105 4 5 6 7 8 9 10 11 12 13 14 15) asIntegerArray;  " body " 	add: #(12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27) asIntegerArray;  	add: #(24 25 26 27 29 30 31 32 33 34 35 36 37 38 39 40) asIntegerArray; " lid "  	add: #(96 96 96 96 97 98 99 100 101 101 101 101 0 1 2 3) asIntegerArray;	add: #(0 1 2 3 106 107 108 109 110 111 112 113 114 115 116 117) asIntegerArray;  " bottom "	add: #(118 118 118 118 124 122 119 121 123 126 125 120 40 39 38 37) asIntegerArray; " handle "	add: #(41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56) asIntegerArray;  	add: #(53 54 55 56 57 58 59 60 61 62 63 64 28 65 66 67) asIntegerArray; " spout "  	add: #(68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83) asIntegerArray;  	add: #(80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95) asIntegerArray.^p.! !!TTeapot methodsFor: 'initialize'!vertexData^#(0.2 0.0 2.7		0.2 -0.112  2.7		0.112  -0.2  2.7		0.0 -0.2  2.71.3375  0  2.53125	1.3375  -0.749  2.531250.749  -1.3375  2.531250  -1.3375  2.531251.4375 0  2.531251.4375  -0.805  2.531250.805  -1.4375 2.531250  -1.4375  2.531251.5  0  2.41.5   -0.84 2.40.84  -1.5  2.40  -1.5  2.41.75  0  1.8751.75  -0.98  1.8750.98  -1.75  1.8750  -1.75  1.8752  0  1.352  -1.12  1.351.12  -2  1.350  -2  1.352  0  0.92  -1.12  0.91.12  -2  0.9 0  -2  0.9-2  0  0.92  0  0.452  -1.12   0.451.12  -2  0.450  -2  0.451.5  0  0.2251.5  -0.84  0.2250.84  -1.5  0.2250  -1.5  0.2251.5  0  0.151.5  -0.84  0.150.84  -1.5  0.150  -1.5  0.15-1.6  0  2.025-1.6  -0.3  2.025-1.5   -0.3  2.25-1.5  0  2.25-2.3  0  2.025-2.3  -0.3   2.025-2.5  -0.3  2.25-2.5  0  2.25-2.7  0  2.025-2.7  -0.3  2.025-3  -0.3  2.25-3   0   2.25-2.7  0  1.8-2.7  -0.3  1.8-3  -0.3  1.8-3  0  1.8-2.7  0  1.575-2.7   -0.3  1.575-3  -0.3  1.35-3  0  1.35-2.5  0  1.125-2.5  -0.3  1.125-2.65  -0.3  0.9375-2.65  0  0.9375-2  -0.3  0.9-1.9  -0.3  0.6-1.9  0  0.61.7  0   1.4251.7  -0.66  1.4251.7  -0.66  0.61.7  0  0.62.6  0  1.4252.6  -0.66  1.4253.1  -0.66   0.8253.1  0  0.8252.3  0  2.12.3  -0.25  2.12.4  -0.25  2.0252.4  0  2.0252.7  0  2.42.7   -0.25  2.43.3  -0.25  2.43.3   0  2.42.8  0   2.4752.8  -0.25  2.4753.525  -0.25  2.493753.525  0  2.493752.9  0   2.4752.9  -0.15  2.4753.45  -0.15  2.51253.45  0  2.51252.8  0  2.42.8  -0.15  2.43.2  -0.15  2.43.2  0  2.40  0  3.150.8  0  3.150.8  -0.45  3.150.45  -0.8   3.150  -0.8  3.150  0  2.851.4  0  2.41.4    -0.784  2.40.784  -1.4  2.40   -1.4  2.40.4  0  2.550.4  -0.224  2.550.224  -0.4  2.550  -0.4  2.551.3  0  2.551.3   -0.728  2.550.728  -1.3   2.550  -1.3  2.551.3  0   2.41.3  -0.728  2.40.728  -1.3  2.40  -1.3  2.40  0  01.425  -0.798  01.5  0  0.0751.425   0  00.798  -1.425    00  -1.5  0.0750   -1.425  01.5  -0.84  0.0750.84  -1.5  0.075) asFloatArray.! !!TTensor methodsFor: 'initialize' stamp: 'das 4/17/2002 17:59'!addFaces: fcs vertices: verts	faces _ fcs.	vertices _ verts.	self volumeIntegrate.	notDone _ true.! !!TTensor methodsFor: 'initialize' stamp: 'das 5/1/2002 13:54'!initialize	mass _ 1.0.	t0 _ 0.0.	t1 _ B3DVector3 new.	t2 _ B3DVector3 new.	tp _ B3DVector3 new.	notDone _ true.! !!TTensor methodsFor: 'initialize' stamp: 'das 4/17/2002 17:58'!initializeDensity: d	density _ d.	t0 _ 0.0.	t1 _ B3DVector3 new.	t2 _ B3DVector3 new.	tp _ B3DVector3 new.	notDone _ true.! !!TTensor methodsFor: 'initialize' stamp: 'das 4/17/2002 17:58'!initializeMass: mss	mass _ mss.	t0 _ 0.0.	t1 _ B3DVector3 new.	t2 _ B3DVector3 new.	tp _ B3DVector3 new.	notDone _ true.! !!TTensor methodsFor: 'construction' stamp: 'das 4/7/2002 20:18'!calcPlane: tri	| abc d abcd |	abc _ (((tri at: 2)-(tri at:1)) cross: ((tri at: 3)-(tri at: 1))).	abc squaredLength = 0 ifTrue:[^ nil ].	abc normalize.	d _ (abc dot: (tri at: 1)) negated.	abcd _ abc asB3DVector4.	abcd w: d.	^ abcd.! !!TTensor methodsFor: 'construction' stamp: 'das 4/8/2002 02:05'!faceIntegrate: plane tri: tri	| fArray pArray k1 k2 k3 k4 a1 a2 a3 b1 b2 b3 ab w p1 pa paa paaa pb pbb pbbb pab paab pabb|	pArray _ self projectionIntegrate: tri.	fArray _ FloatArray ofSize: 12.	p1 _ pArray at:1.	pa _ pArray at:2.	paa _ pArray at:3.	paaa _ pArray at:4.	pb _ pArray at: 5.	pbb _ pArray at: 6.	pbbb _ pArray at: 7.	pab _ pArray at: 8.	paab _ pArray at: 9.	pabb _ pArray at: 10.	k1 _ 1.0/(plane at: c). k2 _ k1*k1. k3 _ k2*k1. k4 _ k3*k1.		a1 _ plane at: a.	a2 _ a1*a1.	a3 _ a1*a2.	b1 _ plane at: b.	b2 _ b1*b1.	b3 _ b1*b2.	ab _ a1*b1.	w _ plane at: 4.	fArray at: 1 put: k1 * pa.	fArray at: 2 put: k1 * pb.	fArray at: 3 put: k2 *((a1*pa) + (b1*pb) + (w * p1)) negated .		fArray at: 4 put: k1 * paa.	fArray at: 5 put: k1 * pbb.	fArray at: 6 put: k3 * ((a2*paa) + (2*ab*pab) + (b2*pbb) +		(w*((2*((a1*pa)+(b1*pb))) + (w*p1)))).	fArray at: 7 put: k1 * paaa.	fArray at: 8 put: k1 * pbbb.	fArray at: 9 put: k4 *((a3*paaa) + (3*a2*b1*paab)		+ (3*a1*b2*pabb) + (b3*pbbb))negated.	fArray at: 9 put: (fArray at: 9) +		(k4*3*w*((a2*paa) + (2*a1*b1*pab) + (b2*pbb))negated).	fArray at: 9 put: (fArray at: 9) +		(k4*w*w*((3*((a1*pa) + (b1*pb))) + (w*p1)) negated).	fArray at: 10 put: k1 * paab.	fArray at: 11 put: k2  * ((a1*pabb) + (b1*pbbb) + (w*pbb)) negated.	fArray at: 12 put: k3 * ((a2*paaa) + (2*a1*b1*paab) + (b2*pabb)).	fArray at: 12 put: (fArray at: 12) + (k3 * (w*((2*((a1*paa) + (b1*pab))) + (w*pa)))).	^  fArray.	"voidInertiaTensor::FaceIntegrals(TVVector3 norm, float d, TVVector3 tri[3]){	double w;	double k1, k2, k3, k4;	ProjectionIntegrals(tri);	w = d;	k1 = 1 / norm[C]; k2 = k1 * k1; k3 = k2 * k1; k4 = k3 * k1;1	Fa = k1 * Pa;2	Fb = k1 * Pb;3	Fc = -k2 * (norm[A]*Pa + norm[B]*Pb + w*P1);4	Faa = k1 * Paa;5	Fbb = k1 * Pbb;6	Fcc = k3 * (sqr(norm[A])*Paa + 2*norm[A]*norm[B]*Pab + sqr(norm[B])*Pbb		+ w*(2*(norm[A]*Pa + norm[B]*Pb) + w*P1));7	Faaa = k1 * Paaa;8	Fbbb = k1 * Pbbb;9	Fccc = -k4 * (cube(norm[A])*Paaa + 3*sqr(norm[A])*norm[B]*Paab 		+ 3*norm[A]*sqr(norm[B])*Pabb + cube(norm[B])*Pbbb		+ 3*w*(sqr(norm[A])*Paa + 2*norm[A]*norm[B]*Pab + sqr(norm[B])*Pbb)		+ w*w*(3*(norm[A]*Pa + norm[B]*Pb) + w*P1));10	Faab = k1 * Paab;11	Fbbc = -k2 * (norm[A]*Pabb + norm[B]*Pbbb + w*Pbb);12	Fcca = k3 * (sqr(norm[A])*Paaa + 2*norm[A]*norm[B]*Paab + sqr(norm[B])*Pabb		+ w*(2*(norm[A]*Paa + norm[B]*Pab) + w*Pa));}"! !!TTensor methodsFor: 'construction' stamp: 'das 4/8/2002 01:30'!projectionIntegrate: tri	| pArray a0 a1 b0 b1 da db a02 a03 a04 b02 b03 b04 a12 a13 b12 b13 c1 ca caa caaa cb cbb cbbb cab kab caab kaab cabb kabb |		pArray _ FloatArray ofSize:10.	1 to: 3 do:[ :i || i2 |		i2 _ 1+(i\\3).		a0 _ (tri at: i) at: a.		b0 _ (tri at: i) at: b.		a1 _ (tri at: i2) at: a.		b1 _ (tri at: i2) at: b.		da _ a1 - a0.		db _ b1 - b0.		a02 _ a0*a0. a03 _ a02*a0. a04 _ a03*a0.		b02 _ b0*b0. b03 _ b02*b0. b04 _ b03*b0. 		a12 _ a1*a1. a13 _ a12*a1.		b12 _ b1*b1. b13 _ b12*b1.		c1 _ a1+a0.		ca _ (a1*c1) + a02. 		caa _ (a1*ca)+a03. caaa _ (a1*caa)+a04.		cb _ (b1*(b1+b0)) + b02. cbb _ (b1*cb)+b03. cbbb _ (b1*cbb)+b04.		cab _ (3*a12)+(2*a1*a0)+a02. kab _ a12+(2*a1*a0)+(3*a02).		caab _ (a0*cab)+(4*a13). kaab _ (a1*kab)+(4*a03).		cabb _ (4*b13)+(3*b12*b0)+(2*b1*b02)+b03.		kabb _ b13+(2*b12*b0)+(3*b1*b02)+(4*b03).		pArray at: 1 put: ((pArray at: 1) + (db*c1)).		pArray at: 2 put: ((pArray at: 2) + (db*ca)).		pArray at: 3 put: ((pArray at: 3) + (db*caa)).		pArray at: 4 put: ((pArray at: 4) + (db*caaa)).		pArray at: 5 put: ((pArray at: 5) + (da*cb)).		pArray at: 6 put: ((pArray at: 6) + (da* cbb)).		pArray at: 7 put: ((pArray at: 7) + (da*cbbb)).		pArray at: 8 put: ((pArray at: 8) + (db*((b1*cab)+(b0*kab)))).		pArray at: 9 put: ((pArray at: 9) + (db*((b1*caab)+(b0*kaab)))).		pArray at: 10 put: ((pArray at: 10) + (da*((a1*cabb)+(a0*kabb)))).		].	pArray at: 1 put: (pArray at: 1)/2.0.	pArray at: 2 put: (pArray at: 2)/6.0.	pArray at: 3 put: (pArray at: 3)/12.0.	pArray at: 4 put: (pArray at: 4)/20.0.	pArray at: 5 put: (pArray at: 5)/-6.0.	pArray at: 6 put: (pArray at: 6)/-12.0.	pArray at: 7 put: (pArray at: 7)/-20.0.	pArray at: 8 put: (pArray at: 8)/24.0.	pArray at: 9 put: (pArray at: 9)/60.0.	pArray at:10 put: (pArray at: 10)/-60.0.	^ pArray."void InertiaTensor::ProjectionIntegrals(TVVector3 tri[3]){	double a0, a1, da;	double b0, b1, db;	double a0_2, a0_3, a0_4, b0_2, b0_3, b0_4;	double a1_2, a1_3, b1_2, b1_3;	double C1, Ca, Caa, Caaa, Cb, Cbb, Cbbb;	double Cab, Kab, Caab, Kaab, Cabb, Kabb;	P1 = Pa = Pb = Paa = Pab = Pbb = Paaa = Paab = Pabb = Pbbb = 0.0;	for (int i = 0; i < 3; i++) {		a0 = tri[i][A];		b0 = tri[i][B];		a1 = tri[(i+1) % 3][A];		b1 = tri[(i+1) % 3][B];		da = a1 - a0;		db = b1 - b0;		a0_2 = a0 * a0; a0_3 = a0_2 * a0; a0_4 = a0_3 * a0;		b0_2 = b0 * b0; b0_3 = b0_2 * b0; b0_4 = b0_3 * b0;		a1_2 = a1 * a1; a1_3 = a1_2 * a1; 		b1_2 = b1 * b1; b1_3 = b1_2 * b1;		C1 = a1 + a0;		Ca = a1*C1 + a0_2; Caa = a1*Ca + a0_3; Caaa = a1*Caa + a0_4;		Cb = b1*(b1 + b0) + b0_2; Cbb = b1*Cb + b0_3; Cbbb = b1*Cbb + b0_4;		Cab = 3*a1_2 + 2*a1*a0 + a0_2; Kab = a1_2 + 2*a1*a0 + 3*a0_2;		Caab = a0*Cab + 4*a1_3; Kaab = a1*Kab + 4*a0_3;		Cabb = 4*b1_3 + 3*b1_2*b0 + 2*b1*b0_2 + b0_3;		Kabb = b1_3 + 2*b1_2*b0 + 3*b1*b0_2 + 4*b0_3;		P1 += db*C1;		Pa += db*Ca;		Paa += db*Caa;		Paaa += db*Caaa;		Pb += da*Cb;		Pbb += da*Cbb;		Pbbb += da*Cbbb;		Pab += db*(b1*Cab + b0*Kab);		Paab += db*(b1*Caab + b0*Kaab);		Pabb += da*(a1*Cabb + a0*Kabb);	}1	P1 /= 2.0;2	Pa /= 6.0;3	Paa /= 12.0;4	Paaa /= 20.0;5	Pb /= -6.0;6	Pbb /= -12.0;7	Pbbb /= -20.0;8	Pab /= 24.0;9	Paab /= 60.0;10	Pabb /= -60.0;}"! !!TTensor methodsFor: 'construction' stamp: 'das 5/1/2002 14:00'!result	| cms tt1 tt2 ttp|	tt1 _ t1/2.0.	tt2 _ t2/3.0.	ttp _ tp/2.0.		mass ifNotNil:[		density _ mass/t0.] ifNil:[		mass _ density*t0.].	centerMass _ tt1/t0.	cms _ centerMass * centerMass."Compute the inertia tensor."	tensor _ B3DMatrix4x4 new.	tensor a11: (density *((tt2 at:2) + (tt2 at:3))) - (mass * ((cms at: 2) + (cms at: 3))).	tensor a22: (density *((tt2 at:3) + (tt2 at:1))) - (mass * ((cms at: 3) + (cms at: 1))).	tensor a33: (density *((tt2 at:1) + (tt2 at:2))) - (mass * ((cms at: 1) + (cms at: 2))).	tensor a12: (mass * (centerMass at:1) * (centerMass at: 2)) - (density * (ttp at: 1)). 	tensor a21: tensor a12.	tensor a23:  (mass * (centerMass at:2) * (centerMass at: 3)) - (density * (ttp at: 2)). 	tensor a32: tensor a23.	tensor a13:  (mass * (centerMass at:1) * (centerMass at: 3)) - (density * (ttp at: 3)) . 	tensor a31: tensor a13.	tensor a44: 1.0.	notDone _ false.	^ tensor." ""InertiaTensor::InertiaTensor(RMFace* faces, int numFaces, OSPoint3D* points, float denseMass, ITFlags flags):mFaces(faces), mNumFaces(numFaces), mPoints(points){	TVMatrix33 it;	VolumeIntegrals();	if(flags == ITDENSITY)	{		mDensity = denseMass;		mMass = mDensity * T0;	}	else if(flags == ITMASS)	{		mMass = denseMass;		mDensity = mMass/T0;	}	//TVVector3 mCM;	//TVMatrix33 mJ;	 /* compute center of mass */	mCM.x = T1[X] / T0;	mCM.y = T1[Y] / T0;	mCM.z = T1[Z] / T0;	/* compute inertia tensor */	mJ[X][X] = mDensity * (T2[Y] + T2[Z]);	mJ[Y][Y] = mDensity * (T2[Z] + T2[X]);	mJ[Z][Z] = mDensity * (T2[X] + T2[Y]);	mJ[X][Y] = mJ[Y][X] = - mDensity * TP[X];	mJ[Y][Z] = mJ[Z][Y] = - mDensity * TP[Y];	mJ[Z][X] = mJ[X][Z] = - mDensity * TP[Z];	/* translate inertia tensor to center of mass */	mJ[X][X] -= mMass * (mCM.y*mCM.y + mCM.z*mCM.z);	mJ[Y][Y] -= mMass * (mCM.z*mCM.z + mCM.x*mCM.x);	mJ[Z][Z] -= mMass * (mCM.x*mCM.x + mCM.y*mCM.y);	mJ[X][Y] = mJ[Y][X] += mMass * mCM.x * mCM.y; 	mJ[Y][Z] = mJ[Z][Y] += mMass * mCM.y * mCM.z; 	mJ[Z][X] = mJ[X][Z] += mMass * mCM.z * mCM.x; }"! !!TTensor methodsFor: 'construction' stamp: 'das 4/8/2002 00:39'!volumeIntegrate	| tri plane aPlane fArray t |	tri _ B3DVector3Array ofSize:3.	1 to: faces size by: 3 do:[ :i |		tri at: 1 put: (vertices at: 1+(faces at: i)).		tri at: 2 put: (vertices at: 1+(faces at: i+1)).		tri at: 3 put: (vertices at: 1+(faces at: i+2)).		plane _ self calcPlane: tri.		plane ifNotNil:[			aPlane _ plane abs.	" a,b, and c are the indices into the plane equation s.t. c is the maximal length component."			c _ 1.			(aPlane at: 2) > (aPlane at: c) ifTrue:[ c _ 2. ].			(aPlane at: 3) > (aPlane at: c) ifTrue:[ c _ 3 ].			a _ 1+(c\\3).			b _ 1+(a\\3).			fArray _ self faceIntegrate: plane tri: tri.			a == 1 ifTrue:[ t _ fArray at: 1.].			b == 1 ifTrue:[ t _ fArray at: 2.].			c == 1 ifTrue:[ t _ fArray at: 3.].			t0 _ t0 + ((plane at: 1) * t).			t1 at: a put: (t1 at: a) + ((plane at:a)*(fArray at:4)).			t1 at: b put: (t1 at: b) + ((plane at:b)*(fArray at:5)).			t1 at: c put: (t1 at: c) + ((plane at:c)*(fArray at:6)).			t2 at: a put: (t2 at: a) + ((plane at:a)*(fArray at:7)).			t2 at: b put: (t2 at: b) + ((plane at:b)*(fArray at:8)).			t2 at: c put: (t2 at: c) + ((plane at:c)*(fArray at:9)).			tp at: a put: (tp at: a) + ((plane at:a)*(fArray at:10)).			tp at: b put: (tp at: b) + ((plane at:b)*(fArray at:11)).			tp at: c put: (tp at: c) + ((plane at:c)*(fArray at: 12)).			].		]."void InertiaTensor::VolumeIntegrals(){	double nx, ny, nz;	T0 = T1[X] = T1[Y] = T1[Z] 		= T2[X] = T2[Y] = T2[Z] 		= TP[X] = TP[Y] = TP[Z] = 0;	for (int i = 0; i < mNumFaces; i++) 	{		TVVector3 tri[3];		TVVector3 norm;		float d;		tri[0] = mPoints[mFaces[i].P1.nVIndex];		tri[1] = mPoints[mFaces[i].P2.nVIndex];		tri[2] = mPoints[mFaces[i].P3.nVIndex];		if(CalcPlaneNorm(tri, norm, d))		{			nx = fabs(norm[X]);			ny = fabs(norm[Y]);			nz = fabs(norm[Z]);			if (nx > ny && nx > nz) C = X;			else C = (ny > nz) ? Y : Z;			A = (C + 1) % 3;			B = (A + 1) % 3;			FaceIntegrals(norm, d, tri);			T0 += norm[X] * ((A == X) ? Fa : ((B == X) ? Fb : Fc));			T1[A] += norm[A] * Faa;			T1[B] += norm[B] * Fbb;			T1[C] += norm[C] * Fcc;			T2[A] += norm[A] * Faaa;			T2[B] += norm[B] * Fbbb;			T2[C] += norm[C] * Fccc;			TP[A] += norm[A] * Faab;			TP[B] += norm[B] * Fbbc;			TP[C] += norm[C] * Fcca;		}	}	T1[X] /= 2; T1[Y] /= 2; T1[Z] /= 2;	T2[X] /= 3; T2[Y] /= 3; T2[Z] /= 3;	TP[X] /= 2; TP[Y] /= 2; TP[Z] /= 2;}"! !!TTensor methodsFor: 'accessing' stamp: 'das 4/17/2002 18:01'!centerMass	notDone ifTrue:[self result.].	^ centerMass.! !!TTensor methodsFor: 'accessing' stamp: 'das 4/6/2002 21:36'!density	^ density! !!TTensor methodsFor: 'accessing' stamp: 'das 4/17/2002 18:00'!density: d	density _ d.	mass _ nil.	notDone _ true.! !!TTensor methodsFor: 'accessing' stamp: 'das 4/6/2002 21:34'!mass	^ mass.! !!TTensor methodsFor: 'accessing' stamp: 'das 4/17/2002 17:59'!mass: ms	mass _ ms.	density _ nil.	notDone _ true.! !!TTensor methodsFor: 'accessing' stamp: 'das 4/7/2002 17:02'!t0	^ t0.! !!TTensor methodsFor: 'accessing' stamp: 'das 4/7/2002 17:02'!t1	^ t1.! !!TTensor methodsFor: 'accessing' stamp: 'das 4/7/2002 17:02'!t2	^ t2.! !!TTensor methodsFor: 'accessing' stamp: 'das 4/17/2002 18:01'!tensor	notDone ifTrue:[ ^ self result.].	^ tensor.! !!TTensor methodsFor: 'accessing' stamp: 'das 4/7/2002 17:02'!tp	^ tp.! !!TTensor class methodsFor: 'instance creation' stamp: 'das 5/1/2002 13:54'!initialize	^ self new initialize.! !!TTensor class methodsFor: 'instance creation' stamp: 'das 4/7/2002 14:06'!initializeMass: m	^ self new initializeMass: m.! !!TTensor class methodsFor: 'instance creation' stamp: 'ar 9/30/2004 12:46'!testCube		| cube quadFaces triFaces it counter |	cube _ TCube new.	cube location: (B3DVector3 x:1 y:2 z: 3).	cube update.	quadFaces _ cube quadFaces.	triFaces _ IntegerArray ofSize: (3*2*6).	counter _ 1.	1 to: quadFaces size by: 4 do:[ :i |		triFaces at: counter put: (quadFaces at: i)-1.		triFaces at: counter + 1 put: (quadFaces at: i+1)-1.		triFaces at: counter + 2 put: (quadFaces at: i+2)-1.		triFaces at: counter + 3 put: (quadFaces at: i+2)-1.		triFaces at: counter + 4 put: (quadFaces at: i+3)-1.		triFaces at: counter + 5 put: (quadFaces at: i)-1.		counter _ counter+6.].	it _ TTensor initializeMass: 1.0.	it addFaces: triFaces vertices: cube vertices.	it result.	Transcript show: 'tensor: '; cr; show: it tensor; cr.	Transcript show: 'center of mass: '; cr; show: it centerMass; cr.	Transcript show: 'density: '; show: it density; cr.	^ it.		! !!TTensor class methodsFor: 'instance creation' stamp: 'ar 9/30/2004 12:46'!testCube: scale position: position		| cube quadFaces triFaces it counter |	cube _ TCube new.	cube location: position.	cube extent: scale.	cube update.	quadFaces _ cube quadFaces.	triFaces _ IntegerArray ofSize: (3*2*6).	counter _ 1.	1 to: quadFaces size by: 4 do:[ :i |		triFaces at: counter put: (quadFaces at: i)-1.		triFaces at: counter + 1 put: (quadFaces at: i+1)-1.		triFaces at: counter + 2 put: (quadFaces at: i+2)-1.		triFaces at: counter + 3 put: (quadFaces at: i+2)-1.		triFaces at: counter + 4 put: (quadFaces at: i+3)-1.		triFaces at: counter + 5 put: (quadFaces at: i)-1.		counter _ counter+6.].	it _ TTensor initializeMass: 1.0.	it addFaces: triFaces vertices: cube vertices.	it result.	Transcript show: 'tensor: '; cr; show: it tensor; cr.	Transcript show: 'center of mass: '; cr; show: it centerMass; cr.	Transcript show: 'density: '; show: it density; cr.	^ it.		! !!TTensor class methodsFor: 'instance creation' stamp: 'das 4/8/2002 02:06'!testSphere		| v f vert radius segments position seg2 ringSin ringCos rts rtc rbs rbc pi2 ax it |	radius _ 1.0.	segments _30.	seg2 _ 1+ (segments * 2) .	ringSin _ FloatArray ofSize: seg2.	ringCos _ FloatArray ofSize: seg2.	vert _ B3DVector3 new.	pi2 _ Float pi *2.0.	position _ B3DVector3 x: 10 y:10 z: 10.	"position _ B3DVector3 new."	v _ OrderedCollection new.	f _ OrderedCollection new.	1 to: seg2-1 do:[ :index | 		ax _ ((index-1) * pi2)/ (seg2-1).		ringSin at:index put: ax sin.		ringCos at:index put: ax cos.].	ringSin at: seg2 put: (ringSin at: 1).	ringCos at: seg2 put: (ringCos at: 1).	rts _ 0.0.	rtc _ 1.0.	rbs _ ringSin at: 2.	rbc _ ringCos at: 2.	1 to: segments do:[ :iv |		1 to: seg2 do: [ :ih | 			vert x: rts*(ringSin at: ih) y: rtc z: rts*(ringCos at: ih).			v add:  (vert * radius)+ position.			vert x: rbs*(ringSin at: ih) y: rbc z: rbs*(ringCos at: ih).			v add: (vert * radius)+ position.			ih  = 1 ifFalse:[				f add: v size - 4.				f add: v size - 3.				f add: v size - 2.				f add: v size - 3.				f add: v size - 1.				f add: v size - 2.			].].		rts _ rbs.		rtc _ rbc.		rbs _ ringSin at: iv+2.		rbc _ ringCos at: iv+2.		]."	1 to: f size by: 3 do:[ : i | |p1 p2 center scale aForm|		aForm _ Form extent: 1@1.		aForm fillBlack.		center _ 500@500.		scale _ 100@100.		p1 _ ((v at: 1+(f at: i)) at:2)@((v at: 1+(f at: i))at:3).		p2 _ ((v at: 1+(f at: i+1)) at:2)@((v at: 1+(f at: i+1))at:3).		(Line from: (p1*scale)+center to: (p2*scale)+center withForm: aForm) display.		p1 _ p2.		p2 _ ((v at: 1+(f at: i+2)) at:2)@((v at: 1+(f at: i+2))at: 3).		(Line from: (p1*scale)+center to: (p2*scale)+center withForm: aForm) display.		p1 _ p2.		p2 _((v at: 1+(f at: i)) at:2)@((v at: 1+(f at: i))at:3)..		(Line from: (p1*scale)+center to: (p2*scale)+center withForm: aForm)display.		]."	it _ TTensor initializeMass: 1.0.	it addFaces: f vertices: v.	it result.	Transcript show:'Sphere tensor:'; cr.	Transcript show: it tensor; cr.	Transcript show:'Center of mass:'; cr.	Transcript show: it centerMass; cr.	Transcript show: 'Density: '; cr; show: it density; cr.	^ it.		! !!TTensor class methodsFor: 'instance creation' stamp: 'das 4/8/2002 09:15'!testSphere: segments		| v f vert radius position seg2 ringSin ringCos rts rtc rbs rbc pi2 ax it |	radius _ 1.0.	seg2 _ 1+ (segments * 2) .	ringSin _ FloatArray ofSize: seg2.	ringCos _ FloatArray ofSize: seg2.	vert _ B3DVector3 new.	pi2 _ Float pi *2.0.	position _ B3DVector3 x: 10 y:10 z: 10.	"position _ B3DVector3 new."	v _ OrderedCollection new.	f _ OrderedCollection new.	1 to: seg2-1 do:[ :index | 		ax _ ((index-1) * pi2)/ (seg2-1).		ringSin at:index put: ax sin.		ringCos at:index put: ax cos.].	ringSin at: seg2 put: (ringSin at: 1).	ringCos at: seg2 put: (ringCos at: 1).	rts _ 0.0.	rtc _ 1.0.	rbs _ ringSin at: 2.	rbc _ ringCos at: 2.	1 to: segments do:[ :iv |		1 to: seg2 do: [ :ih | 			vert x: rts*(ringSin at: ih) y: rtc z: rts*(ringCos at: ih).			v add:  (vert * radius)+ position.			vert x: rbs*(ringSin at: ih) y: rbc z: rbs*(ringCos at: ih).			v add: (vert * radius)+ position.			ih  = 1 ifFalse:[				f add: v size - 4.				f add: v size - 3.				f add: v size - 2.				f add: v size - 3.				f add: v size - 1.				f add: v size - 2.			].].		rts _ rbs.		rtc _ rbc.		rbs _ ringSin at: iv+2.		rbc _ ringCos at: iv+2.		]."	1 to: f size by: 3 do:[ : i | |p1 p2 center scale aForm|		aForm _ Form extent: 1@1.		aForm fillBlack.		center _ 500@500.		scale _ 100@100.		p1 _ ((v at: 1+(f at: i)) at:2)@((v at: 1+(f at: i))at:3).		p2 _ ((v at: 1+(f at: i+1)) at:2)@((v at: 1+(f at: i+1))at:3).		(Line from: (p1*scale)+center to: (p2*scale)+center withForm: aForm) display.		p1 _ p2.		p2 _ ((v at: 1+(f at: i+2)) at:2)@((v at: 1+(f at: i+2))at: 3).		(Line from: (p1*scale)+center to: (p2*scale)+center withForm: aForm) display.		p1 _ p2.		p2 _((v at: 1+(f at: i)) at:2)@((v at: 1+(f at: i))at:3)..		(Line from: (p1*scale)+center to: (p2*scale)+center withForm: aForm)display.		]."	it _ TTensor initializeMass: 1.0.	it addFaces: f vertices: v.	it result.	Transcript show:'Sphere tensor:'; cr.	Transcript show: it tensor; cr.	Transcript show:'Center of mass:'; cr.	Transcript show: it centerMass; cr.	Transcript show: 'Density: '; cr; show: it density; cr.	^ it.		! !!TTensor class methodsFor: 'instance creation' stamp: 'das 4/8/2002 09:16'!testSphere: segments position: position		| v f vert radius seg2 ringSin ringCos rts rtc rbs rbc pi2 ax it |	radius _ 1.0.	seg2 _ 1+ (segments * 2) .	ringSin _ FloatArray ofSize: seg2.	ringCos _ FloatArray ofSize: seg2.	vert _ B3DVector3 new.	pi2 _ Float pi *2.0.	v _ OrderedCollection new.	f _ OrderedCollection new.	1 to: seg2-1 do:[ :index | 		ax _ ((index-1) * pi2)/ (seg2-1).		ringSin at:index put: ax sin.		ringCos at:index put: ax cos.].	ringSin at: seg2 put: (ringSin at: 1).	ringCos at: seg2 put: (ringCos at: 1).	rts _ 0.0.	rtc _ 1.0.	rbs _ ringSin at: 2.	rbc _ ringCos at: 2.	1 to: segments do:[ :iv |		1 to: seg2 do: [ :ih | 			vert x: rts*(ringSin at: ih) y: rtc z: rts*(ringCos at: ih).			v add:  (vert * radius)+ position.			vert x: rbs*(ringSin at: ih) y: rbc z: rbs*(ringCos at: ih).			v add: (vert * radius)+ position.			ih  = 1 ifFalse:[				f add: v size - 4.				f add: v size - 3.				f add: v size - 2.				f add: v size - 3.				f add: v size - 1.				f add: v size - 2.			].].		rts _ rbs.		rtc _ rbc.		rbs _ ringSin at: iv+2.		rbc _ ringCos at: iv+2.		]."	1 to: f size by: 3 do:[ : i | |p1 p2 center scale aForm|		aForm _ Form extent: 1@1.		aForm fillBlack.		center _ 500@500.		scale _ 100@100.		p1 _ ((v at: 1+(f at: i)) at:2)@((v at: 1+(f at: i))at:3).		p2 _ ((v at: 1+(f at: i+1)) at:2)@((v at: 1+(f at: i+1))at:3).		(Line from: (p1*scale)+center to: (p2*scale)+center withForm: aForm) display.		p1 _ p2.		p2 _ ((v at: 1+(f at: i+2)) at:2)@((v at: 1+(f at: i+2))at: 3).		(Line from: (p1*scale)+center to: (p2*scale)+center withForm: aForm) display.		p1 _ p2.		p2 _((v at: 1+(f at: i)) at:2)@((v at: 1+(f at: i))at:3)..		(Line from: (p1*scale)+center to: (p2*scale)+center withForm: aForm)display.		]."	it _ TTensor initializeMass: 1.0.	it addFaces: f vertices: v.	it result.	Transcript show:'Sphere tensor:'; cr.	Transcript show: it tensor; cr.	Transcript show:'Center of mass:'; cr.	Transcript show: it centerMass; cr.	Transcript show: 'Density: '; cr; show: it density; cr.	^ it.		! !!TTexture methodsFor: 'fileIn/Out' stamp: 'das 7/1/2004 09:04'!isLoaded	^tform isLoaded.! !!TTexture methodsFor: 'access' stamp: 'das 6/30/2004 23:29'!bMipmap	^ tform bMipmap.! !!TTexture methodsFor: 'access' stamp: 'das 5/24/2004 13:09'!extension		^ tform extension.! !!TTexture methodsFor: 'access' stamp: 'das 5/24/2004 11:12'!extent: ext	super extent: ext.	baseScale _ (extent x/tform extent x) asFloat.! !!TTexture methodsFor: 'access' stamp: 'das 7/1/2004 10:18'!fileName	^ tform fileName.! !!TTexture methodsFor: 'access' stamp: 'das 7/8/2004 07:56'!formExtent	^ tform extent.! !!TTexture methodsFor: 'access' stamp: 'ar 10/1/2004 15:04'!invalidate: aRect	tform invalidate: aRect.! !!TTexture methodsFor: 'access' stamp: 'das 7/1/2004 09:51'!isStatic	^ tform isStatic.! !!TTexture methodsFor: 'access' stamp: 'das 7/1/2004 09:50'!isStatic: aBool		tform isStatic: aBool.! !!TTexture methodsFor: 'access' stamp: 'das 7/1/2004 10:18'!magFilter	^ tform magFilter.! !!TTexture methodsFor: 'access' stamp: 'das 7/1/2004 10:18'!minFilter	^ tform minFilter.! !!TTexture methodsFor: 'access' stamp: 'das 6/9/2004 21:40'!mode	^ mode.! !!TTexture methodsFor: 'access' stamp: 'das 6/9/2004 21:40'!mode: md	mode _ md.! !!TTexture methodsFor: 'access' stamp: 'das 6/21/2003 20:47'!scale	^ baseScale.! !!TTexture methodsFor: 'access' stamp: 'das 5/24/2004 11:12'!scale: sc	baseScale _ baseScale * sc.	self translation: (self translation * sc).	extent _ tform extent * baseScale. 	"save the original value if we have to render this object."	self boundsChanged.! !!TTexture methodsFor: 'access' stamp: 'das 7/1/2004 09:32'!shrinkFit^ tform bShrinkFit.! !!TTexture methodsFor: 'access' stamp: 'das 7/1/2004 09:32'!shrinkFit: bSF tform shrinkFit: bSF.! !!TTexture methodsFor: 'access' stamp: 'das 7/8/2004 08:04'!targetExtent	^ tform extent.! !!TTexture methodsFor: 'access' stamp: 'das 7/8/2004 10:22'!targetForm	^tform form.! !!TTexture methodsFor: 'access' stamp: 'das 5/24/2004 11:12'!textureForm	^tform form.! !!TTexture methodsFor: 'access' stamp: 'ar 10/1/2004 15:13'!tform	^tform! !!TTexture methodsFor: 'access' stamp: 'ar 10/1/2004 15:04'!updateRect: aRect	self invalidate: aRect! !!TTexture methodsFor: 'access'!uvAngle	^ uvAngle.! !!TTexture methodsFor: 'access'!uvAngle: uva	uvAngle _ uva.! !!TTexture methodsFor: 'access'!uvOffset	^ uvOffset.! !!TTexture methodsFor: 'access'!uvOffset: uvo	uvOffset_ uvo.! !!TTexture methodsFor: 'access'!uvScale	^uvScale.! !!TTexture methodsFor: 'access'!uvScale: uvs	uvScale_ uvs.! !!TTexture methodsFor: 'initialize' stamp: 'das 7/1/2004 09:58'!destroy	"destroy me"	super destroy.	self delete.! !!TTexture methodsFor: 'initialize' stamp: 'das 5/24/2004 11:13'!flipVertically	"Flip the texture vertically"	tform form flipVertically.	tform updateAll.! !!TTexture methodsFor: 'initialize' stamp: 'das 7/8/2004 18:58'!initializeOpaque: aBool extent: targetExtent| mat |	self 		initializeWithForm: (Form extent: targetExtent depth: 32) 		mipmap: false "aCroquetWorld ogl autoMipmap"		shrinkFit: false. "the form needs to grow"	uvScale _ (tform extent/tform trueExtent) asFloatPoint.	mat _ TMaterial new.	aBool ifTrue:[		mat ambientColor: #(1.0 1.0 1.0 1) asFloatArray.		mat diffuseColor: #(1.0 1.0 1.0 1) asFloatArray.	] ifFalse:[		mat ambientColor: #(1.0 1.0 1.0 0.9) asFloatArray.		mat diffuseColor: #(1.0 1.0 1.0 0.9) asFloatArray.	].	mat emissiveColor: #(1.0 1.0 1.0 1.0) asFloatArray.	super material: mat.	^self.! !!TTexture methodsFor: 'initialize' stamp: 'DPR 7/14/2003 11:16'!initializeWithFileName: fName	^self initializeWithFileName: fName mipmap: true shrinkFit: false.! !!TTexture methodsFor: 'initialize' stamp: 'DPR 8/21/2003 16:49'!initializeWithFileName: fName mipmap: bMM	^self initializeWithFileName: fName mipmap: bMM shrinkFit: false.! !!TTexture methodsFor: 'initialize' stamp: 'DPR 7/10/2003 07:54'!initializeWithFileName: fName mipmap: bMM shrinkFit: bSF 	^self initializeWithFileName: fName mipmap: bMM shrinkFit: false extension: nil.! !!TTexture methodsFor: 'initialize' stamp: 'das 5/24/2004 11:12'!initializeWithFileName: fName mipmap: bMM shrinkFit: bSF extension: ext	tform _ TForm fromFileNamed: fName mipmap: bMM shrinkFit: bSF extension: ext.	self setup.! !!TTexture methodsFor: 'initialize' stamp: 'das 5/24/2004 11:06'!initializeWithForm: baseForm mipmap: bMM shrinkFit: bSF 	self initializeWithForm: baseForm mipmap: bMM shrinkFit: bSF extension: nil.! !!TTexture methodsFor: 'initialize' stamp: 'das 7/8/2004 18:46'!initializeWithForm: baseForm mipmap: bMM shrinkFit: bSF extension: ext	tform _ TForm fromForm: baseForm mipmap: bMM shrinkFit: bSF extension: ext.	self setup.! !!TTexture methodsFor: 'initialize' stamp: 'das 7/8/2004 18:46'!setup	baseScale _ 0.01.	extent _ tform extent * baseScale.	self aspectFixed: true.	self aspect: (extent y/extent x) asFloat.	self texture: self.	uvScale _ 1.0@1.0.	uvOffset _ 0.0@0.0.	uvAngle _ 0.0.	extent _ extent * baseScale. 	"save the original value if we have to render this object."	self objectName: tform fileName.	tform addParent: self.	mode _ GLModulate.! !!TTexture methodsFor: 'render' stamp: 'das 5/24/2004 13:22'!disable: ogl	ogl changeTexture ifFalse:[^false].	ogl glDisable: GLTexture2d.! !!TTexture methodsFor: 'render' stamp: 'ar 10/1/2004 15:27'!enable: ogl	(tform notNil and: [ogl installTexture: tform]) ifTrue:[.		ogl glEnable: GLTexture2d.		timeStamp ~= ogl timeStamp ifTrue:[self update.].		ogl glTexParameteri: GLTexture2d with: GLTextureWrapS with:GLRepeat;			glTexParameteri: GLTexture2d with: GLTextureWrapT with:GLRepeat.].	timeStamp _ ogl timeStamp.! !!TTexture methodsFor: 'render' stamp: 'das 5/10/2004 15:44'!renderFrame: ogl parent: parent root: root	self update.	^ super renderFrame: ogl parent: parent root: root.! !!TTexture methodsFor: 'render' stamp: 'das 3/12/2004 14:03'!renderFrame: ogl space: space	self update.	^ super renderFrame: ogl space: space.! !!TTexture methodsFor: 'render' stamp: 'das 7/1/2004 10:27'!renderPrimitive: ogl	self enable: ogl.	ogl glTexEnvi: GLTextureEnv with: GLTextureEnvMode with: mode.	super renderPrimitive: ogl.	self disable:ogl.! !!TTexture methodsFor: 'render' stamp: 'das 5/24/2004 13:31'!update"This is used when you are about to use or render this texture. This is called whenever we are send #enable: to the texture, and it is only called once per render."! !!TTexture methodsFor: 'render' stamp: 'das 5/24/2004 14:32'!upload	tform updateAll.! !!TTexture methodsFor: 'testing' stamp: 'das 7/8/2002 15:43'!isTexture	^ true.! !!TTexture methodsFor: 'copying' stamp: 'das 7/8/2002 15:15'!copy	^ self shallowCopy.! !!TTextureForm methodsFor: 'events' stamp: 'DPR 5/1/2004 13:11'!handleEvent2D: someEvent pointer: pointer	self subclassResponsibility! !!TTextureForm methodsFor: 'events' stamp: 'DPR 5/1/2004 12:43'!handlesKeyboard: ptr	^true! !!TTextureForm methodsFor: 'events' stamp: 'DPR 5/1/2004 12:43'!handlesPointerDown: pointer	^true! !!TTextureForm methodsFor: 'events' stamp: 'DPR 5/1/2004 12:43'!handlesPointerOver: pointer	^true! !!TTextureForm methodsFor: 'events' stamp: 'DPR 5/1/2004 12:43'!keyDown: pointer	self passEvent: pointer event2D from: pointer.! !!TTextureForm methodsFor: 'events' stamp: 'DPR 7/5/2004 20:03'!keyStroke: pointer	self passEvent: pointer event2D from: pointer.! !!TTextureForm methodsFor: 'events' stamp: 'das 7/8/2004 10:37'!passEvent: anEvent from: pointer	| pt evt |	passEvents == false ifTrue: [^self]. "ignoring events" 	pt _ pointer selectedPoint x @ pointer selectedPoint y.	pt _ pt / self extent + 0.5.	pt _ pt * targetExtent.	pt _ pt x @ (targetExtent y - pt y).	evt _ anEvent copy.	evt _ evt translateBy: (pt - evt position) truncated.	evt resetHandlerFields.	evt setHand: nil.	self handleEvent2D: evt pointer: pointer.! !!TTextureForm methodsFor: 'events' stamp: 'DPR 5/1/2004 13:26'!pointerDown: pointer	self passEvent: pointer event2D from: pointer.! !!TTextureForm methodsFor: 'events' stamp: 'DPR 5/23/2004 14:35'!pointerEnter: pointer	mouseOver _ true.! !!TTextureForm methodsFor: 'events' stamp: 'DPR 5/23/2004 14:36'!pointerLeave: pointer	mouseOver _ false.! !!TTextureForm methodsFor: 'events' stamp: 'DPR 5/1/2004 12:43'!pointerMove: pointer	| rval |	pointer testDistance: false.	pointer currentFrame: self.	rval _ self pick: pointer.	pointer testDistance: true.	rval ifTrue:[		mouseOver ifFalse:[			mouseOver _ true.			self passEvent: pointer event2D asMouseEnter from: pointer.].		self passEvent: pointer event2D asMouseMove from: pointer.		] ifFalse: [		mouseOver ifTrue:[			mouseOver _ false.			self passEvent: pointer event2D asMouseLeave from: pointer.].		].	^ rval.			! !!TTextureForm methodsFor: 'events' stamp: 'DPR 5/1/2004 13:26'!pointerOver: pointer	| evt |	evt _ pointer event2D ifNil:[^self].	evt isKeyboard ifTrue:[^ self.].	self passEvent: pointer event2D asMouseMove from: pointer.! !!TTextureForm methodsFor: 'events' stamp: 'DPR 5/1/2004 13:27'!pointerUp: pointer	self passEvent: pointer event2D from: pointer.! !!TTextureForm methodsFor: 'events' stamp: 'DPR 5/1/2004 12:43'!wantsBlueButton	^true! !!TTextureForm methodsFor: 'testing' stamp: 'DPR 5/1/2004 12:43'!isComponent	^ true.! !!TTextureForm methodsFor: 'accessing' stamp: 'DPR 5/1/2004 12:43'!material: nothin! !!TTextureForm methodsFor: 'accessing' stamp: 'DPR 5/1/2004 12:43'!passEvents: aBool	passEvents := aBool! !!TTextureForm methodsFor: 'render' stamp: 'das 7/8/2004 07:34'!updateArea: aRectangle with: aForm	"the form contains new data to copy into the rectangle area specified"	tform updateArea: aRectangle with: aForm.! !!TTextureForm methodsFor: 'initialize' stamp: 'das 7/8/2004 07:26'!initializeOpaque: aBool extent: ext	targetExtent _ ext.	super initializeOpaque: aBool extent: targetExtent.	mouseOver _ false.	^self.! !!TMorphic methodsFor: 'events' stamp: 'ar 10/1/2004 09:21'!handleEvent2D: someEvent pointer: pointer	morphMonitor ifNil: [^self].	morphMonitor future: 0.0 perform: #handleEvent2D:pointer: withArguments: { someEvent . pointer }.! !!TMorphic methodsFor: 'events' stamp: 'ar 10/1/2004 09:22'!pointerEnter: pointer	super pointerEnter: pointer.	morphMonitor ifNil: [^self].	morphMonitor future: 0.0 perform: #pointerEnter: withArguments: { pointer }.! !!TMorphic methodsFor: 'events' stamp: 'ar 10/1/2004 09:22'!pointerLeave: pointer	super pointerLeave: pointer.	morphMonitor ifNil: [^self].	morphMonitor future: 0.0 perform: #pointerLeave: withArguments: { pointer }.! !!TMorphic methodsFor: 'initialize' stamp: 'DPR 5/23/2004 13:47'!morphMonitor: aTMorphMonitor	morphMonitor _ aTMorphMonitor.! !!TMorphic methodsFor: 'render' stamp: 'ar 10/1/2004 08:30'!update	morphMonitor ifNotNil:[morphMonitor sendTextureUpdate].! !!TSpreadSheetTxtr methodsFor: 'as yet unclassified' stamp: 'das 8/16/2004 01:29'!initialize	super initialize.	self initializeOpaque: false extent: 1024@768.! !!TSpreadSheetTxtr methodsFor: 'as yet unclassified' stamp: 'das 8/17/2004 13:02'!selectField: farray	| ext2 pos cube mat scl |	scl _ self extent/self formExtent.	ext2 _ extent/2.0.	selection ifNotNil:[		self removeChild: selection.		selection _ nil.].	selection _ TGroup new.	self addChild: selection.	farray do:[ :field |		field value ifNotNil:[			pos _ field key center*scl.			cube _ TCube new.			cube extent: ((field key extent*scl)@field value).			cube translation: ((pos x-ext2 x)@(ext2 y-(pos y))@(field value/2.0)).			selection addChild: cube.			mat _ TMaterial new.			field value >0.0 ifTrue:[ mat color:  #(0.3 1.0 0.3 0.3) asFloatArray.]			ifFalse:[ 				field value<0.0 ifTrue:[mat color:#(1.0 0.3 0.3 0.3)asFloatArray.] ifFalse:			[mat color:#(0.3 0.3 1.0 0.3)asFloatArray.]].			cube material: mat.			cube solid: false.		].	].! !!TTextureStress methodsFor: 'as yet unclassified' stamp: 'DPR 8/12/2003 09:45'!new	super new	self setupStressTest.! !!TTextureStress methodsFor: 'as yet unclassified' stamp: 'das 2/17/2004 16:43'!setupStressTest	"set up my stress test"	| myForm txtr box |	myForm := Form extent: 1024@1024 depth: 32.	box := myForm boundingBox.	1 to: 4 do:[:i|		myForm getCanvas fillOval: box color: Color red.		box := box insetBy: 1.		myForm getCanvas fillOval: box color: Color green.		box := box insetBy: 1.		myForm getCanvas fillOval: box color: Color blue.		box := box insetBy: 1.		myForm getCanvas fillOval: box color: Color yellow.		box := box insetBy: 1.	].	1 to: 1 do:[:i|		txtr := TTexture new initializeWithForm: myForm mipmap: true shrinkFit: true.		txtr isStatic: true.		self addChild: txtr.	].! !!TTorus methodsFor: 'accessing' stamp: 'DPR 7/22/2004 03:21'!boundSphere	^ boundSphere.! !!TTorus methodsFor: 'accessing' stamp: 'DPR 7/22/2004 03:21'!boundSphere: bndSphr	boundSphere _ bndSphr.! !!TTorus methodsFor: 'accessing' stamp: 'DPR 7/22/2004 03:30'!innerRadius		^ innerRadius! !!TTorus methodsFor: 'accessing' stamp: 'DPR 7/22/2004 03:30'!innerRadius: rval	innerRadius := rval.	self boundsChanged.! !!TTorus methodsFor: 'accessing' stamp: 'DPR 7/22/2004 03:21'!localPosition	^ boundSphere localPosition.! !!TTorus methodsFor: 'accessing' stamp: 'DPR 7/22/2004 03:21'!localPosition: pval	boundSphere localPosition: pval.	self boundsChanged.! !!TTorus methodsFor: 'accessing' stamp: 'DPR 7/22/2004 03:21'!radius		^ boundSphere radius! !!TTorus methodsFor: 'accessing' stamp: 'DPR 7/23/2004 00:40'!radius: rval	| oldRadius |	oldRadius := self radius.	boundSphere radius: rval.	innerRadius := rval / oldRadius * innerRadius.	self boundsChanged.! !!TTorus methodsFor: 'accessing' stamp: 'DPR 7/22/2004 03:21'!segments	^ segments! !!TTorus methodsFor: 'accessing' stamp: 'DPR 7/22/2004 03:21'!segments: segs	segments _ segs! !!TTorus methodsFor: 'initialize' stamp: 'DPR 7/22/2004 03:26'!initialize	super initialize.	innerRadius := 0.0.  "no hole"	boundSphere _ TBoundSphere localPosition: (B3DVector3 new x:0.0 y:0.0 z:0.0) radius: 1.0.	boundSphere frame: self.	segments _ 10.	^self		! !!TTorus methodsFor: 'render' stamp: 'DPR 7/22/2004 03:21'!pick: pointer	^ pointer pickSphere: self boundSphere localPosition 		radiusSquared: self boundSphere radiusSquared.! !!TTorus methodsFor: 'render' stamp: 'DPR 7/23/2004 20:58'!renderPrimitive: ogl		| segSq twoPi delta1 delta2 radius cr sr omega1 omega2 rad omega1cos omega1sin omega2cos vert norm normLen i1 i2 u v dv |	segSq := segments * segments.	vert := Array ofSize: segSq.	norm := Array ofSize: segSq.	twoPi := Float pi * 2.0.	delta1 := twoPi / segSq.	delta2 := twoPi / segments.	radius := boundSphere radius.	cr := (radius + innerRadius) * 0.5.	sr := (radius - innerRadius) * 0.5.		1 to: segSq do: [ :i |		omega1 := i * delta1.		omega1cos := omega1 cos.		omega1sin := omega1 sin.		omega2 := i * delta2.		omega2cos := omega2 cos.		rad := ((sr * (omega2 cos)) + cr).		vert at: i put: (B3DVector3 new x: rad * omega1cos y: rad * omega1sin z: sr * (omega2 sin)).		"now compute unit normals"		normLen := (omega2cos * omega2cos + 1) sqrt.		norm at: i put: (B3DVector3 new x: omega1cos / normLen y: omega1sin / normLen z: omega2cos / normLen).		].	dv := 1.0 / segSq.	ogl glBegin(GLTriangleStrip).	0 to: segSq - 1 do: [ :i |		i1 := i + 1.		i2 := ((i + segments) \\ segSq) + 1.		u := (i \\ segments) asFloat / segments.		v := i asFloat / segSq.		"Transcript cr; show: (norm at: i1); show: ' '; show:(norm at: i2)."		ogl glNormal3fv(norm at: i1).		ogl glTexCoord2f(u,v).		ogl glVertex3fv(vert at: i1).		ogl glNormal3fv(norm at: i2).		ogl glTexCoord2f(u, v+dv).		ogl glVertex3fv(vert at: i2).		].	ogl glEnd.				! !!TTracer methodsFor: 'accessing' stamp: 'das 11/17/2003 13:19'!addPath: pos	path add: pos.	path size > maxSize ifTrue:[path removeFirst].! !!TTracer methodsFor: 'accessing' stamp: 'das 12/30/2003 15:31'!boundSphere	^ bounds.! !!TTracer methodsFor: 'accessing' stamp: 'das 11/17/2003 22:31'!maxSize: ms	maxSize _ ms.! !!TTracer methodsFor: 'accessing' stamp: 'das 11/17/2003 11:35'!path 	^ path.! !!TTracer methodsFor: 'accessing' stamp: 'das 11/17/2003 22:30'!reset	path _ OrderedCollection new.! !!TTracer methodsFor: 'render' stamp: 'das 3/12/2004 14:04'!render: ogl	ogl glDisable: GLLighting.	ogl glDisable: GLCullFace.	ogl glColor3fv: #(0 0 1.0)asFloatArray.	ogl glBegin: GLLineStrip.	path do:[ :gp | ogl glVertex3fv: gp.]. 	ogl glEnd.	ogl glEnable: GLLighting.! !!TTracer methodsFor: 'render' stamp: 'ar 9/30/2004 16:54'!renderFrame: ogl space: space	| saveParent saveTransform count childCount globalTrans ac |" I am running a parallel set of transforms here. Why? Because I am told the OGL is inefficient at reading the current transform. Easy to change."" Any given frame can have multiple parents. This means that the frame can't keep a static reference to the parent frame. This must be dynamic, essentially filled out at render time. This allows for pure -instancing- of frame objects. That is, the same frame and all of its contents can easily be in multiple locations in the render tree without significant additional bookkeeping. It also means that when an object DOES need to refer to its parent or the space frame (read -root- for traditional approaches), this can ONLY be done at render-time via this mechanism. It also means that a child really must not modify the parent directly, as the parent has other responsibilities."" #renderFrame: must return the number of objects that were rendered - failure to do so will just crash."	count _ 0.	(visible or:[frameChildren notNil])ifFalse:[^ 0 ].	saveParent _ space currentParent.	self parent ~= saveParent ifTrue:[ self isSpace ifFalse:[self frameChanged. ]].	self currentParent: saveParent.	space currentParent: self. 	" apply the local transform to this matrix "	saveTransform _ space currentTransform.	saveTransform ifNotNil: [		space currentTransform: (saveTransform composeWith: localTransform).]		ifNil:[space currentTransform: localTransform. ].			ogl glPushMatrix. 	ogl glMultMatrixf: localTransform transposed. 	self boundSphere ifNotNil:[		self boundSphere transform: space currentTransform.		solid ifTrue:[ space testRayFrames: self boundSphere.].	]."------ is this inside the viewing pyramid?"	ac _ ogl camera.	(visible and:[ac testBounds: self boundSphere]) ifTrue:[ 		ac pointer ifNotNil:[			ac inPortal ifTrue:[ (ac pointer pointerPick: self boundSphere) ]			ifFalse:[ self isPortal ifFalse:[ (ac pointer pointerPick: self boundSphere) ]. ].		].		timeStamp _ ogl timeStamp.		count _ 1.		self render: ogl.			self hasAlpha ifTrue: [ 			globalTrans _ B3DMatrix4x4 new.			ogl glGetFloatv: GLModelviewMatrix with: globalTrans.			space addAlphaObject: self 				transform: globalTrans "space currentTransform clone"				distance: ((ac globalPosition - space currentTranslation ) squaredLength * CroquetGlobals frameScaleSquared)				parent: space currentParent.].].	frameChildren ifNotNil:[		" render all of the child frames "		childCount _ 0.		frameChildren do:[:rFrame | childCount _ childCount+(rFrame renderFrame: ogl space: space).]. 		childCount > 0 ifTrue:[count _ count+childCount. timeStamp _ ogl timeStamp.]		].	ogl glPopMatrix.	space currentTransform: saveTransform.	space currentParent: saveParent.	^ count.! !!TTracer methodsFor: 'initialize' stamp: 'das 2/17/2004 17:10'!initialize	super initialize.	path _ OrderedCollection new.	maxSize _ 10000.	bounds _ TBoundSphere localPosition:(30@10@-120) radius: 10000.	bounds frame: self.! !!TTree methodsFor: 'as yet unclassified' stamp: 'ar 9/30/2004 13:11'!initializeWithDepth: depth	| tbranch |	tbranch _ TCube new.	tbranch extent: (B3DVector3 x: 0.1 y: 1.0 z:0.1).	tbranch locationX: 0 y: 0.5 z:0.	self contents: tbranch.		depth ~= 0 ifTrue:[		tbranch _ TTree new initializeWithDepth: depth - 1.		self addChild: tbranch.		tbranch translationX: 0 y: 1.0  z:0.0.		tbranch rotationAroundZ: -20.		tbranch _ TTree new initializeWithDepth: depth - 1.		self addChild: tbranch.		tbranch translationX: 0 y: 1.0  z:0.		tbranch rotationAroundZ: 20.		].	^self					! !!TTriangle methodsFor: 'initialize' stamp: 'DPR 1/9/2004 14:05'!initBounds	| d1 d2 d3 c1 c2 c3 c radius center|" Graphics Gems 1 - page 22"	d1 _ (v2-v1) dot: (v2-v1).	d2 _ (v3-v2) dot: (v1- v2).	d3 _ (v1-v3) dot: (v2-v3).	c1 _ d2*d3.	c2 _ d3*d1.	c3 _ d1*d2.	c _ c1+c2+c3.	radius _ ((d1+d2)*(d2+d3)*(d3+d1)/c)sqrt * 0.5.	center _ (((c2+c3)*v1) + ((c3+c1)*v2) + ((c1+c2)*v3))/(2*c).	boundSphere _ TBoundSphere localPosition: center radius: radius.	boundSphere frame: self.! !!TTriangle methodsFor: 'initialize' stamp: 'das 2/17/2004 16:46'!initialize	| c h |	super initialize.	h _ (1-(0.5*0.5))sqrt.	c _ ((0.5*0.5)/h )negated.	v1 _ B3DVector3 x: 0.0 y:h+c z: 0.0.	v2 _ B3DVector3 x: -0.5 y:c z: 0.0.	v3 _ B3DVector3 x: 0.5 y:c z:0.0.	self initBounds.	normal _ (v1 cross: v2) normalized.	^self! !!TTriangle methodsFor: 'render'!pick: pointer	^ pointer pickTriangle: normal tri: v1 tri: v2 tri: v3.			! !!TTriangle methodsFor: 'render' stamp: 'das 3/12/2004 14:04'!renderPrimitive: ogl	normal ifNil: [ normal _ (v1 cross: v2) normalized.].	ogl		glBegin: GLTriangles;			glNormal3fv: normal;			glTexCoord2f:0.5 with: 0.0;	glVertex3fv: v1;			glTexCoord2f:1.0 with:1.0;	glVertex3fv: v3;			glTexCoord2f:0.0 with:1.0;	glVertex3fv: v2;		glEnd.! !!TTriangle methodsFor: 'accessing'!v1: vv1 v2: vv2 v3: vv3	v1 _ vv1.	v2 _ vv2.	v3 _ vv3.	normal _ nil.	self boundsChanged.! !!TUserCamera methodsFor: 'accessing' stamp: 'das 2/17/2004 11:42'!addOverlay: ov	overlays add: ov.! !!TUserCamera methodsFor: 'accessing' stamp: 'das 12/20/2003 15:14'!avatar	^avatar! !!TUserCamera methodsFor: 'accessing' stamp: 'das 7/31/2004 11:52'!avatar: aFrame	avatar _ aFrame.	pointer avatar: aFrame.! !!TUserCamera methodsFor: 'accessing' stamp: 'DPR 7/13/2004 16:21'!debugOverlay	^debugOverlay! !!TUserCamera methodsFor: 'accessing' stamp: 'das 10/3/2004 17:02'!downPointer	^ avatar downPointer.! !!TUserCamera methodsFor: 'accessing' stamp: 'das 7/14/2004 03:34'!forwardOnY	^ avatar forwardOnY."	^ forwardOnY."! !!TUserCamera methodsFor: 'accessing' stamp: 'das 7/14/2004 03:34'!forwardOnY: foy	avatar forwardOnY: foy."	forwardOnY _ forwardOnY + foy.	self frameChanged."! !!TUserCamera methodsFor: 'accessing' stamp: 'DPR 7/14/2004 22:36'!morphicOverlay	^morphicOverlay! !!TUserCamera methodsFor: 'accessing' stamp: 'das 12/20/2003 14:47'!pointer	^ pointer.! !!TUserCamera methodsFor: 'accessing' stamp: 'das 2/17/2004 13:43'!pointer:pntr	pointer _ pntr.! !!TUserCamera methodsFor: 'accessing' stamp: 'das 2/17/2004 11:04'!removeOverlay: ov	overlays remove: ov.! !!TUserCamera methodsFor: 'accessing' stamp: 'das 12/20/2003 15:28'!setDoRender: bool	doRender _ bool.! !!TUserCamera methodsFor: 'accessing' stamp: 'ar 9/30/2004 15:44'!snapshot! !!TUserCamera methodsFor: 'accessing' stamp: 'ar 10/1/2004 13:57'!snapshot: ptr		self morphicOverlay dock addSnapshotItem: (TSnapshot new initializeWithFrame: avatar).! !!TUserCamera methodsFor: 'accessing' stamp: 'das 7/30/2004 01:42'!thirdPerson	^ thirdPerson.! !!TUserCamera methodsFor: 'accessing' stamp: 'das 8/4/2004 22:25'!thirdPerson: cbool	thirdPerson_cbool.! !!TUserCamera methodsFor: 'transform' stamp: 'ar 10/4/2004 13:59'!followAvatar	| at ct trans bt |	thirdPerson ~= 0.0 ifTrue:[		at_ avatar globalTransform.		ct _ self localTransform.		trans _ B3DMatrix4x4 identity. 		trans translation: (B3DVector3 x:0.0 y:0.7 z: 4)*thirdPerson.		bt _ at composeWith: trans. "This is the target position of the camera"		trans _ ct translation + ((bt translation - ct translation)/4.0)."at translation ~= ct translation ifTrue:[		self lookAt:at translation up: (B3DVector3 x:0 y:1 z:0) * thirdPerson.].self translation: trans."		currentSpace _ avatar root.		at _ at asQuaternion.		ct _ ct asQuaternion.		ct_ct slerpTo: at at: 0.25.		self localTransform: (ct asMatrix4x4 translation:trans).	]ifFalse:[		currentSpace _ avatar root.		self localTransform: avatar globalTransform.	].	pointer cameraTransform: self localTransform.	thirdPersonDelta ~=0 ifTrue:[		thirdPerson _ thirdPerson + thirdPersonDelta.		thirdPerson <= 0.0 ifTrue:[thirdPersonDelta _ 0. thirdPerson _ 0.0.].		thirdPerson >=1.0 ifTrue:[ thirdPersonDelta _ 0. thirdPerson _ 1.0].	].	avatar driving ifTrue:[avatar meta driveStep].! !!TUserCamera methodsFor: 'transform' stamp: 'das 9/25/2004 14:00'!postRender! !!TUserCamera methodsFor: 'transform' stamp: 'das 9/25/2004 17:32'!preRender"This method gets called just before the rendering""if we have transitioned to a new space, for the camera onto the TAvatar"	avatar currentSpace = avatarSpace ifFalse:[ 		self localTransform: avatar localTransform.		pointer cameraTransform: self localTransform.		avatarSpace _ avatar currentSpace].	pointer resetSelected.	^ self followAvatar.! !!TUserCamera methodsFor: 'transform' stamp: 'das 8/7/2004 12:53'!snapBack	avatar goto: avatar snapTrans count: 6.	avatar snapTrans: nil.! !!TUserCamera methodsFor: 'initialize' stamp: 'das 10/3/2004 17:27'!frustumChanged	overlays do:[ :ol | ol frustumChanged: self].	avatar viewAngle: viewAngle bounds: self bounds zScreen: zScreen.! !!TUserCamera methodsFor: 'initialize' stamp: 'das 10/3/2004 17:19'!initializeWithViewPort: vp	super initializeWithViewPort: vp.	pointer _ TPointer new.	pointer minDistance: zNear.	pointer camera: self.	self addChild: pointer.	yellowButtonPressed _ false.	redButtonPressed _ false.	renderInterval _ 50.0.  "render every 50 milliseconds by default"	renderEstimate _ 30.0.  "estimate of rendering time"	doRender _ true.	lastRenderTime _ 0.0.	remoteControl _ nil.	overlays _ OrderedCollection new.	self addOverlay: (buttonsOverlay _ TOverlayButtons new camera: self).	self addOverlay: (morphicOverlay _ vp).	"self addOverlay: (debugOverlay _ TDebugOverlay new)."	thirdPerson _ 1.0.	thirdPersonDelta _ 0.	! !!TUserCamera methodsFor: 'remoteControl' stamp: 'das 12/21/2003 12:10'!isRemoteControl	^ remoteControl ~= nil.! !!TUserCamera methodsFor: 'remoteControl' stamp: 'das 12/21/2003 12:10'!setRemoteControl: bool	remoteControl _ bool.! !!TUserCamera methodsFor: 'render' stamp: 'das 3/12/2004 14:04'!renderFrame: ogl space: space" Only render if we are rendering in a portal - otherwise, we interfere with the user ."	| rval |	doRender ifTrue:[		inPortal ifFalse:[			avatar ifNotNil:[				avatar visibleTree: false. 				rval _  super renderFrame: ogl space: space.				avatar visibleTree: true.				^ rval.			].		] ifTrue:[				^ super renderFrame: ogl space: space.		].	].	^ 0.! !!TUserCamera methodsFor: 'render' stamp: 'ar 9/30/2004 15:19'!renderOverlay: ogl	overlays ifNotNil:[		overlays do:[:ov |				"reset the buffers"				ogl glDepthMask: GLTrue;					glDisable: GLBlend;					glClear: (GLDepthBufferBit bitOr: GLStencilBufferBit).				"and render each overlay"				ov renderOverlay: ogl]].! !!TUserCamera methodsFor: 'chat' stamp: 'das 12/22/2003 11:06'!chatObject	chatObject ifNotNil:[^chatObject].	chatObject := TVoiceRecorder new.	^chatObject! !!TUserCamera methodsFor: 'chat' stamp: 'das 12/22/2003 11:06'!chatStatus	^self chatObject statusString! !!TUserCamera methodsFor: 'chat' stamp: 'das 12/22/2003 11:07'!endChat	chatObject ifNotNil:[self isChatting ifTrue:[chatObject stopRecording]].! !!TUserCamera methodsFor: 'chat' stamp: 'das 7/31/2004 09:49'!endChat: ptr	chatObject ifNotNil:[self isChatting ifTrue:[chatObject stopRecording]].! !!TUserCamera methodsFor: 'chat' stamp: 'das 12/22/2003 11:07'!isChatting	^chatObject notNil and:[chatObject isRecording]! !!TUserCamera methodsFor: 'chat' stamp: 'das 12/22/2003 11:07'!startChat	self chatObject startRecording.! !!TUserCamera methodsFor: 'chat' stamp: 'das 7/31/2004 09:49'!startChat: ptr	self chatObject startRecording.! !!TUserCamera methodsFor: 'popUp' stamp: 'das 2/20/2004 10:51'!makeFloor: sp fileName: txtrName	| stone txt |	txt _ TTexture				new initializeWithFileName: txtrName				mipmap: true				shrinkFit: false.	txt uvScale: 16.0@16.0.	stone _ TCube new.	stone extentX:80 y:0.5 z: 80.	stone translationX: 0 y: -4.0 z: 0.0.	stone texture: txt.	stone objectName: 'floor'.	sp addChild: stone.	^ stone.! !!TUserCamera methodsFor: 'popUp' stamp: 'DPR 7/14/2004 17:43'!makePopup	"put the popup in an overlay that tracks the camera"	buttonsOverlay makePopup.! !!TUserCamera methodsFor: 'events' stamp: 'das 9/25/2004 16:48'!blueButtonDown: anEvent	| selected |	selected := pointer selectedObject.	(selected notNil and:[selected wantsBlueButton]) ifTrue:[		avatar selection: pointer selection pointerDown: anEvent.		].! !!TUserCamera methodsFor: 'events' stamp: 'das 9/25/2004 16:48'!blueButtonUp: anEvent	| selected |	selected := pointer selectedObject.	(selected notNil and:[selected wantsBlueButton]) ifTrue:[		avatar selection: pointer selection pointerUp: anEvent. ]! !!TUserCamera methodsFor: 'events' stamp: 'das 9/23/2004 23:09'!calcPointerTransform: pointerXY	| bCenter at up side cpointer |" x and y are negated on purpose. Why? Because the z value should actually be negated as it is referring to a position in front of the camera (in the negative z direction) but anyone trying to do the math for TPointer will probably want to use a positive direction vector. OK? Get it? Essentially the math is wrong, but it is consistent. "	bCenter _ self bounds center.	at _ (B3DVector3				x: bCenter x - pointerXY x				y: pointerXY y - bCenter y				z: zScreen ) normalized.	up _ B3DVector3 x: 0.0 y:1.0 z:0.0.	side _ (up cross: at) normalized.	up _ (at cross: side) normalized.	cpointer _ B3DMatrix4x4 identity.	cpointer at: 1 at: 1 put: side x.	cpointer at: 1 at: 2 put: side y.	cpointer at: 1 at: 3 put: side z.	cpointer at: 2 at: 1 put: up x.	cpointer at: 2 at: 2 put: up y.	cpointer at: 2 at: 3 put: up z.	cpointer at: 3 at: 1 put: at x.	cpointer at: 3 at: 2 put: at y.	cpointer at: 3 at: 3 put: at z.	^ cpointer transposed.! !!TUserCamera methodsFor: 'events' stamp: 'DPR 5/31/2004 12:06'!dropFiles: aFileStream event: evt	pointer dropFiles: aFileStream event: evt.	! !!TUserCamera methodsFor: 'events' stamp: 'DPR 8/27/2004 08:09'!goToSnapshot: item	item verifyProperlyVeiled.		avatar future: 50.0 perform: #goToPortal:transform: withArguments: { item root . item globalTransform }.	self killFrame: true.! !!TUserCamera methodsFor: 'events' stamp: 'DPR 8/17/2004 21:57'!gotoSpace: aSpace transform: aTransform	avatar future: 50.0 perform: #goToPortal:transform: withArguments: { aSpace . aTransform }.	self killFrame: true.! !!TUserCamera methodsFor: 'events' stamp: 'das 9/25/2004 16:48'!keyDown: anEvent	avatar selection: pointer selection keyDown: anEvent.	! !!TUserCamera methodsFor: 'events' stamp: 'das 10/3/2004 16:54'!keyStroke: anEvent	"first check to see if the pointer object wants the keyboard input.	Should change to have pointer tell us when it wants the keyboard, so we aren't broadcasting this request to all instances"	(pointer wantsKeyboard: anEvent)		ifTrue:[avatar selection: pointer selection keyStroke: anEvent. ^self].	anEvent keyValue = 1 ifTrue: [ self toggleAvatarPerson. ^self. ].	anEvent keyValue = 2 ifTrue: [ self halt. ^self. ].	anEvent keyValue = 18 ifTrue:[ self switchMirror. ^self.].	anEvent keyValue = 19 ifTrue:[		self root ambientSoundPlaying ifTrue:[			self root stopAmbientSound.] ifFalse:[			self root startAmbientSound].			^ self. ].	(anEvent keyValue = 3) ifTrue:[		"Need some sort of visual indication here...."		self isChatting 			ifTrue:[self endChat]			 ifFalse:[self startChat].		^ self.	].	anEvent keyValue = 30 ifTrue:[ self translation: self translation + (0@1@0). ^self. ].	anEvent keyValue = 31 ifTrue:[ self translation: self translation - (0@1@0). ^self.].	! !!TUserCamera methodsFor: 'events' stamp: 'das 9/25/2004 16:49'!keyUp: anEvent	avatar selection: pointer selection keyUp: anEvent.	! !!TUserCamera methodsFor: 'events' stamp: 'das 10/3/2004 23:44'!mouseDown: evt	| root |	self pointerXY: evt cursorPoint.	remoteControl ifNotNil:[ 		root _ remoteControl root.		remoteControl removeChild: self.		root addChild: self.		self localTransform: remoteControl globalTransform.		pointer cameraTransform: self localTransform.		self setDoRender: true.		remoteControl _ nil.		avatar forwardOnY: 6.		].	mouseDownTime _ evt timeStamp.	(evt controlKeyPressed not and:[evt yellowButtonPressed]) ifTrue:[		yellowButtonPressed _ true.		avatar meta startDriving: evt shiftPressed.		].	evt redButtonPressed ifTrue:[		redButtonPressed _ true.		(avatar selection: pointer selection pointerDown: evt) ifFalse:[self makePopup.].		pointer setDown: avatar pointer isDown.		pointer doSelect: avatar pointer doSelect.	] ifFalse:[		avatar selection: pointer selection event2D: evt.	].! !!TUserCamera methodsFor: 'events' stamp: 'das 9/25/2004 18:25'!mouseMove: evt	"evt is a MouseMoveEvent"	self pointerXY: evt position.	(evt anyButtonPressed and:[ evt yellowButtonPressed not]) ifTrue:[		avatar selection: pointer selection pointerMove: evt asMouseMove.	] ifFalse:[		avatar selection: pointer selection event2D: evt asMouseMove.	].	pointer setDown: avatar pointer isDown.	pointer doSelect: avatar pointer doSelect.! !!TUserCamera methodsFor: 'events' stamp: 'das 10/3/2004 23:47'!mouseUp: evt	yellowButtonPressed ifTrue:[		evt timeStamp - mouseDownTime < 250 ifTrue:[ 			avatar snapTrans ifNotNil:[avatar snapBack.] ifNil:[				pointer selectedObject ifNotNil:[					pointer selectedObject isWindow ifTrue:[ pointer selectedObject gotoWindow:avatar pointer.].].].			] ifFalse:[ avatar snapTrans: nil.].		yellowButtonPressed_ false.		avatar meta stopDriving.		].	redButtonPressed ifTrue:[ 		avatar selection: pointer selection pointerUp: evt. 		pointer setDown: avatar pointer isDown.		pointer doSelect: avatar pointer doSelect.		redButtonPressed _ false.].	self pointerXY: evt cursorPoint.! !!TUserCamera methodsFor: 'events' stamp: 'das 10/3/2004 13:16'!openHalo: ptr	CroquetGlobals theTeapotMorph addHalo.! !!TUserCamera methodsFor: 'events' stamp: 'das 10/3/2004 23:51'!pointerXY: pxy 	| xy trans |	xy _  pxy - viewPort topLeft.	trans _ self calcPointerTransform: xy.	pointer  localTransform: trans.	avatar meta speedControl: (self bounds center - xy)/ (self bounds extent *0.5) pointerTransform:  pointer localTransform.	avatar metaSend localTransform: avatar localTransform.! !!TUserCamera methodsFor: 'events' stamp: 'das 2/17/2004 13:36'!switchMirror	rearCam ifNil:[		rearCam _ TOverlayRearView new initialize: self viewPort.		overlays add: rearCam.		] ifNotNil:[ overlays remove: rearCam. rearCam _ nil.].! !!TUserCamera methodsFor: 'events' stamp: 'ar 10/4/2004 15:50'!toggleAvatarPerson	thirdPerson := thirdPerson - 1.	thirdPerson < 0 ifTrue:[thirdPerson := 5].! !!TUserCamera methodsFor: 'morph import' stamp: 'ar 9/30/2004 13:45'!makePicture: aFile	| win image txtr |	[[aFile binary.	image _ Form fromBinaryStream: (RWBinaryOrTextStream with: aFile contents) reset]		ensure: [aFile close].	"make a picture from a form, and put it in a window in front of the camera"	txtr _ TTexture new.	txtr initializeWithForm: image				mipmap: true				shrinkFit: false.]		on: Error do: [ :ex |			txtr _ TTexture new initializeWithForm: TForm defaultTForm mipmap: true shrinkFit: true.			ex return. ].	win _ avatar makeWindowInFront.	win contents: txtr.	^ win! !!TUserCamera methodsFor: 'morph import' stamp: 'ar 9/30/2004 13:45'!makePortal: aPortal	"make a portal in front of me, linking to another portal"	| win |	win _ avatar makeWindowInFront.	win contents: (TPortal new linkPortal: aPortal).	^ win.! !!TUserCamera methodsFor: 'avatar' stamp: 'das 7/29/2004 15:46'!clickOpenAvatarFile: avatarPath	avatar loadAvatar: avatarPath.! !!TUserCamera methodsFor: 'painter' stamp: 'das 9/6/2004 20:51'!clickOpenAliceFile: filePath	| frame trans teaUrl model |	teaUrl := 'http://www.reed.com/TeaLand'.	2 to: filePath size do:[:i| teaUrl := teaUrl,'/', (filePath at: i)].	teaUrl := (teaUrl allButLast: 4), '.tea'.	model := CroquetData loadAliceModel: filePath url: teaUrl.	trans _ self translation - (self lookAt * 10).	frame _ TSpinner new.	frame matNil.	frame translation: trans.	frame contents: model.	avatar root addChild: frame.	frame translation: trans.	avatar root addChild: frame.! !!TUserCamera methodsFor: 'painter' stamp: 'DPR 7/18/2004 17:09'!makePoohMeshFrom: aForm	| list pts subdivision mask |	mask := Form extent: aForm extent*2 depth: 1.	(WarpBlt toForm: mask)		sourceForm: aForm destRect: mask boundingBox;		combinationRule: Form over;		cellSize: 1;		colorMap: (Color maskingMap: aForm depth);		warpBits.	subdivision := PoohSubdivision withSize: (mask boundingBox).	list := mask traceOutlines.	list := list collect:[:poly|		poly collect:[:loop|			pts _ StrokeSimplifier new.			loop do:[:pt| pts add: pt].			pts closeStroke.			pts := pts finalStroke.			pts := StrokeSimplifier smoothen: pts length: 10.			pts := LineIntersections regularize: pts.			pts do:[:pt| subdivision insertPoint: pt].			pts]].	list := list collect:[:poly|		poly collect:[:loop| subdivision constraintOutline: loop].	].	list do:[:poly|		poly keysAndValuesDo:[:index :loop|			subdivision markExteriorEdges: (index = 1) in: loop.		].	].	^subdivision build3DObject: false.! !!TUserCamera methodsFor: 'painter' stamp: 'ar 10/2/2004 20:23'!makePoohObjectFrom: aForm player: aPlayer rotateBy: rot replaceOldCostume: aBoolean	| aSpace pts bbForm tex mat subdivision b3dMesh mesh pos scale tfm |	"Convert the form"	bbForm := Form extent: aForm extent asSmallerPowerOfTwo depth: 32.	aForm displayScaledOn: bbForm in: (bbForm boundingBox insetBy: 1).	"Smear the borders of the texture a bit to prevent problems in texture mapping"	bbForm smearFill: 10. "pixels - less is faster but more is safer"	aSpace := avatar root.	"Create the texture"	tex := TTexture new initializeWithForm: bbForm mipmap: true shrinkFit: true extension: #colorKeyZero.	"The material"	mat _ TMaterial new.	mat ambientColor: #(1 1 1 1) asFloatArray.	mat diffuseColor: #(1 1 1 1) asFloatArray.	mat texture: tex.	mat textureMode: GLModulate.	"The b3d mesh"	true ifTrue:[		b3dMesh := self makePoohMeshFrom: aForm.		scale := 0.01.	] ifFalse:[		pts _ StrokeSimplifier new.		aForm traceOutline: Color transparent do:[:aPoint| pts add: aPoint].		pts closeStroke.		pts := pts finalStroke.		pts := StrokeSimplifier smoothen: pts length: 10.		pts := LineIntersections regularize: pts.		subdivision _ PoohSubdivision constraintOutline: pts.		b3dMesh _ subdivision build3DObject: false. "single sided textures"		scale := 0.02.	].	tfm := (B3DRotation axis: 1@0@0 angle: 180) asMatrix4x4.	tfm := tfm composeWith: (B3DRotation axis: 0@1@0 angle: rot) asMatrix4x4.	tfm := tfm composeWith: (B3DMatrix4x4 withScale: scale@scale@scale).	tfm := tfm composeWith: (B3DMatrix4x4 withOffset: (aForm width * -0.5) @ (aForm height * -0.5) @ 0).	b3dMesh transformBy: tfm.	"The TMesh"	mesh := TMesh new initializeWithVertices: b3dMesh vertices 		alias: nil 		norms: b3dMesh vertexNormals		textureUV: b3dMesh texCoords		faceGroups: {1. b3dMesh zeroBasedFaceGroup}		material: mat.	mesh solid: false.	mesh initBounds.	"Position it"	pos := avatar translation - (avatar lookAt * 10).	mesh translation: pos.	mesh rotationAroundY: avatar yaw + rot.	aSpace  addChild: mesh.	"mesh startScript:[mesh turnTo: cWorld activeCamera].""self tweakWorld ifNotNil:[	mesh replaceUserCostume: mesh sketch: aForm.	aSpace player signal: #created with: mesh player.]."! !!TUserCamera methodsFor: 'painter' stamp: 'ar 10/2/2004 20:24'!popUpBillboard: aForm player: aPlayer	| aSpace bbForm size billboard aPosition txtr mat |	aSpace :=  self root.	size := aForm extent * 0.01.	bbForm := Form extent: aForm extent asSmallerPowerOfTwo depth: 32.	aForm displayScaledOn: bbForm in: (bbForm boundingBox insetBy: 1).	billboard := TBillboard new.	txtr := TTexture new initializeWithForm: aForm mipmap: true shrinkFit: true extension: #colorKeyZero.	txtr aspect: size y / size x asFloat. 	txtr extent: size.	txtr objectOwner: billboard.	mat _ TMaterial new.	mat ambientColor: #(1 1 1 0.99) asFloatArray.	mat diffuseColor: #(1 1 1 0.99) asFloatArray.	mat emissiveColor: #(1 1 1 0.99) asFloatArray.	txtr material: mat.	txtr extent: txtr extent * 3.		billboard addChild: txtr.	aPlayer ifNotNil:[		aPlayer frame: billboard.		aPlayer sketch: aForm.		aPlayer icon: nil.		^self].	billboard player sketch: aForm.	aPosition := self translation - (self lookAt * 10).	billboard translation: aPosition.	aSpace addChild: billboard."	| pos size aSpace bbForm |	size := aForm extent * 0.01.	bbForm := Form extent: aForm extent asSmallerPowerOfTwo depth: 32.	aForm displayScaledOn: bbForm in: (bbForm boundingBox insetBy: 1).	pos := cWorld activeCamera translation + (cWorld activeCamera lookAt * 10).	aSpace := cWorld activeCamera root.	aSpace popUpBillboard: bbForm extent: size at: pos.	aSpace asyncSend: #popUpBillboard:extent:at: with: bbForm with: size with: pos."! !!TVoiceRecorder methodsFor: 'initialization' stamp: 'das 4/11/2003 16:08'!addLocalFeedback	testFeedback _ true.! !!TVoiceRecorder methodsFor: 'initialization' stamp: 'das 4/15/2003 11:18'!initialize	super initialize.	codec := GSMCodec new.	volumeBuffers := 1.	volumeAverage := 0."	self addLocalFeedback."! !!TVoiceRecorder methodsFor: 'private' stamp: 'ar 3/12/2002 22:01'!allocateBuffer	"Allocate a new buffer and reset nextIndex."	| bufSize |	"Multiple of samplesPerFrame that is approx. bufferTime long"	bufSize := (self bufferSize truncateTo: self samplesPerFrame) max: self samplesPerFrame.	(currentBuffer == nil or:[currentBuffer monoSampleCount ~= bufSize]) ifTrue:[		currentBuffer _ SoundBuffer newMonoSampleCount: bufSize.	].	nextIndex _ 1.! !!TVoiceRecorder methodsFor: 'private' stamp: 'das 4/18/2003 01:33'!bufferSize	"Buffer size should be small enough to		* fit into a UDP packet even if worst-case compressed		* be small enough not to introduce addl. latency (even on 11kHz)	"	^1600! !!TVoiceRecorder methodsFor: 'private' stamp: 'ar 3/12/2002 21:28'!emitBuffer: buffer	"Do nothing here - all work is done in #sendBuffer:"! !!TVoiceRecorder methodsFor: 'private' stamp: 'ar 6/15/2002 20:04'!recordLoop	"Record process loop that records samples."	| n sampleCount repeat hasSound |	n _ 0.	repeat := 5.	[true] whileTrue: [		n = 0 ifTrue: [bufferAvailableSema wait].		n _ self primRecordSamplesInto: currentBuffer startingAt: nextIndex.		nextIndex _ nextIndex + n.		stereo			ifTrue: [sampleCount _ currentBuffer stereoSampleCount]			ifFalse: [sampleCount _ currentBuffer monoSampleCount].		nextIndex > sampleCount ifTrue: [			hasSound := self sendBuffer: currentBuffer ifSilent: (repeat > 0).			repeat := hasSound ifTrue:[5] ifFalse:[repeat - 1].			self allocateBuffer.		].	].! !!TVoiceRecorder methodsFor: 'private' stamp: 'ar 10/4/2004 16:16'!sendBuffer: buffer ifSilent: sendAnyways	"Send the shared buffer"	| data nowFrameTime hasSound useCodec|	nowFrameTime := frameTime.true ifTrue:[	useCodec _ codec.] ifFalse:[	useCodec _ nil.].	stereo 		ifTrue:[frameTime := frameTime + (1000.0 * buffer stereoSampleCount / samplingRate)]		ifFalse:[frameTime := frameTime + (1000.0 * buffer monoSampleCount / samplingRate)].	self meterFrom: 1 count: buffer monoSampleCount in: buffer.	volumeBuffers > 10 ifTrue:[volumeBuffers := 0. volumeAverage := 0].	volumeAverage := volumeAverage + meterLevel.	volumeBuffers := volumeBuffers+1.	hasSound := meterLevel >  self noiseThreshold.	(hasSound or:[sendAnyways]) ifFalse:[^hasSound].	useCodec 		ifNil:[data := buffer asByteArray]		ifNotNil:[data := useCodec encodeSoundBufferNoReset: buffer].	teaOwner ifNotNil:[		teaOwner metaSend playSoundBuffer:data at:nowFrameTime stereo:stereo samplingRate:samplingRate codec:(useCodec ifNotNil:[useCodec class]).	].	teaOwner ifNil:[teaOwner := CroquetGlobals theTeapotMorph activeCamera].	teaOwner teaParty ifNil:[	teaOwner playSoundBuffer:data at:nowFrameTime stereo:stereo samplingRate:samplingRate codec:(useCodec ifNotNil:[useCodec class]).	].	^hasSound! !!TVoiceRecorder methodsFor: 'recording controls' stamp: 'ar 5/20/2002 16:19'!isRecording	^recordProcess notNil! !!TVoiceRecorder methodsFor: 'recording controls' stamp: 'ar 5/20/2002 16:17'!startRecording	frameTime := 0.	super startRecording.! !!TVoiceRecorder methodsFor: 'accessing' stamp: 'das 4/18/2003 00:41'!noiseThreshold	"Heuristic value for now..."	^1000! !!TVoiceRecorder methodsFor: 'accessing' stamp: 'ar 6/17/2002 00:09'!statusString	self isRecording ifFalse:[^''].	^'Chat Volume: ', self volumeAverage printString, '%'! !!TVoiceRecorder methodsFor: 'accessing' stamp: 'ar 3/13/2002 01:03'!teaOwner	^teaOwner! !!TVoiceRecorder methodsFor: 'accessing' stamp: 'ar 3/13/2002 01:21'!teaOwner: aTObject	teaOwner := aTObject.! !!TVoiceRecorder methodsFor: 'accessing' stamp: 'ar 6/16/2002 23:58'!volumeAverage	^(volumeAverage max: 0) * 100 / volumeBuffers // 32768! !!TWaveDemo methodsFor: 'private'!compile: x	SomeInstance _ nil.	self class compile: x.	SomeInstance _ self.! !!TWaveDemo methodsFor: 'accessing'!contents: cnt	contents ifNotNil:[		self removeChild: contents.].	contents _ cnt.	contents objectOwner: self.	contents texture: texture.	self addChild: contents.! !!TWaveDemo methodsFor: 'accessing' stamp: 'das 7/8/2004 10:23'!targetForm	^texture targetForm! !!TWaveDemo methodsFor: 'accessing'!texture	^texture! !!TWaveDemo methodsFor: 'accessing'!textureForm	^texture textureForm! !!TWaveDemo methodsFor: 'stepping'!drawSampleBufferLines: buf in: target color: color	"Draw the sample buffer in the target form using the given color."	| delta cc sample lastSample |	delta _ buf size // target width - 2.	cc _ target getCanvas.	sample _ buf at: 1.	sample _ sample // 64 + 128 min: 255 max: 1.	lastSample _ sample.	1 to: target width do:[:i|	sample _ buf at: i*delta.		sample _ sample // 64 + 128 min: 255 max: 1.		cc line: (i-1@lastSample) to: i@sample width: 1 color: color.		lastSample _ sample.	].! !!TWaveDemo methodsFor: 'stepping'!drawSampleBufferPoints: buf in: target color: color	"Draw the sample buffer in the target form using the given color."	| sample delta pos pv |	delta _ buf size // target width - 2.	pv _ color pixelValueForDepth: 32.	1 to: target width do:[:i|		sample _ buf at: i*delta.		sample _ sample // 64 + 128 min: 255 max: 1.		pos _ (sample * target width) + i.		target bits at: pos put: pv.		"pos > 1 ifTrue:[target bits at: pos+1 put: pv]."	].! !!TWaveDemo methodsFor: 'stepping' stamp: 'ar 9/30/2004 15:03'!renderFrame: ogl parent: parent root: root	(root ambientSoundPlaying and: [ root ambientSound volume ~= 0.0 ]) ifTrue: [		timeOut := TeaTime now asFloat + 200.0.].	"the following samples the sound up to 200 milliseconds after its last play"	(timeOut >= TeaTime now asFloat) ifTrue: [stepSelector ifNotNil:[self perform: stepSelector]].	^ super renderFrame: ogl parent: parent root: root.! !!TWaveDemo methodsFor: 'stepping' stamp: 'ar 10/1/2004 15:03'!sample1	| target r buf |	target _ texture targetForm.	r _ 1@11 corner: target width-1@246.	self warpTarget: target to: r.	self smoothTarget: target amount: 180.	buf _ SoundPlayer lastPlayBuffer.	buf ifNotNil:["draw the current sample buffer"		self drawSampleBufferLines: buf in: target color: myColor.	] ifNil:["draw a straight line"		SoundPlayer useLastBuffer: true.		target getCanvas 			line: target boundingBox leftCenter 			to: target boundingBox rightCenter 			width: 1 color: myColor.	].	"and upload new texture"	texture invalidate: target boundingBox.! !!TWaveDemo methodsFor: 'stepping'!smoothTarget: target amount: amt	target bits primFill: 0.	(BitBlt toForm: target)		combinationRule: 30;		sourceForm: image;		copyBitsTranslucent: amt.! !!TWaveDemo methodsFor: 'stepping' stamp: 'ar 10/4/2004 10:16'!step	SoundPlayer isPlaying 		ifTrue:[timeOut := 10]		ifFalse:[timeOut < 0 ifTrue:[^self].				timeOut := timeOut - 1].	stepSelector ifNotNil:[self perform: stepSelector].! !!TWaveDemo methodsFor: 'stepping' stamp: 'ar 10/1/2004 15:04'!update	| target r buf |	target _ texture targetForm.	r _ 1@11 corner: target width-1@246.	self warpTarget: target to: r.	self smoothTarget: target amount: 180.	buf _ SoundPlayer lastPlayBuffer.	buf ifNotNil:["draw the current sample buffer"		self drawSampleBufferLines: buf in: target color: myColor.	] ifNil:["draw a straight line"		SoundPlayer useLastBuffer: true.		target getCanvas 			line: target boundingBox leftCenter 			to: target boundingBox rightCenter 			width: 1 color: myColor.	].	"and upload new texture"	texture invalidate: target boundingBox.! !!TWaveDemo methodsFor: 'stepping'!wantsSteps	^ true! !!TWaveDemo methodsFor: 'stepping'!warpTarget: target to: r	target unhibernate.	image unhibernate.	(WarpBlt toForm: image)		combinationRule: Form over;		cellSize: 1;		sourceForm: target;		copyQuad: r innerCorners		toRect: target boundingBox.! !!TWaveDemo methodsFor: 'events'!handlesPointerDown: ptr	^true! !!TWaveDemo methodsFor: 'events'!handlesPointerOver: ptr	^true! !!TWaveDemo methodsFor: 'events' stamp: 'DPR 1/9/2004 14:05'!pointerDown: ptr	| state |	state _ SoundPlayer isPlaying not.	self syncSound: state.! !!TWaveDemo methodsFor: 'events' stamp: 'ar 9/30/2004 15:03'!pointerEnter: ptr	myColor _ Color r: 0.5 g: 1.0 b: 0.0.	timeOut := TeaTime now asFloat + 200.0.! !!TWaveDemo methodsFor: 'events' stamp: 'ar 9/30/2004 15:03'!pointerLeave: ptr	myColor _ Color r: 1.0 g: 0.5 b: 0.0.	timeOut := TeaTime now asFloat + 200.0.! !!TWaveDemo methodsFor: 'events'!syncSound: shouldBePlaying	SoundPlayer isPlaying = shouldBePlaying ifTrue:[^self].	shouldBePlaying ifFalse: [^SoundPlayer shutDown].	self root startAmbientSound.! !!TWaveDemo methodsFor: 'initialize' stamp: 'ar 9/30/2004 15:03'!initialize	| w |	super initialize.	timeOut := TeaTime now asFloat + 200.0.	w _ 256.	stepSelector _ #sample1.	texture _ TTexture new initializeWithForm: (Form extent: w@256 depth: 32) mipmap: false shrinkFit: true.	texture objectOwner: self.	image _ Form extent: w@256 depth: 32.	myColor _ Color r: 1.0 g: 0.5 b: 0.0.	SomeInstance _ self.	^self! !!TWaveDemo methodsFor: 'testing'!isComponent	^true! !!TWaveDemo methodsFor: 'fileIn/Out' stamp: 'ar 6/6/2002 15:31'!prepareToExportOn: exporter	super prepareToExportOn: exporter.	image := Form extent: image extent depth: image depth bits: nil.! !!TWaves methodsFor: 'accessing' stamp: 'das 5/19/2002 00:11'!envTexture: et		envTexture _ et.! !!TWaves methodsFor: 'accessing' stamp: 'das 5/19/2002 01:45'!texture: txtr	super texture: txtr.	aspect _ txtr aspect.! !!TWaves methodsFor: 'events' stamp: 'das 5/16/2002 19:11'!handlesPointerDown: pointer	^ true.! !!TWaves methodsFor: 'events' stamp: 'das 8/11/2002 22:37'!pointerDown: pointer"saves a few variables. Most of the work is done in #pointerMove:"	selectedPoint _ pointer selectedPoint copy.	cameraNorm _ (pointer camera frameLookAt: self) negated.	self pointerMove: pointer.	! !!TWaves methodsFor: 'events' stamp: 'DPR 1/9/2004 14:05'!pointerMove: pointer	| loc dx dy index |" #pointerMove: determines which cell we have clicked inside of and after proper bounds checking, it adds a spring force to that cell and a few surrounding it. The #step routine then calculates the wave functions based upon this disturbance."	dx _ self extent x/2.	dy _ self extent y/2.	pointer selectedFrame = self 	"(pointer frame: self pickQuad: (B3DVector3  x:0.0 y:0.0 z:1.0)		q1: (B3DVector3 x: location x + dx negated y: location y + dy z: location z)		q2: (B3DVector3 x: location x + dx negated y: location y + dy negated z: location z)		q3: (B3DVector3 x: location x + dx y: location y + dy negated z: location z)		q4: (B3DVector3 x: location x + dx y: location y + dy z: location z))""	(pointer frame: self pickPlane: selectedPoint normal: cameraNorm)"	 ifTrue:[		loc _ pointer selectedPoint - location.		dx _ (0.5+(loc x/extent x) * size x) asInteger.		dx = size x ifTrue:[dx = dx-1.].		dy _ (0.5+(loc y/extent y)* size y) asInteger.		dy = size y ifTrue:[dy = dy -1].		index _ (dy*size x + dx).		self impulse: index.		].	! !!TWaves methodsFor: 'actions' stamp: 'das 5/21/2002 13:47'!impulse: index	(index >=1 and:[index <= (surface size - (size x+1))]) ifTrue:[			surface at: index put: 2.0.			surface at: index+1 put: 2.0.			surface at: index + size x put: 2.0.			surface at: index + size x + 1 put: 2.0. ].		countDown _ 300.! !!TWaves methodsFor: 'initialize' stamp: 'ar 9/30/2004 13:12'!initializeWithSize: sz	| nCell |	size _ sz.	nCell _ size x * size y.	surface _ FloatArray ofSize: nCell.	force _ FloatArray ofSize: nCell.	velocity _ FloatArray ofSize: nCell.	fVert _ FloatArray ofSize: nCell.	fHorz _ FloatArray ofSize: nCell.	fDiag1 _ FloatArray ofSize: nCell.	fDiag2 _ FloatArray ofSize: nCell.	normals _ B3DVector3Array ofSize: nCell.	textureUV _ B3DVector2Array ofSize: nCell.	oneOverSqrtTwo _ 1.0/(2.0 sqrt).		matWater _ TMaterial new.	matWater ambientColor: #(0.8 0.9 0.9 0.9) asFloatArray.	matWater diffuseColor: #(0.8 0.9 0.9 0.9) asFloatArray.	aspectFixed _ true.	self disableCaching.	countDown _ 0.	nSteps _ 0.0.	^self! !!TWaves methodsFor: 'testing' stamp: 'das 5/16/2002 19:01'!isComponent	^ true.! !!TWaves methodsFor: 'render' stamp: 'das 7/1/2004 00:35'!renderAlpha: ogl	| tx ty ttx tty vx vy vvx vvvx vvy tcount bcount |" This first renders the base texture, then it renders the environment map on the disturbed surface. If the surface has not been touched in 300 cycles, we can assume that it has calmed sufficiently so that we can just re-render the rectangle with the environment map on it instead of the entire grid."(countDown ~= 0) ifTrue:[	envTexture ifNotNil:[envTexture enable: ogl.].	matWater enable: ogl.	ogl glPushAttrib: GLTextureBit;		glTexEnvf: GLTextureEnv with: GLTextureEnvMode with: GLDecal;		glTexGeni: GLS with: GLTextureGenMode with: GLSphereMap;		glTexGeni: GLT with: GLTextureGenMode with: GLSphereMap;		glEnable: GLTextureGenS;		glEnable: GLTextureGenT.	tx _ 1.0/(size x - 1).	ty _ -1.0/(size y - 1).	vvvx _ location x - (self extent x/2.0).	vvy _ location y - (self extent y/2.0).	vx _ self extent x/(size x -1)asFloat.	vy _ self extent y/(size y -1)asFloat.	tty _ 0.0.	tcount _ 1.	bcount _ tcount+size x.	ogl glEnable: GLNormalize.	size y -1 timesRepeat:[		ogl glBegin: GLTriangleStrip.		ttx _ 0.0.		vvx _ vvvx.		size x timesRepeat:[			ogl glTexCoord2f: ttx with: tty+ty;				glNormal3f: (fVert at: bcount) with: (fHorz at: bcount) with: 1.0;				glVertex3f: vvx with: vvy + vy with: (surface at: bcount);				glTexCoord2f: ttx with: tty;				glNormal3f: (fVert at: tcount) with: (fHorz at: tcount) with: 1.0;				glVertex3f: vvx with: vvy with: (surface at: tcount).			ttx _ ttx + tx.			vvx _ vvx + vx.			tcount _ tcount+1.			bcount _ bcount+1.			].		ogl glEnd.		tty _ tty + ty.		vvy _ vvy + vy.		].	ogl glDisable: GLNormalize.	matWater disable: ogl.	ogl glPopAttrib. 	envTexture ifNotNil:[envTexture disable: ogl.].]ifFalse:[super renderAlpha: ogl.].						! !!TWaves methodsFor: 'stepping' stamp: 'das 7/11/2003 14:39'!step" Calculates the wave function for the surface if countDown is non-zero. It is a simple cellular based spring function. We assume that the restoring force is based only on the difference of the z-values. Given that every action has a corresponding reaction, we need only test for delta z in three directions - down, to the right, and diagonal down and to the right. The resulting difference is added to the current cell and subtracted from the adjacent cell."countDown = 0 ifFalse:[		countDown _ countDown-1.	fVert replaceFrom: (size x+1) to: (fVert size) with: surface startingAt: 1.	fVert replaceFrom: 1 to: size x with: surface startingAt: 1.	fVert -= surface.	fHorz replaceFrom: 2 to: (fHorz size) with: surface startingAt: 1.	1 to: size y do:[:i | | dy |		dy _ (i-1) * size x + 1.		fHorz at: dy put: (surface at: dy).].	fHorz -= surface.	fDiag1 replaceFrom: (size x + 2) to: (fDiag1 size) with: surface startingAt:1.	fDiag1 -= surface.	fDiag2 replaceFrom: (size x -1) to: (fDiag2 size) with: surface startingAt: 1.	fDiag2 -= surface.	force replaceFrom: 1 to: force size with: fVert."	force +=fVert."	fVert replaceFrom: 1 to: (fVert size - size x) with: fVert startingAt:(size x + 1).	force -=fVert.	force +=fHorz.	fHorz replaceFrom: 1 to: (fHorz size - 1) with: fHorz startingAt: 2.	force -=fHorz.	fDiag1 *= oneOverSqrtTwo.	force += fDiag1.	fDiag1 replaceFrom: 1 to: (fDiag1 size - (size x +2)) with: fDiag1 startingAt: (size x + 2).	force -= fDiag1.	fDiag2 *= oneOverSqrtTwo.	force += fDiag2.	fDiag2 replaceFrom: 1 to: (fDiag2 size - (size x -1)) with: fDiag2 startingAt: (size x - 1).	force -= fDiag2.	force *= 0.02.	velocity += force.	surface += velocity.	surface *= 0.97.	"n _ B3DVector3 new.	1 to: normals size do:[ :i |		n x: (fHorz at: i) y: (fVert at: i) z: 1.0.		normals at: i put: n.]."		].! !!TWaves methodsFor: 'stepping' stamp: 'DPR 8/24/2002 16:17'!stepAt: msecs	"this is a quick hack.   The way this works is that it simulates steps at a 25 fps frame rate - 40 milliseconds per step - by calling the step method as many times as would have occurred since lastStepTime if the steps occur on 40 msec boundaries"	| nSteps |	nSteps _ (msecs // 40) - (self lastStepTime // 40).	[nSteps > 0] whileTrue: [ nSteps _ nSteps -1. self step ].! !!TWaves methodsFor: 'stepping' stamp: 'das 6/16/2002 09:31'!stepx" Calculates the wave function for the surface if countDown is non-zero. It is a simple cellular based spring function. We assume that the restoring force is based only on the difference of the z-values. Given that every action has a corresponding reaction, we need only test for delta z in three directions - down, to the right, and diagonal down and to the right. The resulting difference is added to the current cell and subtracted from the adjacent cell."countDown = 0 ifFalse:[	fVert replaceFrom: (size x+1) to: (fVert size) with: surface startingAt: 1.	fVert replaceFrom: 1 to: size x with: surface startingAt: 1.	fVert -= surface.	fHorz replaceFrom: 2 to: (fHorz size) with: surface startingAt: 1.	1 to: size y do:[:i | | dy |		dy _ (i-1) * size x + 1.		fHorz at: dy put: (surface at: dy).].	fHorz -= surface.	fDiag1 replaceFrom: (size x + 2) to: (fDiag1 size) with: surface startingAt:1.	fDiag1 -= surface.	fDiag2 replaceFrom: (size x -1) to: (fDiag2 size) with: surface startingAt: 1.	fDiag2 -= surface.	force replaceFrom: 1 to: force size with: fVert."	force +=fVert."	fVert replaceFrom: 1 to: (fVert size - size x) with: fVert startingAt:(size x + 1).	force -=fVert.	force +=fHorz.	fHorz replaceFrom: 1 to: (fHorz size - 1) with: fHorz startingAt: 2.	force -=fHorz.	fDiag1 *= oneOverSqrtTwo.	force += fDiag1.	fDiag1 replaceFrom: 1 to: (fDiag1 size - (size x +2)) with: fDiag1 startingAt: (size x + 2).	force -= fDiag1.	fDiag2 *= oneOverSqrtTwo.	force += fDiag2.	fDiag2 replaceFrom: 1 to: (fDiag2 size - (size x -1)) with: fDiag2 startingAt: (size x - 1).	force -= fDiag2.	force *= 0.02.	velocity += force.	surface += velocity.	surface *= 0.97.	"n _ B3DVector3 new.	1 to: normals size do:[ :i |		n x: (fHorz at: i) y: (fVert at: i) z: 1.0.		normals at: i put: n.]."		].! !!TWaves methodsFor: 'stepping' stamp: 'das 5/16/2002 19:06'!wantsSteps	^ true.! !!TWaves class methodsFor: 'instance creation' stamp: 'ar 9/30/2004 12:39'!initializeWithSize: sz^ self new initializeWithSize: sz! !!TWidget class methodsFor: 'instance creation' stamp: 'DPR 2/17/2004 12:06'!createNewWithUrl: url fileName: fName scale: scl	| tframe |	tframe _ (CroquetData loadURL: url reuseExisting: false).	tframe ifNil:[		tframe _ (TLoad3DSMax new initializeWithFileName: 			(FileDirectory pathFrom: fName) scale: scl) frame.		tframe boundsDepth: 1.		tframe initBounds.		TExporter export: tframe asBinary:url.		tframe do:[ :tf |			tf isMesh ifTrue:[ tf materialList do:[ :ml |				ml ambientColor: #(0.2 0.5 1.0 0.8) asFloatArray.				ml diffuseColor:#(0.2 0.5 1.0 0.8) asFloatArray.				ml textureMode: GLModulate.				].			tf checkAlpha.			].		].	].	^ tframe.! !!TWindow methodsFor: 'actions' stamp: 'das 7/31/2004 10:30'!closeContents	self closeContents: nil.! !!TWindow methodsFor: 'actions' stamp: 'das 7/31/2004 10:29'!closeContents: ptr	contents ifNotNil:[		contentsOn ifTrue:[			self removeChild: rectFront.			rectFront _ saveContents.			"contents visible: false."			contentsOn _ false.			self addChild: rectFront.			contents3D ifTrue:[self addChild: rectBack].			rectFront extent: windowFrame extent asPoint.			self extent: rectFront extent asPoint.			windowButtons openButton.			].		].! !!TWindow methodsFor: 'actions' stamp: 'das 10/14/2003 01:39'!doCloseContents	contents ifNotNil:[		contentsOn ifTrue:[			self removeChild: rectFront.			rectFront _ saveContents.			"contents visible: false."			contentsOn _ false.			self addChild: rectFront.			contents3D ifTrue:[self addChild: rectBack].			rectFront extent: windowFrame extent asPoint.			self extent: rectFront extent asPoint.			windowButtons openButton.			].		].! !!TWindow methodsFor: 'actions' stamp: 'abc 7/26/2002 19:20'!doKillWindow	frameParent removeChild: self.	contents ifNotNil:[ 		contents isPortal ifTrue:[ 			contents kill.			contents _ nil.			].		].! !!TWindow methodsFor: 'actions' stamp: 'das 3/9/2004 14:48'!doOpenContents	contents ifNotNil:[		contentsOn ifFalse:[			self removeChild: rectFront.			contents3D ifTrue:[self removeChild: rectBack.].			contentsOn _ true.			rectFront _ contents.			"contents visible: true."			self addChild: rectFront.			rectFront extent: windowFrame extent asPoint.			self extent: rectFront extent asPoint.			windowButtons closeButton.			].		].! !!TWindow methodsFor: 'actions' stamp: 'das 9/26/2004 10:59'!gotoWindow: ptr	| front distance trans dx ac |	ac _ ptr camera.	dx _ self extent y.	dx _ dx/2.0.	distance _ dx/((ac viewAngle degreesToRadians/2.0) tan).	self extent x/self extent y > ac aspect ifTrue:[ distance _ distance/ac aspect.].	distance _ distance + windowFrame radius.	front _ B3DVector3 x: 0 y: 0 z: distance.	front _ self orientation localPointToGlobal: front.	front _ self translation + front.	trans _ self localTransform copy.	trans translation: front.	ptr avatar goto: trans count: 6.! !!TWindow methodsFor: 'actions' stamp: 'ar 10/2/2004 15:24'!grabWindow: ptr	| trans |	trans _ ptr avatar globalTransform orthoNormInverse composeWith: self globalTransform.	self meta transferTo: ptr avatar.	self meta localTransform: trans.! !!TWindow methodsFor: 'actions' stamp: 'ar 9/30/2004 12:02'!killWindow	frameParent removeChild: self.	contents ifNotNil:[ 		contents isPortal ifTrue:[ 			contents kill.			contents _ nil.			].		].! !!TWindow methodsFor: 'actions' stamp: 'das 7/31/2004 10:28'!killWindow: ptr	frameParent removeChild: self.	contents ifNotNil:[ 		contents isPortal ifTrue:[ 			contents kill.			contents _ nil.			].		].! !!TWindow methodsFor: 'actions' stamp: 'ar 10/2/2004 15:23'!moveWindow: pointer	| delta  |	(pointer frame: self pickPlane: selectedPoint normal: cameraNorm) ifTrue:[		delta _ selectedPoint - pointer selectedPoint.		self meta translation: (self translation - (self orientation localPointToGlobal: delta)).		^ true.].	^ false.! !!TWindow methodsFor: 'actions' stamp: 'DPR 1/9/2004 14:05'!openContents	(self handlesEvent: #openContents) ifTrue:[		self signal: #openContents.	] ifFalse:[		self doOpenContents.	].! !!TWindow methodsFor: 'actions' stamp: 'das 7/31/2004 10:29'!openContents: ptr	(self handlesEvent: #openContents) ifTrue:[		self signal: #openContents.	] ifFalse:[	contents ifNotNil:[		contentsOn ifFalse:[			self removeChild: rectFront.			contents3D ifTrue:[self removeChild: rectBack.].			contentsOn _ true.			rectFront _ contents.			"contents visible: true."			self addChild: rectFront.			rectFront extent: windowFrame extent asPoint.			self extent: rectFront extent asPoint.			windowButtons closeButton.			].		].	].! !!TWindow methodsFor: 'actions' stamp: 'das 3/9/2004 14:51'!releaseWindow	self releaseToRoot.! !!TWindow methodsFor: 'actions' stamp: 'das 7/31/2004 10:34'!releaseWindow: ptr	self releaseToRoot.! !!TWindow methodsFor: 'actions' stamp: 'ar 10/2/2004 15:23'!resizeWindow: pointer	| delta deltaLoc sz |	(pointer frame: windowFrame pickPlane: selectedPoint normal: windowFrame frontNorm) ifTrue:[		delta _ selectedPoint - pointer selectedPoint.		deltaLoc _ delta/2.0.		21 = eventNum ifTrue:[ delta y: delta y negated. ].		22 = eventNum ifTrue:[ delta x: delta x negated. delta y: delta y negated.].		23 = eventNum ifTrue:[ delta x: delta x negated. ].		" 24 = eventNum ifTrue:[ --- do nothing --- ]."		sz _ windowFrame extent asPoint.		sz _ (sz x + delta x) @ (sz y + delta y).		self meta extent: sz.		self meta translation: (self translation - (self orientation localPointToGlobal: deltaLoc)).		selectedPoint _ selectedPoint - (B3DVector3 x: deltaLoc x y: deltaLoc y z: 0.0).		tinyCube translation: selectedPoint.		^ true.].	^ false.! !!TWindow methodsFor: 'actions' stamp: 'ar 10/2/2004 15:23'!rotateWindow: pointer	| delta trans spfrom spto deltaLoc theta |		" Rotate around the y-axis "	spinTime _ TeaTime now asFloat - lastTime.	lastTime _ TeaTime now asFloat.		(pointer frame: self pickCylinderFrom: (B3DVector3 x: 0.0 y: 100.0 z: 0.0)				to: (B3DVector3 x: 0.0 y: -100.0 z: 0.0) radius: selectedRadius)			ifFalse: [ "we are not on the cylinder anymore...."			delta _ 2*selectedRadius.			(pointer framePointer row1 dot: (pointer framePosition))  > 0 				ifFalse:[  delta _ delta negated.].			deltaLoc _ pointer framePointer row1 * delta.			(pointer frame: self pickCylinderFrom: (B3DVector3 x: deltaLoc x y: 100.0 z: deltaLoc z)				to: (B3DVector3 x: deltaLoc x y: -100.0 z: deltaLoc z) radius: selectedRadius)				ifFalse:[lastSpin _ nil. ^ false.].			spto _ pointer selectedPoint copy- deltaLoc.			spto x: spto x negated				y: 0				z: spto z negated.			]	ifTrue: [spto _ pointer selectedPoint copy.].	spfrom _ selectedPoint copy.	spfrom y: 0.0.	spfrom normalize.	spto y: 0.0.	spto normalize.	theta _ ((spfrom z * spto x) - (spto z * spfrom x))"/selectedRadiusSquared".	theta < -1.0 ifTrue:[theta_ -1.0].	theta > 1.0 ifTrue:[theta _ 1.0].	theta _ theta arcSin radiansToDegrees/2.0.	lastSpin _ B3DMatrix4x4 identity rotationAroundY: theta.	trans _ self translation.	self translationX: 0.0 y:0.0 z:0.0.	self localTransform: (self localTransform composeWith: lastSpin).	self translation: trans.	self metaSend localTransform: localTransform clone.	^ true.! !!TWindow methodsFor: 'actions' stamp: 'ar 10/4/2004 16:03'!snapshotWindow: ptr	contents ifNil:[^nil].	contents isPortal ifFalse:[^nil].	self playSoundNamed: 'camera'.	CroquetGlobals theTeapotMorph dock addSnapshotItem:		(TSnapshot new initializeWithFrame: contents toPortal).! !!TWindow methodsFor: 'actions' stamp: 'tak 5/26/2004 00:46'!zoomWindow: pointer 	"This allows you to pull a window towards you."	| delta p0 i0 i1 t p newTranslation plainNormal |	(pointer frame: self pickPlane: selectedPoint normal: cameraNorm)		ifTrue: [			"assumed just horizontal"			plainNormal _ 0 @ 1 @ 0.			"plainNormal _ pointer camera localToGlobal: (0@1@0)."			p0 _ self localToGlobal: selectedPoint.			i0 _ pointer globalPosition.			i1 _ pointer globalTransform localPointToGlobal: 0 @ 0 @ 1.			[t _ (p0 - i0 dot: plainNormal) / (i1 - i0 dot: plainNormal)]				on: ZeroDivide do: [^ false].			p _ i0 + (t abs negated * (i1 - i0)).			delta _ p - p0.			newTranslation _ self translation + delta.			(pointer globalToLocal: newTranslation) z < pointer camera zScreen negated				ifTrue: ["self moveWindow: pointer."					^ true].			self translation: newTranslation.			^ true].	^ false! !!TWindow methodsFor: 'accessing' stamp: 'das 7/22/2003 16:26'!contents3D: cont		contents3D _ true.	self contents: cont.	windowFrame doInside: true.	self removeChild: rectBack.! !!TWindow methodsFor: 'accessing' stamp: 'das 3/9/2004 14:47'!contents: cont		contents ifNotNil:[ " put window into a known state "		contents = rectFront ifTrue:[		self removeChild: rectFront.		rectFront _ saveContents.		self addChild: rectFront.]].		contents _ cont.	contents3D ifFalse:[		contents translation: (contents translation + (B3DVector3 x:0 y:0 z:windowFrame radius)).].	contentsOn _ true.	self removeChild: rectFront.	saveContents _ rectFront.	rectFront _ contents.	contents material: matRectNorm.	rectFront extent: windowFrame extent.	self extent: rectFront extent asPoint.	rectBack extent: rectFront extent asPoint.	windowFrame extent: rectFront extent asPoint.	rectFront objectOwner: self.	self addChild: rectFront.	windowButtons closeButton.! !!TWindow methodsFor: 'accessing' stamp: 'das 3/9/2004 14:48'!extent	^ windowFrame extent asPoint! !!TWindow methodsFor: 'accessing' stamp: 'das 3/9/2004 14:48'!extent: ext	| sz |	rectFront extent: ext.	sz _ rectFront extent asPoint. " The rectFront might have something to say about this..."	rectBack extent: sz.	windowFrame extent: sz.	windowButtons extent: sz.! !!TWindow methodsFor: 'accessing' stamp: 'das 4/29/2002 19:09'!frameOn	^ windowFrame frameOn.! !!TWindow methodsFor: 'accessing' stamp: 'das 4/29/2002 19:10'!frameOn: bool	windowFrame frameOn: bool.! !!TWindow methodsFor: 'accessing' stamp: 'das 6/22/2003 19:08'!grabButton: bool	windowButtons grabButton: bool.! !!TWindow methodsFor: 'accessing' stamp: 'das 6/3/2002 12:47'!isBrowser: bool		isBrowser _ bool.! !!TWindow methodsFor: 'accessing' stamp: 'das 7/9/2002 14:41'!materialDown	^ matDown! !!TWindow methodsFor: 'accessing' stamp: 'das 7/9/2002 14:41'!materialHilite	^ matHilite! !!TWindow methodsFor: 'accessing' stamp: 'das 7/9/2002 14:40'!materialNorm	^ matNorm.! !!TWindow methodsFor: 'accessing' stamp: 'das 7/9/2002 14:40'!materialOver	^ matOver! !!TWindow methodsFor: 'accessing' stamp: 'das 7/13/2002 12:38'!radius	^ windowFrame radius.! !!TWindow methodsFor: 'accessing' stamp: 'das 7/15/2002 20:49'!radius: rad	^ windowFrame radius:rad.! !!TWindow methodsFor: 'accessing' stamp: 'das 8/12/2004 11:33'!rectBack	^ rectBack.! !!TWindow methodsFor: 'accessing' stamp: 'DPR 2/27/2002 09:21'!rectFront	contentsOn ifFalse:[ 		^ rectFront. 				] ifTrue:[ ^ saveContents.].	^ rectFront.! !!TWindow methodsFor: 'accessing' stamp: 'das 3/9/2004 14:51'!rectFront: rf	contentsOn ifFalse:[ 		rectFront _ rf. 				rectFront extent: windowFrame extent asPoint.		self extent: rectFront extent asPoint.		] ifTrue:[ saveContents _ rf.].	rf translation: (rf translation + (B3DVector3 x:0 y:0 z:windowFrame radius)).	rf objectOwner: self.! !!TWindow methodsFor: 'events' stamp: 'das 6/1/2002 13:16'!handlesKeyboard: ptr	contentsOn ifTrue:[		contents isComponent ifTrue:[			(contents handlesKeyboard: ptr) ifTrue:[^ true.]]].	^false.! !!TWindow methodsFor: 'events'!handlesPointerDown: pointer	^ true.! !!TWindow methodsFor: 'events'!handlesPointerOver: pointer	^ true.! !!TWindow methodsFor: 'events' stamp: 'DPR 6/1/2004 03:03'!keyDown: ptr	contents isComponent ifTrue:[ contents keyDown: ptr.].! !!TWindow methodsFor: 'events' stamp: 'DPR 7/5/2004 20:03'!keyStroke: ptr	contents isComponent ifTrue:[ contents keyStroke: ptr.].! !!TWindow methodsFor: 'events' stamp: 'DPR 6/1/2004 03:04'!keyUp: ptr	contents isComponent ifTrue:[ contents keyUp: ptr.].! !!TWindow methodsFor: 'events' stamp: 'das 10/3/2004 16:54'!pointerDown: pointer"	pointer event2D shiftPressed ifTrue:[		self meta switchContents.		rectFront material: matRectDown.		^ true.]."	selectedFrame _ pointer selectedFrame.	selectedFrame isComponent ifTrue:[ selectedFrame pointerDown: pointer].	selectedPoint _ pointer selectedPoint copy.	selectedFrame = windowFrame ifTrue:[ 		eventNum _ pointer selectedIndex.		selectedRadiusSquared _ 			(selectedPoint x * selectedPoint x) + (selectedPoint z * selectedPoint z).		selectedRadius _ selectedRadiusSquared sqrt.		tinyCube translation: selectedPoint.		tinyCube visible: true.	] ifFalse:[ eventNum _ 0.].	windowFrame material: matDown."	windowFrame materialAlpha: nil."	rectFront material: matRectDown."	rectFront materialAlpha: nil."	rectBack material: matRectDown.	"	rectBack materialAlpha: nil."	cameraNorm _ (pointer camera frameLookAt: self) negated.	selectedNorm _ pointer selectedNormal.	self spin: nil.	lastSpin _ nil.	lastTime _ TeaTime now asFloat.	^ true.! !!TWindow methodsFor: 'events' stamp: 'DPR 5/28/2004 16:53'!pointerEnter: pointer	selectedFrame _ pointer selectedFrame.	selectedFrame isComponent ifTrue:[ selectedFrame pointerEnter: pointer].	windowFrame material: matOver.	windowButtons enable.	rectFront material: matRectOver.	rectBack material: matRectOver.	^ true.! !!TWindow methodsFor: 'events' stamp: 'das 7/13/2002 13:05'!pointerLeave: pointer 	selectedFrame isComponent ifTrue:[ selectedFrame pointerLeave: pointer].	windowFrame material: matNorm.	windowButtons disable.	rectFront material: matRectNorm.	rectBack material: matRectNorm.	windowFrame hilite: 0.	^ true! !!TWindow methodsFor: 'events' stamp: 'das 8/7/2004 13:04'!pointerMove: pointer"	pointer event2D shiftPressed ifTrue:[		^ false.]."	eventNum = 0 ifTrue:[ 		selectedFrame ifNotNil:[		selectedFrame isComponent ifTrue:[ 			selectedFrame pointerMove: pointer.].			^ true.].		^ false.]."RESIZE THE WINDOW"	(eventNum >= 21 and: [eventNum <=24]) ifTrue:[ ^ self resizeWindow: pointer. ]."ROTATE AROUND THE Y-AXIS"	(eventNum = 13 or:[eventNum = 14]) ifTrue:[ ^ self rotateWindow: pointer.]." MOVE THE WINDOW PERPENDICULAR TO THE CAMERA"	(eventNum = 11 ) ifTrue:[ ^ pointer event2D shiftPressed ifTrue:[self zoomWindow: pointer.]	ifFalse:[self moveWindow: pointer.]]." MOVE THE WINDOW PARALLEL TO THE CAMERA "	(eventNum = 12) ifTrue:[ ^ pointer event2D shiftPressed ifTrue:[self moveWindow: pointer.]		ifFalse:[self zoomWindow: pointer.].].! !!TWindow methodsFor: 'events' stamp: 'DPR 5/28/2004 17:09'!pointerOver: pointer	selectedFrame ~= pointer selectedFrame ifTrue:[		selectedFrame isComponent ifTrue:[selectedFrame pointerLeave: pointer.].		pointer selectedFrame isComponent ifTrue:[pointer selectedFrame pointerEnter: pointer].		selectedFrame _ pointer selectedFrame.].	pointer selectedFrame objectName = 'windowFrame' ifTrue:[		windowFrame hilite: pointer selectedIndex.		^ true.].	selectedFrame isComponent ifTrue:[ 		selectedFrame pointerOver: pointer.].	rectFront = pointer selectedFrame ifTrue:[		windowFrame hilite: 0.].	^ true.! !!TWindow methodsFor: 'events' stamp: 'ar 10/4/2004 13:40'!pointerUp: pointer	selectedFrame ifNotNil:[		selectedFrame isComponent ifTrue:[ 			selectedFrame pointerUp: pointer].].	windowFrame material: matNorm.	windowFrame hilite: 0.	rectFront material: matRectNorm.	rectBack material: matRectNorm.	tinyCube visible: false.	TeaTime now asFloat - lastTime > 20.0 ifTrue:[spinTime _ TeaTime now asFloat - lastTime].	(spinTime<300.0 and:[spinTime> 10.0])ifTrue:[		self spin: lastSpin.		].	lastSpin _ nil.	selectedFrame = rectFront ifTrue:[		contentsOn ifFalse:[			self openContents.			^ true.].].	^ true.! !!TWindow methodsFor: 'events' stamp: 'ar 6/6/2002 20:18'!wantsBlueButton	^rectFront wantsBlueButton! !!TWindow methodsFor: 'initialize' stamp: 'das 3/9/2004 14:50'!initialize	super initialize.	windowFrame _ TWindowFrame new.	windowFrame objectOwner: self.	eventNum _ 0.	matHilite _ TMaterial new.	matHilite ambientColor: #(1.0 1.0 0.2 0.5) asFloatArray.	matHilite diffuseColor: #(1.0 1.0 0.2 0.5) asFloatArray.	windowFrame materialHilite: matHilite.	isBrowser _ false.	tinyCube _ TCube new.	tinyCube extentX: 0.1 y: 0.1 z: 0.1.	tinyCube visible: false.	self addChild: windowFrame.	self addChild: tinyCube.	matNorm _ TMaterial new.	matNorm ambientColor: #(0.5 0.7 0.7 0.5) asFloatArray.	matNorm diffuseColor: #(0.5 0.7 0.7 0.5) asFloatArray.	windowFrame material: matNorm.	matOver _ TMaterial new.	matOver ambientColor: #(0.2 0.5 1.0 0.8) asFloatArray.	matOver diffuseColor: #(0.2 0.5 1.0 0.8) asFloatArray.	matDown _ TMaterial new.	matDown ambientColor: #(0.2 1.0 0.5 0.8) asFloatArray.	matDown diffuseColor: #(0.2 1.0 0.5 0.8) asFloatArray.	matTiny _ TMaterial new.	matTiny ambientColor: #(1.0 1.0 0.2 1.0) asFloatArray.	matTiny diffuseColor: #(1.0 1.0 0.2 1.0) asFloatArray.	tinyCube material: matTiny.	alpha _ 0.	dalpha _ 1.	matRectNorm _ TMaterial new.	matRectNorm ambientColor: #(0.8 0.8 0.8 0.5) asFloatArray.	matRectNorm diffuseColor: #(0.8 0.8 0.8 0.5) asFloatArray.	matRectOver _ TMaterial new.	matRectOver ambientColor: #(1.0 1.0 1.0 0.8) asFloatArray.	matRectOver diffuseColor: #(1.0 1.0 1.0 0.8) asFloatArray.	matRectDown _ TMaterial new.	matRectDown ambientColor: #(1.0 1.0 1.0 0.9) asFloatArray.	matRectDown diffuseColor: #(1.0 1.0 1.0 0.9) asFloatArray.	matRectDown emissiveColor: #(1.0 1.0 1.0 1.0) asFloatArray.	rectFront _ TRectangle new.	rectFront extent: windowFrame extent asPoint.	rectFront location: (B3DVector3 x:0.0 y:0.0 z: windowFrame radius).	rectFront material: matRectNorm.	rectFront objectOwner: self.	rectFront objectName:'rectFront'.	self addChild: rectFront.	rectBack _ TRectangle new.	rectBack extent: windowFrame extent asPoint.	rectBack location: (B3DVector3 x:0.0 y:0.0 z: windowFrame radius negated).	rectBack flip: true.	rectBack material: matRectNorm.	rectBack objectOwner: self.	rectBack objectName: 'rectBack'.	self addChild: rectBack.		windowFrame frameOn: true.	windowButtons _ TWindowButtons new initializeWithWindow: self extent: windowFrame extent."	windowButtons objectOwner: self."	self addChild: windowButtons.	contentsOn _ false.	contents3D _ false.	^self! !!TWindow methodsFor: 'testing' stamp: 'ar 6/7/2002 23:47'!isBrowser	^ isBrowser ifNil:[false].! !!TWindow methodsFor: 'testing'!isComponent	^ true.! !!TWindow methodsFor: 'testing' stamp: 'das 4/15/2002 20:24'!isSolid	^ false.! !!TWindow methodsFor: 'testing' stamp: 'das 7/15/2002 20:45'!isWindow	^ true.! !!TWindow methodsFor: 'toys' stamp: 'ar 10/1/2004 08:46'!onOpenProtectedContents	| login userName password tm teaWorld |	contents ifNil:[^self].	contentsOn ifTrue:[^self].	login := TLoginMorph new.	userName := password := nil.	login name: 'your name' 		actionBlock: [:user :pwd| 			userName := user. password := pwd.			self signal: #loginComplete.			true] 		cancelBlock: [self signal: #loginComplete].	login fullBounds.	tm _ TMorphic new initializeOpaque: true extent: login fullBounds.	teaWorld _ TMorphMonitor new initializeWithWorld: nil extent: login fullBounds.	teaWorld eventsTo: tm.	tm passEvents: false.	teaWorld world addMorphCentered: login.	tm translation: rectFront translation + (0@0@0.01).	self addChild: tm.	self waitUntil: #loginComplete.	self removeChild: tm.	(userName == nil or:[password == nil]) ifTrue:[^self].	"@@@ password validation goes here @@@"	self doOpenContents.! !!TWindow methodsFor: 'stepping' stamp: 'ar 9/30/2004 15:07'!spin: x	spin _ x.! !!TWindow methodsFor: 'stepping' stamp: 'das 8/4/2004 18:14'!spinDelta	^spinTime.! !!TWindow methodsFor: 'stepping' stamp: 'ar 9/30/2004 15:07'!stepAt: msecs	| trans ticks transform |"hack approximation:  spin as many times as there would have been 20 msec ticks in the last time interval"		spin ifNotNil:[		ticks _ (msecs // 20) - (self lastStepTime // 20).		trans _ self translation.		self translationX: 0.0 y:0.0 z:0.0.		transform _ self localTransform.		[ ticks > 0 ] whileTrue: [ ticks _ ticks - 1. transform _ transform composeWith: spin.].		self localTransform: transform.		self translation: trans.	].! !!TWindow methodsFor: 'stepping'!wantsSteps	^ true.! !!TWindowButtons methodsFor: 'accessing' stamp: 'das 10/4/2002 18:52'!closeButton 	openButton switch: true.! !!TWindowButtons methodsFor: 'accessing' stamp: 'das 10/3/2002 19:31'!disable	frameChildren do:[ :fc | fc disable.]."	grabButton disable.	gotoButton disable.	killButton disable.	openButton disable.	cameraButton disable."! !!TWindowButtons methodsFor: 'accessing' stamp: 'das 10/3/2002 19:31'!enable	frameChildren do:[ :fc | fc enable.]."	grabButton enable.	gotoButton enable.	killButton enable.	openButton enable.	cameraButton enable."! !!TWindowButtons methodsFor: 'accessing' stamp: 'das 6/22/2003 19:06'!grabButton: bool 	grabButton switch: bool.! !!TWindowButtons methodsFor: 'accessing' stamp: 'ar 9/30/2004 13:12'!initializeWithWindow: win extent: ext	| tframe tframe2 path |	path _ {FileDirectory default pathName. 'Content'. 'Widgets'}."----------------------- goto button -----------------"	tframe _ TWidget createNewWithUrl:'http://www.reed.com/TeaLand/widgets/arrow.tea'		fileName:(path,{'arrow.ASE'}) scale: 1.0.	gotoButton _ TButton new initializeWithFrame: tframe.	gotoButton target: win action: #gotoWindow:."----------------------- kill button ------------------"	tframe _ TWidget createNewWithUrl:'http://www.reed.com/TeaLand/widgets/cross.tea'		fileName:(path,{ 'cross.ASE'}) scale: 0.5.	killButton _ TButton new initializeWithFrame: tframe.	killButton rotationAroundZ: 45.0.	killButton target: win action: #killWindow:."---------------------- open close button ---------------"	tframe _ TWidget createNewWithUrl:'http://www.reed.com/TeaLand/widgets/cross.tea'		fileName:(path,{'cross.ASE'}) scale: 0.5.	tframe2 _  TWidget createNewWithUrl:'http://www.reed.com/TeaLand/widgets/minus.tea'		fileName:(path,{'minus.ASE'}) scale: 0.5.	openButton _ TButton new initializeWithFrame: tframe		frame2: tframe2.	openButton target: win action:#openContents:.	openButton target2: win action2:#closeContents:."------------------------ grab button --------------------"	tframe _ TWidget createNewWithUrl:'http://www.reed.com/TeaLand/widgets/handOpen.tea'		fileName:(path,{'HandOpen.ASE'}) scale: 0.6.	tframe2 _ TWidget createNewWithUrl:'http://www.reed.com/TeaLand/widgets/handClosed.tea'		fileName:(path,{'HandClosed.ASE'}) scale: 0.6.	grabButton _ TButton new initializeSwitchWithFrame: tframe frame2:tframe2.	grabButton target: win action: #grabWindow:.	grabButton target2: win action2: #releaseWindow:.	grabButton rotationAroundZ: 180.0."--------------------- camera button -----------------------"	tframe _ TWidget createNewWithUrl:'http://www.reed.com/TeaLand/widgets/camera.tea'		fileName:(path,{'camera.ASE'}) scale: 0.6.	cameraButton _ TButton new initializeWithFrame:tframe.	cameraButton target: win action: #snapshotWindow:.	extent _ ext.	self addChild: grabButton.	self addChild: gotoButton.	self addChild: killButton.	self addChild: openButton.	self addChild: cameraButton.	self closeButton.	self extent: extent.	^self! !!TWindowButtons methodsFor: 'accessing' stamp: 'das 10/4/2002 18:52'!openButton 	openButton switch: false.! !!TWindowButtons methodsFor: 'initialize' stamp: 'das 10/3/2002 19:28'!extent: ext	| height |	height _ 0.55.	gotoButton translation:(B3DVector3 x: 0 y: ext y/2.0+height+0.25 z:0.0).	grabButton translation:(B3DVector3 x: ext x/4.0 y: ext y/2.0+height z:0.0).	cameraButton translation:(B3DVector3 x: ext x/-4.0 y: ext y/2.0+height z:0.0).	killButton translation:(B3DVector3 x: ext x/-2.0 y: ext y/2.0+height z:0.0).	openButton translation:(B3DVector3 x: ext x/2.0 y: ext y/2.0+height z:0.0).! !!TWindowButtons methodsFor: 'initialize' stamp: 'ar 9/8/2002 18:42'!material: mat	mat ifNil:[^self].	super material: mat.	frameChildren do:[ :fc | fc color: mat ambientColor copy.].! !!TWindowFrame methodsFor: 'accessing' stamp: 'das 2/20/2004 10:53'!colorize: col	material ifNil:[		material _ TMaterial new.		materialAlpha _ material.].	material ambientColor: col.	material diffuseColor: col.	self boundsChanged.! !!TWindowFrame methodsFor: 'accessing' stamp: 'das 6/21/2003 10:11'!doInside: bool	doInside _ bool.	self boundsChanged.! !!TWindowFrame methodsFor: 'accessing'!extent	^ extent.! !!TWindowFrame methodsFor: 'accessing'!extent: ext	extent _ ext.	self boundsChanged.! !!TWindowFrame methodsFor: 'accessing'!extentX: x y: y	extent x: x y: y.	self boundsChanged.! !!TWindowFrame methodsFor: 'accessing' stamp: 'das 6/21/2003 13:11'!frameBox	| extent2 |	extent2 _ extent/2.0.	^TBox origin: (extent2 x + radius) negated @ (extent2 y + radius) negated @ radius negated corner: (extent2 x + radius) @ (extent2 y + radius) @ radius.! !!TWindowFrame methodsFor: 'accessing'!frameOn		^ frameOn.! !!TWindowFrame methodsFor: 'accessing'!frameOn: bool		frameOn _ bool.! !!TWindowFrame methodsFor: 'accessing'!frontNorm	^ frontNorm.! !!TWindowFrame methodsFor: 'accessing'!hilite	^ hilite.! !!TWindowFrame methodsFor: 'accessing'!hilite: hval	hilite = hval ifTrue:[^self].	hilite _ hval.	hilite = 0 ifTrue:[ self enableCaching.] ifFalse:[ self disableCaching.]."	glListValid _ false."! !!TWindowFrame methodsFor: 'accessing' stamp: 'das 4/15/2002 20:26'!isSolid	^ false.! !!TWindowFrame methodsFor: 'accessing'!materialHilite	^ materialHilite.! !!TWindowFrame methodsFor: 'accessing'!materialHilite: mh	materialHilite _ mh.! !!TWindowFrame methodsFor: 'accessing'!radius		^ radius! !!TWindowFrame methodsFor: 'accessing'!radius: rad	radius _ rad.	self boundsChanged.! !!TWindowFrame methodsFor: 'accessing' stamp: 'das 6/21/2003 13:06'!scale: scale	extent _ extent * scale.	radius _ radius * scale.! !!TWindowFrame methodsFor: 'accessing'!segments		^ segments.! !!TWindowFrame methodsFor: 'accessing'!segments: sg		segments _ sg.! !!TWindowFrame methodsFor: 'initialize' stamp: 'DPR 1/9/2004 14:05'!initBounds	boundSphere _ TBoundSphere localPosition: B3DVector3 new radius: radius + (extent r / 2).	boundSphere frame: self! !!TWindowFrame methodsFor: 'initialize' stamp: 'das 2/17/2004 17:02'!initialize	super initialize.	segments _ 2. " number of segments/corner"	radius _ 0.25. " also 1/2 the width of the slab"	extent _ Point x: 4 y: 4. " x-y extent of the slab."	frontNorm _ B3DVector3 x: 0.0 y:0.0 z: 1.0.	self objectName: 'windowFrame'.	doInside _ false.	hilite _ 0.	^self! !!TWindowFrame methodsFor: 'render' stamp: 'DPR 7/12/2004 16:40'!pick: pointer	| dx dy dxn dyn rs sel |	rs _ radius * radius.	dx _ extent x/2.0.	dy _ extent y/2.0.	dxn _ dx negated.	dyn _ dy negated.	sel _ pointer copiedSelection." Top "	(pointer pickCylinderFrom: (B3DVector3 x: dxn y: dy z: 0) to:							    (B3DVector3 x: dx y: dy z: 0) radius: radius) ifTrue:		[		pointer selectedPoint y< dy ifTrue:[ 			pointer selected: sel.			(pointer pickQuad: (B3DVector3 x:0 y: -1 z: 0) 				q1: (B3DVector3 x:dx negated y: dy z: radius)				q2: (B3DVector3 x:dx y: dy z: radius)				q3: (B3DVector3 x:dx y: dy z: radius negated)				q4: (B3DVector3 x: dx negated y: dy z: radius negated)) ifTrue:[					pointer selectedIndex: 11.					^ true.].]		ifFalse:[			pointer selectedIndex: 11.			^ true.].]." Bottom "	(pointer pickCylinderFrom: (B3DVector3 x: dxn y: dyn z: 0) to:							    (B3DVector3 x: dx y: dyn z: 0) radius: radius) ifTrue:		[		pointer selectedPoint y> (dy negated) ifTrue:[ 			pointer selected: sel.			(pointer pickQuad: (B3DVector3 x:0 y: 1 z: 0) 				q1: (B3DVector3 x:dx negated y: dy negated z: radius)				q2: (B3DVector3 x:dx y: dy negated z: radius)				q3: (B3DVector3 x:dx y: dy negated z: radius negated)				q4: (B3DVector3 x: dx negated y: dy negated z: radius negated)) ifTrue:[					pointer selectedIndex: 12.					^ true.].]		ifFalse:[			pointer selectedIndex: 12.			^ true.].]." Left "	(pointer pickCylinderFrom: (B3DVector3 x: dxn y: dy z: 0) to:							    (B3DVector3 x: dxn y: dyn z: 0) radius: radius) ifTrue:		[		pointer selectedPoint x> (dx negated) ifTrue:[ 			pointer selected: sel.			(pointer pickQuad: (B3DVector3 x:1 y: 0 z: 0) 				q1: (B3DVector3 x:dx negated y: dy negated z: radius)				q2: (B3DVector3 x:dx negated y: dy negated z: radius negated)				q3: (B3DVector3 x:dx negated y: dy  z: radius negated)				q4: (B3DVector3 x: dx negated y: dy  z: radius )) ifTrue:[					pointer selectedIndex: 13.					^ true.].]		ifFalse:[		pointer selectedIndex: 13.		^ true.].]." Right "	(pointer pickCylinderFrom: (B3DVector3 x: dx y: dy z: 0) to:							    (B3DVector3 x: dx y: dyn z: 0) radius: radius) ifTrue:		[		pointer selectedPoint x< dx ifTrue:[ 			pointer selected: sel.			(pointer pickQuad: (B3DVector3 x:-1 y: 0 z: 0) 				q1: (B3DVector3 x:dx  y: dy negated z: radius)				q2: (B3DVector3 x:dx  y: dy negated z: radius negated)				q3: (B3DVector3 x:dx  y: dy  z: radius negated)				q4: (B3DVector3 x: dx  y: dy  z: radius )) ifTrue:[					pointer selectedIndex: 14.					^ true.].]		ifFalse:[		pointer selectedIndex: 14.		^ true.].]." Top Left"	(pointer pickSphere: (B3DVector3 x: dxn y: dy z: 0) radiusSquared: rs) ifTrue:		[pointer selectedIndex: 21.		^ true.]." Top Right"	(pointer pickSphere: (B3DVector3 x: dx y: dy z: 0) radiusSquared: rs) ifTrue:		[pointer selectedIndex: 22.		^ true.]."Bottom Right"	(pointer pickSphere: (B3DVector3 x: dx y: dyn z: 0) radiusSquared: rs) ifTrue:		[pointer selectedIndex: 23.		^ true.]."Bottom Left"	(pointer pickSphere: (B3DVector3 x: dxn y: dyn z: 0) radiusSquared: rs) ifTrue:		[pointer selectedIndex: 24.		^ true.].		^ false.! !!TWindowFrame methodsFor: 'render' stamp: 'das 3/12/2004 14:05'!renderInside: ogl x: dx y: dy	ogl glBegin: GLQuads."Inside frame""Left frame"		ogl glNormal3f: 1.0 with: 0.0 with: 0.0.		ogl glVertex3f: dx negated with: dy with: radius.		ogl glVertex3f: dx negated with: dy negated with: radius.		ogl glVertex3f: dx negated with: dy negated with: radius negated.		ogl glVertex3f: dx negated with: dy with: radius negated."Top frame"		ogl glNormal3f: 0.0 with: -1.0 with: 0.0.		ogl glVertex3f: dx negated with: dy with: radius.		ogl glVertex3f: dx negated with: dy with: radius negated.		ogl glVertex3f: dx with: dy with: radius negated.		ogl glVertex3f: dx with: dy with: radius."Right frame"		ogl glNormal3f: -1.0 with: 0.0 with: 0.0.		ogl glVertex3f: dx with: dy negated with: radius.		ogl glVertex3f: dx with: dy with: radius.		ogl glVertex3f: dx with: dy with: radius negated.		ogl glVertex3f: dx with: dy negated with: radius negated."Bottom frame"		ogl glNormal3f: 0.0 with: 1.0 with: 0.0.		ogl glVertex3f: dx with: dy negated with: radius.		ogl glVertex3f: dx with: dy negated with: radius negated.		ogl glVertex3f: dx negated with: dy negated with: radius negated.		ogl glVertex3f: dx negated with: dy negated with: radius.					ogl glEnd.! !!TWindowFrame methodsFor: 'render' stamp: 'das 3/12/2004 14:06'!renderPrimitive: ogl	| ringSin ringCos segs halfSegs pi2 ax vert1 vert2 norm1 norm2 dx dy vs1 vs2 vn1 vn2 |	vert1 _ B3DVector3 new.	vert2 _ B3DVector3 new.	norm1 _ B3DVector3 new.	norm2 _ B3DVector3 new.	segs _ 4 * segments.	halfSegs _ 2 * segments.	ringSin _ FloatArray ofSize: segs+1.	ringCos _ FloatArray ofSize: segs+1.	pi2 _ Float pi * 2.0.	1 to: segs do: [ : index |		ax _ ((index-1) * pi2) / segs.		ringSin at: index put: ax sin.		ringCos at: index put: ax cos.].	ringSin at: segs+1 put: (ringSin at: 1).	ringCos at: segs+1 put: (ringCos at: 1).	dx _ extent x/2.0.	dy _ extent y/2.0.	1 to: halfSegs do:[ :iv |		ogl glBegin: GLTriangleStrip." ---- top right ---- "	hilite = 22 ifTrue:[materialHilite enable: ogl.].		1 to: segments+1 do:[ :ih |			norm1 x: (ringSin at: (iv+1)) * (ringSin at: ih)				 y: (ringSin at: (iv+1)) * (ringCos at: ih)				 z: (ringCos at: (iv+1)).			ogl glNormal3fv: norm1.			vert1 _ norm1 * radius.			vert1 x: vert1 x + dx.			vert1 y: vert1 y + dy.			ogl glVertex3fv: vert1.			norm2 x: (ringSin at: iv) * (ringSin at: ih)				 y: (ringSin at: iv) * (ringCos at: ih)				 z: (ringCos at: iv).			ogl glNormal3fv: norm2.			vert2 _ norm2 * radius.			vert2 x: vert2 x + dx.			vert2 y: vert2 y + dy.			ogl glVertex3fv: vert2.			ih = 1 ifTrue:[ 				vn1 _ norm1 copy. 				vs1 _ vert1 copy.				vn2 _ norm2 copy. 				vs2 _ vert2 copy.].			].		hilite = 22 ifTrue:[material enable: ogl.].		hilite = 14 ifTrue:[materialHilite enable: ogl.].		ogl glNormal3fv: norm1.		vert1 y:0.		ogl glVertex3fv: vert1.		ogl glNormal3fv: norm2.		vert2 y: 0.		ogl glVertex3fv: vert2.		hilite = 14 ifTrue:[material enable: ogl.]." ---- bottom right ----- "	hilite = 23 ifTrue:[materialHilite enable: ogl.].		segments+1 to: (2*segments)+1 do:[ :ih |			norm1 x: (ringSin at: (iv+1)) * (ringSin at: ih)				 y: (ringSin at: (iv+1)) * (ringCos at: ih)				 z: (ringCos at: (iv+1)).			ogl glNormal3fv: norm1.			vert1 _ norm1 * radius.			vert1 x: vert1 x + dx.			vert1 y: vert1 y-  dy.			ogl glVertex3fv: vert1.			norm2 x: (ringSin at: iv) * (ringSin at: ih)				 y: (ringSin at: iv) * (ringCos at: ih)				 z: (ringCos at: iv).			ogl glNormal3fv: norm2.			vert2 _ norm2 * radius.			vert2 x: vert2 x + dx.			vert2 y: vert2 y - dy.			ogl glVertex3fv: vert2.			].		hilite = 23 ifTrue:[material enable: ogl.].		hilite = 12 ifTrue:[materialHilite enable: ogl.].		ogl glNormal3fv: norm1.		vert1 x:0.		ogl glVertex3fv: vert1.		ogl glNormal3fv: norm2.		vert2 x: 0.		ogl glVertex3fv: vert2.		hilite = 12 ifTrue:[material enable: ogl.]." ---- bottom left ---- "		hilite = 24 ifTrue:[materialHilite enable: ogl.].		(2*segments)+1 to: (3*segments)+1 do:[ :ih |			norm1 x: (ringSin at: (iv+1)) * (ringSin at: ih)				 y: (ringSin at: (iv+1)) * (ringCos at: ih)				 z: (ringCos at: (iv+1)).			ogl glNormal3fv: norm1.			vert1 _ norm1 * radius.			vert1 x: vert1 x - dx.			vert1 y: vert1 y-  dy.			ogl glVertex3fv: vert1.			norm2 x: (ringSin at: iv) * (ringSin at: ih)				 y: (ringSin at: iv) * (ringCos at: ih)				 z: (ringCos at: iv).			ogl glNormal3fv: norm2.			vert2 _ norm2 * radius.			vert2 x: vert2 x - dx.			vert2 y: vert2 y - dy.			ogl glVertex3fv: vert2.			].		hilite = 24 ifTrue:[material enable: ogl.].		hilite = 13 ifTrue:[materialHilite enable: ogl.].		ogl glNormal3fv: norm1.		vert1 y:0.		ogl glVertex3fv: vert1.		ogl glNormal3fv: norm2.		vert2 y: 0.		ogl glVertex3fv: vert2.		hilite = 13 ifTrue:[material enable: ogl.]." ---- top left ----- "		hilite = 21 ifTrue:[materialHilite enable: ogl.].		(3*segments)+1 to: (4*segments)+1 do:[ :ih |			norm1 x: (ringSin at: (iv+1)) * (ringSin at: ih)				 y: (ringSin at: (iv+1)) * (ringCos at: ih)				 z: (ringCos at: (iv+1)).			ogl glNormal3fv: norm1.			vert1 _ norm1 * radius.			vert1 x: vert1 x - dx.			vert1 y: vert1 y+  dy.			ogl glVertex3fv: vert1.			norm2 x: (ringSin at: iv) * (ringSin at: ih)				 y: (ringSin at: iv) * (ringCos at: ih)				 z: (ringCos at: iv).			ogl glNormal3fv: norm2.			vert2 _ norm2 * radius.			vert2 x: vert2 x - dx.			vert2 y: vert2 y + dy.			ogl glVertex3fv: vert2.			].		hilite = 21 ifTrue:[material enable: ogl.].		hilite = 11 ifTrue:[materialHilite enable: ogl.].		ogl glNormal3fv: norm1.		vert1 x:0.		ogl glVertex3fv: vert1.		ogl glNormal3fv: norm2.		vert2 x: 0.		ogl glVertex3fv: vert2.		hilite = 11 ifTrue:[material enable: ogl.].		hilite = 22 ifTrue:[materialHilite enable: ogl.].		ogl glNormal3fv: vn1.		ogl glVertex3fv: vs1.		ogl glNormal3fv: vn2.		ogl glVertex3fv: vs2.				ogl glEnd.].					doInside ifTrue:[		material enable: ogl.		self renderInside: ogl x: dx y: dy.].	! !!TWindowFrameMorph methodsFor: 'accessing' stamp: 'ar 9/6/2002 22:44'!alphaSlider	^alphaSlider! !!TWindowFrameMorph methodsFor: 'accessing' stamp: 'ar 9/6/2002 21:30'!closeButton	^closeButton! !!TWindowFrameMorph methodsFor: 'accessing' stamp: 'ar 9/6/2002 21:30'!collapseButton	^collapseButton! !!TWindowFrameMorph methodsFor: 'accessing' stamp: 'ar 10/26/2002 19:52'!doItButton	^doItButton! !!TWindowFrameMorph methodsFor: 'accessing' stamp: 'ar 9/6/2002 21:30'!expandButton	^expandButton! !!TWindowFrameMorph methodsFor: 'accessing' stamp: 'ar 9/6/2002 22:03'!label	^label contents! !!TWindowFrameMorph methodsFor: 'accessing' stamp: 'ar 9/6/2002 22:03'!label: aString	label contents: aString! !!TWindowFrameMorph methodsFor: 'accessing' stamp: 'ar 10/26/2002 19:31'!labelColor	^label labelColor! !!TWindowFrameMorph methodsFor: 'accessing' stamp: 'ar 10/26/2002 19:31'!labelColor: aColor	label labelColor: aColor! !!TWindowFrameMorph methodsFor: 'accessing' stamp: 'ar 9/6/2002 21:21'!window: aTWindow	alphaSlider target: aTWindow.	alphaSlider value: aTWindow alpha.! !!TWindowFrameMorph methodsFor: 'accessing' stamp: 'ar 10/26/2002 19:50'!windowColor: windowColor	| buttonColor |	self fillStyle: (GradientFillStyle colors: {windowColor. Color white mixed: 0.65 with: windowColor}).	self fillStyle origin: 0@0; direction: 0@24.	buttonColor := (windowColor mixed: 0.3 with: Color white).	closeButton color: buttonColor.	collapseButton color: buttonColor.	expandButton color: buttonColor.	doItButton ifNotNil:[doItButton color: buttonColor].! !!TWindowFrameMorph methodsFor: 'initialize' stamp: 'ar 9/6/2002 21:22'!buildAlphaSlider	| slider |	slider := SimpleSliderMorph new.	slider extent: 100@10.	slider target: self.	slider actionSelector: #alpha:.	^slider! !!TWindowFrameMorph methodsFor: 'initialize' stamp: 'ar 9/6/2002 21:51'!buildCloseButton	^self buildWindowButton: CloseButtonForm! !!TWindowFrameMorph methodsFor: 'initialize' stamp: 'ar 10/26/2002 19:50'!buildDoItButton	| button doIt |	button := (BorderedMorph new)		extent: 16@16;		cornerStyle: #rounded;		color: Color gray;		borderStyle: (BorderStyle raised width: 2);		yourself.	button on: #mouseDown send: #mouseDown:from: to: self.	button on: #mouseUp send: #mouseUp:from: to: self.	doIt := StringMorph contents: '!!'.	doIt emphasis: 1.	button addMorphCentered: doIt.	doItButton := button.	^doItButton! !!TWindowFrameMorph methodsFor: 'initialize' stamp: 'ar 9/6/2002 21:51'!buildExpandButton	^self buildWindowButton: ExpandButtonForm! !!TWindowFrameMorph methodsFor: 'initialize' stamp: 'ar 9/6/2002 21:50'!buildWindowButton	^self buildWindowButton: nil! !!TWindowFrameMorph methodsFor: 'initialize' stamp: 'ar 9/6/2002 21:55'!buildWindowButton: graphic	| button icon |	button := (BorderedMorph new)		extent: 16@16;		cornerStyle: #rounded;		color: Color gray;		borderStyle: (BorderStyle raised width: 2);		yourself.	button on: #mouseDown send: #mouseDown:from: to: self.	button on: #mouseUp send: #mouseUp:from: to: self.	graphic ifNil:[^button].	icon := SketchMorph withForm: graphic.	button addMorphCentered: icon.	^button! !!TWindowFrameMorph methodsFor: 'initialize' stamp: 'ar 9/6/2002 21:22'!buildWindowLabel	^(StringMorph contents: 'Tea Window') color: Color white; emphasis: 1! !!TWindowFrameMorph methodsFor: 'initialize' stamp: 'ar 10/25/2002 21:00'!collapse	alphaSlider visible: false.! !!TWindowFrameMorph methodsFor: 'initialize' stamp: 'ar 10/25/2002 21:00'!expand	alphaSlider visible: true.! !!TWindowFrameMorph methodsFor: 'initialize' stamp: 'ar 10/26/2002 19:42'!initialize	| spacer |	super initialize.	self layoutPolicy: TableLayout new.	self listDirection: #leftToRight.	self cellPositioning: #leftCenter.	self hResizing: #spaceFill; vResizing: #shrinkWrap.	self layoutInset: 4@4; cellInset: 4@0.	self addMorphBack: (closeButton := self buildCloseButton).	label := self buildWindowLabel.	spacer := (Morph new) color: Color transparent; hResizing: #spaceFill; vResizing: #spaceFill.	spacer clipSubmorphs: true.	spacer addMorphBack: label.	self addMorphBack: spacer.	self addMorphBack: (alphaSlider := self buildAlphaSlider).	self addMorphBack: (collapseButton := self buildWindowButton).	self addMorphBack: (expandButton := self buildExpandButton).! !!TWindowFrameMorph methodsFor: 'initialize' stamp: 'ar 10/26/2002 19:43'!makeLabelButton	| newLabel |	newLabel := TButtonMorph new.	newLabel fillStyle direction: newLabel fillStyle direction * 2.	"newLabel cornerStyle: #rounded."	newLabel label: self label.	newLabel labelColor: self labelColor.	newLabel fullBounds.	newLabel position: label position.	newLabel highlightWidth: 2.	label owner replaceSubmorph: label by: newLabel.	label delete.	label := newLabel.	^label! !!TWindowFrameMorph methodsFor: 'events' stamp: 'ar 9/6/2002 21:55'!mouseDown: evt from: aButton	aButton borderColor: #inset.! !!TWindowFrameMorph methodsFor: 'events' stamp: 'ar 9/6/2002 22:43'!mouseUp: evt from: aButton	aButton borderColor: #raised.	(aButton containsPoint: evt position) ifTrue:[aButton signal: #fire].! !!TWindowFrameMorph class methodsFor: 'instance creation' stamp: 'ar 9/6/2002 21:53'!initialize	"TWindowFrameMorph initialize"	| proto |	proto := (ScriptingSystem formAtKey: 'expandBox').	proto ifNotNil:[		ExpandButtonForm := proto rotateBy: #left centerAt: 0@0.	].	proto := ScriptingSystem formAtKey:'Halo-Dismiss'.	proto ifNotNil:[		CloseButtonForm := Form extent: proto extent depth: 8.		(BitBlt toForm: CloseButtonForm) sourceForm: proto; combinationRule: 3; copyBits.	].! !!TWirePortal methodsFor: 'as yet unclassified' stamp: 'das 8/12/2004 11:36'!render: ogl depth: depth	| saveForceWire rval |	saveForceWire _ ogl forceWire.	ogl forceWire: ogl forceWire not.	rval _ super render: ogl depth: depth.	ogl forceWire: saveForceWire.	^ rval.! !!TWorldCanvas methodsFor: 'initialization' stamp: 'ar 10/1/2004 07:50'!finish	self finish: { form boundingBox }.! !!TWorldCanvas methodsFor: 'initialization' stamp: 'ar 10/1/2004 07:50'!finish: allDamage	allDamage do:[:r|		monitor sendDamage: r.	].! !!TWorldCanvas methodsFor: 'initialization' stamp: 'ar 10/1/2004 07:51'!on: aTMorphMonitor	monitor _ aTMorphMonitor.	self setForm: monitor canvasForm.! !!TWorldCanvas class methodsFor: 'as yet unclassified' stamp: 'ar 10/1/2004 07:49'!on: aForm	^ self new on: aForm! !!TXLightPipe methodsFor: 'as yet unclassified' stamp: 'DPR 6/1/2004 03:36'!changedButtonNumber: evt	evt redButtonChanged ifTrue: [^1].	evt yellowButtonChanged ifTrue: [^2].	evt blueButtonChanged ifTrue: [^3].	"should never get here!!"	^1.! !!TXLightPipe methodsFor: 'as yet unclassified' stamp: 'DPR 5/23/2004 11:37'!close	lightPipe close.	lightPipe _ nil.! !!TXLightPipe methodsFor: 'as yet unclassified' stamp: 'DPR 6/22/2004 15:02'!ctrlKeyCode	| shiftKey |	shiftKey := lightPipe keyCodeAndColumn: 16rFFE3.  "control key"	^shiftKey first.! !!TXLightPipe methodsFor: 'as yet unclassified' stamp: 'DPR 6/2/2004 11:05'!handleEvent: someEvent	"here is where we map events into the XWindow"	| position type |	type := someEvent type.	type = #mouseDown ifTrue: [ 		xtest fakeButtonEventButton: (self changedButtonNumber: someEvent) isPress: true delay: 0.		].	type = #mouseUp ifTrue: [		xtest fakeButtonEventButton: (self changedButtonNumber: someEvent) isPress: false delay: 0.		].	type = #mouseMove ifTrue: [		position := someEvent position.		xtest fakeMotionEventScreen: 0 x: position x y: position y delay: 0.		].	type = #keyDown ifTrue: [		"self sendKey: someEvent isPress: true."		].	type = #keystroke ifTrue: [		"for some reason the keyDown events are not coming through		 so perhaps we should simulate them?"		self sendKey: someEvent isPress: true.		self sendKey: someEvent isPress: false.		].	type = #keyUp ifTrue: [		self sendKey: someEvent isPress: false.		].		! !!TXLightPipe methodsFor: 'as yet unclassified' stamp: 'DPR 8/10/2004 18:59'!monitorXDisplay: aDisplay window: window eventsTo: aTXWindow	"creates an object to monitor an X display window"	| display |	display _ X11Display XOpenDisplay: aDisplay.	(display getHandle asInteger ~= 0 and: [		((lightPipe _ XLightPipe new) openDisplay: display window: window) and: [			(xtest _ XTest new) openDisplay: display]])		ifTrue: [			changesTo := aTXWindow.			changesTo future: 0.0 perform: #XMonitor: withArguments: { self }.			self pollWindowChanges.		]		ifFalse: [			aTXWindow future: 0.0 perform: #XopenFailed withArguments: #().		].! !!TXLightPipe methodsFor: 'as yet unclassified' stamp: 'ar 10/4/2004 13:22'!pollWindowChanges	lightPipe ifNil: [^self].	self future: 50.0 perform: #pollWindowChanges.	lightPipe damagedAreasDo: [ :form :rect |		changesTo future: 0.0 perform: #updateArea:with: withArguments: { rect . form }.		].! !!TXLightPipe methodsFor: 'as yet unclassified' stamp: 'DPR 6/22/2004 15:10'!sendKey: someEvent isPress: aBool	| keycodeAndColumn keyCode col needShift kv needCtrl |	kv := someEvent keyValue.	keycodeAndColumn := lightPipe keyCodeAndColumn: kv.	keycodeAndColumn ifNil: [^self].	needCtrl := lightPipe needsCtrlShift: kv.	keyCode := keycodeAndColumn first.	keyCode ifNil: [^nil].	col := keycodeAndColumn second.	"here we need to simulate the modifier keys etc. if it's a keypress"	"for now just handle shift key"	needShift := (col bitAnd: 1) ~= 0.	aBool ifTrue: [		needShift ifTrue: [ xtest fakeKeyEventKeycode:  self shiftKeyCode isPress: aBool delay: 0.].		needCtrl ifTrue: [ xtest fakeKeyEventKeycode: self ctrlKeyCode isPress: aBool delay: 0.]].	xtest fakeKeyEventKeycode:  keyCode isPress: aBool delay: 0.	aBool ifFalse: [		needShift ifTrue: [ xtest fakeKeyEventKeycode:  self shiftKeyCode isPress: aBool delay: 0.].		needCtrl ifTrue: [ xtest fakeKeyEventKeycode: self ctrlKeyCode isPress: aBool delay: 0.]].! !!TXLightPipe methodsFor: 'as yet unclassified' stamp: 'DPR 6/2/2004 11:45'!shiftKeyCode	| shiftKey |	shiftKey := lightPipe keyCodeAndColumn: 16rFFE1.  "shift key"	^shiftKey first.! !!TXMLExporter methodsFor: 'exporting' stamp: 'ar 6/2/2002 14:41'!export: anObject	super export: anObject.	self saveOnFile.! !!TXWindow methodsFor: 'as yet unclassified' stamp: 'DPR 5/23/2004 11:20'!XMonitor: aTXWindow	"this tells us the object that is monitoring the window on its home machine"	theTXWindow := aTXWindow.	! !!TXWindow methodsFor: 'as yet unclassified' stamp: 'DPR 5/23/2004 11:18'!XopenFailed	"response when we couldn't open the Xwindow"! !!TXWindow methodsFor: 'as yet unclassified' stamp: 'DPR 5/29/2004 11:40'!handTrackingPointer: pointer	| |	^hands at: pointer ifAbsentPut: [ self makeHand: pointer tool color ].! !!TXWindow methodsFor: 'as yet unclassified' stamp: 'DPR 5/29/2004 10:37'!handTrackingPointer: pointer position: position	| hand transform |	hand _ self handTrackingPointer: pointer.	activeHand ifNil: [ activeHand := hand. ].	transform := B3DMatrix4x4 identity.	transform rotationAroundX: 90.	transform translation: pointer selectedPoint + (0@0@0.01).		hand localTransform: transform.	hand visible: true.			! !!TXWindow methodsFor: 'as yet unclassified' stamp: 'DPR 6/2/2004 09:32'!handleEvent2D: someEvent pointer: pointer	| hand type |	hand _ self handTrackingPointer: pointer position: someEvent position.	activeHand ifNil: [ activeHand := hand ].	type _ someEvent type.	hand == activeHand ifFalse: [ "when not active hand, suppress mouse events"		(type == #mouseMove or: [type == #mouseUp]) ifTrue: [^self].		(type == #mouseDown) ifTrue: [			mouseDown ifTrue: [^self].			activeHand _ hand.			].					].	type == #mouseUp ifTrue: [ mouseDown _ false. ].	type == #mouseDown ifTrue: [ mouseDown _ true ].	type == #mouseMove ifTrue: [		someEvent position = lastActivePosition ifTrue: [^self].  "skip event if hand doesn't move"		lastActivePosition _ someEvent position.			].	theTXWindow ifNotNil: [		theTXWindow future: 50.0 deferRelative: 0.0 perform: #handleEvent: withArguments: { someEvent }.		].	! !!TXWindow methodsFor: 'as yet unclassified' stamp: 'DPR 6/2/2004 09:27'!initializeOpaque: aBool extent: myExtent	super initializeOpaque: aBool extent: myExtent.	hands _ WeakKeyDictionary new.	activeHand _ nil.	lastActivePosition _ nil.	mouseDown _ false.	^self.	! !!TXWindow methodsFor: 'as yet unclassified' stamp: 'DPR 5/29/2004 11:42'!makeHand: col	| hand handMaterial color |	color _ col copy.	color at: 4 put: 0.35.	handMaterial _ TMaterial new.	handMaterial ambientColor: color asFloatArray.	handMaterial diffuseColor: color asFloatArray.	handMaterial texture:( TTexture				new initializeWithFileName: 'neonGlow.png'				mipmap: true				shrinkFit: false).	handMaterial textureMode: GLModulate.	handMaterial cullFace: false.	hand _ TLinedCylinder new.	hand topRadius: 0.1.	hand baseRadius: 0.02.	hand height: 0.08.	hand material: handMaterial.	hand visible: false.	hand solidTree: false.	self addChild:hand.	^hand! !!TXWindow methodsFor: 'as yet unclassified' stamp: 'DPR 5/28/2004 16:21'!pointerEnter: pointer	| hand |	super pointerEnter: pointer.	hand _ self handTrackingPointer: pointer.	hand visible: true. "when it is positioned, then make it visible"! !!TXWindow methodsFor: 'as yet unclassified' stamp: 'DPR 5/28/2004 16:20'!pointerLeave: pointer	| hand |	super pointerLeave: pointer.	hand _ hands at: pointer ifAbsent: [^nil].	activeHand == hand ifTrue: [ activeHand _ nil].	hand visible: false.! !!TeaBackingMorph methodsFor: 'rendering' stamp: 'ar 10/1/2004 13:38'!glRenderOn: ogl	"Update what's dirty and blast out the texture"	| tw th box mat |	texture ifNil:[		"probably shouldn't be using TTextures here, this is a ogl level thing"		texture := TTexture 			new initializeWithForm: (Form extent: self extent x asLargerPowerOfTwo @ self extent y asLargerPowerOfTwo depth: 32)			mipmap: false 			shrinkFit: true.		mat _ TMaterial new.		mat ambientColor: #(1.0 1.0 1.0 0.9) asFloatArray.		mat diffuseColor: #(1.0 1.0 1.0 0.9) asFloatArray.		mat emissiveColor: #(1.0 1.0 1.0 1.0) asFloatArray.		texture material: mat.	].	damageRecorder updateIsNeeded ifTrue:[self repairDamage].	texture enable: ogl.	tw := bounds width asFloat / texture targetForm width asFloat.	th := bounds height asFloat / texture targetForm height asFloat.	box := bounds translateBy: owner bounds origin negated.	ogl glDisable: GLLighting.	ogl glColor4f: 1.0 with: 1.0 with: 1.0 with: 1.0.	ogl glBegin: GLQuads;		glTexCoord2f: 0.0 with: 0.0;		glVertex2f: box left with: box top;		glTexCoord2f: tw with: 0.0;		glVertex2f: box right with: box top;		glTexCoord2f: tw with: th;		glVertex2f: box right with: box bottom;		glTexCoord2f: 0.0 with: th;		glVertex2f: box left with: box bottom;		glEnd.	texture disable: ogl.! !!TeaBackingMorph methodsFor: 'rendering' stamp: 'ar 9/8/2002 03:26'!invalidRect: aRectangle from: aMorph	| damageRect |	texture ifNil:[^super invalidRect: aRectangle from: aMorph].	damageRect _ aRectangle.	aMorph == self ifFalse:[		"Clip to receiver's clipping bounds if the damage came from a child"		self clipSubmorphs 			ifTrue:[damageRect _ aRectangle intersect: self clippingBounds]].	damageRecorder recordInvalidRect: (damageRect translateBy: bounds origin negated).! !!TeaBackingMorph methodsFor: 'rendering' stamp: 'ar 10/1/2004 15:04'!repairDamage	| rectList fc bb |	rectList _ damageRecorder invalidRectsFullBounds: (0@0 extent: self extent).	damageRecorder reset.	bb := BitBlt toForm: texture targetForm.	bb combinationRule: 40 "fixAlpha:with:".	bb halftoneForm: (Bitmap with: 16rFF000000).	fc := (FormCanvas on: texture targetForm).	rectList do:[:r|		fc clipBy: r during:[:cc| 			cc fillColor: Color transparent.			cc translateBy: bounds origin negated during:[:cc2 | self fullDrawOn: cc2]].		bb destRect: (r).		bb copyBits.		texture invalidate: (r).	].! !!TeaBackingMorph methodsFor: 'initialize' stamp: 'ar 8/19/2002 19:51'!initialize	super initialize.	damageRecorder := DamageRecorder new.	damageRecorder doFullRepaint.! !!TeaBackingMorph methodsFor: 'geometry' stamp: 'ar 9/6/2002 22:53'!position: aPoint	| delta |	texture ifNil:[^super position: aPoint].	delta _ aPoint - bounds topLeft.	(delta x = 0 and: [delta y = 0]) ifTrue: [^ self].  "Null change"	self privateFullMoveBy: delta.	owner ifNotNil:[owner layoutChanged].! !!TWindowMorph methodsFor: 'geometry' stamp: 'ar 9/6/2002 22:29'!activate	frame labelColor: Color white.	content unlock.! !!TWindowMorph methodsFor: 'geometry' stamp: 'ar 9/8/2002 13:45'!activateEvent: evt	owner addMorphFront: self.! !!TWindowMorph methodsFor: 'geometry' stamp: 'ar 9/6/2002 23:58'!extent: aPoint	| textureExtent |	super extent: aPoint.	texture ifNil:[^self].	textureExtent := self extent asLargerPowerOfTwo.	textureExtent = texture textureForm extent ifFalse:[texture := nil].! !!TWindowMorph methodsFor: 'geometry' stamp: 'ar 9/6/2002 22:40'!ownerChanged	"back stop so we can adjust activity state"	owner ifNotNil:[		owner firstSubmorph == self 			ifTrue:[self activate]			ifFalse:[self passivate].	].	^super ownerChanged! !!TWindowMorph methodsFor: 'geometry' stamp: 'ar 9/6/2002 22:29'!passivate	frame labelColor: Color black.	content lock.! !!TWindowMorph methodsFor: 'initialize' stamp: 'ar 10/25/2002 23:22'!closeRequest	model ifNil:[^self delete].	model closeRequest.! !!TWindowMorph methodsFor: 'initialize' stamp: 'ar 9/8/2002 03:16'!collapseRequest	self isCollapsed ifTrue:[self expand] ifFalse:[self collapse].! !!TWindowMorph methodsFor: 'initialize' stamp: 'ar 9/8/2002 04:06'!expandRequest	self isCollapsed ifTrue:[^self expand].	(self hasProperty: #priorBounds) ifTrue:[		self bounds: (self valueOfProperty: #priorBounds ifAbsent:[^self]).		self removeProperty: #priorBounds.	] ifFalse:[		self setProperty: #priorBounds toValue: self bounds.		self bounds: owner bounds.		owner addMorphFront: self.	].! !!TWindowMorph methodsFor: 'initialize' stamp: 'ar 9/8/2002 03:20'!initialize	super initialize.	self color: (Color white alpha: 0.9).	self cornerStyle: #rounded.	self borderStyle: (BorderStyle raised width: 2).	self layoutPolicy: TableLayout new.	self hResizing: #shrinkWrap; vResizing: #shrinkWrap.	frame := TWindowFrameMorph new.	self on: #mouseDown send: #activateEvent: to: self.	frame on: #mouseDown send: #startDrag:frame: to: self.	frame on: #mouseUp send: #stopDrag:frame: to: self.	frame alphaSlider target: self.	frame alphaSlider value: self alpha.	self runScript: #collapseRequest when:{frame collapseButton. #fire}.	self runScript: #closeRequest when:{frame closeButton. #fire}.	self runScript: #expandRequest when:{frame expandButton. #fire}.	self addMorphBack: frame.	content := (Morph new)		color: Color transparent;		layoutPolicy: ProportionalLayout new;		hResizing: #spaceFill; vResizing: #spaceFill;		yourself.	self addMorphBack: content.	self extent: 400@170.	self windowColor: Color red.! !!TWindowMorph methodsFor: 'collapse-expand' stamp: 'ar 9/8/2002 03:46'!collapse	self isCollapsed ifTrue:[^self].	self setProperty: #priorBounds toValue: self bounds.	content visible: false; delete.	frame collapse.	self bounds: (self valueOfProperty: #collapseBounds ifAbsent:[^self]).! !!TWindowMorph methodsFor: 'collapse-expand' stamp: 'ar 9/8/2002 04:06'!expand	self isCollapsed ifFalse:[^self].	self setProperty: #collapseBounds toValue: self bounds.	content visible: true.	self addMorphBack: content.	frame expand.	owner addMorphFront: self.	self bounds: (self valueOfProperty: #priorBounds ifAbsent:[^self]).	self removeProperty: #priorBounds.! !!TWindowMorph methodsFor: 'accessing' stamp: 'ar 9/6/2002 21:32'!content	^content! !!TWindowMorph methodsFor: 'accessing' stamp: 'ar 9/6/2002 21:32'!frame	^frame! !!TWindowMorph methodsFor: 'accessing' stamp: 'ar 9/6/2002 22:03'!label	^frame label! !!TWindowMorph methodsFor: 'accessing' stamp: 'ar 9/6/2002 22:03'!label: aString	frame label: aString.! !!TWindowMorph methodsFor: 'accessing' stamp: 'ar 10/25/2002 23:25'!model	^model! !!TWindowMorph methodsFor: 'accessing' stamp: 'ar 10/25/2002 23:25'!model: anObject	model := anObject! !!TWindowMorph methodsFor: 'accessing' stamp: 'ar 9/6/2002 22:38'!windowColor: aColor	| frameColor |	windowColor := aColor.	frame windowColor: windowColor.	frameColor := (Color white mixed: 0.4 with: windowColor).	self adoptPaneColor: (Color white mixed: 0.7 with: windowColor).	self borderStyle baseColor: frameColor.	content submorphsDo:[:m|		m borderWidth > 0 ifTrue:[m borderStyle baseColor: frameColor].	].! !!TWindowMorph methodsFor: 'events' stamp: 'ar 9/6/2002 22:49'!followHand: evt frame: aFrame	| origin |	evt hand showTemporaryCursor: Cursor normal.	origin := aFrame valueOfProperty: #dragOrigin ifAbsent:[^self].	self position: self position + (evt position - origin).	aFrame setProperty: #dragOrigin toValue: evt position.	"self addDropShadow.	self shadowColor: (Color black alpha: 0.3)."! !!TWindowMorph methodsFor: 'events' stamp: 'ar 9/6/2002 22:27'!startDrag: evt frame: aFrame	"Mouse down in window frame"	owner ifNil:[^self].	owner firstSubmorph == self ifFalse:[owner addMorphFront: self].	aFrame setProperty: #dragOrigin toValue: evt position.	aFrame on: #mouseMove send: #followHand:frame: to: self.! !!TWindowMorph methodsFor: 'events' stamp: 'ar 9/6/2002 22:24'!stopDrag: evt frame: aFrame	"Mouse down in window frame"	aFrame on: #mouseMove send: nil to: nil.	aFrame removeProperty: #dragOrigin.	evt hand showTemporaryCursor: nil.	self removeDropShadow.! !!TWindowMorph methodsFor: 'testing' stamp: 'ar 9/8/2002 03:16'!isCollapsed	^content visible not! !!TWindowMorph methodsFor: 'stepping' stamp: 'ar 9/6/2002 23:39'!step	super step.	self model ifNotNilDo:[:m| m step].! !!TWindowMorph methodsFor: 'stepping' stamp: 'ar 9/6/2002 23:29'!stepTime	^500! !!TWindowMorph methodsFor: 'stepping' stamp: 'ar 9/6/2002 23:38'!wantsSteps	^true! !!TZoomNavigatorMorph methodsFor: 'alice items' stamp: 'ar 10/12/2002 01:46'!addAliceFile: path image: aForm	| image |	image := aForm ifNil:[Form extent: 128@96 depth: 8].	self drawName: path last on: image.	self addItem: (TSketchButtonMorph withForm: image)		dragAction: nil		clickAction: (MessageSend receiver: self selector: #clickOpenAliceFile: argument: path).! !!TZoomNavigatorMorph methodsFor: 'alice items' stamp: 'ar 10/12/2002 01:56'!addAliceLibrary: path	| fd fileNames mdlFiles thumbs paths file thumb |	self addBackButton: #aliceModels.	fd := FileDirectory on: (FileDirectory pathFrom: {FileDirectory default pathName}, path).	fileNames := fd fileNames.	mdlFiles := fileNames select:[:any| any endsWith: '.mdl'].	thumbs := fileNames select:[:any| any endsWith: '.gif'].	mdlFiles := mdlFiles asSet.	thumbs := thumbs asSet.	paths := fd directoryNames.	"add paths"	paths do:[:dir|		(thumbs includes: dir,'.gif') ifTrue:[			file := fd readOnlyFileNamed: dir,'.gif'.			thumb := Form fromBinaryStream: file.			thumb := thumb asFormOfDepth: 32.			file close.		] ifFalse:[thumb := nil].		self addAlicePath: (path copyWith: dir) image: thumb.	].	"Now add tea files"	mdlFiles := mdlFiles asArray sort:[:s1 :s2| (s1 compare: s2) <= 2].	mdlFiles do:[:fname|		(thumbs includes: (fname allButLast: 4),'.gif') ifTrue:[			file := fd readOnlyFileNamed: (fname allButLast: 4),'.gif'.			thumb := Form fromBinaryStream: file.			thumb := thumb asFormOfDepth: 32.			file close.		] ifFalse:[thumb := nil].		self addAliceFile: (path copyWith: fname) image: thumb.	].! !!TZoomNavigatorMorph methodsFor: 'alice items' stamp: 'ar 10/12/2002 01:44'!addAlicePath: path image: aForm	| image |	aForm ifNil:[image := Form extent: 128@128 depth: 32].	aForm ifNotNil:[		image := Form extent: aForm extent depth: 32.		aForm displayOn: image.	].	self drawName: path last on: image.	self addItem: (TSketchButtonMorph withForm: image)		dragAction: nil		clickAction: (MessageSend receiver: self selector: #clickOpenAlicePath: argument: path).! !!TZoomNavigatorMorph methodsFor: 'alice items' stamp: 'ar 10/12/2002 01:43'!addAliceRoot	self addAlicePath: {'Content'. 'Alice'} image: AliceForm.! !!TZoomNavigatorMorph methodsFor: 'alice items' stamp: 'ar 10/12/2002 01:45'!clickOpenAliceFile: aPath	owner clickOpenAliceFile: aPath! !!TZoomNavigatorMorph methodsFor: 'alice items' stamp: 'ar 10/12/2002 01:45'!clickOpenAlicePath: aPath	targetHeight := nil.	self addAliceLibrary: aPath.	self mouseMove: ActiveHand lastEvent.! !!TZoomNavigatorMorph methodsFor: 'back button' stamp: 'ar 10/11/2002 23:05'!addBackButton	^self addBackButton: nil.! !!TZoomNavigatorMorph methodsFor: 'back button' stamp: 'ar 10/11/2002 23:07'!addBackButton: contentType	| prior button |	button := TSketchButtonMorph withForm: BackButtonForm.	button setProperty: #contentType toValue: contentType.	prior := scroller submorphs.	scroller removeAllMorphs.	self addItem: button		dragAction: nil		clickAction: (MessageSend receiver: self selector: #clickBackTo: argument: prior).! !!TZoomNavigatorMorph methodsFor: 'back button' stamp: 'ar 10/11/2002 19:01'!clickBackTo: morphs	scroller removeAllMorphs.	morphs do:[:each| self addItem: each].	targetHeight := nil.	self mouseMove: ActiveHand lastEvent.! !!TZoomNavigatorMorph methodsFor: 'initialize' stamp: 'ar 10/11/2002 18:04'!addItem: sketch	sketch extent: self smallExtent.	sketch on: #mouseDown send: #mouseDown:from: to: self.	sketch on: #mouseUp send: #mouseUp:from: to: self.	sketch on: #mouseEnter send: #mouseEnter:from: to: self.	sketch on: #mouseLeave send: #mouseLeave:from: to: self.	sketch on: #startDrag send: #startDrag:from: to: self.	scroller addMorphBack: sketch.	scroller left: self left.! !!TZoomNavigatorMorph methodsFor: 'initialize' stamp: 'ar 10/8/2002 21:40'!addItem: sketch dragAction: dragAction clickAction: clickAction	sketch setProperty: #dragAction toValue: dragAction.	sketch setProperty: #clickAction toValue: clickAction.	self addItem: sketch.! !!TZoomNavigatorMorph methodsFor: 'initialize' stamp: 'das 9/27/2002 01:51'!drawName: projectName on: aForm	| font nameForm box rectForName aCanvas |	font _ TextStyle defaultFont emphasized: 1.	nameForm _ (StringMorph contents: projectName font: font) imageForm.	nameForm _ nameForm scaledToSize: (aForm extent - (4@2) min: nameForm extent).	box _ aForm boundingBox.	rectForName _ box bottomLeft + 			(box width - nameForm width // 2 @ (nameForm height + 2) negated)				extent: nameForm extent.	aCanvas _ aForm getCanvas.	rectForName topLeft eightNeighbors do: [ :pt |		aCanvas			stencil: nameForm 			at: pt			color: Color white.	].	aCanvas		stencil: nameForm 		at: rectForName topLeft 		color: Color black.! !!TZoomNavigatorMorph methodsFor: 'initialize' stamp: 'ar 10/11/2002 19:00'!initialize	super initialize.	self clipSubmorphs: true.	self color: Color transparent.	scroller _ Morph new.	scroller color: Color transparent.	scroller layoutPolicy: TableLayout new.	scroller listDirection: #leftToRight.	scroller hResizing: #shrinkWrap.	scroller cellPositioning: #bottomCenter.	scroller wrapCentering: #bottomRight.	scroller layoutInset: 4@4.	scroller cellInset: 4@0.	scroller height: self largeExtent y + 8. "2 x inset"	self extent: self smallExtent x * 8 + 8 @ scroller height + 16.	self addMorph: scroller.! !!TZoomNavigatorMorph methodsFor: 'initialize' stamp: 'ar 10/11/2002 16:48'!removeAll	scroller removeAllMorphs! !!TZoomNavigatorMorph methodsFor: 'project items' stamp: 'ar 10/8/2002 23:15'!addProject: project	^self addProject: project 		clickAction: (MessageSend receiver: self selector: #clickProjectView: argument: project)		dragAction: (MessageSend receiver: self selector: #dragProjectView: argument: project)! !!TZoomNavigatorMorph methodsFor: 'project items' stamp: 'ar 10/8/2002 23:13'!addProject: project clickAction: clickAction dragAction: dragAction	| size thumb max scale width height form sketchForm sketch |	size _ self largeExtent.	thumb _ project thumbnail.	thumb ifNil:[thumb _ (Form extent: 128@96 depth: 16) fillWhite].	max _ thumb width max: thumb height.	scale _ size x / max.	width _ (thumb width * scale) truncated.	height _ (thumb height * scale) truncated.	form _ Form extent: width@height depth: 16.	thumb displayScaledOn: form.	sketchForm _ Form extent: size depth: form depth.	form displayOn: sketchForm at: sketchForm extent - form extent // (2@1) rule: Form paint.	self drawName: project name on: sketchForm.	sketch _ SketchMorph withForm: sketchForm.	self addItem: sketch dragAction: dragAction clickAction: clickAction.! !!TZoomNavigatorMorph methodsFor: 'project items' stamp: 'ar 3/9/2004 19:30'!addProjectRoot	ProjectsForm ifNil:[ProjectsForm := Form extent: 32@32 depth: 32].	self addProjectRoot: ProjectsForm! !!TZoomNavigatorMorph methodsFor: 'project items' stamp: 'ar 10/11/2002 21:46'!addProjectRoot: thumb	| image |	image := Form extent: thumb extent depth: 32.	thumb displayOn: image.	self drawName: 'Projects' on: image.	self addItem: (TSketchButtonMorph withForm: image)		dragAction: nil		clickAction: (MessageSend receiver: self selector: #addProjects).! !!TZoomNavigatorMorph methodsFor: 'project items' stamp: 'ar 10/11/2002 23:07'!addProjects	self addBackButton: #projects.	(Project allInstances sort:[:p1 :p2| p1 name <= p2 name]) do:[:prj| self addProject: prj. ].	targetHeight := nil.! !!TZoomNavigatorMorph methodsFor: 'project items' stamp: 'ar 10/8/2002 23:16'!clickProjectView: aProject	aProject enter: false.! !!TZoomNavigatorMorph methodsFor: 'project items' stamp: 'ar 10/8/2002 23:17'!dragProjectView: aProject	| project projView |	project _ aProject.	projView _ ProjectViewMorph on: project.	projView setProperty: #teaDropAction toValue: (MessageSend receiver: nil selector: #makeProjectLink: argument: project).	ActiveHand attachMorph: projView.! !!TZoomNavigatorMorph methodsFor: 'snapshot items' stamp: 'ar 10/11/2002 23:10'!addSnapshotItem: aSketch	snapshots add: aSketch.	(scroller submorphs first valueOfProperty: #contentType) == #snapshots ifFalse:[^self].	self addItem: aSketch		dragAction: nil		clickAction: (MessageSend receiver: self selector: #clickSnapshot: argument: aSketch).! !!TZoomNavigatorMorph methodsFor: 'snapshot items' stamp: 'ar 3/9/2004 19:30'!addSnapshotRoot	snapshots ifNil:[snapshots := OrderedCollection new].	SnapshotForm ifNil:[SnapshotForm := Form extent: 32@32 depth: 32].	self addSnapshotRoot: SnapshotForm.! !!TZoomNavigatorMorph methodsFor: 'snapshot items' stamp: 'ar 10/11/2002 22:05'!addSnapshotRoot: thumb	| image |	image := Form extent: thumb extent depth: 32.	thumb displayOn: image.	self drawName: 'Snapshots' on: image.	self addItem: (TSketchButtonMorph withForm: image)		dragAction: nil		clickAction: (MessageSend receiver: self selector: #addSnapshots).! !!TZoomNavigatorMorph methodsFor: 'snapshot items' stamp: 'ar 10/11/2002 23:06'!addSnapshots	self addBackButton: #snapshots.	snapshots do:[:item|		self addItem: item			dragAction: nil			clickAction: (MessageSend receiver: self selector: #clickSnapshot: argument: item)].! !!TZoomNavigatorMorph methodsFor: 'snapshot items' stamp: 'ar 10/4/2004 16:13'!clickSnapshot: item	owner activeCamera gotoSpace: item root transform: item globalTransform.! !!TZoomNavigatorMorph methodsFor: 'snapshot items' stamp: 'ar 5/21/2003 14:25'!resetSnapshots	snapshots := OrderedCollection new.! !!TZoomNavigatorMorph methodsFor: 'tools' stamp: 'ar 10/12/2002 23:53'!addTool: toolClass	| thumb |	thumb := ToolFormLibrary at: toolClass name ifAbsent:[nil].	thumb ifNil:[thumb := Form extent: 128@128 depth: 8].	self addTool: toolClass image: thumb.! !!TZoomNavigatorMorph methodsFor: 'tools' stamp: 'ar 10/12/2002 23:55'!addTool: toolClass image: icon	| sketch image |	image := Form extent: icon extent depth: 32.	icon displayOn: image.	self drawName: toolClass name on: image.	sketch := TSketchButtonMorph withForm: image.	sketch setProperty: #clickAction toValue: (MessageSend receiver: self selector: #openTool: argument: toolClass).	tools add: sketch.! !!TZoomNavigatorMorph methodsFor: 'tools' stamp: 'ar 10/11/2002 23:07'!addTools	self addBackButton: #tools.	tools do:[:sketch| self addItem: sketch].	targetHeight := nil.! !!TZoomNavigatorMorph methodsFor: 'tools' stamp: 'ar 3/9/2004 19:31'!addToolsRoot	tools ifNil:[tools := OrderedCollection new].	ToolsForm ifNil:[ToolsForm := Form extent: 32@32 depth: 32].	self addToolsRoot: ToolsForm.! !!TZoomNavigatorMorph methodsFor: 'tools' stamp: 'ar 10/11/2002 22:08'!addToolsRoot: thumb	| image |	image := Form extent: thumb extent depth: 32.	thumb displayOn: image.	self drawName: 'Tools' on: image.	self addItem: (TSketchButtonMorph withForm: image)		dragAction: nil		clickAction: (MessageSend receiver: self selector: #addTools).! !!TZoomNavigatorMorph methodsFor: 'tools' stamp: 'ar 10/11/2002 22:46'!openTool: toolClass	owner openTool: toolClass.! !!TZoomNavigatorMorph methodsFor: 'geometry' stamp: 'ar 9/22/2002 18:42'!extent: newExtent	super extent: newExtent.	scroller position: self position + (self extent - scroller extent // 2).! !!TZoomNavigatorMorph methodsFor: 'geometry' stamp: 'ar 10/12/2002 18:32'!ownerChanged	self left > owner left ifTrue:[self left: owner left].	self top > owner bottom ifTrue:[self top: owner bottom - 16].	self bottom < owner bottom ifTrue:[self top: owner bottom - 16].	self extent x = owner extent x ifFalse:[super extent: owner extent x @ scroller height + 32].! !!TZoomNavigatorMorph methodsFor: 'event handling' stamp: 'ar 9/22/2002 17:37'!handleMouseMove: anEvent	"We need mouseMove even if no button is pressed"	(anEvent hand hasSubmorphs) ifTrue:[^self].	anEvent wasHandled: true.	self mouseMove: anEvent.! !!TZoomNavigatorMorph methodsFor: 'event handling' stamp: 'ar 9/22/2002 17:40'!handlesMouseOver: event	^true! !!TZoomNavigatorMorph methodsFor: 'event handling' stamp: 'ar 9/22/2002 21:32'!mouseDown: evt from: projSketch! !!TZoomNavigatorMorph methodsFor: 'event handling' stamp: 'ar 10/11/2002 19:00'!mouseEnter: anEvent	"show me"	targetHeight _ self height.! !!TZoomNavigatorMorph methodsFor: 'event handling' stamp: 'das 10/1/2002 17:08'!mouseEnter: evt from: sketch	focus ifNotNil:[ focus changed. focus framesToDwell: 20].	focus _ sketch.	focus framesToDwell: 20.! !!TZoomNavigatorMorph methodsFor: 'event handling' stamp: 'ar 9/22/2002 18:53'!mouseLeave: anEvent	"hide me"	targetHeight _ 16.! !!TZoomNavigatorMorph methodsFor: 'event handling' stamp: 'das 10/1/2002 17:08'!mouseLeave: evt from: sketch	sketch framesToDwell: 20.	focus = sketch ifTrue:[focus changed. focus _ nil.].! !!TZoomNavigatorMorph methodsFor: 'event handling' stamp: 'ar 10/11/2002 20:29'!mouseMove: anEvent	| xPos rightMorph leftMorph leftFraction rightFraction deltaX leftExtent rightExtent |	(self containsPoint: anEvent position) ifFalse:[		scroller submorphsDo:[:m| m extent: self smallExtent].	].	"Figure out where we are"	xPos _ anEvent position x.	"See if we need to scroll"	scrollValue _ nil.	deltaX _ (xPos - bounds left) max: 0.	deltaX < self largeExtent x ifTrue:[		scroller left < bounds left ifTrue:[			scrollValue _ self largeExtent x - deltaX // 8.		].	].	deltaX _ (bounds right - xPos) max: 0.	deltaX < self largeExtent x ifTrue:[		scroller right > bounds right ifTrue:[			scrollValue _ self largeExtent x - deltaX // -8.		].	].	rightMorph _ scroller submorphs detect:[:m| m center x > xPos] ifNone:[nil].	rightMorph ifNil:[		"We're at the right most point"		leftMorph _ nil.		leftFraction _ 0.0.		rightMorph _ scroller lastSubmorph.		rightFraction _ 1.0.	] ifNotNil:[		rightMorph == scroller firstSubmorph ifTrue:[			"Left-most"			leftMorph _ rightMorph.			leftFraction _ 1.0.			rightMorph _ nil.			rightFraction _ 0.0.		] ifFalse:[			"somewhere inbetween"			leftMorph _ scroller submorphs at: (scroller submorphs indexOf: rightMorph)-1.			deltaX _ rightMorph center x - leftMorph center x.			rightFraction _ xPos - leftMorph center x / deltaX asFloat.			leftFraction _ 1.0 - rightFraction.		].	].	leftExtent _ self smallExtent + (self largeExtent - self smallExtent * leftFraction) asIntegerPoint.	rightExtent _ self smallExtent + (self largeExtent - self smallExtent * rightFraction) asIntegerPoint.	scroller submorphsDo:[:m|		m == leftMorph 			ifTrue:[m extent: leftExtent]			ifFalse:[m == rightMorph 				ifTrue:[m extent: rightExtent]				ifFalse:[m extent: self smallExtent]]].! !!TZoomNavigatorMorph methodsFor: 'event handling' stamp: 'ar 10/11/2002 18:51'!mouseUp: evt from: sketch	| clickAction |	clickAction _ sketch valueOfProperty: #clickAction.	clickAction ifNil:[^self].	self mouseLeave: evt.	clickAction value.! !!TZoomNavigatorMorph methodsFor: 'event handling' stamp: 'ar 10/8/2002 21:46'!startDrag: evt from: sketch	| dragAction |	dragAction := sketch valueOfProperty: #dragAction.	dragAction ifNil:[^self].	dragAction value.	self mouseLeave: evt.! !!TZoomNavigatorMorph methodsFor: 'event handling' stamp: 'das 10/1/2002 17:03'!step	"Step the receiver"	| height |	focus ifNotNil:[focus framesToDwell: (focus framesToDwell-1).].	scrollValue ifNotNil:[		scroller left: scroller left + scrollValue.		scrollValue < 0 ifTrue:["scroll left"			scroller right <= bounds right ifTrue:[				scroller right: bounds right.				scrollValue _ nil].		] ifFalse:[			scroller left >= bounds left ifTrue:[				scroller left: bounds left.				scrollValue _ nil].		].		self mouseMove: ActiveHand lastEvent.	].	targetHeight ifNotNil:[		height _ owner bottom - self top.		height = targetHeight ifTrue:[^targetHeight _ nil].		height < targetHeight			ifTrue:[height _ height + 16 min: targetHeight]			ifFalse:[height _ height - 16 max: targetHeight].		self top: owner bottom - height.	].! !!TZoomNavigatorMorph methodsFor: 'event handling' stamp: 'ar 9/22/2002 18:18'!stepTime	^50! !!TZoomNavigatorMorph methodsFor: 'accessing' stamp: 'ar 9/22/2002 17:39'!largeExtent	^128@128! !!TZoomNavigatorMorph methodsFor: 'accessing' stamp: 'ar 9/22/2002 17:39'!smallExtent	^64@64! !!TZoomNavigatorMorph class methodsFor: 'as yet unclassified' stamp: 'ar 10/2/2004 20:31'!initialize	"TZoomNavigatorMorph initialize"	BackButtonForm := TeapotMorph loadIcon2: 'BackButton.gif'.	ProjectsForm := TeapotMorph loadIcon2: 'Projects.gif'.	AliceForm := TeapotMorph loadIcon2: 'Alice.gif'.	SnapshotForm := TeapotMorph loadIcon2: 'Snapshot.gif'.	ToolsForm := TeapotMorph loadIcon2: 'Tools.gif'.	ToolFormLibrary := Dictionary new.	#(TSpaceBrowser TConnectionDialog TPainter) do:[:each|		ToolFormLibrary at: each put: (TeapotMorph loadIcon2: each,'.gif').	].! !!TeaHost methodsFor: 'comparing' stamp: 'DPR 9/7/2002 13:50'!< aTeaHost	self hostUID < aTeaHost hostUID! !!TeaHost methodsFor: 'comparing' stamp: 'DPR 9/7/2002 13:50'!<= aTeaHost	self hostUID <= aTeaHost hostUID! !!TeaHost methodsFor: 'comparing' stamp: 'DPR 9/8/2002 13:03'!= aTeaHost	^self hostUID = aTeaHost hostUID! !!TeaHost methodsFor: 'comparing' stamp: 'DPR 9/7/2002 13:50'!> aTeaHost	self hostUID > aTeaHost hostUID! !!TeaHost methodsFor: 'comparing' stamp: 'DPR 9/7/2002 13:50'!>= aTeaHost	self hostUID >= aTeaHost hostUID! !!TeaHost methodsFor: 'comparing' stamp: 'DPR 9/7/2002 13:51'!~= aTeaHost	self hostUID ~= aTeaHost hostUID! !!TeaHost methodsFor: 'private' stamp: 'ar 9/9/2004 12:00'!broadcastListener	"makes local TeaHost to listen on the UDP broadcast socket"	hostAddr _ ThisHost.	listenUDPSocket _ TSocket newUDP.	listenUDPSocket setPort: 41434.   "magic listening port"	hostUDPPort _ listenUDPSocket primSocketLocalPort: listenUDPSocket socketHandle. "and get the value"	listenUDPSocket setOption: 'SO_BROADCAST' value: 1.  "accept broadcasts"	bytesSent _ bytesReceived _ messagesSent _ messagesReceived _ 0.	sendTCPAlways _ false.	tagCounter _ 0.	tagDict _ Dictionary new.	mapNameToObj _ IdentityDictionary new.	selectorHistogram _ IdentityBag new.	hostID _ (LocalHostIDCounter _ LocalHostIDCounter + 1).	listeningUDP_[self listenUDP] forkAt: Processor userInterruptPriority.	TeaHosts at: self hostName put: self.! !!TeaHost methodsFor: 'private'!connectToAddr: hostaddr port: hostport UDP: udpport	"initialize address and port of this TeaHost (remote), then connect to it."	|  |	hostAddr _ hostaddr.	hostPort _ hostport.	hostUDPPort _ udpport.	hostID _ nil.	listenSocket _ nil.	sendTCPAlways _ self class sendTCPAlways.	TeaHosts at: self hostName put: self! !!TeaHost methodsFor: 'private' stamp: 'ar 9/9/2004 12:00'!listen	"listening process for this local host - gets a messages and dispatches them to TeaProcesses"	| accepted |	[true] whileTrue: [ 		Listens _ Listens + 1.		(accepted _ listenSocket waitForAcceptUntil: TSocket standardDeadline) ifNotNil: [ self listenAccept: accepted]]	! !!TeaHost methodsFor: 'private' stamp: 'ar 9/9/2004 12:00'!listenAccept: accepted([ :tempSocket |  | message length | 			message _ String new: 4000. length _ 0.			[tempSocket isConnected and: [tempSocket isOtherEndClosed not]] whileTrue: [			 (tempSocket waitForDataUntil: TSocket standardDeadline) ifTrue: [				  (length + 1500 > message size) ifTrue: [ 						message _ message, String new: length + 1500 - message size. ].		 		  length _ length + (tempSocket readInto: message startingAt: length+1).		   		  ]].		   self processMessage: message length: length.		   tempSocket closeAndDestroy.		   ] newProcessWith: (Array with: accepted)) resume ! !!TeaHost methodsFor: 'private' stamp: 'ar 9/9/2004 12:00'!listenUDP	"listening process for this local host - gets a messages and dispatches them to TeaProcesses"	[true] whileTrue: [ 		Listens _ Listens + 1.		(listenUDPSocket waitForDataUntil: TSocket standardDeadline) ifTrue: [ self listenUDPData]]	! !!TeaHost methodsFor: 'private' stamp: 'ar 9/9/2004 12:00'!local	"makes a new local TeaHost"	hostAddr _ ThisHost.	listenSocket _ TSocket newTCP.	listenSocket listenOn: (TSocket wildcardPort) backlogSize: 8. "get new local unique port"	hostPort _ listenSocket primSocketLocalPort: listenSocket socketHandle. "and get the value"	listenUDPSocket _ TSocket newUDP.	listenUDPSocket setPort: TSocket wildcardPort. "get local UDP port."	hostUDPPort _ listenUDPSocket primSocketLocalPort: listenUDPSocket socketHandle. "and get the value"	bytesSent _ bytesReceived _ messagesSent _ messagesReceived _ 0.	sendTCPAlways _ self class sendTCPAlways.	tagCounter _ 0.	tagDict _ Dictionary new.	mapNameToObj _ IdentityDictionary new.	selectorHistogram _ IdentityBag new.	hostID _ (LocalHostIDCounter _ LocalHostIDCounter + 1).	"initialize to create tunnels"	listeningTunnels _ Dictionary new.	listening_[self listen] forkAt: Processor userInterruptPriority.	listeningUDP_[self listenUDP] forkAt: Processor userInterruptPriority.	TeaHosts at: self hostName put: self.! !!TeaHost methodsFor: 'private' stamp: 'ar 9/9/2004 12:00'!sendStuff: message to: otherTeaHost	"core message sending"	| tempSocket nSent  host |	otherTeaHost tunneled ifFalse: [		host _ otherTeaHost hostAddress.		(message size < 1500) & (sendTCPAlways not)  ifTrue: [ 			nSent _ [listenUDPSocket sendData: message toHost: host port: otherTeaHost hostUDPPort]						on: Error do:[:ex| Transcript cr; show: ex messageText. ex return: 0].			]		ifFalse: [			tempSocket _ TSocket newTCP.			tempSocket connectTo: host port: otherTeaHost hostPort.			(tempSocket waitForConnectionUntil: TSocket standardDeadline)						ifFalse: [Transcript cr; show: 'timedOut'. ^0].			nSent _ [tempSocket sendData: message] on: Error do:[:ex| ex return: 0].			tempSocket closeAndDestroy.			].	  ] ifTrue: [ nSent _ otherTeaHost tunnelSend: message ].	messagesSent _ messagesSent + 1.	bytesSent _ bytesSent + nSent.	^nSent.! !!TeaHost methodsFor: 'private' stamp: 'DPR 6/3/2002 16:49'!tag: anID value: aValue to: other	"sends a Tea time message to other TeaHost (remote)"	|  encodedMessage encoder |	encoder _ ReferenceStream on: (encodedMessage _ RWBinaryOrTextStream on: (String new: 256)).	encoder nextPut: #tagValue.	encoder nextPut: anID.	encoder nextPut: aValue.	encoder close.	encodedMessage _ encodedMessage contents.	^ self sendStuff: encodedMessage to: other.! !!TeaHost methodsFor: 'private' stamp: 'DPR 6/6/2002 12:23'!tunneled	"if not nil, this port's sending method should use the TCP socket, rather than its TCP/UDP ports"	^tunnelSocket notNil! !!TeaHost methodsFor: 'sharing' stamp: 'das 10/3/2004 09:23'!checkMessages	CroquetGlobals theTeapotMorph checkMessages.! !!TeaHost methodsFor: 'sharing'!define: aName as: anObject	"assigns a host global name aName to anObject"	mapNameToObj at: aName put: anObject! !!TeaHost methodsFor: 'sharing' stamp: 'das 10/3/2004 10:51'!mapNameToObject	^ mapNameToObj.! !!TeaHost methodsFor: 'sharing'!objectNamed: aName	"assigns a host global name aName to anObject"	^mapNameToObj at: aName ifAbsent:[nil]! !!TeaHost methodsFor: 'sharing' stamp: 'das 10/3/2004 10:41'!processMessage: message length: length	| decoder mtype fromHost fromPort objName objMessage target effID tagVal tagPlace  fromUDP sem  ts anArray |	bytesReceived _ bytesReceived + length.	messagesReceived _ messagesReceived + 1.	decoder _ ReferenceStream on: (RWBinaryOrTextStream on: message from: 1 to: length).	[decoder atEnd] whileFalse:[		   mtype _ [decoder next] on: Error do:[:ex| Transcript cr; show: ex asString. ex return].		   mtype = #teaMessage ifTrue: [				ts _ decoder next. "time stamp"				TeaTime adjustBase: ts.				objMessage _ decoder next.				selectorHistogram add: objMessage selector.				selectorHistogram add: objMessage target.				objMessage teaHost: self.				self sendMessages: objMessage.			   ].		   mtype = #effect ifTrue: [ self error:' #effect should not happen'.				objName _ decoder next.				objMessage _ decoder next.				selectorHistogram add: objMessage selector.				selectorHistogram add: objName.				self sendMessages: objMessage to: objName.				].		   mtype = #value ifTrue: [self error:' #value should not happen'.				objName _ decoder next.				objMessage _ decoder next.				fromHost _ decoder next.				fromPort _ decoder next.				fromUDP _ decoder next.				effID _ decoder next.				selectorHistogram add: objMessage selector.				anArray _ objMessage arguments.				1 to: anArray size do:[:index | anArray at: index put: ((anArray at: index) teaObject: mapNameToObj).].				objMessage arguments: anArray.				(target _ (mapNameToObj at: objName ifAbsent: [ nil ]))					ifNotNil: [ [| value| value _ objMessage sentTo: target.								self tag: effID value: value to: (TeaHost address: fromHost port: fromPort UDP: fromUDP).] fork ]. 								].		   mtype = #tagValue ifTrue: [				effID _ decoder next.				tagVal _ decoder next.				tagPlace _ tagDict removeKey: effID ifAbsent: ["duplicate result - ignore" nil ].				tagPlace ifNotNil: [(sem _ tagPlace at: 1) ifNotNil: [ tagPlace at: 1 put: nil. tagPlace at: 2 put: tagVal. sem signal]]				].	].	decoder close.! !!TeaHost methodsFor: 'sharing' stamp: 'das 10/1/2004 18:23'!sendMessage: objMessage to: objName	| target anArray aItem constructArray |	target _ mapNameToObj at: objName ifAbsent:[^ false ].	anArray _ objMessage arguments.	1 to: anArray size do:[ :index | 		aItem _ anArray at: index.		aItem ifNotNil:[			aItem _ aItem teaObject: mapNameToObj.			aItem ifNil:[ ^ false ].			anArray at: index put: aItem.			].		].	objMessage doConstruct ifTrue:[		constructArray _ (anArray at: 2) arguments.		1 to: constructArray size do:[ :index | 			aItem _ constructArray at: index.			aItem ifNotNil:[				aItem _ aItem teaObject: mapNameToObj.				aItem ifNil:[ ^ false ].				constructArray at: index put: aItem.				].			].		].	objMessage arguments: anArray. "probably not necessary"	objMessage delayedSendTo: target.	^ true.	! !!TeaHost methodsFor: 'sharing' stamp: 'das 10/3/2004 22:36'!sendMessages: objMessage	CroquetGlobals messageList add: objMessage."	self checkMessages."	! !!TeaHost methodsFor: 'sharing' stamp: 'das 10/3/2004 09:22'!sendMessages: objMessage to: objName	CroquetGlobals messageList add: (Association key: objName value: objMessage).	self checkMessages.	! !!TeaHost methodsFor: 'sharing' stamp: 'DPR 6/3/2002 16:50'!to: other name: aName sendForValue: aMessage	"sends aMessage to object named aName at this host, and wait for value to come back."	|  encodedMessage encoder tag  sem place retries |		encoder _ ReferenceStream on: (encodedMessage _ RWBinaryOrTextStream on: (String new: 256)).	encoder nextPut: #value.	encoder nextPut: aName.	encoder nextPut: aMessage.	encoder nextPut: self hostAddress.	encoder nextPut: self hostPort.	encoder nextPut: self hostUDPPort.	encoder nextPut: (tag _ tagCounter _ tagCounter + 1).	encoder close.	encodedMessage _ encodedMessage contents.	sem _ Semaphore new.	place _ { sem. nil }.	tagDict at: tag put: place.	retries _ 10.	[ self sendStuff: encodedMessage to: other.	  Delay timeoutSemaphore: sem afterMSecs: other networkResponseLatency.	  sem wait.	  (place at: 1) notNil or: [ (retries _ retries - 1) > 0 or: [ Exception signal: 'Remote value timed out'] ]] whileTrue.	^place at: 2.! !!TeaHost methodsFor: 'inquiry'!hostAddress	"host address for local or remote TeaHost"	^hostAddr! !!TeaHost methodsFor: 'inquiry'!hostID	" return hostID"	^hostID! !!TeaHost methodsFor: 'inquiry'!hostName	" return hostName"	hostNameString ifNil: [hostNameString _ (hostAddr inject: '' into: [ :result :i | result_result, i asString, '.']) allButLast, ':', hostPort asString,'|', hostUDPPort asString].	^hostNameString.! !!TeaHost methodsFor: 'inquiry'!hostPort	"return hostPort"	^hostPort! !!TeaHost methodsFor: 'inquiry'!hostUDPPort	"return hostPort"	^hostUDPPort! !!TeaHost methodsFor: 'inquiry' stamp: 'DPR 9/7/2002 13:48'!hostUID	"return a number that provides an ordering for all TeaHosts"	^((hostAddr inject: 0 into: [:total :next | (total bitShift: 8) + next]) bitShift: 32) + (hostPort bitShift: 16) + hostUDPPort! !!TeaHost methodsFor: 'inquiry'!listenUDPData| message length buffer count |	message _ String new: 0.	length _ 0.	buffer _ String new: 2000.	[	count _ listenUDPSocket receiveDataInto: buffer.		count>0 and: [	message _ message forceTo: length+count paddingWith: $. .						message replaceFrom: length + 1 to: length+count with: buffer startingAt: 1.						length _ length + count.						listenUDPSocket dataAvailable] ] whileTrue.	length > 0 ifTrue: [ self processMessage: message length: length. ]! !!TeaHost methodsFor: 'inquiry'!networkResponseLatency	"returns network response latency to particular host, in milliseconds (round trip time)"	^100 "gross estimate - until we self-tune."! !!TeaHost methodsFor: 'inquiry'!networkStatistics	"returns network statistics"	^Array with: messagesSent with: bytesSent with: messagesReceived with: bytesReceived.! !!TeaHost methodsFor: 'inquiry' stamp: 'DPR 4/20/2002 20:19'!selectorHistogram	^selectorHistogram! !!TeaHost methodsFor: 'tunneling' stamp: 'ar 9/9/2004 12:00'!listenTunnel: aTunnelSocket	"listening process for tunnels from local host - gets a messages and dispatches them to TeaProcesses"	| lBuffer len buffer slen mlen |	lBuffer _ ByteArray new: 4. "byte array to receive length field"	[	len _ 0.		[	(aTunnelSocket waitForDataUntil: (TSocket standardDeadline))				ifTrue: [len _ len + (aTunnelSocket readInto: lBuffer startingAt: len+1)].			len=4] whileFalse.		buffer _ String new: (mlen _ lBuffer longAt: 1 bigEndian: false).		slen _ 0.		[	(aTunnelSocket waitForDataUntil: (TSocket standardDeadline))				ifTrue: [slen _ slen + (aTunnelSocket readInto: buffer startingAt: slen+1)].			slen=mlen] whileFalse.		Listens _ Listens + 1.		self processMessage: buffer length: slen.	] repeat.	! !!TeaHost methodsFor: 'tunneling' stamp: 'DPR 6/7/2003 11:47'!runTunnelListenFor: hostName socket: tunnelIn	| tListen |	"start tunnelListen process"	^listeningTunnels at: hostName ifAbsentPut: [		tListen _ [:tSocket | self listenTunnel: tSocket ] newProcessWith: (Array with: tunnelIn).		tListen priority: Processor userInterruptPriority.		tListen resume.		tListen]! !!TeaHost methodsFor: 'tunneling' stamp: 'DPR 6/12/2003 11:59'!runTunnelProcess	| buffer message sendData |	buffer _ ByteArray new: 4.	[true] whileTrue:[		message := tunnelQueue next.		buffer longAt: 1 put: message size bigEndian: false.		sendData _ (message copyReplaceFrom: 1 to: 0 with: buffer).		tunnelSocket sendData: sendData.	].! !!TeaHost methodsFor: 'tunneling' stamp: 'DPR 6/6/2003 14:55'!tunnel: aSocket	"sets this port's sending method to use the TCP socket, rather than its TCP/UDP ports"	aSocket ifNil:[^self].	tunnelSocket notNil ifTrue: [ Transcript cr;show: 'Attempt to retunnel.'. ^self ].	tunnelQueue _ SharedQueue new.	tunnelSocket _ aSocket.	tunnelProcess := [self runTunnelProcess] forkAt: Processor userInterruptPriority.! !!TeaHost methodsFor: 'tunneling' stamp: 'ar 9/9/2004 12:00'!tunnelOut: hostName	"open a tunnel to receive messages from a host name outside the firewall"	| tunnelIn hostnamepart hostaddr buffer |		self hostName = hostName ifTrue: [^self]. " don't tunnel to myself !! "	(listeningTunnels includesKey: hostName) ifTrue: [^self].	Transcript cr; show: 'Open tunnel to receive from: ', hostName.	hostnamepart _ (ReadStream on: hostName) upTo: $:.	hostaddr _ (NetNameResolver addressForName: hostnamepart timeout: 30).	tunnelIn _ TSocket newTCP.	tunnelIn connectTo: hostaddr port: 41436.	(tunnelIn waitForConnectionUntil: (TSocket standardDeadline))		ifFalse: [ Transcript cr; show: 'Cant tunnel to ', hostnamepart, ':41436'.				tunnelIn closeAndDestroy. ^false ].	"send our hostName over the socket so the other end knows who we are"	buffer _ ByteArray new: 4.	buffer longAt: 1 put: hostNameString size bigEndian: false.	buffer _ hostNameString copyReplaceFrom: 1 to: 0 with: buffer.	tunnelIn sendData: buffer.	"send his hostName over the socket so he knows who which socket we are talking to when we send"	buffer _ ByteArray new: 4.	buffer longAt: 1 put: hostName size bigEndian: false.	buffer _ hostName copyReplaceFrom: 1 to: 0 with: buffer.	tunnelIn sendData: buffer.	buffer _ ByteArray new: 1.	[ (tunnelIn receiveDataInto: buffer) = 1] whileFalse: 		[(tunnelIn waitForDataUntil: (TSocket standardDeadline))		 ifFalse: [Transcript cr; show: 'Tunnelling timed out.'. ^false] ].	(buffer at: 1) = 'R' ifTrue: [ Transcript cr; show: 'Tunnel rejected.'. ^false ].	"otherwise accepted, so start tunnelListen process"	self runTunnelListenFor: hostName socket: tunnelIn.	" and make it so we use the tunnel in the other direction, too!!"	(TeaHost name: hostName) tunnel: tunnelIn.	^ true	! !!TeaHost methodsFor: 'tunneling' stamp: 'DPR 6/12/2003 11:58'!tunnelSend: message	tunnelQueue size > 10 ifTrue: [Transcript cr; show: 'tunnelSend: queue excessive, queue = ', tunnelQueue size asString.].	tunnelQueue nextPut: message.	^message size + 4 "for extra header in tunneling"! !!TeaHost methodsFor: 'shutdown' stamp: 'ar 6/13/2002 21:46'!shutdown	"shutdown this TeaHost gracefully"	TeaHosts removeKey: self hostName.	listening ifNotNil: [listening terminate. listening _ nil].	listeningUDP terminate.	listeningUDP _ nil.	listeningTunnels ifNotNil: [listeningTunnels valuesDo: [ :p | p terminate ]].	listeningTunnels _ nil.	tunnelProcess ifNotNil:[tunnelProcess terminate].	tunnelSocket ifNotNil:[tunnelSocket destroy].! !!TeaHost methodsFor: 'message sending' stamp: 'das 9/30/2004 19:16'!to: other name: aName sendForEffect: aMessage	"sends aMessage to object named aName at this host"	|  encodedMessage encoder |	encoder _ ReferenceStream on: (encodedMessage _ RWBinaryOrTextStream on: (String new: 256)).	encoder nextPut: #teaMessage.	encoder nextPut: TeaTime nowAsMilliseconds.	encoder nextPut: aName.	encoder nextPut: aMessage.	encoder close.	encodedMessage _ encodedMessage contents.	^ self sendStuff: encodedMessage to: other.! !!TeaHost methodsFor: 'message sending' stamp: 'das 10/3/2004 13:56'!to: other sendForEffect: aMessage	"sends aMessage to object named aName at this host"	|  encodedMessage encoder |	encoder _ ReferenceStream on: (encodedMessage _ RWBinaryOrTextStream on: (String new: 256)).	encoder nextPut: #teaMessage.	encoder nextPut: TeaTime nowAsMilliseconds.	encoder nextPut: aMessage.	encoder close.	encodedMessage _ encodedMessage contents.	^ self sendStuff: encodedMessage to: other.! !!TeaHost class methodsFor: 'instance creation' stamp: 'ar 9/9/2004 12:01'!acceptTunnel: aSocket	"received a connection from behind a firewall, accept as a tunnel"	| otherHostName lBuffer len mlen slen myHostName otherHost |	Transcript cr; show: 'Accepting tunnel.'.	"now we open the tunnel, read in the host name of the other end"	lBuffer _ ByteArray new: 4. "byte array to receive length field"	len _ 0.	[	(aSocket waitForDataUntil: (TSocket standardDeadline))			ifTrue: [len _ len + (aSocket readInto: lBuffer startingAt: len+1)].		len=4] whileFalse.	otherHostName _ String new: (mlen _ lBuffer longAt: 1 bigEndian: false).	slen _ 0.	[	(aSocket waitForDataUntil: (TSocket standardDeadline))			ifTrue: [slen _ slen + (aSocket readInto: otherHostName startingAt: slen+1)].		slen=mlen] whileFalse.	lBuffer _ ByteArray new: 4. "byte array to receive length field"	len _ 0.	[	(aSocket waitForDataUntil: (TSocket standardDeadline))			ifTrue: [len _ len + (aSocket readInto: lBuffer startingAt: len+1)].		len=4] whileFalse.	myHostName _ String new: (mlen _ lBuffer longAt: 1 bigEndian: false).	slen _ 0.	[	(aSocket waitForDataUntil: (TSocket standardDeadline))			ifTrue: [slen _ slen + (aSocket readInto:myHostName startingAt: slen+1)].		slen=mlen] whileFalse.	"now we set up the TeaHost to tunnel messages over aSocket"	otherHost _ self name: otherHostName.	otherHost tunneled		ifTrue: [ Transcript cr; show: 'acceptTunnel: rejecting, already tunneled'.				 aSocket sendData: 'R'.]		ifFalse: [otherHost tunnel: aSocket.			aSocket sendData: 'A'.			(self name: myHostName) runTunnelListenFor: otherHostName socket: aSocket].! !!TeaHost class methodsFor: 'instance creation'!address: hostaddr port: hostport UDP: udpport	"connect to remote host by address and port number"	| newHost |	newHost _ self new.	newHost connectToAddr: hostaddr port: hostport UDP: udpport.	^newHost! !!TeaHost class methodsFor: 'instance creation' stamp: 'DPR 5/20/2002 22:10'!broadcaster	"connect to local broadcast TeaHosts"	| bcName |	bcName _ '255.255.255.255|0:41434'.	^TeaHosts at: bcName ifAbsent: [		self new connectToAddr: (NetNameResolver addressForName: bcName timeout: 30) port: 0 UDP: 41434.		]! !!TeaHost class methodsFor: 'instance creation'!name: hostname	"connect to TeaHost by DNS name: squeak.org:7999|3475 (port numbers TCP|UDP)"	| newHost hoststream hostport hostaddr hostnamepart hostportpart udpport |	^TeaHosts at: hostname ifAbsent: [		newHost _ self new.		hostport _ -1.		hoststream _ ReadStream on: hostname.		hostnamepart _ hoststream upTo: $:.		(hoststream atEnd) ifTrue: [Exception signal: 'badTeaHostName'].		hostportpart _ hoststream upTo: $|.		(hoststream atEnd) ifTrue: [Exception signal: 'badTeaHostName'].		hostport _ hostportpart asInteger.		udpport _ Integer readFrom: hoststream.		hostaddr _ (NetNameResolver addressForName: hostnamepart timeout: 30).		newHost connectToAddr: hostaddr port: hostport UDP: udpport.		].! !!TeaHost class methodsFor: 'instance creation' stamp: 'DPR 5/20/2002 21:23'!newBroadcastListener	"make a new local TeaHost and start it listening on the UDP broadcast socket"	| newHost |	newHost _ self new.	newHost broadcastListener.	^newHost! !!TeaHost class methodsFor: 'instance creation' stamp: 'das 9/30/2004 18:29'!newLocal	"make a new local TeaHost and start it listening for messages"	| newHost |	newHost _ self new.	newHost local.	TeaHost pushHostName: newHost hostName.	TeaHost pushObjectNumber: 0.	^newHost! !!TeaHost class methodsFor: 'instance creation' stamp: 'ar 6/15/2002 19:48'!shutDown	"shutdown all listening processes for TeaHost"	TeaHosts ifNotNil: [TeaHosts do: [ :teaHost | [teaHost shutdown] on: Error do:[:ex| ex return] ]].	TeaHosts _ nil.	TunnelOpener ifNotNil: [TunnelOpener terminate].	TunnelOpener _ nil.	TunnelOpening ifNotNil: [TunnelOpening closeAndDestroy].	TunnelOpening _ nil.! !!TeaHost class methodsFor: 'instance creation' stamp: 'ar 9/9/2004 12:01'!startSession	"(re)initialize this host"	LocalHostIDCounter ifNil:[LocalHostIDCounter _ 0].	TSocket initializeNetwork.	ThisHost _ NetNameResolver localHostAddress.	TeaHosts ifNotNil: [^self].	TeaHosts _ Dictionary new.	Listens _ 0.	SendTCPAlways _ false.	"initialize to receive tunnels"		TunnelOpening _ TSocket newTCP.	TunnelOpening listenOn: 41436 backlogSize: 8.	TunnelOpener _ [[ [ :accepted | accepted ifNotNil: [self acceptTunnel: accepted]]						value: (TunnelOpening waitForAcceptUntil: TSocket standardDeadline)] 					 					 repeat] fork.! !!TeaHost class methodsFor: 'class initialization' stamp: 'ar 6/15/2002 19:48'!initialize	"TeaHost initialize"	Smalltalk addToShutDownList: self.! !!TeaHost class methodsFor: 'accessing' stamp: 'das 9/30/2004 18:16'!currentHostName	^ HostName.! !!TeaHost class methodsFor: 'accessing' stamp: 'das 9/30/2004 18:35'!getBaseObjectNumber	^ TObjectCounterBase.! !!TeaHost class methodsFor: 'accessing' stamp: 'das 9/30/2004 18:16'!initHostName	HostName _ ''.	HostNameLast _ ''.	TObjectCounter _ 0.	TObjectCounterLast _ 0.! !!TeaHost class methodsFor: 'accessing'!listenLoops	"ReplicaHost listenLoops"	|  |	^Listens! !!TeaHost class methodsFor: 'accessing' stamp: 'das 9/30/2004 18:16'!nextObjectNumber	^ TObjectCounter _ TObjectCounter +1.! !!TeaHost class methodsFor: 'accessing' stamp: 'das 9/30/2004 18:17'!popHostName	HostName _ HostNameLast.	HostNameLast _ ''.! !!TeaHost class methodsFor: 'accessing' stamp: 'das 9/30/2004 18:17'!popObjectNumber	TObjectCounter _ TObjectCounterLast.	TObjectCounterLast _ 1.! !!TeaHost class methodsFor: 'accessing' stamp: 'das 9/30/2004 18:18'!pushHostName: newName	HostNameLast _ HostName.	HostName _ newName.! !!TeaHost class methodsFor: 'accessing' stamp: 'das 9/30/2004 18:18'!pushObjectNumber: toc	TObjectCounterLast _ TObjectCounter.	TObjectCounter _ toc.! !!TeaHost class methodsFor: 'accessing'!sendTCPAlways	^SendTCPAlways! !!TeaHost class methodsFor: 'accessing'!sendTCPAlways: aBoolean	" force sending TCP always, never send UDP."	SendTCPAlways _ aBoolean! !!TeaHost class methodsFor: 'accessing' stamp: 'das 9/30/2004 18:34'!setBaseObjectNumber	TObjectCounterBase _ TObjectCounter.! !!TeaMessage methodsFor: 'cache' stamp: 'das 10/3/2004 09:34'!myScripts	^myScripts ifNil:[#()]! !!TeaMessage methodsFor: 'cache' stamp: 'das 10/3/2004 09:34'!myScripts: list	myScripts := list.! !!TeaMessage methodsFor: 'accessing' stamp: 'das 10/1/2004 16:29'!doConstruct	^ doConstruct.! !!TeaMessage methodsFor: 'accessing' stamp: 'das 10/1/2004 16:29'!doConstruct: bool	doConstruct _ bool.! !!TeaMessage methodsFor: 'accessing' stamp: 'das 1/3/2003 21:28'!setSelector: aSymbol arguments: anArray	super setSelector: aSymbol arguments: anArray.	teaTime _ Time uniqueMicrosecondClockValue.! !!TeaMessage methodsFor: 'accessing' stamp: 'das 9/30/2004 19:05'!setSelector: aSymbol arguments: anArray host: hn number: num	super setSelector: aSymbol arguments: anArray.	teaTime _ Time uniqueMicrosecondClockValue.	hostName _ hn.	objectCounter _ num.! !!TeaMessage methodsFor: 'accessing' stamp: 'das 10/3/2004 09:32'!setTarget: trgt selector: aSymbol arguments: anArray	target _ trgt.	super setSelector: aSymbol arguments: anArray.	teaTime _ TeaTime now.	hostName _ nil.	objectCounter _ nil.	teaHost _ nil.! !!TeaMessage methodsFor: 'accessing' stamp: 'das 10/3/2004 15:32'!setTarget: trgt selector: aSymbol arguments: anArray atTime: tt	target _ trgt.	super setSelector: aSymbol arguments: anArray.	teaTime _ tt.	hostName _ nil.	objectCounter _ nil.	teaHost _ nil.! !!TeaMessage methodsFor: 'accessing' stamp: 'das 10/3/2004 09:27'!setTarget: trgt selector: aSymbol arguments: anArray host: hn number: num atTime: tt	target _ trgt.	super setSelector: aSymbol arguments: anArray.	teaTime _ tt.	hostName _ hn.	objectCounter _ num.! !!TeaMessage methodsFor: 'accessing' stamp: 'das 10/3/2004 09:59'!target	^ target! !!TeaMessage methodsFor: 'accessing' stamp: 'das 10/3/2004 09:31'!teaHost: th	teaHost _ th.! !!TeaMessage methodsFor: 'accessing' stamp: 'das 1/3/2003 21:29'!teaTime	^teaTime.! !!TeaMessage methodsFor: 'sending' stamp: 'das 10/3/2004 09:35'!delayedSend	| script |	script _ self startScript: #execute withArguments: #().	script setProperty: #hostName toValue: hostName.	script setProperty:  #objectCounter toValue: objectCounter.! !!TeaMessage methodsFor: 'sending' stamp: 'ar 10/2/2004 10:50'!delayedSendTo: receiver	"answer the result of sending this message to receiver"	| script |	"Transcript cr; show: 'MSG: #',selector."	script _ receiver startScript: selector withArguments: args.	script setProperty: #hostName toValue: hostName.	script setProperty:  #objectCounter toValue: objectCounter.! !!TeaMessage methodsFor: 'sending' stamp: 'das 10/3/2004 13:32'!execute	| map aItem |	teaHost ifNotNil:[ "then decode the message because this was replicated"	CroquetGlobals theTeapotMorph ifNil:[^ self error:'TeapotMorph is gone.'].	map _ teaHost mapNameToObject.	target _ target teaObject: map.	target ifNil:[ ^self error:'target is nil'].	1 to: args size do:[ :index | 		aItem _ args at: index.		aItem ifNotNil:[			aItem _ aItem teaObject: map.			aItem ifNil:[ ^ self error:'argument is nil' ].			args at: index put: aItem.			].		].	].		target perform: selector withArguments: args.! !!TeaName methodsFor: 'initialize' stamp: 'das 10/7/2002 13:44'!initialize: name	teaObjectName _ name.! !!TeaName methodsFor: 'initialize' stamp: 'das 10/3/2004 09:45'!initialize: name class: bool	teaObjectName _ name.	isClass _ bool.! !!TeaName methodsFor: 'accessing' stamp: 'das 5/26/2003 09:16'!printOn: aStream	aStream nextPutAll: self teaObjectName.! !!TeaName methodsFor: 'accessing' stamp: 'das 10/3/2004 22:49'!teaObject: teaParty	isClass ifTrue:[^Smalltalk at: teaObjectName.] ifFalse:[	^ teaParty at: teaObjectName ifAbsent:[^ nil ]]..! !!TeaName methodsFor: 'accessing' stamp: 'das 5/26/2003 09:18'!teaObjectName	^ teaObjectName.! !!TeaName class methodsFor: 'as yet unclassified' stamp: 'das 10/7/2002 13:45'!initialize: teaName	^ self new initialize: teaName.! !!TeaParty methodsFor: 'sending' stamp: 'das 10/3/2004 22:40'!broadcastForEffect: aMessage	"for all the other hosts in this TeaParty, send to the receiver on that host named aName the message aMessage."	| myName  |	myName _ myHost hostName."	mutex critical: ["		teaHostSet keysAndValuesDo: [ :h :info | h = myName ifFalse: [										self to: (info at: 1) sendForEffect: aMessage]		].	"]."! !!TeaParty methodsFor: 'sending' stamp: 'das 10/3/2004 20:31'!broadcastForEffect: aMessage local: local	"for all the other hosts in this TeaParty, send to the receiver on that host named aName the message aMessage."	| myName  |	myName _ myHost hostName.	mutex critical: [		teaHostSet keysAndValuesDo: [ :h :info | h = myName ifFalse: [										self to: (info at: 1) sendForEffect: aMessage]		].	].! !!TeaParty methodsFor: 'sending' stamp: 'DPR 4/20/2002 20:49'!for: aName broadcastForEffect: aMessage	"for all the other hosts in this TeaParty, send to the receiver on that host named aName the message aMessage."	| myName  |	myName _ myHost hostName.	mutex critical: [		teaHostSet keysAndValuesDo: [ :h :info | h = myName ifFalse: [										self to: (info at: 1) name: aName sendForEffect: aMessage]		]].! !!TeaParty methodsFor: 'sending' stamp: 'das 10/3/2004 09:56'!myHost	^ myHost.! !!TeaParty methodsFor: 'sending' stamp: 'DPR 9/3/2002 11:17'!to: aHost name: aName sendForEffect: aMessage	selectorHistogram add: aMessage selector.	selectorHistogram add: aName.	myHost to: aHost name: aName sendForEffect: aMessage	"old fork removed, to reduce gc overhead".! !!TeaParty methodsFor: 'sending' stamp: 'das 10/3/2004 09:59'!to: aHost sendForEffect: aMessage	selectorHistogram add: aMessage selector.	selectorHistogram add: aMessage target.	myHost to: aHost sendForEffect: aMessage	"old fork removed, to reduce gc overhead".! !!TeaParty methodsFor: 'private' stamp: 'DPR 5/22/2002 11:53'!goodbye: aHostName nickname: aNickname	"message eliminating a host from this party"	Transcript cr; show: 'Goodbye from ', aHostName, ' (', aNickname, ')'.	mutex critical: [teaHostSet removeKey: aHostName ifAbsent: [nil]]! !!TeaParty methodsFor: 'private' stamp: 'das 10/3/2004 22:53'!goodbyeAll	| goodbyeMsg tn |	tn _ TeaName new initialize: #PartyCoordinator class: false.	goodbyeMsg _ (TeaMessage new setTarget: tn selector: #goodbye:nickname: arguments: (Array with: myHost hostName with: nickname))."	mutex critical: ["		teaHostSet keysAndValuesDo: [:hostname :info | myHost to: (info at: 1) sendForEffect: goodbyeMsg ]."	]."	Transcript cr; show: 'broadcast goodbye'.	tn _ TeaName new initialize: partyURLName class: false.	goodbyeMsg _ (TeaMessage new setTarget: tn selector: #goodbye:nickname: arguments: (Array with: myHost hostName with: nickname)).	blistener to: TeaHost broadcaster sendForEffect: goodbyeMsg. ! !!TeaParty methodsFor: 'private' stamp: 'das 10/3/2004 10:08'!hello: aHostName nickname: aNickname	"message introducing a new host to this party"	| other newOther tn |	TeaParty transcriptOn ifTrue:[		Transcript cr; show: 'Hello from ', aHostName, ' (', aNickname, ')'.	].	other _ TeaHost name: aHostName.	newOther _ false.	mutex critical: [		teaHostSet at: aHostName ifAbsent: [ newOther _ true. ].		teaHostSet at: aHostName put: (Array with: other with: aNickname with: TeaTime nowAsMicroseconds + 45000000.0)].	newOther ifTrue: [		  "if we learn about someone new inform him of us"		TeaParty transcriptOn ifTrue:[Transcript cr; show: 'Tell other guy about me'.].		ForceTunnel notNil ifTrue: [myHost tunnelOut: aHostName].		tn _ TeaName new initialize: #PartyCoordinator class: false.		myHost to: other sendForEffect: (TeaMessage new setTarget: tn selector: #hello:nickname: arguments: (Array with: myHost hostName with: nickname)).		teapot ifNotNil:[teapot noteNewHost: other].	].! !!TeaParty methodsFor: 'private' stamp: 'das 10/3/2004 10:09'!helloAll	| helloMsg  tn |	TeaParty transcriptOn ifTrue:[Transcript cr; show: 'In helloAll'.].	tn _ TeaName new initialize: #PartyCoordinator class: false.	helloMsg _ (TeaMessage new setTarget: tn selector: #hello:nickname: arguments: (Array with: myHost hostName with: nickname)).	mutex critical: [teaHostSet valuesDo: [ :info | myHost to: (info at: 1) sendForEffect: helloMsg.]].	TeaParty transcriptOn ifTrue:[Transcript cr; show: 'Broadcast hello'.].	tn _ TeaName new initialize: partyURLName class: false.	helloMsg _ (TeaMessage new setTarget: tn selector: #hello:nickname: arguments: (Array with: myHost hostName with: nickname)).	blistener to: TeaHost broadcaster sendForEffect: helloMsg.	TeaParty transcriptOn ifTrue:[Transcript cr; show: 'Broadcasted hello'.]. ! !!TeaParty methodsFor: 'private' stamp: 'DPR 6/6/2002 16:00'!host: aTeaHost rendezvousAt: aURL forParty: aPartyName nickname: aNickname	"contact the URL and join a particular Tea Party"	|  doc |	noInternet _ NoInternet.	aTeaHost define: #PartyCoordinator as: self.	aTeaHost define: #ReplicaDir as: (ReplicaDir at: aTeaHost).	blistener _ TeaHost newBroadcastListener.	partyURLName _ Symbol intern: (aURL, '/',  aPartyName).	blistener define: partyURLName as: self.	teaHostSet _ Dictionary new.	myHost _ aTeaHost.	nickname _ aNickname.	myURL _ aURL.	myParty _ aPartyName.	selectorHistogram _ IdentityBag new.	mutex _ Semaphore new.	teaHostSet at: myHost hostName put: (Array with: myHost with: aNickname with: TeaTime infinity asFloat).	mutex signal.	"now join the party, using two methods - an HTTP command, and LAN broadcast"	noInternet ifNil: [doc _ HTTPSocket httpGetDocument: aURL args: 'cmd=JoinParty&PartyName=', aPartyName, '&MemberName=', myHost hostName, '&Nickname=', nickname, '&Timeout=30'.	self processServerResponse: doc ignoreError: true].	self runKeepAlive.! !!TeaParty methodsFor: 'private' stamp: 'ar 7/19/2002 17:21'!processServerResponse: document ignoreError: ignoreError	"process response from TeaParty server"	| doc member mStream hostName nickName remoteAddr currentTime behindNAT |	(document isKindOf: String) ifTrue: [ ignoreError ifFalse: [Exception signal: 'Rendezvous failed ',document]. ^nil].	doc _ ReadStream on: document content.	doc upToAll: '<?xml version="1.0" ?>'.	(doc atEnd or: [doc upToAll: '<ERROR>'. doc atEnd not])		ifTrue: [ ignoreError ifFalse: [Exception signal: 'Rendezvous server error.' ]. ^ nil].	doc reset.	doc upToAll: '<REMOTE_ADDR>'.	doc atEnd ifTrue: [ignoreError ifFalse: [Exception signal: 'Rendezvous server error.' ]. ^nil].	remoteAddr _ doc upToAll: '</REMOTE_ADDR>'.     behindNAT _ (remoteAddr ~= ((ReadStream on: myHost hostName) upTo: $:)).	doc upToAll: '<CURRENT_TIME>'.	doc atEnd ifTrue: [ignoreError ifFalse: [Exception signal: 'Rendezvous server error.' ]. ^nil].	currentTime _ (doc upToAll: '</CURRENT_TIME>') asNumber asFloat.	"parse XML result set"	mutex critical: [		[doc upToAll: '<MEMBER>'. doc atEnd not ] whileTrue: [			member _ doc upToAll: '</MEMBER>'.			mStream _ ReadStream on: member.	  	  	mStream upToAll: '<HOSTNAME>'.			hostName _ mStream upToAll: '</HOSTNAME>'.			mStream upToAll: '<NICKNAME>'.			nickName _ mStream upToAll: '</NICKNAME>'.			teaHostSet at: hostName put: (Array with: (TeaHost name: hostName) with: nickName with: TeaTime nowAsMicroseconds + 45000000).			ForceTunnel == true ifTrue: [ 				myHost tunnelOut: hostName.			] ifFalse:[				behindNAT					ifTrue: [ 	((hostName beginsWith: '10.')									or: [hostName beginsWith: '192.168.'])								 ifFalse: [	"Tunnel required."					 											myHost tunnelOut: hostName ]]].		]].! !!TeaParty methodsFor: 'private' stamp: 'DPR 6/7/2003 16:28'!runKeepAlive	"start the keepAlive process which times out peers that don't hello, and sends hello to peers."	| nextHello nunc when till doc |	nextHello _ TeaTime origin asFloat.	keepAlive _ [		  [ nunc _ TeaTime nowAsMicroseconds.			(nextHello < nunc) ifTrue: [  self helloAll.										noInternet ifNil: [											doc _ HTTPSocket httpGetDocument: myURL														 args: 'cmd=RenewMembership&PartyName=', myParty, '&MemberName=',															 myHost hostName, '&Nickname=', nickname, '&Timeout=45'.											self processServerResponse: doc ignoreError: true.].										 nextHello _ nunc + 30000000 ].			when _ nextHello.				mutex critical: [				teaHostSet keysAndValuesDo: [ :host :info | (till _ info at: 3) < nunc ifTrue: [ teaHostSet removeKey: host ] ifFalse: [ when _ when min: till ] ]].			(Delay forMilliseconds: (when - nunc) asInteger // 1000) wait.			] repeat		] fork.! !!TeaParty methodsFor: 'private' stamp: 'ar 10/2/2004 12:10'!teapot	^teapot! !!TeaParty methodsFor: 'private' stamp: 'ar 10/2/2004 12:10'!teapot: aTeapotMorph	teapot := aTeapotMorph! !!TeaParty methodsFor: 'statistics' stamp: 'DPR 6/4/2002 14:29'!membership	"return a set containing our membership"	| members  |	members _ OrderedCollection new.	mutex critical: [teaHostSet keysDo: [ :h  | members add: h ]].	^members! !!TeaParty methodsFor: 'statistics' stamp: 'DPR 4/20/2002 18:11'!selectorHistogram	^selectorHistogram! !!TeaParty methodsFor: 'resigning' stamp: 'das 10/3/2004 13:51'!resign	"resign from this tea party"	keepAlive ifNil:[^ self].	keepAlive terminate.	keepAlive _ nil.	noInternet ifNil: [HTTPSocket httpGetDocument: myURL args: 'cmd=Resign&PartyName=', myParty, '&MemberName=', myHost hostName].	self goodbyeAll.	blistener shutdown.	blistener _ nil.! !!TeaParty class methodsFor: 'as yet unclassified' stamp: 'DPR 6/6/2002 20:44'!activePartiesAt: aURL	"get the party names at a particular URL"	| doc parties party |	NoInternet ifNotNil: [^Set new].	doc _ HTTPSocket httpGetDocument: aURL args: 'cmd=ActiveParties'.	doc _ ReadStream on: doc content.	doc upToAll: '<ERROR>'. doc atEnd ifFalse: [ Exception signal: 'Rendezvous encountered an error.' . ^ nil] ifTrue: [doc reset].	"parse XML result set"	parties _ Bag new.	[doc upToAll: '<TEAPARTY>'. doc atEnd not ] whileTrue: [		party _ doc upToAll: '</TEAPARTY>'.		parties add: party.		].	^parties.! !!TeaParty class methodsFor: 'as yet unclassified' stamp: 'ar 9/10/2002 21:21'!disableInternet	^NoInternet ifNil:[false].! !!TeaParty class methodsFor: 'as yet unclassified' stamp: 'DPR 6/4/2003 20:35'!disableInternet: aBool	NoInternet _ nil.	aBool ifTrue: [NoInternet _ true ].! !!TeaParty class methodsFor: 'as yet unclassified' stamp: 'ar 9/10/2002 21:20'!forceTunnel	^ForceTunnel ifNil:[false].! !!TeaParty class methodsFor: 'as yet unclassified' stamp: 'DPR 7/16/2002 04:57'!forceTunnel: aBoolean	ForceTunnel _ nil.	aBoolean ifTrue: [ForceTunnel _ aBoolean].! !!TeaParty class methodsFor: 'as yet unclassified'!host: aTeaHost rendezvousAt: aURL forParty: aPartyName nickname: aNickname	"contact the URL and join a particular Tea Party"	| tp |	tp _ self new.	tp host: aTeaHost rendezvousAt: aURL forParty: aPartyName nickname: aNickname.	^tp! !!TeaParty class methodsFor: 'as yet unclassified' stamp: 'ar 6/13/2002 21:49'!testPartyAt: aURL	"test the basic TeaParty functions"	| th1 th2 tp1 tp2 th1set th2set |	TeaHost startSession.	th1 _ TeaHost newLocal.	th2 _ TeaHost newLocal.	Transcript cr; show: 'Tea Hosts: ', th1 hostName, ', ', th2 hostName.	tp1 _ TeaParty host: th1 rendezvousAt: aURL forParty: 'TestPartyLocal' nickname: 'tp1'.	Transcript cr; show: 'Active Parties: ', (TeaParty activePartiesAt: aURL) asString.	Transcript cr; show: 'Members (according to tp1): ', (tp1 membership) asString.	tp2 _ TeaParty host: th2 rendezvousAt: aURL forParty: 'TestPartyLocal' nickname: 'tp2'.	Transcript cr; show: 'Active Parties: ', (TeaParty activePartiesAt: aURL) asString.	Transcript cr; show: 'Members (according to tp1): ', (tp1 membership) asString.	Transcript cr; show: 'Members (according to tp2): ', (tp2 membership) asString.	th1 define: #foo as: (th1set _ Set new).	th2 define: #bar as: (th2set _ Set new).	tp1 for: #bar broadcastForEffect: (Message selector: #add: argument: 2).	tp2 for: #foo broadcastForEffect: (Message selector: #add: argument: 1).	(Delay forSeconds: 2) wait.	Transcript cr;show: 'th1set: ',th1set asString.	Transcript cr;show: 'th2set: ',th2set asString.	th1 define: #tran as: Transcript.	th2 define: #tran as: Transcript.	tp1 for: #tran broadcastForEffect: (Message selector: #show: argument: 'hello from tp1. ').	tp2 for: #tran broadcastForEffect: (Message selector: #show: argument: 'hello from tp2. ')..	(Delay forSeconds: 2) wait.		tp1 resign.	Transcript cr; show: 'tp1 resigns'.	Transcript cr; show: 'Members (according to tp2): ', (tp2 membership) asString.	tp2 resign.	Transcript cr; show: 'tp2 resigns.'.	Transcript cr; show: 'Active Parties: ', (TeaParty activePartiesAt: aURL) asString.	Transcript cr; show: 'Network stats for th1: ', th1 networkStatistics asString.	Transcript cr; show: 'Network stats for th2: ', th2 networkStatistics asString.! !!TeaParty class methodsFor: 'as yet unclassified' stamp: 'ar 6/13/2002 21:49'!testPartyJoin: aURL forParty: aPartyName	"test the basic TeaParty functions"	| th1 tp1 th1set proc1 |	TeaHost startSession.	th1 _ TeaHost newLocal.	Transcript cr; show: 'Tea Host: ', th1 hostName.	tp1 _ TeaParty host: th1 rendezvousAt: aURL forParty: aPartyName nickname: 'tp1'.	Transcript cr; show: 'Active Parties: ', (TeaParty activePartiesAt: aURL) asString.	Transcript cr; show: 'Members: ', (tp1 membership) asString.	th1 define: #foo as: (th1set _ Set new).	Transcript cr;show: 'Participating in party.  Wait for 20 seconds....'.	(Delay forSeconds: 20) wait.	Transcript cr;show: 'Done waiting.'.	tp1 for: #foo broadcastForEffect: (Message selector: #add: argument: th1 hostName).	(Delay forSeconds: 2) wait.	Transcript cr;show: 'th1set: ',th1set asString.	th1 define: #tran as: Transcript.	tp1 for: #tran broadcastForEffect: (Message selector: #show: argument: 'test hello from ', th1 hostName).		proc1 _ [[ tp1 for: #tran broadcastForEffect: (Message selector: #cr). tp1 for: #tran broadcastForEffect: (Message selector: #show: argument: 'hello from ', th1 hostName). (Delay forSeconds: 1) wait. ] repeat] newProcess.	proc1 resume.	(Delay forSeconds: 30) wait.	proc1 terminate.		tp1 resign.	Transcript cr; show: 'Resign'.	th1 shutdown.	Transcript cr; show: 'Members: ', (tp1 membership) asString.	Transcript cr; show: 'Active Parties: ', (TeaParty activePartiesAt: aURL) asString.	Transcript cr; show: 'Network stats: ', th1 networkStatistics asString.! !!TeaParty class methodsFor: 'as yet unclassified' stamp: 'das 9/30/2004 12:58'!transcriptOn	^ TranscriptOn.! !!TeaParty class methodsFor: 'as yet unclassified' stamp: 'das 9/30/2004 12:58'!transcriptOn: bool	TranscriptOn _ bool.! !!TeaTime methodsFor: 'arithmetic' stamp: 'DPR 9/7/2002 12:48'!* amt	"multiply a TeaTime by an amount"	|  |	^(self class) setMilliseconds: (time * amt) state: 0 initialHost: nil.! !!TeaTime methodsFor: 'arithmetic' stamp: 'DPR 9/8/2002 13:30'!+ amt	"add millisecond value to self"	|  |	^(self class) setMilliseconds: (time + amt asFloat) state: 0 initialHost: nil.! !!TeaTime methodsFor: 'arithmetic' stamp: 'DPR 9/8/2002 13:31'!- aTime	"subtract an integer or TeaTime from TeaTime"	| |	^ (aTime isKindOf: (self class)) ifTrue: [time - aTime asFloat]          ifFalse: [self + (aTime asFloat negated)]! !!TeaTime methodsFor: 'arithmetic' stamp: 'DPR 9/7/2002 12:48'!/ amt	"divide a TeaTime by an amount"	|  |	^(self class) setMilliseconds: (time / amt) state: 0 initialHost: nil.! !!TeaTime methodsFor: 'arithmetic' stamp: 'DPR 9/7/2002 15:54'!// amt	"divide a TeaTime by an amount"	|  |	^time // amt asFloat! !!TeaTime methodsFor: 'arithmetic' stamp: 'DPR 9/4/2002 19:13'!hash	"must define hash"	^time hash! !!TeaTime methodsFor: 'arithmetic' stamp: 'DPR 9/8/2002 13:28'!quo: amt	"divide a TeaTime by an amount"	^time quo: amt asFloat! !!TeaTime methodsFor: 'arithmetic' stamp: 'DPR 9/8/2002 13:29'!rem: amt	"divide a TeaTime by an amount"	^time rem: amt asFloat! !!TeaTime methodsFor: 'arithmetic' stamp: 'DPR 6/17/2002 00:49'!secondsRemaining	"return time before TeaTime will be past"	| t |	t _ (self class) nowAsSeconds.	^self asSeconds - t! !!TeaTime methodsFor: 'arithmetic' stamp: 'DPR 9/8/2002 13:30'!timeRemaining	"return time before TeaTime will be past"	^time - (self class) nowAsMilliseconds.! !!TeaTime methodsFor: 'arithmetic' stamp: 'DPR 9/7/2002 12:50'!truncated	"truncate to an integer"	^TeaTime setMilliseconds: time truncated state: 0 initialHost: nil! !!TeaTime methodsFor: 'comparing' stamp: 'DPR 9/7/2002 14:00'!< aTime	"get number form"	^(self compare: aTime) negative. ! !!TeaTime methodsFor: 'comparing' stamp: 'DPR 9/7/2002 14:01'!<= aTime	"get number form"	^(self compare: aTime) positive not.! !!TeaTime methodsFor: 'comparing' stamp: 'DPR 9/8/2002 12:56'!= aTime	"compare"	|  |	(aTime isKindOf: (self class))		ifTrue: [^(time = aTime asFloat) and: [initialHost = aTime initialHost]]		ifFalse: [^false]! !!TeaTime methodsFor: 'comparing' stamp: 'DPR 9/7/2002 14:00'!> aTime	"get number form"	^(self compare: aTime) positive. ! !!TeaTime methodsFor: 'comparing' stamp: 'DPR 9/7/2002 14:00'!>= aTime	"get number form"	^(self compare: aTime) negative not. ! !!TeaTime methodsFor: 'comparing' stamp: 'DPR 9/7/2002 13:04'!blocks: anOther	"true if this teatime dominates anOther, meaning it is later, or is the same and already aborted"	^(self > anOther ) or: [(self = anOther) and: [self mutable not]]! !!TeaTime methodsFor: 'comparing' stamp: 'DPR 9/7/2002 13:57'!compare: aTeaTime	"Compare and return		< 0: if receiver is less than aTeaTime		= 0: if receiver equals aTeaTime		> 0: if receiver is larger than aTeaTime"	| otherTime otherHost |	otherTime _ aTeaTime asFloat.	time < otherTime ifTrue: [^ -1 ].	time > otherTime ifTrue: [^ 1 ].	otherHost _ aTeaTime initialHost.	initialHost = otherHost ifTrue: [ ^ 0 ].	initialHost ifNil: [ ^ -1 ].	initialHost < otherHost ifTrue: [ ^ -1 ].	initialHost > otherHost ifTrue: [ ^ 1 ].	! !!TeaTime methodsFor: 'comparing' stamp: 'DPR 9/4/2002 19:15'!~= aTime	"compare"	(aTime isKindOf: (self class))		ifTrue: [^time ~= aTime asFloat or: [initialHost ~= aTime initialHost]]		ifFalse: [^true]! !!TeaTime methodsFor: 'state management' stamp: 'DPR 6/17/2002 00:49'!abort	"put this TeaTime in the aborted state"	^self scheduler abort: self.! !!TeaTime methodsFor: 'state management' stamp: 'DPR 6/17/2002 00:49'!abortAndTerminate	"put this TeaTime in the aborted state"	self abort.	Processor activeProcess terminate.! !!TeaTime methodsFor: 'state management' stamp: 'DPR 9/4/2002 19:06'!aborted	"returns true only if TeaTime aborted"	|  |	^ state = 1 ! !!TeaTime methodsFor: 'state management' stamp: 'DPR 6/17/2002 00:49'!commit	"commit this TeaTime"	^self scheduler commit: self.! !!TeaTime methodsFor: 'state management' stamp: 'DPR 9/4/2002 19:06'!committed	"returns true only if TeaTime positively committed"	|  |	^ state = 0 ! !!TeaTime methodsFor: 'state management' stamp: 'DPR 6/17/2002 00:49'!mutable	"returns true only if TeaTime still mutable"	^self scheduler isMutable: self! !!TeaTime methodsFor: 'state management' stamp: 'DPR 9/4/2002 19:07'!past	"returns true if self is in the past"	|  |	^time < ((self class) nowAsMilliseconds)! !!TeaTime methodsFor: 'state management' stamp: 'DPR 9/4/2002 19:07'!state	^state! !!TeaTime methodsFor: 'as yet unclassified' stamp: 'DPR 7/18/2002 08:07'!addContingent: aReplica	"make object contingent on this TeaTime - notify the object by sending it a message when state of this TeaTime changes"	self scheduler addContingent: aReplica at: self.	(self mutable) ifFalse: [aReplica thePartysOver]! !!TeaTime methodsFor: 'converting' stamp: 'DPR 9/4/2002 19:04'!asFloat	"get as float"	^time! !!TeaTime methodsFor: 'converting' stamp: 'DPR 9/4/2002 19:05'!asInteger	"get number form"	^time asInteger! !!TeaTime methodsFor: 'converting' stamp: 'DPR 9/4/2002 19:05'!asSeconds	"get in floating point form as seconds"	^time / 1000.0.! !!TeaTime methodsFor: 'private' stamp: 'DPR 9/4/2002 19:05'!initialHost	^initialHost! !!TeaTime methodsFor: 'private' stamp: 'DPR 9/4/2002 19:19'!privateSetState: aState	state _ aState.! !!TeaTime methodsFor: 'private' stamp: 'DPR 6/17/2002 00:49'!scheduler	^self class scheduler! !!TeaTime methodsFor: 'private' stamp: 'DPR 9/4/2002 19:02'!setMilliseconds: t state: aNum initialHost: aTeaHost	"make a TeaTime with a particular microsecond value and state"	time _ t.	state _ aNum.	initialHost _ aTeaHost.	^self! !!TeaTime methodsFor: 'scheduling' stamp: 'DPR 6/17/2002 00:49'!possibleValue: aBlock	"run aBlock until it finishes with a deadline set to self's deadline"	^self possibleValue: aBlock ifAborted: nil	! !!TeaTime methodsFor: 'scheduling' stamp: 'DPR 6/17/2002 00:49'!possibleValue: aBlock ifAborted: altBlock	"run aBlock until it finishes with a deadline set to self's deadline"	^aBlock valueBefore: self ifAborted: altBlock	! !!TeaTime methodsFor: 'scheduling' stamp: 'DPR 6/17/2002 00:49'!waitForFinal	"wait until final state reached (via commit, abort, or timeout)"	| sema |	sema _ Semaphore new.	self scheduler whenFinalized: self signal: sema.	sema wait.! !!TeaTime methodsFor: 'scheduling' stamp: 'DPR 9/16/2002 14:36'!waitUntil	"wait until real time = TeaTime."	| t |	t _ self timeRemaining.	t positive ifTrue: [(Delay forMilliseconds: t asInteger) wait].! !!TeaTime methodsFor: 'printing' stamp: 'DPR 9/7/2002 12:53'!printOn: aStream	"display a TeaTime"	aStream nextPutAll: 'a TeaTime['.	time printOn: aStream.	aStream nextPut: (#($C $A $P $X) at: state + 1).	state=3 ifTrue: [ aStream nextPutAll: ' from: '. initialHost printOn: aStream ].	aStream nextPut: $].	^self! !!TeaTime class methodsFor: 'as yet unclassified' stamp: 'DPR 6/13/2003 09:46'!adjustBase: aTime	"adjust TeaBase forward so that we are not far behind this correspondent's clock"	| delta |	delta _ (aTime - TeaBase) - Time millisecondClockValue.	delta abs > 5000.0 ifTrue: [Transcript cr; show: 'adjustBase excessive ', delta asString, ' msec.'].	delta positive ifTrue: [ TeaBase _ TeaBase + delta ].! !!TeaTime class methodsFor: 'as yet unclassified' stamp: 'DPR 9/8/2002 12:50'!currentInitialHost		| active |	active _ Processor activeProcess.	active class = TeaTime ifTrue: [ ^active host ].	"make sure we have a good TeaHost by default"	DefaultInitialHost ifNil: [ DefaultInitialHost _ TeaHost newLocal. ].	^DefaultInitialHost! !!TeaTime class methodsFor: 'as yet unclassified' stamp: 'DPR 6/17/2002 00:49'!deadline	"return the current deadline for the active possible computation"	^Processor activeProcess deadline! !!TeaTime class methodsFor: 'as yet unclassified' stamp: 'DPR 9/7/2002 12:35'!defaultInitialHost	"make sure we have a good TeaHost"	DefaultInitialHost ifNil: [ DefaultInitialHost _ TeaHost newLocal. ].	^DefaultInitialHost! !!TeaTime class methodsFor: 'as yet unclassified' stamp: 'DPR 9/7/2002 12:29'!defaultInitialHost: aTeaHost	DefaultInitialHost _ aTeaHost! !!TeaTime class methodsFor: 'as yet unclassified' stamp: 'DPR 9/7/2002 12:45'!future: deltaT	"create an uncommitted TeaTime deltaT milliseconds in the future"	| t |	t _ self setMilliseconds: (self nowAsMilliseconds + deltaT) state: 2 initialHost: self currentInitialHost.	self scheduler scheduleTeaTime: t.	^t! !!TeaTime class methodsFor: 'as yet unclassified' stamp: 'DPR 8/26/2002 22:34'!futureSeconds: deltaT	"create an uncommitted TeaTime deltaT seconds (can be float) in the future"	^self future: (deltaT * 1000)! !!TeaTime class methodsFor: 'as yet unclassified' stamp: 'DPR 9/6/2002 16:58'!infinity	"TeaTime after all others - should never be committed..."	^self setMilliseconds: Float infinity state: 0 initialHost: nil! !!TeaTime class methodsFor: 'as yet unclassified' stamp: 'DPR 9/4/2002 19:31'!makeProxy: aTime baseHost: aTeaHost	| ph newTeaTime phs result |	"makes a proxy for the mutable TeaTime whose time is aTime, and which is defined on baseHost"	self halt.  "this is broken"	newTeaTime _ self setMilliseconds: aTime asFloat state: 3 initialHost: aTeaHost.	ph _ self proxyHosts.	phs _ ph at: aTeaHost ifAbsent: [ phs _ Set new. ph at: aTeaHost put: phs. phs ].	result _ phs add: newTeaTime.	"if we've not seen this one before, remember what host it is defined on"	result == newTeaTime ifTrue: [ph at: newTeaTime put: aTeaHost ].		^result! !!TeaTime class methodsFor: 'as yet unclassified' stamp: 'DPR 9/7/2002 12:47'!now	"TeaTime now - returns current Tea time"	^self setMilliseconds: (self nowAsMilliseconds) state: 0 initialHost: nil.! !!TeaTime class methodsFor: 'as yet unclassified' stamp: 'DPR 6/17/2002 00:57'!nowAsMicroseconds	"private helper to return now as microseconds"	^1000.0 * (self nowAsMilliseconds)! !!TeaTime class methodsFor: 'as yet unclassified' stamp: 'bf 9/13/2004 17:51'!nowAsMilliseconds	"private helper to return now as milliseconds"	| t |	TeaBase ifNil: [self reset].	t _ Time millisecondClockValue asFloat.	(t < LastT) ifTrue: [ TeaBase _ TeaBase + (SmallInteger maxVal asFloat) ]. "wrap around happened"	(t = LastT) ifFalse: [ Tweaks _ 0.0. LastT _ t ] ifTrue: [ Tweaks _ Tweaks + DeltaTweak ].	^t + TeaBase + Tweaks! !!TeaTime class methodsFor: 'as yet unclassified' stamp: 'DPR 6/17/2002 00:58'!nowAsSeconds	"private helper to return now as floating point seconds"	^self nowAsMilliseconds / 1000.0! !!TeaTime class methodsFor: 'as yet unclassified' stamp: 'DPR 9/6/2002 20:31'!origin	"TeaTime before all others"	^self setMilliseconds: Float infinity negated state: 0 initialHost: nil! !!TeaTime class methodsFor: 'as yet unclassified' stamp: 'DPR 9/4/2002 18:20'!proxyHosts	ProxyHosts ifNil: [ ProxyHosts _ Dictionary new].	^ ProxyHosts! !!TeaTime class methodsFor: 'as yet unclassified' stamp: 'ar 3/9/2004 20:05'!reset	"reset the class"	"First set TeaBase so that when added to Time millisecondClockValue, it gives an	approximation to milliseconds since midnight 1/1/01.   Should adjust for time zone if it were available, to give UTC time.   In any case, use TeaTime syncWithUTC after this, if connectivity to the network is available."	TeaBase _ ((Time totalSeconds asFloat) * 1000.0 - Time millisecondClockValue asFloat).	ProxyHosts _ nil. 	LastT _ 0.0.	DeltaTweak _ 1.0 / 2048.0.  "fraction of a millisecond to distinguish successive readings by"	"TeaProcessor reset."	DefaultInitialHost _ nil.! !!TeaTime class methodsFor: 'as yet unclassified' stamp: 'ar 3/9/2004 20:03'!shutdown	"shutdown all TeaTime activities"	TeaBase _ nil.	"TeaProcessor terminate."	DefaultInitialHost _ nil.! !!TeaTime class methodsFor: 'as yet unclassified' stamp: 'DPR 9/14/2002 01:00'!syncWithUCT	^self syncWithUTC "fix spelling error" ! !!TeaTime class methodsFor: 'as yet unclassified' stamp: 'ar 9/9/2004 12:01'!syncWithUTC	"get UTC time from NIST server, and calculate difference between local clock and NIST.	Then adjust TeaBase so that TeaTime nowAsMilliseconds returns milliseconds since January 1	1901 UTC.	Return the adjustment in seconds.   Should be very close to zero, though the first time after reset it	should approximate the number of seconds corresponding to the current timezone's difference	from UTC."	| sock result addr time date arrivalTime delta millisecOffset |	TSocket initializeNetworkIfFail: [ ^0 ].	addr _ NetNameResolver addressForName: 'time-b.nist.gov' timeout: 30.	addr ifNil: [ ^0 ].	sock _ TSocket newTCP.	sock connectTo: addr port: 13.	(sock waitForConnectionUntil: (TSocket deadlineSecs: 10)) ifFalse: [ sock closeAndDestroy. ^0 ].	result _ ''.	[ result _ result, sock getData. 	  arrivalTime _ Time millisecondClockValue. "save time when data gotten"	  result size < 50 and: [sock isConnected]] whileTrue.	sock closeAndDestroy.	result size < 24 ifTrue: [ ^0 ].	time _ (result copyFrom: 17 to: 24) asTime.	millisecOffset _ (result copyFrom: 33 to: 37).	[millisecOffset startsWithDigit] whileFalse: [ millisecOffset _ millisecOffset allButFirst ].	millisecOffset _ millisecOffset asNumber.	date _ Date fromJulianDayNumber: ((result copyFrom: 2 to: 6) asInteger + 2400001).	TeaBase ifNil: [ TeaBase _ 0.0].  "make sure TeaBase is a number"	delta _ ((time asSeconds + (date asSeconds)) * 1000.0 - millisecOffset - TeaBase) - arrivalTime.	TeaBase _ TeaBase + delta.	^delta / 1000 "returns adjustment in seconds" ! !!TeaTime class methodsFor: 'as yet unclassified' stamp: 'DPR 9/14/2002 01:14'!testBasic	"basic test of TeaTime"	| t s t20 t10 |	Transcript cr; show: 'TeaTime syncWithUTC: ', TeaTime syncWithUTC asString.	Transcript cr; show: 'sample of UTC sync accuracy: ', ((1 to: 2) collect: [ :i | TeaTime syncWithUTC ]) asString.	Transcript cr; show: ((1 to: 10) collect: [ :i | TeaTime nowAsMicroseconds ]).	Transcript cr; show: ((1 to: 10) collect: [ :i |  TeaTime nowAsSeconds ]).	t _ TeaTime now.	Transcript cr; show: ((1 to: 10) collect: [ :i | TeaTime now - t ]).	Transcript cr; show: 'TeaTime origin < TeaTime infinity: ', (TeaTime origin < TeaTime infinity) asString.	Transcript cr; show: 't < TeaTime now: ', (t < TeaTime now) asString.	Transcript cr; show: 'TeaTime now < t: ', (TeaTime now < t) asString.	s _ Set new.	Transcript cr; show: 'Milliseconds per TeaTime futureSeconds: (2 to: 10) atRandom :', ((Time millisecondsToRun: [ 1 to: 100 do: [ :i | s add: (TeaTime futureSeconds: (2 to: 10) atRandom)]]) asFloat/100.0) asString.	"Transcript cr; show: (s collect: [ :tt | tt secondsRemaining ])."	Transcript cr; show: 'Committed percentage: ', ((s count: [ :tt | tt committed])/1.0) asString.	Transcript show: 'Aborted percentage: ', ((s count: [ :tt | tt aborted])/1.0) asString.	Transcript show: 'Mutable percentage: ', ((s count: [ :tt | tt mutable])/1.0) asString.	Transcript cr; show: 'Delay for 5 seconds.'.		(Delay forSeconds: 5) wait.	Transcript cr; show: 'Commit half of the TeaTimes.'.	s do: [ :tt | (0 to: 1) atRandom < 0.5 ifTrue: [ tt commit ]].	Transcript cr; show: 'Committed percentage: ', ((s count: [ :tt | tt committed])/1.0) asString.	Transcript show: ' Aborted percentage: ', ((s count: [ :tt | tt aborted])/1.0) asString.	Transcript show: ' Mutable percentage: ', ((s count: [ :tt | tt mutable])/1.0) asString.	Transcript cr; show: 'Delay for 2 seconds.'.		(Delay forSeconds: 2) wait.	Transcript cr; show: 'Committed percentage: ', ((s count: [ :tt | tt committed])/1.0) asString.	Transcript show: ' Aborted percentage: ', ((s count: [ :tt | tt aborted])/1.0) asString.	Transcript show: ' Mutable percentage: ', ((s count: [ :tt | tt mutable])/1.0) asString.	Transcript cr; show: 'Wait for all to abort.'.	s do: [ :tt | tt waitForFinal ].	Transcript cr; show: 'Committed percentage: ', ((s count: [ :tt | tt committed])/1.0) asString.	Transcript show: ' Aborted percentage: ', ((s count: [ :tt | tt aborted])/1.0) asString.	Transcript show: ' Mutable percentage: ', ((s count: [ :tt | tt mutable])/1.0) asString.	t20 _ TeaTime futureSeconds: 20.	t10 _ TeaTime futureSeconds: 10.	t20 possibleValue: [ 1 to: 30 do: [ :i | (Delay forSeconds: 1) wait. Transcript cr; show: 't20: ', (t20 timeRemaining / 1000000.0) asString]].	t10 possibleValue: [ 1 to: 20 do: [ :i | 1 to: 20000 do: [ :j |  TeaTime now ]. Processor yield. Transcript cr; show: 't10: ', (t10 timeRemaining / 1000000.0) asString]].	! !!TeaTime class methodsFor: 'private' stamp: 'DPR 6/17/2002 00:49'!scheduler	^TeaProcessor! !!TeaTime class methodsFor: 'private' stamp: 'DPR 9/4/2002 19:29'!setMilliseconds: t state: aNum initialHost: aTeaHost	"make a TeaTime with a particular microsecond value and state"	^self new setMilliseconds: t state: aNum initialHost: aTeaHost.! !!TeapotMorph methodsFor: 'acceleration'!accelerationEnabled"Transcript show:'accelerationEnabled';cr."	"Return true if hardware acceleration is enabled"	self accelerationSuspended ifTrue:[^false].	^self valueOfProperty: #accelerationEnabled ifAbsent:[false]! !!TeapotMorph methodsFor: 'acceleration' stamp: 'ar 9/30/2004 16:43'!accelerationEnabled: aBool	"Enable or disable hardware acceleration"	ogl ifNotNil:[ogl destroy. ogl _ nil].	aBool		ifTrue:[self setProperty: #accelerationEnabled toValue: aBool]		ifFalse:[self removeProperty: #accelerationEnabled]! !!TeapotMorph methodsFor: 'acceleration'!accelerationSuspended"Transcript show:'accelerastionSuspended';cr."	"Return true if hardware acceleration is temporarily suspended"	^self valueOfProperty: #accelerationSuspended ifAbsent:[false]! !!TeapotMorph methodsFor: 'acceleration'!accelerationSuspended: aBool"Transcript show:'accelerationSuspended:';cr."	"Temporarily suspend hardware acceleration"	aBool		ifTrue:[self setProperty: #accelerationSuspended toValue: aBool]		ifFalse:[self removeProperty: #accelerationSuspended]! !!TeapotMorph methodsFor: 'acceleration'!restoreAcceleration"Transcript show:'restoreAcceleration';cr."	"Restore temporarily suspend acceleration"	self accelerationSuspended: false.! !!TeapotMorph methodsFor: 'acceleration' stamp: 'ar 10/2/2004 16:15'!suspendAcceleration	"Temporarily suspend acceleration"	ogl ifNotNil:[		myImage := ogl screenShot.		ogl destroy.		ogl _ nil].	self accelerationSuspended: true.	self changed.! !!TeapotMorph methodsFor: 'drag and drop' stamp: 'ar 10/1/2004 08:38'!acceptDroppingMorph: aMorph event: anEvent	| projName |	(self respondsTo: aMorph dragTransferType) 		ifTrue:[self perform: aMorph dragTransferType with: aMorph passenger].	(aMorph isKindOf: ProjectViewMorph) ifTrue:[		projName _ aMorph project name.		^self makeLinkToProject: projName	].	(aMorph isKindOf: TSnapshot) ifTrue:[		^self makePortal: aMorph.	].	(aMorph isKindOf: Morph) ifTrue: [		^self makeLocalProjectWithMorph: aMorph.	].	^super acceptDroppingMorph: aMorph event: anEvent.! !!TeapotMorph methodsFor: 'drag and drop' stamp: 'ar 10/11/2002 02:08'!dropBehaviorRef: aBehavior! !!TeapotMorph methodsFor: 'drag and drop' stamp: 'ar 10/1/2004 08:39'!makeLocalProjectWithMorph: aMorph	"put a morph into a new morphic project, creating a window for it in front of the camera"	| win tmorph newWorld |	tmorph _ TMorphic new initializeOpaque: true extent: 512@512.	newWorld _ TMorphMonitor createLocalProjectWithExtent: tmorph extent initialMorph: aMorph.	newWorld eventsTo: tmorph.		win _ activeCamera avatar makeWindowInFront.	win contents: tmorph.	^ win.! !!TeapotMorph methodsFor: 'drag and drop' stamp: 'das 10/11/2002 12:55'!wantsDroppedMorph: aMorph event: anEvent	(self respondsTo: aMorph dragTransferType) ifTrue:[^true].	^(aMorph isKindOf: ProjectViewMorph) or:[aMorph isKindOf: TSnapshot].! !!TeapotMorph methodsFor: 'accessing' stamp: 'ar 9/9/2002 17:58'!acrossWorldsStuff	^self valueOfProperty: #acrossWorldsStuff ifAbsentPut:[Dictionary new].! !!TeapotMorph methodsFor: 'accessing' stamp: 'ar 10/4/2004 14:12'!activeCamera	^activeCamera! !!TeapotMorph methodsFor: 'accessing' stamp: 'das 9/27/2002 02:09'!dock	^ dock.! !!TeapotMorph methodsFor: 'accessing' stamp: 'ar 9/30/2004 16:47'!imageForm	^ogl screenShot! !!TeapotMorph methodsFor: 'accessing' stamp: 'das 10/3/2004 09:21'!messageList	^ messageList.! !!TeapotMorph methodsFor: 'accessing' stamp: 'ar 10/26/2002 00:00'!messenger	^messenger! !!TeapotMorph methodsFor: 'accessing' stamp: 'ar 10/26/2002 00:00'!messenger: aMessenger	messenger := aMessenger! !!TeapotMorph methodsFor: 'accessing' stamp: 'ar 10/4/2004 16:09'!ogl	^ogl! !!TeapotMorph methodsFor: 'accessing' stamp: 'ar 10/26/2002 00:16'!people	^people! !!TeapotMorph methodsFor: 'accessing' stamp: 'ar 9/24/2002 00:37'!showTextureStats	"Answer whether to display texture statistics"	^self valueOfProperty: #showTextureStats ifAbsent:[false]! !!TeapotMorph methodsFor: 'accessing' stamp: 'ar 9/24/2002 00:37'!showTextureStats: aBool	"Indicate whether to display texture statistics"	^self setProperty: #showTextureStats toValue: aBool! !!TeapotMorph methodsFor: 'menu' stamp: 'ar 10/2/2004 16:10'!addCustomMenuItems: aMenu hand: aHand	super addCustomMenuItems: aMenu hand: aHand.	aMenu add: 'Connect' action: #initializeTeaParty.	aMenu addUpdating: #showFrameRateString action: #toggleFrameRate.	aMenu addUpdating: #showTextureStatsString action: #toggleTextureStats.	aMenu addUpdating: #transmitStuffString action: #toggleTransmit.	aMenu add: 'start pda server' action: #startPDAServer.	aMenu add: 'make new space' action: #makeNewSpace.! !!TeapotMorph methodsFor: 'menu' stamp: 'ar 6/23/2002 16:49'!showFrameRateString	^(self fpsMorph ifNil:['<off>'] ifNotNil:['<on>']), 'show frame rate'! !!TeapotMorph methodsFor: 'menu' stamp: 'ar 9/24/2002 00:44'!showTextureStatsString	^(self showTextureStats ifTrue:['<on>'] ifFalse:['<off>']), 'show texture stats'! !!TeapotMorph methodsFor: 'menu' stamp: 'ar 9/9/2004 12:01'!startPDAServer	TSocket initializeNetwork.	[self runPDAServer] forkAt: Processor userInterruptPriority.! !!TeapotMorph methodsFor: 'menu' stamp: 'ar 6/23/2002 16:49'!toggleFrameRate	self fpsMorph: (self fpsMorph ifNil:[FrameRateMorph new] ifNotNil:[nil])! !!TeapotMorph methodsFor: 'menu' stamp: 'ar 9/24/2002 00:43'!toggleTextureStats	self showTextureStats: self showTextureStats not! !!TeapotMorph methodsFor: 'menu' stamp: 'ar 3/26/2002 17:21'!toggleTransmit	self extent: 240@320.	self transmitStuff: self transmitStuff not.! !!TeapotMorph methodsFor: 'menu' stamp: 'ar 3/23/2002 00:13'!transmitStuffString	^(self transmitStuff ifTrue:['<on>'] ifFalse:['<off>']),'PDA sync'! !!TeapotMorph methodsFor: 'toys' stamp: 'ar 10/3/2004 12:18'!addZoomNavigator	dock _ TZoomNavigatorMorph new.	dock position: self bounds bottomLeft.	dock fullBounds. "need the layout!!"	dock width: self width.	self addMorph: dock.	dock mouseLeave: nil.	dock addProjectRoot.	dock addSnapshotRoot.	dock addToolsRoot.	dock addAliceRoot.	dock addTool: TPainter.	dock addTool: TSpaceBrowser.	dock addTool: TConnectionDialog.! !!TeapotMorph methodsFor: 'toys' stamp: 'ar 9/30/2004 14:15'!chooseAvatar: newAvatar andClose: aWindow	| oldAvatar |	oldAvatar := activeCamera avatar.	activeCamera meta avatarName: newAvatar teaObjectName.	aWindow ifNotNil:[aWindow delete].	activeCamera waitUntil: #spaceLeave.	activeCamera meta avatarName: oldAvatar teaObjectName.! !!TeapotMorph methodsFor: 'toys' stamp: 'ar 9/30/2004 14:16'!chooseAvatar: frameList for: aFrame	| holder thumb frame button |	aFrame == activeCamera ifFalse:[^self].true ifTrue:[^self chooseAvatar: frameList atRandom andClose: nil].	holder := TeaBackingMorph new.	holder color: Color transparent.	holder layoutPolicy: TableLayout new.	holder listDirection: #leftToRight; hResizing: #shrinkWrap; vResizing: #shrinkWrap.	holder cellInset: 10@0.	frameList do:[:atar|		thumb := atar makeThumbnail.		frame := Morph new.		frame color: ((Color gray: 0.9) alpha: 0.9).		frame borderStyle: (BorderStyle complexFramed width: 5).		frame layoutPolicy: TableLayout new.		frame hResizing: #shrinkWrap; vResizing: #shrinkWrap.		frame addMorphBack: (SketchMorph withForm: thumb).		button := TButtonMorph new.		button label: 'Choose Avatar'.		button hResizing: #spaceFill.		frame addMorphBack: button.		holder addMorphBack: frame.		self startScript: #chooseAvatar:andClose: withArguments:{atar. holder} when:{button. #fire}.	].	holder fullBounds.	self addMorphCentered: holder.! !!TeapotMorph methodsFor: 'toys' stamp: 'ar 10/2/2004 20:24'!clickOpenAliceFile: filePath	| frame trans teaUrl |	teaUrl := 'http://www.reed.com/TeaLand'.	2 to: filePath size do:[:i| teaUrl := teaUrl,'/', (filePath at: i)].	teaUrl := (teaUrl allButLast: 4), '.tea'.	frame := self loadURL: teaUrl reuseExisting: false.	frame ifNil:[frame := self loadAliceModel: filePath url: teaUrl].	trans _ activeCamera avatar translation + (activeCamera lookAt * 10).	frame translation: trans.	activeCamera root addChild: frame.	"dist := activeCamera bottom - frame boundingBox min y.	frame startScript:[frame move: #up distance: dist duration: 1].	frame startScript:[frame turnTo: activeCamera]."! !!TeapotMorph methodsFor: 'toys' stamp: 'ar 10/11/2002 02:42'!enableScriptBehaviors	^false! !!TeapotMorph methodsFor: 'toys' stamp: 'das 4/18/2003 17:45'!loadAliceFile: filePath	| frame teaUrl |	teaUrl := 'http://www.reed.com/TeaLand'.	2 to: filePath size do:[:i| teaUrl := teaUrl,'/', (filePath at: i)].	teaUrl := (teaUrl allButLast: 4), '.tea'.	frame := self loadURL: teaUrl reuseExisting: false.	frame ifNil:[frame := self loadAliceModel: filePath url: teaUrl].	^ frame.! !!TeapotMorph methodsFor: 'toys' stamp: 'ar 9/30/2004 12:48'!loadAliceModel: filePath url: teaUrl	| mdl frame thumb fName |	Utilities informUserDuring:[:bar|		bar value: 'Importing ', filePath last,'...'.		fName := FileDirectory pathFrom: {FileDirectory default pathName}, filePath.		mdl := TLoadMDL new.		frame := mdl parseFileNamed: fName.		thumb := Form extent: 128@128 depth: 8.		(frame makeThumbnail: 128@128) displayOn: thumb at: 0@32 rule: Form paint.		TExporter export: frame asBinary: teaUrl withThumbnail: thumb.	].	^frame! !!TeapotMorph methodsFor: 'toys' stamp: 'ar 9/30/2004 12:48'!loadAliceModels: sp	| fd mdl frame url thumb urlName imageUrl |	Utilities informUserDuring:[:bar|		bar value: 'Loading Alice library...'.		mdl := TLoadMDL new.		#('Furnishings') do:[:dir|		"#('Animals' 'Scenery' 'Vehicles') do:[:dir|"		"#('Alphabet' 'Animals' 'Furnishing' 'Logos' 'Misc' 'Scenery' 'Shapes' 'Vehicles') do:[:dir|"			fd := FileDirectory pathFrom: {FileDirectory default pathName. 'Content'. 'Alice'. dir}.			fd := FileDirectory on: fd.			url := 'http://www.reed.com/TeaLand/Alice/',dir,'/'.			(fd fileNamesMatching: '*.mdl') do:[:fName|				urlName := url, (fName copyFrom: 1 to: fName size-3), 'tea'.				imageUrl := url, (fName copyFrom: 1 to: fName size-3), 'gif'.				thumb := self loadImageUrl: imageUrl.				thumb ifNil:[					bar value: 'Initializing Alice library... (', fName,')'.					frame := mdl parseFileNamed: (fd fullNameFor: fName).					thumb := Form extent: 128@128 depth: 8.					(frame makeThumbnail: 128@128) displayOn: thumb at: 0@32 rule: Form paint.					TExporter export: frame asBinary: urlName withThumbnail: thumb.				] ifNotNil:[					bar value: 'Loading Alice library... (', fName,')'.				].			].		].	].! !!TeapotMorph methodsFor: 'toys'!loadAmbientSound: soundName	| myFile mySound fd |	fd _ (FileDirectory default directoryNamed:'sounds').	(fd fileExists: soundName) ifFalse:[^self].	myFile _ MPEGFile openFile: (fd fullNameFor: soundName).	mySound _ myFile audioPlayerForChannel: 1.	mySound repeat: true.	mySound volume: 1.0.	^mySound! !!TeapotMorph methodsFor: 'toys' stamp: 'ar 9/30/2004 16:06'!make3Body: spc	| sp2 light tframe p1 win pic p2 |	sp2 _ TSpace new.	sp2 color:  (Color				r: 0.0				g: 0.0				b: 0.0).		sp2 url: 'http://www.reed.com/TeaLand/spaces/3body.tea'."Add a light to the world "	light _ TLight new.	light ambientColor: #(0.3 0.3 0.3 1)asFloatArray.	tframe _ TSpinner new.	tframe translationX: -10 y:0.0 z: 0.0.	tframe rotationAroundX: -90.	tframe matNil.	tframe contents: light.	sp2 addChild: tframe.	tframe _ T3Body new.	sp2 addChild: tframe.	p1 _ TPortal new.	win _ TWindow new.	win translationX: -12 y: 0.0 z: -2.0.	win contents: p1.	spc addChild: win.	pic _ TTexture				new initializeWithFileName: 'dpr.bmp'				mipmap: true				shrinkFit: false.	win rectFront: pic.	win closeContents.	p2 _ TPortal new.	win _ TWindow new.	win rotationAroundY: 225.	win translationX: 40.0 y:10.0 z: 40.0.	win contents: p2.	sp2 addChild: win.	p1 linkPortal: p2.	self makeSnapshot: sp2 angle: 11 translation:(B3DVector3 x:11.27770042419434 y:10.25 z:100.1538009643555).	^sp2! !!TeapotMorph methodsFor: 'toys' stamp: 'ar 9/30/2004 16:10'!makeAlphaTexture: sp	| form pic fs win mat |	form _ Form extent: 256@256 depth: 32.	fs _ GradientFillStyle colors: {Color red alpha: 1.0. Color red alpha: 0.0}.	fs origin: 0@0; direction: 0@256.	form getCanvas fillRectangle: form boundingBox fillStyle: fs."	pic := TTexture new."	pic _ TTexture new initializeWithForm: form mipmap: false shrinkFit: false.	fs _ GradientFillStyle colors: {Color red alpha: 1.0. Color red alpha: 0.0}.	fs origin: 0@0; direction: 0@256.	form getCanvas fillRectangle: form boundingBox fillStyle: fs.	mat _ TMaterial new.	mat ambientColor: #(0.8 0.8 0.8 0.5) asFloatArray.	mat diffuseColor: #(0.8 0.8 0.8 0.5) asFloatArray.	pic material: mat.	win _ pic.	"win _ TWindow new."	win translationX: 0.0 y: 0.0 z: -10.0.	"win contents: pic."	sp addChild: win.! !!TeapotMorph methodsFor: 'toys' stamp: 'ar 9/30/2004 16:06'!makeBounce: sp	| win sp2 p1 p2 lt  ball txt |	ball _ TSphere new.	ball rotationAroundZ: 10.		txt _ TTexture				new initializeWithFileName: 'RChecker.bmp'				mipmap: true				shrinkFit: false.	ball texture: txt.	txt _ TTexture				new initializeWithFileName: 'graph128.bmp'				mipmap: true				shrinkFit: false.	p1 _ TPortal new.	lt _ TLight new.	lt rotationAroundZ: 120.	sp2 _ TSpace new.	sp2 addChild: lt.	sp2 color:(Color r: 1.0 g: 1.0 b: 1.0).	sp2 addChild: ball.	win _ TWindow new.	win translationX: -5 y: 0.0 z: -8.0.	win contents: p1.	sp addChild: win.	p2 _ TPortal new.	win _ TWindow new.	win rotationAroundY: 180.	win translationX: 0.0 y:0.0 z: 3.0.	win contents: p2.	sp2 addChild: win.	p1 linkPortal: p2.! !!TeapotMorph methodsFor: 'toys' stamp: 'ar 9/30/2004 16:09'!makeCharacters: sp at: loc	| url tframe tgroup trans ang offset |	tgroup _ TGroup new.	trans _ B3DMatrix4x4 identity.	ang _ 72.0.	offset _ 0@0@-12.	url _ 'http://www.reed.com/TeaLand/characters/nemo.tea'.	tframe _ self loadURL: url.	tframe ifNil:[		tframe _ (TLoad3DSMax new initializeWithFileName: 			(FileDirectory pathFrom: {FileDirectory default pathName. 'Content'. 'Characters'. 'Nemo'. 'cptNemo.ase'}) 			scale: 0.03 shadeAngle: 90.1 textureMode: GLModulate) frame.		tframe boundsDepth: 2.		tframe initBounds.		TExporter export: tframe asBinary:url.		].	trans rotationAroundY: ang*1.	trans translation: (trans localPointToGlobal: offset).	tframe localTransform: trans.	tgroup addChild: tframe.	url _ 'http://www.reed.com/TeaLand/characters/superhero.tea'.	tframe _ self loadURL: url.	tframe ifNil:[		tframe _ (TLoad3DSMax new initializeWithFileName: 			(FileDirectory pathFrom: {FileDirectory default pathName. 'Content'. 'Characters'. 'superhero'. 'superhero.ase'}) 			scale: 0.23 shadeAngle: 90.1 textureMode: GLModulate) frame.		tframe boundsDepth: 2.		tframe initBounds.		TExporter export: tframe asBinary:url.		].	trans _ tframe localTransform..	trans _ (B3DMatrix4x4 identity rotationAroundY: ang*2) composeWith:trans.	trans translation: ((B3DMatrix4x4 identity rotationAroundY: ang*2) localPointToGlobal: offset+(0@2.65@0)).	tframe localTransform: trans.	tgroup addChild: tframe.	url _ 'http://www.reed.com/TeaLand/characters/Laura.tea'.	tframe _ self loadURL: url.	tframe ifNil:[		tframe _ (TLoad3DSMax new initializeWithFileName: 			(FileDirectory pathFrom: {FileDirectory default pathName. 'Content'. 'Characters'. 'Laura'. 'LauraCroft.ase'}) 			scale: 0.15 shadeAngle: 90.1 textureMode: GLModulate) frame.		tframe boundsDepth: 2.		tframe initBounds.		TExporter export: tframe asBinary:url.		].	trans _ B3DMatrix4x4 identity.	trans rotationAroundY: ang*3.	trans translation: (trans localPointToGlobal: offset+(0@2@0)).	tframe localTransform: trans.	tgroup addChild: tframe.	url _ 'http://www.reed.com/TeaLand/characters/stoneWoman.tea'.	tframe _ self loadURL: url.	tframe ifNil:[		tframe _ (TLoad3DSMax new initializeWithFileName: 			(FileDirectory pathFrom: {FileDirectory default pathName. 'Content'. 'Characters'. 'stoneWoman'. 'stoneWoman.ase'}) 			scale: 0.07 shadeAngle: 90.1 textureMode: GLModulate) frame.		tframe boundsDepth: 2.		tframe initBounds.		TExporter export: tframe asBinary:url.		].	trans _ B3DMatrix4x4 identity.	trans rotationAroundY: ang*4.	trans translation: (trans localPointToGlobal: offset+(0@3.5@0)).	tframe localTransform: trans.	tgroup addChild: tframe.	url _ 'http://www.reed.com/TeaLand/characters/human.tea'.	tframe _ self loadURL: url.	tframe ifNil:[		tframe _ (TLoad3DSMax new initializeWithFileName: 			(FileDirectory pathFrom: {FileDirectory default pathName. 'Content'. 'Characters'.'human.ase'}) 			scale: 0.07 shadeAngle: 90.1 textureMode: GLModulate) frame.		tframe boundsDepth: 2.		tframe initBounds.		TExporter export: tframe asBinary:url.		].	trans _ B3DMatrix4x4 identity.	trans rotationAroundY: ang*5.	trans translation: (trans localPointToGlobal: offset+(0@3.5@0)).	tframe localTransform: trans.	tgroup addChild: tframe.	tgroup doColorize: false.	tframe _ TSimpleSpin new.	tframe contents: tgroup.	tframe translation: loc.	sp addChild:tframe.! !!TeapotMorph methodsFor: 'toys' stamp: 'ar 10/1/2004 08:41'!makeChess: sp	| chess win tm teaWorld |	chess _ ChessMorph new.	chess beSticky.	tm _ TMorphic new initializeOpaque: true extent: 512@512.	teaWorld _ TMorphMonitor new initializeWithWorld: nil extent: 512@512.	teaWorld eventsTo: tm.	teaWorld world color: chess color.	teaWorld world addMorphCentered: chess.	win _ TWindow new.	win translationX: 12 y: 0.0 z: -16.0.	win rotationAroundY: -75.	win contents: tm.	win closeContents.	sp addChild: win.! !!TeapotMorph methodsFor: 'toys' stamp: 'ar 10/2/2004 20:24'!makeClock: sp	| tframe |	tframe _ TClock new.	tframe translationX: 10 y: 2 z: 20.	sp addChild: tframe.! !!TeapotMorph methodsFor: 'toys' stamp: 'ar 9/30/2004 16:13'!makeDungeon7: sp	| win win2 sp2 p1 p2 lt mat pic tframe |	mat _ TMaterial new.	p1 _ TPortal new.	p1 material: mat.	p2 _ TPortal new.	p2 translationX: -617 y:33 z: 211."	p2 rotationAroundY: 180.	p2 material: mat.""	lt _ TLight new.	lt materialAlpha: (TMaterial new).	lt ambientColor: #(0.9 0.7 0.7 1.0) asFloatArray.	lt diffuseColor: #(1.0  1.5  1.0  1.0) asFloatArray.	lt specularColor: #(0.0 0.0 0.0 1.0) asFloatArray.	lt rotationAroundZ: 120."	lt _ TLight new."	lt ambientColor: #(3.0 2.8 2.7 1.0) asFloatArray.	lt diffuseColor: #(2.0  1.9  1.7  1.0) asFloatArray.	lt specularColor: #(0.0 0.0 0.0 1.0) asFloatArray."	tframe _ TSpinner new.	tframe translationX: -10 y:0.0 z: 0.0.	tframe rotationAroundZ: 120.	tframe matNil.	tframe contents: lt.	sp2 _ TSpace new.	sp2 url: 'http://www.reed.com/TeaLand/spaces/dungeon.tea'."	sp2 ambientSound: (self loadAmbientSound: 'flag.mp3')."	sp2 addChild: tframe. " add the light"	sp2 color:(Color r: 0.5 g: 0.5 b: 0.7).	sp2 fogOn: true.	sp2 fogDensity: 0.003.	sp2 fogStart: 100.0.	sp2 fogEnd: 6000.0.		pic _ TTexture new initializeWithFileName: 'smith2.bmp'				mipmap: true				shrinkFit: false.	win _ TWindow new.	win translationX: 12 y: 0.0 z: -1.0.	win contents: p1.	win rectFront: pic.	win closeContents.	sp addChild: win.	win2 _ TWindow new.	win2 translationX: 0.5 y: 6.1 z: -31.	win2 contents: p2.	sp2 addChild: win2."	sp2 addChild: p2."	p1 linkPortal: p2."	tframe _ TSkyBox new initializeWithFileName: 'CA'.	sp2 addChild: tframe.	"	tframe _ self loadURL: 'http://www.reed.com/TeaLand/spaces/theDungeon7.tea'.	tframe ifNil:[		tframe _ (TLoad3DSMax new initializeWithFileName: 			(FileDirectory pathFrom: {FileDirectory default pathName. 'Content'. 'DungeonDemo'. 'space7.ase'}) 			scale: 0.02 shadeAngle: 90.1 textureMode: GLReplace) frame.		tframe translationX: 0 y: 38.0 z:0.	"	tframe rotationAroundX: -90."		tframe boundsDepth: 3.		tframe initBounds.		TExporter export: tframe asBinary:'http://www.reed.com/TeaLand/spaces/theDungeon7.tea'.		].	"sp2 addChild: tframe."	TQuadTree new initializeWithSpace: sp2 frame: tframe.! !!TeapotMorph methodsFor: 'toys' stamp: 'ar 10/2/2004 20:25'!makeDungeon: sp	| win win2 sp2 p1 p2 lt mat pic tframe waterTop waterfall waterBottom |	mat _ TMaterial new.	p1 _ TPortal new.	p1 material: mat.	p2 _ TPortal new."	p2 rotationAroundY: 180.	p2 translationX: 0.0 y:0.0 z: 3.0.	p2 material: mat."	lt _ TLight new.	lt ambientColor: #(1 1 1 1) asFloatArray.	lt diffuseColor: #(1 1 1 1) asFloatArray.	lt specularColor: #(0.2 0.15 0.15 1.0) asFloatArray.	lt visible: false.	tframe _ TSpinner new.	tframe translationX: -10 y:0.0 z: 0.0.	tframe matNil.	tframe contents: lt.	lt := tframe.	lt addRotationAroundZ: 120.	lt addRotationAroundY:-10.	lt translationX: -30 y:-32 z: -76."	lt2 _ TLight new.	lt2 ambientColor: #(0.7 0.7 0.7 1.0) asFloatArray.	lt2 diffuseColor: #(0.7 0.7 0.7 1.0) asFloatArray.	lt2 specularColor: #(0.1 0.1 0.2 1.0) asFloatArray.	lt2 visible: false.	tframe _ TSpinner new.	tframe matNil.	tframe contents: lt2.	lt2 := tframe.	lt2 addRotationAroundZ: -120.	lt2 addRotationAroundY:10.	lt2 translationX: -34 y:-32 z: -76."	sp2 _ TSpace new.	sp2 url: 'http://www.reed.com/TeaLand/spaces/dungeon.tea'."	sp2 ambientSound: (self loadAmbientSound: 'flag.mp3')."	sp2 ambientSound: (self loadAmbientSound: 'apollo.mp3').	sp2 addChild: lt. " add the light""	sp2 addChild: lt2." " add the light"	sp2 color:(Color r: 0.5 g: 0.7 b: 0.6).	sp2 fogOn: true.	sp2 fogDensity: 0.0015.	sp2 fogStart: 100.0.	sp2 fogEnd: 6000.0.		pic _ TTexture				new initializeWithFileName: 'smith2.bmp'				mipmap: true				shrinkFit: false.	win _ TWindow new.	win translationX: 12 y: 0.0 z: -1.0.	win contents: p1.	win rectFront: pic.	win closeContents.	sp addChild: win.	win2 _ TWindow new.	win2 translationX: -5 y: -32 z: -78.	win2 contents: p2.	sp2 addChild: win2."	sp2 addChild: p2."	p1 linkPortal: p2.	tframe _ TSkyBox new initializeWithFileName: 'CA'."	glx activeCamera attachment: tframe."	sp2 addChild: tframe.		tframe _ self loadURL: 'http://www.reed.com/TeaLand/spaces/theDungeon.tea'.	tframe ifNil:[		tframe _ (TLoad3DSMax new initializeWithFileName: 			(FileDirectory pathFrom: {FileDirectory default pathName. 'Content'. 'DungeonDemo'. 'space5.ase'}) 			scale: 0.035 shadeAngle: 90.1 textureMode: GLModulate) frame.		tframe translationX: -67 y: -3.0 z:-208.0."		tframe translationX: -63 y: -4.0 z:-163.0.""		tframe rotationAroundX: -90."		tframe boundsDepth: 2.		tframe initBounds.		TExporter export: tframe asBinary:'http://www.reed.com/TeaLand/spaces/theDungeon.tea'.		].	"sp2 addChild: tframe."	waterTop _ (tframe find:[:frm | frm objectName = '$WaterfallTop'])at:1.	waterfall _ self makeWaterfall: waterTop translation.	waterTop parent addChild: waterfall.	waterTop removeSelf.	waterBottom _ (tframe find:[:frm | frm objectName = '$WaterfallBottom'])at:1.	waterfall _ self makeWaterfallBottom: waterBottom translation.	waterBottom parent addChild: waterfall.	waterBottom removeSelf.	TQuadTree new initializeWithSpace: sp2 frame: tframe."This is to test the performance of the ray test code.	100 timesRepeat:[ |swarm |		swarm _ TSwarm new.		swarm translationX: 20 atRandom -10 y: -30 z: 20 atRandom - 170.		sp2 addChild: swarm.].""	self makeCharacters:sp2 at: (-6@-36.5@-71)."	self makeSnapshot: sp2 angle: -11 translation:(B3DVector3 x:16.52985000610352 y:-32.47652435302734 z:-103.7088470458984).! !!TeapotMorph methodsFor: 'toys' stamp: 'ar 9/30/2004 16:07'!makeEquip: sp	| win sp2 p1 p2 lt flr tframe pic |	p1 _ TPortal new.	lt _ TLight new.	lt rotationAroundZ: 120.	lt translationX: 10 y: 0 z:10.	sp2 _ TSpace new.	sp2 addChild: lt.	sp2 color:(Color r: 1.0 g: 1.0 b: 1.0).	sp2 url: 'http://www.reed.com/TeaLand/spaces/equipment.tea'.	flr _ self makeFloor: sp2 fileName: 'graph128.bmp'.	flr translationX: 0 y: -3.0 z: -3.0.	sp2 addChild: flr.	win _ TWindow new.	win translationX: -12 y: 0.0 z: -2.0.	win contents: p1.	win startScript: #onOpenProtectedContents when:{win. #openContents}.	sp addChild: win.	pic _ TTexture new initializeWithFileName: 'dpr.bmp'				mipmap: true				shrinkFit: false.	win rectFront: pic.	win closeContents.	p2 _ TPortal new.	win _ TWindow new.	win rotationAroundY: 225.	win translationX: 40.0 y:2.0 z: 40.0.	win contents: p2.	sp2 addChild: win.	p1 linkPortal: p2.	tframe _ self loadURL: 'http://www.reed.com/TeaLand/spaces/theSuburban.tea'.	tframe ifNil:[		tframe _ (TLoad3DSMax new initializeWithFileName: (FileDirectory pathFrom: {FileDirectory default pathName. 'Content'. 'Suburban'. 'Suburban.ase'}) scale: 0.00075) frame.		tframe translationX: 0.0 y: 1.0 z:0.0.	"	tframe rotationAroundX: -90."		tframe boundsDepth: 2.		tframe initBounds.		TExporter export: tframe asBinary:'http://www.reed.com/TeaLand/spaces/theSuburban.tea'.		].	sp2 addChild: tframe.! !!TeapotMorph methodsFor: 'toys' stamp: 'ar 10/2/2004 20:25'!makeFlag: sp	| flg flag pole teapot spinner |	flg _ TTexture				new initializeWithFileName: 'flag.bmp'				mipmap: true				shrinkFit: false.	teapot _ TTeapot new.	teapot texture: txtr.	teapot material: nil.	teapot materialAlpha: nil.	teapot scale: 0.2.	spinner _ TSpinner new.	spinner translationX: 12.0 y: 4.8 z:8.0.	spinner matNorm: nil.	spinner matDown: nil.	spinner matOver: nil.	spinner contents: teapot.	sp addChild: spinner.	flag _ TFlag new.	flag texture: flg.	flag translationX: 12.0 y:4.5 z: 8.0.	pole _ TCylinder new.	pole topRadius: 0.03.	pole baseRadius: 0.06.	pole height:6.0.	pole translationX: 12.0 y:-1.25 z: 8.0.	sp addChild: pole.	sp addChild: flag.	^ flag.! !!TeapotMorph methodsFor: 'toys' stamp: 'ar 9/30/2004 16:07'!makeFloor: sp fileName: txtrName	| stone txt |	txt _ TTexture				new initializeWithFileName: txtrName				mipmap: true				shrinkFit: false.	txt uvScale: 16.0@16.0.	stone _ TCube new.	stone extentX:80 y:0.5 z: 80.	stone translationX: 0 y: -4.0 z: 0.0.	stone texture: txt.	stone objectName: 'floor'.	sp addChild: stone.	^ stone.! !!TeapotMorph methodsFor: 'toys' stamp: 'ar 9/30/2004 12:51'!makeFloor: sp texture: texture	| stone |	texture uvScale: 16.0@16.0.	stone _ TCube new.	stone scaleX:80 y:0.5 z: 80.	stone translationX: 0 y: -4.0 z: 0.0.	stone texture: texture.	sp addChild: stone.! !!TeapotMorph methodsFor: 'toys' stamp: 'ar 9/30/2004 16:07'!makeGM: sp	| win sp2 p1 p2 lt flr tframe pic |	p1 _ TPortal new.	lt _ TLight new.	lt rotationAroundZ: 120.	lt translationX: 10 y: 0 z:10.	sp2 _ TSpace new.	sp2 addChild: lt.	sp2 color:(Color r: 1.0 g: 1.0 b: 1.0).	sp2 url: 'http://www.reed.com/TeaLand/spaces/equipment.tea'.	flr _ self makeFloor: sp2 fileName: 'graph128.bmp'.	flr translationX: 0 y: -3.0 z: -3.0.	sp2 addChild: flr.	win _ TWindow new.	win translationX: -12 y: 0.0 z: -2.0.	win contents: p1.	sp addChild: win.	pic _ TTexture new initializeWithFileName: 'gmlogo.bmp'				mipmap: true				shrinkFit: false.	win rectFront: pic.	win closeContents.	p2 _ TPortal new.	win _ TWindow new.	win rotationAroundY: 225.	win translationX: 40.0 y:2.0 z: 40.0.	win contents: p2.	sp2 addChild: win.	p1 linkPortal: p2.	tframe _ self loadURL: 'http://www.reed.com/TeaLand/spaces/theSuburban.tea'.	tframe ifNil:[		tframe _ (TLoad3DSMax new initializeWithFileName: (FileDirectory pathFrom: {FileDirectory default pathName. 'Content'. 'Suburban'. 'Suburban.ase'}) scale: 0.00075) frame.		tframe translationX: 0.0 y: 1.0 z:0.0.	"	tframe rotationAroundX: -90."		tframe boundsDepth: 2.		tframe initBounds.		TExporter export: tframe asBinary:'http://www.reed.com/TeaLand/spaces/theSuburban.tea'.		].	sp2 addChild: tframe.! !!TeapotMorph methodsFor: 'toys' stamp: 'ar 9/30/2004 16:07'!makeGallery: sp	| meshes rootObj mat p1 p2 lt sp2 win stone texDict tex pic |	stone _ TTexture new initializeWithFileName: 'stone.bmp'				mipmap: true				shrinkFit: false.	mat _ TMaterial new.	p1 _ TPortal new.	"p1 rotationAroundY: 180."	p1 material: mat.	p2 _ TPortal new.	p2 rotationAroundY: 180.	"p2 translationX: 0.0 y: 0.0 z: 30.0."	p2 material: mat.	lt _ TLight new."	lt materialAlpha: (TMaterial new)."	lt ambientColor: #(0.7 0.7 0.7 1.0) asFloatArray.	lt diffuseColor: #(1.0  1.0  1.0  1.0) asFloatArray.	lt specularColor: #(0.0 0.0 0.0 1.0) asFloatArray.	lt rotationAroundZ: 120.	sp2 _ TSpace new.	sp2 url: 'http://www.reed.com/TeaLand/spaces/gallery.tea'."	sp2 ambientSound: (self loadAmbientSound: 'gallery.mp3')."	sp2 addChild: lt.	sp2 color:  (Color r: 0.613 g: 0.839 b: 1.0).	stone rotationAroundX: -90.	stone translationX: 0 y: -4.0 z: 0.0.	stone uvScale: 32.0@32.0.	stone extent: 180.0@180.0.	sp2 addChild: stone.		win _ TWindow new.	win rotationAroundY: 180.	win translationX: -20 y: 0.0 z: 30.0.	win contents: p1.	pic _ TTexture				new initializeWithFileName: 'GrnChplTwr.bmp'				mipmap: true				shrinkFit: false.	win rectFront: pic.	sp addChild: win.	win closeContents.	win _ TWindow new.	win rotationAroundY: 180.	win translationX: 0 y: 0.0 z: -80.0.	win contents: p2.	sp2 addChild: win.	p1 linkPortal: p2.	rootObj _ self loadURL: 'http://www.reed.com/TeaLand/spaces/theGallery.tea'.	rootObj ifNil:[		texDict := Dictionary new.		#('Wall4Texture512x256.bmp' 'Col1Texture128x512.bmp') do:[:fn|			tex := TTexture new initializeWithFileName: fn mipmap: true shrinkFit: true.			texDict at: fn put: tex].		meshes := (FileStream readOnlyFileNamed: 'gallery3.mesh') fileInObjectAndCode.		rootObj := self makeGallery: sp from: meshes using: texDict.		rootObj localTransform: (B3DMatrix4x4 withScale: 2@2@2).		rootObj translationX: 0 y: -4 z: 0.		TExporter export: rootObj asBinary:'http://www.reed.com/TeaLand/spaces/theGallery.tea'.	].	sp2 addChild: rootObj.	self makeMoving: sp2 to: sp.! !!TeapotMorph methodsFor: 'toys' stamp: 'ar 9/30/2004 12:36'!makeGallery: sp from: spec using: texDict	| myName myTfm myTexture myMesh myChildren mesh child mat tex |	myName := spec first.	myTfm := spec second.	myTexture := spec third.	"Transcript cr; show: myTexture."	myMesh := spec fourth.	myMesh ifNotNil:[		myMesh convertToOneBasedReferences.		myMesh faces reverseDirection.		myMesh flipTexCoordV].	myChildren := spec last.	myMesh ifNil:[		mesh := TGroup new.	] ifNotNil:[		mat _ TMaterial new.		mat ambientColor: #(0.5 0.5 0.5 1) asFloatArray.		mat diffuseColor: #(0.5 0.5 0.5 1) asFloatArray.		tex := texDict at: myTexture ifAbsent:[nil].		tex ifNotNil:[			mat texture: tex.			mat textureMode: GLModulate.		].		mesh := TMesh new 			initializeWithVertices: myMesh vertices 			alias: nil 			norms: myMesh vertexNormals			textureUV: myMesh texCoords			faceGroups: {1. myMesh zeroBasedFaceGroup}			material: mat.		mesh initBounds.	].	mesh objectName: myName.	mesh localTransform: myTfm.	myChildren do:[:childSpec|		child := self makeGallery: sp from: childSpec using: texDict.		mesh addChild: child.	].	^mesh! !!TeapotMorph methodsFor: 'toys' stamp: 'ar 9/30/2004 16:12'!makeHoliday: spc	| sp2 light tframe p1 win pic p2 |	sp2 _ TSpace new.	sp2 color:  (Color				r: 0.2				g: 0.25				b: 0.6).		sp2 url: 'http://www.reed.com/TeaLand/spaces/holiday.tea'."Add a light to the world "	light _ TLight new.	tframe _ TSpinner new.	tframe translationX: -10 y:0.0 z: 0.0.	tframe rotationAroundZ: 120.	tframe matNil.	tframe contents: light.	sp2 addChild: tframe.	self makeFloor: sp2 fileName:'stone.bmp'.	tframe _ TParticle new initializeWithSize: 300.	tframe setVelocityRangeMin:(-1@-1@-1) max:(1@1@1).	tframe setAccelerationRangeMin:(0@-2@0) max:(0@-1@0).	tframe material ambientColor: #(1 1 0.7 1.0) asFloatArray.	tframe material diffuseColor: #(1 1 0.7 1.0) asFloatArray.	tframe setLifetimeRange: (750 to: 1500).	tframe translationX: 0 y: 11 z:-10.	sp2 addChild: tframe.	tframe _ TParticle new initializeWithSize: 350.	tframe translationX: 0 y: 5 z:-10.	sp2 addChild: tframe.	tframe _ TParticle new initializeWithSize: 750.	tframe translationX: 0 y: 3 z:-10.	tframe setPositionRangeMin:(-1@-0.1@-1) max: (1@0.1@1).	sp2 addChild: tframe.	tframe _ TParticle new initializeWithSize: 1000.	tframe translationX: 0 y: 1 z:-10.	tframe setPositionRangeMin:(-2@-0.1@-2) max: (2@0.1@2).	sp2 addChild: tframe.	tframe _ TParticle new initializeWithSize: 1200.	tframe translationX: 0 y: -1 z:-10.	tframe setPositionRangeMin:(-3@-0.1@-3) max: (3@0.1@3).	sp2 addChild: tframe.	tframe _ TParticle new initializeWithSize: 500.	tframe translationX: 0 y: -2 z:-10.	tframe setVelocityRangeMin:(-1.2@7@-1.2) max:(1.2@14@1.2).	tframe material ambientColor: #(0.7 0.6 0.2 1.0) asFloatArray.	tframe material diffuseColor: #(0.7 0.6 0.2 1.0) asFloatArray.	sp2 addChild: tframe.	tframe _ TParticle new initializeWithSize: 2000.	tframe translationX: 0 y: 30 z:0.	tframe setLifetimeRange: (6000 to: 9000).	tframe setVelocityRangeMin:(-1.2@0@-1.2) max:(1.2@0@1.2).	tframe setAccelerationRangeMin:(-0.1@-2@-0.1) max:(0.1@-3@0.1).	tframe setPositionRangeMin:(-50@-0.1@-50) max: (50@0.1@50).	tframe material ambientColor: #(1 1 1 1.0) asFloatArray.	tframe material diffuseColor: #(1 1 1 1.0) asFloatArray.	sp2 addChild: tframe.	p1 _ TPortal new.	win _ TWindow new.	win translationX: -12 y: 0.0 z: -2.0.	win contents: p1.	spc addChild: win.	pic _ TTexture new initializeWithFileName: 'dpr.bmp'				mipmap: true				shrinkFit: false.	win rectFront: pic.	win closeContents.	p2 _ TPortal new.	win _ TWindow new.	win rotationAroundY: 225.	win translationX: 40.0 y:2.0 z: 40.0.	win contents: p2.	sp2 addChild: win.	p1 linkPortal: p2.	^sp2! !!TeapotMorph methodsFor: 'toys' stamp: 'ar 9/30/2004 20:02'!makeKay: sp	| env pic win tframe |	pic _ TTexture				new initializeWithFileName: 'kay3.bmp'				mipmap: true				shrinkFit: false.	env _ TTexture				new initializeWithFileName: 'SkyBoxMLLRT.bmp' 				mipmap: true				shrinkFit: false.	tframe _ TWaves initializeWithSize: 20@20.	tframe texture: pic.	tframe envTexture: env.	win _ TWindow new.	win translationX: 7 y: 0.0 z: -2.0.	win contents: tframe.	sp addChild: win."	pic _ TTexture				new initializeWithFileName: 'dpr.bmp'				mipmap: true				shrinkFit: false.	win _ TWindow new.	win translationX: -12 y: 0.0 z: -2.0.	win contents: pic.	sp addChild: win."! !!TeapotMorph methodsFor: 'toys' stamp: 'ar 9/30/2004 12:54'!makeLazySusan: space	| cb lazy |	lazy _ TLazySusan new.	lazy translationX:12 y:-1.5 z: 8.	space addChild: lazy.	cb _ TCube new.	cb extent: (B3DVector3 x:5 y: 0.5 z: 10).	lazy contents: cb.	cb objectName: 'lazy susan'.! !!TeapotMorph methodsFor: 'toys' stamp: 'ar 10/2/2004 20:25'!makeLight: sp	| light tframe |	light _ TLight new.	tframe _ TSpinner new.	tframe translationX: -10 y:0.0 z: 0.0.	tframe rotationAroundZ: 120.	tframe matNil.	tframe contents: light.	sp addChild: tframe.! !!TeapotMorph methodsFor: 'toys' stamp: 'ar 10/1/2004 08:51'!makeLinkToProject: projName	"import an existing morphic project, creating a window for it in front of the camera"	| win tmorph newWorld |	tmorph _ TMorphic new initializeOpaque: true extent: 512@512.	newWorld _ TMorphMonitor new initializeWithWorld: projName extent: tmorph targetExtent.	newWorld eventsTo: tmorph.		win _ activeCamera avatar makeWindowInFront.	win contents: tmorph.	^ win.! !!TeapotMorph methodsFor: 'toys' stamp: 'ar 9/30/2004 12:54'!makeManual: space	| url pic win |	#(		('Manual/Croquet.html' 0 -0.20 15 0)	) do:[:spec|		url := spec first. "look locally first"		url := FileDirectory pathFrom: {FileDirectory default pathName}, (spec first findTokens: '/').		(FileStream isAFileNamed: url) 			ifTrue:[url := FileDirectory default url, spec first] "local"			ifFalse:[url := 'http://www.reed.com/TeaLand/', spec first].		pic _ self makeWebPage: url extent: 512@512.		win _ TWindow new new.		win translationX: spec second y: spec third z: spec fourth.		win rotationAroundY: spec fifth.		win contents: pic.		space addChild: win.	].! !!TeapotMorph methodsFor: 'toys' stamp: 'ar 9/30/2004 16:13'!makeMars: sp	| win sp2 p1 p2 lt tframe pic rover |	p1 _ TPortal new.	lt _ TLight new.	lt rotationAroundZ: 120.	lt translationX: 10 y: 0 z:10.	sp2 _ TSpace new.	sp2 addChild: lt.	sp2 color:(Color r: 0.6 g: 0.5 b: 0.2).	sp2 url: 'http://www.reed.com/TeaLand/spaces/redplanet.tea'.	win _ TWindow new.	win translationX: -20 y: 0.0 z: -2.0.	win contents: p1.	sp addChild: win.	pic _ TTexture new initializeWithFileName: 'mars2.bmp'				mipmap: true				shrinkFit: false.	win rectFront: pic.	win closeContents.	p2 _ TPortal new.	win _ TWindow new.	win rotationAroundY: 225.	win translationX: 40.0 y:-17.0 z: 40.0.	win contents: p2.	sp2 addChild: win.	p1 linkPortal: p2.	rover _ TRover new.	rover translationX:10 y:-19.11 z:0.	sp2 addChild: rover.	tframe _ self loadURL: 'http://www.reed.com/TeaLand/spaces/mars.tea'.	tframe ifNil:[		tframe _ (TLoad3DSMax new initializeWithFileName: (FileDirectory pathFrom: {FileDirectory default pathName. 'Content'. 'mars'. 'masterTerrain.ase'}) scale: 0.05) frame."		tframe rotationAroundX: -90."		tframe boundsDepth: 2.		tframe initBounds.		TExporter export: tframe asBinary:'http://www.reed.com/TeaLand/spaces/mars.tea'.		].	tframe translationX: 0.0 y: 22.0 z:0.0.	TQuadTree new initializeWithSpace: sp2 frame: tframe. 	self makeSnapshot: sp2 angle: 15 translation:(B3DVector3 x:21.26738166809082 y:-17.4773292541504 z:38.1824035644531).! !!TeapotMorph methodsFor: 'toys' stamp: 'ar 9/30/2004 12:54'!makeMirror2: sp	| win prtl |	prtl _ TPortal new.	win _ TWindow new.	win translationX: 0 y:0 z: 8.	win contents: prtl.	sp addChild: win.! !!TeapotMorph methodsFor: 'toys' stamp: 'ar 9/30/2004 12:54'!makeMirror: sp	| win prtl |	prtl _ TPortal new.	win _ TWindow new.	win translationX: -1 y:0 z: -8.	win contents: prtl.	sp addChild: win.! !!TeapotMorph methodsFor: 'toys' stamp: 'ar 9/30/2004 16:04'!makeMoving: sp to: spX	| flr win win2 sp2 p1 p2 lt mat pic tframe escalator  |	mat _ TMaterial new.	p1 _ TPortal new.	p1 material: mat.	p2 _ TPortal new."	p2 rotationAroundY: 180.	p2 translationX: 0.0 y:0.0 z: 3.0.	p2 material: mat."	lt _ TLight new."	lt materialAlpha: (TMaterial new)."	lt ambientColor: #(0.5 0.6 0.7 1.0) asFloatArray.	lt diffuseColor: #(1.0  1.5  1.0  1.0) asFloatArray.	lt specularColor: #(0.0 0.0 0.0 1.0) asFloatArray.	lt rotationAroundZ: 120.	sp2 _ TSpace new.	sp2 url: 'http://www.reed.com/TeaLand/spaces/flag.tea'."	sp2 ambientSound: (self loadAmbientSound: 'flag.mp3')."	sp2 addChild: lt.	"sp2 color:(Color r: 0.0 g: 0.05 b: 0.03).	sp2 color:(Color r: 0.0 g: 0.15 b: 0.09).	sp2 fogOn: true.	sp2 fogDensity: 0.015.	sp2 fogStart: 40.0.	sp2 fogEnd: 200.0."	flr _ self makeFloor: sp2 fileName: 'Stone.bmp'.	flr translationX: 0 y: -4.0 z: -3.0.	sp2 addChild: flr.		mat _ TMaterial new.	mat ambientColor: #(0.5 0.5 0.5 1.0) asFloatArray.	mat diffuseColor: #(0.5 0.5 0.5 1.0) asFloatArray.	pic _ TTexture				new initializeWithFileName: 'GrnChplIntDblDrs.bmp'				mipmap: true				shrinkFit: false.	win _ TWindow new.	win translationX: -10 y: 0.0 z: -2.0.	win contents: p1.	win rectFront: pic.	win closeContents.	sp addChild: win.	win2 _ TWindow new.	win2 translationX: 5 y: 0.0 z: 2.0.	win2 rotationAroundY: 55.	win2 contents: p2.	sp2 addChild: win2."	sp2 addChild: p2."	p1 linkPortal: p2.	self makeFlag: sp2.	tframe _ TSkyBox new initializeWithFileName: 'CA'."	glx activeCamera attachment: tframe."	sp2 addChild: tframe.		self makeLazySusan: sp2.	escalator _ TEscalator new initializeWithTreads: 20.	escalator translationX:-10 y:-4 z:0.	sp2 addChild: escalator.		p1 _ TPortal new.	p1 translationX: -10 y: -4 + (20*0.4)+1.4 z:(19*0.4)-0.5.	p1 rotationAroundY:180. 	p1 extent: (Point x: 3 y: 5). 	sp2 addChild: p1.	win _TWindow new.	p2 _ TPortal new.	win contents: p2.	win translationX: 8 y: 0 z:17.	p1 linkPortal: p2.	spX addChild: win.	self makeSnapshot: sp2 angle: 140 translation:(B3DVector3 x:18.49281883239746 y:0.25 z:-12.2568531036377).! !!TeapotMorph methodsFor: 'toys' stamp: 'ar 9/30/2004 14:18'!makeNewSpace	| sp2 light tframe p1 win p2 |	sp2 _ TSpace new.	sp2 color:  (Color				r: 0.2				g: 0.25				b: 0.6).		sp2 url: 'http://www.reed.com/TeaLand/spaces/newSpace.tea'."Add a light to the world "	light _ TLight new.	tframe _ TSpinner new.	tframe translationX: -10 y:0.0 z: 0.0.	tframe rotationAroundZ: 120.	tframe matNil.	tframe contents: light.	sp2 addChild: tframe.	self makeFloor: sp2 fileName:'stone.bmp'.	p1 _ TPortal new.	win _ TWindow new.	win translationX: 0 y: 0.0 z: -3.0.	win contents: p1.	activeCamera addChild: win.	win releaseWindow.	p2 _ TPortal new.	win _ TWindow new.	win rotationAroundY: 225.	win translationX: 40.0 y:2.0 z: 40.0.	win contents: p2.	sp2 addChild: win.	p1 linkPortal: p2.	^sp2! !!TeapotMorph methodsFor: 'toys' stamp: 'ar 10/4/2004 15:41'!makePooh: sp	| win teaWorld player tm |	tm _ TMorphic new initializeOpaque: false extent: 512@256.	teaWorld _ TMorphMonitor new initializeWithWorld: nil extent: 512@256.	teaWorld eventsTo: tm.	[player _ (FlashMorphReader on: (FileStream readOnlyFileNamed: (FileDirectory pathFrom: {FileDirectory default pathName. 'content'. 'poohalone.swf'}))) processFile.	player useTimeSync: false.	player color: Color transparent.	player startPlaying.	player lock.	teaWorld world addMorphCentered: player.	] on: FileDoesNotExistException do:[:ex| ex return].	teaWorld world color: Color transparent.	win _ TWindow new.	win translationX: 31 y: 0.0 z: 28.0.	win rotationAroundY: -90.	win contents: tm.	win closeContents.	sp addChild: win.! !!TeapotMorph methodsFor: 'toys' stamp: 'ar 3/7/2003 15:03'!makePoohMeshFrom: aForm	| list pts subdivision mask |	mask := Form extent: aForm extent*2 depth: 1.	(WarpBlt toForm: mask)		sourceForm: aForm destRect: mask boundingBox;		combinationRule: Form over;		cellSize: 1;		colorMap: (Color maskingMap: aForm depth);		warpBits.	subdivision := PoohSubdivision withSize: (mask boundingBox).	list := mask traceOutlines.	list := list collect:[:poly|		poly collect:[:loop|			pts _ StrokeSimplifier new.			loop do:[:pt| pts add: pt].			pts closeStroke.			pts := pts finalStroke.			pts := StrokeSimplifier smoothen: pts length: 10.			pts := LineIntersections regularize: pts.			pts do:[:pt| subdivision insertPoint: pt].			pts]].	list := list collect:[:poly|		poly collect:[:loop| subdivision constraintOutline: loop].	].	list do:[:poly|		poly keysAndValuesDo:[:index :loop|			subdivision markExteriorEdges: (index = 1) in: loop.		].	].	^subdivision build3DObject: false.! !!TeapotMorph methodsFor: 'toys' stamp: 'ar 10/4/2004 15:55'!makePoohObjectFrom: aForm player: aPlayer rotateBy: rot replaceOldCostume: aBoolean	| aSpace pts bbForm tex mat subdivision b3dMesh mesh pos scale tfm |	"Convert the form"	bbForm := Form extent: aForm extent asSmallerPowerOfTwo depth: 32.	aForm displayScaledOn: bbForm in: (bbForm boundingBox insetBy: 1).	"Smear the borders of the texture a bit to prevent problems in texture mapping"	bbForm smearFill: 10. "pixels - less is faster but more is safer"	aSpace := activeCamera root.	"Create the texture"	tex := TTexture meta new initializeWithForm: bbForm mipmap: true shrinkFit: true extension: #colorKeyZero.	"The material"	mat _ TMaterial meta new.	mat meta ambientColor: #(1 1 1 1) asFloatArray.	mat meta diffuseColor: #(1 1 1 1) asFloatArray.	mat meta texture: tex.	mat meta textureMode: GLModulate.	"The b3d mesh"	true ifTrue:[		b3dMesh := self makePoohMeshFrom: aForm.		scale := 0.01.	] ifFalse:[		pts _ StrokeSimplifier new.		aForm traceOutline: Color transparent do:[:aPoint| pts add: aPoint].		pts closeStroke.		pts := pts finalStroke.		pts := StrokeSimplifier smoothen: pts length: 10.		pts := LineIntersections regularize: pts.		subdivision _ PoohSubdivision constraintOutline: pts.		b3dMesh _ subdivision build3DObject: false. "single sided textures"		scale := 0.02.	].	tfm := (B3DRotation axis: 1@0@0 angle: 180) asMatrix4x4.	tfm := tfm composeWith: (B3DRotation axis: 0@1@0 angle: rot) asMatrix4x4.	tfm := tfm composeWith: (B3DMatrix4x4 withScale: scale@scale@scale).	tfm := tfm composeWith: (B3DMatrix4x4 withOffset: (aForm width * -0.5) @ (aForm height * -0.5) @ 0).	b3dMesh transformBy: tfm.	"The TMesh"	mesh := TMesh meta new initializeWithVertices: b3dMesh vertices 		alias: nil 		norms: b3dMesh vertexNormals		textureUV: b3dMesh texCoords		faceGroups: {1. b3dMesh zeroBasedFaceGroup}		material: mat.	mesh meta solid: false.	mesh meta initBounds.	"Position it"	pos := activeCamera avatar translation - (activeCamera avatar lookAt * 10).	mesh meta translation: pos.	mesh meta rotationAroundY: activeCamera avatar yaw + rot.	aSpace meta addChild: mesh.	"mesh startScript:[mesh turnTo: activeCamera].""self tweakWorld ifNotNil:[	mesh meta replaceUserCostume: mesh sketch: aForm.	aSpace player signal: #created with: mesh player.]."! !!TeapotMorph methodsFor: 'toys' stamp: 'das 6/23/2003 02:10'!makePopUp: sp" DeprecatedNeed to remove this as soon as I know that it doesn't hurt anything."! !!TeapotMorph methodsFor: 'toys' stamp: 'ar 10/1/2004 08:37'!makePortal: aPortal	"make a portal in front of me, linking to another portal"	| win |	win _ activeCamera avatar makeWindowInFront.	win contents: (TPortal new linkPortal: aPortal).	^ win.! !!TeapotMorph methodsFor: 'toys' stamp: 'ar 10/1/2004 08:43'!makeProjectLink: sp	| win teaWorld tm |	tm _ TMorphic new initializeOpaque: true extent: 1024@768.	teaWorld _ TMorphMonitor new initializeWithWorld: 'Building with Squeak' extent: 1024@768.	teaWorld eventsTo: tm.	win _ TWindow new.	win translationX: 8 y: 0.0 z: -20.0.	"win rotationAroundY: 135.0."	win contents: tm.	win closeContents.	sp addChild: win.	^ win.! !!TeapotMorph methodsFor: 'toys' stamp: 'ar 10/2/2004 20:24'!makePyramid: sp	| pyr matNorm spinner |	pyr _ TSierpinski new.	matNorm _ TMaterial new.	matNorm ambientColor: #(0.5 0.7 0.7 0.5) asFloatArray.	matNorm diffuseColor: #(0.5 0.7 0.7 0.5) asFloatArray.	pyr material: matNorm.	pyr scale: 5.0.	pyr depth: 1.	spinner _ TSpinner new.	spinner translationX: 12 y:0 z: 12.	spinner contents: pyr.	sp addChild: spinner.! !!TeapotMorph methodsFor: 'toys' stamp: 'ar 10/1/2004 12:13'!makeSlime: sp	| p1 p2 pic win win2 lt sp2 |	p1 _ TPortal new.	p2 _ TPortal new.	p1 linkPortal: p2.	lt _ TLight new."	lt materialAlpha: (TMaterial new)."	lt ambientColor: #(0.5 0.6 0.7 1.0) asFloatArray.	lt diffuseColor: #(1.0  1.5  1.0  1.0) asFloatArray.	lt specularColor: #(0.0 0.0 0.0 1.0) asFloatArray.	lt translationX: 20 y: 0.0 z: 20.0.	lt rotationAroundZ: 120.	sp2 _ TSpace new.	sp2 url: 'http://www.reed.com/TeaLand/spaces/slimemold.tea'.	sp2 addChild: lt.	sp2 color:(Color r: 0.8 g: 0.8 b: 1.0)."	teaWorld _ TMorphic new initialize: glx world: nil opaque: false extent: 64@64.	slime _ StarSqueakSlimeMold new initialize.	slime startRunning.	teaWorld world addMorphCentered: slime.	teaWorld world color: Color transparent.	man _ TManifold initializeWithContents: slime.	man texture: teaWorld.	man translationX: 0 y: -3.0 z: 0.	sp2 addChild: man."	self makeSpreadSheet: sp2.	self makeFloor: sp2 fileName: 'graph128.bmp'.	pic _ TTexture				new initializeWithFileName: 'slime.bmp'				mipmap: true				shrinkFit: false.	win _ TWindow new.	win translationX: 20 y: 0.0 z: 10.0.	win contents: p1.	win rectFront: pic.	win closeContents.	sp addChild: win.	win2 _ TWindow new.	win2 rotationAroundY: 180.	win2 translationX: 0 y: 0.0 z: 40.0.	win2 contents: p2.	sp2 addChild: win2.	self makeSnapshot: sp2 angle: -40 translation:(B3DVector3 x:-6.16044044494629 y:0.25 z:8.65220928192139).! !!TeapotMorph methodsFor: 'toys' stamp: 'ar 10/1/2004 13:08'!makeSnapshot: space angle: yval translation: t	| trans |	trans _ B3DMatrix4x4 identity.	trans rotationAroundY: yval.	trans translation: t.	dock addSnapshotItem:  (TSnapshot new initializeWithFrame: space transform:trans).! !!TeapotMorph methodsFor: 'toys' stamp: 'ar 9/30/2004 16:07'!makeSolar: spc	| sp2 light tframe p1 win pic p2 |	sp2 _ TSpace new.	sp2 color:  (Color				r: 0.0				g: 0.0				b: 0.0).		sp2 url: 'http://www.reed.com/TeaLand/spaces/holiday.tea'."Add a light to the world "	light _ TLight new.	tframe _ TSpinner new.	tframe translationX: -10 y:0.0 z: 0.0.	tframe rotationAroundZ: 90.	tframe matNil.	tframe contents: light.	sp2 addChild: tframe.	tframe _ TSolar new.	sp2 addChild: tframe.	p1 _ TPortal new.	win _ TWindow new.	win translationX: -12 y: 0.0 z: -2.0.	win contents: p1.	spc addChild: win.	pic _ TTexture				new initializeWithFileName: 'dpr.bmp'				mipmap: true				shrinkFit: false.	win rectFront: pic.	win closeContents.	p2 _ TPortal new.	win _ TWindow new.	win rotationAroundY: 225.	win translationX: 40.0 y:30.0 z: 40.0.	win contents: p2.	sp2 addChild: win.	p1 linkPortal: p2.	^sp2! !!TeapotMorph methodsFor: 'toys' stamp: 'ar 9/30/2004 16:15'!makeSomeFish: sp	| mesh pic1 pic2 pic3 rnd fish tMesh mat avatarList |	tMesh  := self loadURL: 'http://www.reed.com/TeaLand/spaces/theFish.tea'.	tMesh ifNil:[		mesh _ (FileStream readOnlyFileNamed:(FileDirectory pathFrom: {FileDirectory default pathName. 'Content'. 'Underwater'. 'fish.mesh'})) fileInObjectAndCode.		mesh reverseFaceDirection.		mesh transformBy: ((B3DRotation angle: 180 axis: 0@1@0) asMatrix4x4 composedWithLocal: (B3DMatrix4x4 withScale: (1@1@1))).		mat _ TMaterial new.		mat ambientColor: #(1 1 1 1) asFloatArray.		mat diffuseColor: #(1 1 1 1) asFloatArray.		tMesh := TMesh new initializeWithVertices: mesh vertices 			alias: nil 			norms: mesh vertexNormals			textureUV: mesh texCoords			faceGroups: {1. mesh zeroBasedFaceGroup}			material: mat.		tMesh initBounds.		TExporter export: tMesh asBinary:'http://www.reed.com/TeaLand/spaces/theFish.tea'.	].	pic1 _ TTexture new initializeWithFileName: (FileDirectory pathFrom: #('Content' 'Underwater' 'OpalEye.jpg')) mipmap: true shrinkFit: false.	pic2 _ TTexture new initializeWithFileName: (FileDirectory pathFrom: #('Content' 'Underwater' 'RockFish.jpg')) mipmap: true shrinkFit: false.	pic3 _ TTexture new initializeWithFileName: (FileDirectory pathFrom: #('Content' 'Underwater' 'Seniorita.jpg')) mipmap: true shrinkFit: false.	avatarList := OrderedCollection new.	rnd := Random seed: 123456.	{pic1. pic2. pic3} do:[:tex|		1 to: 4 do:[:i|			fish  := self loadURL: 'http://www.reed.com/TeaLand/spaces/theFish.tea' reuseExisting: false.			fish scale: 3.			fish solid: false.			fish objectName: 'fish'.			fish translationX: rnd next * 20 - 10 y: rnd next z: rnd next * 20 - 10.			fish material texture: tex.			fish material textureMode: GLModulate.			sp addChild: fish.			"TFollowVisitor attachTo: fish."		].	].	avatarList := {pic1. pic2. pic3} collect:[:tex|		fish  := self loadURL: 'http://www.reed.com/TeaLand/spaces/theFish.tea' reuseExisting: false.		fish solid: false.		fish scale: 3.		fish objectName: 'fish'.		fish material texture: tex.		fish material textureMode: GLModulate.		fish].	self startScript: #chooseAvatar:for: 		withArguments: {avatarList} 		when:{sp. #objectEnter}.! !!TeapotMorph methodsFor: 'toys' stamp: 'ar 10/1/2004 12:31'!makeSpreadSheet: sp	| teaWorld win tm |	tm _ TSpreadSheetTxtr new.	teaWorld _ TSpreadSheet new.	teaWorld eventsTo: tm.	win _ TWindow new.	win translation: (0@0.25@2).	win contents: tm.	sp addChild: win.! !!TeapotMorph methodsFor: 'toys' stamp: 'ar 10/1/2004 08:44'!makeStartupLink: sp	| win teaWorld tm |	tm _ TMorphic new initializeOpaque: true extent: 1024@768.	teaWorld _ TMorphMonitor new initializeWithWorld: 'Macintosh' extent: 1024@768.	teaWorld eventsTo: tm.	win _ TWindow new.	win translationX: 0 y:0.25 z: 24.92.	win contents: tm.	"win switchContents."	sp addChild: win."	self makeMovie: win."  "make movie attached to window"! !!TeapotMorph methodsFor: 'toys' stamp: 'ar 9/30/2004 16:07'!makeStoneFloor: sp	| stone txt |	txt _ TTexture				new initializeWithFileName: 'stone.bmp'				mipmap: true				shrinkFit: false.	txt uvScale: 16.0@16.0.	stone _ TCube new.	stone scaleX:80 y:0.5 z: 80.	stone translationX: 0 y: -4.0 z: 0.0.	stone texture: txt.	sp addChild: stone.! !!TeapotMorph methodsFor: 'toys' stamp: 'ar 9/30/2004 12:58'!makeTracker: sp	| tracker |	tracker := TSelectionTracker new.	sp addChild: tracker.! !!TeapotMorph methodsFor: 'toys' stamp: 'ar 9/30/2004 16:07'!makeUnderwater2: sp	| flr win sp2 p1 p2 lt mat pic |		mat _ TMaterial new.	p1 _ TPortal new.	p1 material: mat.	p2 _ TPortal new.	p2 rotationAroundY: 180.	p2 translationX: 0.0 y:0.0 z: 3.0.	p2 material: mat.	lt _ TLight new."	lt materialAlpha: (TMaterial new)."	lt ambientColor: #(0.65 0.75 0.85 1.0) asFloatArray.	lt diffuseColor: #(1.0  1.5  1.0  1.0) asFloatArray.	lt specularColor: #(0.0 0.0 0.0 1.0) asFloatArray.	lt rotationAroundZ: 120.	lt translationX: 0 y: 1 z: 0.	sp2 _ TCausticSpace new.	sp2 url: 'http://www.reed.com/TeaLand/spaces/underwater.tea'."	sp2 ambientSound: (self loadAmbientSound: 'underwater.mp3')."	sp2 addChild: lt.	sp2 color:(Color r: 0.1 g: 0.3 b: 0.2).	sp2 fogOn: true.	sp2 fogDensity: 0.025.	sp2 fogStart: 40.0.	sp2 fogEnd: 200.0.	flr _ self makeFloor: sp2 fileName: 'floor.bmp'.	flr disableCaching."	flr rotationAroundX: -90."	flr translationX: 0 y: -4.0 z: -3.0."	flr materialAlpha: (TMaterial new).	flr textureAlpha: nil."	sp2 addChild: flr.		win _ TWindow new.	win translationX: -5 y: 0.0 z: -2.0.	win contents: p1.	pic _ TTexture				new initializeWithFileName: 'andreas.bmp'				mipmap: true				shrinkFit: false.	win rectFront: pic.	sp addChild: win.	sp2 addChild: p2.	p1 linkPortal: p2."	self makeWaveDemo: sp2."	self makeWindows: sp2.	self makeUnderwaterSharks: sp2.	win closeContents.! !!TeapotMorph methodsFor: 'toys' stamp: 'ar 10/2/2004 20:25'!makeUnderwater3: sp	| sp2 p1 p2 lt mat floorMesh win pic tMesh url cc |	mat _ TMaterial new.	p1 _ TPortal new.	p1 material: mat.	p2 _ TPortal new.	p2 material: mat.	lt _ TLight new.	"lt materialAlpha: (TMaterial new)."	lt ambientColor: #(0.5 0.5 0.5 1.0) asFloatArray.	lt diffuseColor: #(1.0  1.0  1.0  1.0) asFloatArray.	lt specularColor: #(0.0 0.0 0.0 1.0) asFloatArray.	lt rotationAroundZ: 220.	lt translationX: 0 y: 3 z: -15.	cc := Color r: 0.0 g: 0.45 b: 0.51.	"cc := Color r: 0.1 g: 0.3 b: 0.2."	sp2 _ TCausticSpace new.	"sp2 _ TSpace new."	sp2 url: 'http://www.reed.com/TeaLand/spaces/underwater.tea'."	sp2 ambientSound: (self loadAmbientSound: 'underwater.mp3')."	sp2 addChild: lt.	sp2 color: cc.	sp2 fogOn: true.	sp2 fogDensity: 0.025.	sp2 fogStart: 40.0.	sp2 fogEnd: 200.0.	tMesh  := self loadURL: 'http://www.reed.com/TeaLand/spaces/theGroundShape.tea'.	tMesh ifNil:[		floorMesh _ (FileStream readOnlyFileNamed: (FileDirectory pathFrom: {FileDirectory default pathName. 'Content'. 'Underwater'. 'topo.mesh'})) fileInObjectAndCode.		floorMesh faces reverseDirection.		"floorMesh transformBy: (B3DMatrix4x4 withScale: (0.01@0.01@0.01))."		pic := TTexture new initializeWithFileName: (FileDirectory pathFrom: {FileDirectory default pathName. 'Content'. 'Underwater'. 'Waves1.jpg'}).		mat _ TMaterial new.		mat ambientColor: #(0.2 0.4 0.3 1) asFloatArray.		mat diffuseColor: #(0.2 0.4 0.3 1) asFloatArray.		mat texture: pic.		mat textureMode: GLModulate.		tMesh := TMesh new initializeWithVertices: floorMesh vertices 			alias: nil 			norms: floorMesh vertexNormals			textureUV: floorMesh texCoords			faceGroups: {1. floorMesh zeroBasedFaceGroup}			material: mat.		"texList _ (1 to: 32) collect:[:i|			TTexture new initializeWithFileName: (FileDirectory pathFrom: {'Content'. 'Underwater'. 'Waves', i printString, '.jpg'}).		].		floorMesh attachBehavior: (TAnimateTextures new textureList: texList)."		tMesh initBounds.		TExporter export: tMesh asBinary:'http://www.reed.com/TeaLand/spaces/theGroundShape.tea'.	].	tMesh solid: true.	tMesh translationX: 0 y: -76 z: 0.	tMesh material ambientColor: #(1 1 1 1) asFloatArray.	tMesh material diffuseColor: #(1 1 1 1) asFloatArray.	sp2 addChild: tMesh.	self makeSomeFish: sp2.	"self makePooh: sp2."false ifTrue:[	#(		('tutorials/embedded/fishScript/fishScript.html' -10 1 -22 30)		('tutorials/embedded/fishPaint/fishPaint.html' 10 1 -22 -30)	) do:[:spec|		url := spec first. "look locally first"		url := FileDirectory pathFrom: {FileDirectory default pathName}, (spec first findTokens: '/').		(FileStream isAFileNamed: url) 			ifTrue:[url := FileDirectory default url, spec first] "local"			ifFalse:[url := 'http://www.reed.com/TeaLand/', spec first].		pic _ self makeWebPage: url extent: 512@256.		win _ TWindow new new.		win translationX: spec second y: spec third z: spec fourth.		win rotationAroundY: spec fifth.		win contents: pic.		sp2 addChild: win.	].].	"self makeUnderwaterSharks: sp2."	"self makeShark: sp2.	self makeSomeFish: sp2."	win _ TWindow new.	win translationX: -5 y: 0.0 z: -2.0.	win contents: p1.	pic _ TTexture new initializeWithFileName: 'andreas.bmp'				mipmap: true				shrinkFit: false.	win rectFront: pic.	win closeContents.	sp addChild: win.	win _ TWindow new.	win rotationAroundY: 180.	win translationX: 0.0 y:0.0 z: 3.0.	win contents: p2.	sp2 addChild: win.	p1 linkPortal: p2.! !!TeapotMorph methodsFor: 'toys' stamp: 'ar 9/30/2004 16:08'!makeUnderwater: sp	| flr win sp2 p1 p2 lt mat spinner teapot |	flr _ TTexture				new initializeWithFileName: 'floor.bmp'				mipmap: true				shrinkFit: false.	mat _ TMaterial new.	p1 _ TPortal new.	p1 material: mat.	p2 _ TPortal new.	p2 rotationAroundY: 180.	p2 translationX: 0.0 y:0.0 z: 3.0.	p2 material: mat.	lt _ TLight new."	lt materialAlpha: (TMaterial new)."	lt ambientColor: #(0.5 0.6 0.7 1.0) asFloatArray.	lt diffuseColor: #(1.0  1.5  1.0  1.0) asFloatArray.	lt specularColor: #(0.0 0.0 0.0 1.0) asFloatArray.	lt rotationAroundZ: 120.	sp2 _ TCausticSpace new.	sp2 addChild: lt.	"sp2 color:(Color r: 0.0 g: 0.05 b: 0.03)."	sp2 color:(Color r: 0.0 g: 0.15 b: 0.09).	sp2 fogOn: true.	sp2 fogDensity: 0.015.	sp2 fogStart: 40.0.	sp2 fogEnd: 200.0.	flr rotationAroundX: -90.	flr translationX: 0 y: -2.0 z: -3.0.	flr uvScale: 8.0@8.0.	flr extent: 40.0@40.0.	flr materialAlpha: (TMaterial new).	flr textureAlpha: nil.	sp2 addChild: flr.		teapot _ TTeapot new.	teapot texture: txtr.	teapot textureAlpha: nil.	teapot materialAlpha: (TMaterial new).	teapot scale: 1.2.		mat _ TMaterial new.	mat ambientColor: #(0.5 0.5 0.5 1.0) asFloatArray.	mat diffuseColor: #(0.5 0.5 0.5 1.0) asFloatArray.	spinner _ TSpinner new.	spinner matNorm: nil.	spinner matDown: nil.	spinner matOver: nil.	spinner translationX: 0.0 y: -1.0 z:0.0.	spinner contents: teapot.	sp2 addChild: spinner.		"teapot translationX: 0.0 y: -1.0 z:0.0.	sp2 addChild: teapot."		win _ TWindow new.	win translationX: -5 y: 0.0 z: -2.0.	win contents: p1.	sp addChild: win.	sp2 addChild: p2.	p1 linkPortal: p2.! !!TeapotMorph methodsFor: 'toys' stamp: 'ar 10/2/2004 20:26'!makeUnderwaterSharks: sp	| mesh pic mat tMesh win |	tMesh  := self loadURL: 'http://www.reed.com/TeaLand/spaces/theShark.tea'.	tMesh ifNil:[		mesh _ (FileStream readOnlyFileNamed:'shark.mesh') fileInObjectAndCode.		mesh convertToOneBasedReferences.		mesh transformBy: (B3DMatrix4x4 withScale: (0.01@0.01@0.01)).		pic _ TTexture new initializeWithFileName: 'shark.jpg' mipmap: true shrinkFit: false.		mat _ TMaterial new.		mat ambientColor: #(1 1 1 1) asFloatArray.		mat diffuseColor: #(1 1 1 1) asFloatArray.		mat texture: pic.		mat textureMode: GLModulate.		tMesh := TMesh new initializeWithVertices: mesh vertices 			alias: nil 			norms: mesh vertexNormals			textureUV: mesh texCoords			faceGroups: {1. mesh zeroBasedFaceGroup}			material: mat.		tMesh initBounds.		TExporter export: tMesh asBinary:'http://www.reed.com/TeaLand/spaces/theShark.tea'.	].	{	-10@-0.5@-10.		-10@-0.5@10.		 10@-0.5@10.		 10@-0.5@-10	} do:[:trans|		tMesh  := self loadURL: 'http://www.reed.com/TeaLand/spaces/theShark.tea' reuseExisting: false.		self enableScriptBehaviors ifTrue:[			tMesh translation: trans.			sp addChild: tMesh.		] ifFalse:[			win _ TSpinner new.			win spin: (B3DRotation axis: 0@1@0 angle: 1) asMatrix4x4.			win translation: trans.			win contents: tMesh.			sp addChild: win.		].	].! !!TeapotMorph methodsFor: 'toys' stamp: 'ar 9/30/2004 16:12'!makeWaterfall: trans	| ptxtr aMat tframe |	ptxtr _ TTexture new initializeWithFileName: 'Water1.bmp' mipmap: false shrinkFit: false extension: #colorKey.	ptxtr aspectFixed: false.	ptxtr extent: 3@12.	aMat _ TMaterial new.	aMat ambientColor: #(1.0 1.0 1.0 0.4).	aMat diffuseColor: #(1.0 1.0 1.0 0.4).	ptxtr materialAlpha: aMat.	tframe _ TParticleTxtr new initializeWithSize: 100.	tframe translation: trans - (1@5@0). "take the size of the texture into account".	tframe addTexture: ptxtr.	tframe setLifetimeRange: (1700 to: 2500).	tframe setPositionRangeMin:(-0.8@-0.1@-0.1) max: (0.8@0.1@0.1).	tframe setVelocityRangeMin:(-1.2@-0.1@-1.2) max:(1.2@0.1@4.2).	tframe setAccelerationRangeMin:(0@-25@0) max:(0@-20@0).	tframe rotationAroundY: -90.	tframe startColor: #(1.0 1.0 1.0 0.7) asFloatArray.	tframe endColor: #(1.0 1.0 1.0 0.2) asFloatArray.	^ tframe.! !!TeapotMorph methodsFor: 'toys' stamp: 'ar 9/30/2004 16:13'!makeWaterfallBottom: trans	| ptxtr aMat tframe |	ptxtr _ TTexture new initializeWithFileName: 'Water2.bmp' mipmap: false shrinkFit: false extension: #colorKey.	ptxtr aspectFixed: false.	ptxtr extent: 5@5.	aMat _ TMaterial new.	aMat ambientColor: #(1.0 1.0 1.0 0.2).	aMat diffuseColor: #(1.0 1.0 1.0 0.2).	ptxtr materialAlpha: aMat.	tframe _ TParticleTxtr new initializeWithSize: 100.	tframe translation: trans + (-3@2.5@0). "take the size of the texture into account".	tframe addTexture: ptxtr.	tframe setLifetimeRange: (1500 to: 2000).	tframe setPositionRangeMin:(-5.0@-0.1@-5.0) max: (5.0@0.1@5.0).	tframe setVelocityRangeMin:(-1.2@2.0@-1.2) max:(1.2@4.0@4.2).	tframe setAccelerationRangeMin:(0@-1@0) max:(0@-0.5@0).	tframe rotationAroundY: -90.	tframe startColor: #(1.0 1.0 1.0 0.6) asFloatArray.	tframe endColor: #(1.0 1.0 1.0 0.0) asFloatArray.	^ tframe.! !!TeapotMorph methodsFor: 'toys' stamp: 'ar 9/30/2004 19:32'!makeWaveDemo: sp	| player |	player _ TWaveDemo new.	sp addChild: player.	^player! !!TeapotMorph methodsFor: 'toys' stamp: 'ar 9/30/2004 12:59'!makeWaveDemo: player at: pos in: sp	| tmp mat |	tmp _ TSphere new.	tmp radius: 2.	mat _ TMaterial new.	mat ambientColor: #(1 1 1 0.95) asFloatArray.	mat diffuseColor: #(1 1 1 0.95) asFloatArray.	mat emissiveColor: #(1 1 1 0.95) asFloatArray.	tmp material: mat.	tmp translationX: pos x y: pos y z: pos z.	tmp texture: player texture.	tmp visible: true.	tmp objectOwner: player.	sp addChild: tmp.	^tmp! !!TeapotMorph methodsFor: 'toys' stamp: 'ar 10/1/2004 08:45'!makeWebPage: url extent: pageExtent	"Create a TMorphic containing nothing but a web page.	Hack scamper not to show up - it's just *way* to ugly."	| world scamper window page tm teaWorld |	tm _ TMorphic new initializeOpaque: true extent: pageExtent.	teaWorld _ TMorphMonitor new initializeWithWorld: nil extent: pageExtent.	teaWorld eventsTo: tm.	world := teaWorld world.	scamper := Scamper new.	window := scamper morphicWindow.	world addMorph: window.	page := window findA: WebPageMorph. "heh, heh"	world addMorphFront: page.	page bounds: world bounds.	window visible: false.	scamper jumpToUrl: url asUrl.	^tm! !!TeapotMorph methodsFor: 'toys' stamp: 'ar 9/30/2004 16:09'!makeWidgets: sp"This is to test window widgets. "| tframe tbutton|"	tframe _ self loadURL: 'http://www.reed.com/TeaLand/widgets/camera.tea'."tframe ifNil:[	tframe _ (TLoad3DSMax new initializeWithFileName: (FileDirectory pathFrom: #('Content' 'Widgets' 'camera.ase')) scale: 10.0) frame.	tframe boundsDepth: 1.	tframe initBounds.	TExporter export: tframe asBinary:'http://www.reed.com/TeaLand/widgets/camera.tea'.	].	tbutton _ TButton new initializeWithFrame: tframe copy.	tbutton enable.	tbutton persist: true.	sp addChild: tbutton.! !!TeapotMorph methodsFor: 'toys' stamp: 'ar 9/30/2004 16:08'!makeWindows: sp	| win pic |	#(		('lake.jpg' 0 1 -22 0)		('energy.jpg' -14 1 -22 0)		('oxygen.jpg' 10 1 -22 0)		('pyramid.jpg' 16 1 -18 -90)		('photosythesis.jpg' 16 1 0 -90)		('rockfish.jpg' -18 1 -18 90)		('opaleye.jpg' -18 1 -2 90)		('seniorita.jpg' -18 1 12 90)	) do:[:spec|		pic _ TTexture new initializeWithFileName: spec first mipmap: true shrinkFit: false.		win _ TWindow new.		win translationX: spec second y: spec third z: spec fourth.		win rotationAroundY: spec fifth.		win contents: pic.		sp addChild: win.	].! !!TeapotMorph methodsFor: 'toys' stamp: 'ar 10/1/2004 14:18'!openTool: toolClass	| tool window |	tool := toolClass new.	tool camera: activeCamera.	window := tool open.	self addMorphCentered: window.	tool postBuildIn: self.	^tool! !!TeapotMorph methodsFor: 'toys' stamp: 'ar 8/19/2002 19:51'!painter	^self valueOfProperty: #painter! !!TeapotMorph methodsFor: 'toys' stamp: 'ar 8/19/2002 19:51'!painter: aPainter	^self setProperty: #painter toValue: aPainter! !!TeapotMorph methodsFor: 'toys' stamp: 'ar 10/2/2004 20:24'!popUpBillboard: aForm	| aSpace bbForm size billboard aPosition texture mat |	aSpace := activeCamera root.	size := aForm extent * 0.01.	bbForm := Form extent: aForm extent asSmallerPowerOfTwo depth: 32.	aForm displayScaledOn: bbForm in: (bbForm boundingBox insetBy: 1).	billboard := TBillboard meta new.	texture := TTexture meta new initializeWithForm: aForm mipmap: true shrinkFit: true extension: #colorKeyZero.	texture meta isStatic: true.	texture meta aspect: size y / size x asFloat. 	texture meta extent: size.	texture meta objectOwner: billboard.	mat _ TMaterial meta new.	mat meta ambientColor: #(1 1 1 0.99) asFloatArray.	mat meta diffuseColor: #(1 1 1 0.99) asFloatArray.	mat meta emissiveColor: #(1 1 1 0.99) asFloatArray.	texture meta material: mat.	texture meta extent: texture extent * 3.		billboard meta addChild: texture.	aPosition := activeCamera translation + (activeCamera lookAt * 10).	billboard meta translation: aPosition.	aSpace meta addChild: billboard."	| pos size aSpace bbForm |	size := aForm extent * 0.01.	bbForm := Form extent: aForm extent asSmallerPowerOfTwo depth: 32.	aForm displayScaledOn: bbForm in: (bbForm boundingBox insetBy: 1).	pos := activeCamera translation + (activeCamera lookAt * 10).	aSpace := activeCamera root.	aSpace popUpBillboard: bbForm extent: size at: pos.	aSpace asyncSend: #popUpBillboard:extent:at: with: bbForm with: size with: pos."! !!TeapotMorph methodsFor: 'toys' stamp: 'ar 10/2/2004 20:24'!popUpBillboard: aForm player: aPlayer	| aSpace bbForm size billboard aPosition texture mat |	aSpace := activeCamera root.	size := aForm extent * 0.01.	bbForm := Form extent: aForm extent asSmallerPowerOfTwo depth: 32.	aForm displayScaledOn: bbForm in: (bbForm boundingBox insetBy: 1).	billboard := TBillboard meta new.	texture := TTexture meta new initializeWithForm: aForm mipmap: true shrinkFit: true extension: #colorKeyZero.	texture meta aspect: size y / size x asFloat. 	texture meta extent: size.	texture meta objectOwner: billboard.	mat _ TMaterial meta new.	mat meta ambientColor: #(1 1 1 0.99) asFloatArray.	mat meta diffuseColor: #(1 1 1 0.99) asFloatArray.	mat meta emissiveColor: #(1 1 1 0.99) asFloatArray.	texture meta material: mat.	texture meta extent: texture extent * 3.		billboard meta addChild: texture.	aPlayer ifNotNil:[		aPlayer frame: billboard.		aPlayer sketch: aForm.		aPlayer icon: nil.		^self].	billboard player sketch: aForm.	aPosition := activeCamera translation + (activeCamera lookAt * 10).	billboard meta translation: aPosition.	aSpace meta addChild: billboard."	| pos size aSpace bbForm |	size := aForm extent * 0.01.	bbForm := Form extent: aForm extent asSmallerPowerOfTwo depth: 32.	aForm displayScaledOn: bbForm in: (bbForm boundingBox insetBy: 1).	pos := activeCamera translation + (activeCamera lookAt * 10).	aSpace := activeCamera root.	aSpace popUpBillboard: bbForm extent: size at: pos.	aSpace asyncSend: #popUpBillboard:extent:at: with: bbForm with: size with: pos."! !!TeapotMorph methodsFor: 'toys' stamp: 'jh 5/19/2003 23:18'!repaint: aPlayer replaceOldCostume: aBoolean	| painter |	painter := self openTool: TPainter.	painter repaint: aPlayer replaceOldCostume: aBoolean.! !!TeapotMorph methodsFor: 'toys' stamp: 'das 10/3/2004 23:06'!updateAvatar	"Update my avatar by replicating it among all of the members of my party"	| old new |	old := activeCamera avatar.Transcript show: 'Out with the old: '; show: old teaObjectName;cr.	new := TAvatar meta new.	new meta loadAvatar: avatarPath.	new meta nickname: self nickname.	new meta host: self localTeaHost hostName.	new meta localTransform: old localTransform.Transcript show: 'In with the new: '; show: new teaObjectName;cr.	"Install it"	old parent meta addChild: new.	activeCamera avatar: new.Transcript show: 'Whas that again?: '; show: old teaObjectName;cr;cr.	^old! !!TeapotMorph methodsFor: 'drawing'!areasRemainingToFill: aRectangle	"Minimize overdraw""Transcript show:'areasRemainingToFill:';cr."	(color isColor and:[color isOpaque]) ifFalse: [^ Array with: aRectangle].	^ aRectangle areasOutside: self bounds.! !!TeapotMorph methodsFor: 'drawing' stamp: 'ar 9/30/2004 16:46'!doTransmitStuff	| myForm myTime myCount myBuffer myBytes time bytes ff |	(ogl == nil or:[ogl isOpenGLRenderer not]) ifTrue:[^self].	myTime := self valueOfProperty: #myTime ifAbsent:[0].	myCount := self valueOfProperty: #myCount ifAbsent:[0].	myForm := self valueOfProperty: #myForm ifAbsent:[nil].	myBuffer := self valueOfProperty: #myBuffer ifAbsent:[nil].	myBytes := self valueOfProperty: #myBytes ifAbsent:[0].	(myForm == nil or:[myForm extent ~= bounds extent]) ifTrue:[		myForm := Form extent: bounds extent depth: 32.		self setProperty: #myForm toValue: myForm.		myBuffer := ByteArray new: myForm width * myForm height * 5. "way more than needed"		self setProperty: #myBuffer toValue: myBuffer.	].	time := [	myForm unhibernate.	ogl glReadPixels: 0 with: 0 with: bounds width with: bounds height with: ogl imagePixelFormat32 with: ogl imagePixelType32 with: myForm bits.	ff := Form extent: myForm extent depth: myForm depth.	ff := (WarpBlt			rotate: myForm			degrees: 0			center: myForm boundingBox center			scaleBy: 1@-1			smoothing: 1) first.	bytes := JPEGReadWriter2 		compressImage: ff		quality: 80		progressiveJPEG: false 		buffer: myBuffer.	] timeToRun.	myTime := myTime + time.	myBytes := myBytes + bytes.	myCount := myCount + 1.	self setProperty: #myTime toValue: myTime.	self setProperty: #myBytes toValue: myBytes.	self setProperty: #myCount toValue: myCount.	self setProperty: #myJpeg toValue: (myBuffer copyFrom: 1 to: bytes).	(myTime // myCount) printString, ' msecs/frame' displayAt: 0@0.	(myBytes // myCount) printString, ' bytes/frame' displayAt: 0@15.	(bytes) printString, ' bytes' displayAt: 0@30.	myForm displayOn: Display at: 0@45.	Display forceToScreen: (0@0 extent: 320@285).	! !!TeapotMorph methodsFor: 'drawing' stamp: 'ar 9/30/2004 16:44'!drawAcceleratedOn: aCanvas 	| myRect |	myRect _ (self bounds: bounds in: nil)				intersect: (0 @ 0 extent: DisplayScreen actualScreenSize).	(ogl notNil and: [ogl isAccelerated]) ifFalse: [		ogl ifNotNil:[ogl destroy. ogl _ nil].	].	ogl ifNotNil: [ogl _ ogl bufferRect: myRect].	ogl ifNil: [		ogl _ OpenGL newIn: myRect.		ogl ifNil: [^self drawSimulatedOn: aCanvas].		ogl glEnable: GLTexture2d.	] ifNotNil: [		ogl reset.		ogl glEnable: GLDepthTest.	].	ogl viewportOffset: aCanvas origin.	ogl clipRect: aCanvas clipRect.	self renderOn: ogl.	Display addExtraRegion: myRect for: self! !!TeapotMorph methodsFor: 'drawing' stamp: 'das 10/3/2004 15:45'!drawOn: aCanvas	"Figure out if we can use HWA or if we need to punt"	(aCanvas form == Display and:[self accelerationEnabled and:[self isFlexed not]])		ifTrue:[self drawAcceleratedOn: aCanvas]		ifFalse:[self drawSimulatedOn: aCanvas].! !!TeapotMorph methodsFor: 'drawing' stamp: 'ar 9/30/2004 16:45'!drawSimulatedOn: aCanvas	ogl ifNotNil:[		"Dump it. We may just being dragged around by the hand."		ogl destroy.		ogl _ nil.	].	myImage		ifNil:[aCanvas fillRectangle: self bounds color: self color]		ifNotNil:[aCanvas drawImage: myImage at: bounds origin].! !!TeapotMorph methodsFor: 'drawing' stamp: 'ar 9/30/2004 16:46'!forceToScreen	"When using hardware acceleration, this method forces the receiver to swap its buffers.""Transcript show:'forceToScreen';cr."		activeCamera killFrame ifFalse:[		ogl ifNotNil:[			ogl swapBuffers ifFalse:[				"Something went wrong"				ogl destroy.				ogl _ nil]]] ifTrue:[activeCamera killFrame: false.].! !!TeapotMorph methodsFor: 'drawing' stamp: 'ar 9/30/2004 13:28'!renderOn: aRenderer	(color isTransparent or:[color isTranslucent]) 		ifTrue:[aRenderer restoreMorphicBackground: self bounds under: self].	aRenderer viewport: self bounds.	aRenderer isOpenGLRenderer		ifTrue:[self glRenderOn: aRenderer].	aRenderer isValid ifTrue:[		aRenderer restoreMorphicForeground: self bounds above: self.	].! !!TeapotMorph methodsFor: 'drawing' stamp: 'ar 3/23/2002 00:12'!transmitStuff	^self hasProperty: #doTransmitStuff! !!TeapotMorph methodsFor: 'drawing' stamp: 'ar 3/23/2002 00:11'!transmitStuff: aBool	aBool 		ifTrue:[self setProperty: #doTransmitStuff toValue: true]		ifFalse:[self removeProperty: #doTransmitStuff].	self removeProperty: #myTime.	self removeProperty: #myBuffer.	self removeProperty: #myCount.	self removeProperty: #myForm.	self removeProperty: #myBytes.! !!TeapotMorph methodsFor: 'event handling' stamp: 'ar 9/30/2004 16:47'!blueButtonDown: anEvent	"Special gestures (cmd-mouse on the Macintosh; Alt-mouse on Windows and Unix) allow a mouse-sensitive morph to be moved or bring up a halo for the morph."	| selected |	ogl ifNil:[^super blueButtonDown: anEvent].	selected := activeCamera pointer selectedObject.	(selected notNil and:[selected wantsBlueButton]) ifTrue:[		self hasHalo ifTrue:[ self removeHalo].		activeCamera pointer pointerDown: anEvent.	] ifFalse:[super blueButtonDown: anEvent].! !!TeapotMorph methodsFor: 'event handling' stamp: 'ar 9/30/2004 16:46'!blueButtonUp: anEvent	"Special gestures (cmd-mouse on the Macintosh; Alt-mouse on Windows and Unix) allow a mouse-sensitive morph to be moved or bring up a halo for the morph."	| selected |	ogl ifNil:[^super blueButtonUp: anEvent].	selected := activeCamera pointer selectedObject.	(selected notNil and:[selected wantsBlueButton]) ifTrue:[		activeCamera pointer pointerUp: anEvent.	] ifFalse:[super blueButtonUp: anEvent].! !!TeapotMorph methodsFor: 'event handling' stamp: 'das 10/3/2004 13:19'!checkMessages	| msg |"	mutex critical:["		[messageList size > 0 ifTrue:[				msg _ messageList at:1. 				msg teaTime < TeaTime now ifTrue:[					msg delayedSend. true.] ifFalse:[false]]ifFalse:[false]]		whileTrue:[ messageList removeFirst ]."	]."! !!TeapotMorph methodsFor: 'event handling' stamp: 'ar 9/30/2004 13:54'!dropFiles: evt	| f frame |	"Only take first file"	f _ FileStream requestDropStream: 1.	[(frame _ activeCamera pointer selectedObject)		ifNotNil: [frame isComponent				ifTrue: [(frame handlesPointerOver: self)						ifTrue: [frame dropFiles: f pointer: self]]]		ifNil: [activeCamera makePicture: f].	] ensure:[f close].! !!TeapotMorph methodsFor: 'event handling' stamp: 'ar 7/26/2002 05:11'!handleMouseMove: anEvent	"Reimplemented to get #mouseOver: messages"	self mouseOver: anEvent.	super handleMouseMove: anEvent.! !!TeapotMorph methodsFor: 'event handling'!handlesKeyboard: evt	^ true! !!TeapotMorph methodsFor: 'event handling'!handlesMouseDown: evt	^ true.	"evt yellowButtonPressed ifTrue: [^false] ifFalse: [^true]."! !!TeapotMorph methodsFor: 'event handling'!handlesMouseOver: evt^ true.! !!TeapotMorph methodsFor: 'event handling'!handlesMouseStillDown: evt^ true.! !!TeapotMorph methodsFor: 'event handling' stamp: 'ar 3/9/2004 19:48'!justDroppedInto: aMorph event: anEvent	self restoreAcceleration.	World doOneCycleNow.	(self hasProperty: #openTeaFileOnDrop) ifTrue:[		self removeProperty: #openTeaFileOnDrop.		self requestInitialSpace.		"make sure cursor is back to normal"		Cursor normal show.	].! !!TeapotMorph methodsFor: 'event handling' stamp: 'ar 4/9/2002 11:59'!keyDown: anEvent	| kv |	kv _ anEvent keyValue.	kv = 30 ifTrue:[self setProperty: #fwdSpeed toValue: -10].	kv = 31 ifTrue:[self setProperty: #fwdSpeed toValue: 10].	kv = 28 ifTrue:[self setProperty: #turnSpeed toValue: 45].	kv = 29 ifTrue:[self setProperty: #turnSpeed toValue: -45].! !!TeapotMorph methodsFor: 'event handling' stamp: 'ar 10/2/2004 07:53'!keyStroke: anEvent	^activeCamera keyStroke: anEvent	! !!TeapotMorph methodsFor: 'event handling' stamp: 'ar 9/30/2004 14:18'!keyUp: anEvent	| kv |	kv _ anEvent keyValue.	kv = 38 ifTrue:[self setProperty: #fwdSpeed toValue: 0].	kv = 40 ifTrue:[self setProperty: #fwdSpeed toValue: 0].	kv = 37 ifTrue:[self setProperty: #turnSpeed toValue: 0].	kv = 39 ifTrue:[self setProperty: #turnSpeed toValue: 0].	activeCamera pointer keyUp: anEvent.	! !!TeapotMorph methodsFor: 'event handling' stamp: 'ar 10/1/2004 09:43'!mouseDown: evt	activeCamera mouseDown: evt.! !!TeapotMorph methodsFor: 'event handling' stamp: 'ar 10/2/2004 19:36'!mouseEnter: evt	evt hand newKeyboardFocus: self.! !!TeapotMorph methodsFor: 'event handling' stamp: 'ar 10/2/2004 19:35'!mouseMove: evt	activeCamera mouseMove: evt.! !!TeapotMorph methodsFor: 'event handling' stamp: 'ar 10/2/2004 19:35'!mouseOver: anEvent	activeCamera pointerXY: anEvent position! !!TeapotMorph methodsFor: 'event handling' stamp: 'ar 10/2/2004 19:35'!mouseStillDown: evt	^ self mouseMove: evt! !!TeapotMorph methodsFor: 'event handling' stamp: 'ar 10/2/2004 19:35'!mouseUp: evt	activeCamera mouseUp: evt.! !!TeapotMorph methodsFor: 'tea time' stamp: 'ar 10/2/2004 12:28'!connect: partyURL partyName: partyName nickName: partyNickname	| party |	self initializeLocalTeaHost.	"join the appropriate TeaParty"	party _ TeaParty host: self localTeaHost rendezvousAt: partyURL forParty: partyName nickname: partyNickname.	party teapot: self.	self teaParty: party.	self nickname: partyNickname.	"install this camera visibly into all other TeaHosts at its current location in the space."	"self updateParty: party nickName: partyNickname."! !!TeapotMorph methodsFor: 'tea time' stamp: 'ar 10/2/2004 15:07'!destroyAvatarNamed: atarName	"Destroy the old avatar under the name atarName. Note: The reason why we don't replicate the #destroy message is that during initial connection the new avatar might not exist on the remote machine."	| atar |	atar := self teaObjects at: atarName ifAbsent:[^self].	atar destroy.! !!TeapotMorph methodsFor: 'tea time' stamp: 'das 10/3/2004 23:37'!initializeLocalTeaHost	| host |	TeaHost startSession.	host _ TeaHost newLocal.	self localTeaHost: host.	"define names of all shared teaObjects"	self teaObjects keysAndValuesDo:[:name :val| host define: name as: val].	"register all classes"	"Smalltalk allClassesDo:[:cls| self registerTeaObject: cls; registerTeaObject: cls class]."	^host.! !!TeapotMorph methodsFor: 'tea time' stamp: 'ar 9/10/2002 21:16'!initializeTeaParty	^self connect: 'http://www.reed.com/TeaParties/'		partyName: 'Tea'		nickName: Utilities authorInitials.! !!TeapotMorph methodsFor: 'tea time'!localTeaHost	^self valueOfProperty: #localTeaHost! !!TeapotMorph methodsFor: 'tea time'!localTeaHost: host	^self setProperty: #localTeaHost toValue: host! !!TeapotMorph methodsFor: 'tea time'!nickname	^self valueOfProperty: #nickname! !!TeapotMorph methodsFor: 'tea time'!nickname: nickname	^self setProperty: #nickname toValue: nickname! !!TeapotMorph methodsFor: 'tea time' stamp: 'ar 10/2/2004 16:09'!noteNewHost: aHost	"We just learned about a new host. Do whatever is necesary."	| old |	aHost hostName = self localTeaHost hostName ifTrue:[^self].	SoundPlayer hiThere.	old := self updateAvatar. "For example, broadcasting my avatar"	self meta destroyAvatarNamed: old teaObjectName.! !!TeapotMorph methodsFor: 'tea time' stamp: 'ar 10/2/2004 07:58'!registerTeaObject: anObject	| host |	(host := self localTeaHost) ifNotNil:[host define: anObject teaObjectName as: anObject].	self teaObjects at: anObject teaObjectName put: anObject.! !!TeapotMorph methodsFor: 'tea time' stamp: 'das 10/3/2004 23:22'!teaName	^TeaName new initialize: self teaObjectName class: false.! !!TeapotMorph methodsFor: 'tea time' stamp: 'ar 10/2/2004 10:07'!teaObjectName	^#TheTeapotMorph! !!TeapotMorph methodsFor: 'tea time' stamp: 'das 9/29/2003 13:20'!teaObjects"	^self valueOfProperty: #teaObjects ifAbsentPut:[WeakValueDictionary new]."	^self valueOfProperty: #teaObjects ifAbsentPut:[Dictionary new].! !!TeapotMorph methodsFor: 'tea time'!teaParty	^self valueOfProperty: #teaParty! !!TeapotMorph methodsFor: 'tea time'!teaParty: host	^self setProperty: #teaParty toValue: host! !!TeapotMorph methodsFor: 'initialization' stamp: 'das 10/3/2004 13:48'!delete	activeCamera avatar meta destroy.	Current == self ifTrue:[Current _ nil].	CroquetGlobals snapshots: nil.	self teaParty ifNotNil: [		self teaParty resign. 		"TeaPartyStats _ self teaParty selectorHistogram"].	self localTeaHost ifNotNil: [		self localTeaHost shutdown.		"TeaHostStats _ self localTeaHost selectorHistogram."		"TeaHostTraffic _ self localTeaHost networkStatistics"].	ogl ifNotNil:[		activeCamera ifNotNil:[			activeCamera endChat.]].	ogl ifNotNil: [		"texture delete: gl." 		ogl destroy.		ogl _ nil.].	super delete.	self tweakWorld 		ifNil:[self scriptScheduler shutDown]		ifNotNil:[self shutdownTweakWorld].	CroquetGlobals theTeapotMorph: nil.	TCleanup run.! !!TeapotMorph methodsFor: 'initialization' stamp: 'ar 9/23/2002 02:38'!dismissViaHalo	self delete.! !!TeapotMorph methodsFor: 'initialization' stamp: 'das 10/3/2004 23:13'!initialize	| logo space avatar root |	super initialize.	mutex _ Semaphore new.	TeaHost initHostName.	CroquetGlobals theTeapotMorph: self.	CroquetGlobals snapshots: OrderedCollection new.	messageList _ SortedCollection sortBlock:[:m1 :m2 | m1 teaTime < m2 teaTime].	self registerTeaObject: nil.	self registerTeaObject: self.	people := OrderedCollection new.	myColor _ {2 atRandom-1. 2 atRandom-1. 2 atRandom-1. 1.0}asFloatArray.	self clipSubmorphs: true.	self scriptScheduler: ScriptScheduler new.	self scriptScheduler runActiveScripts. "to get started"	Current _ self.	self accelerationEnabled: true.	self		color: (Color				r: 0.7				g: 0.9				b: 1.0).	bounds _ 0 @ 0 corner: 640 @ 480.	"Temporary hostName""	TeaHost pushHostName: UUID new asString."	space _ TSpace new.	activeCamera _ TUserCamera new initializeWithViewPort: self.	activeCamera viewClip: false.	avatarPath := #('Content' 'Alice' 'Animals' 'AliceLiddell.mdl').	avatar _ TAvatar new.	avatar loadAvatar: avatarPath.	avatar translationX: 0 y: 0 z: 30.	space addChild: avatar.	activeCamera avatar: avatar.	logo _ TTexture				new initializeWithFileName: 'squeaklogo2.bmp'				mipmap: true				shrinkFit: false.	activeCamera texture: logo.	activeCamera translationX: 0 y: 0 z: 30.	"self openConnectionDialog."	self addZoomNavigator.	TeaHost popHostName.	TeaHost initHostName.	root := self initializeDefaultSpace.	root addChild: avatar.! !!TeapotMorph methodsFor: 'initialization' stamp: 'ar 10/2/2004 16:20'!initializeDefaultSpace	| space tframe waveDemo |"self initializeTweakWorld.""self makeJIVE."	space _ TSpace new.	space url: 'http://www.reed.com/TeaLand/spaces/intro.tea'."	space ambientSound: (self loadAmbientSound:'intro.mp3')."	self makeLight: space.	txtr _ TTexture				new initializeWithFileName: 'checker.bmp'				mipmap: true				shrinkFit: false.		self makeFloor: space fileName:'stone.bmp'.	waveDemo _ self makeWaveDemo: space.	self makeWaveDemo: waveDemo at: -30@-1@-30 in: space.	self makeWaveDemo: waveDemo at: 30@-1@-30 in: space.	self makeWaveDemo: waveDemo at: 30@-1@30 in: space.	self makeWaveDemo: waveDemo at: -30@-1@30 in: space.	self makeKay: space.	self makeMirror: space. "	self makeMirror2: space."	self makePyramid: space.	"self makeUnderwater: space."	self makeUnderwater3: space.	self makePopUp: space.	self makeChess: space.	self makeProjectLink: space.	self makePooh: space.	self makeStartupLink: space.	self makeGallery: space.	self makeDungeon: space.	self make3Body: space.	"self makeSolar: space."	self makeClock: space.	self makeSlime: space.	self makeMars: space."	self makeManual: space."	tframe _ TSkyBox new initializeWithFileName: 'MLL'.	space addChild: tframe."	tframe _ TPortal3D initializeWithSpace: space.	win _ TWindow new.	win translationX: -12 y: 0.0 z: 5.0.	win contents3D: tframe.	space addChild: win."	^space! !!TeapotMorph methodsFor: 'initialization'!intoWorld: aWorld"Transcript show:'intoWorld:';cr.	"	"The receiver is showing in the given world"	aWorld ifNil:[^self].	super intoWorld: aWorld.	aWorld when: #aboutToLeaveWorld send: #suspendAcceleration to: self.	aWorld when: #aboutToEnterWorld send: #restoreAcceleration to: self.	self restoreAcceleration.! !!TeapotMorph methodsFor: 'initialization' stamp: 'ar 10/8/2002 15:09'!loadImageUrl: url	| loc myLoader result |	loc := ResourceLocator new urlString: url.	loc ifNil:[^ nil].	loc resourceFileSize: 0.	myLoader := TResourceLoader new.	myLoader download: loc whenFinishedSend:#value: to:[:ll| 		result := [Form fromFileNamed: loc localFileName] on: Error do:[:ex| ex return: nil].	].	[myLoader isDone] whileFalse:[myLoader step].	^result! !!TeapotMorph methodsFor: 'initialization' stamp: 'das 4/18/2003 15:38'!loadInitialSpace: urlString	| space |	space := self loadURL: urlString.	^space! !!TeapotMorph methodsFor: 'initialization' stamp: 'ar 10/8/2002 23:24'!loadLocator: aLocator	^self loadLocator: aLocator reuseExisting: true! !!TeapotMorph methodsFor: 'initialization' stamp: 'ar 9/30/2004 16:46'!loadLocator: aLocator reuseExisting: aBool	| fs importer result resList |	aLocator localFileName ifNil:[^self inform:'Failed to load object'].	aBool ifTrue:[result := (self teaObjects at: aLocator urlString ifAbsent:[nil])].	result ifNil:[		fs := FileStream readOnlyFileNamed: aLocator localFileName.		[importer := TImporter new.		importer addAttribute: #ogl value: ogl.		result := [importer importStream: fs] 			on: Error 			do:[:ex|				"allow outer error handlers to catch the exception"				ex isNested ifTrue:[ex pass].				"otherwise ignore it and just return true"				ex return: nil.			].		] ensure:[fs close].		result ifNil:[^result].		self teaObjects at: aLocator urlString put: result.		resList := importer resources.		resList size > 0 ifTrue:[			(loader == nil or:[loader isDone]) ifTrue:[				loader := TResourceLoader new.			].			loader addAll: resList].	].	^result! !!TeapotMorph methodsFor: 'initialization' stamp: 'ar 10/8/2002 23:25'!loadURL: url	^self loadURL: url reuseExisting: true! !!TeapotMorph methodsFor: 'initialization' stamp: 'ar 9/30/2004 19:27'!loadURL: url reuseExisting: aBool	| loc myLoader result |	loc := ResourceLocator new urlString: url.	loc ifNil:[^ nil].	loc resourceFileSize: 0.	myLoader := TResourceLoader new.	myLoader download: loc whenFinishedSend:#value: to:[:ll| 		result := self loadLocator: ll reuseExisting: aBool	].	[myLoader isDone] whileFalse:[myLoader step].	^result! !!TeapotMorph methodsFor: 'initialization' stamp: 'das 10/1/2002 16:42'!localURL: url	^ self teaObjects at: url.! !!TeapotMorph methodsFor: 'initialization' stamp: 'das 10/17/2002 13:07'!myColor	^ myColor.! !!TeapotMorph methodsFor: 'initialization' stamp: 'ar 9/10/2002 21:22'!openConnectionDialog	| dialog |	dialog := TConnectionDialog new.	dialog teapot: self.	self addMorphCentered: dialog open.! !!TeapotMorph methodsFor: 'initialization' stamp: 'ar 3/9/2004 19:11'!outOfWorld: aWorld"Transcript show:'outOfWorld';cr."	"The receiver is leaving the given world"	aWorld ifNil:[^self].	self suspendAcceleration.	aWorld removeActionsWithReceiver: self.	super outOfWorld: aWorld.! !!TeapotMorph methodsFor: 'initialization' stamp: 'ar 10/2/2004 19:36'!requestInitialSpace	| spaceName space |	self class == TeapotMorph ifTrue:[		spaceName := FillInTheBlank request:'Enter the TEA url' initialAnswer:'http://www.reed.com/TeaLand/spaces/intro.tea'.	].	Cursor wait showWhile:[		spaceName isEmptyOrNil 			ifTrue:[space := self initializeDefaultSpace]			ifFalse:[space := self loadInitialSpace: spaceName].	].	space ifNil:[^self error:'Couldnt construct space'].	activeCamera avatar enter: space.	activeCamera snapshot: nil.! !!TeapotMorph methodsFor: 'initialization' stamp: 'ar 9/23/2002 02:41'!slideToTrash: evt	self delete.! !!TeapotMorph methodsFor: 'fileIn/Out' stamp: 'ar 6/12/2002 03:42'!download: aLocator whenFinishedSend: aSelector to: anObject	loader ifNil:[loader := TResourceLoader new].	loader download: aLocator whenFinishedSend: aSelector to: anObject.! !!TeapotMorph methodsFor: 'fileIn/Out' stamp: 'ar 6/6/2002 22:34'!teaExportOn: exporter	^self error:'Cannot export'! !!TeapotMorph methodsFor: 'rendering' stamp: 'ar 8/19/2002 19:54'!drawSubmorphsOn: ignored	"ignore the entire enchilada"! !!TeapotMorph methodsFor: 'rendering' stamp: 'ar 10/1/2004 13:35'!frustumChanged: camera! !!TeapotMorph methodsFor: 'rendering' stamp: 'ar 10/2/2004 19:40'!glRenderMorphicOverlayOn: aRenderer 	|  box |	self tweakWorld ifNotNil:[self glRenderTweakOn: aRenderer].	box := 0@0 extent: self extent.	self glRenderSubmorphsOn: ogl.	activeCamera isChatting ifTrue:[		ogl drawString: activeCamera chatStatus 			at: box topLeft font: nil color: Color orange align: #topLeft.	].	statusString ifNotNil:[		ogl drawString: statusString 			at: box bottomLeft font: nil color: Color orange.	].	self fpsMorph ifNotNil:[		ogl drawString: self fpsMorph contents 			at: box topRight font: nil color: Color orange align: #topRight.	].	self showTextureStats ifTrue:[		| mgr offset |		offset _ 0@15.		mgr := ogl textureManager.		{			'Max: ', mgr memUsed asStringWithCommas.			'Now: ', mgr memFrame asStringWithCommas.			'Active Textures: ', mgr numTexturesUsed asStringWithCommas.			'Textures bound: ', mgr numTexturesBound asStringWithCommas.			'Textures reused: ', mgr numTexturesReused asStringWithCommas.		} do:[:string|			ogl drawString: string at: box topLeft  + offset font: nil color: Color orange align: #topLeft.			offset _ offset + (0@15).		].	].false ifTrue:[	ogl glColor4f: 0 with: 0 with: 0 with: 1.	ogl		glBegin: GLQuads;			glVertex2f: box left with: box top;			glVertex2f: box right with: box top;			glVertex2f: box right with: box top + 1;			glVertex2f: box left with: box top + 1;			glVertex2f: box left with: box bottom-1;			glVertex2f: box right with: box bottom-1;			glVertex2f: box right with: box bottom;			glVertex2f: box left with: box bottom;		glEnd.	box := box bottomLeft rect: box bottomRight - (1@100).	ogl 		glEnable: GLBlend;		glBlendFunc: GLSrcAlpha with: GLOneMinusSrcAlpha;		glColor4f: 0.0 with: 0.0 with: 0.0 with: 0.5;		glLineWidth: 1;		glBegin: GLLineLoop;			glVertex2f: box left with: box bottom;			glVertex2f: box left with: box top;			glVertex2f: box right with: box top;			glVertex2f: box right with: box bottom;		glEnd;		glColor4f: 1.0 with: 1.0 with: 1.0 with: 0.5;		glBegin: GLQuads;			glVertex2f: box left + 1 with: box bottom - 1;			glVertex2f: box left + 1 with: box top + 1;			glVertex2f: box right - 1 with: box top + 1;			glVertex2f: box right - 1 with: box bottom - 1;		glEnd;		glDisable: GLBlend;	yourself.]."	#(topLeft topCenter topRight	leftCenter center rightCenter	bottomLeft bottomCenter bottomRight) do:[:sym|		pos := box perform: sym.		ogl drawString: sym at: pos font: nil color: Color black align: sym.	]."! !!TeapotMorph methodsFor: 'rendering' stamp: 'ar 9/30/2004 14:17'!glRenderOn: aRenderer 	activeCamera renderView: aRenderer.! !!TeapotMorph methodsFor: 'rendering' stamp: 'ar 8/19/2002 21:10'!glRenderSubmorphsOn: aRenderer	"Display submorphs back to front"	submorphs size = 0 ifTrue:[^self].	submorphs reverseDo:[:sm| sm glRenderOn: aRenderer].! !!TeapotMorph methodsFor: 'rendering' stamp: 'ar 8/19/2002 20:30'!morphsInFrontOf: someMorph overlapping: aRectangle do: aBlock	"Evaluate aBlock with all top-level morphs in front of someMorph that overlap with the given rectangle. someMorph is either an immediate child of the receiver or nil (in which case all submorphs of the receiver are enumerated)."	owner ifNil:[^self].	^owner morphsInFrontOf: self overlapping: aRectangle do: aBlock.! !!TeapotMorph methodsFor: 'rendering' stamp: 'ar 10/2/2004 19:41'!renderOverlay: ogl	"Set up gl to provide overlay drawing - this is done in pixel coordinates"	ogl glDisable: GLLighting.	ogl beginMorphicOverlay: bounds.	self glRenderMorphicOverlayOn: ogl.	ogl endMorphicOverlay.	CroquetGlobals snapshots do:[ :ss | ss glRenderOn: ogl].	ogl glEnable: GLLighting.! !!TeapotMorph methodsFor: 'step' stamp: 'ar 6/23/2002 16:48'!fpsMorph	^self valueOfProperty: #fpsMorph! !!TeapotMorph methodsFor: 'step' stamp: 'ar 6/23/2002 16:48'!fpsMorph: aMorph	^self setProperty: #fpsMorph toValue: aMorph! !!TeapotMorph methodsFor: 'step' stamp: 'das 10/3/2004 15:45'!step	| now last delta |	self checkMessages.	ogl ifNil:[^self].	self fpsMorph ifNotNil:[self fpsMorph step].	now _ TeaTime now.	last _ self valueOfProperty: #lastStepTime ifAbsent:[now].	self setProperty: #lastStepTime toValue: now."	delta _ now - last.	delta > 0 ifTrue:[		df _ (self valueOfProperty: #fwdSpeed ifAbsent:[0]) * delta * 0.001.		dt _ (self valueOfProperty: #turnSpeed ifAbsent:[0]) * delta * 0.001.		ogl activeCamera forwardOnY: df.		ogl activeCamera yaw: dt.	]."	pdaClient ifNotNil:[self updatePDAClient].	self changed.	loader ifNotNil:[		loader stepFor: 100.		statusString := loader currentUrl.		statusString ifNotNil:[statusString := 'Loading ', statusString,'...'].		loader isDone ifTrue:[loader := nil. statusString := nil].	].	"NOTE: When tweakWorld is present its scheduler is aliased to my scheduler.	All script activity is then run from there."	self tweakWorld ifNil:[		self scriptScheduler ifNotNilDo:[:scheduler| scheduler runActiveScripts].	] ifNotNil:[		self runTweakCycle.	]."	activeCamera avatar meta driveStep.""	activeCamera avatar meta localTransform: activeCamera avatar localTransform."! !!TeapotMorph methodsFor: 'step'!stepTime	^0 "every frame"! !!TeapotMorph methodsFor: 'step'!wantsSteps	^true! !!TeapotMorph methodsFor: 'tweak support' stamp: 'ar 10/1/2004 15:37'!glRenderTweakCostume: aCostume on: aRenderer	| box formCache texCache textureDict mat rectList bb tfm m44 tw th |	aCostume visible ifFalse:[^self].	textureDict := self tweakCache.	box := aCostume localFullBounds.	box := box origin asIntegerPoint corner: box corner asIntegerPoint.	formCache := aCostume localCache.	formCache ifNil:[aCostume localCache: (formCache := aCostume newFormCache)].	"figure out changes in size/depth"	(formCache form == nil 		or:[formCache form extent isPowerOfTwo not			or:[formCache form extent asLargerPowerOfTwo ~= box extent asLargerPowerOfTwo]]) ifTrue:[		formCache form: (Form extent: box extent asLargerPowerOfTwo depth: 32).	].	"grab the texture cache"	texCache := textureDict at: aCostume ifAbsent:[nil].	"make sure it hasn't changed"	(texCache == nil or:[texCache textureForm ~~ formCache form]) ifTrue:[		texCache ifNotNil:[aRenderer releaseTexture: texCache tform].		texCache := TTexture new 				initializeWithForm: formCache form				mipmap: false 				shrinkFit: true.		mat _ TMaterial new.		mat ambientColor: #(1.0 1.0 1.0 0.9) asFloatArray.		mat diffuseColor: #(1.0 1.0 1.0 0.9) asFloatArray.		mat emissiveColor: #(1.0 1.0 1.0 1.0) asFloatArray.		texCache material: mat.		textureDict at: aCostume put: texCache.	].	"repair damage"	rectList := formCache 		repairDamage: aCostume localFullBounds 		using:[:cc| aCostume localFullDrawOn: cc].	"fix up alpha and remember upload rectangle"	bb := BitBlt toForm: texCache textureForm.	bb combinationRule: 40 "fixAlpha:with:".	bb halftoneForm: (Bitmap with: 16rFF000000).	rectList do:[:r|		| aRect |		aRect := r translateBy: box origin negated.		bb destRect: aRect.		bb copyBits.		texCache invalidate: aRect.	].	"draw the costume"	texCache enable: aRenderer.	tfm := aCostume transform.	aRenderer glPushMatrix.	aRenderer glTranslatef: tfm offset x with: tfm offset y with: 0.0.	tfm isPureTranslation ifFalse:[		tfm := tfm asMatrixTransform2x3.		m44 := B3DMatrix4x4 identity.		m44 a11: tfm a11; a12: tfm a21; a21: tfm a12; a22: tfm a22.		aRenderer glMultMatrixf: m44.	].	tw := box width asFloat / texCache textureForm width asFloat.	th := box height asFloat / texCache textureForm height asFloat.	aRenderer glBegin: GLQuads;		glTexCoord2f: 0.0 with: 0.0;		glVertex2f: box left with: box top;		glTexCoord2f: tw with: 0.0;		glVertex2f: box right with: box top;		glTexCoord2f: tw with: th;		glVertex2f: box right with: box bottom;		glTexCoord2f: 0.0 with: th;		glVertex2f: box left with: box bottom;	glEnd.	aRenderer glPopMatrix.	texCache disable: aRenderer.! !!TeapotMorph methodsFor: 'tweak support' stamp: 'ar 10/1/2004 15:38'!glRenderTweakOn: aRenderer 	| texCache textureDict myWorld |	(myWorld := self tweakWorld) ifNil:[^self].	textureDict := self tweakCache.	aRenderer glDisable: GLLighting.	aRenderer glColor4f: 1.0 with: 1.0 with: 1.0 with: 1.0.	self tweakWorld asPrimCostume contents reverseDo:[:aCostume|		self glRenderTweakCostume: aCostume on: aRenderer.	].	self tweakWorld hands reverseDo:[:aHand|		aHand costume invalidationSuppressed			ifFalse:[self glRenderTweakCostume: aHand costume on: aRenderer].	].	aRenderer glEnable: GLLighting.	"remove obsolete costumes from texture dictionary"	textureDict keys "need a copy" do:[:aCostume|		aCostume container == myWorld costume ifFalse:[			"it got removed"			aCostume localCache: nil.			texCache := textureDict removeKey: aCostume.			aRenderer releaseTexture: texCache tform.		].	].! !!TeapotMorph methodsFor: 'tweak support' stamp: 'ar 2/10/2003 18:55'!handleEvent: anEvent	| evt myWorld |	(myWorld := self tweakWorld) ifNil:[^super handleEvent: anEvent].	(#(mouseDown mouseUp mouseMove	keyDown keyUp keystroke) includes: anEvent type) ifTrue:[		(anEvent isMouse and:[anEvent isMouseDown]) ifTrue:[self comeToFront].		"pass it into myWorld"		evt := anEvent translatedBy: bounds origin negated.		"evt printString displayAt: 0@0."		myWorld eventQueue nextPut: evt clone.		anEvent wasHandled: true.		^true].	^super handleEvent: anEvent! !!TeapotMorph methodsFor: 'tweak support' stamp: 'bf 9/16/2004 13:47'!initializeTweakWorld	| myWorld |	myWorld := Smalltalk at: #CWorldPlayer ifPresent:[:cls| cls basicNew].	myWorld ifNil:[^self].	myWorld setScheduler: self scriptScheduler.	myWorld initialize.	myWorld ownerMorph: self.	myWorld eventQueue: SharedQueue new.	self tweakWorld: myWorld.	myWorld bootstrap: [		self startScript: #onKeyDown: when:{myWorld. #keyDown}.		self startScript: #onKeyStroke: when:{myWorld. #keyStroke}.		self startScript: #onKeyUp: when:{myWorld. #keyUp}.		self startScript: #onMouseDown when:{myWorld. #mouseDown}.		self startScript: #onMouseMove when:{myWorld. #mouseMove}.		self startScript: #onMouseUp when:{myWorld. #mouseUp}.		self startScript: #onBlueButtonDown when:{myWorld. #blueButtonDown}.		self startScript: #onBlueButtonUp when:{myWorld. #blueButtonUp}.		self startScript: #onYellowButtonDown when:{myWorld. #yellowButtonDown}.		self startScript: #onYellowButtonUp when:{myWorld. #yellowButtonUp}.	].	myWorld signal: #geometryChanged.! !!TeapotMorph methodsFor: 'tweak support' stamp: 'ar 9/30/2004 16:45'!onBlueButtonDown	"Special gestures (cmd-mouse on the Macintosh; Alt-mouse on Windows and Unix) allow a mouse-sensitive morph to be moved or bring up a halo for the morph."	| selected evt |	evt := ActiveHand lastEvent translatedBy: bounds origin. "offset for morphic"	"(self tweakWorld activeProject playerAtPoint: ActiveHand position) 		ifNotNil:[^self tweakWorld activeProject onBlueButtonDown]."	ogl ifNil:[^self addHalo: self world firstHand lastEvent].	selected := activeCamera pointer selectedObject.	(selected notNil and:[selected wantsBlueButton]) ifTrue:[		activeCamera pointer pointerDown: evt.	] ifFalse:[self addHalo: self world firstHand lastEvent].! !!TeapotMorph methodsFor: 'tweak support' stamp: 'ar 2/11/2003 13:00'!onBlueButtonUp	| evt |	evt := ActiveHand lastEvent translatedBy: bounds origin. "offset for morphic"	^self mouseUp: evt! !!TeapotMorph methodsFor: 'tweak support' stamp: 'ar 2/10/2003 17:39'!onKeyDown: event	self keyDown: event! !!TeapotMorph methodsFor: 'tweak support' stamp: 'ar 2/10/2003 17:39'!onKeyStroke: anEvent	^self keyStroke: anEvent! !!TeapotMorph methodsFor: 'tweak support' stamp: 'ar 2/10/2003 17:39'!onKeyUp: event	self keyUp: event! !!TeapotMorph methodsFor: 'tweak support' stamp: 'bf 3/11/2004 18:12'!onMouseDown	"Transcript show: evt class asString. ----> MouseButtonEvent"	| evt |	"draggee := self tweakWorld activeProject dragChildAt: ActiveHand position.	draggee ifNotNil:[^draggee onDrag]."	ActiveHand dragContents ifNotNil:[^self].	"clicks on desktop remove halo and keyboard focus"	ActiveHand keyboardFocus: nil.	ActiveHand halo target: nil.	evt := ActiveHand lastEvent translatedBy: bounds origin. "offset for morphic"	self mouseDown: evt.	self startScript: #onMouseStillDown.! !!TeapotMorph methodsFor: 'tweak support' stamp: 'ar 4/25/2003 23:10'!onMouseMove	| evt |	evt := ActiveHand lastEvent translatedBy: bounds origin. "offset for morphic"	self mouseMove: evt.	self mouseOver: evt.! !!TeapotMorph methodsFor: 'tweak support' stamp: 'ar 2/11/2003 13:09'!onMouseStillDown	"Transcript show: evt class asString. ----> MouseButtonEvent"	| evt |	self clock forEach: #tick do:[		evt := ActiveHand lastEvent translatedBy: bounds origin. "offset for morphic"		self mouseMove: evt.	].! !!TeapotMorph methodsFor: 'tweak support' stamp: 'ar 4/25/2003 23:10'!onMouseUp	| evt |	self stopScript: #onMouseStillDown.	evt := ActiveHand lastEvent translatedBy: bounds origin. "offset for morphic"	self mouseUp: evt.! !!TeapotMorph methodsFor: 'tweak support' stamp: 'bf 3/11/2004 18:12'!onYellowButtonDown	| evt |	"target := self tweakWorld costume contents detect:[:any| 		any isUnlocked			and:[any isVisible 			and:[any isSticky not			and:[any fullContainsPoint: ActiveHand position]]]	] ifNone:[nil].	target ifNotNil:[^target onContextMenu]."	evt := ActiveHand lastEvent translatedBy: bounds origin. "offset for morphic"	self mouseDown: evt.	self startScript: #onMouseStillDown.! !!TeapotMorph methodsFor: 'tweak support' stamp: 'ar 4/25/2003 23:10'!onYellowButtonUp	| evt |	self stopScript: #onMouseStillDown.	evt := ActiveHand lastEvent translatedBy: bounds origin. "offset for morphic"	^self mouseUp: evt.! !!TeapotMorph methodsFor: 'tweak support' stamp: 'ar 2/11/2003 13:05'!runTweakCycle	| priorHand myWorld |	myWorld := self tweakWorld.	(self extent = myWorld display extent) ifFalse:[		myWorld extent: self extent.	].	priorHand := ActiveHand.	[		myWorld runCroquetCycle.	] ensure:[ActiveHand := priorHand].! !!TeapotMorph methodsFor: 'tweak support' stamp: 'ar 6/12/2003 20:36'!shutdownTweakWorld	"shut down the tweak world - most importantly kill its scheduler"	| myScheduler |	myScheduler := self scriptScheduler.	"Note: scheduler cannot be terminated from within a script so fork off a new process which does the necessary stuff later on"	[myScheduler shutDown] forkAt: Processor userSchedulingPriority.! !!TeapotMorph methodsFor: 'tweak support' stamp: 'ar 2/10/2003 14:57'!tweakCache	^self valueOfProperty: #tweakCache ifAbsentPut:[IdentityDictionary new]! !!TeapotMorph methodsFor: 'tweak support' stamp: 'ar 2/10/2003 14:57'!tweakWorld	^self valueOfProperty: #tweakWorld! !!TeapotMorph methodsFor: 'tweak support' stamp: 'ar 2/10/2003 18:14'!tweakWorld: myWorld	^self setProperty: #tweakWorld toValue: myWorld! !!TeapotMorph methodsFor: 'pda' stamp: 'ar 9/9/2004 12:01'!handleEventData: client	| buf count evt kv |	buf _ String new: 100.	count _ 0.	[client isConnected ifFalse:[^false].	count _ count + (client receiveDataInto: buf).	count = 0 ifTrue:[^false].	count > 0 and:[(buf at: count) = Character cr]] whileFalse:[		client waitForDataUntil: (TSocket deadlineSecs: 5).		(client dataAvailable and:[client isConnected]) ifFalse: [			Transcript cr; show: 'Destroying pda socket for lack of data'.			client destroy.			^false		].	].	evt _ MorphicEvent readFrom: (ReadStream on: buf).	evt ifNil:[^true].	evt isKeyboard ifTrue:[		kv _ evt keyValue.		evt isKeyDown ifTrue:[			kv = 30 ifTrue:[self setProperty: #fwdSpeed toValue: -10].			kv = 31 ifTrue:[self setProperty: #fwdSpeed toValue: 10].			kv = 28 ifTrue:[self setProperty: #turnSpeed toValue: 45].			kv = 29 ifTrue:[self setProperty: #turnSpeed toValue: -45].		].		evt isKeyUp ifTrue:[			kv = 38 ifTrue:[self setProperty: #fwdSpeed toValue: 0].			kv = 40 ifTrue:[self setProperty: #fwdSpeed toValue: 0].			kv = 37 ifTrue:[self setProperty: #turnSpeed toValue: 0].			kv = 39 ifTrue:[self setProperty: #turnSpeed toValue: 0].		].		^true	].	evt isMouse ifFalse:[^self].	evt setHand: ActiveHand.	evt _ evt translatedBy: bounds origin.	evt resetHandlerFields.	self processEvent: evt.	^true! !!TeapotMorph methodsFor: 'pda' stamp: 'ar 9/9/2004 12:01'!runPDAServer	| s client n |	s := TSocket newTCP.	s listenOn: 43421 backlogSize: 4.	n _ 0.	[		[client := s waitForAcceptUntil: (TSocket deadlineSecs: 300).		client == nil] whileTrue.		n _ n + 1.		pdaClient _ client.		'Connection #', n printString displayAt: 500@0.		Display forceToScreen: (500@0 extent: 100@15).	] repeat.! !!TeapotMorph methodsFor: 'pda'!sendImageData: client	| data time sz |	sz _ ByteArray new: 4.	data := self valueOfProperty: #myJpeg.	time _[		data ifNotNil:[			sz longAt: 1 put: data size bigEndian: true.			client sendData: sz, data.		].	] timeToRun.	time printString displayAt: 500@0.	Display forceToScreen: (500@0 extent: 100@15).	client close.! !!TeapotMorph methodsFor: 'pda'!updatePDAClient	| client |	pdaClient ifNil:[^self].	client _ pdaClient.	pdaClient _ nil.	[self updatePDAClient: client] on: Error do:[:x| client destroy].	"client isConnected ifFalse:[pdaClient _ nil]."! !!TeapotMorph methodsFor: 'pda'!updatePDAClient: client	| rcv snd |	client ifNil:[^self].	client isConnected ifFalse:[^self].	"client dataAvailable ifFalse:[^self].	rcv _ [(self handleEventData: client) ifFalse:[^self]] timeToRun."	client isConnected ifFalse:[^self].	snd _ [self sendImageData: client] timeToRun.	('rcv: ', rcv printString, ' snd: ', snd printString,'     ') displayAt: 500@15.! !!TeapotMorph methodsFor: 'testing' stamp: 'ar 9/30/2004 12:50'!makeCylinder: sp	| spinner cylinder |		cylinder _ TCylinder new.	cylinder texture: txtr.	cylinder height: 5.0.	cylinder topRadius: 1.0.	cylinder baseRadius: 1.0.	cylinder translationX: 0.0 y:-2.5 z: 0.0.	spinner _ TSpinner new.	spinner translationX: -5.0 y: 0.0 z:-8.0.	spinner contents: cylinder.	sp addChild: spinner.	! !!TeapotMorph methodsFor: 'scripts-support' stamp: 'ar 7/21/2002 19:13'!scriptScheduler	^self valueOfProperty: #scriptScheduler! !!TeapotMorph methodsFor: 'scripts-support' stamp: 'ar 7/21/2002 19:14'!scriptScheduler: aScriptScheduler	^self setProperty: #scriptScheduler toValue: aScriptScheduler! !!SampleTeapotMorph methodsFor: 'initialize' stamp: 'das 10/3/2004 14:02'!initializeDefaultSpace	| space tframe |	"Create a new space""self makeJIVE."	space _ TSpace new.	"Make a light"	self makeLight: space.	"Make a floor"	self makeFloor: space fileName:'stone.bmp'.	"Make a sky box"	tframe _ TSkyBox new initializeWithFileName: 'MLL'.	space addChild: tframe.	"Make a mirror"	tframe := self makeMirror: space.	tframe := TSpinCube new.	space addChild: tframe.	self makeSpreadSheet: space."	self make3Body: space.""	self makeDungeon:space."	"self makeStartupLink: space."	^space! !!TeaTest methodsFor: 'initialization' stamp: 'ar 9/30/2004 16:12'!initializeDefaultSpace	| space light tframe win|	space _ TSpace new.	space url: 'http://www.reed.com/TeaLand/spaces/intro.tea'."Add a light to the world "	light _ TLight new.	tframe _ TSpinner new.	tframe translationX: -10 y:0.0 z: 0.0.	tframe rotationAroundZ: 120.	tframe matNil.	tframe contents: light.	space addChild: tframe." Create texture to add to the cube.""	txtr _ TTexture				initializeWithFileName: 'checker.bmp'				mipmap: true				shrinkFit: false."" Add a few fun objects. "	self makeFloor: space fileName:'stone.bmp'."	lastLink _ nil.	1 to: 20 do:[:i |		tcube _ TCube new.		tcube scale: (B3DVector3 x: 0.1 y: 0.1 z: 0.1).		tframe _ TLink initializeWithFrame: tcube.		tframe translationX: i/10.0 y: 0 z: 0.		tframe link: lastLink.		i = 1 ifTrue:[tframe mass: nil].		i = 20 ifTrue:[tframe mass: nil].		lastLink _ tframe.		space addChild: tframe.].""	self makeKay: space.	self makeMirror: space.	self makePyramid: space.	self makeClock: space.	self makeUnderwater2: space.	self makeSlime: space.""	self makeMars: space."	self makeGM: space.	self makePopUp: space."	self makeDungeon7: space.""	space addChild: (TTree initializeWithDepth: 4).""	portal _ TPortal new.	win _ TWindow new.	win translationX: -20 y: 0.0 z: -2.0.	win contents: portal.	space addChild: win.	portal linkPortal: glx activeCamera."	tframe _ TParticle new initializeWithSize: 1000.	tframe translationX: 0 y: 0 z: -10.	space addChild: tframe.	^space! !!TeapotMorph class methodsFor: 'as yet unclassified' stamp: 'ar 4/27/2003 23:31'!current	^Current ifNil:[		| xx |		xx := self allInstances.		xx isEmpty ifTrue:[^nil].		Current := xx last]! !!TeapotMorph class methodsFor: 'as yet unclassified' stamp: 'ar 6/11/2003 16:38'!descriptionForPartsBin	^ self partName:	(self name copyFrom: 1 to: self name size - 5 "Morph")		categories:		#('Tea')		documentation:	'Prototype OpenGL Engine test bed.'		sampleImageForm: (Form extent: 220@97 depth: 8 bits: (Base64MimeConverter mimeDecode: '9NfiBf8T//8PJg8mD/8PJg8mJv///8H/E///Jg8P2tSwsLCwsIuwi4sJixOLsLCwsLCw1NraDw8mJv//sf8TJtrUsLCwi4uFi2FhYWBhYAlgG2BhYGBgYGFhYIVhi4WFi4uLsLCwsNoP/6X/D////yYm1LCwi4thhRVgB2BgYGENYAVhC2GLi4uwsNQPnf8b////Jg+wsLCLYWFgYGBgYGBaYGBgYFpgFWAHYWBhYAlgD2BgYGFhYYWLi7DaD5X/D////yYP1LCwi2FhYA1gCmBgYFoNYAdgYWBgFWALYGFhi4uwsA+R/xMm2rCwi4VhYGBgYGBgYGBaDWAHYFpgYA1gCmBgYGEVYAthYWGLi7Am/4n/C/8mD7Cwi2FhFWAPWmBgYGBgYGBgWmBaKWALYWGFsNQm//+B/w////8m1LCLhWFgYGAJYAtaYGBgYGBgWglgJ1pgYGBgYDxgPDw8YGA2PDY8NjY2NjY2NjY2PDY8Njw8PDw8PA1gC2BgYGGFi7APgf8L/w+wsIthYWAVYBtgPGA8YGBgPGBgPDY2NjY2NjY1NTU1NjURNR81NTY2NjY2NjY2NmA8YGBgYGBgYGBhhYWw2ib/ef8L////2rCLhWENYDdgWmBgYDxgPGBgYGA8YGBgNjw2NjY2NTU1NTU1LzU1NTU1WTVaWVpaWn5aflpaWllaWVkvCi81NS8bNTU2NjY2NjxgWmBgYGBgYGGLsA8m////df8LJtqwsIVhYWARYApgYDxgFzw2PDY2NTU1LzU1NTUvWlp+GxwcCRwvHBypHKmpHB8cHKmpHBwcHIQbWlo1NS81NTU2NjY2YGBgYGBgYGBhhbAPJv9x/w////8PsIuFYWBgYGEJYAdgYGBaCmBgPGAFNg82NTUvNS81NVp+GxsJHDccqampH6kfHx8fHw4fDg4fDh8fHx8fHx8fHxypqRwcG35aNS81NTY2NmBgYGBgYGFhi7APcf8L/yawsGFhYGANYC9aYGBgYDxaPGA8NjY2NTU1LzU1Wn4cHBwcHKkcHB8fHx8ODg7UDg8P1A8PDw0PJ9QP1A/UDg7UHw4fH6kfH6kcflk1NTU2NmBgYGBgYGFhsA8m/2n/D////ybasIVhYWBhYA1gX2BgYDxgYDw2NjY1NTUvNVl+GxwcHBypHB8fHw4ODtTUD9QPDyYPJiYmJv//Jv///yb//yYm/yb/JiYmJg8mDw8PD9QP1A4ODh8fHxwcflk1NTY2PGBgYGFhhdQmaf8L//8P1IthYWENYCtgWmBgYGBgYDw2NjU1NS81WRsbHBwcHKkfHx8ODg/UDw8mJiYm////Gf8n////Jv8mJg8mDw8PD9QODh8fHxx+WjU1NjxgYGBgYYUP////Zf83/9qwYYVgYGBgYWBgYGBgYGBgYFpgYGBgPGA2NjY1LzU1Wn4cHBwcHB8fDg7UDw8PDyYm/yn/H///Jv8mDyYPD9QODh8fqVpaNTY2PGBgYGGwJv9h/wv///8P2othYRFgH2BgYDw8NjY1NTU1fhyEHBwcHx8ODg8PDw8m//8x/x////8m/yYPDw8PDg4fH341NjY8PGBghQ8m////Xf8P//8PsIVhYWBhYGBhDWAbYGA2NjY1LzVZGxwcHBwfHw4ODw8P////Pf8XJiYPDw8ODh8bWTU2NjxgYNQm//9d/wv/JrCFYGFgYA1gG2BaYDw8NjY1LzVaGxwcHKkfDg4PDw8mJkH/F////yYmDw/UDg4cWTU2Njw2H///Xf8L2rCFYGFgYGEJYBtaYFpgYGA8PDY1NTVaGxwcHBwfDtQPJiZJ/xP///8PDw/UDqlaNTY2NhwmWf8L////2othYGERYBdgPDY1NTVZHBwcHKkfDg8PDyb//03/E/8mDw/UDoVZNTUvHw////9V/wv//w+FYWBgYA1gF2BgPGA8NjU1NRscGxwfHw4PDyb/Uf8T////Jg8P1A6ENVkODib//1X/K//ai2BgYWBgYGBgYGBgYFpgWmBgYGBgYDY2NVocGxwcqQ7UDyb///9V/w///w8P1A4fH9QP//9V/wvai2FhYGFgYA1gE2BgYDw2NRyEhYWLi7DU2g9Z/w////8mJg8ODtQP//9R/y/////ai2FgYGFgYGBgYGBgYGBaYGBgYGBgYDw8NmBgYWFgYWFhYYWLsLAP/1n/Eyb/Dw8PsLCwi4uLi4uw2g8R/wv/Jib/JiYP/zH/C///D7BhYWBhCWAHWmBgYApgPGA8Fzw2YDw8Njw2PDxgYGFhhbAm////Vf8X///asIuwi2BhYGBhYWFhYYUP//8J/w////8m2rCwsIs8fv8x/wf/D7BhFWAHYDxgNg02Czw2YGBhsCb/Vf8XJrCwhWA8PDw2PDw2PGBgYGA8YA8J/xP///8mi4WFYWA1WSYm////Lf83D9RhYWFgYWBgYGBgYGBgWmBgYGBgYDxgPDw2PDY2NjU1NS81LzU2NjY8PDxgYIsPJv///03/M////w+whTw2NjY2Njw2NmA2PDxgPGA2Nqkm////////////2otgYGA8NS/U1A///y3/C9qLYWBgYWBgDWAjYDxgPDw2NjY1NS4vL1NTU1NTLy82Njw2PDY8hQ8m//9N/wv//w+wYDY2Ngk2Izw8PDZgPGA2Nh8mJv////////8Pi2BgYDYvUx8OD///Kf8L////2rBhYWAJYCtgYFpgYDxgPGA8PDw8PDY1Ly5aHBwcHKkfqRwbNTU2PDxgNjypDyb/Tf8z/w+LYDY2NjY2NTUvLy8vNTU2PDw8PDw8NjUODyb///////8PhWBgYDw1Ux8ODyb/Kf87//8msIVgYGBgYGBgYGBgWmBgYGBgYFpgPGA8PDw2Ly8vhBwcHBwfqR8fHx8OfjY2YDxgNjYfDyZN/zMPsGA2PDY2NS8vLi8vUy9TNTU2NmA8YGA2NjUOD////////w+LYGBgNjVTHA4PJv8p/wf//7CwCWAvYGBaYGBgYDxgPGBgYDY8PDY1LlocHBwfHw4P1A8PD9QODh82YGA8YDY2Dg9J/zf///8msGA8NjY2NS8oWhscHBwcHBwbNjZgYGA8PDY1fg8P///////ahWBgYDY1L6kfDyb/Kf8L/yawi2FgYWANYCtgYDw8PDY8NjUvUxwcHB8O1A8PJib/JiYmD9QfYGBgWjw2ftQP////Rf83////1IU8NjY2NS4vfhwcHBwfHx8fHx9aYGBgPGA2NS8fD///////2otgYGA8L1McHw8m/yn/C/+wi2FgYWBhCWAvYDxgYGA8YDxgNjY2Ly8cGxwf1A8m////////////Jg+pYWBgPDY1H9Qm//9F/zf//w+wYDY2NjYuLxsbHKkfDg7UDw/U1B9gYWBgYDw2NRvUD/////8mhWBaYDY1LxwO1Cb/Kf8H/4uLYAlgG1pgYGA8YDxgPGA8PDw8NjUuGBwcqdQP/wn/E////yYPhWFgYDY1fg4P//9F/zf//9RhNjY2Ni8ufhwcHw7UDyYmJiYmJg+wYGA2NjY2L1oO1Cb///8Pi2BgYDY1Ux8fDyb/Kf8L2rBhYGFgYGAJYBdgYGA8YDw8PDw2Ni8uHBwf1A///w3/D//Ui2FgYDZZDtQP/0X/E/8msGA8NjY1Ly8cHKkODw8J/x8PYDUvLy8vLy8f1A////8PhWBgYDw1L6kO1P//Kf8nsIthYGBgYGBgYFpgYGBgYGA8YDxgPGA2NjY2L1ocqR8PJv//Df8P/w+Li2BgNjUfDg//Rf8T/9qLNjY2NjUufhwcH9Qm/wn/H/+pflpaWVlZfh8OD////w+LYGBgNi9THA7U//8p/weLhWFgDWAXWmA8YDxgPDw2PDUuGxypDg////8N/x///7CwYWA2NRwf1Cb/Jg8m////JtrUsLCwD///Df8P///asLCLi4uw////Cf8nJg8m////D7Cwi4uL1P//////////sGE8NjY2Ly4bHKkOJv//Cf8f//8PDh+pHKmpHw4P////1GFgWmA2NVOpH9T//yn/B2FhYGAJYBtgYGA8YDxgPGA8PDY8Ni8vGxwO1Cb///8N/x///9qwYWA8NVof1P/ai2CE///asIuFYWFgYGCLDf872rCLhWFhYWBgYIUP////////Jg9gNan/Jtqwi2FgYGA2Nqn///////+wYDY2NjYvChypHw8m//8J/x///yYPDg4fHw4O1Cb///8PhWBgYDw1LxwfDyb/Kf8jYYVgYGFgYGBgWmBgYGBgYDxgPGA8PDw8NjYvLxypDiYR/2P//ybahWBgNVmp1P+wYWCL2rBhYDY2Njw8PDw8Ng8m/////////yawsGFgNjY2PDxgYDw2H///////JrA8NoQmsGFgNjY2Njw2NjWpD////w+LYDY2NjUvUxwf1A////8J/x////8mJg8PDw8PJv////8PYWBgYDYvUxwfDyb/Jf8L////JmFhYGAJYBdgYDxgYDxgYDw8YDY2Ni9THKnUDxH/Y////w+LYWA1L6kOD4tgYGGFPDYvNTU1NTY2NjY2NQ8m////////sItgNjUvLzU1NjZgYDY2Dw////8PhWA2i4s2NS8vNS81NjY2NS/UD///2rBgPDY2NS4YHB/UJv///w3/G////yb/////////1IVgYGA2NS8fH9T//yX/J////w9gYGBgYGBgWmBgYGBgYGA8PGA8YDw8Njw2Ni5THKnU/xH/Z////yaLYGA2LxwO2os8YGA2Ly8vU1M1LzU2NjY2NVoPD/////+wi2A1LygvU1NTNTY8YDw2NQ8m///aizxgPDYvLi9TUy81Njw2Ni9aDyb/1ItgNjw2NS5+HB/U////////Dw8NsBdgH///////1IVgWmA2NS8cDtT//yX/B////w8NYBdgPGBgYDw8PDw8NjxgNi9THA7UJhX/g7BgYDUvHB8PYWBgNi4vWqkcqRwcHDY2NjY2L4QPD///2rBgNS4vHKkcHKkchDZgYDY1ftQPJtqFYDY1Li4cqRypqRw2PDw2NS4f1Cawizw2Njw1Ln4cDg//////////D7CFhYuFi4WFi4uFYDUcDyb///8PYWBgYDYvUxwf1P//Jf8L////D2BhYGAJYBdgYFpgWmBgPDw8YDw8Ni9aHB8PJhX/Y4tgYDUvHB/aYVo8NS5+HBwcqR8fHx82YDY2NS8OD/8msGE2Li8cHBwcHx8fH4RhYGA1Lw4PD9RhPDYuL6kcHKkcHx8fYGA2Ly4cDg+wizw2NjY1LxupDg////////8PsAlgG2BgYDYufg8PJv//sIVgYDw8NS+pHw8m/yX/B////w8NYBdgYGA8YDw8YDw8Njw8Ni9THB8P/xX/g4thYDUvHA7aYWA2L1McHKkfDg/UD9SpYGA2NS8cDg/UsGA1Ln4cHKkfDtTU1NSLi2A2NRsOD7BhPDUuWhscHB8O1A/UhWE8NS4bHw+wi2A8NjY2LlocDg////////8msGE8YGA8YGBgYGBgNi9+H9QP///UYWBgYDYvUxwO1Cb/Jf8n////JmBgYGBgYGBaYGBgYGBgPGA8YDw8YDw8YDw2NS4cHw8mFf+DhWA8L1McH7BhPC8uGxypHw8PDyYmDw9hYDY2L1oOD7CLNi8uHBwcDtQPJiYmD9SwYTYvUw7UsIU2Ly4cHBwODw8mJiawizw1Lhup1NSLYDY8NjYuWanUD////////9RgNjU1NTU2PGBaYGA2L1qpHw///9SFYGBgNjUvHB8PJv8p/yM2YGBgWmBgYGBgYGBgPGBaYDxgPDxgYDZgPDUvHB8PJhH/h////yaFYDYvWhwOsGE2NS8cHKnUD///////JrBhYDYvLx+wsGE2NTWpqbCwsNTU2traJiZhNjUvHw6wYTYvLxwcDtQm/////7CLPDUufqkOsItgPDZgNjUvHx8P////////hTUvLy8vLy88YWBgYDYvfhwOD///sGFgYGA2NVMcDtT//yn/BzZgYGAJYAo8YDxgD2BgPGA8PDYuGx/UJhH/X////w9hYDYvGxwfsGE2L1kcHA4P/////////9SFYDYvL6kfsGA8NmBhi4WwsIuwqbCw2otgPDUuHA6wYTYuUxwfDg///////7CLPDUufqkOD4VhPDY8NjUuHA4PCf8jDw6pHBwcD4tgYGA2L1ocHw//JrBhYGA8Ni9TqR8PJv8p/wdaYGBaDWATWmA8YDxgPGA8YDYvWh8PDxH/L////7BgYDUuHBwOsGA2LlocHw4P/////////yZhYDY1LhywsGBgPDxgYGBgCmBhYGBTYDY1LhwfsGE2L1OpqdQm///////Uizw1Ln4cDg+LYWBgNjw1Lxsf1Cb/////////Dw4fHx+p/7BgYFo2L1ocDg///7BhYGA8PC8vHB/U//8p/w+pNmBgYGBgYGA8YGAKYDxgPA9gYGA8YDw8NS8fDg8R/4f///+LYDY1LxwcDrBhNi9aHB8O//////////8mi2A2Ly8cH4tgPDY2NTU2NjY2NjY2NTY1NTUvLoQfsGE2LlOpHw8m//////+wizw1Ln6pDg+wYWA2YDY2NS8fDg//////////Dw/U1A4P/4tgYGA2L1ocHw///7BhYGBgNi9TqQ4PJv8p/wcmNTZgCWAXPGBaYGBgYGBgYDxgPGBgNi9+Dg8R/4f//w9hYDYuWRwfDotgNi9aqR8P//////////8Pi2A2NS4csLBgPDUuLy8vLi4vLi8vLy4vLy8vLhwfsGE2Ly8cH9Qm///////Ui2A1LhscDg8PhWBgNmA8NjUb1A////////////8m/yb/JmFgYGA2L1qpDg///7BhPGA8NjVTHB8PJv8p/yf/LzY8YGBgYFo8YGBgPGBgYGBgYGA8WmBgYDw8NjUf1Cb///8N/2P//4tgPC8uHBwfDrBgNjVTHx8P//////////8mi2A2Ly8cqYthNi9THBwcqakcqRwcHKkcHBwcqakfi2E1LlOpHw/////////Uizw1Ln6pDg//i2A8YDw8NjY1H9Qm//8J/x///7BgYGBaNi9aHB8P/yawYWA8YDYvLxwfDyb/Kf8L/xw1NjxgYGAJYAdgYDxgCWALNjUbDg////8N/2P/1GBgNi5THBwf2otgNjUuqR/U///////////asGA2L1McH4thPDUvHBypHBwfqR8fH6kfH6mpHKkOsGE2L1OpHw/////////ai2A1Ln4cDg//1GBgYDY8PDY2Ng4P//8J/x//D4VgYGBgNi9+HA4P//+wYTxgPDYvU6kfD///Kf8T//8vNjY8YGBgYGA8YGBgYApgPGBgBWALYDY2hA8P//8N/2MPYWA2Li8cHB8OD4tgNjUvGx8PJv/////////UhTw1Ln4cH4uLPDYvGxwfDg4O1A7UDtQmsGE2NdSwi2A2LlMcHw8m///////Uizw1Ln6pDg8m/2FgYDxgYGA2NjaFD/8J/zcPYWBaYGBgNi9aHB8P/yawYGA8PDY1L6mFDtQPDw8mDyYPJg8mJg8P////////JqkYGx//Ef8T//+pLzZgPGBgYGBgPGBgYA1gC2BgPDaFDyb/Cf+H////D4VgNjUufhupHw8Pi2A2NjUvH9QP////////D7BgNi8vHBwfi4VhNjVZHx8PJg8mJg8mJg9hNi5aDtSwYDYvU6kf1P///////9SLYDUuGxwOD/8mJjxgYDw8PGA8YGBgi7DaJg//JiawYWBgYGBgYDYvWhwOD/8msGE8PDw8NmBhCYsFsBOwsGA1//////8PGA7/Jql+Ef8L////LzY2YGAZYAdghQ8mCf+n//8Pi2A8NS9THByp1A8Pi2A2NjU1Ng4P////////1Is8Ni9THKkO1IVhYDY2ftQPJv//////Jos2Ly4fHw6wYDYvUxwODyb//////9qLYDUufqkOD////w42PGA8YDxgYGBhhYuLsLCwsItgYDY2NmBgYDYvWhwfD///sGBgPDw8PDxgYGBgYGBgYWFhYWFhhWE1Lw//////GCYYfhgODhz///8N/w////8cLzY2YGBgWmANYLtgYFpgWmBgYGBhhYuwDyb//////yawYWA8NS4uHBwcHw//D4tgNjY2NjU2Hw8m//8P1ItgNi8ohBypDg+LYGBgYDaEsA//////D7BgNS5THx8Oi2A1LlOpHw8m///////Ui2A1Ln6pDib/////HzY8PGBgYGBgYGBgYWFhYGBgYDY1Li9hYGA2L34cDg//JrBhPDw8PDw8PDZgYDw8PGA8YGBgYGBgL1MP////Hx//C/8mC/8Y////Ef/PNTU2NmA8YGBgYGBgYFpgYGBgWmA8YGBgYGBgYGBhYYWLsLCwsLCwi2FgYDY1Li8cGxwfDg//D4tgNjY1NjY2YGBhhYuLhWA2Ly5+HBwfDyYmYGBgYGBhYYuLsLCwi2A1Ly4cHB8Oi2A2L1McDtT////////Ui2A1Ln4cDg//////Jh82NjY8YDxgYGBgYGBgYGBgNjUuWRyLYWA2L1ocHw//JotgPDw8PDY2PDw2PGA8PDxgYGBgYGBgNVMf////HA//ChwYDv8cD///Ef8XDy81NjxgYGBaYFpgYGBgYFpgYGAJYI9gYGBhYWFhYYVhYGBgNjUvLlMcHBwfDib///+FPDYvLy82NjZgYGBgYDY2Ly5THBwfDg8m/w82PDZgYGBhYWFhYDY1Li4bHKkfsItgNS9TqR8P////////sItgNS5+HA4P//////8mDlo1NjY8PGBgYDxgPGA2NS4uWhwcsGA2Ni5+HA4P/w+LYDY2NhE2FzY2Ly8O////HNT/Cw8cHP9+////Ef8T/xwvNjZgYGBgYGBgYGBgWg1gi2A2YDxgYGBgYGA2NjUvLi9+HBwcHw4PJv//JmFgNS9TWTU1NTY2NjU1NS8oWhwcqR8PJv//Jg42NjY2NjY2NjU1Li4vGxwcqdQPYDYvLi+pHw8m///////UYDUvLhupDg///////yYPD6k2NTU1NjY2NjY1NS8uL34cHBxhNTUvL1qpDg//JjYNLx81Ly8vLzUvLzUvLi8O////Dxv/C/8PGCYY////Ef/P//81NTY8YGBgYGBgYFpgYGBgWmBgYGBgYGBgYTY1NjY2NjY2NjU1Ly8vfhwcHBwfDg8m////JoVgNS9ZHH4vNS8vLy8uLlOEHBypH9QP/////yYPHDUvNTUvLy4uL1kcHBypDg8PNS4vLlOpHw////////+LNS4vLn4cDg////////8mDw8fqVovNS8vLy8vLi9+HBwcHB8fhH5+foQcHw//JouFhH5+Wn5aWlpaWlpaWlp+WlpaWn5aWoQf/////xwc////JhgP////Ef8L////Ly82NjwVYK9gNht+WVlZNVlZfhsbHBwcHB8ODib//////yaLPDYuUxwcqRwbfn5+GxwcHBwcHw8P////////JtTUHxsbWn5+GxwcHBypDtQm/yYPH6mpqQ4P/////////ybUH6kcHw4m//////////8PDw4OH6kchBwbGxwcHBwcHw4PDw/UHx+pDtQP////D9QfqakcqakfqRwfHBwfHB8fHB8cH6kfDv//////HxgYfn4PFf8T//8mDy81Njw8YGBgYGBaYA1gB2BgYIQKHKkcHCccqR8fDg8PD////////yZhPDUvU6kcHx8OHx8cqRypqR8ODw8J/28mDw4OHx8cqakcHx8ODw8m////JtQfHx8PD/////////8mDw4fHw4PJv///////////yYmD9QOHx8fqampHx8fDg8PDyYmD9TUDg4PJv///yYPDg4ODh8ODh8ODg4ODg4fDg4fDh8O1A////8d/wv///8mDi81NglgB1pgYGAJYDNhYGBhYRwcHx8fHx8fDg4PDyb///////////9hYDUuWakfDtTU1A4ODg4O1A8P/yYJ/yv/Jg8P1A4ODh8ODtQPD///////Jg8P1NQmJv//////////Jg8P1A8PCf8n/7Bg/w8PDw/UDtQODtTUDw8P/////yYmDw8PJv//////DyYPFQ8HJv///yH/D/8fLzU2NmBgYGBaYAlgF2BhYGBgYGBhYWGpDg4P1NQPDw8PCf8b////YWA1L1mpHw8P/yYPDw8PDyYm////Cf8b////Jg8PDw8PDw8mJv//////////JiYmCf8L////JiYm//8J/xMPYC8PDyYmJiYPDw8mJg8mCf8H/yb//xH/D/8m//////////8m/yX/C/8mDy81NjZaFWAPYGFhYYsPD/8m////Cf8P//8mhTw2LlkcHw8mQf8P//8msDUuHA8PJv//Vf8L//8mDi81NTYJYApgYGBhBWALYGBgYYWFsCYN/w///yaFYDYvWakf1P9B/w8mJmEvLoQODg4P//9V/w////8mD1kvNjY2YGAVYAtgYWGFsCb//wn/D///JmA2NS4LHx/U/z3/E///Jg+wNi8uHA4fH9QP//9Z/xMPDxsvNTY2YGBgYGBgYWBhCmBhYGAJYBtgYbDaJv///////////yY2Ly8uWRwfDyY5/xf///8mD9SLPC8uUx8fqR8O1Cb//1n/E/8PDx8vLzU2PDxgYGBgYWANYB9aYDxgYGBgYYuwJv//////////DrAcG4SpDg//Of8T/ybasItgNi8uWh8cqR8O1F3/H///Jg/UWi81Njw8YWBgYGFgYWBhYGBgYGBgWmAJYBdgYYWLsCb///////8PDg4fHw4P/zX/F///D9qwsGFgNjUuLxwcHKkfDg//Xf8P////Jg8PHC8vNTY2FWAbPGBgYGBgYIWFYYuwD////yYPDg4ODyb/Mf8b//8PD7Cwi2FhYDY2Ly5TqRypHA4ODyb/Yf83/w/U1H4vNTU2PGBgYGFgYGBgYFpgYGBgYGBaPGBgYGA8PGBgYGBhYYWLsLAPDw8PDyb//y3/H/8mD9TUsLCLYWFgYDw2NS4vGxwcHKkODw8m//9h/w///yYP1B9ZNTU1NjYRYBs8YGBgYGA8YDxgPGBgYWBhi4uwsNoP//8p/x8mD9SwsLCwhYVhYGBgYDY2Ly4vfhwcHBwf1A8maf8PDw/UHC8vNTU2Njw8EWAbWjxgPGA8YDw8PGBgYGBhi4uwi7DUDw//Hf8n//8mD9qwsIuwsIuLYWBgYGBgYDw8NjUvL1kcHBwcHw7UDyb/af93/w8P1A4cLy81NTY2NmBgYGBgYGBgWmBgPGA8YGBgYGBgYDxgYDxgPGBgYGBgYWGLi4uwsLCwsNTaDw8PJiYm////////JiYmJg8P2tqwsLCwsIuLi4uFhWBgYGBgWmBgYGA2NjUvLlkcHBypHA4ODw////9p/xf///8PD9QOqVo1LzU1NjY2PDxgPA1gBzxgYGANYAtgYGFghWGFiwmLF4uwi7CLi4uLi4uFYYVhYWFhYGBgCWAXPGA8NjY1Ly8vWhscHBwfH9QPJv9x/xf/Dw8ODh9aLzUvNTU2NjY8PGBgWglgD2BgPGBgYGBgYGBaYBFgB2GFYGEKYGFgYAlgBzxgPDwKPGBgPBdgNjY1Ly8vfhwcHBwfHw4PDyb//3H/K///Jg8PDh8fGzUvLzU1NjY2NjxgYFpgYFpgYGBgYGBgYGBaYFpgYGAlYB9gPGBgYGBgYGA8NjY1Ly8uWRscHBwcHA7U1A8mef8bJg8P1A4OHFovLy8vNTU2NjY2PGBgYDxgKWAnWmBgYGBgYDxgPDw8PDY2NjY1Ly4vL1ocHBwcqR8f1A8PJv//ef8n//8mJg/UDg4OqX41Ly8vNTU1NjY2Njw2YFo8YGBgYFpgYFpgFWArYGBaYGBaYGBgYGA8YGA8PDY2NjY1NS8vLy8vGxwcHBypqR8O1A8PJoH/H/8PJg/UDh8fqX5ZLy8vNS81NTY2NjY2NjxgPGANYAdgYGBhCWArWmBgYGBgYGBgPDw2NjY2NjU1NS8vLy9ZGxwcHBwcHx8O1A8PJib//4H/W////yYmDw/UDg4fHxt+Ly8vLy81NTU1NjY2NjY2NjZgPDxgYGBaYGBgYGBgWmBgWmBgYGBgPDw8PDY2NjY2NTU1NS8vLy8vWX4bHBwcHKkfHw4O1A8PJv+J/x///yYPD9TUDg4fHx8cflkvLy8vLy8vNTU1NTY2FTYnNjY1NTU1LzUvLy8vLy8vWhscHBwcHBypHw4O1NQPJiYm////jf8f/yb/Dw/UDg4fDh8fHByEG1pZUy8vLy4vLy81Lw01BzUvNS8JLxdZfn4bHBwcHBypHB8fHw4O1A8PD5n/Q///Dw8P1NQODh8fHx8fqakcHBt+flpaWVNTLy8vLy8vUy9TLy9ZWVpaWn4bGxwcHBypHBwcqakfHw4ODtQPDw+h/z///w8mDw/UDw4ODh8fH6kfqakcqRypqRypHBwcHBypHBwcHBwcHBypqRwfH6kfHw4ODtTU1A8PJv8m//+l/zcm/yYPDw8PDw/U1A4ODg4fDh8fDh8fHw6pHx8fHx8fHw4fDg4fDg7U1NQPDw8PD/8m////sf8FJiMmDw8PDw8PDw/U1A8P1A/U1A8PDw8PDw8PDyYmJv///+TB/w==' as: String) asByteArray).! !!TeapotMorph class methodsFor: 'as yet unclassified'!includeInNewMorphMenu	^true! !!TeapotMorph class methodsFor: 'as yet unclassified' stamp: 'ar 10/26/2002 00:50'!loadIcon2: iconName	^self loadIcon: iconName defaultExtent: 128@128! !!TeapotMorph class methodsFor: 'as yet unclassified' stamp: 'ar 10/11/2002 23:15'!loadIcon: iconName	| iconFile icon |	iconFile := [(FileDirectory default directoryNamed: 'icons') readOnlyFileNamed: iconName]		on: Error do:[:ex| ex return: nil].	iconFile ifNil:[^Form extent: 11@11 depth: 8].	icon := Form fromBinaryStream: iconFile.	icon mapColor: Color white to: Color transparent.	iconFile close.	^icon! !!TeapotMorph class methodsFor: 'as yet unclassified' stamp: 'ar 10/26/2002 00:50'!loadIcon: iconName defaultExtent: defaultExtent	| iconFile icon |	iconFile := [(FileDirectory default directoryNamed: 'icons') readOnlyFileNamed: iconName]		on: Error do:[:ex| ex return: nil].	iconFile ifNil:[^Form extent: defaultExtent depth: 8].	icon := Form fromBinaryStream: iconFile.	iconFile close.	^icon! !!TeapotMorph class methodsFor: 'as yet unclassified' stamp: 'bf 9/16/2004 12:17'!startFullScreen	| tm |	Display fullScreenMode: true.	Display newDepth: Display depth.	DisplayScreen checkForNewScreenSize.	Project current flapsSuppressed: true.	World doOneCycleNow.	tm _ self new.	tm bounds: World bounds.	World addMorph: tm.	tm handleEvent: ActiveHand lastEvent asMouseMove resetHandlerFields.	tm removeProperty: #openTeaFileOnDrop.	WorldState addDeferredUIMessage:[tm requestInitialSpace].! !!SampleTeapotMorph class methodsFor: 'new-morph participation' stamp: 'ar 6/11/2003 16:37'!descriptionForPartsBin	^super descriptionForPartsBin! !!TeaTest class methodsFor: 'as yet unclassified' stamp: 'das 6/11/2002 15:28'!descriptionForPartsBin	^ self partName:	'Tea Test Morph'		categories:		#('Tea')		documentation:	'Tea demonstration test bed.'		sampleImageForm: (Form extent: 220@97 depth: 8 bits: (Base64MimeConverter mimeDecode: '9NfiBf8T//8PJg8mD/8PJg8mJv///8H/E///Jg8P2tSwsLCwsIuwi4sJixOLsLCwsLCw1NraDw8mJv//sf8TJtrUsLCwi4uFi2FhYWBhYAlgG2BhYGBgYGFhYIVhi4WFi4uLsLCwsNoP/6X/D////yYm1LCwi4thhRVgB2BgYGENYAVhC2GLi4uwsNQPnf8b////Jg+wsLCLYWFgYGBgYGBaYGBgYFpgFWAHYWBhYAlgD2BgYGFhYYWLi7DaD5X/D////yYP1LCwi2FhYA1gCmBgYFoNYAdgYWBgFWALYGFhi4uwsA+R/xMm2rCwi4VhYGBgYGBgYGBaDWAHYFpgYA1gCmBgYGEVYAthYWGLi7Am/4n/C/8mD7Cwi2FhFWAPWmBgYGBgYGBgWmBaKWALYWGFsNQm//+B/w////8m1LCLhWFgYGAJYAtaYGBgYGBgWglgJ1pgYGBgYDxgPDw8YGA2PDY8NjY2NjY2NjY2PDY8Njw8PDw8PA1gC2BgYGGFi7APgf8L/w+wsIthYWAVYBtgPGA8YGBgPGBgPDY2NjY2NjY1NTU1NjURNR81NTY2NjY2NjY2NmA8YGBgYGBgYGBhhYWw2ib/ef8L////2rCLhWENYDdgWmBgYDxgPGBgYGA8YGBgNjw2NjY2NTU1NTU1LzU1NTU1WTVaWVpaWn5aflpaWllaWVkvCi81NS8bNTU2NjY2NjxgWmBgYGBgYGGLsA8m////df8LJtqwsIVhYWARYApgYDxgFzw2PDY2NTU1LzU1NTUvWlp+GxwcCRwvHBypHKmpHB8cHKmpHBwcHIQbWlo1NS81NTU2NjY2YGBgYGBgYGBhhbAPJv9x/w////8PsIuFYWBgYGEJYAdgYGBaCmBgPGAFNg82NTUvNS81NVp+GxsJHDccqampH6kfHx8fHw4fDg4fDh8fHx8fHx8fHxypqRwcG35aNS81NTY2NmBgYGBgYGFhi7APcf8L/yawsGFhYGANYC9aYGBgYDxaPGA8NjY2NTU1LzU1Wn4cHBwcHKkcHB8fHx8ODg7UDg8P1A8PDw0PJ9QP1A/UDg7UHw4fH6kfH6kcflk1NTU2NmBgYGBgYGFhsA8m/2n/D////ybasIVhYWBhYA1gX2BgYDxgYDw2NjY1NTUvNVl+GxwcHBypHB8fHw4ODtTUD9QPDyYPJiYmJv//Jv///yb//yYm/yb/JiYmJg8mDw8PD9QP1A4ODh8fHxwcflk1NTY2PGBgYGFhhdQmaf8L//8P1IthYWENYCtgWmBgYGBgYDw2NjU1NS81WRsbHBwcHKkfHx8ODg/UDw8mJiYm////Gf8n////Jv8mJg8mDw8PD9QODh8fHxx+WjU1NjxgYGBgYYUP////Zf83/9qwYYVgYGBgYWBgYGBgYGBgYFpgYGBgPGA2NjY1LzU1Wn4cHBwcHB8fDg7UDw8PDyYm/yn/H///Jv8mDyYPD9QODh8fqVpaNTY2PGBgYGGwJv9h/wv///8P2othYRFgH2BgYDw8NjY1NTU1fhyEHBwcHx8ODg8PDw8m//8x/x////8m/yYPDw8PDg4fH341NjY8PGBghQ8m////Xf8P//8PsIVhYWBhYGBhDWAbYGA2NjY1LzVZGxwcHBwfHw4ODw8P////Pf8XJiYPDw8ODh8bWTU2NjxgYNQm//9d/wv/JrCFYGFgYA1gG2BaYDw8NjY1LzVaGxwcHKkfDg4PDw8mJkH/F////yYmDw/UDg4cWTU2Njw2H///Xf8L2rCFYGFgYGEJYBtaYFpgYGA8PDY1NTVaGxwcHBwfDtQPJiZJ/xP///8PDw/UDqlaNTY2NhwmWf8L////2othYGERYBdgPDY1NTVZHBwcHKkfDg8PDyb//03/E/8mDw/UDoVZNTUvHw////9V/wv//w+FYWBgYA1gF2BgPGA8NjU1NRscGxwfHw4PDyb/Uf8T////Jg8P1A6ENVkODib//1X/K//ai2BgYWBgYGBgYGBgYFpgWmBgYGBgYDY2NVocGxwcqQ7UDyb///9V/w///w8P1A4fH9QP//9V/wvai2FhYGFgYA1gE2BgYDw2NRyEhYWLi7DU2g9Z/w////8mJg8ODtQP//9R/y/////ai2FgYGFgYGBgYGBgYGBaYGBgYGBgYDw8NmBgYWFgYWFhYYWLsLAP/1n/Eyb/Dw8PsLCwi4uLi4uw2g8R/wv/Jib/JiYP/zH/C///D7BhYWBhCWAHWmBgYApgPGA8Fzw2YDw8Njw2PDxgYGFhhbAm////Vf8X///asIuwi2BhYGBhYWFhYYUP//8J/w////8m2rCwsIs8fv8x/wf/D7BhFWAHYDxgNg02Czw2YGBhsCb/Vf8XJrCwhWA8PDw2PDw2PGBgYGA8YA8J/xP///8mi4WFYWA1WSYm////Lf83D9RhYWFgYWBgYGBgYGBgWmBgYGBgYDxgPDw2PDY2NjU1NS81LzU2NjY8PDxgYIsPJv///03/M////w+whTw2NjY2Njw2NmA2PDxgPGA2Nqkm////////////2otgYGA8NS/U1A///y3/C9qLYWBgYWBgDWAjYDxgPDw2NjY1NS4vL1NTU1NTLy82Njw2PDY8hQ8m//9N/wv//w+wYDY2Ngk2Izw8PDZgPGA2Nh8mJv////////8Pi2BgYDYvUx8OD///Kf8L////2rBhYWAJYCtgYFpgYDxgPGA8PDw8PDY1Ly5aHBwcHKkfqRwbNTU2PDxgNjypDyb/Tf8z/w+LYDY2NjY2NTUvLy8vNTU2PDw8PDw8NjUODyb///////8PhWBgYDw1Ux8ODyb/Kf87//8msIVgYGBgYGBgYGBgWmBgYGBgYFpgPGA8PDw2Ly8vhBwcHBwfqR8fHx8OfjY2YDxgNjYfDyZN/zMPsGA2PDY2NS8vLi8vUy9TNTU2NmA8YGA2NjUOD////////w+LYGBgNjVTHA4PJv8p/wf//7CwCWAvYGBaYGBgYDxgPGBgYDY8PDY1LlocHBwfHw4P1A8PD9QODh82YGA8YDY2Dg9J/zf///8msGA8NjY2NS8oWhscHBwcHBwbNjZgYGA8PDY1fg8P///////ahWBgYDY1L6kfDyb/Kf8L/yawi2FgYWANYCtgYDw8PDY8NjUvUxwcHB8O1A8PJib/JiYmD9QfYGBgWjw2ftQP////Rf83////1IU8NjY2NS4vfhwcHBwfHx8fHx9aYGBgPGA2NS8fD///////2otgYGA8L1McHw8m/yn/C/+wi2FgYWBhCWAvYDxgYGA8YDxgNjY2Ly8cGxwf1A8m////////////Jg+pYWBgPDY1H9Qm//9F/zf//w+wYDY2NjYuLxsbHKkfDg7UDw/U1B9gYWBgYDw2NRvUD/////8mhWBaYDY1LxwO1Cb/Kf8H/4uLYAlgG1pgYGA8YDxgPGA8PDw8NjUuGBwcqdQP/wn/E////yYPhWFgYDY1fg4P//9F/zf//9RhNjY2Ni8ufhwcHw7UDyYmJiYmJg+wYGA2NjY2L1oO1Cb///8Pi2BgYDY1Ux8fDyb/Kf8L2rBhYGFgYGAJYBdgYGA8YDw8PDw2Ni8uHBwf1A///w3/D//Ui2FgYDZZDtQP/0X/E/8msGA8NjY1Ly8cHKkODw8J/x8PYDUvLy8vLy8f1A////8PhWBgYDw1L6kO1P//Kf8nsIthYGBgYGBgYFpgYGBgYGA8YDxgPGA2NjY2L1ocqR8PJv//Df8P/w+Li2BgNjUfDg//Rf8T/9qLNjY2NjUufhwcH9Qm/wn/H/+pflpaWVlZfh8OD////w+LYGBgNi9THA7U//8p/weLhWFgDWAXWmA8YDxgPDw2PDUuGxypDg////8N/x///7CwYWA2NRwf1Cb/Jg8m////JtrUsLCwD///Df8P///asLCLi4uw////Cf8nJg8m////D7Cwi4uL1P//////////sGE8NjY2Ly4bHKkOJv//Cf8f//8PDh+pHKmpHw4P////1GFgWmA2NVOpH9T//yn/B2FhYGAJYBtgYGA8YDxgPGA8PDY8Ni8vGxwO1Cb///8N/x///9qwYWA8NVof1P/ai2CE///asIuFYWFgYGCLDf872rCLhWFhYWBgYIUP////////Jg9gNan/Jtqwi2FgYGA2Nqn///////+wYDY2NjYvChypHw8m//8J/x///yYPDg4fHw4O1Cb///8PhWBgYDw1LxwfDyb/Kf8jYYVgYGFgYGBgWmBgYGBgYDxgPGA8PDw8NjYvLxypDiYR/2P//ybahWBgNVmp1P+wYWCL2rBhYDY2Njw8PDw8Ng8m/////////yawsGFgNjY2PDxgYDw2H///////JrA8NoQmsGFgNjY2Njw2NjWpD////w+LYDY2NjUvUxwf1A////8J/x////8mJg8PDw8PJv////8PYWBgYDYvUxwfDyb/Jf8L////JmFhYGAJYBdgYDxgYDxgYDw8YDY2Ni9THKnUDxH/Y////w+LYWA1L6kOD4tgYGGFPDYvNTU1NTY2NjY2NQ8m////////sItgNjUvLzU1NjZgYDY2Dw////8PhWA2i4s2NS8vNS81NjY2NS/UD///2rBgPDY2NS4YHB/UJv///w3/G////yb/////////1IVgYGA2NS8fH9T//yX/J////w9gYGBgYGBgWmBgYGBgYGA8PGA8YDw8Njw2Ni5THKnU/xH/Z////yaLYGA2LxwO2os8YGA2Ly8vU1M1LzU2NjY2NVoPD/////+wi2A1LygvU1NTNTY8YDw2NQ8m///aizxgPDYvLi9TUy81Njw2Ni9aDyb/1ItgNjw2NS5+HB/U////////Dw8NsBdgH///////1IVgWmA2NS8cDtT//yX/B////w8NYBdgPGBgYDw8PDw8NjxgNi9THA7UJhX/g7BgYDUvHB8PYWBgNi4vWqkcqRwcHDY2NjY2L4QPD///2rBgNS4vHKkcHKkchDZgYDY1ftQPJtqFYDY1Li4cqRypqRw2PDw2NS4f1Cawizw2Njw1Ln4cDg//////////D7CFhYuFi4WFi4uFYDUcDyb///8PYWBgYDYvUxwf1P//Jf8L////D2BhYGAJYBdgYFpgWmBgPDw8YDw8Ni9aHB8PJhX/Y4tgYDUvHB/aYVo8NS5+HBwcqR8fHx82YDY2NS8OD/8msGE2Li8cHBwcHx8fH4RhYGA1Lw4PD9RhPDYuL6kcHKkcHx8fYGA2Ly4cDg+wizw2NjY1LxupDg////////8PsAlgG2BgYDYufg8PJv//sIVgYDw8NS+pHw8m/yX/B////w8NYBdgYGA8YDw8YDw8Njw8Ni9THB8P/xX/g4thYDUvHA7aYWA2L1McHKkfDg/UD9SpYGA2NS8cDg/UsGA1Ln4cHKkfDtTU1NSLi2A2NRsOD7BhPDUuWhscHB8O1A/UhWE8NS4bHw+wi2A8NjY2LlocDg////////8msGE8YGA8YGBgYGBgNi9+H9QP///UYWBgYDYvUxwO1Cb/Jf8n////JmBgYGBgYGBaYGBgYGBgPGA8YDw8YDw8YDw2NS4cHw8mFf+DhWA8L1McH7BhPC8uGxypHw8PDyYmDw9hYDY2L1oOD7CLNi8uHBwcDtQPJiYmD9SwYTYvUw7UsIU2Ly4cHBwODw8mJiawizw1Lhup1NSLYDY8NjYuWanUD////////9RgNjU1NTU2PGBaYGA2L1qpHw///9SFYGBgNjUvHB8PJv8p/yM2YGBgWmBgYGBgYGBgPGBaYDxgPDxgYDZgPDUvHB8PJhH/h////yaFYDYvWhwOsGE2NS8cHKnUD///////JrBhYDYvLx+wsGE2NTWpqbCwsNTU2traJiZhNjUvHw6wYTYvLxwcDtQm/////7CLPDUufqkOsItgPDZgNjUvHx8P////////hTUvLy8vLy88YWBgYDYvfhwOD///sGFgYGA2NVMcDtT//yn/BzZgYGAJYAo8YDxgD2BgPGA8PDYuGx/UJhH/X////w9hYDYvGxwfsGE2L1kcHA4P/////////9SFYDYvL6kfsGA8NmBhi4WwsIuwqbCw2otgPDUuHA6wYTYuUxwfDg///////7CLPDUufqkOD4VhPDY8NjUuHA4PCf8jDw6pHBwcD4tgYGA2L1ocHw//JrBhYGA8Ni9TqR8PJv8p/wdaYGBaDWATWmA8YDxgPGA8YDYvWh8PDxH/L////7BgYDUuHBwOsGA2LlocHw4P/////////yZhYDY1LhywsGBgPDxgYGBgCmBhYGBTYDY1LhwfsGE2L1OpqdQm///////Uizw1Ln4cDg+LYWBgNjw1Lxsf1Cb/////////Dw4fHx+p/7BgYFo2L1ocDg///7BhYGA8PC8vHB/U//8p/w+pNmBgYGBgYGA8YGAKYDxgPA9gYGA8YDw8NS8fDg8R/4f///+LYDY1LxwcDrBhNi9aHB8O//////////8mi2A2Ly8cH4tgPDY2NTU2NjY2NjY2NTY1NTUvLoQfsGE2LlOpHw8m//////+wizw1Ln6pDg+wYWA2YDY2NS8fDg//////////Dw/U1A4P/4tgYGA2L1ocHw///7BhYGBgNi9TqQ4PJv8p/wcmNTZgCWAXPGBaYGBgYGBgYDxgPGBgNi9+Dg8R/4f//w9hYDYuWRwfDotgNi9aqR8P//////////8Pi2A2NS4csLBgPDUuLy8vLi4vLi8vLy4vLy8vLhwfsGE2Ly8cH9Qm///////Ui2A1LhscDg8PhWBgNmA8NjUb1A////////////8m/yb/JmFgYGA2L1qpDg///7BhPGA8NjVTHB8PJv8p/yf/LzY8YGBgYFo8YGBgPGBgYGBgYGA8WmBgYDw8NjUf1Cb///8N/2P//4tgPC8uHBwfDrBgNjVTHx8P//////////8mi2A2Ly8cqYthNi9THBwcqakcqRwcHKkcHBwcqakfi2E1LlOpHw/////////Uizw1Ln6pDg//i2A8YDw8NjY1H9Qm//8J/x///7BgYGBaNi9aHB8P/yawYWA8YDYvLxwfDyb/Kf8L/xw1NjxgYGAJYAdgYDxgCWALNjUbDg////8N/2P/1GBgNi5THBwf2otgNjUuqR/U///////////asGA2L1McH4thPDUvHBypHBwfqR8fH6kfH6mpHKkOsGE2L1OpHw/////////ai2A1Ln4cDg//1GBgYDY8PDY2Ng4P//8J/x//D4VgYGBgNi9+HA4P//+wYTxgPDYvU6kfD///Kf8T//8vNjY8YGBgYGA8YGBgYApgPGBgBWALYDY2hA8P//8N/2MPYWA2Li8cHB8OD4tgNjUvGx8PJv/////////UhTw1Ln4cH4uLPDYvGxwfDg4O1A7UDtQmsGE2NdSwi2A2LlMcHw8m///////Uizw1Ln6pDg8m/2FgYDxgYGA2NjaFD/8J/zcPYWBaYGBgNi9aHB8P/yawYGA8PDY1L6mFDtQPDw8mDyYPJg8mJg8P////////JqkYGx//Ef8T//+pLzZgPGBgYGBgPGBgYA1gC2BgPDaFDyb/Cf+H////D4VgNjUufhupHw8Pi2A2NjUvH9QP////////D7BgNi8vHBwfi4VhNjVZHx8PJg8mJg8mJg9hNi5aDtSwYDYvU6kf1P///////9SLYDUuGxwOD/8mJjxgYDw8PGA8YGBgi7DaJg//JiawYWBgYGBgYDYvWhwOD/8msGE8PDw8NmBhCYsFsBOwsGA1//////8PGA7/Jql+Ef8L////LzY2YGAZYAdghQ8mCf+n//8Pi2A8NS9THByp1A8Pi2A2NjU1Ng4P////////1Is8Ni9THKkO1IVhYDY2ftQPJv//////Jos2Ly4fHw6wYDYvUxwODyb//////9qLYDUufqkOD////w42PGA8YDxgYGBhhYuLsLCwsItgYDY2NmBgYDYvWhwfD///sGBgPDw8PDxgYGBgYGBgYWFhYWFhhWE1Lw//////GCYYfhgODhz///8N/w////8cLzY2YGBgWmANYLtgYFpgWmBgYGBhhYuwDyb//////yawYWA8NS4uHBwcHw//D4tgNjY2NjU2Hw8m//8P1ItgNi8ohBypDg+LYGBgYDaEsA//////D7BgNS5THx8Oi2A1LlOpHw8m///////Ui2A1Ln6pDib/////HzY8PGBgYGBgYGBgYWFhYGBgYDY1Li9hYGA2L34cDg//JrBhPDw8PDw8PDZgYDw8PGA8YGBgYGBgL1MP////Hx//C/8mC/8Y////Ef/PNTU2NmA8YGBgYGBgYFpgYGBgWmA8YGBgYGBgYGBhYYWLsLCwsLCwi2FgYDY1Li8cGxwfDg//D4tgNjY1NjY2YGBhhYuLhWA2Ly5+HBwfDyYmYGBgYGBhYYuLsLCwi2A1Ly4cHB8Oi2A2L1McDtT////////Ui2A1Ln4cDg//////Jh82NjY8YDxgYGBgYGBgYGBgNjUuWRyLYWA2L1ocHw//JotgPDw8PDY2PDw2PGA8PDxgYGBgYGBgNVMf////HA//ChwYDv8cD///Ef8XDy81NjxgYGBaYFpgYGBgYFpgYGAJYI9gYGBhYWFhYYVhYGBgNjUvLlMcHBwfDib///+FPDYvLy82NjZgYGBgYDY2Ly5THBwfDg8m/w82PDZgYGBhYWFhYDY1Li4bHKkfsItgNS9TqR8P////////sItgNS5+HA4P//////8mDlo1NjY8PGBgYDxgPGA2NS4uWhwcsGA2Ni5+HA4P/w+LYDY2NhE2FzY2Ly8O////HNT/Cw8cHP9+////Ef8T/xwvNjZgYGBgYGBgYGBgWg1gi2A2YDxgYGBgYGA2NjUvLi9+HBwcHw4PJv//JmFgNS9TWTU1NTY2NjU1NS8oWhwcqR8PJv//Jg42NjY2NjY2NjU1Li4vGxwcqdQPYDYvLi+pHw8m///////UYDUvLhupDg///////yYPD6k2NTU1NjY2NjY1NS8uL34cHBxhNTUvL1qpDg//JjYNLx81Ly8vLzUvLzUvLi8O////Dxv/C/8PGCYY////Ef/P//81NTY8YGBgYGBgYFpgYGBgWmBgYGBgYGBgYTY1NjY2NjY2NjU1Ly8vfhwcHBwfDg8m////JoVgNS9ZHH4vNS8vLy8uLlOEHBypH9QP/////yYPHDUvNTUvLy4uL1kcHBypDg8PNS4vLlOpHw////////+LNS4vLn4cDg////////8mDw8fqVovNS8vLy8vLi9+HBwcHB8fhH5+foQcHw//JouFhH5+Wn5aWlpaWlpaWlp+WlpaWn5aWoQf/////xwc////JhgP////Ef8L////Ly82NjwVYK9gNht+WVlZNVlZfhsbHBwcHB8ODib//////yaLPDYuUxwcqRwbfn5+GxwcHBwcHw8P////////JtTUHxsbWn5+GxwcHBypDtQm/yYPH6mpqQ4P/////////ybUH6kcHw4m//////////8PDw4OH6kchBwbGxwcHBwcHw4PDw/UHx+pDtQP////D9QfqakcqakfqRwfHBwfHB8fHB8cH6kfDv//////HxgYfn4PFf8T//8mDy81Njw8YGBgYGBaYA1gB2BgYIQKHKkcHCccqR8fDg8PD////////yZhPDUvU6kcHx8OHx8cqRypqR8ODw8J/28mDw4OHx8cqakcHx8ODw8m////JtQfHx8PD/////////8mDw4fHw4PJv///////////yYmD9QOHx8fqampHx8fDg8PDyYmD9TUDg4PJv///yYPDg4ODh8ODh8ODg4ODg4fDg4fDh8O1A////8d/wv///8mDi81NglgB1pgYGAJYDNhYGBhYRwcHx8fHx8fDg4PDyb///////////9hYDUuWakfDtTU1A4ODg4O1A8P/yYJ/yv/Jg8P1A4ODh8ODtQPD///////Jg8P1NQmJv//////////Jg8P1A8PCf8n/7Bg/w8PDw/UDtQODtTUDw8P/////yYmDw8PJv//////DyYPFQ8HJv///yH/D/8fLzU2NmBgYGBaYAlgF2BhYGBgYGBhYWGpDg4P1NQPDw8PCf8b////YWA1L1mpHw8P/yYPDw8PDyYm////Cf8b////Jg8PDw8PDw8mJv//////////JiYmCf8L////JiYm//8J/xMPYC8PDyYmJiYPDw8mJg8mCf8H/yb//xH/D/8m//////////8m/yX/C/8mDy81NjZaFWAPYGFhYYsPD/8m////Cf8P//8mhTw2LlkcHw8mQf8P//8msDUuHA8PJv//Vf8L//8mDi81NTYJYApgYGBhBWALYGBgYYWFsCYN/w///yaFYDYvWakf1P9B/w8mJmEvLoQODg4P//9V/w////8mD1kvNjY2YGAVYAtgYWGFsCb//wn/D///JmA2NS4LHx/U/z3/E///Jg+wNi8uHA4fH9QP//9Z/xMPDxsvNTY2YGBgYGBgYWBhCmBhYGAJYBtgYbDaJv///////////yY2Ly8uWRwfDyY5/xf///8mD9SLPC8uUx8fqR8O1Cb//1n/E/8PDx8vLzU2PDxgYGBgYWANYB9aYDxgYGBgYYuwJv//////////DrAcG4SpDg//Of8T/ybasItgNi8uWh8cqR8O1F3/H///Jg/UWi81Njw8YWBgYGFgYWBhYGBgYGBgWmAJYBdgYYWLsCb///////8PDg4fHw4P/zX/F///D9qwsGFgNjUuLxwcHKkfDg//Xf8P////Jg8PHC8vNTY2FWAbPGBgYGBgYIWFYYuwD////yYPDg4ODyb/Mf8b//8PD7Cwi2FhYDY2Ly5TqRypHA4ODyb/Yf83/w/U1H4vNTU2PGBgYGFgYGBgYFpgYGBgYGBaPGBgYGA8PGBgYGBhYYWLsLAPDw8PDyb//y3/H/8mD9TUsLCLYWFgYDw2NS4vGxwcHKkODw8m//9h/w///yYP1B9ZNTU1NjYRYBs8YGBgYGA8YDxgPGBgYWBhi4uwsNoP//8p/x8mD9SwsLCwhYVhYGBgYDY2Ly4vfhwcHBwf1A8maf8PDw/UHC8vNTU2Njw8EWAbWjxgPGA8YDw8PGBgYGBhi4uwi7DUDw//Hf8n//8mD9qwsIuwsIuLYWBgYGBgYDw8NjUvL1kcHBwcHw7UDyb/af93/w8P1A4cLy81NTY2NmBgYGBgYGBgWmBgPGA8YGBgYGBgYDxgYDxgPGBgYGBgYWGLi4uwsLCwsNTaDw8PJiYm////////JiYmJg8P2tqwsLCwsIuLi4uFhWBgYGBgWmBgYGA2NjUvLlkcHBypHA4ODw////9p/xf///8PD9QOqVo1LzU1NjY2PDxgPA1gBzxgYGANYAtgYGFghWGFiwmLF4uwi7CLi4uLi4uFYYVhYWFhYGBgCWAXPGA8NjY1Ly8vWhscHBwfH9QPJv9x/xf/Dw8ODh9aLzUvNTU2NjY8PGBgWglgD2BgPGBgYGBgYGBaYBFgB2GFYGEKYGFgYAlgBzxgPDwKPGBgPBdgNjY1Ly8vfhwcHBwfHw4PDyb//3H/K///Jg8PDh8fGzUvLzU1NjY2NjxgYFpgYFpgYGBgYGBgYGBaYFpgYGAlYB9gPGBgYGBgYGA8NjY1Ly8uWRscHBwcHA7U1A8mef8bJg8P1A4OHFovLy8vNTU2NjY2PGBgYDxgKWAnWmBgYGBgYDxgPDw8PDY2NjY1Ly4vL1ocHBwcqR8f1A8PJv//ef8n//8mJg/UDg4OqX41Ly8vNTU1NjY2Njw2YFo8YGBgYFpgYFpgFWArYGBaYGBaYGBgYGA8YGA8PDY2NjY1NS8vLy8vGxwcHBypqR8O1A8PJoH/H/8PJg/UDh8fqX5ZLy8vNS81NTY2NjY2NjxgPGANYAdgYGBhCWArWmBgYGBgYGBgPDw2NjY2NjU1NS8vLy9ZGxwcHBwcHx8O1A8PJib//4H/W////yYmDw/UDg4fHxt+Ly8vLy81NTU1NjY2NjY2NjZgPDxgYGBaYGBgYGBgWmBgWmBgYGBgPDw8PDY2NjY2NTU1NS8vLy8vWX4bHBwcHKkfHw4O1A8PJv+J/x///yYPD9TUDg4fHx8cflkvLy8vLy8vNTU1NTY2FTYnNjY1NTU1LzUvLy8vLy8vWhscHBwcHBypHw4O1NQPJiYm////jf8f/yb/Dw/UDg4fDh8fHByEG1pZUy8vLy4vLy81Lw01BzUvNS8JLxdZfn4bHBwcHBypHB8fHw4O1A8PD5n/Q///Dw8P1NQODh8fHx8fqakcHBt+flpaWVNTLy8vLy8vUy9TLy9ZWVpaWn4bGxwcHBypHBwcqakfHw4ODtQPDw+h/z///w8mDw/UDw4ODh8fH6kfqakcqRypqRypHBwcHBypHBwcHBwcHBypqRwfH6kfHw4ODtTU1A8PJv8m//+l/zcm/yYPDw8PDw/U1A4ODg4fDh8fDh8fHw6pHx8fHx8fHw4fDg4fDg7U1NQPDw8PD/8m////sf8FJiMmDw8PDw8PDw/U1A8P1A/U1A8PDw8PDw8PDyYmJv///+TB/w==' as: String) asByteArray).! !!TeaTest class methodsFor: 'as yet unclassified' stamp: 'das 6/11/2002 15:27'!includeInNewMorphMenu	^true! !!TextStyle methodsFor: '*Croquet' stamp: 'ar 6/7/2002 13:35'!marginTabs	^marginTabsArray! !!TextStyle methodsFor: '*Croquet' stamp: 'ar 6/7/2002 13:35'!prepareToExportOn: exporter	| style |	style := TextStyle named: (self defaultFont familyName).	fontArray := fontArray collect:[:font|		DiskProxy global: #StrikeFont selector: #familyName:size:emphasized:			args: (Array with: font familyName with: font height with: font emphasis).	].	style ifNotNil:[		style tabsArray == self tabsArray ifTrue:[tabsArray := nil].		style marginTabs == self marginTabs ifTrue:[marginTabsArray := nil].	].! !!TextStyle methodsFor: '*Croquet' stamp: 'ar 6/7/2002 13:34'!tabsArray	^tabsArray! !!Time class methodsFor: '*Croquet' stamp: 'das 10/18/2002 15:10'!uniqueMicrosecondClockValue	| t |	LastMicroSecond isNil ifTrue:[LastMicroSecond _ 0.].	t _ self millisecondClockValue * 1000.	t <= LastMicroSecond ifTrue:[ t _ LastMicroSecond + 1.].	LastMicroSecond _ t.	^ t."	On my 0.9 GHz PC, the following code almost always had the variable mx at 39, and never more than that. This means that in one million runs, I never even came close to approaching an overflow of the true millisecond counter, which would have required mx to approach 1000.This does NOT mean that this is a good way to do this. It works for now. Once we have a true microSecond counter we may want to consider this approach to ensure unique event times.	mx _ 0.	1 to: 1000000 do:[:i | mx _mx max: (Time uniqueMicrosecondClockValue-(Time millisecondClockValue*1000)).].	mx. 39"! !!True class methodsFor: '*Croquet' stamp: 'ar 6/5/2002 21:42'!teaImportLiteralFrom: byteStream	^true! !!TweakTeapotMorph methodsFor: 'initialization' stamp: 'ar 10/2/2004 19:44'!initializeDefaultSpace	| space light tframe |	space _ TSpace new.	space url: 'http://www.reed.com/TeaLand/spaces/intro.tea'.	"Add a light to the world "	light _ TLight new.	tframe _ TSpinner new.	tframe translationX: -10 y:0.0 z: 0.0.	tframe rotationAroundZ: 120.	tframe matNil.	tframe contents: light.	space addChild: tframe.	self makeFloor: space fileName:'stone.bmp'.	self makeMirror: space. 	self makePyramid: space.	self initializeTweakWorld.		^space! !!TweakTeapotMorph class methodsFor: 'as yet unclassified' stamp: 'bf 9/14/2004 13:23'!descriptionForPartsBin	^super descriptionForPartsBin! !!UndefinedObject methodsFor: '*Croquet' stamp: 'ar 6/5/2002 21:47'!teaExportLiteralOn: byteStream! !!UndefinedObject methodsFor: '*Croquet' stamp: 'ar 6/6/2002 22:34'!teaExportOn: exporter	^exporter exportLiteral: self! !!UndefinedObject methodsFor: '*Croquet' stamp: 'ar 9/9/2004 14:28'!teaObjectName	^#nil! !!UndefinedObject methodsFor: '*Croquet' stamp: 'ar 10/2/2004 10:04'!teaParty	^nil! !!UndefinedObject class methodsFor: '*Croquet' stamp: 'ar 6/5/2002 21:42'!teaImportLiteralFrom: byteStream	^nil! !!UserInputEvent methodsFor: '*Croquet'!translateBy: delta	"add delta to cursorPoint, and return the new event"	position ifNil:[position _ ActiveHand position].	position _ position + delta.! !!Wonderland methodsFor: '*Croquet' stamp: 'ar 6/6/2002 22:34'!teaExportOn: exporter	^self error: 'Cannot export'! !!WorldState methodsFor: '*Croquet' stamp: 'ar 6/22/2002 19:15'!assuredCanvasFor: pasteUp	remoteServer ifNotNil:[^self assuredRemoteCanvas].	(canvas isNil or: [(canvas extent ~= viewBox extent) or: [		canvas form depth ~= Display depth and:[pasteUp == World]]])		ifTrue:			["allocate a new offscreen canvas the size of the window"			self canvas: (Display defaultCanvasClass extent: viewBox extent)].	^ self canvas! !!WorldState methodsFor: '*Croquet' stamp: 'ar 6/22/2002 19:15'!displayWorld: aWorld submorphs: submorphs	"Update this world's display."	| deferredUpdateMode worldDamageRects handsToDraw handDamageRects allDamage |	submorphs do: [:m | m fullBounds].  "force re-layout if needed"	self checkIfUpdateNeeded ifFalse: [^ self].  "display is already up-to-date"	deferredUpdateMode _ self doDeferredUpdatingFor: aWorld.	deferredUpdateMode ifFalse: [self assuredCanvasFor: aWorld].	canvas roundCornersOf: aWorld during:[		worldDamageRects _ self drawWorld: aWorld submorphs: submorphs invalidAreasOn: canvas.  "repair world's damage on canvas"		"self handsDo:[:h| h noticeDamageRects: worldDamageRects]."		handsToDraw _ self selectHandsToDrawForDamage: worldDamageRects.		handDamageRects _ handsToDraw collect: [:h | h savePatchFrom: canvas].		allDamage _ worldDamageRects, handDamageRects.		handsToDraw reverseDo: [:h | canvas fullDrawMorph: h].  "draw hands onto world canvas"	].	"*make this true to flash damaged areas for testing*"	Preferences debugShowDamage ifTrue: [aWorld flashRects: allDamage color: Color black].	canvas finish: allDamage.	"quickly copy altered rects of canvas to Display:"	deferredUpdateMode		ifTrue: [self forceDamageToScreen: allDamage]		ifFalse: [canvas showAt: aWorld viewBox origin invalidRects: allDamage].	handsToDraw do: [:h | h restoreSavedPatchOn: canvas].  "restore world canvas under hands"	Display deferUpdates: false; forceDisplayUpdate.! !!WorldState methodsFor: '*Croquet' stamp: 'ar 6/22/2002 19:15'!doDeferredUpdatingFor: aWorld        "If this platform supports deferred updates, then make my canvas be the Display (or a rectangular portion of it), set the Display to deferred update mode, and answer true. Otherwise, do nothing and answer false. One can set the class variable DisableDeferredUpdates to true to completely disable the deferred updating feature."	| properDisplay |	PasteUpMorph disableDeferredUpdates ifTrue: [^ false].	(Display deferUpdates: true) ifNil: [^ false].  "deferred updates not supported"	remoteServer ifNotNil:[		self assuredCanvasFor: aWorld.		^true].	properDisplay _ canvas notNil and: [canvas form == Display].	aWorld == World ifTrue: [  "this world fills the entire Display"		properDisplay ifFalse: [			aWorld viewBox: Display boundingBox.    "do first since it may clear canvas"			self canvas: (Display getCanvas copyClipRect: Display boundingBox).		]	].	^ true! !!WorldState methodsFor: '*Croquet' stamp: 'ar 1/17/2002 21:04'!forceDamageToScreen: allDamage	"here for the convenience of NebraskaWorldState"	canvas form == Display 		ifTrue:[Display forceDamageToScreen: allDamage]		ifFalse:[allDamage do: [:r | canvas forceToScreen: r]].	self remoteCanvasesDo: [ :each | 		allDamage do: [:r | each forceToScreen: r].		each displayIsFullyUpdated.	].! !!WorldState methodsFor: '*Croquet' stamp: 'ar 6/7/2002 01:01'!postImportFrom: importer	super postImportFrom: importer! !!WorldState methodsFor: '*Croquet' stamp: 'ar 6/7/2002 01:09'!prepareToExportOn: exporter	super prepareToExportOn: exporter.	hands := Array with: hands first.	activeHand := nil.	viewBox := nil.	canvas := nil.	damageRecorder := nil.	stepList := nil.	lastStepTime := nil.	lastStepMessage := nil.	lastCycleTime := nil.	commandHistory := nil.	alarms := nil.	lastAlarmTime := nil.	remoteServer := nil.	multiCanvas := nil.! !!XDevice methodsFor: 'accessing' stamp: 'ar 9/30/2004 08:42'!classes	"This method was automatically generated"	^XInputClassInfo fromHandle: (handle pointerAt: 9)! !!XDevice methodsFor: 'accessing' stamp: 'ar 9/30/2004 08:42'!classes: anObject	"This method was automatically generated"	handle pointerAt: 9 put: anObject getHandle.! !!XDevice methodsFor: 'accessing' stamp: 'ar 9/30/2004 08:42'!deviceID	"This method was automatically generated"	^handle unsignedLongAt: 1! !!XDevice methodsFor: 'accessing' stamp: 'ar 9/30/2004 08:42'!deviceID: anObject	"This method was automatically generated"	handle unsignedLongAt: 1 put: anObject! !!XDevice methodsFor: 'accessing' stamp: 'ar 9/30/2004 08:42'!numClasses	"This method was automatically generated"	^handle unsignedLongAt: 5! !!XDevice methodsFor: 'accessing' stamp: 'ar 9/30/2004 08:42'!numClasses: anObject	"This method was automatically generated"	handle unsignedLongAt: 5 put: anObject! !!XDevice class methodsFor: 'as yet unclassified' stamp: 'DPR 6/1/2004 01:03'!fields	^#(	(deviceID 'ulong')		(numClasses 'ulong')		(classes 'XInputClassInfo*'))! !!XDevice class methodsFor: 'as yet unclassified' stamp: 'DPR 6/1/2004 01:04'!initialize	self defineFields.! !!XForm methodsFor: 'as yet unclassified' stamp: 'DPR 6/23/2004 00:32'!colormapFromARGB	^colorMap! !!XForm methodsFor: 'as yet unclassified' stamp: 'DPR 6/23/2004 00:32'!colormapFromARGB: aColorMap	colorMap _ aColorMap.! !!XForm methodsFor: 'as yet unclassified' stamp: 'DPR 6/23/2004 00:26'!hasNonStandardPallette	^colorMap notNil.! !!XImage methodsFor: 'accessing' stamp: 'ar 9/30/2004 08:42'!addPixel	"This method was automatically generated"	^ExternalData fromHandle: (handle pointerAt: 81) type: ExternalType void asPointerType! !!XImage methodsFor: 'accessing' stamp: 'ar 9/30/2004 08:42'!addPixel: anObject	"This method was automatically generated"	handle pointerAt: 81 put: anObject getHandle.! !!XImage methodsFor: 'accessing' stamp: 'ar 9/30/2004 08:42'!bitmapBitOrder	"This method was automatically generated"	^handle unsignedLongAt: 29! !!XImage methodsFor: 'accessing' stamp: 'ar 9/30/2004 08:42'!bitmapBitOrder: anObject	"This method was automatically generated"	handle unsignedLongAt: 29 put: anObject! !!XImage methodsFor: 'accessing' stamp: 'ar 9/30/2004 08:42'!bitmapPad	"This method was automatically generated"	^handle unsignedLongAt: 33! !!XImage methodsFor: 'accessing' stamp: 'ar 9/30/2004 08:42'!bitmapPad: anObject	"This method was automatically generated"	handle unsignedLongAt: 33 put: anObject! !!XImage methodsFor: 'accessing' stamp: 'ar 9/30/2004 08:42'!bitmapUnit	"This method was automatically generated"	^handle unsignedLongAt: 25! !!XImage methodsFor: 'accessing' stamp: 'ar 9/30/2004 08:42'!bitmapUnit: anObject	"This method was automatically generated"	handle unsignedLongAt: 25 put: anObject! !!XImage methodsFor: 'accessing' stamp: 'ar 9/30/2004 08:42'!bitsPerPixel	"This method was automatically generated"	^handle unsignedLongAt: 45! !!XImage methodsFor: 'accessing' stamp: 'ar 9/30/2004 08:42'!bitsPerPixel: anObject	"This method was automatically generated"	handle unsignedLongAt: 45 put: anObject! !!XImage methodsFor: 'accessing' stamp: 'ar 9/30/2004 08:42'!blueMask	"This method was automatically generated"	^handle unsignedLongAt: 57! !!XImage methodsFor: 'accessing' stamp: 'ar 9/30/2004 08:42'!blueMask: anObject	"This method was automatically generated"	handle unsignedLongAt: 57 put: anObject! !!XImage methodsFor: 'accessing' stamp: 'ar 9/30/2004 08:42'!byteOrder	"This method was automatically generated"	^handle unsignedLongAt: 21! !!XImage methodsFor: 'accessing' stamp: 'ar 9/30/2004 08:42'!byteOrder: anObject	"This method was automatically generated"	handle unsignedLongAt: 21 put: anObject! !!XImage methodsFor: 'accessing' stamp: 'ar 9/30/2004 08:42'!bytesPerLine	"This method was automatically generated"	^handle unsignedLongAt: 41! !!XImage methodsFor: 'accessing' stamp: 'ar 9/30/2004 08:42'!bytesPerLine: anObject	"This method was automatically generated"	handle unsignedLongAt: 41 put: anObject! !!XImage methodsFor: 'accessing' stamp: 'ar 9/30/2004 08:42'!createImage	"This method was automatically generated"	^ExternalData fromHandle: (handle pointerAt: 65) type: ExternalType void asPointerType! !!XImage methodsFor: 'accessing' stamp: 'ar 9/30/2004 08:42'!createImage: anObject	"This method was automatically generated"	handle pointerAt: 65 put: anObject getHandle.! !!XImage methodsFor: 'accessing' stamp: 'ar 9/30/2004 08:42'!data	"This method was automatically generated"	^ExternalData fromHandle: (handle pointerAt: 17) type: ExternalType byte asPointerType! !!XImage methodsFor: 'accessing' stamp: 'ar 9/30/2004 08:42'!data: anObject	"This method was automatically generated"	handle pointerAt: 17 put: anObject getHandle.! !!XImage methodsFor: 'accessing' stamp: 'ar 9/30/2004 08:42'!depth	"This method was automatically generated"	^handle unsignedLongAt: 37! !!XImage methodsFor: 'accessing' stamp: 'ar 9/30/2004 08:42'!depth: anObject	"This method was automatically generated"	handle unsignedLongAt: 37 put: anObject! !!XImage methodsFor: 'accessing' stamp: 'ar 9/30/2004 08:42'!destroyImage	"This method was automatically generated"	^ExternalData fromHandle: (handle pointerAt: 69) type: ExternalType void asPointerType! !!XImage methodsFor: 'accessing' stamp: 'ar 9/30/2004 08:42'!destroyImage: anObject	"This method was automatically generated"	handle pointerAt: 69 put: anObject getHandle.! !!XImage methodsFor: 'accessing' stamp: 'ar 9/30/2004 08:42'!format	"This method was automatically generated"	^handle unsignedLongAt: 13! !!XImage methodsFor: 'accessing' stamp: 'ar 9/30/2004 08:42'!format: anObject	"This method was automatically generated"	handle unsignedLongAt: 13 put: anObject! !!XImage methodsFor: 'accessing' stamp: 'ar 9/30/2004 08:42'!greenMask	"This method was automatically generated"	^handle unsignedLongAt: 53! !!XImage methodsFor: 'accessing' stamp: 'ar 9/30/2004 08:42'!greenMask: anObject	"This method was automatically generated"	handle unsignedLongAt: 53 put: anObject! !!XImage methodsFor: 'accessing' stamp: 'ar 9/30/2004 08:42'!height	"This method was automatically generated"	^handle unsignedLongAt: 5! !!XImage methodsFor: 'accessing' stamp: 'ar 9/30/2004 08:42'!height: anObject	"This method was automatically generated"	handle unsignedLongAt: 5 put: anObject! !!XImage methodsFor: 'accessing' stamp: 'ar 9/30/2004 08:42'!obdata	"This method was automatically generated"	^ExternalData fromHandle: (handle pointerAt: 61) type: ExternalType void asPointerType! !!XImage methodsFor: 'accessing' stamp: 'ar 9/30/2004 08:42'!obdata: anObject	"This method was automatically generated"	handle pointerAt: 61 put: anObject getHandle.! !!XImage methodsFor: 'accessing' stamp: 'ar 9/30/2004 08:42'!putPixel	"This method was automatically generated"	^ExternalData fromHandle: (handle pointerAt: 73) type: ExternalType void asPointerType! !!XImage methodsFor: 'accessing' stamp: 'ar 9/30/2004 08:42'!putPixel: anObject	"This method was automatically generated"	handle pointerAt: 73 put: anObject getHandle.! !!XImage methodsFor: 'accessing' stamp: 'ar 9/30/2004 08:42'!redMask	"This method was automatically generated"	^handle unsignedLongAt: 49! !!XImage methodsFor: 'accessing' stamp: 'ar 9/30/2004 08:42'!redMask: anObject	"This method was automatically generated"	handle unsignedLongAt: 49 put: anObject! !!XImage methodsFor: 'accessing' stamp: 'ar 9/30/2004 08:42'!subImage	"This method was automatically generated"	^ExternalData fromHandle: (handle pointerAt: 77) type: ExternalType void asPointerType! !!XImage methodsFor: 'accessing' stamp: 'ar 9/30/2004 08:42'!subImage: anObject	"This method was automatically generated"	handle pointerAt: 77 put: anObject getHandle.! !!XImage methodsFor: 'accessing' stamp: 'ar 9/30/2004 08:42'!width	"This method was automatically generated"	^handle unsignedLongAt: 1! !!XImage methodsFor: 'accessing' stamp: 'ar 9/30/2004 08:42'!width: anObject	"This method was automatically generated"	handle unsignedLongAt: 1 put: anObject! !!XImage methodsFor: 'accessing' stamp: 'ar 9/30/2004 08:42'!xoffset	"This method was automatically generated"	^handle unsignedLongAt: 9! !!XImage methodsFor: 'accessing' stamp: 'ar 9/30/2004 08:42'!xoffset: anObject	"This method was automatically generated"	handle unsignedLongAt: 9 put: anObject! !!XImage class methodsFor: 'as yet unclassified' stamp: 'DPR 5/21/2004 16:27'!fields	^#((width 'ulong') "width of image"	(height 'ulong') "height of image"	(xoffset 'ulong') "number of pixels offset in X direction"	(format 'ulong') "XYBitmap, XYPixmap, ZPixmap"    	(data 'byte*') "pointer to image data"   	(byteOrder 'ulong') " data byte order, LSBFirst, MSBFirst "    	(bitmapUnit 'ulong')	 "quant. of scanline 8, 16, 32"	(bitmapBitOrder 'ulong') "LSBFirst, MSBFirst"    	(bitmapPad 'ulong') "8, 16, 32 either XY or ZPixmap"	(depth 'ulong') "depth of image"	(bytesPerLine ulong) "accelarator to next line"   	(bitsPerPixel 'ulong') "bits per pixel (ZPixmap)"	(redMask 'ulong') "bits in z arrangment"	(greenMask 'ulong')	(blueMask 'ulong')	(obdata 'void*') "hook for the object routines to hang on"	(createImage 'void*') "function pointers"	(destroyImage 'void*')	(putPixel 'void*')	(subImage 'void*')	(addPixel 'void*'))! !!XImage class methodsFor: 'as yet unclassified' stamp: 'DPR 5/21/2004 16:08'!initialize	self defineFields.! !!XInputClassInfo methodsFor: 'accessing' stamp: 'ar 9/30/2004 08:42'!eventTypeBase	"This method was automatically generated"	^handle unsignedByteAt: 2! !!XInputClassInfo methodsFor: 'accessing' stamp: 'ar 9/30/2004 08:42'!eventTypeBase: anObject	"This method was automatically generated"	handle unsignedByteAt: 2 put: anObject! !!XInputClassInfo methodsFor: 'accessing' stamp: 'ar 9/30/2004 08:42'!inputClass	"This method was automatically generated"	^handle unsignedByteAt: 1! !!XInputClassInfo methodsFor: 'accessing' stamp: 'ar 9/30/2004 08:42'!inputClass: anObject	"This method was automatically generated"	handle unsignedByteAt: 1 put: anObject! !!XInputClassInfo class methodsFor: 'as yet unclassified' stamp: 'DPR 6/1/2004 01:09'!fields	^#(	(inputClass 'byte')		(eventTypeBase 'byte'))! !!XInputClassInfo class methodsFor: 'as yet unclassified' stamp: 'DPR 6/1/2004 01:06'!initialize	self defineFields.! !!XLightPipe methodsFor: 'as yet unclassified' stamp: 'DPR 5/23/2004 11:40'!close	XLightPipe ignoreWindow(display, window).	display closeDisplay.! !!XLightPipe methodsFor: 'as yet unclassified' stamp: 'DPR 6/23/2004 01:33'!damagedAreasDo: aBlock	"while there are changes, invoke block with form and damage rectangle"	| lpw damage extent bytes toBytes lineBytes startByte formRect formLine putPosition form  imageBounds rgbaBitMasks aMask bytesPerPixel |	[lpw _ XLightPipe checkWindow(display, window, 0).		lpw getHandle asInteger = 0] whileFalse: [		damage := lpw damage asRectangle.		extent := lpw image width @ lpw image height.		imageBounds := Rectangle origin: 0@0 corner: extent.		damage := damage intersect: imageBounds.  "damage can be bigger than the image!!"		"compute ColorMap, which stays constant once we initialize"		colorMap ifNil: [			rgbaBitMasks := Array with: lpw image redMask with: lpw image greenMask with: lpw image blueMask with: 0.			bpp := lpw image bitsPerPixel.			"the A mask is the rest of the bits"			aMask := rgbaBitMasks inject: ((1 bitShift: bpp) - 1) into: [				:cumMask :mask | cumMask - mask ].			rgbaBitMasks at: 4 put: aMask.			colorMap := ColorMap mappingFromARGB: rgbaBitMasks.].		"copy image data into form"		formRect := Rectangle origin: 0@0 corner: damage width @ damage height.		form := XForm extent: formRect corner depth: bpp.		form colormapFromARGB: colorMap.			"copy bytes into form from image data"		bytesPerPixel := bpp / 8. 		bytes := lpw image data getHandle.		toBytes := form bits.		lineBytes := extent x * bytesPerPixel.		formLine := form width * bytesPerPixel.		startByte := (damage origin x * bytesPerPixel) + (damage origin y * lineBytes).		putPosition := 1.		"copy the rectangle from the image into our form"		1 to: damage height do: [ :line |			bytes 				copyBytesFrom: startByte+1 				to: startByte + formLine				into: toBytes				startingAt: putPosition.			startByte := startByte + lineBytes.			putPosition := putPosition + formLine.		].		"?? Smalltalk isBigEndian ifTrue: [ toBytes swapEndianness.]."		XLightPipe release(display, lpw).		aBlock value: form value: damage.	].! !!XLightPipe methodsFor: 'as yet unclassified' stamp: 'DPR 6/22/2004 14:55'!getKeyMap	| kcRange col k |	keyMap := IdentityDictionary new.	kcRange := display keycodes.	(kcRange at: 1) to: (kcRange at: 2) do: [ :keycode |		col := 0.		[k := display keysymForKeycode: keycode column: col. k isNil] whileFalse: [			(k >= 32 and: [ k <= 255 ]) ifFalse: [				(k >= 16rFF08 and: [ k <= 16rFF1B ])					ifTrue: [k := k - 16rFF00.]					ifFalse: [ k == 16rFFFFF ifTrue: [ k := 16r7F ].]				].			keyMap at: k put: { keycode . col }.			col  := col + 1.			].		]."define control keys that are not special"	ctrlKeys := 0.	0 to: 16r1F do: [ :ck | keyMap at: ck ifAbsentPut: [													ctrlKeys := ctrlKeys bitOr: (1 bitShift: ck). 													(keyMap at: ck + 16r20) ]].	^nil. 	" from Carl Worth, xstroke.c:    XDisplayKeycodes(dpy, &min_kc, &max_kc);        for (keycode = min_kc; keycode <= max_kc; keycode++) {        col = 0;        while (1) {            k = XKeycodeToKeysym (dpy, keycode, col);            if (k == NoSymbol)                break;            if (k == keysym) {                *code_ret = keycode;                if (col_ret)                    *col_ret = col;                return 0;            }            col++;        }    }    return 1;"! !!XLightPipe methodsFor: 'as yet unclassified' stamp: 'DPR 6/2/2004 11:44'!keyCodeAndColumn: keyValue	^keyMap at: keyValue ifAbsent: [nil].! !!XLightPipe methodsFor: 'as yet unclassified' stamp: 'DPR 6/22/2004 15:01'!needsCtrlShift: keyVal	^keyVal < 16r20 and: [ (ctrlKeys bitAnd: (1 bitShift: keyVal)) ~= 0].! !!XLightPipe methodsFor: 'as yet unclassified' stamp: 'DPR 6/2/2004 11:40'!openDisplay: anX11Display window: aNumber	| success |	display _ anX11Display.	window _ aNumber.	window ifNil: [ window _ display rootWindow. ].	success _ XLightPipe attendWindow(display, window).	self getKeyMap.	^success.! !!XLightPipe class methodsFor: 'as yet unclassified' stamp: 'DPR 5/21/2004 15:01'!attendSubWindows(display, window)	<cdecl: bool 'XlightPipeAttendSubWindows' (X11Display* ulong) module: 'lightpipe'>	^self externalCallFailed! !!XLightPipe class methodsFor: 'as yet unclassified' stamp: 'DPR 5/21/2004 15:04'!attendWindow(display, window)	<cdecl: bool 'XLightPipeAttendWindow' (X11Display* ulong) module: 'lightpipe'>	^self externalCallFailed! !!XLightPipe class methodsFor: 'as yet unclassified' stamp: 'DPR 5/21/2004 15:01'!checkAny(display, block)	<cdecl: XLightPipeWindow* 'XlightPipeCheckAny' (X11Display* bool) module: 'lightpipe'>	^self externalCallFailed! !!XLightPipe class methodsFor: 'as yet unclassified' stamp: 'DPR 5/21/2004 15:09'!checkWindow(display, window, block)	<cdecl: XLightPipeWindow* 'XLightPipeCheckWindow' (X11Display* ulong bool) module: 'lightpipe'>	^self externalCallFailed! !!XLightPipe class methodsFor: 'as yet unclassified' stamp: 'DPR 5/21/2004 15:01'!ignoreWindow(display, window)	<cdecl: void 'XlightPipeIgnoreWindow' (X11Display* ulong) module: 'lightpipe'>	^self externalCallFailed! !!XLightPipe class methodsFor: 'as yet unclassified' stamp: 'DPR 5/29/2004 13:35'!init	<cdecl: void 'XLightPipeInit' () module: 'lightpipe'>	^self externalCallFailed! !!XLightPipe class methodsFor: 'as yet unclassified' stamp: 'DPR 5/21/2004 15:20'!release(display, lpw)	<cdecl: void 'XLightPipeRelease' (X11Display* XLightPipeWindow*) module: 'lightpipe'>	^self externalCallFailed! !!XLightPipeWindow methodsFor: 'accessing' stamp: 'ar 9/30/2004 08:42'!borderWidth	"This method was automatically generated"	^handle unsignedLongAt: 9! !!XLightPipeWindow methodsFor: 'accessing' stamp: 'ar 9/30/2004 08:42'!borderWidth: anObject	"This method was automatically generated"	handle unsignedLongAt: 9 put: anObject! !!XLightPipeWindow methodsFor: 'accessing' stamp: 'ar 9/30/2004 08:42'!damage	"This method was automatically generated"	^XRectangle fromHandle: (handle structAt: 13 length: 8)! !!XLightPipeWindow methodsFor: 'accessing' stamp: 'ar 9/30/2004 08:42'!damage: anObject	"This method was automatically generated"	handle structAt: 13 put: anObject getHandle length: 8.! !!XLightPipeWindow methodsFor: 'accessing' stamp: 'ar 9/30/2004 08:42'!geometry	"This method was automatically generated"	^XRectangle fromHandle: (handle structAt: 1 length: 8)! !!XLightPipeWindow methodsFor: 'accessing' stamp: 'ar 9/30/2004 08:42'!geometry: anObject	"This method was automatically generated"	handle structAt: 1 put: anObject getHandle length: 8.! !!XLightPipeWindow methodsFor: 'accessing' stamp: 'ar 9/30/2004 08:42'!image	"This method was automatically generated"	^XImage fromHandle: (handle pointerAt: 21)! !!XLightPipeWindow methodsFor: 'accessing' stamp: 'ar 9/30/2004 08:42'!image: anObject	"This method was automatically generated"	handle pointerAt: 21 put: anObject getHandle.! !!XLightPipeWindow class methodsFor: 'as yet unclassified' stamp: 'DPR 5/21/2004 16:26'!fields	^#(		(geometry 'XRectangle')		(borderWidth 'ulong')		(damage 'XRectangle')		(image 'XImage*')).	! !!XLightPipeWindow class methodsFor: 'as yet unclassified' stamp: 'DPR 5/21/2004 15:39'!initialize	self defineFields.	! !!XRectangle methodsFor: 'accessing' stamp: 'DPR 5/22/2004 10:19'!asRectangle	"convert from a Rectangle"	| x y |	^Rectangle origin: (x := self x) @ (y := self y) corner: (x + self width) @ (y + self height).! !!XRectangle methodsFor: 'accessing' stamp: 'ar 9/30/2004 08:42'!height	"This method was automatically generated"	^handle unsignedShortAt: 7! !!XRectangle methodsFor: 'accessing' stamp: 'ar 9/30/2004 08:42'!height: anObject	"This method was automatically generated"	handle unsignedShortAt: 7 put: anObject! !!XRectangle methodsFor: 'accessing' stamp: 'ar 9/30/2004 08:42'!width	"This method was automatically generated"	^handle unsignedShortAt: 5! !!XRectangle methodsFor: 'accessing' stamp: 'ar 9/30/2004 08:42'!width: anObject	"This method was automatically generated"	handle unsignedShortAt: 5 put: anObject! !!XRectangle methodsFor: 'accessing' stamp: 'ar 9/30/2004 08:42'!x	"This method was automatically generated"	^handle signedShortAt: 1! !!XRectangle methodsFor: 'accessing' stamp: 'ar 9/30/2004 08:42'!x: anObject	"This method was automatically generated"	handle signedShortAt: 1 put: anObject! !!XRectangle methodsFor: 'accessing' stamp: 'ar 9/30/2004 08:42'!y	"This method was automatically generated"	^handle signedShortAt: 3! !!XRectangle methodsFor: 'accessing' stamp: 'ar 9/30/2004 08:42'!y: anObject	"This method was automatically generated"	handle signedShortAt: 3 put: anObject! !!XRectangle class methodsFor: 'as yet unclassified' stamp: 'DPR 5/31/2004 23:52'!FakeDeviceKeyEvent: display device: device keycode: keycode isPress: isPress axes: axes nAxes: nAxes delay: delay	<cdecl: long 'XTestFakeDeviceKeyEvent' (X11Display* XDevice* long bool long* long long) module: 'X11'>	^self externalCallFailed.! !!XRectangle class methodsFor: 'as yet unclassified' stamp: 'DPR 5/21/2004 15:57'!fields	^#((x 'short') (y 'short') (width 'ushort') (height 'ushort')).! !!XRectangle class methodsFor: 'as yet unclassified' stamp: 'DPR 5/21/2004 15:57'!initialize	self defineFields.! !!XTest methodsFor: 'as yet unclassified' stamp: 'DPR 6/1/2004 01:34'!fakeButtonEventButton: button isPress: isPress delay: delay	^self class FakeButtonEvent: display button: button isPress: isPress delay: delay! !!XTest methodsFor: 'as yet unclassified' stamp: 'DPR 6/1/2004 01:33'!fakeKeyEventKeycode: keycode isPress: isPress delay: delay	^self class FakeKeyEvent: display keycode: keycode isPress: isPress delay: delay! !!XTest methodsFor: 'as yet unclassified' stamp: 'DPR 6/1/2004 01:48'!fakeMotionEventScreen: screen x: x y: y delay: delay	^self class FakeMotionEvent: display screen: screen x: x y: y delay: delay! !!XTest methodsFor: 'as yet unclassified' stamp: 'DPR 6/1/2004 02:21'!openDisplay: aDisplay	| eventBase errorBase major minor query |	display _ aDisplay.	eventBase _ WordArray new: 1.	errorBase _ WordArray new: 1.	major _ WordArray new: 1.	minor _ WordArray new: 1.	query := self class QueryExtension: display eventBase: eventBase errorBase: errorBase major: major minor: minor.	^query.! !!XTest class methodsFor: 'as yet unclassified' stamp: 'DPR 6/1/2004 02:28'!CompareCurrentCursorWithWindow: display window: window	<cdecl: bool 'XTestCompareCurrentCursorWithWindow' (X11Display* long) module: 'Xtst'>	^self externalCallFailed.! !!XTest class methodsFor: 'as yet unclassified' stamp: 'DPR 6/1/2004 02:28'!CompareCursorWithWindow: display window: window cursor: cursor	<cdecl: bool 'XTestCompareCursorWithWindow' (X11Display* long long) module: 'Xtst'>	^self externalCallFailed.! !!XTest class methodsFor: 'as yet unclassified' stamp: 'DPR 6/1/2004 02:28'!Discard: display	<cdecl: long 'XTestDiscard' (X11Display*) module: 'Xtst'>	^self externalCallFailed.! !!XTest class methodsFor: 'as yet unclassified' stamp: 'DPR 6/1/2004 02:28'!FakeButtonEvent: display button: button isPress: isPress delay: delay	<cdecl: long 'XTestFakeButtonEvent' (X11Display* ulong bool ulong) module: 'Xtst'>	^self externalCallFailed.! !!XTest class methodsFor: 'as yet unclassified' stamp: 'DPR 6/1/2004 02:28'!FakeDeviceButtonEvent: display device: device button: button isPress: isPress axes: axes nAxes: nAxes delay: delay	<cdecl: long 'XTestFakeDeviceButtonEvent' (X11Display* XDevice* ulong bool long* long ulong) module: 'Xtst'>	^self externalCallFailed.! !!XTest class methodsFor: 'as yet unclassified' stamp: 'DPR 6/1/2004 02:28'!FakeDeviceMotionEvent: display device: device isRelative: isRelative firstAxis: firstAxis axes: axes nAxes: nAxes delay: delay	<cdecl: long 'XTestFakeDeviceMotionEvent' (X11Display* XDevice* bool long long* long ulong) module: 'Xtst'>	^self externalCallFailed.! !!XTest class methodsFor: 'as yet unclassified' stamp: 'DPR 6/1/2004 02:28'!FakeKeyEvent: display keycode: keycode isPress: isPress delay: delay	<cdecl: long 'XTestFakeKeyEvent' (X11Display* ulong bool ulong) module: 'Xtst'>	^self externalCallFailed.! !!XTest class methodsFor: 'as yet unclassified' stamp: 'DPR 6/1/2004 02:28'!FakeMotionEvent: display screen: screen x: x y: y delay: delay	<cdecl: long 'XTestFakeMotionEvent' (X11Display* long long long ulong) module: 'Xtst'>	^self externalCallFailed.! !!XTest class methodsFor: 'as yet unclassified' stamp: 'DPR 6/1/2004 02:28'!FakeProximityEvent: display device: device inProximity: inProximity axes: axes nAxes: nAxes delay: delay	<cdecl: long 'XTestFakeProximityEvent' (X11Display* XDevice* bool long* long ulong) module: 'Xtst'>	^self externalCallFailed.! !!XTest class methodsFor: 'as yet unclassified' stamp: 'DPR 6/1/2004 02:29'!FakeRelativeMotionEvent: display x: x y: y delay: delay	<cdecl: long 'XTestFakeRelativeMotionEvent' (X11Display* long long ulong) module: 'Xtst'>	^self externalCallFailed.! !!XTest class methodsFor: 'as yet unclassified' stamp: 'DPR 6/1/2004 02:29'!GrabControl: display impervious: impervious	<cdecl: long 'XTestGrabControl' (X11Display* bool) module: 'Xtst'>	^self externalCallFailed.! !!XTest class methodsFor: 'as yet unclassified' stamp: 'DPR 6/1/2004 00:49'!QueryExtension: display eventBase: eventBase errorBase: errorBase major: major minor: minor	<cdecl: bool 'XTestQueryExtension' (X11Display* long* long* long* long*) module: 'Xtst'>	^self externalCallFailed.! !!XTest class methodsFor: 'as yet unclassified' stamp: 'DPR 6/1/2004 02:29'!SetGContextOfGC: display gid: gid	<cdecl: long 'XTestSetGContextOfGC' (X11Display* long) module: 'Xtst'>	^self externalCallFailed.! !!XTest class methodsFor: 'as yet unclassified' stamp: 'DPR 6/1/2004 02:29'!SetVisualIDOfVisual: display visualID: visualID	<cdecl: long 'XTestSetVisualIDOfVisual' (X11Display* long) module: 'Xtst'>	^self externalCallFailed.! !!XTest class reorganize!('as yet unclassified' CompareCurrentCursorWithWindow:window: CompareCursorWithWindow:window:cursor: Discard: FakeButtonEvent:button:isPress:delay: FakeDeviceButtonEvent:device:button:isPress:axes:nAxes:delay: FakeDeviceMotionEvent:device:isRelative:firstAxis:axes:nAxes:delay: FakeKeyEvent:keycode:isPress:delay: FakeMotionEvent:screen:x:y:delay: FakeProximityEvent:device:inProximity:axes:nAxes:delay: FakeRelativeMotionEvent:x:y:delay: GrabControl:impervious: QueryExtension:eventBase:errorBase:major:minor: SetGContextOfGC:gid: SetVisualIDOfVisual:visualID:)!!XTest reorganize!('as yet unclassified' fakeButtonEventButton:isPress:delay: fakeKeyEventKeycode:isPress:delay: fakeMotionEventScreen:x:y:delay: openDisplay:)!XRectangle initialize!!XRectangle class reorganize!('as yet unclassified' FakeDeviceKeyEvent:device:keycode:isPress:axes:nAxes:delay: fields initialize)!!XRectangle reorganize!('accessing' asRectangle height height: width width: x x: y y:)!XLightPipeWindow initialize!!XLightPipeWindow class reorganize!('as yet unclassified' fields initialize)!!XLightPipeWindow reorganize!('accessing' borderWidth borderWidth: damage damage: geometry geometry: image image:)!!XLightPipe class reorganize!('as yet unclassified' #'attendSubWindows()/2' #'attendWindow()/2' #'checkAny()/2' #'checkWindow()/3' #'ignoreWindow()/2' init #'release()/2')!!XLightPipe reorganize!('as yet unclassified' close damagedAreasDo: getKeyMap keyCodeAndColumn: needsCtrlShift: openDisplay:window:)!XInputClassInfo initialize!!XInputClassInfo class reorganize!('as yet unclassified' fields initialize)!!XInputClassInfo reorganize!('accessing' eventTypeBase eventTypeBase: inputClass inputClass:)!XImage initialize!!XImage class reorganize!('as yet unclassified' fields initialize)!!XImage reorganize!('accessing' addPixel addPixel: bitmapBitOrder bitmapBitOrder: bitmapPad bitmapPad: bitmapUnit bitmapUnit: bitsPerPixel bitsPerPixel: blueMask blueMask: byteOrder byteOrder: bytesPerLine bytesPerLine: createImage createImage: data data: depth depth: destroyImage destroyImage: format format: greenMask greenMask: height height: obdata obdata: putPixel putPixel: redMask redMask: subImage subImage: width width: xoffset xoffset:)!!XForm class reorganize!('as yet unclassified')!!XForm reorganize!('as yet unclassified' colormapFromARGB colormapFromARGB: hasNonStandardPallette)!XDevice initialize!!XDevice class reorganize!('as yet unclassified' fields initialize)!!XDevice reorganize!('accessing' classes classes: deviceID deviceID: numClasses numClasses:)!!TweakTeapotMorph class reorganize!('as yet unclassified' descriptionForPartsBin)!!TweakTeapotMorph reorganize!('initialization' initializeDefaultSpace)!!TeaTest class reorganize!('as yet unclassified' descriptionForPartsBin includeInNewMorphMenu)!!SampleTeapotMorph class reorganize!('new-morph participation' descriptionForPartsBin)!!TeapotMorph class reorganize!('as yet unclassified' current descriptionForPartsBin includeInNewMorphMenu loadIcon2: loadIcon: loadIcon:defaultExtent: startFullScreen)!!TeaTest reorganize!('initialization' initializeDefaultSpace)!!SampleTeapotMorph reorganize!('initialize' initializeDefaultSpace)!!TeapotMorph reorganize!('acceleration' accelerationEnabled accelerationEnabled: accelerationSuspended accelerationSuspended: restoreAcceleration suspendAcceleration)('drag and drop' acceptDroppingMorph:event: dropBehaviorRef: makeLocalProjectWithMorph: wantsDroppedMorph:event:)('accessing' acrossWorldsStuff activeCamera dock imageForm messageList messenger messenger: ogl people showTextureStats showTextureStats:)('menu' addCustomMenuItems:hand: showFrameRateString showTextureStatsString startPDAServer toggleFrameRate toggleTextureStats toggleTransmit transmitStuffString)('toys' addZoomNavigator chooseAvatar:andClose: chooseAvatar:for: clickOpenAliceFile: enableScriptBehaviors loadAliceFile: loadAliceModel:url: loadAliceModels: loadAmbientSound: make3Body: makeAlphaTexture: makeBounce: makeCharacters:at: makeChess: makeClock: makeDungeon7: makeDungeon: makeEquip: makeFlag: makeFloor:fileName: makeFloor:texture: makeGM: makeGallery: makeGallery:from:using: makeHoliday: makeKay: makeLazySusan: makeLight: makeLinkToProject: makeManual: makeMars: makeMirror2: makeMirror: makeMoving:to: makeNewSpace makePooh: makePoohMeshFrom: makePoohObjectFrom:player:rotateBy:replaceOldCostume: makePopUp: makePortal: makeProjectLink: makePyramid: makeSlime: makeSnapshot:angle:translation: makeSolar: makeSomeFish: makeSpreadSheet: makeStartupLink: makeStoneFloor: makeTracker: makeUnderwater2: makeUnderwater3: makeUnderwater: makeUnderwaterSharks: makeWaterfall: makeWaterfallBottom: makeWaveDemo: makeWaveDemo:at:in: makeWebPage:extent: makeWidgets: makeWindows: openTool: painter painter: popUpBillboard: popUpBillboard:player: repaint:replaceOldCostume: updateAvatar)('drawing' areasRemainingToFill: doTransmitStuff drawAcceleratedOn: drawOn: drawSimulatedOn: forceToScreen renderOn: transmitStuff transmitStuff:)('event handling' blueButtonDown: blueButtonUp: checkMessages dropFiles: handleMouseMove: handlesKeyboard: handlesMouseDown: handlesMouseOver: handlesMouseStillDown: justDroppedInto:event: keyDown: keyStroke: keyUp: mouseDown: mouseEnter: mouseMove: mouseOver: mouseStillDown: mouseUp:)('tea time' connect:partyName:nickName: destroyAvatarNamed: initializeLocalTeaHost initializeTeaParty localTeaHost localTeaHost: nickname nickname: noteNewHost: registerTeaObject: teaName teaObjectName teaObjects teaParty teaParty:)('initialization' delete dismissViaHalo initialize initializeDefaultSpace intoWorld: loadImageUrl: loadInitialSpace: loadLocator: loadLocator:reuseExisting: loadURL: loadURL:reuseExisting: localURL: myColor openConnectionDialog outOfWorld: requestInitialSpace slideToTrash:)('fileIn/Out' download:whenFinishedSend:to: teaExportOn:)('rendering' drawSubmorphsOn: frustumChanged: glRenderMorphicOverlayOn: glRenderOn: glRenderSubmorphsOn: morphsInFrontOf:overlapping:do: renderOverlay:)('step' fpsMorph fpsMorph: step stepTime wantsSteps)('tweak support' glRenderTweakCostume:on: glRenderTweakOn: handleEvent: initializeTweakWorld onBlueButtonDown onBlueButtonUp onKeyDown: onKeyStroke: onKeyUp: onMouseDown onMouseMove onMouseStillDown onMouseUp onYellowButtonDown onYellowButtonUp runTweakCycle shutdownTweakWorld tweakCache tweakWorld tweakWorld:)('pda' handleEventData: runPDAServer sendImageData: updatePDAClient updatePDAClient:)('testing' makeCylinder:)('scripts-support' scriptScheduler scriptScheduler:)!!TeaTime class reorganize!('as yet unclassified' adjustBase: currentInitialHost deadline defaultInitialHost defaultInitialHost: future: futureSeconds: infinity makeProxy:baseHost: now nowAsMicroseconds nowAsMilliseconds nowAsSeconds origin proxyHosts reset shutdown syncWithUCT syncWithUTC testBasic)('private' scheduler setMilliseconds:state:initialHost:)!!TeaTime reorganize!('arithmetic' * + - / // hash quo: rem: secondsRemaining timeRemaining truncated)('comparing' < <= = > >= blocks: compare: ~=)('state management' abort abortAndTerminate aborted commit committed mutable past state)('as yet unclassified' addContingent:)('converting' asFloat asInteger asSeconds)('private' initialHost privateSetState: scheduler setMilliseconds:state:initialHost:)('scheduling' possibleValue: possibleValue:ifAborted: waitForFinal waitUntil)('printing' printOn:)!!TeaParty class reorganize!('as yet unclassified' activePartiesAt: disableInternet disableInternet: forceTunnel forceTunnel: host:rendezvousAt:forParty:nickname: testPartyAt: testPartyJoin:forParty: transcriptOn transcriptOn:)!!TeaParty reorganize!('sending' broadcastForEffect: broadcastForEffect:local: for:broadcastForEffect: myHost to:name:sendForEffect: to:sendForEffect:)('private' goodbye:nickname: goodbyeAll hello:nickname: helloAll host:rendezvousAt:forParty:nickname: processServerResponse:ignoreError: runKeepAlive teapot teapot:)('statistics' membership selectorHistogram)('resigning' resign)!!TeaName class reorganize!('as yet unclassified' initialize:)!!TeaName reorganize!('initialize' initialize: initialize:class:)('accessing' printOn: teaObject: teaObjectName)!!TeaMessage class reorganize!('as yet unclassified')!!TeaMessage reorganize!('cache' myScripts myScripts:)('accessing' doConstruct doConstruct: setSelector:arguments: setSelector:arguments:host:number: setTarget:selector:arguments: setTarget:selector:arguments:atTime: setTarget:selector:arguments:host:number:atTime: target teaHost: teaTime)('sending' delayedSend delayedSendTo: execute)!TeaHost initialize!!TeaHost class reorganize!('instance creation' acceptTunnel: address:port:UDP: broadcaster name: newBroadcastListener newLocal shutDown startSession)('class initialization' initialize)('accessing' currentHostName getBaseObjectNumber initHostName listenLoops nextObjectNumber popHostName popObjectNumber pushHostName: pushObjectNumber: sendTCPAlways sendTCPAlways: setBaseObjectNumber)!!TeaHost reorganize!('comparing' < <= = > >= ~=)('private' broadcastListener connectToAddr:port:UDP: listen listenAccept: listenUDP local sendStuff:to: tag:value:to: tunneled)('sharing' checkMessages define:as: mapNameToObject objectNamed: processMessage:length: sendMessage:to: sendMessages: sendMessages:to: to:name:sendForValue:)('inquiry' hostAddress hostID hostName hostPort hostUDPPort hostUID listenUDPData networkResponseLatency networkStatistics selectorHistogram)('tunneling' listenTunnel: runTunnelListenFor:socket: runTunnelProcess tunnel: tunnelOut: tunnelSend:)('shutdown' shutdown)('message sending' to:name:sendForEffect: to:sendForEffect:)!TZoomNavigatorMorph initialize!!TZoomNavigatorMorph class reorganize!('as yet unclassified' initialize)!!TWindowMorph class reorganize!('as yet unclassified')!!TeaBackingMorph class reorganize!('as yet unclassified')!!TZoomNavigatorMorph reorganize!('alice items' addAliceFile:image: addAliceLibrary: addAlicePath:image: addAliceRoot clickOpenAliceFile: clickOpenAlicePath:)('back button' addBackButton addBackButton: clickBackTo:)('initialize' addItem: addItem:dragAction:clickAction: drawName:on: initialize removeAll)('project items' addProject: addProject:clickAction:dragAction: addProjectRoot addProjectRoot: addProjects clickProjectView: dragProjectView:)('snapshot items' addSnapshotItem: addSnapshotRoot addSnapshotRoot: addSnapshots clickSnapshot: resetSnapshots)('tools' addTool: addTool:image: addTools addToolsRoot addToolsRoot: openTool:)('geometry' extent: ownerChanged)('event handling' handleMouseMove: handlesMouseOver: mouseDown:from: mouseEnter: mouseEnter:from: mouseLeave: mouseLeave:from: mouseMove: mouseUp:from: startDrag:from: step stepTime)('accessing' largeExtent smallExtent)!!TWindowMorph reorganize!('geometry' activate activateEvent: extent: ownerChanged passivate)('initialize' closeRequest collapseRequest expandRequest initialize)('collapse-expand' collapse expand)('accessing' content frame label label: model model: windowColor:)('events' followHand:frame: startDrag:frame: stopDrag:frame:)('testing' isCollapsed)('stepping' step stepTime wantsSteps)!!TeaBackingMorph reorganize!('rendering' glRenderOn: invalidRect:from: repairDamage)('initialize' initialize)('geometry' position:)!!TXWindow class reorganize!('as yet unclassified')!!TXWindow reorganize!('as yet unclassified' XMonitor: XopenFailed handTrackingPointer: handTrackingPointer:position: handleEvent2D:pointer: initializeOpaque:extent: makeHand: pointerEnter: pointerLeave:)!!TXMLExporter class reorganize!('as yet unclassified')!!TXMLExporter reorganize!('exporting' export:)!!TXLightPipe class reorganize!('as yet unclassified')!!TXLightPipe reorganize!('as yet unclassified' changedButtonNumber: close ctrlKeyCode handleEvent: monitorXDisplay:window:eventsTo: pollWindowChanges sendKey:isPress: shiftKeyCode)!!TWorldCanvas class reorganize!('instance creation')('as yet unclassified' on:)!!TWorldCanvas reorganize!('initialization' finish finish: on:)!!TWirePortal class reorganize!('as yet unclassified')!!TWirePortal reorganize!('as yet unclassified' render:depth:)!TWindowFrameMorph initialize!!TWindowFrameMorph class reorganize!('instance creation' initialize)!!TWindowFrameMorph reorganize!('accessing' alphaSlider closeButton collapseButton doItButton expandButton label label: labelColor labelColor: window: windowColor:)('initialize' buildAlphaSlider buildCloseButton buildDoItButton buildExpandButton buildWindowButton buildWindowButton: buildWindowLabel collapse expand initialize makeLabelButton)('events' mouseDown:from: mouseUp:from:)!!TWindowFrame class reorganize!('instance creation')!!TWindowFrame reorganize!('accessing' colorize: doInside: extent extent: extentX:y: frameBox frameOn frameOn: frontNorm hilite hilite: isSolid materialHilite materialHilite: radius radius: scale: segments segments:)('initialize' initBounds initialize)('render' pick: renderInside:x:y: renderPrimitive:)!!TWindowButtons class reorganize!('instance creation')!!TWindowButtons reorganize!('accessing' closeButton disable enable grabButton: initializeWithWindow:extent: openButton)('initialize' extent: material:)!!TWindow class reorganize!('instance creation')!!TWindow reorganize!('actions' closeContents closeContents: doCloseContents doKillWindow doOpenContents gotoWindow: grabWindow: killWindow killWindow: moveWindow: openContents openContents: releaseWindow releaseWindow: resizeWindow: rotateWindow: snapshotWindow: zoomWindow:)('accessing' contents3D: contents: extent extent: frameOn frameOn: grabButton: isBrowser: materialDown materialHilite materialNorm materialOver radius radius: rectBack rectFront rectFront:)('events' handlesKeyboard: handlesPointerDown: handlesPointerOver: keyDown: keyStroke: keyUp: pointerDown: pointerEnter: pointerLeave: pointerMove: pointerOver: pointerUp: wantsBlueButton)('initialize' initialize)('testing' isBrowser isComponent isSolid isWindow)('toys' onOpenProtectedContents)('stepping' spin: spinDelta stepAt: wantsSteps)!!TWidget class reorganize!('instance creation' createNewWithUrl:fileName:scale:)!!TWidget reorganize!('as yet unclassified')!!TWaves class reorganize!('instance creation' initializeWithSize:)!!TWaves reorganize!('accessing' envTexture: texture:)('events' handlesPointerDown: pointerDown: pointerMove:)('actions' impulse:)('initialize' initializeWithSize:)('testing' isComponent)('render' renderAlpha:)('stepping' step stepAt: stepx wantsSteps)!!TWaveDemo class reorganize!('as yet unclassified')!!TWaveDemo reorganize!('private' compile:)('accessing' contents: targetForm texture textureForm)('stepping' drawSampleBufferLines:in:color: drawSampleBufferPoints:in:color: renderFrame:parent:root: sample1 smoothTarget:amount: step update wantsSteps warpTarget:to:)('events' handlesPointerDown: handlesPointerOver: pointerDown: pointerEnter: pointerLeave: syncSound:)('initialize' initialize)('testing' isComponent)('fileIn/Out' prepareToExportOn:)!!TVoiceRecorder class reorganize!('as yet unclassified')!!TVoiceRecorder reorganize!('initialization' addLocalFeedback initialize)('private' allocateBuffer bufferSize emitBuffer: recordLoop sendBuffer:ifSilent:)('recording controls' isRecording startRecording)('accessing' noiseThreshold statusString teaOwner teaOwner: volumeAverage)!!TUserCamera class reorganize!('as yet unclassified')!!TUserCamera reorganize!('accessing' addOverlay: avatar avatar: debugOverlay downPointer forwardOnY forwardOnY: morphicOverlay pointer pointer: removeOverlay: setDoRender: snapshot snapshot: thirdPerson thirdPerson:)('transform' followAvatar postRender preRender snapBack)('initialize' frustumChanged initializeWithViewPort:)('remoteControl' isRemoteControl setRemoteControl:)('render' renderFrame:space: renderOverlay:)('chat' chatObject chatStatus endChat endChat: isChatting startChat startChat:)('popUp' makeFloor:fileName: makePopup)('events' blueButtonDown: blueButtonUp: calcPointerTransform: dropFiles:event: goToSnapshot: gotoSpace:transform: keyDown: keyStroke: keyUp: mouseDown: mouseMove: mouseUp: openHalo: pointerXY: switchMirror toggleAvatarPerson)('drag and drop')('morph import' makePicture: makePortal:)('window')('avatar' clickOpenAvatarFile:)('painter' clickOpenAliceFile: makePoohMeshFrom: makePoohObjectFrom:player:rotateBy:replaceOldCostume: popUpBillboard:player:)('CIM')!!TTriangle class reorganize!('instance creation')!!TTriangle reorganize!('initialize' initBounds initialize)('render' pick: renderPrimitive:)('accessing' v1:v2:v3:)!!TTree class reorganize!('as yet unclassified')!!TTree reorganize!('as yet unclassified' initializeWithDepth:)!!TTracer class reorganize!('as yet unclassified')!!TTracer reorganize!('accessing' addPath: boundSphere maxSize: path reset)('render' render: renderFrame:space:)('initialize' initialize)!!TTorus class reorganize!('as yet unclassified')!!TTorus reorganize!('accessing' boundSphere boundSphere: innerRadius innerRadius: localPosition localPosition: radius radius: segments segments:)('initialize' initialize)('render' pick: renderPrimitive:)!!TTextureStress class reorganize!('as yet unclassified')!!TTextureStress reorganize!('as yet unclassified' new setupStressTest)!!TSpreadSheetTxtr class reorganize!('as yet unclassified')!!TMonitorWorld class reorganize!('as yet unclassified')!!TMorphic class reorganize!('instance creation')!!TTextureForm class reorganize!('as yet unclassified')!!TSpreadSheetTxtr reorganize!('as yet unclassified' initialize selectField:)!!TMonitorWorld reorganize!('as yet unclassified')!!TMorphic reorganize!('events' handleEvent2D:pointer: pointerEnter: pointerLeave:)('initialize' morphMonitor:)('render' update)!!TTextureForm reorganize!('events' handleEvent2D:pointer: handlesKeyboard: handlesPointerDown: handlesPointerOver: keyDown: keyStroke: passEvent:from: pointerDown: pointerEnter: pointerLeave: pointerMove: pointerOver: pointerUp: wantsBlueButton)('testing' isComponent)('accessing' material: passEvents:)('render' updateArea:with:)('initialize' initializeOpaque:extent:)!!TTexture class reorganize!('as yet unclassified')!!TTexture reorganize!('fileIn/Out' isLoaded)('access' bMipmap extension extent: fileName formExtent invalidate: isStatic isStatic: magFilter minFilter mode mode: scale scale: shrinkFit shrinkFit: targetExtent targetForm textureForm tform updateRect: uvAngle uvAngle: uvOffset uvOffset: uvScale uvScale:)('initialize' destroy flipVertically initializeOpaque:extent: initializeWithFileName: initializeWithFileName:mipmap: initializeWithFileName:mipmap:shrinkFit: initializeWithFileName:mipmap:shrinkFit:extension: initializeWithForm:mipmap:shrinkFit: initializeWithForm:mipmap:shrinkFit:extension: setup)('render' disable: enable: renderFrame:parent:root: renderFrame:space: renderPrimitive: update upload)('testing' isTexture)('copying' copy)!TTensor initialize!!TTensor class reorganize!('instance creation' initialize initializeMass: testCube testCube:position: testSphere testSphere: testSphere:position:)!!TTensor reorganize!('initialize' addFaces:vertices: initialize initializeDensity: initializeMass:)('construction' calcPlane: faceIntegrate:tri: projectionIntegrate: result volumeIntegrate)('accessing' centerMass density density: mass mass: t0 t1 t2 tensor tp)!!TTeapot class reorganize!('instance creation')!!TTeapot reorganize!('render' glTeapot:gridSize: glTeapot:gridSize:scale:type: initBounds pick: renderPrimitive:)('accessing' gridSize gridSize: scale scale: type type:)('initialize' initialize patchData vertexData)!!TSwarm class reorganize!('as yet unclassified')!!TSwarm reorganize!('initialize' initialize)('testing' isComponent)!!TSuburban class reorganize!('instance creation')!!TSuburban reorganize!('events' handlesKeyboard: handlesPointerDown: keyDown: keyStroke: openLeftDoor: openRightDoor: pointerDown: pointerUp:)('initialize' initializeWithTerrain:)('testing' isComponent)('accessing' setSpeed: setTurn: stop switchTransparency turnAngle turnAngle: updateTurn)('stepping' stepAt: wantsSteps)!!TSpreadSheet class reorganize!('as yet unclassified')!!TSpreadSheet reorganize!('initialize' initialize)('actions' selectField: selectFields: updateField:)!!TSpinner class reorganize!('instance creation')!!TSpinner reorganize!('events' contents contents: handlesKeyboard: handlesPointerDown: handlesPointerOver: pointerEnter: pointerLeave: pointerMove: pointerOver: pointerUp:)('initialize' initialize keyDown: keyStroke: pointerDown:)('testing' isComponent)('accessing' matDown matDown: matNil matNorm matNorm: matOver matOver: spin spin:)('stepping' stepAt: wantsSteps)!!TSpinCube class reorganize!('as yet unclassified')!!TSpinCube reorganize!('as yet unclassified' initialize initialize: spin:)!!TSphere class reorganize!('instance creation')!!TSphere reorganize!('accessing' boundSphere boundSphere: localPosition localPosition: radius radius: segments segments:)('initialize' initialize)('render' pick: render:sphere: renderPrimitive:)!!TSpellBox class reorganize!('instance creation')!!TSpellBox reorganize!('initialize' initializeClass:texture: initializeWithFrame:class:)('events' pointerUp:)!!TSpeaker class reorganize!('instance creation')!!TSpeaker reorganize!('accessing' color: fadeDelay)('action' disable enable signalVolume:)('initialize' initializeWithFrame:)('testing' isComponent isSolid)('stepping' stepAt: wantsSteps)!!TSpaceImposter class reorganize!('as yet unclassified')!!TSpaceImposter reorganize!('initialize' generateView:transFrom:transTo:extent: initializeWithSpace:transform: renderOffscreen:)!!TSpaceBrowser class reorganize!('as yet unclassified')!!TSpaceBrowser reorganize!('menus' addVariableIn: browseSelected destroyObject: editScript:in: goNearSelected removeBehavior: renameScript:in: stopScript:in: treeMenu: turnToSelected)('initialize' avatar: buildTreeList camera: open windowColor)('stuff' dragItemMorph:from: dragPassengerFor:inMorph: dragTransferTypeForMorph: wantsDroppedMorph:event:inMorph:)('accessing' inspectSelected selectedFrame selectedFrameWrapper selectedFrameWrapper: selectedObject step topFrame topFrame: treeList)!!TCausticSpace class reorganize!('instance creation')!!TSpace class reorganize!('instance creation')('scripting')!!TCausticSpace reorganize!('render' forceAlpha restoreFromAlpha: setupAlpha:)('initialize' initialize)('fileIn/Out' postImportFrom:)!!TSpace reorganize!('accessing' addAlpha: addAlphaObject:transform:distance:parent: alphaObjects alphaObjects: color color: cullBackFaces cullBackFaces: currentCameraTransform currentParent currentParent: currentTransform currentTransform: currentTranslation dropInFrame dropInFrame: locator rayFrames testRays testRays: url url:)('frameManagement' addLightFrame: addPortalFrame: addRayFrame: removeLightFrame: removePortalFrame: removeRayFrame:)('ambient sound' ambientSound ambientSound: ambientSoundFadeFrom:to:duration: ambientSoundFadeVolume:stepSize:forSteps:finalVolume: ambientSoundPauseComplete ambientSoundPlaying pauseAmbientSound playAmbientSound: resumeAmbientSound startAmbientSound stopAmbientSound switchToAmbientSoundFrom:)('render' clearRender:camera: doRender: doRender:camera: forceAlpha hasAlphaObjectsToRender makeThumbnailOf:extent: makeThumbnailOf:using: popAlphaObjects pushAlphaObjects render:thumbnailOf:using: renderClear: renderSpace: renderSpace:port:depth: renderSpaceAlpha:transform: restoreFromAlpha: setCull: setupAlpha: setupFog: setupLights: snapShot:camera: snapShot:rectangle:atLoc:view: testRayFrames: testRayFramesQuadTree:)('properties' eventsGenerated)('fog properties' fogColor fogColor: fogDensity fogDensity: fogEnd fogEnd: fogOn fogOn: fogStart fogStart:)('initialize' initialize initializeInPlace:)('testing' isSpace)('scripting')('fileIn/Out' prepareToExportOn:)!!TSolar class reorganize!('as yet unclassified')!!TSolar reorganize!('events' handlesKeyboard: handlesPointerDown: keyDown: pointerUp:)('initialize' initialize)('testing' isComponent)('buttonEvents' buttonTool gravityOff gravityOn lowPressureOff lowPressureOn spinningOff spinningOn wideSpreadOff wideSpreadOn)('stepping' stepAt: wantsSteps)!TSocket initialize!!TSocket class reorganize!('instance creation' acceptFrom: createIfFail: new newTCP newUDP tcpCreateIfFail: udpCreateIfFail:)('examples' clientServerTestUDP clientServerTestUDP2 remoteTestClientTCP remoteTestClientTCPOpenClose1000 remoteTestClientTCPOpenClosePutGet remoteTestClientUDP remoteTestServerTCP remoteTestServerTCPOpenClose1000 remoteTestServerTCPOpenClosePutGet remoteTestServerTCPUsingAccept remoteTestServerUDP remoteTestServerUDP2 remoteTestSinkTCP timeTest timeTestUDP timeTestUDP2 timeTestUDP3)('utilities' deadServer deadServer: deadlineSecs: nameForWellKnownTCPPort: ping: pingPorts:on:timeOutSecs: pingPortsOn: standardDeadline wildcardAddress wildcardPort)('network initialization' ensureNetworkConnected initializeNetwork initializeNetworkIfFail:)('class initialization' initialize)('tests' loopbackTest newAcceptCheck sendTest)('registry' register: registry registryThreshold registryThreshold: unregister:)!!TSocket reorganize!('connection open/close' accept close closeAndDestroy closeAndDestroy: connectTo:port: disconnect listenOn: listenOn:backlogSize:)('initialize-destroy' acceptFrom: destroy initialize:)('accessing' address localAddress localPort peerName port primitiveOnlySupportsOneSemaphore readSemaphore remoteAddress remotePort socketHandle writeSemaphore)('queries' dataAvailable isConnected isOtherEndClosed isThisEndClosed isUnconnected isUnconnectedOrInvalid isValid isWaitingForConnection sendDone socketError statusString)('sending-receiving' discardReceivedData getData readInto:startingAt: receiveDataInto: semaphore sendData: sendData:count: sendSomeData: sendSomeData:startIndex: sendSomeData:startIndex:count:)('emulate semaphores' emulateAcceptFrom:receiveBufferSize:sendBufSize:semaIndex:readSemaIndex:writeSemaIndex: emulateSocketCreateNetwork:type:receiveBufferSize:sendBufSize:semaIndex:readSemaIndex:writeSemaIndex: runSignalDispatcher)('finalization' finalize)('other' getOption: getResponseNoLF setOption:value:)('primitives' primAcceptFrom:receiveBufferSize:sendBufSize:semaIndex: primAcceptFrom:receiveBufferSize:sendBufSize:semaIndex:readSemaIndex:writeSemaIndex: primSocket:connectTo:port: primSocket:getOption: primSocket:listenOn: primSocket:listenOn:backlogSize: primSocket:receiveDataInto:startingAt:count: primSocket:receiveUDPDataInto:startingAt:count: primSocket:sendData:startIndex:count: primSocket:sendUDPData:toHost:port:startIndex:count: primSocket:setOption:value: primSocket:setPort: primSocketAbortConnection: primSocketCloseConnection: primSocketConnectionStatus: primSocketCreateNetwork:type:receiveBufferSize:sendBufSize:semaIndex: primSocketCreateNetwork:type:receiveBufferSize:sendBufSize:semaIndex:readSemaIndex:writeSemaIndex: primSocketDestroy: primSocketDestroyGently: primSocketError: primSocketLocalAddress: primSocketLocalPort: primSocketReceiveDataAvailable: primSocketRemoteAddress: primSocketRemotePort: primSocketSendDone:)('printing' printOn:)('datagrams' receiveDataInto:fromHost:port: receiveUDPDataInto: sendData:toHost:port: sendUDPData:toHost:port: setPeer:port: setPort:)('registry' register unregister)('waiting' waitForAcceptUntil: waitForConnectionUntil: waitForDataUntil: waitForDisconnectionUntil: waitForSendDoneUntil:)!!TSnapshot class reorganize!('instance creation')!!TSnapshot reorganize!('render' drawOn: glRenderOn:)('accessor' globalMatrixOut globalTransform location name root thumbnail time url)('initialize' initializeWithFrame: initializeWithFrame:transform:)('testing' isCamera isPortal isSpace)('dropping/grabbing' dragToSpace)!!TSkyBox class reorganize!('instance creation')!!TSkyBox reorganize!('initialize' initializeWithFileName:)('testing' isComponent)('stepping' stepAt: wantsSteps)!!TSketchEditorMorph class reorganize!('as yet unclassified')!!TSketchEditorMorph reorganize!('accessing' accept action action: brush brush: cancel lastEvent lastEvent: paintingForm paintingFormPen paintingFormPen: palette teapot teapot:)('palette handling' cancelPainting:evt: clearPainting: paintBoxChanged: paletteAttached: paletteDetached: savePainting:evt: undoPainting:evt:)('painting' clear erase: erasePrep: fill: paint: prepareToPaint: repaint: undo:)('drawing' drawOn: handlesMouseDown: handlesMouseOver: handlesMouseOverDragging: mouseDown: mouseEnter: mouseEnterDragging: mouseLeave: mouseLeaveDragging: mouseMove: mouseUp:)!!TSketchButtonMorph class reorganize!('as yet unclassified')!!TSketchButtonMorph reorganize!('as yet unclassified' containsPoint:)!!TSimpleSpin class reorganize!('as yet unclassified')!!TSimpleSpin reorganize!('as yet unclassified' contents: handlesPointerDown: isComponent pointerUp: setSpinning: stepAt: wantsSteps)!!TSierpinski class reorganize!('instance creation')!!TSierpinski reorganize!('accessing' depth depth: scale scale: value:)('events' handlesKeyboard: keyDown: keyStroke:)('initialize' initialize split:depth: update)('testing' isComponent)('render' pick: renderPrimitive:)!!TSelectionTracker class reorganize!('as yet unclassified')!!TSelectionTracker reorganize!('render' renderFrame:parent:root: renderFrame:space:)!!TSelection class reorganize!('as yet unclassified')!!TSelection reorganize!('accessing' cameraTransform cameraTransform: distance distance: distanceSquared distanceSquared: frame frame: framePosition framePosition: index index: normal normal: object object: parent parent: parentTransform parentTransform: point point: triangle triangle:)!!TEditBox3D class reorganize!('instance creation' castSpell:)!!TScrollBox3D class reorganize!('instance creation')!!TEditBox3D reorganize!('actions' moveBox: resizeBox: selectChild selectLeftSibling selectParent selectRightSibling)('events' handlesKeyboard: keyDown: keyStroke:)('accessing' scale: selectedPoint:)('initialize' initialize initializeWithContents:)!!TScrollBox3D reorganize!('actions' calcRotateDimension delete doCorner: doEdge: intoBox moveBox: outOfBox rotateBox: rotateBoxX: rotateBoxY: rotateBoxZ: scaleBox:)('events' child: handlesPointerDown: handlesPointerOver: pointerDown: pointerEnter: pointerLeave: pointerMove: pointerOver: pointerUp:)('initialize' contents: initialize initializeWithContents: makeSides update)('accessing' changed deferScale: extent extent: material:)('render' renderFrame:parent:root: renderFrame:space:)('testing' isComponent)!!TScriptorWrapper class reorganize!('as yet unclassified')!!TScriptorWrapper reorganize!('accessing' addMenuItemsTo: asString contents dropObject dropType frame hasContents icon iconSize item)!!TSampledSound class reorganize!('as yet unclassified')!!TSampledSound reorganize!('accessing' addSoundBuffer:at:stereo:samplingRate:codec: currentSound currentSound: nextSound)('sound generation' doControl mixSampleCount:into:startingAt:leftVol:rightVol: reset testCount:)('initialize' initialize)!!TRover class reorganize!('as yet unclassified')!!TRover reorganize!('events' handlesKeyboard: handlesPointerDown: keyDown: keyStroke: pointerDown: pointerUp:)('initialize' initialize)('testing' isComponent)('accessing' setSpeed: setTurn: stop turnAngle turnAngle: updateTurn)('stepping' stepAt: wantsSteps)!!TRigidBody class reorganize!('instance creation')!!TRigidBody reorganize!('accessing' allStop angularMomentum angularMomentum: centerMass centerMassWorld frame velocity velocity:)('collision' collideFloor: collidePlane:offset:)('compute' computeForce:delta: globalTransformUpdate impulse:at: integrate: orthoNormalize:)('initialize' initializeWithFrame:mass:)('testing' isRigidBody)!!TResourceLoader class reorganize!('utilities' cacheDirectory fileNameFromUrl:)('instance creation' new)!!TResourceLoader reorganize!('accessing' add: addAll: currentUrl download:whenFinishedSend:to:)('initialize' initialize)('testing' isDone)('loading' load: runLoaderProcess startDownload step stepFor:)!!TRenderAlpha class reorganize!('instance creation' object:transform:distance:parent:)!!TRenderAlpha reorganize!('accessing' distance object:transform:distance:parent: parent tObject transform)!!TPortal class reorganize!('instance creation')!!TButtonHolder class reorganize!('as yet unclassified')!!TRectangle class reorganize!('instance creation')!!TPortal reorganize!('accessing' blocked blocked: cameraDistance cameraDistance: hasAlpha inside linkPortal: lookAt material: outVector outVector: portalToScreen:rect: testEnter: toPortal toPortal: toPortalRoot visible:)('render' disableClipPlane: enableClipPlane: render: render:depth: renderAlpha: renderPortal:)('fileIn/Out' doneLoading: postImportFrom: prepareToExportOn:)('transform' initClipPlanes:mirror:)('initialize' initialize)('testing' isPortal isSolid)('terminate' kill)!!TButtonHolder reorganize!('accessing' addChild: extent:)('initialize' initialize)('scriptThis' makeNewSpace:)('render' material: pick: render: renderAlpha:)!!TRectangle reorganize!('accessing' aspect aspect: aspectFixed aspectFixed: extent extent: extentRect: flip: frameBox location location: normal: scale:)('initialize' initBounds initialize)('render' pick: renderPrimitive:)!!TPointer class reorganize!('instance creation')!TRay initialize!!TRay class reorganize!('class initialization' initialize)('instance creation')!!TPointer reorganize!('accessing' avatar avatar: camera camera: cameraTransform: isDown localTransform: pointerXY pointerXY: setDown: setSpell: tool tool:)('events' controlKeyPressed event2D event2D: keyDown: keyStroke: keyUp: pointerDown: pointerEnter: pointerLeave: pointerMove: pointerOver: pointerUp: shiftPressed wantsKeyboard:)('initialize' calcTransform:z: initialize)('testing' isRay)('fileIn/Out' prepareToExportOn:)('*Jana-Script' isPointerDown isPointerDownOn:)!!TRay reorganize!('accessing' automatic copiedSelection currentFrame currentFrame: doSelect doSelect: downRay downRay: framePointer framePointer: framePointerTrans: framePosition framePosition: lastSelection maxDistance maxDistance: minDistance minDistance: resetSelected resetTotal selected selected: selectedDistance selectedDistance: selectedDistanceSquared selectedDistanceSquared: selectedFrame selectedFrame: selectedFramePosition selectedFramePosition: selectedIndex selectedIndex: selectedNormal selectedNormal: selectedObject selectedObject: selectedParent selectedParent: selectedParentTransform selectedParentTransform: selectedPoint selectedPoint: selectedPointAt selectedTriangle selectedTriangle: selection selection: setAutomatic: sphereDistSquared sphereDistSquared: testDistance testDistance: testSelectedDistance: testSelectedDistanceSquared:)('picking' frame:pickCylinderFrom:radius:to:radius: frame:pickCylinderFrom:to:radius: frame:pickPlane:normal: frame:pickQuad:q1:q2:q3:q4: frame:pickQuad:q2:q3:q4: frame:pickSphere:radiusSquared: frame:pickTriangle:tri:tri: frame:pickTriangle:tri:tri:tri: globalTransformUpdate pick: pickBoundSphere: pickCylinderFrom:radius:to:radius: pickCylinderFrom:to:radius: pickDownSphere: pickFrame:tri:tri:tri: pickLocalBoundSphere: pickLocalNorm: pickPlane:normal: pickQuad:q1:q2:q3:q4: pickQuad:q2:q3:q4: pickSphere:radiusSquared: pickTriangle:tri:tri: pickTriangle:tri:tri:tri: pickTriangles:list: pointerPick: pointerPickFloor: pointerPickTree: portalTest:at:)('initialize' initialize)('testing' isRay)!!TQuadTree class reorganize!('class initialization')!!TQuadTree reorganize!('accessing' add: add:depth: addSphere: boundSphere globalTransformUpdate outBox quadOn quadOn:)('events' handlesPointerDown: pointerDown: wantsSteps)('render' hasAlpha pickFloor: quadPickFloor:location: renderAlpha: renderFrame:parent:root: renderFrame:space: renderTree:root: renderTree:space:)('initialize' initializeWithCorner:size:depth: initializeWithFrame: initializeWithSpace:frame: reinstall)('testing' isComponent)!!TQuad class reorganize!('as yet unclassified')!!TQuad reorganize!('initialize' initBounds initialize)('render' pick: renderPrimitive:)('accessing' v1:v2:v3:v4:)!!TPrimitiveText class reorganize!('as yet unclassified')!!TPrimitiveText reorganize!('render' boundsChanged renderPrimitive:)('initialize' initialize)('accessing' text text: textAlign textAlign: textBounds textBounds: textColor textColor:)!!TPrimitiveString class reorganize!('as yet unclassified')!!TPrimitiveString reorganize!('accessing' font font: string string: text text: textAlign textAlign: textColor textColor:)('initialize' initialize)('render' renderPrimitive:)!!TPrimitiveMesh class reorganize!('as yet unclassified')!!TPrimitiveMesh reorganize!('render' boundsChanged pick: renderPrimitive:)('accessing' initBounds mesh mesh: myCube)('initialize' initialize)!!TManifold class reorganize!('instance creation')!!TLinedCylinder class reorganize!('as yet unclassified')!!TCylinder class reorganize!('instance creation')!!TCube class reorganize!('instance creation')!!TPrimitive class reorganize!('as yet unclassified')!!TManifold reorganize!('accessing' contents contents: extent extent: scale scale: segments spanSize spanSize: texture texture:)('events' handlesKeyboard: keyDown: keyStroke:)('initialize' initBounds initializeWithContents:)('testing' isComponent)('render' pick: render:)('stepping' step stepAt: wantsSteps)!!TLinedCylinder reorganize!('as yet unclassified' render:)!!TCylinder reorganize!('accessing' baseRadius baseRadius: capped capped: frameBox height height: scale: slices slices: stacks stacks: topRadius topRadius:)('initialize' initBounds initialize)('render' pick: renderPrimitive:)!!TCube reorganize!('accessing' boxTop:bottom: colorize: extent extent: extentX: extentX:y:z: extentY: extentZ: location location: locationX:y:z: quadFaces scale: vertices)('as yet unclassified' frameBox)('initialize' initBounds initialize update)('render' pick: renderPrimitive:)!!TPrimitive reorganize!('render' boundSphere hasAlpha opaque render: renderAlpha: renderPrimitive: renderPrimitiveCached:)('accessing' boundsChanged colorize: disableCaching enableCaching material material: materialAlpha materialAlpha: resetCaching texture texture: textureAlpha textureAlpha: transparency:)('copying' copy)('properties-material')('fileIn/Out' postImportFrom:)('initialize' initBounds initialize)!!TPortal3D class reorganize!('instance creation')!!TPortal3D reorganize!('accessing' boundSphere boundingBox extent extent: offset offset: scale scale: space space:)('render' disableClipPlanes: enableClipPlanes: render:)('initialize' initBounds initialize initializeWithSpace:)('testing' isComponent)('stepping' stepAt: wantsSteps)!!TPhysicsEngine class reorganize!('instance creation')!!TPhysicsEngine reorganize!('accessing' addChild: floor:)('events' handlesPointerDown: pointerDown:)('initialize' initialize)('testing' isComponent)('stepping' step wantsSteps)!!TPath class reorganize!('instance creation')!!TPath reorganize!('accessing' box gridPath nextSpline: scale:)('initialize' initializeWithSpline: postCopy resolution: update)('events' parentChanged:)('render' render:)!TPatch initialize!!TPatch class reorganize!('class initialization' initialize)('as yet unclassified' new)!!TPatch reorganize!('as yet unclassified' mirrorX mirrorY mirrorZ patch:vertex:)!!TParticleTxtr class reorganize!('as yet unclassified')!!TParticleTxtr reorganize!('initialize' addTexture:)('render' doRender: doRenderColor: hasAlpha)!!TParticle class reorganize!('instance creation' initializeWithSize:)!!TParticle reorganize!('accessing' addAttractor: billBoard: endColor endColor: hasAttractor: material material: removeAttractor: setAccelerationRangeMin:max: setLifetimeFrom:to: setLifetimeRange: setPositionRangeMin:max: setVelocityRangeMin:max: startColor startColor: updateVars)('initialize' boundSphere boundsChanged initializeWithSize:)('render' determinePosition doRender: doRenderColor: hasAlpha regenerate: render: renderAlpha:)('testing' isComponent)('stepping' doAttractors: stepAt: wantsSteps)!!TPainter class reorganize!('as yet unclassified')!!TPainter reorganize!('actions' acceptSketch:from: leftButtonScript repaint:replaceOldCostume: rightButtonScript)('library' initiateSaveImage libraryDirectory makeLibrary makeLibraryButtonFrom: mouseDownSketch:from: mouseUpSketch:from: saveImage scrollBack: scrollForward: updateLibrary:)('initialize' makeButton: makeButtonRow: makeControlButton:after: makeControlButtons makeInplaceArrows makePainter open)!!TOverlayRearView class reorganize!('as yet unclassified')!!TOverlayRearView reorganize!('render' renderOverlay:)('initialize' frustumChanged: initialize:)!!TOverlayButtons class reorganize!('as yet unclassified')!!TOverlayButtons reorganize!('initialize' camera: frustumChanged: initialize)('render' renderOverlay:)('popups' killPopup makeBoxButton makeCAD: makeCADButton makeEditBox makeEditBoxButton makeExit: makeExitButton makePopup makePortal3D: makePortal3DButton makePortal: makePortalButton makeWireFilter: makeWireFilterButton makeX:display: makeX:display:window: makeXDisplay: makeXDisplay:window: makeXTerminal makeXTerminal: makeXTerminalButton)!!TMyCube class reorganize!('as yet unclassified')!!TMorphMonitor class reorganize!('as yet unclassified' createLocalProjectWithExtent:initialMorph:)!!TMesh class reorganize!('instance creation' initializeWithVertices:alias:norms:textureUV:faceGroups:material:)!TMaterial initialize!!TMaterial class reorganize!('class initialization' initialize)('instance creation')!!TLoadMDL class reorganize!('as yet unclassified')!TLoad3DSMax initialize!!TLoad3DSMax class reorganize!('class initialization' findFileName: initialize)('instance creation')!!TLink class reorganize!('instance creation')!!TLight class reorganize!('instance creation')!!TLife class reorganize!('as yet unclassified')!!TForm class reorganize!('instance creation' defaultForm defaultTForm fromFileNamed:mipmap:shrinkFit:extension: fromForm:mipmap:shrinkFit:extension:)!!TLeaf class reorganize!('as yet unclassified')!!TLazySusan class reorganize!('instance creation')!!TLaser class reorganize!('instance creation')!!TForceWire class reorganize!('as yet unclassified')!!TEscalator class reorganize!('as yet unclassified')!!TEditBox class reorganize!('instance creation' castSpell:)!!TClock class reorganize!('class initialization')!!TCamera class reorganize!('as yet unclassified')!!TCADObject class reorganize!('as yet unclassified')!!TButton class reorganize!('accessing' downColor hiliteColor normColor overColor)('class initialization')!!TBillboard class reorganize!('as yet unclassified')!!TAvatar class reorganize!('as yet unclassified')!!TAttractor class reorganize!('as yet unclassified')!!T3Body class reorganize!('as yet unclassified')!!TGroup class reorganize!('as yet unclassified')!!TFlag class reorganize!('instance creation')!!TDemoBot class reorganize!('as yet unclassified')!!TCrosshair class reorganize!('as yet unclassified')!!TCAD2D class reorganize!('as yet unclassified')!!TBody class reorganize!('as yet unclassified')!TFrame initialize!!TFrame class reorganize!('class initialization' initialize initializeIcons)('instance creation')('accessing' scriptIcon scriptIcon:)!!TObject class reorganize!('instance creation')('metaInitialize')('accessing' howToPassAsArgument new)!!TMyCube reorganize!('events' handlesPointerDown: pick: pointerDown:)('initialize' initialize)('testing' isComponent)('render' render:)('accessing' boundSphere)('simulation' update)!!TMorphMonitor reorganize!('initialize' eventsTo: initializeWithWorld:extent:)('drag-drop' initiateWorldDrag: initiateWorldDrop:)('accessing' addMorph: addMorphCentered: canvasForm color: world)('events' destroyHand: handOfPointer: handOfPointer:ifAbsent: handleEvent2D:pointer: pointerEnter: pointerLeave: stepMorph)('as yet unclassified' close sendDamage: sendTextureUpdate)('project switches' enter:project:)!!TMesh reorganize!('render' boundSphere disableCaching enableCaching hasAlpha oldRender: oldRenderAlpha: render: renderAlpha: renderPrimitive: renderPrimitive:alpha: resetCaching)('accessing' boundsChanged boundsDepth boundsDepth: collapse colorize: faceGroupsDo: forceGlobalToLocal frameBox fullBright: hasAlpha: inertiaTensor isSolid material material: materialList materialList: normals normals: opaque opaque: pick: scale: scaleBounds: transparency: vertices vertices:)('initialize' checkAlpha initBounds initializeWithVertices:alias:norms:textureUV:faceGroups:material: optimizeFaceGroups validateFaceGroups)('collision' collideFloor: collidePlane:offset:)('properties')('testing' isMesh)('copying' postCopy)('fileIn/Out' postImportFrom: prepareToExportOn:)('croquet')!!TMaterial reorganize!('accessing' ambientColor ambientColor: boundSphere color: cullFace cullFace: diffuseColor diffuseColor: emissiveColor emissiveColor: flipFace flipFace: fullBright fullBright: hasAlpha scale: shininess shininess: specularColor specularColor: subMaterialList subMaterialList: texture texture: textureMode textureMode: transparency transparency: uvAngle uvAngle: uvOffset uvOffset: uvScale uvScale:)('render' disable: enable: render: renderAlpha:)('properties-material')('initialize' initialize)('copying' postCopy)!!TLoadMDL reorganize!('parsing' buildMesh:faces:normals:textureUV:textureMap: fixTransformsIn: getChildNamed:from: loadMeshFromFile:texture: parseFileNamed: parseOBJFile:texture: parseVFBFile:texture: scaleFactor)!!TLoad3DSMax reorganize!('convert' aliasIndexToArray: basicCalcFaceNormals basicCalcVertexNormals: calcFaceNormals calcTextureVertices calcVertexNormals: facesToFaceGroup:materials: makeHelperObject: primCalcFaceNormals:faces:faceNormals: primCalcVertexNormals:vertexCount:faces:faceNormals:shadeAngleCos: reconstruct textureIndexToArray: textureTransform:material: vertNormToArray: vertexIndexToArray:)('parse' compare:and:within: convertTName: makeGeometry: makeGroup: makeMap: makeMaterial: makeMaterials: makeMesh: makeNodeName: makeNumber: makeNumberArray: makeTransform: nextFieldOn: nextOn: nextTokenTo:on: parse: parse:announcing: parseFileNamed: parseOld: parseOldFileNamed: parseTree:bar: showTree: showTree:depth: testNorm:norm:)('accessing' frame scale scale: shadeAngle shadeAngle:)('initialize' initializeWithFileName: initializeWithFileName:scale: initializeWithFileName:scale:shadeAngle: initializeWithFileName:scale:shadeAngle:textureMode: reset)!!TLink reorganize!('accessing' addForce: gravity: kSpring kSpring: link link: mass mass:)('events' handlesPointerDown: pointerDown: pointerMove:)('initialize' initializeWithFrame:)('testing' isComponent)('render' renderFrame:parent:root: renderFrame:space:)('stepping' step stepAt: wantsSteps)!!TLight reorganize!('accessing' ambientColor ambientColor: diffuseColor diffuseColor: distance distance: global global: local local: specularColor specularColor: spotCutoff spotCutoff: spotDirection spotDirection: spotExponent spotExponent: type type:)('render' enable:index: enable:index:scaled: render: renderAlpha: renderDirectional renderPoint renderSpot)('events' handlesKeyboard: keyDown: keyStroke:)('initialize' initialize)('testing' isComponent isLight)!!TLife reorganize!('accessing' cellX cellX:cellY: cellY texture texture:)('render' render:)!!TForm reorganize!('import/export' doneLoading: postImportFrom: prepareToExportOn:)('accessing' bMipmap extension extent fileName form invalidate: isLoaded isStatic: magFilter minFilter printOn: resetUpdateRect scaleTexture:to: shrinkFit shrinkFit: target textureForm thumb trueExtent updateAll updateArea:with: updateRect)('initialize' calcMemUsed initialize:form:mipmap:shrinkFit:extension: initialize:form:mipmap:shrinkFit:extension:thumb: setupForm: setupForm:thumb:)!!TLeaf reorganize!('construction' createPrimitive: destroyPrimitive:)('initialize' initialize)('accessing' addChild: addParent: isStatic setStatic: valid valid:)!!TLazySusan reorganize!('events' contents contents: handlesKeyboard: handlesPointerDown: handlesPointerOver: keyDown: keyStroke: pointerDown: pointerEnter: pointerLeave: pointerMove: pointerOver: pointerUp:)('initialize' initialize)('testing' isComponent)('accessing' matDown matDown: matNil matNorm matNorm: matOver matOver: spin spin:)('stepping' stepAt: wantsSteps)!!TLaser reorganize!('accessing' addAttachment: color color: initialize length: removeAttachment scale: setSpell:)('events' pointerDown: pointerMove: pointerUp:)('render')!!TForceWire reorganize!('render')!!TEscalator reorganize!('initialize' initializeWithTreads: makeTreads)('testing' isComponent)('accessing' numTreads numTreads: speed speed:)('stepping' stepAt: wantsSteps)('render' renderFrame:parent:root:)!!TEditBox reorganize!('accessing' contents: scale: selectedPoint:)('actions' delete dragBox: resizeBox: rotateBoxX: rotateBoxY: rotateBoxZ: selectChild selectLeftSibling selectParent selectRightSibling)('events' handlesKeyboard: handlesPointerDown: handlesPointerOver: keyDown: keyStroke: pointerDown: pointerEnter: pointerMove: pointerUp:)('initialize' initializeWithContents: makeCorners makeEdges makeSides)('testing' isComponent)('transform' update updateEdge:from:to:message:)!!TClock reorganize!('initialize' initialize)('testing' isComponent)('stepping' syncHands)('render' renderFrame:parent:root:)!!TCamera reorganize!('accessing' aspect avatar bounds bounds: clipPlanes clipPlanes: currentSpace currentSpace: debugOverlay exportOn: hasAlpha inPortal inPortal: killFrame killFrame: outVector pitch pointer pointer: portalClip portalClip: roll roll: root sideVector texture texture: upVector viewAngle viewAngle: viewClip viewClip: viewPort yaw yaw: zFar zFar: zNear zNear: zScreen zScreen:)('transform' clipPlanesTransform clipPlanesTransform: doScale: scale: transformClipPlanes updateTransform)('initialize' frustumChanged initClipPlanes initFrustum: initializeWithViewPort:)('render' postRender preRender render: renderAlpha: renderOverlay: renderView: teleportTo:in: testBounds: testSphere:radius:)('testing' isCamera)('toys' jump)('*Jana-Script' isPointerDown isPointerDownOn:)!!TCADObject reorganize!('initialize' initialize)('actions' doExtend: extend extend: reselect: selected:)('testing' isComponent)('accessing' selectedPlane)!!TButton reorganize!('accessing' color: fadeDelay local: persist spin: switch)('action' disable enable fadeDelta spinDelta target2:action2: target:action:)('events' doFade handlesPointerDown: handlesPointerOver: persist: pointerDown: pointerEnter: pointerLeave: pointerMove: pointerOver: pointerUp: switch:)('initialize' initializeSwitchWithFrame:frame2: initializeWithFrame: initializeWithFrame:frame2:)('testing' isComponent isSolid)('stepping' stepAt: wantsSteps)!!TBillboard reorganize!('render' renderFrame:parent:root: renderFrame:space:)!!TAvatar reorganize!('driving' driveStep startDriving: stopDriving)('accessing' camera content: currentSpace downPointer driving goToPortal goToPortal: goToPortalTransform goToPortalTransform: host host: newSpace nickname nickname: pointer scale: setDoRender: snapTrans snapTrans: speedControl: speedControl:pointerTransform: sticky: transparency: viewAngle:bounds: viewAngle:bounds:zScreen:)('initialize' defaultAvatar initialize loadAvatar:)('green-properties')('render' renderFrame:parent:root: renderFrame:space:)('testing' isComponent)('voice chat' initPhone)('scripts')('events' handlesPointerDown: handlesPointerOver: pointerDown: pointerEnter: pointerLeave: pointerUp: selection:event2D: selection:keyDown: selection:keyStroke: selection:keyUp: selection:pointerDown: selection:pointerEnter: selection:pointerLeave: selection:pointerMove: selection:pointerOver: selection:pointerUp:)('transform' addToNewSpace: doGoto downFloor:distance:position: enter: fall forwardOnY forwardOnY: goToPortal:transform: goto:count: pointerTransform: skiddoo snapBack)('construction' makePortal makeWindowInFront)!!TAttractor reorganize!('accessing' hard hard: mass mass: radius radius: radiusSquared)('initialize' initialize)!!T3Body reorganize!('events' handlesKeyboard: keyDown: keyStroke: reset speed:)('stepping' step stepAt: wantsSteps)('initialize' initialize)('testing' isComponent)!!TGroup reorganize!('accessing' colorize: doColorize: material: visibleTree:)('initialize' initialize)('testing' isGroup)!!TFlag reorganize!('render' boundSphere render:)('initialize' extent2:segments: initialize pick:)('events' handlesKeyboard: keyDown:)('testing' isComponent)('stepping' step stepAt: wantsSteps)('accessing' tackBottom tackBottom: tackTop tackTop: texture texture:)!!TDemoBot reorganize!('stepping' isComponent moveSpeed moving moving: nothing nothing: searching searching: startWait startWait: step stepAt: stepTime turnSpeed turning turning: waitDistance waitTime waiting waiting: wantsSteps)('accessing' mySpace mySpace: myTarget myTarget: myTargetId: state state: state:duration: targets targets:)!!TCrosshair reorganize!('initialize')('render' render:)!!TCAD2D reorganize!('accessing' addPaths: addToPath: boundingBox epsilon extent extent: makePath max max: min min: nextPlane: paths paths: previousPlane: resolution: scale: select unselect)('events' handlesPointerDown: pointerDown: pointerMove: pointerUp:)('initialize' initialize update)('testing' hasAlpha isComponent)('render' render: render:horizontal:width: render:vertical:width: renderAlpha: renderPrimitive:)!!TBody reorganize!('accessing' addAttractor: isOn reset speed: start stop velocity velocity:)('stepping' doStep runStep stepAt: wantsSteps)('initialize' initialize)!!TFrame reorganize!('hierarchy' addChild: boundSpheresDo: child: collapse currentParent: destroy hasChild: insertFrame: isChild: parent parent: prune removeAll removeChild: removeSelf root singleParent singleParent: transferTo:)('scripts' attachBehavior: detachBehavior: myEventMap myEventMap: myPlayer myPlayer: myScripts: player signalEvent:)('frameManagement' addLightFrame: addLightFrames addPortalFrame: addPortalFrames addRayFrame: addRayFrames forceGlobalToLocal removeLightFrame: removeLightFrames removePortalFrame: removePortalFrames removeRayFrame: removeRayFrames replaceChild:with:)('transform' addRotationAroundX: addRotationAroundY: addRotationAroundZ: addYaw: frameLookAt: globalMatrixOut globalOrientation globalPitch globalPitchYawRoll globalPosition globalPosition: globalRoll globalTransform globalTransform: globalTransformUpdate globalYaw inverseGlobalOrientation inverseGlobalTransform localTransform localTransform: lookAt:up: newRoot:newTransform: orientation orientation: pitch pitch: pitchYawRoll pitchYawRoll: pitchYawRollBy: quaternion relativeTransform: releaseToRoot roll roll: rotFromBallPoints:to: rotation:around: rotation:aroundX:y:z: rotationAroundX: rotationAroundY: rotationAroundZ: scale scale: transformBy: translation translation: translationX:y:z: yaw yaw: yawTransform)('synchronization')('yellow-scripts-support' eventsGenerated myBehaviors myBehaviors: myScripts scriptBehaviors)('fileIn/Out' postImportFrom: prepareToExportOn: setFrameParent:)('accessing' boundSphere boundingBox boundingBox: boundsChanged boundsDepth: changed: childChanged childChanged: colorize: compositeBoundSphere disableCaching disableCachingTree distanceTo: do: extent extent: find: find:into: frameBox frameChanged frameChildren frameChildrenDo: fullBright: globalToLocal: hasAlpha inertiaTensor localToGlobal: locator lookAt lookSide lookUp makeFrame material material: materialAlpha: objectName objectName: objectOwner objectOwner: octreeBox octreeRadius octreeSieve: parentChanged parentChanged: scriptIcon selected: showFrame showFrame: solid solid: solidTree: solidVisibleTree: sphereTree test test: transparency: visible visible: visibleTree visibleTree:)('collision detection')('copying' postCopy)('stepping' doStep lastStepTime lastStepTime: startStepping step stepAt: stepTime stepTime: stopStepping wantsSteps)('error handling')('yellow-scripts' forwardBy:duration:style:rate: moveBy:duration:style:rate: moveTo:duration:style:rate: rollBy:duration:style:rate:)('events' collidesInto: event2D: handlesEvent2D handlesKeyboard: handlesPointerDown: handlesPointerOver: keyDown: keyStroke: keyUp: pointerDown: pointerEnter: pointerLeave: pointerMove: pointerOver: pointerUp: wantsBlueButton)('yellow-scripts-compiled')('properties')('initialize' initBounds initialize)('testing' isBrowser isCamera isComponent isFrame isGroup isLight isMesh isPortal isRay isRigidBody isSolid isSpace isTexture isWindow)('toys' jump: makeThumbnail makeThumbnail: makeThumbnailWithName makeThumbnailWithName:)('debugging')('render' makeThumb: pick: pickFloor: render: render:box: render:cube:location:scale: render:cube:scale: render:sphere:segments: renderAlpha: renderCube:location:scale: renderCube:scale: renderFrame:parent:root: renderFrame:space:)('voice chat' playSoundBuffer:at:stereo:samplingRate:codec: streamingSound streamingSound:)('*JIVE')!!TObject reorganize!('accessing' teaName teaObjectName teaObjectName:)('fileIn/fileOut' postImportFrom: prepareToExportOn: teaExportOn:)('initialize' initialize register)('testing' isFrame isTeaObject isTeaParty)('copying' copy postCopy)('teatime' future:perform: future:perform:withArguments:)!!TConnectionDialog class reorganize!('as yet unclassified')!!TModel class reorganize!('as yet unclassified' new open)!!TConnectionDialog reorganize!('initialize' addInputNames:values: buildConnectButton buildInputPane buildOptionsList camera: initialize open)('connect' connect)('accessing' disableInternet disableInternet: forceTunnel forceTunnel: nickName nickName: partyName partyName: partyURL partyURL: teapot teapot: toggleInternet toggleTunnel)!!TModel reorganize!('as yet unclassified' camera: close closeRequest delete initialize myEventMap myEventMap: myScripts myScripts: open perform:orSendTo: postBuildIn: window windowColor)!!TMeta class reorganize!('as yet unclassified')!!TMetaSend class reorganize!('as yet unclassified')!!TMeta reorganize!('action' doesNotUnderstand:)('initialize')!!TMetaSend reorganize!('initialize' teaObject:)('action' doesNotUnderstand:)!!TMetaNotification class reorganize!('as yet unclassified')!!TMetaNotification reorganize!('as yet unclassified' defaultAction)!!TMetaNil class reorganize!('as yet unclassified')!!TMetaNil reorganize!('nilMessage' doesNotUnderstand:)!!TLoginMorph class reorganize!('as yet unclassified')!!TLoginMorph reorganize!('building' buttonColor buttonNamed:action:color:help: cancelButton myFont okButton)('actions' doCancel doOK)('initialize' initialize name:actionBlock:cancelBlock: openInWorld: rebuild)!!TLoad3DSMaxTest class reorganize!('as yet unclassified')!!TLoad3DSMaxTest reorganize!('Testing' testNextToken testNextTokenWithParenthesis testParse testParseNesting testParseNesting2)!!TLoad3DSMaxPlugin class reorganize!('as yet unclassified' hasHeaderFile headerFile)!!TLoad3DSMaxPlugin reorganize!('as yet unclassified' cross3:with:into: dot3:with: length3: normalize3: normalizeIfNotZero: primCalcFaceNormals:faces:faceNormals: primCalcVertexNormals:vertexCount:faces:faceNormals:shadeAngleCos: testNorm:norm:shadeAngleCos: vector3Add:with: vector3Div:withScalar: vector3Sub:with:)!!TImporter class reorganize!('instance creation' import: importFile: importStream: new)!!TImporter reorganize!('accessing' addAttribute:value: attributeAt: attributeAt:ifAbsent: resources)('importing' checkVersion: download:whenFinishedSend:to: import: import:migratingTo: importStream: readFrom: remap:)('initialize' initialize)!!THandMorph class reorganize!('as yet unclassified')!!THandMorph reorganize!('as yet unclassified' drawOn: processEvents showHardwareCursor:)!!TGraphicsTest class reorganize!('as yet unclassified' new open)!!TGraphicsTest reorganize!('testing' analyzeLog:success: cr flush newOGL nextPutAll: runTests show:)('initialize' initialize open)!!TFileOutMaker class reorganize!('fileOut' fileOutCroquet)!!TFileOutMaker reorganize!('as yet unclassified')!!TExporter class reorganize!('instance creation' export: export:as: export:asBinary: export:asBinary:withThumbnail: export:asXML: new)!!TExporter reorganize!('exporting' addFileResource:locator: export: export:as: export:asBinary: export:asBinary:withThumbnail: export:asXML: exportLiteral: exportMorph: exportObject: exportTeaObject: literalClasses version)('accessing' baseUrl resources)('private' copyResources remap:)('initialize' initialize)!!TExportData class reorganize!('instance creation' new new:)!!TExportData reorganize!('accessing' at: at:put: binary binary: binarySize id id: indexedSize indexedSize: instShape instShape: refClass refClass: size)('exporting' exportDataOn:classMap:swapEnds: exportReferenceOn:classMap: importDataFrom:classMap:shapeMap:refMap:swapEnds: teaExportOn:)('initialize' initialize:)('printing' printOn: storeBinaryXMLOn: storeXMLOn: wordBitsOf:as: wordStringOf:)!!TCurveFitter3 class reorganize!('as yet unclassified')!!TCurveFitter3 reorganize!('fitting' computeMaxError3:from:to:in:params: computeWeightedInTangent:at:max: computeWeightedOutTangent:at:max: fitPoints3:from:to:error:in:out: fitPoints:error: fitPoints:from:to:error: fitTwoPoints3:from:to:in:out: generateBezier3:from:to:params:in:out: inTangent:at: midTangent:at: outTangent:at: parametrizePoints:from:to:)!!TCleanup class reorganize!('as yet unclassified' run)!!TCleanup reorganize!('as yet unclassified')!!TButtonMorph class reorganize!('as yet unclassified')!!TButtonMorph reorganize!('initialize' beBordered initialize)('accessing' contents contents: highlightColor highlightColor: highlightWidth highlightWidth: label label: labelColor labelColor:)('event handling' handlesMouseDown: handlesMouseOver: handlesMouseOverDragging: mouseDown: mouseEnter: mouseEnterDragging: mouseLeave: mouseLeaveDragging: mouseUp:)!!TBox class reorganize!('instance creation' min:max: new origin:corner:)!!TBox reorganize!('math' * addBox:)('accessing' atRandom: center centerX centerY centerZ corner cornerVertices cornerVerticesDo: diagonal extent extentMax extentMin extentX extentY extentZ growVertex: max max: merge: min min: origin radius scale: splitXMax splitXMin splitYMax splitYMin splitZMax splitZMin transformedBy: translatedBy:)('comparing' axisTestXv1:v2:a:b:fa:fb: axisTestYv1:v2:a:b:fa:fb: axisTestZv1:v2:a:b:fa:fb: intersectBox: intersectT1:T2:T3: pointInBox: pointOverBox: unionBox: unionSphere:radius:)('initialize' initialize min:max:)('render')!!TBoundSphere class reorganize!('instance creation' calcBoundSphere: calcBoundSphere:faces: calcTree:faces:box:depth: calcTree:faces:depth: localPosition:radius: mtfBall: mtfBall:faces:)!!TBoundSphere reorganize!('access' addChild: box box: children children: frame globalPosition isLeafSphere localPosition localPosition: localPosition:radius: radius radius: radiusSquared scale: sumFaces sumNodes volume)('construct' calcBoundSphere: calcBoundSphere:faces: calcSurface:faces: calcTree:faces:box:depth: calcTree:faces:depth: frame: splitBoxes: union:)('collision' collideFloor:transform: collidePlane:offset: collidePlane:offset:current: collideSphere: ray:tri:tri:tri:)('mini ball' mtfBall: mtfBall:faces: privateMtfBall0:with:with:with: privateMtfBall1:with:with:with: privateMtfBall2:with:with:with: privateMtfBall3:with:with:with: privateMtfRandomize: privateMtfSphereFromP1:p2: privateMtfSphereFromP1:p2:p3: privateMtfSphereFromP1:p2:p3:p4:)('render' pick: pickChildren: render:box: render:box:depth: render:frame:segments: renderSurface:)('transform' transform:)!!SpreadSheetField class reorganize!('as yet unclassified')!!SpreadSheetField reorganize!('initialization' acceptContents initialize: initialize:row:column: mouseDown: releaseEditor)!!SpreadSheet class reorganize!('as yet unclassified')!!SpreadSheet reorganize!('initialization' drawOn: initialize selectAll selectColumn: selectField: selectRow: tSpreadSheet: updateField:)!!RequestProjectOwner class reorganize!('as yet unclassified')!!RequestProjectOwner reorganize!('exceptionDescription' defaultAction isResumable)!!OpenGLMorph class reorganize!('as yet unclassified' descriptionForPartsBin includeInNewMorphMenu)!!OpenGLMorph reorganize!('acceleration' accelerationEnabled accelerationEnabled: accelerationSuspended accelerationSuspended: restoreAcceleration suspendAcceleration)('drawing' areasRemainingToFill: drawAcceleratedOn: drawOn: drawSimulatedOn: forceToScreen renderOn:)('initialize' delete initialize intoWorld: outOfWorld:)('OpenGL rendering' glRenderOn:)('fileIn/Out' prepareToExportOn:)('stepping' step stepTime wantsSteps)!!OGLWin32 class reorganize!('as yet unclassified')!!OGLUnixX11LE class reorganize!('as yet unclassified')!!OGLUnixX11BE class reorganize!('as yet unclassified')!!OGLUnixQuartz class reorganize!('as yet unclassified' test test:with:)!!OGLUnix class reorganize!('as yet unclassified')!!OGLMacOS9 class reorganize!('as yet unclassified')!!OGLMacOSX class reorganize!('as yet unclassified')!!OpenGL class reorganize!('instance creation' new)('compiling' addSelector:withMethod:)!!OGLWin32 reorganize!('accessing' glExtCallingConvention glExtGetProcAddress: imagePixelFormat32 imagePixelType32 textureInternalFormat texturePixelFormat texturePixelType)('initialize' beginFrame openGLLibraryName)!!OGLUnixX11LE reorganize!('accessing' imagePixelType32 texturePixelType)('intitialize' beginFrame)!!OGLUnixX11BE reorganize!('accessing' imagePixelType32 texturePixelType)!!OGLUnixQuartz reorganize!('accessing' imagePixelFormat32 imagePixelType32 textureInternalFormat texturePixelFormat texturePixelType)('initialize' openGLLibraryName)!!OGLUnix reorganize!('accessing' imagePixelFormat32 imagePixelType32 textureInternalFormat texturePixelFormat texturePixelType)('initialize' openGLLibraryName)!!OGLMacOS9 reorganize!('initialize' openGLLibraryName)!!OGLMacOSX reorganize!('accessing' imagePixelFormat32 imagePixelType32 textureInternalFormat texturePixelFormat texturePixelType)('initialize' openGLLibraryName)!!OpenGL reorganize!('accessing' camera camera: changeTexture changeTexture: closeDisplayList currentPortal currentPortal: extent flipFace fontManager forceWire forceWire: frontFace glGetBoolean: glGetFloat: glGetInteger: glGetTexLevelParameterf:with:with: glGetTexLevelParameteri:with:with: glGetTexParameterf:with: glGetTexParameteri:with: inPortal3D inPortal3D: isMirror maxPortalDepth maxPortalDepth: mirrorFlip openDisplayList openDisplayList: origin screenShot screenShot: test test: textureManager timeStamp timeStamp:)('textures' bindTexture: deleteTexture: disableTexture: enableTexture: installTexture: releaseTexture: setTextureSizeOf:to: textureInternalFormatCompressed textureSizeOf:)('project' gluLookAtEyeX:aEyeY:aEyeZ:aCenterX:aCenterY:aCenterZ:aUpX:aUpY:aUpZ: gluPerspective:aspect:zNear:zFar:)('testing' autoMipmap maxIndices maxVertices)('Keyword API' glAccum:with: glActiveTextureARB: glAlphaFunc:with: glAreTexturesResident:with:with: glAreTexturesResidentEXT:with:with: glArrayElement: glArrayElementEXT: glBindTexture:with: glBitmap:with:with:with:with:with:with: glBlendColor:with:with:with: glBlendEquation: glBlendFunc:with: glCallList: glCallLists:with:with: glClear: glClearAccum:with:with:with: glClearColor:with:with:with: glClearDepth: glClearIndex: glClearStencil: glClientActiveTextureARB: glClipPlane:with: glColor3b:with:with: glColor3bv: glColor3d:with:with: glColor3dv: glColor3f:with:with: glColor3fv: glColor3i:with:with: glColor3iv: glColor3s:with:with: glColor3sv: glColor3ub:with:with: glColor3ubv: glColor3ui:with:with: glColor3uiv: glColor3us:with:with: glColor3usv: glColor4b:with:with:with: glColor4bv: glColor4d:with:with:with: glColor4dv: glColor4f:with:with:with: glColor4fv: glColor4i:with:with:with: glColor4iv: glColor4s:with:with:with: glColor4sv: glColor4ub:with:with:with: glColor4ubv: glColor4ui:with:with:with: glColor4uiv: glColor4us:with:with:with: glColor4usv: glColorMask:with:with:with: glColorMaterial:with: glColorPointer:with:with:with: glColorPointerEXT:with:with:with:with: glColorSubTable:with:with:with:with:with: glColorTable:with:with:with:with:with: glColorTableParameterfv:with:with: glColorTableParameteriv:with:with: glConvolutionFilter1D:with:with:with:with:with: glConvolutionFilter2D:with:with:with:with:with:with: glConvolutionParameterf:with:with: glConvolutionParameterfv:with:with: glConvolutionParameteri:with:with: glConvolutionParameteriv:with:with: glCopyColorSubTable:with:with:with:with: glCopyColorTable:with:with:with:with: glCopyConvolutionFilter1D:with:with:with:with: glCopyConvolutionFilter2D:with:with:with:with:with: glCopyPixels:with:with:with:with: glCopyTexImage1D:with:with:with:with:with:with: glCopyTexImage2D:with:with:with:with:with:with:with: glCopyTexSubImage1D:with:with:with:with:with: glCopyTexSubImage2D:with:with:with:with:with:with:with: glCopyTexSubImage3D:with:with:with:with:with:with:with:with: glCullFace: glDeleteLists:with: glDeleteTextures:with: glDeleteTexturesEXT:with: glDepthFunc: glDepthMask: glDepthRange:with: glDisable: glDisableClientState: glDrawArrays:with:with: glDrawArraysEXT:with:with: glDrawBuffer: glDrawElements:with:with:with: glDrawPixels:with:with:with:with: glDrawRangeElements:with:with:with:with:with: glEdgeFlag: glEdgeFlagPointer:with: glEdgeFlagPointerEXT:with:with: glEdgeFlagv: glEnable: glEnableClientState: glEnd glEndList glEvalCoord1d: glEvalCoord1dv: glEvalCoord1f: glEvalCoord1fv: glEvalCoord2d:with: glEvalCoord2dv: glEvalCoord2f:with: glEvalCoord2fv: glEvalMesh1:with:with: glEvalMesh2:with:with:with:with: glEvalPoint1: glEvalPoint2:with: glFeedbackBuffer:with:with: glFinish glFlush glFogf:with: glFogfv:with: glFogi:with: glFogiv:with: glFrontFace: glFrustum:with:with:with:with:with: glGenLists: glGenTextures:with: glGenTexturesEXT:with: glGetBooleanv:with: glGetClipPlane:with: glGetColorTable:with:with:with: glGetColorTableParameterfv:with:with: glGetColorTableParameteriv:with:with: glGetConvolutionFilter:with:with:with: glGetConvolutionParameterfv:with:with: glGetConvolutionParameteriv:with:with: glGetDoublev:with: glGetError glGetFloatv:with: glGetHistogram:with:with:with:with: glGetHistogramParameterfv:with:with: glGetHistogramParameteriv:with:with: glGetIntegerv:with: glGetLightfv:with:with: glGetLightiv:with:with: glGetMapdv:with:with: glGetMapfv:with:with: glGetMapiv:with:with: glGetMaterialfv:with:with: glGetMaterialiv:with:with: glGetMinmax:with:with:with:with: glGetMinmaxParameterfv:with:with: glGetMinmaxParameteriv:with:with: glGetPixelMapfv:with: glGetPixelMapuiv:with: glGetPixelMapusv:with: glGetPointerv:with: glGetPointervEXT:with: glGetPolygonStipple: glGetSeparableFilter:with:with:with:with:with: glGetString: glGetTexEnvfv:with:with: glGetTexEnviv:with:with: glGetTexGendv:with:with: glGetTexGenfv:with:with: glGetTexGeniv:with:with: glGetTexImage:with:with:with:with: glGetTexLevelParameterfv:with:with:with: glGetTexLevelParameteriv:with:with:with: glGetTexParameterfv:with:with: glGetTexParameteriv:with:with: glHint:with: glHistogram:with:with:with: glIndexMask: glIndexPointer:with:with: glIndexPointerEXT:with:with:with: glIndexd: glIndexdv: glIndexf: glIndexfv: glIndexi: glIndexiv: glIndexs: glIndexsv: glIndexub: glIndexubv: glInitNames glInterleavedArrays:with:with: glIsEnabled: glIsList: glIsTexture: glIsTextureEXT: glLightModelf:with: glLightModelfv:with: glLightModeli:with: glLightModeliv:with: glLightf:with:with: glLightfv:with:with: glLighti:with:with: glLightiv:with:with: glLineStipple:with: glLineWidth: glListBase: glLoadIdentity glLoadMatrixd: glLoadMatrixf: glLoadName: glLogicOp: glMap1d:with:with:with:with:with: glMap1f:with:with:with:with:with: glMap2d:with:with:with:with:with:with:with:with:with: glMap2f:with:with:with:with:with:with:with:with:with: glMapGrid1d:with:with: glMapGrid1f:with:with: glMapGrid2d:with:with:with:with:with: glMapGrid2f:with:with:with:with:with: glMaterialf:with:with: glMaterialfv:with:with: glMateriali:with:with: glMaterialiv:with:with: glMatrixMode: glMinmax:with:with: glMultMatrixd: glMultMatrixf: glMultiTexCoord1dARB:with: glMultiTexCoord1dvARB:with: glMultiTexCoord1fARB:with: glMultiTexCoord1fvARB:with: glMultiTexCoord1iARB:with: glMultiTexCoord1ivARB:with: glMultiTexCoord1sARB:with: glMultiTexCoord1svARB:with: glMultiTexCoord2dARB:with:with: glMultiTexCoord2dvARB:with: glMultiTexCoord2fARB:with:with: glMultiTexCoord2fvARB:with: glMultiTexCoord2iARB:with:with: glMultiTexCoord2ivARB:with: glMultiTexCoord2sARB:with:with: glMultiTexCoord2svARB:with: glMultiTexCoord3dARB:with:with:with: glMultiTexCoord3dvARB:with: glMultiTexCoord3fARB:with:with:with: glMultiTexCoord3fvARB:with: glMultiTexCoord3iARB:with:with:with: glMultiTexCoord3ivARB:with: glMultiTexCoord3sARB:with:with:with: glMultiTexCoord3svARB:with: glMultiTexCoord4dARB:with:with:with:with: glMultiTexCoord4dvARB:with: glMultiTexCoord4fARB:with:with:with:with: glMultiTexCoord4fvARB:with: glMultiTexCoord4iARB:with:with:with:with: glMultiTexCoord4ivARB:with: glMultiTexCoord4sARB:with:with:with:with: glMultiTexCoord4svARB:with: glNewList:with: glNormal3b:with:with: glNormal3bv: glNormal3d:with:with: glNormal3dv: glNormal3f:with:with: glNormal3fv: glNormal3i:with:with: glNormal3iv: glNormal3s:with:with: glNormal3sv: glNormalPointer:with:with: glNormalPointerEXT:with:with:with: glOrtho:with:with:with:with:with: glPassThrough: glPixelMapfv:with:with: glPixelMapuiv:with:with: glPixelMapusv:with:with: glPixelStoref:with: glPixelStorei:with: glPixelTransferf:with: glPixelTransferi:with: glPixelZoom:with: glPointSize: glPolygonMode:with: glPolygonOffset:with: glPolygonStipple: glPopAttrib glPopClientAttrib glPopMatrix glPopName glPrioritizeTextures:with:with: glPushAttrib: glPushClientAttrib: glPushMatrix glPushName: glRasterPos2d:with: glRasterPos2dv: glRasterPos2f:with: glRasterPos2fv: glRasterPos2i:with: glRasterPos2iv: glRasterPos2s:with: glRasterPos2sv: glRasterPos3d:with:with: glRasterPos3dv: glRasterPos3f:with:with: glRasterPos3fv: glRasterPos3i:with:with: glRasterPos3iv: glRasterPos3s:with:with: glRasterPos3sv: glRasterPos4d:with:with:with: glRasterPos4dv: glRasterPos4f:with:with:with: glRasterPos4fv: glRasterPos4i:with:with:with: glRasterPos4iv: glRasterPos4s:with:with:with: glRasterPos4sv: glReadBuffer: glReadPixels:with:with:with:with:with:with: glRectd:with:with:with: glRectdv:with: glRectf:with:with:with: glRectfv:with: glRecti:with:with:with: glRectiv:with: glRects:with:with:with: glRectsv:with: glRenderMode: glResetHistogram: glResetMinmax: glRotated:with:with:with: glRotatef:with:with:with: glScaled:with:with: glScalef:with:with: glScissor:with:with:with: glSelectBuffer:with: glSeparableFilter2D:with:with:with:with:with:with:with: glShadeModel: glStencilFunc:with:with: glStencilMask: glStencilOp:with:with: glTexCoord1d: glTexCoord1dv: glTexCoord1f: glTexCoord1fv: glTexCoord1i: glTexCoord1iv: glTexCoord1s: glTexCoord1sv: glTexCoord2d:with: glTexCoord2dv: glTexCoord2f:with: glTexCoord2fv: glTexCoord2i:with: glTexCoord2iv: glTexCoord2s:with: glTexCoord2sv: glTexCoord3d:with:with: glTexCoord3dv: glTexCoord3f:with:with: glTexCoord3fv: glTexCoord3i:with:with: glTexCoord3iv: glTexCoord3s:with:with: glTexCoord3sv: glTexCoord4d:with:with:with: glTexCoord4dv: glTexCoord4f:with:with:with: glTexCoord4fv: glTexCoord4i:with:with:with: glTexCoord4iv: glTexCoord4s:with:with:with: glTexCoord4sv: glTexCoordPointer:with:with:with: glTexCoordPointerEXT:with:with:with:with: glTexEnvf:with:with: glTexEnvfv:with:with: glTexEnvi:with:with: glTexEnviv:with:with: glTexGend:with:with: glTexGendv:with:with: glTexGenf:with:with: glTexGenfv:with:with: glTexGeni:with:with: glTexGeniv:with:with: glTexImage1D:with:with:with:with:with:with:with: glTexImage2D:with:with:with:with:with:with:with:with: glTexImage3D:with:with:with:with:with:with:with:with:with: glTexParameterf:with:with: glTexParameterfv:with:with: glTexParameteri:with:with: glTexParameteriv:with:with: glTexSubImage1D:with:with:with:with:with:with: glTexSubImage2D:with:with:with:with:with:with:with:with: glTexSubImage3D:with:with:with:with:with:with:with:with:with:with: glTranslated:with:with: glTranslatef:with:with: glVertex2d:with: glVertex2dv: glVertex2f:with: glVertex2fv: glVertex2i:with: glVertex2iv: glVertex2s:with: glVertex2sv: glVertex3d:with:with: glVertex3dv: glVertex3f:with:with: glVertex3fv: glVertex3i:with:with: glVertex3iv: glVertex3s:with:with: glVertex3sv: glVertex4d:with:with:with: glVertex4dv: glVertex4f:with:with:with: glVertex4fv: glVertex4i:with:with:with: glVertex4iv: glVertex4s:with:with:with: glVertex4sv: glVertexPointer:with:with:with: glVertexPointerEXT:with:with:with:with: glViewport:with:with:with: realglBegin:)('extensions' extensions glExtCallingConvention glExtGetProcAddress: hasExtension: loadExtension:)('rendering' drawIndexed:faces:vertices:normals:colors:texCoords: drawIndexedQuadMesh: drawIndexedQuads:vertices:normals:colors:texCoords: drawIndexedTriangleMesh: drawIndexedTriangles:vertices:normals:colors:texCoords: setCull)('GL_ARB_texture_compression' #'glCompressedTexImage1DARB()/7' glCompressedTexImage1DARB:with:with:with:with:with:with: #'glCompressedTexImage2DARB()/8' glCompressedTexImage2DARB:with:with:with:with:with:with:with: #'glCompressedTexImage3DARB()/9' glCompressedTexImage3DARB:with:with:with:with:with:with:with:with: #'glCompressedTexSubImage1DARB()/7' glCompressedTexSubImage1DARB:with:with:with:with:with:with: #'glCompressedTexSubImage2DARB()/9' glCompressedTexSubImage2DARB:with:with:with:with:with:with:with:with: #'glCompressedTexSubImage3DARB()/11' glCompressedTexSubImage3DARB:with:with:with:with:with:with:with:with:with:with: #'glGetCompressedTexImageARB()/3' glGetCompressedTexImageARB:with:with:)('initialize' beginFrame beginFrame: beginMorphicOverlay: cleanup defaultFlags destroy endFrame endMorphicOverlay initFrustum:bounds:zNear:zFar: initialize initializeIn: makeCurrent openGLLibraryName)('GL_EXT_compiled_vertex_array' #'glLockArraysEXT()/2' glLockArraysEXT:with: glUnlockArraysEXT #'glUnlockArraysEXT()/0')('OpenGL API' #'glAccum()/2' #'glActiveTextureARB()/1' #'glAlphaFunc()/2' #'glAreTexturesResident()/3' #'glAreTexturesResidentEXT()/3' #'glArrayElement()/1' #'glArrayElementEXT()/1' #'glBegin()/1' glBegin: #'glBindTexture()/2' #'glBitmap()/7' #'glBlendColor()/4' #'glBlendEquation()/1' #'glBlendFunc()/2' #'glCallList()/1' #'glCallLists()/3' #'glClear()/1' #'glClearAccum()/4' #'glClearColor()/4' #'glClearDepth()/1' #'glClearIndex()/1' #'glClearStencil()/1' #'glClientActiveTextureARB()/1' #'glClipPlane()/2' #'glColor3b()/3' #'glColor3bv()/1' #'glColor3d()/3' #'glColor3dv()/1' #'glColor3f()/3' #'glColor3fv()/1' #'glColor3i()/3' #'glColor3iv()/1' #'glColor3s()/3' #'glColor3sv()/1' #'glColor3ub()/3' #'glColor3ubv()/1' #'glColor3ui()/3' #'glColor3uiv()/1' #'glColor3us()/3' #'glColor3usv()/1' #'glColor4b()/4' #'glColor4bv()/1' #'glColor4d()/4' #'glColor4dv()/1' #'glColor4f()/4' #'glColor4fv()/1' #'glColor4i()/4' #'glColor4iv()/1' #'glColor4s()/4' #'glColor4sv()/1' #'glColor4ub()/4' #'glColor4ubv()/1' #'glColor4ui()/4' #'glColor4uiv()/1' #'glColor4us()/4' #'glColor4usv()/1' #'glColorMask()/4' #'glColorMaterial()/2' #'glColorPointer()/4' #'glColorPointerEXT()/5' #'glColorSubTable()/6' #'glColorTable()/6' #'glColorTableParameterfv()/3' #'glColorTableParameteriv()/3' #'glConvolutionFilter1D()/6' #'glConvolutionFilter2D()/7' #'glConvolutionParameterf()/3' #'glConvolutionParameterfv()/3' #'glConvolutionParameteri()/3' #'glConvolutionParameteriv()/3' #'glCopyColorSubTable()/5' #'glCopyColorTable()/5' #'glCopyConvolutionFilter1D()/5' #'glCopyConvolutionFilter2D()/6' #'glCopyPixels()/5' #'glCopyTexImage1D()/7' #'glCopyTexImage2D()/8' #'glCopyTexSubImage1D()/6' #'glCopyTexSubImage2D()/8' #'glCopyTexSubImage3D()/9' #'glCullFace()/1' #'glDeleteLists()/2' #'glDeleteTextures()/2' #'glDeleteTexturesEXT()/2' #'glDepthFunc()/1' #'glDepthMask()/1' #'glDepthRange()/2' #'glDisable()/1' #'glDisableClientState()/1' #'glDrawArrays()/3' #'glDrawArraysEXT()/3' #'glDrawBuffer()/1' #'glDrawElements()/4' #'glDrawPixels()/5' #'glDrawRangeElements()/6' #'glEdgeFlag()/1' #'glEdgeFlagPointer()/2' #'glEdgeFlagPointerEXT()/3' #'glEdgeFlagv()/1' #'glEnable()/1' #'glEnableClientState()/1' #'glEnd()/0' #'glEndList()/0' #'glEvalCoord1d()/1' #'glEvalCoord1dv()/1' #'glEvalCoord1f()/1' #'glEvalCoord1fv()/1' #'glEvalCoord2d()/2' #'glEvalCoord2dv()/1' #'glEvalCoord2f()/2' #'glEvalCoord2fv()/1' #'glEvalMesh1()/3' #'glEvalMesh2()/5' #'glEvalPoint1()/1' #'glEvalPoint2()/2' #'glFeedbackBuffer()/3' #'glFinish()/0' #'glFlush()/0' #'glFogf()/2' #'glFogfv()/2' #'glFogi()/2' #'glFogiv()/2' #'glFrontFace()/1' #'glFrustum()/6' #'glGenLists()/1' #'glGenTextures()/2' #'glGenTexturesEXT()/2' #'glGetBooleanv()/2' #'glGetClipPlane()/2' #'glGetColorTable()/4' #'glGetColorTableParameterfv()/3' #'glGetColorTableParameteriv()/3' #'glGetConvolutionFilter()/4' #'glGetConvolutionParameterfv()/3' #'glGetConvolutionParameteriv()/3' #'glGetDoublev()/2' #'glGetError()/0' #'glGetFloatv()/2' #'glGetHistogram()/5' #'glGetHistogramParameterfv()/3' #'glGetHistogramParameteriv()/3' #'glGetIntegerv()/2' #'glGetLightfv()/3' #'glGetLightiv()/3' #'glGetMapdv()/3' #'glGetMapfv()/3' #'glGetMapiv()/3' #'glGetMaterialfv()/3' #'glGetMaterialiv()/3' #'glGetMinmax()/5' #'glGetMinmaxParameterfv()/3' #'glGetMinmaxParameteriv()/3' #'glGetPixelMapfv()/2' #'glGetPixelMapuiv()/2' #'glGetPixelMapusv()/2' #'glGetPointerv()/2' #'glGetPointervEXT()/2' #'glGetPolygonStipple()/1' #'glGetSeparableFilter()/6' #'glGetString()/1' #'glGetTexEnvfv()/3' #'glGetTexEnviv()/3' #'glGetTexGendv()/3' #'glGetTexGenfv()/3' #'glGetTexGeniv()/3' #'glGetTexImage()/5' #'glGetTexLevelParameterfv()/4' #'glGetTexLevelParameteriv()/4' #'glGetTexParameterfv()/3' #'glGetTexParameteriv()/3' #'glHint()/2' #'glHistogram()/4' #'glIndexMask()/1' #'glIndexPointer()/3' #'glIndexPointerEXT()/4' #'glIndexd()/1' #'glIndexdv()/1' #'glIndexf()/1' #'glIndexfv()/1' #'glIndexi()/1' #'glIndexiv()/1' #'glIndexs()/1' #'glIndexsv()/1' #'glIndexub()/1' #'glIndexubv()/1' #'glInitNames()/0' #'glInterleavedArrays()/3' #'glIsEnabled()/1' #'glIsList()/1' #'glIsTexture()/1' #'glIsTextureEXT()/1' #'glLightModelf()/2' #'glLightModelfv()/2' #'glLightModeli()/2' #'glLightModeliv()/2' #'glLightf()/3' #'glLightfv()/3' #'glLighti()/3' #'glLightiv()/3' #'glLineStipple()/2' #'glLineWidth()/1' #'glListBase()/1' #'glLoadIdentity()/0' #'glLoadMatrixd()/1' #'glLoadMatrixf()/1' #'glLoadName()/1' #'glLogicOp()/1' #'glMap1d()/6' #'glMap1f()/6' #'glMap2d()/10' #'glMap2f()/10' #'glMapGrid1d()/3' #'glMapGrid1f()/3' #'glMapGrid2d()/6' #'glMapGrid2f()/6' #'glMaterialf()/3' #'glMaterialfv()/3' #'glMateriali()/3' #'glMaterialiv()/3' #'glMatrixMode()/1' #'glMinmax()/3' #'glMultMatrixd()/1' #'glMultMatrixf()/1' #'glMultiTexCoord1dARB()/2' #'glMultiTexCoord1dvARB()/2' #'glMultiTexCoord1fARB()/2' #'glMultiTexCoord1fvARB()/2' #'glMultiTexCoord1iARB()/2' #'glMultiTexCoord1ivARB()/2' #'glMultiTexCoord1sARB()/2' #'glMultiTexCoord1svARB()/2' #'glMultiTexCoord2dARB()/3' #'glMultiTexCoord2dvARB()/2' #'glMultiTexCoord2fARB()/3' #'glMultiTexCoord2fvARB()/2' #'glMultiTexCoord2iARB()/3' #'glMultiTexCoord2ivARB()/2' #'glMultiTexCoord2sARB()/3' #'glMultiTexCoord2svARB()/2' #'glMultiTexCoord3dARB()/4' #'glMultiTexCoord3dvARB()/2' #'glMultiTexCoord3fARB()/4' #'glMultiTexCoord3fvARB()/2' #'glMultiTexCoord3iARB()/4' #'glMultiTexCoord3ivARB()/2' #'glMultiTexCoord3sARB()/4' #'glMultiTexCoord3svARB()/2' #'glMultiTexCoord4dARB()/5' #'glMultiTexCoord4dvARB()/2' #'glMultiTexCoord4fARB()/5' #'glMultiTexCoord4fvARB()/2' #'glMultiTexCoord4iARB()/5' #'glMultiTexCoord4ivARB()/2' #'glMultiTexCoord4sARB()/5' #'glMultiTexCoord4svARB()/2' #'glNewList()/2' #'glNormal3b()/3' #'glNormal3bv()/1' #'glNormal3d()/3' #'glNormal3dv()/1' #'glNormal3f()/3' #'glNormal3fv()/1' #'glNormal3i()/3' #'glNormal3iv()/1' #'glNormal3s()/3' #'glNormal3sv()/1' #'glNormalPointer()/3' #'glNormalPointerEXT()/4' #'glOrtho()/6' #'glPassThrough()/1' #'glPixelMapfv()/3' #'glPixelMapuiv()/3' #'glPixelMapusv()/3' #'glPixelStoref()/2' #'glPixelStorei()/2' #'glPixelTransferf()/2' #'glPixelTransferi()/2' #'glPixelZoom()/2' #'glPointSize()/1' #'glPolygonMode()/2' #'glPolygonOffset()/2' #'glPolygonStipple()/1' #'glPopAttrib()/0' #'glPopClientAttrib()/0' #'glPopMatrix()/0' #'glPopName()/0' #'glPrioritizeTextures()/3' #'glPushAttrib()/1' #'glPushClientAttrib()/1' #'glPushMatrix()/0' #'glPushName()/1' #'glRasterPos2d()/2' #'glRasterPos2dv()/1' #'glRasterPos2f()/2' #'glRasterPos2fv()/1' #'glRasterPos2i()/2' #'glRasterPos2iv()/1' #'glRasterPos2s()/2' #'glRasterPos2sv()/1' #'glRasterPos3d()/3' #'glRasterPos3dv()/1' #'glRasterPos3f()/3' #'glRasterPos3fv()/1' #'glRasterPos3i()/3' #'glRasterPos3iv()/1' #'glRasterPos3s()/3' #'glRasterPos3sv()/1' #'glRasterPos4d()/4' #'glRasterPos4dv()/1' #'glRasterPos4f()/4' #'glRasterPos4fv()/1' #'glRasterPos4i()/4' #'glRasterPos4iv()/1' #'glRasterPos4s()/4' #'glRasterPos4sv()/1' #'glReadBuffer()/1' #'glReadPixels()/7' #'glRectd()/4' #'glRectdv()/2' #'glRectf()/4' #'glRectfv()/2' #'glRecti()/4' #'glRectiv()/2' #'glRects()/4' #'glRectsv()/2' #'glRenderMode()/1' #'glResetHistogram()/1' #'glResetMinmax()/1' #'glRotated()/4' #'glRotatef()/4' #'glScaled()/3' #'glScalef()/3' #'glScissor()/4' #'glSelectBuffer()/2' #'glSeparableFilter2D()/8' #'glShadeModel()/1' #'glStencilFunc()/3' #'glStencilMask()/1' #'glStencilOp()/3' #'glTexCoord1d()/1' #'glTexCoord1dv()/1' #'glTexCoord1f()/1' #'glTexCoord1fv()/1' #'glTexCoord1i()/1' #'glTexCoord1iv()/1' #'glTexCoord1s()/1' #'glTexCoord1sv()/1' #'glTexCoord2d()/2' #'glTexCoord2dv()/1' #'glTexCoord2f()/2' #'glTexCoord2fv()/1' #'glTexCoord2i()/2' #'glTexCoord2iv()/1' #'glTexCoord2s()/2' #'glTexCoord2sv()/1' #'glTexCoord3d()/3' #'glTexCoord3dv()/1' #'glTexCoord3f()/3' #'glTexCoord3fv()/1' #'glTexCoord3i()/3' #'glTexCoord3iv()/1' #'glTexCoord3s()/3' #'glTexCoord3sv()/1' #'glTexCoord4d()/4' #'glTexCoord4dv()/1' #'glTexCoord4f()/4' #'glTexCoord4fv()/1' #'glTexCoord4i()/4' #'glTexCoord4iv()/1' #'glTexCoord4s()/4' #'glTexCoord4sv()/1' #'glTexCoordPointer()/4' #'glTexCoordPointerEXT()/5' #'glTexEnvf()/3' #'glTexEnvfv()/3' #'glTexEnvi()/3' #'glTexEnviv()/3' #'glTexGend()/3' #'glTexGendv()/3' #'glTexGenf()/3' #'glTexGenfv()/3' #'glTexGeni()/3' #'glTexGeniv()/3' #'glTexImage1D()/8' #'glTexImage2D()/9' #'glTexImage3D()/10' #'glTexParameterf()/3' #'glTexParameterfv()/3' #'glTexParameteri()/3' #'glTexParameteriv()/3' #'glTexSubImage1D()/7' #'glTexSubImage2D()/9' #'glTexSubImage3D()/11' #'glTranslated()/3' #'glTranslatef()/3' #'glVertex2d()/2' #'glVertex2dv()/1' #'glVertex2f()/2' #'glVertex2fv()/1' #'glVertex2i()/2' #'glVertex2iv()/1' #'glVertex2s()/2' #'glVertex2sv()/1' #'glVertex3d()/3' #'glVertex3dv()/1' #'glVertex3f()/3' #'glVertex3fv()/1' #'glVertex3i()/3' #'glVertex3iv()/1' #'glVertex3s()/3' #'glVertex3sv()/1' #'glVertex4d()/4' #'glVertex4dv()/1' #'glVertex4f()/4' #'glVertex4fv()/1' #'glVertex4i()/4' #'glVertex4iv()/1' #'glVertex4s()/4' #'glVertex4sv()/1' #'glVertexPointer()/4' #'glVertexPointerEXT()/5' #'glViewport()/4')('display lists' instance registerList:range:owner: unregisterList:)('private' privateInstallLibrary: test2D)('gotchas' popMatrix pushMatrix)('text support' drawParagraph:color:at:align: drawString:at: drawString:at:font:color: drawString:at:font:color:align: drawString:from:to:at:font: drawString:from:to:at:font:align: drawString:from:to:at:font:color: drawStringRect:at:color:align: frameStringRect:at:color:align:)!!OGLTextureManager class reorganize!('as yet unclassified')!!OGLTextureManager reorganize!('initialize' beginFrame cleanup endFrame initialize: releaseTextureMemoryIfNeeded)('accessing' bindTexture: deleteTexture: releaseTexture: setTextureSizeOf:to: textureHandleOf: textureHandleOf:ifAbsent: textureSizeOf: uploadTexture: uploadTexture:dirtyRect:)('private' compressedSizeOf:at:form: scaleTexture:to:)('stats' memFrame memUsed numTexturesBound numTexturesReused numTexturesUsed)!!OGLTextureHandle class reorganize!('as yet unclassified')!!OGLTextureHandle reorganize!('accessing' bytesUsed bytesUsed: glID glID: isAllocated isAllocated: scaledSize scaledSize: target target: timeStamp timeStamp:)('printing' printOn:)!!OGLFontManager class reorganize!('as yet unclassified')!!OGLFontManager reorganize!('displaying' drawString:from:to:font: drawString:from:to:font:align: drawStringRect:align: frameStringRect:align: uploadFont:)('initialize' initialize:)!OGLExtManager initialize!!OGLExtManager class reorganize!('GL_ARB_texture_compression' #'glCompressedTexImage1DARB()/7' glCompressedTexImage1DARB:with:with:with:with:with:with: #'glCompressedTexImage2DARB()/8' glCompressedTexImage2DARB:with:with:with:with:with:with:with: #'glCompressedTexImage3DARB()/9' glCompressedTexImage3DARB:with:with:with:with:with:with:with:with: #'glCompressedTexSubImage1DARB()/7' glCompressedTexSubImage1DARB:with:with:with:with:with:with: #'glCompressedTexSubImage2DARB()/9' glCompressedTexSubImage2DARB:with:with:with:with:with:with:with:with: #'glCompressedTexSubImage3DARB()/11' glCompressedTexSubImage3DARB:with:with:with:with:with:with:with:with:with:with: #'glGetCompressedTexImageARB()/3' glGetCompressedTexImageARB:with:with: initializeArbTextureCompression)('GL_EXT_texture_compression_s3tc' initializeExtTextureCompressionS3tc)('GL_EXT_compiled_vertex_array' #'glLockArraysEXT()/2' glLockArraysEXT:with: glUnlockArraysEXT #'glUnlockArraysEXT()/0' initializeExtCompiledVertexArray)('GL_SGIS_generate_mipmap' initializeSgisGenerateMipmap)('class initialization' forwardExtMethod: initialize install:withEXTConstants: parseEXTConstants:)('instance creation' new)!!OGLExtManager reorganize!('dynamic lookup' doesNotUnderstand: loadExtension:)('accessing' ogl ogl:)!!OGLCanvas class reorganize!('as yet unclassified')!!OGLCanvas reorganize!('private' fillOval: fillPoly: fillRect: frameOval: framePoly: frameRectInner:outer: lineFrom:to: setFillColor: setLineWidth:)('drawing-support' clipBy:during: clipRect contentsOfArea:into: drawPolygon:color:borderWidth:borderColor: drawString:from:to:in:font:color: extent fillOval:color:borderWidth:borderColor: frameAndFillRectangle:fillColor:borderWidth:borderColor: image:at:sourceRect:rule: line:to:width:color: origin paragraph:bounds:color: stencil:at:sourceRect:color: transformBy:clippingTo:during:smoothing: translateBy:during: warpImage:transform:at:sourceRect:cellSize:)('copying' copy)('initialize' initialize:)!!OGLBlt class reorganize!('as yet unclassified')!!OGLBlt reorganize!('text display' displayString:from:to:at:strikeFont:kern: fillRectangle:color: installStrikeFont:foregroundColor:backgroundColor: textOffset: textPosition:)('initialize' initialize:)!MPEGFile initialize!!CroquetTools class reorganize!('changes' fileOutAllChangesTo: filterAllChangesFrom:to: mergeAllChangesFrom:to:)!!CroquetTools reorganize!('as yet unclassified')!!CroquetGlobals class reorganize!('as yet unclassified' acrossWorldsStuff frameScale frameScale: frameScaleInverse frameScaleSquared messageList objectNamed: registerTeaObject: snapshots snapshots: teaParty textureAt:ifAbsentPut: theTeapotMorph theTeapotMorph:)!!CroquetGlobals reorganize!('as yet unclassified')!!CroquetData class reorganize!('as yet unclassified' download:whenFinishedSend:to: findContentFileName: findTextureFileName: load3dsFile: loadAliceFile: loadAliceModel:url: loadAliceModels: loadAmbientSound: loadFormAtPath: loadIcon2: loadIcon: loadIcon:defaultExtent: loadImageUrl: loadLocator: loadLocator:reuseExisting: loadURL: loadURL:reuseExisting: logError:)!!CroquetData reorganize!('as yet unclassified')!