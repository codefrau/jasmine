'From Squeak3.6 of ''6 October 2003'' [latest update: #5429] on 4 October 2004 at 10:02:20 pm'!ProtoObject subclass: #CCollectionMatcher	instanceVariableNames: 'target '	classVariableNames: ''	poolDictionaries: ''	category: 'Tweak-Collections'!!CCollectionMatcher commentStamp: 'ar 3/27/2004 17:21' prior: 0!I am an abstract base class for collection matchers such as the Any or the All matcher.!CCollectionMatcher subclass: #CAllMatcher	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'Tweak-Collections'!!CAllMatcher commentStamp: 'ar 3/27/2004 17:20' prior: 0!I am a simple helper which allows to use the "all" message with collections, e.g.,	#('foo.zip' 'bar.zip') all endsWith: '.zip'!CCollectionMatcher subclass: #CAnyMatcher	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'Tweak-Collections'!!CAnyMatcher commentStamp: 'ar 3/27/2004 17:20' prior: 0!I am a simple helper which allows to use the "all" message with collections, e.g.,	#('foo.zip' 'bar.zip') any endsWith: '.zip'!Object subclass: #CBorder	instanceVariableNames: ''	classVariableNames: 'Default '	poolDictionaries: ''	category: 'Tweak-Costumes-Borders'!Object subclass: #CCanvasCache	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'Tweak-Costumes-Support'!Object subclass: #CChangeRecord	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'Tweak-Undo'!Object subclass: #CClipboard	instanceVariableNames: 'contents '	classVariableNames: 'Default '	poolDictionaries: ''	category: 'Tweak-Costumes-Support'!Association subclass: #CComponentBinding	instanceVariableNames: 'home '	classVariableNames: ''	poolDictionaries: ''	category: 'Tweak-Support'!!CComponentBinding commentStamp: 'ar 3/15/2004 21:21' prior: 0!A component binding is an optimized representation of a two-way link between a component owner and the owned component.Instance variables:	key		<Symbol>	The name of the component (as known to its owner)	value	<Object>		The component	home	<Object>		The component owner.The component binding is used by the owner to point to its component (retrieving the value) whereas it is stored in the component's componentBinding field and the component refers to its owner via the home of the binding.!Object subclass: #CCornerRounder	instanceVariableNames: 'cornerMasks cornerOverlays underBits '	classVariableNames: 'CR0 CR1 CR2 '	poolDictionaries: ''	category: 'Tweak-Costumes-Support'!Object subclass: #CCostumePen	instanceVariableNames: 'width color isDown points pathLength '	classVariableNames: ''	poolDictionaries: ''	category: 'Tweak-Costumes-TODO'!!CCostumePen commentStamp: 'ar 3/27/2004 17:53' prior: 0!CCostumePen represents the pen aspect of a costume.Instance variables:	width	<Number>	The width of the pen.	color	<Color>		The color of the pen.	isDown	<Boolean>	Whether the pen is currently down.	points	<Collection of: Point>	The recorded points for this pen.	pathLength	<Number>	The total length of the path.!Object subclass: #CCursorLibrary	instanceVariableNames: ''	classVariableNames: 'Default '	poolDictionaries: ''	category: 'Tweak-Support'!Object subclass: #CDamageRecorder	instanceVariableNames: 'invalidRects totalRepaint '	classVariableNames: ''	poolDictionaries: ''	category: 'Tweak-Costumes-Support'!Object subclass: #CDeserializer	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'Tweak-Serializer'!Object subclass: #CDisplayTransform	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'Tweak-Costumes-Transforms'!!CDisplayTransform commentStamp: 'ar 3/27/2004 17:58' prior: 0!This class represents a base for generic transformations of 2D points between different coordinate systems (including scaling and rotation). The transformations map objects between one coordinate system and another where it is assumed that a nested hierarchy of transformations can be defined.It is assumed that transformations deal with Integer points. All transformations should return Integer coordinates (even though float points may be passed in as argument).Compositions of transformations MUST work in the following order. A 'global' transformation (the argument in #composedWithGlobal:) is defined as a transformation that takes place between the receiver (the 'local') transformation and any 'global' point computations, whereas a 'local' transformation (e.g., the argument in #composedWithLocal:) takes place between the receiver ('global') and any 'local' points. For the transformation methods this means that combining a global and a local transformation will result in the following order:		globalPointToLocal: globalPoint			"globalPoint -> globalTransform -> localTransform -> locaPoint"			^localTransform globalPointToLocal:				(globalTransform globalPointToLocal: globalPoint)		localPointToGlobal: localPoint			"localPoint -> localTransform -> globalTransform -> globalPoint"			^globalTransform localPointToGlobal:				(localTransform localPointToGlobal: localPoint)!CCanvasCache subclass: #CFormCache	instanceVariableNames: 'valid form damageRecorder '	classVariableNames: ''	poolDictionaries: ''	category: 'Tweak-Costumes-Support'!Object subclass: #CGraphicsFill	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'Tweak-Costumes-Fills'!Object subclass: #CGraphicsShape	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'Tweak-Costumes-TODO'!!CGraphicsShape commentStamp: 'ar 3/27/2004 17:53' prior: 0!CGraphicsShape is the abstract superclass for all objects which represent the shape aspect of some costume.!Object subclass: #CIconLibrary	instanceVariableNames: 'icons '	classVariableNames: 'Default '	poolDictionaries: ''	category: 'Tweak-Support'!CDisplayTransform subclass: #CIdentityTransform	instanceVariableNames: ''	classVariableNames: 'Default '	poolDictionaries: ''	category: 'Tweak-Costumes-Transforms'!!CIdentityTransform commentStamp: 'ar 3/27/2004 17:59' prior: 0!I am the identity transform. And because I am I can do a whole lot of optimizations.!Object subclass: #CKeyboardDispatchTable	instanceVariableNames: 'metaTable '	classVariableNames: ''	poolDictionaries: ''	category: 'Tweak-Widgets-Support'!!CKeyboardDispatchTable commentStamp: 'ar 3/27/2004 18:01' prior: 0!CKeyboardDispatchTable simplifies mapping from particular keyboard events to specific actions.!Object subclass: #CLayoutCell	instanceVariableNames: 'target cellSize extraSpace flags nextCell '	classVariableNames: ''	poolDictionaries: ''	category: 'Tweak-Costumes-Layouts'!!CLayoutCell commentStamp: 'ar 3/27/2004 18:02' prior: 0!I am used in table layouts to hold temporary values while the layout is being computed.Instance variables:	target 		<Morph>		The morph contained in this cell	cellSize 		<Point>		The size of the cell	extraSpace 	<nil | Point>	Additional space to add after this cell	nextCell 	<nil | LayoutCell>	The next cell in the arrangement.Implementation note:Both, cellSize and extraSpace contains points where	x - represents the primary table direction	y - represents the secondary table direction!Object subclass: #CLayoutFrame	instanceVariableNames: 'leftFraction leftOffset topFraction topOffset rightFraction rightOffset bottomFraction bottomOffset '	classVariableNames: ''	poolDictionaries: ''	category: 'Tweak-Costumes-Layouts'!!CLayoutFrame commentStamp: 'ar 3/27/2004 18:02' prior: 0!I define a frame for positioning some morph in a proportional layout.Instance variables:	leftFraction 	topFraction 	rightFraction 	bottomFraction 	<Float>		The fractional distance (between 0 and 1) to place the morph in its owner's bounds	leftOffset 	topOffset 	rightOffset 	bottomOffset 	<Integer>	Fixed pixel offset to apply after fractional positioning (e.g., "10 pixel right of the center of the owner")!Object subclass: #CLayoutProperties	instanceVariableNames: 'hResizing vResizing layoutInset '	classVariableNames: ''	poolDictionaries: ''	category: 'Tweak-Costumes-Layouts'!!CLayoutProperties commentStamp: 'ar 3/27/2004 18:02' prior: 0!This class provides a compact bit encoding for the most commonly used layout properties.!Object subclass: #CMD5Hasher	instanceVariableNames: 'state '	classVariableNames: 'ABCDTable IndexTable ShiftTable SinTable '	poolDictionaries: ''	category: 'Tweak-Support'!!CMD5Hasher commentStamp: 'DSM 1/20/2000 14:08' prior: 0!This class implements the MD5 128-bit one-way hash function.  It relies onthe ThirtyTwoBitRegister class supplied as part of the "Digital Signatures"functionality included in Squeak 2.7.  As of this date (1/20/2000), theU.S. Government has lifted many of the previous restrictions on the exportof encryption software, but you should check before exporting anythingincluding this code.  MD5 is commonly used for some secure Internetprotocols, including authentication in HTTP, which is why I wrote it.Submitted by Duane Maxwell!Object subclass: #CMakerPart	instanceVariableNames: 'value '	classVariableNames: ''	poolDictionaries: ''	category: 'Tweak-Maker-Parts'!CMakerPart subclass: #CGlobalPart	instanceVariableNames: 'globalName globalSelector globalArgs '	classVariableNames: ''	poolDictionaries: ''	category: 'Tweak-Maker-Parts'!CDisplayTransform variableWordSubclass: #CMatrixTransform	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'Tweak-Costumes-Transforms'!!CMatrixTransform commentStamp: 'ar 3/27/2004 17:59' prior: 0!This class represents a transformation for points, that is a combination of scale, offset, and rotation. It is implemented as a 2x3 matrix containing the transformation from the local coordinate system in the global coordinate system. Thus, transforming points from local to global coordinates is fast and cheap whereas transformations from global to local coordinate systems are relatively expensive.Implementation Note: It is assumed that the transformation deals with Integer points. All transformations will return Integer coordinates (even though float points may be passed in here).!Object subclass: #CMouseClickState	instanceVariableNames: 'clickClient clickState firstClickDown firstClickUp firstClickTime clickSelector dblClickSelector dblClickTime dblClickTimeoutSelector dragSelector dragThreshold '	classVariableNames: ''	poolDictionaries: ''	category: 'Tweak-Costumes-Support'!Object subclass: #CMouseOverHandler	instanceVariableNames: 'mouseOverList enteredList overList leftList '	classVariableNames: ''	poolDictionaries: ''	category: 'Tweak-Costumes-Support'!CProtoObject subclass: #CObject	instanceVariableNames: '<?xml  version="1.0"?><fields><field instanceVariable="true">myProperties</field><field instanceVariable="true" toSet="myScripts:">myScripts</field><field instanceVariable="true" toSet="myEventMap:">myEventMap</field><field toGet="name" toSet="name:" changeEvent="nameChanged">name</field><field toGet="value" toSet="value:" changeEvent="valueChanged" serializer="writeValueOn:" deserializer="readValueFrom:">value</field><field virtual="true" toGet="components">components</field></fields>'	classVariableNames: ''	poolDictionaries: ''	category: 'Tweak-User-Kernel'!!CObject commentStamp: 'ar 3/27/2004 18:05' prior: 0!CObject defines the notions that any object in the Tweak universe should have.!CObject subclass: #CCollectionBase	instanceVariableNames: '<?xml  version="1.0"?><fields><field virtual="true" toGet="cursor" toSet="cursor:" changeEvent="cursorChanged">cursor</field><field virtual="true" toGet="wrapCursor" toSet="wrapCursor:" changeEvent="wrapCursorChanged">wrapCursor</field><field toGet="elements" toSet="elements:" changeEvent="elementsChanged">elements</field></fields>'	classVariableNames: ''	poolDictionaries: ''	category: 'Tweak-Collections'!!CCollectionBase commentStamp: 'ar 3/16/2004 10:44' prior: 0!CCollectionBase defines the generic interface for collections inside Tweak.!CCollectionBase subclass: #CCollection	instanceVariableNames: '<?xml  version="1.0"?><fields><field instanceVariable="true">values</field><field instanceVariable="true" toSet="cursor:">cursor</field></fields>'	classVariableNames: ''	poolDictionaries: ''	category: 'Tweak-User-Kernel'!!CCollection commentStamp: 'ar 3/27/2004 18:04' prior: 0!CCollection defines the generic collection implementation based on CCollectionBase (which defines the interface).Instance variables:	values		<Array>		The values of the collection.	cursor		<Number>	The primary cursor of the collection.!CObject subclass: #CCollectionClient	instanceVariableNames: '<?xml  version="1.0"?><fields></fields>'	classVariableNames: ''	poolDictionaries: ''	category: 'Tweak-Collections'!!CCollectionClient commentStamp: 'ar 3/15/2004 15:52' prior: 0!CCollectionClient defines the implementation side of a full collection. It provides a much smaller interface which has to be implemented for 'types' of collections.!CCollectionClient subclass: #CArrayedCollectionClient	instanceVariableNames: '<?xml  version="1.0"?><fields><field instanceVariable="true">values</field><field toGet="cursor" toSet="cursor:" changeEvent="cursorChanged">cursor</field><field toGet="wrapCursor" toSet="wrapCursor:" changeEvent="wrapCursorChanged">wrapCursor</field></fields>'	classVariableNames: ''	poolDictionaries: ''	category: 'Tweak-Collections'!CObject subclass: #CCostumeAspect	instanceVariableNames: '<?xml  version="1.0"?><fields><field instanceVariable="true" toSet="costume:">costume</field></fields>'	classVariableNames: ''	poolDictionaries: ''	category: 'Tweak-Costumes-Aspects'!!CCostumeAspect commentStamp: 'ar 3/27/2004 17:33' prior: 0!CCostumeAspect is the abstract base class for all aspects manifest in primitive costumes. All aspects share some properties: They are owned by their costume, e.g., they are NEVER shared between costumes. They must be copied if a client wants to remember a particular aspect for saving/restoring it (say, remembering the fill, changing it, and restoring it) and they will notify their costume about any changes done to them.Instance variables:	costume		<CPrimitiveCostume>	The costume owning me.!CCostumeAspect subclass: #CCostumeBorder	instanceVariableNames: '<?xml  version="1.0"?><fields><field instanceVariable="true" toSet="style:">style</field><field instanceVariable="true" toSet="width:">width</field><field instanceVariable="true" toSet="color:">color</field><field instanceVariable="true">cachedBorder</field></fields>'	classVariableNames: ''	poolDictionaries: ''	category: 'Tweak-Costumes-Aspects'!!CCostumeBorder commentStamp: 'ar 3/27/2004 17:34' prior: 0!CCostumeBorder represents the border aspect of a costume. Borders are generally described by their 'style' (the way in which the border should be drawn) their width and their color. The border aspect utilizes CBorder objects to actually perform most of the work.Instance variables:	style 			<Symbol>	The border's style.	width 			<Number>	The border's width.	color 			<Color>		The border's color.	cachedBorder	<CBorder>	The internal border representation. !CCostumeAspect subclass: #CCostumeFill	instanceVariableNames: '<?xml  version="1.0"?><fields><field instanceVariable="true" toSet="style:">style</field><field instanceVariable="true" toSet="colors:">colors</field><field instanceVariable="true" toSet="alpha:">alpha</field><field instanceVariable="true" toSet="offset:">offset</field><field instanceVariable="true" toSet="angle:">angle</field><field instanceVariable="true" toSet="frame:">frame</field><field instanceVariable="true">cachedFill</field></fields>'	classVariableNames: ''	poolDictionaries: ''	category: 'Tweak-Costumes-Aspects'!!CCostumeFill commentStamp: 'ar 3/27/2004 17:36' prior: 0!CCostumeFill represents the fill aspect of a costume.Instance variables:	style 		<Symbol>			The fill style.	colors 		<Array of: Color>	The fill colors.	alpha 		<Float>				The alpha value of the fill (0-1)	offset 		<Point>				The offset of the fill.	angle 		<Number>			The angle of the fill.	frame 		<Rectangle>			The bounding box for the fill.	cachedFill	<CGraphicsFill> 		The (internal) representation of the fill!CCostumeAspect subclass: #CCostumeGraphic	instanceVariableNames: '<?xml  version="1.0"?><fields><field instanceVariable="true" toSet="form:">form</field><field instanceVariable="true" toSet="fit:">fit</field><field instanceVariable="true" toSet="opaque:">opaque</field><field instanceVariable="true" toSet="offset:">offset</field><field instanceVariable="true" toSet="anchorPoint:">anchorPoint</field><field instanceVariable="true" toSet="sourceRect:">sourceRect</field></fields>'	classVariableNames: ''	poolDictionaries: ''	category: 'Tweak-Costumes-Aspects'!!CCostumeGraphic commentStamp: 'bf 4/2/2004 20:31' prior: 0!CCostumeGraphic represents the (background) graphic aspect of a costume.Instance variables:	form			<Form>		The form to be used.	fit 				<Symbol>	How the form should be fitted.	opaque 			<Boolean>	Whether the form should be treated as opaque or not.	offset 			<Point>		The offset of the graphic.	anchorPoint		<Symbol>	Where to anchor the graphic.	sourceRect		<Rectangle>	Which portion of the graphic to use !CCostumeAspect subclass: #CCostumeGrid	instanceVariableNames: '<?xml  version="1.0"?><fields><field instanceVariable="true" toSet="origin:">origin</field><field instanceVariable="true" toSet="extent:">extent</field><field instanceVariable="true" toSet="enabled:">enabled</field><field instanceVariable="true" toSet="visible:">visible</field><field instanceVariable="true" toSet="color:">color</field></fields>'	classVariableNames: 'GridCache '	poolDictionaries: ''	category: 'Tweak-Costumes-Aspects'!!CCostumeGrid commentStamp: 'ar 3/27/2004 17:39' prior: 0!CCostumeGrid represents the grid aspect of a costume.Instance variables:	origin 		<Point>		The origin of the grid.	extent 		<Point>		The extent (modulus) of the grid.	enabled 	<Boolean>	Whether this grid is active or not.	visible 		<Boolean>	Whether this grid is visible.	color		<Color>		The color of the grid. !CCostumeAspect subclass: #CCostumeHighlight	instanceVariableNames: '<?xml  version="1.0"?><fields><field instanceVariable="true" toSet="name:">name</field><field instanceVariable="true" toSet="active:">active</field></fields>'	classVariableNames: ''	poolDictionaries: ''	category: 'Tweak-Costumes-Highlights'!!CCostumeHighlight commentStamp: 'ar 3/27/2004 17:44' prior: 0!Costume highlights allow to add rendering behavior dynamically to costumes. Costume highlights are treated like other aspects but since they are dynamic they don't have an intrinsic name but must be explicitly named.Instance variables:	name 	<Symbol>	The name of the highlight (aspect name)	active	<Boolean>	Whether this highlight is active. !CCostumeHighlight subclass: #CBorderHighlight	instanceVariableNames: '<?xml  version="1.0"?><fields><field instanceVariable="true" toSet="border:">border</field><field instanceVariable="true">prior</field></fields>'	classVariableNames: ''	poolDictionaries: ''	category: 'Tweak-Costumes-Highlights'!!CBorderHighlight commentStamp: 'ar 3/27/2004 17:45' prior: 0!CBorderHighlight temporarily replaces a Costume's border with another one.Instance variables:	border 	<CCostumeBorder>	The border attributes to use	prior	<CCostumeBorder>	The previous border attributes. !CCostumeHighlight subclass: #CCoronaHighlight	instanceVariableNames: '<?xml  version="1.0"?><fields><field instanceVariable="true" toSet="color:">color</field><field instanceVariable="true" toSet="width:">width</field></fields>'	classVariableNames: ''	poolDictionaries: ''	category: 'Tweak-Costumes-Highlights'!!CCoronaHighlight commentStamp: 'bf 4/2/2004 16:14' prior: 0!CCoronaHighlight draws a 'corona' around the costume.Instance variables:	color 	<Color>	The color to be used for the halo.	width 	<Number>	The extent of the halo.!CCostumeAspect subclass: #CCostumeTextHolder	instanceVariableNames: '<?xml  version="1.0"?><fields><field instanceVariable="true" toSet="text:">text</field><field instanceVariable="true">paragraph</field><field instanceVariable="true">editor</field><field instanceVariable="true" toSet="offset:">offset</field><field instanceVariable="true" toSet="color:">color</field><field instanceVariable="true" toSet="borderWidth:">borderWidth</field><field instanceVariable="true" toSet="borderColor:">borderColor</field><field instanceVariable="true" toSet="anchorPoint:">anchorPoint</field><field instanceVariable="true" toSet="inset:">inset</field><field instanceVariable="true">displaying</field><field instanceVariable="true" toSet="showCaret:">showCaret</field><field instanceVariable="true" toSet="wrapContents:">wrapContents</field><field instanceVariable="true" toSet="emphasis:">emphasis</field><field instanceVariable="true" toSet="font:">font</field></fields>'	classVariableNames: 'DefaultBorder '	poolDictionaries: ''	category: 'Tweak-Costumes-Aspects'!!CCostumeTextHolder commentStamp: 'ar 3/27/2004 17:43' prior: 0!CCostumeTextHolder represents the text aspect of a costume.Instance variables:	text 			<Text>				The text.	offset 			<Point>				The offset for the text	color 			<Color>				The default color of the text.	borderWidth 	<Number>			The border width for the text	borderColor 		<Color>				The border color for the text.	anchorPoint 	<Symbol>			The anchor point for the text.	inset 			<Point>				The text's inset from the bounding rectangle.	showCaret 		<Boolean | nil>		Whether the caret should be displayed.	wrapContents 	<Boolean>			Whether to wrap the text or not.	emphasis 		<Number>			The default emphasis.	font			<Font>				The default font for the text. 	paragraph 		<CTextParagraph>	The paragraph representation of text.	editor 			<CTextParagraphEditor>	The editor for the text	displaying 		<Boolean>			Whether the text is in a display operation.!CCostumeHighlight subclass: #CCursorHighlight	instanceVariableNames: '<?xml  version="1.0"?><fields><field instanceVariable="true" toSet="cursor:">cursor</field><field instanceVariable="true">priorCursor</field></fields>'	classVariableNames: ''	poolDictionaries: ''	category: 'Tweak-Costumes-Highlights'!!CCursorHighlight commentStamp: 'ar 3/27/2004 17:46' prior: 0!CCursorHighlight temporarily replaces a Costume's mouse cursor with another one.Instance variables:	cursor 		<Cursor>		The new mouse cursor	priorCursor	<Cursor>		The previous mouse cursor.!CObject subclass: #CDialog	instanceVariableNames: '<?xml  version="1.0"?><fields></fields>'	classVariableNames: ''	poolDictionaries: ''	category: 'Tweak-Widgets-Basic'!!CDialog commentStamp: 'ar 3/27/2004 17:55' prior: 0!CDialog is a facade to allow redirection of certain UI requests to specific clients. It is never instantiated nor subclassed.!CObject subclass: #CDirectoryEntry	instanceVariableNames: '<?xml  version="1.0"?><fields><field toGet="directory" toSet="directory:" changeEvent="directoryChanged">directory</field><field toGet="entry" toSet="entry:" changeEvent="entryChanged">entry</field><field toGet="icon" toSet="icon:" changeEvent="iconChanged">icon</field></fields>'	classVariableNames: 'DefaultIcon IconCache '	poolDictionaries: ''	category: 'Tweak-Widgets-FileDialog'!!CDirectoryEntry commentStamp: 'ar 3/14/2004 02:28' prior: 0!This ridiculous class exists for the mere purpose of the unavailability of the directory from a directory entry. This is so stupid I don't even know where to start...!CCostumeHighlight subclass: #CDropShadowHighlight	instanceVariableNames: '<?xml  version="1.0"?><fields><field instanceVariable="true" toSet="color:">color</field><field instanceVariable="true" toSet="offset:">offset</field><field instanceVariable="true">shadowForm</field><field instanceVariable="true">dirty</field></fields>'	classVariableNames: ''	poolDictionaries: ''	category: 'Tweak-Costumes-Highlights'!!CDropShadowHighlight commentStamp: 'ar 3/27/2004 17:48' prior: 0!CDropShadowHighlight adds a drop shadow to some costume.Instance variables:	color	<Color>	The color of the drop shadow.	offset 	<Point>	The offset for the drop shadow.	shadowForm <Form> The (internal) form used to display the shadow.	dirty 	<Boolean> Whether the shadowForm needs to be recreated.!CObject subclass: #CEventBehavior	instanceVariableNames: '<?xml  version="1.0"?><fields><field toGet="target" toSet="target:" changeEvent="targetChanged">target</field></fields>'	classVariableNames: ''	poolDictionaries: ''	category: 'Tweak-User-Kernel'!!CEventBehavior commentStamp: 'ar 5/3/2004 22:44' prior: 0!An event behavior describes a set of "standalone scripts" which are triggered by events. Event behaviors can be attached to arbitrary players and are an easy way to generalize (event-triggered) behaviors to generic players.See CExampleBehavior for a simple example of how to use a behavior.Instance variables:	target	<CObject>		The event source of the object.!CEventBehavior subclass: #CExampleBehavior	instanceVariableNames: '<?xml  version="1.0"?><fields></fields>'	classVariableNames: ''	poolDictionaries: ''	category: 'Tweak-Behaviors'!!CExampleBehavior commentStamp: 'ar 5/3/2004 22:44' prior: 0!CExampleBehavior is an example for what an event behavior can do. It will change the alpha value of its target to be translucent when the mouse cursor enters or leaves the target.To run evaluate the following:	CExampleBehavior attachTo: CWorkspace open.!CCostumeHighlight subclass: #CFillingHighlight	instanceVariableNames: '<?xml  version="1.0"?><fields><field instanceVariable="true" toSet="fill:">fill</field></fields>'	classVariableNames: ''	poolDictionaries: ''	category: 'Tweak-Costumes-Highlights'!!CFillingHighlight commentStamp: 'ar 3/27/2004 17:49' prior: 0!CFillingHighlight fills the costume's bounding box with the specified color.Instance variables:	fill	<CCostumeFill>	The fill to use.!CCostumeHighlight subclass: #CFramingHighlight	instanceVariableNames: '<?xml  version="1.0"?><fields><field instanceVariable="true" toSet="border:">border</field><field instanceVariable="true" toSet="inset:">inset</field></fields>'	classVariableNames: ''	poolDictionaries: ''	category: 'Tweak-Costumes-Highlights'!!CFramingHighlight commentStamp: 'ar 3/27/2004 17:50' prior: 0!CFramingHighlight draws a border around the costume's bounding rectangle.Instance variables:	border 	<CBorder>	The border to use.	inset	<Point>		Inset to apply before drawing the border.!CCostumeAspect subclass: #CLayoutPolicy	instanceVariableNames: '<?xml  version="1.0"?><fields></fields>'	classVariableNames: ''	poolDictionaries: ''	category: 'Tweak-Costumes-Layouts'!!CLayoutPolicy commentStamp: 'ar 3/27/2004 18:02' prior: 0!A LayoutPolicy defines how submorphs of some morph should be arranged. Subclasses of the receiver define concrete layout policies.!CObject subclass: #CLibraryEntry	instanceVariableNames: '<?xml  version="1.0"?><fields><field toGet="image" toSet="image:" changeEvent="imageChanged">image</field><field toGet="label" toSet="label:" changeEvent="labelChanged">label</field><field toGet="library" toSet="library:" changeEvent="libraryChanged">library</field></fields>'	classVariableNames: ''	poolDictionaries: ''	category: 'Tweak-ProjectBuilder'!CLayoutPolicy subclass: #CListLayout	instanceVariableNames: '<?xml  version="1.0"?><fields><field instanceVariable="true">minExtentCache</field><field instanceVariable="true">fillers</field></fields>'	classVariableNames: ''	poolDictionaries: ''	category: 'Tweak-Costumes-Layouts'!CObject subclass: #CMenuItem	instanceVariableNames: '<?xml  version="1.0"?><fields><field toGet="action" toSet="action:" changeEvent="actionChanged">action</field><field toGet="checked" toSet="checked:" changeEvent="checkedChanged">checked</field><field toGet="enabled" toSet="enabled:" changeEvent="enabledChanged">enabled</field><field toGet="label" toSet="label:" changeEvent="labelChanged">label</field><field toGet="separator" toSet="separator:" changeEvent="separatorChanged">separator</field><field toGet="subMenu" toSet="subMenu:" changeEvent="subMenuChanged">subMenu</field></fields>'	classVariableNames: ''	poolDictionaries: ''	category: 'Tweak-Widgets-Menus'!CObject subclass: #CMultiColumnListSpec	instanceVariableNames: '<?xml  version="1.0"?><fields><field toGet="action" toSet="action:" changeEvent="actionChanged">action</field><field toGet="color" toSet="color:" changeEvent="colorChanged">color</field><field toGet="drawSelector" toSet="drawSelector:" changeEvent="drawSelectorChanged">drawSelector</field><field toGet="drawer" toSet="drawer:" changeEvent="drawerChanged">drawer</field><field toGet="label" toSet="label:" changeEvent="labelChanged">label</field><field toGet="width" toSet="width:" changeEvent="widthChanged">width</field></fields>'	classVariableNames: ''	poolDictionaries: ''	category: 'Tweak-Widgets-Lists'!CCostumeAspect subclass: #CNoBorder	instanceVariableNames: '<?xml  version="1.0"?><fields></fields>'	classVariableNames: ''	poolDictionaries: ''	category: 'Tweak-Costumes-Aspects'!!CNoBorder commentStamp: 'ar 3/27/2004 17:32' prior: 0!CNoBorder is a highly specialized border aspect for being able to represent "unbordered" objects more efficiently.!CCostumeAspect subclass: #CNoFill	instanceVariableNames: '<?xml  version="1.0"?><fields></fields>'	classVariableNames: ''	poolDictionaries: ''	category: 'Tweak-Costumes-Aspects'!!CNoFill commentStamp: 'ar 3/27/2004 17:32' prior: 0!CNoFill is a highly specialized fill aspect for being able to represent "unfilled" objects more efficiently.!CDeserializer subclass: #CObjectMakerDeserializer	instanceVariableNames: 'objectMaker makerPart contents '	classVariableNames: ''	poolDictionaries: ''	category: 'Tweak-Maker'!Object subclass: #CObjectMakerImporter	instanceVariableNames: 'imports parts partMap swapEnds loader '	classVariableNames: ''	poolDictionaries: ''	category: 'Tweak-Maker'!CDisplayTransform subclass: #COffsetTransform	instanceVariableNames: 'offset '	classVariableNames: ''	poolDictionaries: ''	category: 'Tweak-Costumes-Transforms'!!COffsetTransform commentStamp: 'ar 3/27/2004 18:00' prior: 0!COffsetTransform is a very specialized kind of transformation which optimizes for the specific case of only having to deal with translation (which is very common).!CGraphicsFill subclass: #COrientedFill	instanceVariableNames: 'origin direction normal frame '	classVariableNames: ''	poolDictionaries: ''	category: 'Tweak-Costumes-Fills'!COrientedFill subclass: #CBitmapFill	instanceVariableNames: 'form tileFlag '	classVariableNames: ''	poolDictionaries: ''	category: 'Tweak-Costumes-Fills'!COrientedFill subclass: #CGradientFill	instanceVariableNames: 'colorRamp pixelRamp radial isTranslucent '	classVariableNames: ''	poolDictionaries: ''	category: 'Tweak-Costumes-Fills'!Association subclass: #CPartBinding	instanceVariableNames: 'home '	classVariableNames: ''	poolDictionaries: ''	category: 'Tweak-Tweaks'!CObject subclass: #CPlayer	instanceVariableNames: '<?xml  version="1.0"?><fields><field instanceVariable="true">myCostume</field><field instanceVariable="true">myPlayer</field><field virtual="true" toGet="player" toSet="player:" changeEvent="playerChanged" color="FF00FF">player</field><field virtual="true" toGet="costume" toSet="costume:" changeEvent="costumeChanged" color="FF00FF">costume</field><field virtual="true" toGet="container" toSet="container:" changeEvent="containerChanged" color="FF00FF">container</field><field virtual="true" toGet="elements" toSet="elements:" changeEvent="elementsChanged" color="FF00FF">elements</field><field virtual="true" toGet="hand" color="FF00FF">hand</field><field virtual="true" toGet="world" color="FF00FF">world</field><field virtual="true" toGet="balloonHelp" toSet="balloonHelp:" changeEvent="balloonHelpChanged" color="FF00FF">balloonHelp</field><field virtual="true" toGet="mouseCursor" toSet="mouseCursor:" changeEvent="mouseCursorChanged" color="FF00FF">mouseCursor</field><field virtual="true" toGet="border" toSet="border:" changeEvent="borderChanged" color="00FF00">border</field><field virtual="true" toGet="borderColor" toSet="borderColor:" changeEvent="borderChanged" color="00FF00">borderColor</field><field virtual="true" toGet="borderStyle" toSet="borderStyle:" changeEvent="borderChanged" color="00FF00">borderStyle</field><field virtual="true" toGet="borderWidth" toSet="borderWidth:" changeEvent="borderChanged" color="00FF00">borderWidth</field><field virtual="true" serializable="false" toGet="geometry" toSet="geometry:" changeEvent="geometryChanged" color="00FFFF">geometry</field><field virtual="true" serializable="false" toGet="x" toSet="x:" changeEvent="geometryChanged" color="00FFFF">x</field><field virtual="true" toGet="y" toSet="y:" changeEvent="geometryChanged" color="00FFFF">y</field><field virtual="true" toGet="position" toSet="position:" changeEvent="geometryChanged" color="00FFFF">position</field><field virtual="true" toGet="width" toSet="width:" changeEvent="geometryChanged" color="00FFFF">width</field><field virtual="true" toGet="height" toSet="height:" changeEvent="geometryChanged" color="00FFFF">height</field><field virtual="true" toGet="extent" toSet="extent:" changeEvent="geometryChanged" color="00FFFF">extent</field><field virtual="true" toGet="angle" toSet="angle:" changeEvent="geometryChanged" color="00FFFF">angle</field><field virtual="true" toGet="scale" toSet="scale:" changeEvent="geometryChanged" color="00FFFF">scale</field><field virtual="true" toGet="heading" toSet="heading:" changeEvent="geometryChanged" color="00FFFF">heading</field><field virtual="true" toGet="left" toSet="left:" changeEvent="geometryChanged" color="00FFFF">left</field><field virtual="true" toGet="right" toSet="right:" changeEvent="geometryChanged" color="00FFFF">right</field><field virtual="true" toGet="top" toSet="top:" changeEvent="geometryChanged" color="00FFFF">top</field><field virtual="true" toGet="bottom" toSet="bottom:" changeEvent="geometryChanged" color="00FFFF">bottom</field><field virtual="true" toGet="origin" toSet="origin:" changeEvent="geometryChanged" color="00FFFF">origin</field><field virtual="true" toGet="corner" toSet="corner:" changeEvent="geometryChanged" color="00FFFF">corner</field><field virtual="true" toGet="center" toSet="center:" changeEvent="geometryChanged" color="00FFFF">center</field><field virtual="true" toGet="topLeft" toSet="topLeft:" changeEvent="geometryChanged" color="00FFFF">topLeft</field><field virtual="true" toGet="topRight" toSet="topRight:" changeEvent="geometryChanged" color="00FFFF">topRight</field><field virtual="true" toGet="bottomLeft" toSet="bottomLeft:" changeEvent="geometryChanged" color="00FFFF">bottomLeft</field><field virtual="true" toGet="bottomRight" toSet="bottomRight:" changeEvent="geometryChanged" color="00FFFF">bottomRight</field><field virtual="true" toGet="bounds" toSet="bounds:" changeEvent="geometryChanged" color="00FFFF">bounds</field><field virtual="true" toGet="transform" toSet="transform:" changeEvent="geometryChanged" color="00FFFF">transform</field><field virtual="true" toGet="color" toSet="color:" changeEvent="fillChanged" color="FFFF00">color</field><field virtual="true" toGet="fill" toSet="fill:" changeEvent="fillChanged" color="FFFF00">fill</field><field virtual="true" toGet="fillAlpha" toSet="fillAlpha:" changeEvent="fillChanged" color="FFFF00">fillAlpha</field><field virtual="true" toGet="fillAngle" toSet="fillAngle:" changeEvent="fillChanged" color="FFFF00">fillAngle</field><field virtual="true" toGet="fillColor" toSet="fillColor:" changeEvent="fillChanged" color="FFFF00">fillColor</field><field virtual="true" toGet="fillColors" toSet="fillColors:" changeEvent="fillChanged" color="FFFF00">fillColors</field><field virtual="true" toGet="fillOffset" toSet="fillOffset:" changeEvent="fillChanged" color="FFFF00">fillOffset</field><field virtual="true" toGet="fillStyle" toSet="fillStyle:" changeEvent="fillChanged" color="FFFF00">fillStyle</field><field virtual="true" toGet="aspectRatio" toSet="aspectRatio:" changeEvent="geometryChanged" color="FF0000">aspectRatio</field><field virtual="true" toGet="graphic" toSet="graphic:" changeEvent="graphicChanged" color="FF0000">graphic</field><field virtual="true" toGet="graphicAnchorPoint" toSet="graphicAnchorPoint:" changeEvent="graphicChanged" color="FF0000">graphicAnchorPoint</field><field virtual="true" toGet="graphicFit" toSet="graphicFit:" changeEvent="graphicChanged" color="FF0000">graphicFit</field><field virtual="true" toGet="graphicForm" toSet="graphicForm:" changeEvent="graphicChanged" color="FF0000">graphicForm</field><field virtual="true" toGet="graphicOffset" toSet="graphicOffset:" changeEvent="graphicChanged" color="FF0000">graphicOffset</field><field virtual="true" toGet="hResizing" toSet="hResizing:" color="00FF00">hResizing</field><field virtual="true" toGet="vResizing" toSet="vResizing:" color="00FF00">vResizing</field><field virtual="true" toGet="layout" toSet="layout:" color="00FF00">layout</field><field virtual="true" toGet="clipping" toSet="clipping:" changeEvent="flagsChanged" color="FF00FF">clipping</field><field virtual="true" toGet="floating" toSet="floating:" changeEvent="flagsChanged" color="FF00FF">floating</field><field virtual="true" toGet="infinite" toSet="infinite:" changeEvent="flagsChanged" color="FF00FF">infinite</field><field virtual="true" toGet="locked" toSet="locked:" changeEvent="flagsChanged" color="FF00FF">locked</field><field virtual="true" toGet="sticky" toSet="sticky:" changeEvent="flagsChanged" color="FF00FF">sticky</field><field virtual="true" toGet="visible" toSet="visible:" changeEvent="flagsChanged" color="FF00FF">visible</field><field virtual="true" toGet="collisionsEnabled" toSet="collisionsEnabled:" changeEvent="collisionsEnabledChanged" color="00FF00">collisionsEnabled</field><field virtual="true" toGet="preciseCollisions" toSet="preciseCollisions:" changeEvent="preciseCollisionsChanged" color="00FF00">preciseCollisions</field><field virtual="true" toGet="roundCorners" toSet="roundCorners:" changeEvent="roundCornersChanged" color="0000FF">roundCorners</field><field virtual="true" toGet="roundCornerSpec" toSet="roundCornerSpec:" changeEvent="roundCornersChanged" color="0000FF">roundCornerSpec</field><field toGet="hScrollable" toSet="hScrollable:" changeEvent="hScrollableChanged" color="00FF00">hScrollable</field><field toGet="vScrollable" toSet="vScrollable:" changeEvent="vScrollableChanged" color="00FF00">vScrollable</field><field toGet="scrollDelta" toSet="scrollDelta:" changeEvent="scrollDeltaChanged" color="00FF00">scrollDelta</field><field virtual="true" toGet="scrollingDisabled" toSet="scrollingDisabled:" changeEvent="scrollingDisabledChanged" color="00FF00">scrollingDisabled</field><field virtual="true" toGet="scrollOffset" toSet="scrollOffset:" changeEvent="scrollOffsetChanged" color="00FF00">scrollOffset</field><field virtual="true" toGet="dropShadow" toSet="dropShadow:" changeEvent="dropShadowChanged" color="FF0000">dropShadow</field><field virtual="true" toGet="dropShadowColor" toSet="dropShadowColor:" changeEvent="shadowChanged" color="FF0000">dropShadowColor</field><field virtual="true" toGet="dropShadowOffset" toSet="dropShadowOffset:" changeEvent="shadowChanged" color="FF0000">dropShadowOffset</field><field virtual="true" toGet="dropShadowEnabled" toSet="dropShadowEnabled:" changeEvent="dropShadowChanged" color="FF0000">dropShadowEnabled</field><field virtual="true" toGet="textHolder" toSet="textHolder:" changeEvent="textChanged" color="0000FF">textHolder</field><field virtual="true" toGet="text" toSet="text:" changeEvent="textChanged" color="0000FF">text</field><field virtual="true" toGet="textAnchorPoint" toSet="textAnchorPoint:" changeEvent="textChanged" color="0000FF">textAnchorPoint</field><field virtual="true" toGet="textAttributes" toSet="textAttributes:" changeEvent="textChanged" color="0000FF">textAttributes</field><field virtual="true" toGet="textBorderColor" toSet="textBorderColor:" changeEvent="textChanged" color="0000FF">textBorderColor</field><field virtual="true" toGet="textBorderWidth" toSet="textBorderWidth:" changeEvent="textChanged" color="0000FF">textBorderWidth</field><field virtual="true" toGet="textColor" toSet="textColor:" changeEvent="textChanged" color="0000FF">textColor</field><field virtual="true" toGet="textEmphasis" toSet="textEmphasis:" changeEvent="textChanged" color="0000FF">textEmphasis</field><field virtual="true" toGet="textFont" toSet="textFont:" changeEvent="textChanged" color="0000FF">textFont</field><field virtual="true" toGet="textInset" toSet="textInset:" changeEvent="textChanged" color="0000FF">textInset</field><field virtual="true" toGet="textOffset" toSet="textOffset:" changeEvent="textChanged" color="0000FF">textOffset</field><field virtual="true" toGet="textWrap" toSet="textWrap:" changeEvent="textChanged" color="0000FF">textWrap</field><field toGet="eventBehaviors" toSet="eventBehaviors:" changeEvent="eventBehaviorsChanged" color="FF00FF">eventBehaviors</field></fields>'	classVariableNames: ''	poolDictionaries: ''	category: 'Tweak-User-Kernel'!!CPlayer commentStamp: 'ar 3/25/2004 14:08' prior: 0!Players are the fundamental graphical objects in Tweak. They are an assembly of various "aspects" including:- elements: What's in the player.- geometry: Where is the player?- fill: How is it filled?- border: How is it bordered?- text: Does it carry text?- layout: How does it arrange its children?- grid: Do we want to do gridding?- shadow: Do we have a drop shadow?- highlights: Do we have any extra highlights?...!CPlayer subclass: #CBorderStyleReadout	instanceVariableNames: '<?xml  version="1.0"?><fields></fields>'	classVariableNames: ''	poolDictionaries: ''	category: 'Tweak-ColorTool'!CPlayer subclass: #CCodeHolder	instanceVariableNames: '<?xml  version="1.0"?><fields><field toGet="window" toSet="window:" changeEvent="windowChanged">window</field><field toGet="codePane" toSet="codePane:" changeEvent="codePaneChanged">codePane</field><field toGet="codingKeys" toSet="codingKeys:" changeEvent="codingKeysChanged">codingKeys</field></fields>'	classVariableNames: ''	poolDictionaries: ''	category: 'Tweak-DevTools'!CCodeHolder subclass: #CChangeSorter	instanceVariableNames: '<?xml  version="1.0"?><fields><field toGet="parent" toSet="parent:" changeEvent="parentChanged">parent</field><field toGet="myChangeSet" toSet="myChangeSet:" changeEvent="myChangeSetChanged">myChangeSet</field><field toGet="priorChangeSetList" toSet="priorChangeSetList:" changeEvent="priorChangeSetListChanged">priorChangeSetList</field><field toGet="changeSetCategory" toSet="changeSetCategory:" changeEvent="changeSetCategoryChanged">changeSetCategory</field><field toGet="classListPane" toSet="classListPane:" changeEvent="classListPaneChanged">classListPane</field><field toGet="methodListPane" toSet="methodListPane:" changeEvent="methodListPaneChanged">methodListPane</field><field toGet="changeSetListPane" toSet="changeSetListPane:" changeEvent="changeSetListPaneChanged">changeSetListPane</field><field toGet="selectedMessage" toSet="selectedMessage:" changeEvent="selectedMessageChanged">selectedMessage</field><field toGet="selectedChangeSetName" toSet="selectedChangeSetName:" changeEvent="selectedChangeSetNameChanged">selectedChangeSetName</field><field toGet="selectedClassName" toSet="selectedClassName:" changeEvent="selectedClassNameChanged">selectedClassName</field></fields>'	classVariableNames: 'AllChangeSets ChangeSetCategories ChangeSetNamesInRelease PreviousSet RecentUpdateMarker '	poolDictionaries: ''	category: 'Tweak-DevTools'!CCodeHolder subclass: #CClassBrowser	instanceVariableNames: '<?xml  version="1.0"?><fields><field toGet="selectedClassName" toSet="selectedClassName:" changeEvent="selectedClassNameChanged">selectedClassName</field><field toGet="selectedMessage" toSet="selectedMessage:" changeEvent="selectedMessageChanged">selectedMessage</field><field toGet="selectedMessageCategory" toSet="selectedMessageCategory:" changeEvent="selectedMessageCategoryChanged">selectedMessageCategory</field><field toGet="selectedSystemCategory" toSet="selectedSystemCategory:" changeEvent="selectedSystemCategoryChanged">selectedSystemCategory</field><field toGet="systemCategoryList" toSet="systemCategoryList:" changeEvent="systemCategoryListChanged">systemCategoryList</field><field toGet="classList" toSet="classList:" changeEvent="classListChanged">classList</field><field toGet="messageCategoryList" toSet="messageCategoryList:" changeEvent="messageCategoryListChanged">messageCategoryList</field><field toGet="messageList" toSet="messageList:" changeEvent="messageListChanged">messageList</field><field toGet="classButton" toSet="classButton:" changeEvent="classButtonChanged">classButton</field><field toGet="instanceButton" toSet="instanceButton:" changeEvent="instanceButtonChanged">instanceButton</field><field toGet="commentButton" toSet="commentButton:" changeEvent="commentButtonChanged">commentButton</field></fields>'	classVariableNames: ''	poolDictionaries: ''	category: 'Tweak-DevTools'!CPlayer subclass: #CColorPicker	instanceVariableNames: '<?xml  version="1.0"?><fields><field toGet="colorValues" toSet="colorValues:" changeEvent="colorValuesChanged">colorValues</field><field toGet="primaryPicker" toSet="primaryPicker:" changeEvent="primaryPickerChanged">primaryPicker</field></fields>'	classVariableNames: 'StandardColorPalette '	poolDictionaries: ''	category: 'Tweak-ColorTool'!CPlayer subclass: #CColorTool	instanceVariableNames: '<?xml  version="1.0"?><fields><field toGet="flagsPage" toSet="flagsPage:" changeEvent="flagsPageChanged">flagsPage</field><field toGet="fillPage" toSet="fillPage:" changeEvent="fillPageChanged">fillPage</field><field toGet="borderPage" toSet="borderPage:" changeEvent="borderPageChanged">borderPage</field><field toGet="target" toSet="target:" changeEvent="targetChanged">target</field><field toGet="window" toSet="window:" changeEvent="windowChanged">window</field></fields>'	classVariableNames: ''	poolDictionaries: ''	category: 'Tweak-ColorTool'!CPlayer subclass: #CColorToolBorderPage	instanceVariableNames: '<?xml  version="1.0"?><fields><field toGet="target" toSet="target:" changeEvent="targetChanged">target</field><field toGet="borderStyleList" toSet="borderStyleList:" changeEvent="borderStyleListChanged">borderStyleList</field><field toGet="borderColorChooser" toSet="borderColorChooser:" changeEvent="borderColorChooserChanged">borderColorChooser</field><field toGet="borderWidthField" toSet="borderWidthField:" changeEvent="borderWidthFieldChanged">borderWidthField</field><field toGet="label" toSet="label:" changeEvent="labelChanged">label</field></fields>'	classVariableNames: ''	poolDictionaries: ''	category: 'Tweak-ColorTool'!CPlayer subclass: #CColorToolFillPage	instanceVariableNames: '<?xml  version="1.0"?><fields><field toGet="target" toSet="target:" changeEvent="targetChanged">target</field><field toGet="fillStyleList" toSet="fillStyleList:" changeEvent="fillStyleListChanged">fillStyleList</field><field toGet="fillColorChooser" toSet="fillColorChooser:" changeEvent="fillColorChooserChanged">fillColorChooser</field><field toGet="fillAlphaField" toSet="fillAlphaField:" changeEvent="fillAlphaFieldChanged">fillAlphaField</field><field toGet="fillAngleField" toSet="fillAngleField:" changeEvent="fillAngleFieldChanged">fillAngleField</field><field toGet="label" toSet="label:" changeEvent="labelChanged">label</field></fields>'	classVariableNames: ''	poolDictionaries: ''	category: 'Tweak-ColorTool'!CPlayer subclass: #CColorToolFlagsPage	instanceVariableNames: '<?xml  version="1.0"?><fields><field toGet="target" toSet="target:" changeEvent="targetChanged">target</field><field toGet="roundedFlag" toSet="roundedFlag:" changeEvent="roundedFlagChanged">roundedFlag</field><field toGet="lockedFlag" toSet="lockedFlag:" changeEvent="lockedFlagChanged">lockedFlag</field><field toGet="shadowFlag" toSet="shadowFlag:" changeEvent="shadowFlagChanged">shadowFlag</field><field toGet="floatingFlag" toSet="floatingFlag:" changeEvent="floatingFlagChanged">floatingFlag</field><field toGet="visibleFlag" toSet="visibleFlag:" changeEvent="visibleFlagChanged">visibleFlag</field><field toGet="stickyFlag" toSet="stickyFlag:" changeEvent="stickyFlagChanged">stickyFlag</field><field toGet="clippingFlag" toSet="clippingFlag:" changeEvent="clippingFlagChanged">clippingFlag</field><field toGet="infiniteFlag" toSet="infiniteFlag:" changeEvent="infiniteFlagChanged">infiniteFlag</field></fields>'	classVariableNames: ''	poolDictionaries: ''	category: 'Tweak-ColorTool'!CPlayer subclass: #CCostume	instanceVariableNames: '<?xml  version="1.0"?><fields></fields>'	classVariableNames: ''	poolDictionaries: ''	category: 'Tweak-User-Kernel'!!CCostume commentStamp: 'ar 3/25/2004 01:15' prior: 0!CCostume is a convenience class which can be used as superclass for objects which are intended to be used as costumes for other players. Since "being a costume" is a role rather than a type there is no other significance to CCostume than marking an object so that users know they should think about this object as a costume which has a player. Because of this, CCostume makes #defaultPlayer a responsibility of its subclasses so that these subclasses properly document their requirements.!CPlayer subclass: #CCustomDrawListTarget	instanceVariableNames: '<?xml  version="1.0"?><fields><field toGet="list" toSet="list:" changeEvent="listChanged">list</field></fields>'	classVariableNames: ''	poolDictionaries: ''	category: 'Tweak-Widgets-Lists-Costumes'!CCodeHolder subclass: #CDebugger	instanceVariableNames: '<?xml  version="1.0"?><fields><field instanceVariable="true" toGet="interruptedProcess" toSet="interruptedProcess:">interruptedProcess</field><field instanceVariable="true" toGet="interruptedController" toSet="interruptedController:">interruptedController</field><field instanceVariable="true" toGet="contextStack" toSet="contextStack:">contextStack</field><field instanceVariable="true" toGet="contextStackTop" toSet="contextStackTop:">contextStackTop</field><field instanceVariable="true" toGet="contextStackIndex" toSet="contextStackIndex:">contextStackIndex</field><field instanceVariable="true" toGet="contextStackList" toSet="contextStackList:">contextStackList</field><field instanceVariable="true" toGet="receiverInspector" toSet="receiverInspector:">receiverInspector</field><field instanceVariable="true" toGet="contextVariablesInspector" toSet="contextVariablesInspector:">contextVariablesInspector</field><field instanceVariable="true" toGet="externalInterrupt" toSet="externalInterrupt:">externalInterrupt</field><field instanceVariable="true" toGet="proceedValue" toSet="proceedValue:">proceedValue</field><field instanceVariable="true" toGet="selectingPC" toSet="selectingPC:">selectingPC</field><field instanceVariable="true" toGet="sourceMap" toSet="sourceMap:">sourceMap</field><field instanceVariable="true" toGet="tempNames" toSet="tempNames:">tempNames</field><field instanceVariable="true" toGet="savedCursor" toSet="savedCursor:">savedCursor</field><field instanceVariable="true" toGet="isolationHead" toSet="isolationHead:">isolationHead</field><field instanceVariable="true" toGet="failedProject" toSet="failedProject:">failedProject</field><field instanceVariable="true" toGet="errorWasInUIProcess" toSet="errorWasInUIProcess:">errorWasInUIProcess</field><field instanceVariable="true" toGet="labelString" toSet="labelString:">labelString</field><field instanceVariable="true" toGet="theMethodNode" toSet="theMethodNode:">theMethodNode</field><field toGet="stackListPane" toSet="stackListPane:" changeEvent="stackListPaneChanged">stackListPane</field><field toGet="receiverInspectorList" toSet="receiverInspectorList:" changeEvent="receiverInspectorListChanged">receiverInspectorList</field><field toGet="receiverInspectorContents" toSet="receiverInspectorContents:" changeEvent="receiverInspectorContentsChanged">receiverInspectorContents</field><field toGet="contextVariableInspectorList" toSet="contextVariableInspectorList:" changeEvent="contextVariableInspectorListChanged">contextVariableInspectorList</field><field toGet="contextVariableInspectorContents" toSet="contextVariableInspectorContents:" changeEvent="contextVariableInspectorContentsChanged">contextVariableInspectorContents</field><field toGet="proceedButton" toSet="proceedButton:" changeEvent="proceedButtonChanged">proceedButton</field><field toGet="restartButton" toSet="restartButton:" changeEvent="restartButtonChanged">restartButton</field><field toGet="sendButton" toSet="sendButton:" changeEvent="sendButtonChanged">sendButton</field><field toGet="doStepButton" toSet="doStepButton:" changeEvent="doStepButtonChanged">doStepButton</field><field toGet="stepIntoBlockButton" toSet="stepIntoBlockButton:" changeEvent="stepIntoBlockButtonChanged">stepIntoBlockButton</field><field toGet="fullStackButton" toSet="fullStackButton:" changeEvent="fullStackButtonChanged">fullStackButton</field><field toGet="whereButton" toSet="whereButton:" changeEvent="whereButtonChanged">whereButton</field></fields>'	classVariableNames: 'ContextStackKeystrokes ErrorRecursion '	poolDictionaries: ''	category: 'Tweak-DevTools'!CPlayer subclass: #CFieldReference	instanceVariableNames: '<?xml  version="1.0"?><fields><field instanceVariable="true" toSet="value:">value</field><field instanceVariable="true" toGet="target" toSet="target:">target</field><field instanceVariable="true" toGet="fieldDefinition" toSet="fieldDefinition:" changeEvent="fieldDefinitionChanged">fieldDefinition</field><field virtual="true" toGet="fieldName" toSet="fieldName:">fieldName</field></fields>'	classVariableNames: 'CachedFields FailToken '	poolDictionaries: ''	category: 'Tweak-Support'!!CFieldReference commentStamp: 'ar 3/27/2004 17:25' prior: 0!CFieldReference represents a link to a particular field in some object. Its value is kept in sync with the field it observes via the change event associated with the field. Field references are created using #fieldNamed:, e.g.,	xField := Sketch fieldNamed: #x.	xField value. "will answer the value of Sketch's x"	xField value: 100. "will set Sketch's x field to 100"Field references can be used as players for many of the primitive value containing widgets, for example:	xSpinner := CSpinner new.	xSpinner player: xField.	xSpinner open.!CPlayer subclass: #CFileDialog	instanceVariableNames: '<?xml  version="1.0"?><fields><field toGet="directory" toSet="directory:" changeEvent="directoryChanged">directory</field><field toGet="fileList" toSet="fileList:" changeEvent="fileListChanged">fileList</field><field toGet="fileName" toSet="fileName:" changeEvent="fileNameChanged">fileName</field><field toGet="selectedPattern" toSet="selectedPattern:" changeEvent="selectedPatternChanged">selectedPattern</field><field toGet="filePatternList" toSet="filePatternList:" changeEvent="filePatternListChanged">filePatternList</field><field toGet="showDirectories" toSet="showDirectories:" changeEvent="showDirectoriesChanged">showDirectories</field><field toGet="window" toSet="window:" changeEvent="windowChanged">window</field><field toGet="fullName" toSet="fullName:" changeEvent="fullNameChanged">fullName</field><field toGet="sorter" toSet="sorter:" changeEvent="sorterChanged">sorter</field><field toGet="rootDirectories" toSet="rootDirectories:" changeEvent="rootDirectoriesChanged">rootDirectories</field></fields>'	classVariableNames: ''	poolDictionaries: ''	category: 'Tweak-Widgets-FileDialog'!CCostume subclass: #CFileDialogCostume	instanceVariableNames: '<?xml  version="1.0"?><fields><field toGet="directoryList" toSet="directoryList:" changeEvent="directoryListChanged">directoryList</field><field toGet="fileList" toSet="fileList:" changeEvent="fileListChanged">fileList</field><field toGet="inputField" toSet="inputField:" changeEvent="inputFieldChanged">inputField</field><field toGet="patternList" toSet="patternList:" changeEvent="patternListChanged">patternList</field><field toGet="okButton" toSet="okButton:" changeEvent="okButtonChanged">okButton</field><field toGet="cancelButton" toSet="cancelButton:" changeEvent="cancelButtonChanged">cancelButton</field></fields>'	classVariableNames: ''	poolDictionaries: ''	category: 'Tweak-Widgets-FileDialog-Costumes'!CPlayer subclass: #CFileDialogPattern	instanceVariableNames: '<?xml  version="1.0"?><fields><field toGet="description" toSet="description:" changeEvent="descriptionChanged">description</field><field toGet="patterns" toSet="patterns:" changeEvent="patternsChanged">patterns</field></fields>'	classVariableNames: ''	poolDictionaries: ''	category: 'Tweak-Widgets-FileDialog'!!CFileDialogPattern commentStamp: 'ar 3/27/2004 19:34' prior: 0!CFileDialogPattern describe a particular list of file extension to filter in a file dialog.!CPlayer subclass: #CFileDialogSorter	instanceVariableNames: '<?xml  version="1.0"?><fields><field toGet="primarySort" toSet="primarySort:" changeEvent="primarySortChanged">primarySort</field><field toGet="secondarySort" toSet="secondarySort:" changeEvent="secondarySortChanged">secondarySort</field></fields>'	classVariableNames: ''	poolDictionaries: ''	category: 'Tweak-Widgets-FileDialog'!!CFileDialogSorter commentStamp: 'ar 3/27/2004 19:34' prior: 0!CFileDialogSorter performs a two-order sort of elements.!CFileDialog subclass: #CFileOpenDialog	instanceVariableNames: '<?xml  version="1.0"?><fields></fields>'	classVariableNames: ''	poolDictionaries: ''	category: 'Tweak-Widgets-FileDialog'!CFileDialogCostume subclass: #CFileOpenDialogCostume	instanceVariableNames: '<?xml  version="1.0"?><fields></fields>'	classVariableNames: ''	poolDictionaries: ''	category: 'Tweak-Widgets-FileDialog-Costumes'!CFileDialog subclass: #CFileSaveDialog	instanceVariableNames: '<?xml  version="1.0"?><fields></fields>'	classVariableNames: ''	poolDictionaries: ''	category: 'Tweak-Widgets-FileDialog'!CFileDialogCostume subclass: #CFileSaveDialogCostume	instanceVariableNames: '<?xml  version="1.0"?><fields></fields>'	classVariableNames: ''	poolDictionaries: ''	category: 'Tweak-Widgets-FileDialog-Costumes'!CPlayer subclass: #CFillStyleReadout	instanceVariableNames: '<?xml  version="1.0"?><fields></fields>'	classVariableNames: ''	poolDictionaries: ''	category: 'Tweak-ColorTool'!CPlayer subclass: #CHalo	instanceVariableNames: '<?xml  version="1.0"?><fields><field toGet="label" toSet="label:" changeEvent="labelChanged">label</field><field toGet="multiSelections" toSet="multiSelections:" changeEvent="multiSelectionsChanged">multiSelections</field><field toGet="rootContext" toSet="rootContext:" changeEvent="rootContextChanged">rootContext</field><field toGet="target" toSet="target:" changeEvent="targetChanged">target</field></fields>'	classVariableNames: ''	poolDictionaries: ''	category: 'Tweak-ProjectBuilder'!CPlayer subclass: #CHaloButton	instanceVariableNames: '<?xml  version="1.0"?><fields></fields>'	classVariableNames: ''	poolDictionaries: ''	category: 'Tweak-ProjectBuilder'!CPlayer subclass: #CHaloResizer	instanceVariableNames: '<?xml  version="1.0"?><fields><field toGet="target" toSet="target:" changeEvent="targetChanged">target</field></fields>'	classVariableNames: ''	poolDictionaries: ''	category: 'Tweak-ProjectBuilder'!CPlayer subclass: #CHandPlayer	instanceVariableNames: '<?xml  version="1.0"?><fields><field instanceVariable="true" toSet="mouseFocus:">mouseFocus</field><field instanceVariable="true" toSet="keyboardFocus:">keyboardFocus</field><field instanceVariable="true" toSet="cursorFocus:">cursorFocus</field><field instanceVariable="true">mouseOverHandler</field><field instanceVariable="true">lastEvent</field><field instanceVariable="true">lastEventBuffer</field><field instanceVariable="true" toSet="dragContents:">dragContents</field><field instanceVariable="true">pressedKeys</field><field instanceVariable="true" toSet="balloon:">balloon</field></fields>'	classVariableNames: 'EventStats ShowEvents '	poolDictionaries: 'EventSensorConstants '	category: 'Tweak-Worlds'!CPlayer subclass: #CHolder	instanceVariableNames: '<?xml  version="1.0"?><fields><field virtual="true" toGet="cursor" toSet="cursor:" changeEvent="cursorChanged">cursor</field><field virtual="true" toGet="wrapCursor" toSet="wrapCursor:" changeEvent="wrapCursorChanged">wrapCursor</field></fields>'	classVariableNames: ''	poolDictionaries: ''	category: 'Tweak-User-Kernel'!!CHolder commentStamp: 'ar 3/27/2004 18:05' prior: 0!CHolder provides the full collection interface for use with its elements. Subclasses are typically thought about as being containers of some sort - for any kind of either graphical or non-graphical objects.!CPlayer subclass: #CImagePlayer	instanceVariableNames: '<?xml  version="1.0"?><fields></fields>'	classVariableNames: ''	poolDictionaries: ''	category: 'Tweak-User-Media'!!CImagePlayer commentStamp: 'ar 3/14/2004 16:08' prior: 0!This class is a stand-in for objects representing pictures. It is intended to be used wherever we create or import an image. At some point we WILL want to have different costumes for 'images' and this will be the base type to be used for it.!CCodeHolder subclass: #CInspector	instanceVariableNames: '<?xml  version="1.0"?><fields><field instanceVariable="true" toGet="object" toSet="object:">object</field><field instanceVariable="true" toGet="selectionUpdateTime" toSet="selectionUpdateTime:">selectionUpdateTime</field><field toGet="listPane" toSet="listPane:" changeEvent="listPaneChanged">listPane</field><field toGet="contentsPane" toSet="contentsPane:" changeEvent="contentsPaneChanged">contentsPane</field></fields>'	classVariableNames: ''	poolDictionaries: ''	category: 'Tweak-DevTools'!CInspector subclass: #CContextVariablesInspector	instanceVariableNames: '<?xml  version="1.0"?><fields></fields>'	classVariableNames: ''	poolDictionaries: ''	category: 'Tweak-DevTools'!CPlayer subclass: #CLibraryEntryCostume	instanceVariableNames: '<?xml  version="1.0"?><fields><field toGet="label" toSet="label:" changeEvent="labelChanged">label</field><field toGet="image" toSet="image:" changeEvent="imageChanged">image</field></fields>'	classVariableNames: ''	poolDictionaries: ''	category: 'Tweak-ProjectBuilder-Costumes'!CHolder subclass: #CList	instanceVariableNames: '<?xml  version="1.0"?><fields><field toGet="allowDeselect" toSet="allowDeselect:" changeEvent="allowDeselectChanged">allowDeselect</field><field toGet="itemMaker" toSet="itemMaker:" changeEvent="itemMakerChanged">itemMaker</field><field toGet="items" toSet="items:" changeEvent="itemsChanged">items</field></fields>'	classVariableNames: ''	poolDictionaries: ''	category: 'Tweak-Widgets-Lists'!!CList commentStamp: 'ar 3/25/2004 12:06' prior: 0!CListPlayer represents the basic list widget. It carries its own list of items which (contrary to the elements) can be shared with another object therefore allowing lists to automatically provide a view on an arbitrary collection. Lists can have an itemMaker specifying which user interface element should be used to represent its items. By default a CListItem is used which merely uses the #displayText representation of the object.To implement a new kind of list item all that needs to be provided is a player which can take a value to display (see also CListItem). If more complex behavior is required (for example to treat the list as a set of costumes) the itemMaker can implement #listItemValue: to handle the request for displaying the particular value (see CPlayer>>listItemValue:).!CList subclass: #CDropDownList	instanceVariableNames: '<?xml  version="1.0"?><fields><field toGet="allowEditing" toSet="allowEditing:" changeEvent="allowEditingChanged">allowEditing</field></fields>'	classVariableNames: ''	poolDictionaries: ''	category: 'Tweak-Widgets-Lists'!!CDropDownList commentStamp: 'ar 3/27/2004 19:23' prior: 0!CDropDownList presents the user with (what essentially is) an input field and a drop down list. When the user selects an item the list's selection AND value will change to the selected item. If the list is editable, then the user can type into the input field and upon accepting the input the lists will carry the accepted value.!CPlayer subclass: #CMenuItemSeparator	instanceVariableNames: '<?xml  version="1.0"?><fields></fields>'	classVariableNames: ''	poolDictionaries: ''	category: 'Tweak-Widgets-Menus-Costumes'!CCodeHolder subclass: #CMessageSet	instanceVariableNames: '<?xml  version="1.0"?><fields><field toGet="autoSelectString" toSet="autoSelectString:" changeEvent="autoSelectStringChanged">autoSelectString</field><field toGet="selectedReference" toSet="selectedReference:" changeEvent="selectedReferenceChanged">selectedReference</field><field toGet="messageList" toSet="messageList:" changeEvent="messageListChanged">messageList</field></fields>'	classVariableNames: ''	poolDictionaries: ''	category: 'Tweak-DevTools'!CMessageSet subclass: #CChangedMessageSet	instanceVariableNames: '<?xml  version="1.0"?><fields><field instanceVariable="true" toGet="changeSet" toSet="changeSet:">changeSet</field></fields>'	classVariableNames: ''	poolDictionaries: ''	category: 'Tweak-DevTools'!CPlayer subclass: #CMoviePlayer	instanceVariableNames: '<?xml  version="1.0"?><fields></fields>'	classVariableNames: ''	poolDictionaries: ''	category: 'Tweak-User-Media'!!CMoviePlayer commentStamp: 'ar 3/14/2004 16:10' prior: 0!This class is a stand-in for objects representing movies. It is intended to be used wherever we create or import a movie. At some point we WILL want to have different costumes for 'movies' and this will be the base type to be used for it.!CColorPicker subclass: #CMultiColorPicker	instanceVariableNames: '<?xml  version="1.0"?><fields></fields>'	classVariableNames: ''	poolDictionaries: ''	category: 'Tweak-ColorTool'!CList subclass: #CMultiColumnList	instanceVariableNames: '<?xml  version="1.0"?><fields><field toGet="columns" toSet="columns:" changeEvent="columnsChanged">columns</field></fields>'	classVariableNames: ''	poolDictionaries: ''	category: 'Tweak-Widgets-Lists'!!CMultiColumnList commentStamp: 'ar 3/27/2004 19:24' prior: 0!CMultiColumnList displays a multi-column list of strings. My columns are specified by a CMultiColumnListSpec.!CPlayer subclass: #CMultiSelectionHalo	instanceVariableNames: '<?xml  version="1.0"?><fields></fields>'	classVariableNames: ''	poolDictionaries: ''	category: 'Tweak-ProjectBuilder'!CCollectionBase subclass: #CPlayerCollection	instanceVariableNames: '<?xml  version="1.0"?><fields><field instanceVariable="true" toSet="costume:">costume</field></fields>'	classVariableNames: ''	poolDictionaries: ''	category: 'Tweak-Costumes-Primitive'!CCodeHolder subclass: #CPreDebugger	instanceVariableNames: '<?xml  version="1.0"?><fields><field toGet="notifyPane" toSet="notifyPane:" changeEvent="notifyPaneChanged">notifyPane</field><field toGet="proceedButton" toSet="proceedButton:" changeEvent="proceedButtonChanged">proceedButton</field><field toGet="abortButton" toSet="abortButton:" changeEvent="abortButtonChanged">abortButton</field><field toGet="debugButton" toSet="debugButton:" changeEvent="debugButtonChanged">debugButton</field></fields>'	classVariableNames: ''	poolDictionaries: ''	category: 'Tweak-DevTools'!Object subclass: #CPrimitiveCostume	instanceVariableNames: 'container contents bounds fill border flags properties '	classVariableNames: 'DefaultBorder DefaultFill FlagCached FlagClipEnabled FlagCustomDraw FlagExcessBounds FlagFlagLayoutNeeded FlagHasFullBounds FlagHasGraphic FlagHasGrid FlagHasHighlights FlagHasMatrix FlagHasOverlay FlagHasScroller FlagHasShape FlagHasText FlagHidden FlagIntrinsicFullBounds FlagInvalidated FlagInvalidationSuppressed FlagLayoutNeeded FlagLocked FlagRegistry FlagRoundedCorners '	poolDictionaries: ''	category: 'Tweak-Costumes-Primitive'!!CPrimitiveCostume commentStamp: 'ar 9/21/2003 20:11' prior: 0!TODO:	* add player as inst var	* add text as inst var!CPrimitiveCostume subclass: #CHandCostume	instanceVariableNames: 'mouseCursor '	classVariableNames: ''	poolDictionaries: 'EventSensorConstants '	category: 'Tweak-Worlds'!CPlayer subclass: #CProject	instanceVariableNames: '<?xml  version="1.0"?><fields><field toGet="library" toSet="library:" changeEvent="libraryChanged">library</field><field toGet="thumbnail" toSet="thumbnail:" changeEvent="thumbnailChanged">thumbnail</field></fields>'	classVariableNames: ''	poolDictionaries: ''	category: 'Tweak-ProjectBuilder'!CPlayer subclass: #CProjectBuilder	instanceVariableNames: '<?xml  version="1.0"?><fields><field toGet="allProjects" toSet="allProjects:" changeEvent="allProjectsChanged">allProjects</field><field toGet="project" toSet="project:" changeEvent="projectChanged">project</field><field toGet="window" toSet="window:" changeEvent="windowChanged">window</field><field toGet="worldMenu" toSet="worldMenu:" changeEvent="worldMenuChanged">worldMenu</field><field toGet="projectList" toSet="projectList:" changeEvent="projectListChanged">projectList</field><field toGet="lastImportDirectory" toSet="lastImportDirectory:" changeEvent="lastImportDirectoryChanged">lastImportDirectory</field><field virtual="true" toGet="toolMenuItems">toolMenuItems</field></fields>'	classVariableNames: 'ToolMenuItems '	poolDictionaries: ''	category: 'Tweak-ProjectBuilder'!CPlayer subclass: #CProjectCostume	instanceVariableNames: '<?xml  version="1.0"?><fields><field toGet="label" toSet="label:" changeEvent="labelChanged">label</field><field toGet="image" toSet="image:" changeEvent="imageChanged">image</field></fields>'	classVariableNames: ''	poolDictionaries: ''	category: 'Tweak-ProjectBuilder-Costumes'!CObject subclass: #CProjectLibrary	instanceVariableNames: '<?xml  version="1.0"?><fields><field toGet="contents" toSet="contents:" changeEvent="contentsChanged">contents</field></fields>'	classVariableNames: ''	poolDictionaries: ''	category: 'Tweak-ProjectBuilder'!Object subclass: #CProjectLoader	instanceVariableNames: 'archive resources notifier '	classVariableNames: ''	poolDictionaries: ''	category: 'Tweak-ProjectBuilder'!CChangeRecord subclass: #CPropertyChange	instanceVariableNames: 'value '	classVariableNames: ''	poolDictionaries: ''	category: 'Tweak-Undo'!CLayoutPolicy subclass: #CProportionalLayout	instanceVariableNames: '<?xml  version="1.0"?><fields><field instanceVariable="true">minExtentCache</field></fields>'	classVariableNames: ''	poolDictionaries: ''	category: 'Tweak-Costumes-Layouts'!!CProportionalLayout commentStamp: 'ar 3/27/2004 18:02' prior: 0!I represent a layout that places all children of some morph in their given LayoutFrame.!Object subclass: #CResource	instanceVariableNames: ''	classVariableNames: 'ResourceTypes '	poolDictionaries: ''	category: 'Tweak-Resources'!!CResource commentStamp: 'ar 12/2/2003 14:32' prior: 0!Resources represent 'big objects' which are* shared* immutable* 'externally stored' in a project* identified via unique ID (UUID, possibly md5 hash)* possibly bound to a url for updating!CResource subclass: #CMaker	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'Tweak-Maker'!CResource subclass: #CMediaResource	instanceVariableNames: 'name type url '	classVariableNames: ''	poolDictionaries: ''	category: 'Tweak-Resources'!CMediaResource subclass: #CImageResource	instanceVariableNames: 'form '	classVariableNames: ''	poolDictionaries: ''	category: 'Tweak-Resources'!CMediaResource subclass: #CMovieResource	instanceVariableNames: 'movie '	classVariableNames: ''	poolDictionaries: ''	category: 'Tweak-Resources'!CMaker subclass: #CObjectMaker	instanceVariableNames: 'name image thumbnail uuid parts imports prevVersion nextVersion '	classVariableNames: ''	poolDictionaries: ''	category: 'Tweak-Maker'!Object subclass: #CResourceManager	instanceVariableNames: 'resources '	classVariableNames: 'Default '	poolDictionaries: ''	category: 'Tweak-Resources'!BorderedMorph subclass: #CRootMorph	instanceVariableNames: 'window myWorld '	classVariableNames: ''	poolDictionaries: ''	category: 'Tweak-Worlds'!CChangeRecord subclass: #CScriptChange	instanceVariableNames: 'value '	classVariableNames: ''	poolDictionaries: ''	category: 'Tweak-Undo'!Object subclass: #CScriptForObject	instanceVariableNames: 'sqkCodeStrm objToName suffixCnt '	classVariableNames: ''	poolDictionaries: ''	category: 'Tweak-Misc'!!CScriptForObject commentStamp: 'tk 6/28/2004 14:55' prior: 0!Return Squeak code to construct an identical object to a chosen object.  Use the tweaks.  Also look at the properties that are not objectBindings.	For now write Squeak code.  Later it will be Tweak script.	Must generate temp names for the objects.sqkCodeStrm		WriteStream of Squeak code.objToName		IdentityDictionary (cobject -> temp name string)suffixCnt		last used integer suffix for a temp name (not per class!!)	Subclasses are for generating English or keywords instead of Squeak code.!CScriptForObject subclass: #CEnglishForObject	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'Tweak-Misc'!CScriptForObject subclass: #CEnglishObjOutline	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'Tweak-Misc'!CScriptForObject subclass: #CKeywordsForObject	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'Tweak-Misc'!CPlayer subclass: #CScriptorHeader	instanceVariableNames: '<?xml  version="1.0"?><fields><field toGet="fireButton" toSet="fireButton:" changeEvent="fireButtonChanged">fireButton</field><field toGet="collapseButton" toSet="collapseButton:" changeEvent="collapseButtonChanged">collapseButton</field><field toGet="rcvrLabel" toSet="rcvrLabel:" changeEvent="rcvrLabelChanged">rcvrLabel</field><field toGet="scriptName" toSet="scriptName:" changeEvent="scriptNameChanged">scriptName</field><field toGet="ticker" toSet="ticker:" changeEvent="tickerChanged">ticker</field><field toGet="trigger" toSet="trigger:" changeEvent="triggerChanged">trigger</field><field toGet="closeButton" toSet="closeButton:" changeEvent="closeButtonChanged">closeButton</field></fields>'	classVariableNames: ''	poolDictionaries: ''	category: 'Tweak-Tiles-Costumes'!Object subclass: #CSerializer	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'Tweak-Serializer'!CSerializer subclass: #CObjectMakerSerializer	instanceVariableNames: 'root objMap partList data contents imports parentField currentValue parentValue '	classVariableNames: ''	poolDictionaries: ''	category: 'Tweak-Maker'!CMakerPart subclass: #CSharedPart	instanceVariableNames: 'partID '	classVariableNames: ''	poolDictionaries: ''	category: 'Tweak-Maker-Parts'!CSharedPart subclass: #CObjectPart	instanceVariableNames: 'partMaker contents '	classVariableNames: ''	poolDictionaries: ''	category: 'Tweak-Maker-Parts'!CObjectPart subclass: #CBitsArrayPart	instanceVariableNames: 'partBits '	classVariableNames: ''	poolDictionaries: ''	category: 'Tweak-Maker-Parts'!CSharedPart subclass: #CReferencePart	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'Tweak-Maker-Parts'!CSharedPart subclass: #CResourcePart	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'Tweak-Maker-Parts'!CObjectPart subclass: #CSequencePart	instanceVariableNames: 'partSize '	classVariableNames: ''	poolDictionaries: ''	category: 'Tweak-Maker-Parts'!CBorder subclass: #CSimpleBorder	instanceVariableNames: 'owner baseColor color width '	classVariableNames: ''	poolDictionaries: ''	category: 'Tweak-Costumes-Borders'!CSimpleBorder subclass: #CComplexBorder	instanceVariableNames: 'style colors lineStyles borderForm '	classVariableNames: ''	poolDictionaries: ''	category: 'Tweak-Costumes-Borders'!CSimpleBorder subclass: #CInsetBorder	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'Tweak-Costumes-Borders'!CSimpleBorder subclass: #CRaisedBorder	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'Tweak-Costumes-Borders'!CLayoutPolicy subclass: #CSimpleLayout	instanceVariableNames: '<?xml  version="1.0"?><fields><field instanceVariable="true">minExtentCache</field></fields>'	classVariableNames: ''	poolDictionaries: ''	category: 'Tweak-Costumes-Layouts'!CPlayer subclass: #CSimpleTextEditor	instanceVariableNames: '<?xml  version="1.0"?><fields><field toGet="window" toSet="window:" changeEvent="windowChanged">window</field><field toGet="editor" toSet="editor:" changeEvent="editorChanged">editor</field></fields>'	classVariableNames: ''	poolDictionaries: ''	category: 'Tweak-DocEditor'!CGraphicsFill subclass: #CSolidFill	instanceVariableNames: 'color pixelValue32 '	classVariableNames: ''	poolDictionaries: ''	category: 'Tweak-Costumes-Fills'!CPlayer subclass: #CSoundPlayer	instanceVariableNames: '<?xml  version="1.0"?><fields></fields>'	classVariableNames: ''	poolDictionaries: ''	category: 'Tweak-User-Media'!!CSoundPlayer commentStamp: 'ar 3/14/2004 16:08' prior: 0!This class is a stand-in for objects representing sounds. It is intended to be used wherever we create or import a sound. At some point we WILL want to have different costumes for 'sounds' and this will be the base type to be used for it.!CMediaResource subclass: #CSoundResource	instanceVariableNames: 'sound '	classVariableNames: ''	poolDictionaries: ''	category: 'Tweak-Resources'!CList subclass: #CSpinnerList	instanceVariableNames: '<?xml  version="1.0"?><fields></fields>'	classVariableNames: ''	poolDictionaries: ''	category: 'Tweak-Widgets-Lists'!!CSpinnerList commentStamp: 'ar 3/27/2004 19:24' prior: 0!I show a list with spinner buttons. When the user clicks on the spin buttons my cursor advances accordingly.!CList subclass: #CStringList	instanceVariableNames: '<?xml  version="1.0"?><fields></fields>'	classVariableNames: ''	poolDictionaries: ''	category: 'Tweak-Widgets-Lists'!!CStringList commentStamp: 'ar 3/27/2004 19:25' prior: 0!CStringList shows a #displayText representation of its elements.!CPlayer subclass: #CStyleReadoutList	instanceVariableNames: '<?xml  version="1.0"?><fields><field toGet="selection" toSet="selection:" changeEvent="selectionChanged">selection</field></fields>'	classVariableNames: ''	poolDictionaries: ''	category: 'Tweak-ColorTool'!!CStyleReadoutList commentStamp: 'ar 3/16/2004 16:35' prior: 0!I couldn't think of a good name for the class but what it's doing is really to define the most stupid list type possible - all it does is taking its value as the selection in its elements.!CList subclass: #CTabButtonList	instanceVariableNames: '<?xml  version="1.0"?><fields></fields>'	classVariableNames: ''	poolDictionaries: ''	category: 'Tweak-Widgets-Lists'!!CTabButtonList commentStamp: 'ar 3/24/2004 23:30' prior: 0!I represent a list of tabs which can be selected. My selection is represented as my value so clients can just stuff some objects responding to #displayText into me and get the currently selected tab value back by asking for my selection.!CLayoutPolicy subclass: #CTableLayout	instanceVariableNames: '<?xml  version="1.0"?><fields><field instanceVariable="true">properties</field><field instanceVariable="true">minExtentCache</field></fields>'	classVariableNames: ''	poolDictionaries: ''	category: 'Tweak-Costumes-Layouts'!!CTableLayout commentStamp: 'ar 3/27/2004 18:02' prior: 0!The layout process:For computing the new layout for the children of any morph, we start with an initial rectangle which is provided as a reference.Step 1: The first step of layout computation is to compute the minimum extent each of our children can have. The minimum extent is mapped through both the local layout frame of the morph (for relative positioning) and the global layout frame (for insets, such as cursor indication) to obtain the minimal size required for each cell.Step 2: Based on the cell sizes, the number of cells we can put into each row and column is computed. For equal spacing, the maximum size of the cells is taken into account here.Step 3: Based on the row/column sizes, we compute the extra space which should be added to each row/column. For 	#leftFlush/#topFlush - we add all extra space add the end	#rightFlush/#bottomFlush - we add all extra space at the start	#centering - we add 1/2 of the extra space at start and end	#justified - we distribute the space evenly between the morphs[NOTE: If any #spaceFill morphs are encountered during this step, #justified is implied and the space is exclusively and equally distributed between those #spaceFill morphs. This is for backward compatibility and should *never* be necessary in the new regime].Step 4: The morphs are placed in the computed cells and the extra space is distributed as necessary. Placing the submorphs is done by mapping through the global and the local layout frame as requested.Start point:=> bounds: new rectangle for the morph.Compute basic arrangement of morphs:=> For each submorph compute minExtent	- if global layout frame inset in global layout frame	- if local layout frame inset in local layout frame=> Compute number of morphs per, width and height of row/column	- if equal spacing based on max size=> Compute extra space per row/column	- if centering = #justified; distribute space equally	- if centering #leftFlush/#topFlush (-1) add start extra	- if centering #rightFlush/#bottomFlush (1) add end extra	- if centering #centered add 1/2 extra to start/end	<extra space must be float and rounded accordingly!!>=> Place morphs in appropriate cells	- if global layout frame inset in global layout frame	- if local layout frame inset in local layout frame	<will likely cause #layoutChanged by submorphs>Distribute morphs in row/column:=> Compute the max length of each row/column!Object subclass: #CTableLayoutProperties	instanceVariableNames: 'cellInset cellPositioning cellSpacing layoutInset listCentering listDirection listSpacing reverseTableCells rubberBandCells wrapCentering wrapDirection minCellSize maxCellSize '	classVariableNames: ''	poolDictionaries: ''	category: 'Tweak-Costumes-Layouts'!Object subclass: #CTextComposer	instanceVariableNames: 'lines maxRightX currentY scanner possibleSlide nowSliding prevIndex prevLines currCharIndex startCharIndex stopCharIndex deltaCharIndex theText theContainer isFirstLine theTextStyle defaultLineHeight actualHeight wantsColumnBreaks '	classVariableNames: ''	poolDictionaries: ''	category: 'Tweak-Costumes-Text'!CPlayer subclass: #CTextConverter	instanceVariableNames: '<?xml  version="1.0"?><fields></fields>'	classVariableNames: ''	poolDictionaries: ''	category: 'Tweak-Widgets-Text-Converters'!!CTextConverter commentStamp: 'ar 3/27/2004 19:14' prior: 0!I convert between objects and text representations. My subclasses must implement two methods - the method #printValue: which takes an object as argument and answers an appropriate text representation as well as #readValue: which takes a text as an argument and answers an appropriate object. If the input can not be converted into an appropriate object (say, when trying to read a number from something like 'foo') I am expected to raise an Error. My users will handle such error conditions. Also note that I am a role rather than a type - any object can act in my role if it implements the messages which can be found in my protocol.!CTextConverter subclass: #CDateConverter	instanceVariableNames: '<?xml  version="1.0"?><fields><field toGet="format" toSet="format:" changeEvent="formatChanged">format</field></fields>'	classVariableNames: ''	poolDictionaries: ''	category: 'Tweak-Widgets-Text-Converters'!!CDateConverter commentStamp: 'ar 3/27/2004 19:13' prior: 0!I convert between text and dates.!CTextConverter subclass: #CNumberConverter	instanceVariableNames: '<?xml  version="1.0"?><fields></fields>'	classVariableNames: ''	poolDictionaries: ''	category: 'Tweak-Widgets-Text-Converters'!!CNumberConverter commentStamp: 'ar 3/27/2004 19:13' prior: 0!I convert between text and numbers.!CTextConverter subclass: #CStringConverter	instanceVariableNames: '<?xml  version="1.0"?><fields></fields>'	classVariableNames: ''	poolDictionaries: ''	category: 'Tweak-Widgets-Text-Converters'!!CStringConverter commentStamp: 'ar 3/27/2004 19:13' prior: 0!I convert between text and strings. Really. For example, I strip out text formatting.!CPlayer subclass: #CTextEditorPane	instanceVariableNames: '<?xml  version="1.0"?><fields><field toGet="oldBorder" toSet="oldBorder:" changeEvent="oldBorderChanged">oldBorder</field><field toGet="editor" toSet="editor:" changeEvent="editorChanged">editor</field></fields>'	classVariableNames: ''	poolDictionaries: ''	category: 'Tweak-Widgets-Text'!Object subclass: #CTextParagraph	instanceVariableNames: 'text textStyle container lines maxRightX editor '	classVariableNames: ''	poolDictionaries: ''	category: 'Tweak-Costumes-Text'!CObject subclass: #CTextParagraphEditor	instanceVariableNames: '<?xml  version="1.0"?><fields><field instanceVariable="true" toSet="costume:">costume</field><field instanceVariable="true" toSet="paragraph:">paragraph</field><field instanceVariable="true">markBlock</field><field instanceVariable="true">pointBlock</field><field instanceVariable="true">undoStack</field><field instanceVariable="true">redoStack</field><field instanceVariable="true">lastUndoType</field><field instanceVariable="true">findText</field><field instanceVariable="true" toSet="modified:">modified</field><field instanceVariable="true">emphasisHere</field></fields>'	classVariableNames: ''	poolDictionaries: ''	category: 'Tweak-Costumes-Text'!!CTextParagraphEditor commentStamp: 'ar 3/26/2004 01:18' prior: 0!Okay, this is completely ridiculous here but I wanted to get rid of all of the messy editors in MVC and Morphic so here it is. It works, but it ain't nice, oh no. Please go ahead and rewrite it!!Notes: The "costume" here really *ought* to be the costume not the text holder but right now that's screwed up. Most likely we really want this guy be associated with the costume so that a costume is "editable" if it has a text editor (which implies carrying a text but the text could be there anyway).!CPlayer subclass: #CTextTool	instanceVariableNames: '<?xml  version="1.0"?><fields><field toGet="fontNames" toSet="fontNames:" changeEvent="fontNamesChanged">fontNames</field><field toGet="fontSizes" toSet="fontSizes:" changeEvent="fontSizesChanged">fontSizes</field><field toGet="boldButton" toSet="boldButton:" changeEvent="boldButtonChanged">boldButton</field><field toGet="italicButton" toSet="italicButton:" changeEvent="italicButtonChanged">italicButton</field><field toGet="underlineButton" toSet="underlineButton:" changeEvent="underlineButtonChanged">underlineButton</field><field toGet="struckoutButton" toSet="struckoutButton:" changeEvent="struckoutButtonChanged">struckoutButton</field><field toGet="leftAlign" toSet="leftAlign:" changeEvent="leftAlignChanged">leftAlign</field><field toGet="centerAlign" toSet="centerAlign:" changeEvent="centerAlignChanged">centerAlign</field><field toGet="rightAlign" toSet="rightAlign:" changeEvent="rightAlignChanged">rightAlign</field><field toGet="blockAlign" toSet="blockAlign:" changeEvent="blockAlignChanged">blockAlign</field><field toGet="editor" toSet="editor:" changeEvent="editorChanged">editor</field><field toGet="window" toSet="window:" changeEvent="windowChanged">window</field></fields>'	classVariableNames: ''	poolDictionaries: ''	category: 'Tweak-TextTool'!CCostume subclass: #CTileCostume	instanceVariableNames: '<?xml  version="1.0"?><fields></fields>'	classVariableNames: ''	poolDictionaries: ''	category: 'Tweak-Tiles-Costumes'!!CTileCostume commentStamp: 'ar 3/30/2004 16:59' prior: 0!CTileCostume is the basis for most of the costumes in Tweak's tile system. It provides the basics for the notification mechanism which is used for tiles in DnD interactions. ALL of the events involved are signaled in the players and not in the costumes in order to allow costumes to be completely exchangeable. In other words, a properly implemented tile costume has absolutely no need to know anything about other tile costumes except the event protocol involved. The events used are:#tilePadDragged - This event notifies a tile that it was just dragged out of its (tile) container. For example, in an expression like [[Foo's x] + [Foo's y]] grabbing [Foo's x] would signal #tilePadDrag in [Foo's x]. The event should be handled by tiles which have a different representation depending on whether they are inside another tile or not.#tilePadDropped - This event notifies a tile that it was just dropped into a (tile) container, For example, dropping [Foo's x] into an expression like [[ X ] + [Foo's y]] would signal #tilePadDrop in [Foo's x]. The event should be handled by tiles which have a different representation depending on whether they are inside another tile or not.#tilePadHighlight - This event notifies a tile that its container (probably a variable) would allow dropping a tile in the place it currently is. For example, dragging [Foo's x] over the [ X ] tile in an expression like [ [ X ] + [Foo's y] ] would signal #tilePadHighlight in the [ X ] tile when the user drags [Foo's x] over it. This event should be handled by costumes which have a non-transparent representation to either become transparent (let the parent's highlight show through) or provide their own highlighting for giving user-feedback about the possibility of the drop operation.#tilePadUnhighlight - This event notifies a tile to reverse the effect of a #tilePadHighlight.#tilePadEnter - This event notifies a tile that it entered a 'hot area', e.g., another tile which would accept it if the user dropped it there.#tilePadLeave - This event notifies a tile that it left a 'hot area'.!CTileCostume subclass: #CColorTileCostume	instanceVariableNames: '<?xml  version="1.0"?><fields><field toGet="swatch" toSet="swatch:" changeEvent="swatchChanged">swatch</field></fields>'	classVariableNames: ''	poolDictionaries: ''	category: 'Tweak-Tiles-ValueCostumes'!CTileCostume subclass: #CEnumListCostume	instanceVariableNames: '<?xml  version="1.0"?><fields><field toGet="list" toSet="list:" changeEvent="listChanged">list</field></fields>'	classVariableNames: ''	poolDictionaries: ''	category: 'Tweak-Tiles-ValueCostumes'!CTileCostume subclass: #CEnumTileCostume	instanceVariableNames: '<?xml  version="1.0"?><fields><field toGet="label" toSet="label:" changeEvent="labelChanged">label</field><field toGet="spinner" toSet="spinner:" changeEvent="spinnerChanged">spinner</field><field toGet="valueList" toSet="valueList:" changeEvent="valueListChanged">valueList</field></fields>'	classVariableNames: ''	poolDictionaries: ''	category: 'Tweak-Tiles-ValueCostumes'!CTileCostume subclass: #CImageResourceTileCostume	instanceVariableNames: '<?xml  version="1.0"?><fields><field toGet="editor" toSet="editor:" changeEvent="editorChanged">editor</field><field toGet="button" toSet="button:" changeEvent="buttonChanged">button</field></fields>'	classVariableNames: ''	poolDictionaries: ''	category: 'Tweak-Tiles-ValueCostumes'!CTileCostume subclass: #CMessageAndArgsCostume	instanceVariableNames: '<?xml  version="1.0"?><fields></fields>'	classVariableNames: ''	poolDictionaries: ''	category: 'Tweak-Tiles-Costumes'!CTileCostume subclass: #CMessagePartCostume	instanceVariableNames: '<?xml  version="1.0"?><fields></fields>'	classVariableNames: ''	poolDictionaries: ''	category: 'Tweak-Tiles-Costumes'!CTileCostume subclass: #CMessageTileCostume	instanceVariableNames: '<?xml  version="1.0"?><fields><field toGet="fireButton" toSet="fireButton:" changeEvent="fireButtonChanged">fireButton</field><field toGet="receiverTile" toSet="receiverTile:" changeEvent="receiverTileChanged">receiverTile</field><field toGet="argumentsTile" toSet="argumentsTile:" changeEvent="argumentsTileChanged">argumentsTile</field><field toGet="expandArrow" toSet="expandArrow:" changeEvent="expandArrowChanged">expandArrow</field></fields>'	classVariableNames: ''	poolDictionaries: ''	category: 'Tweak-Tiles-Costumes'!CTileCostume subclass: #CNumberTileCostume	instanceVariableNames: '<?xml  version="1.0"?><fields><field toGet="editor" toSet="editor:" changeEvent="editorChanged">editor</field><field toGet="spinner" toSet="spinner:" changeEvent="spinnerChanged">spinner</field></fields>'	classVariableNames: ''	poolDictionaries: ''	category: 'Tweak-Tiles-ValueCostumes'!CTileCostume subclass: #COperatorTileCostume	instanceVariableNames: '<?xml  version="1.0"?><fields><field toGet="leftHandTile" toSet="leftHandTile:" changeEvent="leftHandTileChanged">leftHandTile</field><field toGet="operatorTile" toSet="operatorTile:" changeEvent="operatorTileChanged">operatorTile</field><field toGet="rightHandTile" toSet="rightHandTile:" changeEvent="rightHandTileChanged">rightHandTile</field></fields>'	classVariableNames: ''	poolDictionaries: ''	category: 'Tweak-Tiles-Costumes'!CTileCostume subclass: #CPropertyTileCostume	instanceVariableNames: '<?xml  version="1.0"?><fields><field toGet="receiverTile" toSet="receiverTile:" changeEvent="receiverTileChanged">receiverTile</field><field toGet="propertyName" toSet="propertyName:" changeEvent="propertyNameChanged">propertyName</field></fields>'	classVariableNames: ''	poolDictionaries: ''	category: 'Tweak-Tiles-Costumes'!CTileCostume subclass: #CReceiverTileCostume	instanceVariableNames: '<?xml  version="1.0"?><fields><field toGet="reflexive" toSet="reflexive:" changeEvent="reflexiveChanged">reflexive</field></fields>'	classVariableNames: ''	poolDictionaries: ''	category: 'Tweak-Tiles-Costumes'!CTileCostume subclass: #CSequenceTileCostume	instanceVariableNames: '<?xml  version="1.0"?><fields><field toGet="target" toSet="target:" changeEvent="targetChanged">target</field><field toGet="spacer" toSet="spacer:" changeEvent="spacerChanged">spacer</field></fields>'	classVariableNames: ''	poolDictionaries: ''	category: 'Tweak-Tiles-Costumes'!CSequenceTileCostume subclass: #CScriptorTileCostume	instanceVariableNames: '<?xml  version="1.0"?><fields><field toGet="header" toSet="header:" changeEvent="headerChanged">header</field></fields>'	classVariableNames: ''	poolDictionaries: ''	category: 'Tweak-Tiles-Costumes'!CTileCostume subclass: #CSoundTileCostume	instanceVariableNames: '<?xml  version="1.0"?><fields><field toGet="label" toSet="label:" changeEvent="labelChanged">label</field><field toGet="spinner" toSet="spinner:" changeEvent="spinnerChanged">spinner</field></fields>'	classVariableNames: ''	poolDictionaries: ''	category: 'Tweak-Tiles-ValueCostumes'!CTileCostume subclass: #CStringTileCostume	instanceVariableNames: '<?xml  version="1.0"?><fields><field toGet="editor" toSet="editor:" changeEvent="editorChanged">editor</field></fields>'	classVariableNames: ''	poolDictionaries: ''	category: 'Tweak-Tiles-ValueCostumes'!CPlayer subclass: #CTileDefinition	instanceVariableNames: '<?xml  version="1.0"?><fields><field toGet="externalName" toSet="externalName:" changeEvent="externalNameChanged">externalName</field><field toGet="type" toSet="type:" changeEvent="typeChanged">type</field><field toGet="helpText" toSet="helpText:" changeEvent="helpTextChanged">helpText</field><field toGet="selector" toSet="selector:" changeEvent="selectorChanged">selector</field></fields>'	classVariableNames: ''	poolDictionaries: ''	category: 'Tweak-Tiles-Definition'!CTileDefinition subclass: #CArgumentDefinition	instanceVariableNames: '<?xml  version="1.0"?><fields><field toGet="defaultValue" toSet="defaultValue:" changeEvent="defaultValueChanged">defaultValue</field></fields>'	classVariableNames: ''	poolDictionaries: ''	category: 'Tweak-Tiles-Definition'!CTileDefinition subclass: #CCategoryDefinition	instanceVariableNames: '<?xml  version="1.0"?><fields><field toGet="items" toSet="items:" changeEvent="itemsChanged">items</field></fields>'	classVariableNames: ''	poolDictionaries: ''	category: 'Tweak-Tiles-Definition'!CTileDefinition subclass: #CMessageDefinition	instanceVariableNames: '<?xml  version="1.0"?><fields><field toGet="arguments" toSet="arguments:" changeEvent="argumentsChanged">arguments</field></fields>'	classVariableNames: ''	poolDictionaries: ''	category: 'Tweak-Tiles-Definition'!CTileDefinition subclass: #COperatorDefinition	instanceVariableNames: '<?xml  version="1.0"?><fields><field toGet="arguments" toSet="arguments:" changeEvent="argumentsChanged">arguments</field></fields>'	classVariableNames: ''	poolDictionaries: ''	category: 'Tweak-Tiles-Definition'!CTileDefinition subclass: #CSlotDefinition	instanceVariableNames: '<?xml  version="1.0"?><fields></fields>'	classVariableNames: ''	poolDictionaries: ''	category: 'Tweak-Tiles-Definition'!CPlayer subclass: #CTileInspector	instanceVariableNames: '<?xml  version="1.0"?><fields><field toGet="target" toSet="target:" changeEvent="targetChanged">target</field><field toGet="fieldList" toSet="fieldList:" changeEvent="fieldListChanged">fieldList</field><field toGet="category" toSet="category:" changeEvent="categoryChanged">category</field></fields>'	classVariableNames: ''	poolDictionaries: ''	category: 'Tweak-Tiles-Inspector'!CPlayer subclass: #CTileLibrary	instanceVariableNames: '<?xml  version="1.0"?><fields></fields>'	classVariableNames: 'Default '	poolDictionaries: ''	category: 'Tweak-Tiles-Definition'!CPlayer subclass: #CTilePlayer	instanceVariableNames: '<?xml  version="1.0"?><fields><field toGet="valueType" toSet="valueType:" changeEvent="valueTypeChanged">valueType</field><field toGet="definition" toSet="definition:" changeEvent="definitionChanged">definition</field></fields>'	classVariableNames: ''	poolDictionaries: ''	category: 'Tweak-Tiles-Players'!!CTilePlayer commentStamp: 'ar 3/7/2004 21:29' prior: 0!CTilePlayer is the abstract superclass for all elements in the tile scripting world. It is essentially a parse node representation just that it knows how to represent itself graphically via the appropriate costumes.Each tile element has a "valueType" which represents the type associated with it. Note that the meaning of "valueType" is polymorphic, meaning that depending on the concrete element its interpretation differs. For example:* CMessageTile: "valueType" describes the return type of the message (if any). Messages without a return type are assumed to be "commands" not returning any useful value.* CValueTile: "valueType" describes the type of the value represented by the tile. If the type has not been set explicitly it will be derived from the concrete object (in which case it may too specific).* CArgumentTile: "valueType" describes the *expected* type of the argument.* CPropertyTile: "valueType" describes the type of the (virtual or real) property.!CTilePlayer subclass: #CMessageTile	instanceVariableNames: '<?xml  version="1.0"?><fields><field toGet="arguments" toSet="arguments:" changeEvent="argumentsChanged">arguments</field><field toGet="receiver" toSet="receiver:" changeEvent="receiverChanged">receiver</field><field toGet="selector" toSet="selector:" changeEvent="selectorChanged">selector</field></fields>'	classVariableNames: ''	poolDictionaries: ''	category: 'Tweak-Tiles-Players'!!CMessageTile commentStamp: 'ar 3/7/2004 21:33' prior: 0!A tile representing a fully-formed message send.!CMessageTile subclass: #COperatorTile	instanceVariableNames: '<?xml  version="1.0"?><fields></fields>'	classVariableNames: ''	poolDictionaries: ''	category: 'Tweak-Tiles-Players'!CTilePlayer subclass: #CPropertyTile	instanceVariableNames: '<?xml  version="1.0"?><fields><field toGet="property" toSet="property:" changeEvent="propertyChanged">property</field><field toGet="receiver" toSet="receiver:" changeEvent="receiverChanged">receiver</field></fields>'	classVariableNames: ''	poolDictionaries: ''	category: 'Tweak-Tiles-Players'!!CPropertyTile commentStamp: 'ar 3/7/2004 21:32' prior: 0!A tile representing a (virtual or real) property of some object.!CTilePlayer subclass: #CSequenceTile	instanceVariableNames: '<?xml  version="1.0"?><fields><field toGet="statements" toSet="statements:" changeEvent="statementsChanged">statements</field></fields>'	classVariableNames: ''	poolDictionaries: ''	category: 'Tweak-Tiles-Players'!CSequenceTile subclass: #CScriptorTile	instanceVariableNames: '<?xml  version="1.0"?><fields><field toGet="receiver" toSet="receiver:" changeEvent="receiverChanged">receiver</field><field toGet="selector" toSet="selector:" changeEvent="selectorChanged">selector</field><field toGet="trigger" toSet="trigger:" changeEvent="triggerChanged">trigger</field></fields>'	classVariableNames: ''	poolDictionaries: ''	category: 'Tweak-Tiles-Players'!CPlayer subclass: #CTileReadout	instanceVariableNames: '<?xml  version="1.0"?><fields><field toGet="label" toSet="label:" changeEvent="labelChanged">label</field><field toGet="editor" toSet="editor:" changeEvent="editorChanged">editor</field><field toGet="field" toSet="field:" changeEvent="fieldChanged">field</field><field toGet="fieldType" toSet="fieldType:" changeEvent="fieldTypeChanged">fieldType</field></fields>'	classVariableNames: ''	poolDictionaries: ''	category: 'Tweak-Tiles-Inspector'!CPlayer subclass: #CTileType	instanceVariableNames: '<?xml  version="1.0"?><fields></fields>'	classVariableNames: ''	poolDictionaries: ''	category: 'Tweak-Tiles-Types'!CTileType subclass: #CColorType	instanceVariableNames: '<?xml  version="1.0"?><fields></fields>'	classVariableNames: ''	poolDictionaries: ''	category: 'Tweak-Tiles-Types'!CTileType subclass: #CEnumType	instanceVariableNames: '<?xml  version="1.0"?><fields></fields>'	classVariableNames: ''	poolDictionaries: ''	category: 'Tweak-Tiles-Types'!CEnumType subclass: #CBooleanType	instanceVariableNames: '<?xml  version="1.0"?><fields></fields>'	classVariableNames: ''	poolDictionaries: ''	category: 'Tweak-Tiles-Types'!CTileType subclass: #CNumberType	instanceVariableNames: '<?xml  version="1.0"?><fields></fields>'	classVariableNames: ''	poolDictionaries: ''	category: 'Tweak-Tiles-Types'!CNumberType subclass: #CIntegerType	instanceVariableNames: '<?xml  version="1.0"?><fields></fields>'	classVariableNames: ''	poolDictionaries: ''	category: 'Tweak-Tiles-Types'!CTileType subclass: #CPlayerType	instanceVariableNames: '<?xml  version="1.0"?><fields></fields>'	classVariableNames: ''	poolDictionaries: ''	category: 'Tweak-Tiles-Types'!CTileType subclass: #CResourceType	instanceVariableNames: '<?xml  version="1.0"?><fields></fields>'	classVariableNames: ''	poolDictionaries: ''	category: 'Tweak-Tiles-Types'!CResourceType subclass: #CImageResourceType	instanceVariableNames: '<?xml  version="1.0"?><fields></fields>'	classVariableNames: ''	poolDictionaries: ''	category: 'Tweak-Tiles-Types'!CEnumType subclass: #CSoundNameType	instanceVariableNames: '<?xml  version="1.0"?><fields></fields>'	classVariableNames: ''	poolDictionaries: ''	category: 'Tweak-Tiles-Types'!CTileType subclass: #CStringType	instanceVariableNames: '<?xml  version="1.0"?><fields></fields>'	classVariableNames: ''	poolDictionaries: ''	category: 'Tweak-Tiles-Types'!CEnumType subclass: #CSymbolType	instanceVariableNames: '<?xml  version="1.0"?><fields></fields>'	classVariableNames: ''	poolDictionaries: ''	category: 'Tweak-Tiles-Types'!CSymbolType subclass: #CBorderStyleType	instanceVariableNames: '<?xml  version="1.0"?><fields></fields>'	classVariableNames: ''	poolDictionaries: ''	category: 'Tweak-Tiles-Types'!CSymbolType subclass: #CButtonStateType	instanceVariableNames: '<?xml  version="1.0"?><fields></fields>'	classVariableNames: ''	poolDictionaries: ''	category: 'Tweak-Tiles-Types'!CSymbolType subclass: #CFillStyleType	instanceVariableNames: '<?xml  version="1.0"?><fields></fields>'	classVariableNames: ''	poolDictionaries: ''	category: 'Tweak-Tiles-Types'!CPlayer subclass: #CTileViewer	instanceVariableNames: '<?xml  version="1.0"?><fields><field toGet="categoryList" toSet="categoryList:" changeEvent="categoryListChanged">categoryList</field><field toGet="pages" toSet="pages:" changeEvent="pagesChanged">pages</field><field toGet="header" toSet="header:" changeEvent="headerChanged">header</field><field toGet="holder" toSet="holder:" changeEvent="holderChanged">holder</field></fields>'	classVariableNames: ''	poolDictionaries: ''	category: 'Tweak-Tiles-Viewer'!CHolder subclass: #CTileViewerPage	instanceVariableNames: '<?xml  version="1.0"?><fields></fields>'	classVariableNames: ''	poolDictionaries: ''	category: 'Tweak-Tiles-Viewer'!CPlayer subclass: #CTreeItem	instanceVariableNames: '<?xml  version="1.0"?><fields><field toGet="parent" toSet="parent:" changeEvent="parentChanged">parent</field><field toGet="children" toSet="children:" changeEvent="childrenChanged">children</field><field toGet="tree" toSet="tree:" changeEvent="treeChanged">tree</field><field toGet="indentation" toSet="indentation:" changeEvent="indentationChanged">indentation</field><field toGet="expanded" toSet="expanded:" changeEvent="expandedChanged">expanded</field><field toGet="label" toSet="label:" changeEvent="labelChanged">label</field><field toGet="icon" toSet="icon:" changeEvent="iconChanged">icon</field></fields>'	classVariableNames: ''	poolDictionaries: ''	category: 'Tweak-Widgets-Trees'!!CTreeItem commentStamp: 'ar 3/27/2004 19:30' prior: 0!CTreeItem is the abstract base class for items in a tree. Subclasses need to provide some services in order to make it work appropriately, namely:	getChildren - needs to compute the children of the tree node.	getLabel - needs to answer the label to use for the tree node.	getIcon - needs to answer the icon (Form) to be displayed for the tree node.In addition, tree items can implement the following message	hasChildren - needs to respond true if this item has children or not.This message is optional but unless the children can be really easily computed it is useful to implement this message for improved efficency.!CTreeItem subclass: #CFileDirectoryTreeItem	instanceVariableNames: '<?xml  version="1.0"?><fields></fields>'	classVariableNames: ''	poolDictionaries: ''	category: 'Tweak-Widgets-Trees'!!CFileDirectoryTreeItem commentStamp: 'ar 3/27/2004 19:27' prior: 0!CFileDirectoryTreeItem is a tree item for file directories.!CTreeItem subclass: #CServerDirectoryTreeItem	instanceVariableNames: '<?xml  version="1.0"?><fields></fields>'	classVariableNames: ''	poolDictionaries: ''	category: 'Tweak-Widgets-Trees'!!CServerDirectoryTreeItem commentStamp: 'ar 3/27/2004 19:27' prior: 0!CServerDirectoryTreeItem is a tree item for server directories.!CCostume subclass: #CTreeItemCostume	instanceVariableNames: '<?xml  version="1.0"?><fields><field toGet="marker" toSet="marker:" changeEvent="markerChanged">marker</field><field toGet="label" toSet="label:" changeEvent="labelChanged">label</field></fields>'	classVariableNames: ''	poolDictionaries: ''	category: 'Tweak-Widgets-Trees-Costumes'!CList subclass: #CTreeWidget	instanceVariableNames: '<?xml  version="1.0"?><fields><field toGet="treeNodes" toSet="treeNodes:" changeEvent="treeNodesChanged">treeNodes</field><field toGet="rootNodes" toSet="rootNodes:" changeEvent="rootNodesChanged">rootNodes</field></fields>'	classVariableNames: ''	poolDictionaries: ''	category: 'Tweak-Widgets-Trees'!!CTreeWidget commentStamp: 'ar 3/27/2004 19:33' prior: 0!A tree widget displays a set of tree items. See the class side for some examples.!CObjectMakerDeserializer subclass: #CTweakDeserializer	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'Tweak-Tweaks'!CObjectMaker subclass: #CTweakMaker	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'Tweak-Tweaks'!CObjectMakerSerializer subclass: #CTweakSerializer	instanceVariableNames: 'extraPartNames '	classVariableNames: ''	poolDictionaries: ''	category: 'Tweak-Tweaks'!CObjectPart subclass: #CTweakedPart	instanceVariableNames: 'partBinding '	classVariableNames: ''	poolDictionaries: ''	category: 'Tweak-Tweaks'!CPlayer subclass: #CUserDialog	instanceVariableNames: '<?xml  version="1.0"?><fields><field toGet="dialogLabel" toSet="dialogLabel:" changeEvent="dialogLabelChanged">dialogLabel</field><field toGet="buttonRow" toSet="buttonRow:" changeEvent="buttonRowChanged">buttonRow</field><field toGet="messageText" toSet="messageText:" changeEvent="messageTextChanged">messageText</field></fields>'	classVariableNames: ''	poolDictionaries: ''	category: 'Tweak-Widgets-Basic'!!CUserDialog commentStamp: 'ar 3/27/2004 17:58' prior: 0!CUserDialog handles various common user requests, such as asking the user for some input, informing the user about various events etc.!CPlayer subclass: #CValuePlayer	instanceVariableNames: '<?xml  version="1.0"?><fields></fields>'	classVariableNames: ''	poolDictionaries: ''	category: 'Tweak-User-Kernel'!!CValuePlayer commentStamp: 'ar 3/25/2004 12:09' prior: 0!CValuePlayer is provided as a convenient superclass for documenting that some player is intended to represent a particular value and now more. There is no other significance to it - all players represent a value and therefore many players all over the places will commonly refer to their values.!CValuePlayer subclass: #CListItem	instanceVariableNames: '<?xml  version="1.0"?><fields></fields>'	classVariableNames: ''	poolDictionaries: ''	category: 'Tweak-Widgets-Lists'!!CListItem commentStamp: 'ar 3/25/2004 12:08' prior: 0!CListItem represents a simple list item which does nothing but displaying the #displayText of its value. It knows how to select and how to deselect itself and that's it.!CValuePlayer subclass: #CMenuItemCostume	instanceVariableNames: '<?xml  version="1.0"?><fields><field toGet="checkMarker" toSet="checkMarker:" changeEvent="checkMarkerChanged">checkMarker</field><field toGet="subMenuMarker" toSet="subMenuMarker:" changeEvent="subMenuMarkerChanged">subMenuMarker</field><field toGet="itemLabel" toSet="itemLabel:" changeEvent="itemLabelChanged">itemLabel</field></fields>'	classVariableNames: ''	poolDictionaries: ''	category: 'Tweak-Widgets-Menus-Costumes'!CTilePlayer subclass: #CValueTile	instanceVariableNames: '<?xml  version="1.0"?><fields></fields>'	classVariableNames: ''	poolDictionaries: ''	category: 'Tweak-Tiles-Players'!!CValueTile commentStamp: 'ar 3/7/2004 21:31' prior: 0!A tile representing a literal value.!CTileCostume subclass: #CValueTileCostume	instanceVariableNames: '<?xml  version="1.0"?><fields></fields>'	classVariableNames: ''	poolDictionaries: ''	category: 'Tweak-Tiles-ValueCostumes'!CTilePlayer subclass: #CVariableTile	instanceVariableNames: '<?xml  version="1.0"?><fields><field toGet="expression" toSet="expression:" changeEvent="expressionChanged">expression</field></fields>'	classVariableNames: ''	poolDictionaries: ''	category: 'Tweak-Tiles-Players'!!CVariableTile commentStamp: 'ar 3/7/2004 21:32' prior: 0!A tile representing an "argument slot" in some message. It can contain an arbitrary expression which is evaluated in order to retrieve the actual argument value.!CTileCostume subclass: #CVariableTileCostume	instanceVariableNames: '<?xml  version="1.0"?><fields><field toGet="dropEnabled" toSet="dropEnabled:" changeEvent="dropEnabledChanged">dropEnabled</field></fields>'	classVariableNames: ''	poolDictionaries: ''	category: 'Tweak-Tiles-Costumes'!!CVariableTileCostume commentStamp: 'ar 3/30/2004 17:17' prior: 0!CVariableTileCostume is the basis for all 'variable-like' tiles, e.g., tiles which allow drag and drop operations. It uses some events to coordinate the DnD activity internally, including:#tilePadChildEnter - a tile entered a tile pad embedded in the receiver.#tilePadChildLeave - a tile left a tile pad embedded in the receiver.#tilePadChildDrop - a tile was dropped on a tile pad embedded in the receiver.!CGraphicsShape subclass: #CVectorShape	instanceVariableNames: 'bounds compressedShape '	classVariableNames: ''	poolDictionaries: ''	category: 'Tweak-Costumes-TODO'!!CVectorShape commentStamp: 'ar 3/27/2004 17:54' prior: 0!CVectorShape represents a vector graphics shape.!CPlayer subclass: #CViewerCategoryHeader	instanceVariableNames: '<?xml  version="1.0"?><fields><field toGet="prevArrow" toSet="prevArrow:" changeEvent="prevArrowChanged">prevArrow</field><field toGet="nextArrow" toSet="nextArrow:" changeEvent="nextArrowChanged">nextArrow</field><field toGet="categoryLabel" toSet="categoryLabel:" changeEvent="categoryLabelChanged">categoryLabel</field></fields>'	classVariableNames: ''	poolDictionaries: ''	category: 'Tweak-Tiles-Viewer'!CTileDefinition subclass: #CViewerDefinition	instanceVariableNames: '<?xml  version="1.0"?><fields><field toGet="categories" toSet="categories:" changeEvent="categoriesChanged">categories</field></fields>'	classVariableNames: ''	poolDictionaries: ''	category: 'Tweak-Tiles-Definition'!CPlayer subclass: #CViewerRow	instanceVariableNames: '<?xml  version="1.0"?><fields><field toGet="fireButton" toSet="fireButton:" changeEvent="fireButtonChanged">fireButton</field><field toGet="messageTile" toSet="messageTile:" changeEvent="messageTileChanged">messageTile</field><field toGet="spacer" toSet="spacer:" changeEvent="spacerChanged">spacer</field><field toGet="readout" toSet="readout:" changeEvent="readoutChanged">readout</field></fields>'	classVariableNames: ''	poolDictionaries: ''	category: 'Tweak-Tiles-Viewer'!CPlayer subclass: #CWidget	instanceVariableNames: '<?xml  version="1.0"?><fields><field toGet="font" toSet="font:" changeEvent="fontChanged">font</field></fields>'	classVariableNames: ''	poolDictionaries: ''	category: 'Tweak-Widgets-Basic'!!CWidget commentStamp: 'ar 3/27/2004 18:55' prior: 0!CWidget is the abstract superclass for all 'widget-like' elements. It isn't fully formed out yet.!CWidget subclass: #CButton	instanceVariableNames: '<?xml  version="1.0"?><fields><field toGet="state" toSet="state:" changeEvent="stateChanged">state</field><field toGet="label" toSet="label:" changeEvent="labelChanged">label</field><field toGet="image" toSet="image:" changeEvent="imageChanged">image</field><field toGet="group" toSet="group:" changeEvent="groupChanged">group</field><field toGet="selected" toSet="selected:" changeEvent="selectedChanged">selected</field></fields>'	classVariableNames: ''	poolDictionaries: ''	category: 'Tweak-Widgets-Buttons'!!CButton commentStamp: 'ar 3/29/2004 21:59' prior: 0!Buttons are little state machines where the state of a button is managed by user interactions with their costume. Many costumes also control the visual appearance when the button is in any particular state, but the basic button costume simply controls the state based on user interaction.Instance variables:	state	<Symbol> 	The button state, one of: #normal, #over, #pressed, or #disabled.	label	<String>		The label to be displayed for this button.	image 	<Form>		The image to be displayed for this button.	group	<Collection>	The group to which the button belongs.	selected	<Boolean>	The selection state of this button.If a button is in a group, then it will be the only selected item in this group. Some buttons (such as radio) will be implicitly part of the group formed by their container unless given an explicit group, others (such as check boxes) require the group to be set explicitly.!CButton subclass: #CCheckBox	instanceVariableNames: '<?xml  version="1.0"?><fields></fields>'	classVariableNames: ''	poolDictionaries: ''	category: 'Tweak-Widgets-Buttons'!!CCheckBox commentStamp: 'ar 3/27/2004 19:07' prior: 0!CCheckBox is a simple button toggling its value between true and false. Note that check boxes can have ANY value they want (so they can be used as a three-state display) but the default fire response will simply switch from true to false and back. You can easily implement your own CheckBox behavior by using a check box costume with a regular button and handle the fire event to cycle between whatever values you'd like.!CWidget subclass: #CConstraintValueWidget	instanceVariableNames: '<?xml  version="1.0"?><fields></fields>'	classVariableNames: ''	poolDictionaries: ''	category: 'Tweak-Widgets-Scrolling'!!CConstraintValueWidget commentStamp: 'ar 3/28/2004 19:59' prior: 0!CConstraintValueWidget is an example of how to synchronously constrain #value: messages. Since this isn't always trivial in the Tweak architecture, it acts as an example as well as documentation for "how to do it right".!CButton subclass: #CImageButton	instanceVariableNames: '<?xml  version="1.0"?><fields><field toGet="disabledImage" toSet="disabledImage:" changeEvent="disabledImageChanged">disabledImage</field><field toGet="normalImage" toSet="normalImage:" changeEvent="normalImageChanged">normalImage</field><field toGet="overImage" toSet="overImage:" changeEvent="overImageChanged">overImage</field><field toGet="pressedImage" toSet="pressedImage:" changeEvent="pressedImageChanged">pressedImage</field><field toGet="selectedImage" toSet="selectedImage:" changeEvent="selectedImageChanged">selectedImage</field></fields>'	classVariableNames: ''	poolDictionaries: ''	category: 'Tweak-Widgets-Buttons'!!CImageButton commentStamp: 'ar 4/4/2004 16:18' prior: 0!CImageButton is a simple button which takes two to four images to display depending on its state.	normalImage: The image to display for the #normal state.	overImage: If present, the image to display for the #over state.	pressedImage: If present, the image to display for the #pressed state.	disabledImage: If present, the image to display for the #disabled state.	selectedImage: If present, the image to display if the button is selected.!CWidget subclass: #CLabel	instanceVariableNames: '<?xml  version="1.0"?><fields></fields>'	classVariableNames: ''	poolDictionaries: ''	category: 'Tweak-Widgets-Text'!!CLabel commentStamp: 'ar 3/27/2004 19:10' prior: 0!CLabel is a simple label, showing some value.!CWidget subclass: #CMenu	instanceVariableNames: '<?xml  version="1.0"?><fields><field toGet="menuItems" toSet="menuItems:" changeEvent="menuItemsChanged">menuItems</field><field toGet="label" toSet="label:" changeEvent="labelChanged">label</field></fields>'	classVariableNames: ''	poolDictionaries: ''	category: 'Tweak-Widgets-Menus'!CMenu subclass: #CMenuBar	instanceVariableNames: '<?xml  version="1.0"?><fields></fields>'	classVariableNames: ''	poolDictionaries: ''	category: 'Tweak-Widgets-Menus'!CButton subclass: #CPushButton	instanceVariableNames: '<?xml  version="1.0"?><fields></fields>'	classVariableNames: ''	poolDictionaries: ''	category: 'Tweak-Widgets-Buttons'!!CPushButton commentStamp: 'ar 3/27/2004 19:03' prior: 0!CPushButton is just like any other button, except that it uses a system-default costume.!CButton subclass: #CRadioButton	instanceVariableNames: '<?xml  version="1.0"?><fields></fields>'	classVariableNames: ''	poolDictionaries: ''	category: 'Tweak-Widgets-Buttons'!!CRadioButton commentStamp: 'ar 3/27/2004 19:03' prior: 0!CRadioButton is UNFINISHED!!!CWidget subclass: #CScrollPane	instanceVariableNames: '<?xml  version="1.0"?><fields><field toGet="holder" toSet="holder:" changeEvent="holderChanged">holder</field></fields>'	classVariableNames: ''	poolDictionaries: ''	category: 'Tweak-Widgets-Scrolling'!CConstraintValueWidget subclass: #CSlider	instanceVariableNames: '<?xml  version="1.0"?><fields><field toGet="max" toSet="max:" changeEvent="maxChanged">max</field><field toGet="min" toSet="min:" changeEvent="minChanged">min</field><field toGet="orientation" toSet="orientation:" changeEvent="orientationChanged">orientation</field><field toGet="pageStep" toSet="pageStep:" changeEvent="pageStepChanged">pageStep</field><field toGet="step" toSet="step:" changeEvent="stepChanged">step</field><field toGet="visibleFraction" toSet="visibleFraction:" changeEvent="visibleFractionChanged">visibleFraction</field></fields>'	classVariableNames: ''	poolDictionaries: ''	category: 'Tweak-Widgets-Scrolling'!CSlider subclass: #CScrollBar	instanceVariableNames: '<?xml  version="1.0"?><fields><field toGet="buttonHeight" toSet="buttonHeight:" changeEvent="buttonHeightChanged">buttonHeight</field></fields>'	classVariableNames: ''	poolDictionaries: ''	category: 'Tweak-Widgets-Scrolling'!CConstraintValueWidget subclass: #CSpinner	instanceVariableNames: '<?xml  version="1.0"?><fields><field toGet="max" toSet="max:" changeEvent="maxChanged">max</field><field toGet="min" toSet="min:" changeEvent="minChanged">min</field><field toGet="step" toSet="step:" changeEvent="stepChanged">step</field><field toGet="label" toSet="label:" changeEvent="labelChanged">label</field></fields>'	classVariableNames: ''	poolDictionaries: ''	category: 'Tweak-Widgets-Scrolling'!CWidget subclass: #CSpinnerButtons	instanceVariableNames: '<?xml  version="1.0"?><fields></fields>'	classVariableNames: ''	poolDictionaries: ''	category: 'Tweak-Widgets-Scrolling'!CButton subclass: #CTabButton	instanceVariableNames: '<?xml  version="1.0"?><fields></fields>'	classVariableNames: ''	poolDictionaries: ''	category: 'Tweak-Widgets-Buttons'!!CTabButton commentStamp: 'ar 3/27/2004 19:05' prior: 0!CTabButton is a button used specifically for tabbed palettes (e.g., CTabButtonList).Example:	tabs := CTabButtonList new.	tabs addAll: #('Tab 1' 'Tab 2' 'Tab 3').	tabs open.!CWidget subclass: #CTextEditor	instanceVariableNames: '<?xml  version="1.0"?><fields><field toGet="target" toSet="target:" changeEvent="targetChanged">target</field><field toGet="allowEditing" toSet="allowEditing:" changeEvent="allowEditingChanged">allowEditing</field><field toGet="searchText" toSet="searchText:" changeEvent="searchTextChanged">searchText</field><field toGet="caseSensitiveSearch" toSet="caseSensitiveSearch:" changeEvent="caseSensitiveSearchChanged">caseSensitiveSearch</field><field virtual="true" toGet="editor">editor</field><field virtual="true" toGet="selectionStart" toSet="selectionStart:" changeEvent="textModified">selectionStart</field><field virtual="true" toGet="selectionStop" toSet="selectionStop:" changeEvent="textModified">selectionStop</field><field virtual="true" toGet="contents" toSet="contents:">contents</field></fields>'	classVariableNames: 'StandardEditingKeys '	poolDictionaries: ''	category: 'Tweak-Widgets-Text'!!CTextEditor commentStamp: 'ar 3/27/2004 19:12' prior: 0!CTextEditor represents a generic text editor widget. By default it will not perform any specific actions except text editing, but clients can just register appropriate actions via #onKeyDown:signal: and friends.!CTextEditor subclass: #CInputField	instanceVariableNames: '<?xml  version="1.0"?><fields><field toGet="converter" toSet="converter:" changeEvent="converterChanged">converter</field></fields>'	classVariableNames: ''	poolDictionaries: ''	category: 'Tweak-Widgets-Text'!!CInputField commentStamp: 'ar 3/27/2004 19:10' prior: 0!CInputField is a text editor which reacts to the enter key by accepting its value. It can carry a CTextConverter to convert forth and back between its value (any object) and the text it displays.!CButton subclass: #CTileButton	instanceVariableNames: '<?xml  version="1.0"?><fields></fields>'	classVariableNames: ''	poolDictionaries: ''	category: 'Tweak-Tiles-Costumes'!CButton subclass: #CToolBarButton	instanceVariableNames: '<?xml  version="1.0"?><fields></fields>'	classVariableNames: ''	poolDictionaries: ''	category: 'Tweak-Widgets-Buttons'!CSlider subclass: #CWheelWidget	instanceVariableNames: '<?xml  version="1.0"?><fields></fields>'	classVariableNames: ''	poolDictionaries: ''	category: 'Tweak-Widgets-Scrolling'!CCostume subclass: #CWidgetCostume	instanceVariableNames: '<?xml  version="1.0"?><fields></fields>'	classVariableNames: ''	poolDictionaries: ''	category: 'Tweak-Widgets-Basic-Costumes'!CWidgetCostume subclass: #CButtonCostume	instanceVariableNames: '<?xml  version="1.0"?><fields><field toGet="buttonLabel" toSet="buttonLabel:" changeEvent="buttonLabelChanged">buttonLabel</field><field toGet="buttonImage" toSet="buttonImage:" changeEvent="buttonImageChanged">buttonImage</field></fields>'	classVariableNames: ''	poolDictionaries: ''	category: 'Tweak-Widgets-Buttons-Costumes'!CButtonCostume subclass: #CCheckBoxCostume	instanceVariableNames: '<?xml  version="1.0"?><fields><field toGet="checkMark" toSet="checkMark:" changeEvent="checkMarkChanged">checkMark</field></fields>'	classVariableNames: ''	poolDictionaries: ''	category: 'Tweak-Widgets-Buttons-Costumes'!CWidgetCostume subclass: #CDropDownListCostume	instanceVariableNames: '<?xml  version="1.0"?><fields><field toGet="label" toSet="label:" changeEvent="labelChanged">label</field><field toGet="button" toSet="button:" changeEvent="buttonChanged">button</field></fields>'	classVariableNames: ''	poolDictionaries: ''	category: 'Tweak-Widgets-Lists-Costumes'!CWidgetCostume subclass: #CLabelCostume	instanceVariableNames: '<?xml  version="1.0"?><fields></fields>'	classVariableNames: ''	poolDictionaries: ''	category: 'Tweak-Widgets-Text-Costumes'!CWidgetCostume subclass: #CMenuCostume	instanceVariableNames: '<?xml  version="1.0"?><fields><field instanceVariable="true" toSet="activeChild:">activeChild</field><field instanceVariable="true" toSet="activeParent:">activeParent</field><field toGet="selectedPlayer" toSet="selectedPlayer:" changeEvent="selectedPlayerChanged">selectedPlayer</field><field toGet="menuLabel" toSet="menuLabel:" changeEvent="menuLabelChanged">menuLabel</field><field toGet="menuCursor" toSet="menuCursor:" changeEvent="menuCursorChanged">menuCursor</field><field toGet="holder" toSet="holder:" changeEvent="holderChanged">holder</field></fields>'	classVariableNames: ''	poolDictionaries: ''	category: 'Tweak-Widgets-Menus-Costumes'!CMenuCostume subclass: #CMenuBarCostume	instanceVariableNames: '<?xml  version="1.0"?><fields></fields>'	classVariableNames: ''	poolDictionaries: ''	category: 'Tweak-Widgets-Menus-Costumes'!CButtonCostume subclass: #CPushButtonCostume	instanceVariableNames: '<?xml  version="1.0"?><fields></fields>'	classVariableNames: ''	poolDictionaries: ''	category: 'Tweak-Widgets-Buttons-Costumes'!CButtonCostume subclass: #CRadioButtonCostume	instanceVariableNames: '<?xml  version="1.0"?><fields><field toGet="checkMark" toSet="checkMark:" changeEvent="checkMarkChanged">checkMark</field></fields>'	classVariableNames: ''	poolDictionaries: ''	category: 'Tweak-Widgets-Buttons-Costumes'!CButtonCostume subclass: #CScrollButtonCostume	instanceVariableNames: '<?xml  version="1.0"?><fields></fields>'	classVariableNames: ''	poolDictionaries: ''	category: 'Tweak-Widgets-Scrolling-Costumes'!CWidgetCostume subclass: #CScrollableCostume	instanceVariableNames: '<?xml  version="1.0"?><fields><field toGet="hScrollBar" toSet="hScrollBar:" changeEvent="hScrollBarChanged">hScrollBar</field><field toGet="vScrollBar" toSet="vScrollBar:" changeEvent="vScrollBarChanged">vScrollBar</field><field toGet="scrollTarget" toSet="scrollTarget:" changeEvent="scrollTargetChanged">scrollTarget</field></fields>'	classVariableNames: ''	poolDictionaries: ''	category: 'Tweak-Widgets-Scrolling-Costumes'!!CScrollableCostume commentStamp: 'ar 3/24/2004 22:58' prior: 0!CScrollableCostume is an abstract class provided for convenience to implement costumes requiring scrolling.!CScrollableCostume subclass: #CCustomDrawListCostume	instanceVariableNames: '<?xml  version="1.0"?><fields><field toGet="selectionColor" toSet="selectionColor:" changeEvent="selectionColorChanged">selectionColor</field><field toGet="selectionIndex" toSet="selectionIndex:" changeEvent="selectionIndexChanged">selectionIndex</field></fields>'	classVariableNames: ''	poolDictionaries: ''	category: 'Tweak-Widgets-Lists-Costumes'!CScrollableCostume subclass: #CListCostume	instanceVariableNames: '<?xml  version="1.0"?><fields><field toGet="selectedPlayer" toSet="selectedPlayer:" changeEvent="selectedPlayerChanged">selectedPlayer</field></fields>'	classVariableNames: ''	poolDictionaries: ''	category: 'Tweak-Widgets-Lists-Costumes'!CCustomDrawListCostume subclass: #CMultiColumnListCostume	instanceVariableNames: '<?xml  version="1.0"?><fields><field virtual="true" toGet="columns" toSet="columns:">columns</field><field toGet="header" toSet="header:" changeEvent="headerChanged">header</field></fields>'	classVariableNames: ''	poolDictionaries: ''	category: 'Tweak-Widgets-Lists-Costumes'!CScrollableCostume subclass: #CScrollPaneCostume	instanceVariableNames: '<?xml  version="1.0"?><fields></fields>'	classVariableNames: ''	poolDictionaries: ''	category: 'Tweak-Widgets-Scrolling-Costumes'!CScrollableCostume subclass: #CScrollableTextEditorCostume	instanceVariableNames: '<?xml  version="1.0"?><fields></fields>'	classVariableNames: ''	poolDictionaries: ''	category: 'Tweak-Widgets-Text-Costumes'!!CScrollableTextEditorCostume commentStamp: 'ar 3/27/2004 19:15' prior: 0!CScrollableTextEditorCostume is a costume for a text editor which provides scrollbars. It delegates the textHolder aspect to its scrollTarget since that's the guy who holds the text for the editor.!CWidgetCostume subclass: #CSliderCostume	instanceVariableNames: '<?xml  version="1.0"?><fields></fields>'	classVariableNames: ''	poolDictionaries: ''	category: 'Tweak-Widgets-Scrolling-Costumes'!CSliderCostume subclass: #CScrollBarCostume	instanceVariableNames: '<?xml  version="1.0"?><fields><field toGet="forwardButton" toSet="forwardButton:" changeEvent="forwardButtonChanged">forwardButton</field><field toGet="backButton" toSet="backButton:" changeEvent="backButtonChanged">backButton</field><field toGet="knob" toSet="knob:" changeEvent="knobChanged">knob</field><field toGet="knobShadow" toSet="knobShadow:" changeEvent="knobShadowChanged">knobShadow</field></fields>'	classVariableNames: ''	poolDictionaries: ''	category: 'Tweak-Widgets-Scrolling-Costumes'!CWidgetCostume subclass: #CSpinnerButtonsCostume	instanceVariableNames: '<?xml  version="1.0"?><fields><field toGet="upButton" toSet="upButton:" changeEvent="upButtonChanged">upButton</field><field toGet="downButton" toSet="downButton:" changeEvent="downButtonChanged">downButton</field></fields>'	classVariableNames: ''	poolDictionaries: ''	category: 'Tweak-Widgets-Scrolling-Costumes'!CWidgetCostume subclass: #CSpinnerCostume	instanceVariableNames: '<?xml  version="1.0"?><fields><field toGet="spinnerLabel" toSet="spinnerLabel:" changeEvent="spinnerLabelChanged">spinnerLabel</field><field toGet="spinnerButtons" toSet="spinnerButtons:" changeEvent="spinnerButtonsChanged">spinnerButtons</field><field toGet="spinnerValue" toSet="spinnerValue:" changeEvent="spinnerValueChanged">spinnerValue</field></fields>'	classVariableNames: ''	poolDictionaries: ''	category: 'Tweak-Widgets-Scrolling-Costumes'!CWidgetCostume subclass: #CSpinnerListCostume	instanceVariableNames: '<?xml  version="1.0"?><fields><field toGet="label" toSet="label:" changeEvent="labelChanged">label</field><field toGet="spinner" toSet="spinner:" changeEvent="spinnerChanged">spinner</field></fields>'	classVariableNames: ''	poolDictionaries: ''	category: 'Tweak-Widgets-Lists-Costumes'!CCustomDrawListCostume subclass: #CStringListCostume	instanceVariableNames: '<?xml  version="1.0"?><fields></fields>'	classVariableNames: ''	poolDictionaries: ''	category: 'Tweak-Widgets-Lists-Costumes'!CButtonCostume subclass: #CTabButtonCostume	instanceVariableNames: '<?xml  version="1.0"?><fields></fields>'	classVariableNames: ''	poolDictionaries: ''	category: 'Tweak-Widgets-Buttons-Costumes'!CWidgetCostume subclass: #CTabButtonListCostume	instanceVariableNames: '<?xml  version="1.0"?><fields><field toGet="selectedPlayer" toSet="selectedPlayer:" changeEvent="selectedPlayerChanged">selectedPlayer</field></fields>'	classVariableNames: ''	poolDictionaries: ''	category: 'Tweak-Widgets-Lists-Costumes'!CWidgetCostume subclass: #CTextEditorCostume	instanceVariableNames: '<?xml  version="1.0"?><fields><field toGet="oldBorder" toSet="oldBorder:" changeEvent="oldBorderChanged">oldBorder</field></fields>'	classVariableNames: ''	poolDictionaries: ''	category: 'Tweak-Widgets-Text-Costumes'!!CTextEditorCostume commentStamp: 'ar 3/27/2004 19:15' prior: 0!CTextEditorCostume is a costume for a text editor which provides no scrollbars.!CTextEditorCostume subclass: #CInputFieldCostume	instanceVariableNames: '<?xml  version="1.0"?><fields></fields>'	classVariableNames: ''	poolDictionaries: ''	category: 'Tweak-Widgets-Text-Costumes'!CButtonCostume subclass: #CTileButtonCostume	instanceVariableNames: '<?xml  version="1.0"?><fields></fields>'	classVariableNames: ''	poolDictionaries: ''	category: 'Tweak-Tiles-Costumes'!CButtonCostume subclass: #CToolBarButtonCostume	instanceVariableNames: '<?xml  version="1.0"?><fields></fields>'	classVariableNames: ''	poolDictionaries: ''	category: 'Tweak-Widgets-Buttons-Costumes'!CScrollableCostume subclass: #CTreeWidgetCostume	instanceVariableNames: '<?xml  version="1.0"?><fields><field toGet="selectedPlayer" toSet="selectedPlayer:" changeEvent="selectedPlayerChanged">selectedPlayer</field></fields>'	classVariableNames: ''	poolDictionaries: ''	category: 'Tweak-Widgets-Trees-Costumes'!CSliderCostume subclass: #CWheelWidgetCostume	instanceVariableNames: '<?xml  version="1.0"?><fields><field toGet="maxAngle" toSet="maxAngle:" changeEvent="maxAngleChanged">maxAngle</field><field toGet="wheelAngle" toSet="wheelAngle:" changeEvent="wheelAngleChanged">wheelAngle</field></fields>'	classVariableNames: ''	poolDictionaries: ''	category: 'Tweak-Widgets-Scrolling-Costumes'!CPlayer subclass: #CWidgetLibrary	instanceVariableNames: '<?xml  version="1.0"?><fields></fields>'	classVariableNames: 'Default ImparaColors '	poolDictionaries: ''	category: 'Tweak-Widgets-Support'!!CWidgetLibrary commentStamp: 'ar 3/27/2004 18:01' prior: 0!CWidgetLibrary defines which default costumes to use for various players, the color scheme and some other UI aspects.!CWidget subclass: #CWindow	instanceVariableNames: '<?xml  version="1.0"?><fields><field toGet="closeBox" toSet="closeBox:" changeEvent="closeBoxChanged">closeBox</field><field toGet="maximizeBox" toSet="maximizeBox:" changeEvent="maximizeBoxChanged">maximizeBox</field><field toGet="minimizeBox" toSet="minimizeBox:" changeEvent="minimizeBoxChanged">minimizeBox</field><field toGet="label" toSet="label:" changeEvent="labelChanged">label</field><field toGet="toolBar" toSet="toolBar:" changeEvent="toolBarChanged">toolBar</field><field toGet="menuBar" toSet="menuBar:" changeEvent="menuBarChanged">menuBar</field><field toGet="statusBar" toSet="statusBar:" changeEvent="statusBarChanged">statusBar</field><field toGet="windowColor" toSet="windowColor:" changeEvent="windowColorChanged">windowColor</field></fields>'	classVariableNames: ''	poolDictionaries: ''	category: 'Tweak-Widgets-Basic'!!CWindow commentStamp: 'ar 3/25/2004 18:24' prior: 0!closeBox			<Boolean>	If true, show a close box.maximizeBox		<Boolean>	If true, show a maximize box.minimizeBox		<Boolean>	If true, show a minimize box.label			<String>		The window's label.!CButtonCostume subclass: #CWindowButtonCostume	instanceVariableNames: '<?xml  version="1.0"?><fields></fields>'	classVariableNames: ''	poolDictionaries: ''	category: 'Tweak-Widgets-Basic-Costumes'!CWidgetCostume subclass: #CWindowCostume	instanceVariableNames: '<?xml  version="1.0"?><fields><field toGet="windowFrame" toSet="windowFrame:" changeEvent="windowFrameChanged">windowFrame</field><field toGet="backPage" toSet="backPage:" changeEvent="backPageChanged">backPage</field><field toGet="frontPage" toSet="frontPage:" changeEvent="frontPageChanged">frontPage</field></fields>'	classVariableNames: ''	poolDictionaries: ''	category: 'Tweak-Widgets-Basic-Costumes'!CPlayer subclass: #CWindowCostumeFrame	instanceVariableNames: '<?xml  version="1.0"?><fields><field toGet="closeButton" toSet="closeButton:" changeEvent="closeButtonChanged">closeButton</field><field toGet="collapseButton" toSet="collapseButton:" changeEvent="collapseButtonChanged">collapseButton</field><field toGet="windowLabel" toSet="windowLabel:" changeEvent="windowLabelChanged">windowLabel</field></fields>'	classVariableNames: ''	poolDictionaries: ''	category: 'Tweak-Widgets-Basic-Costumes'!CEventBehavior subclass: #CWindowResizeBehavior	instanceVariableNames: '<?xml  version="1.0"?><fields><field toGet="resizeWithContents" toSet="resizeWithContents:" changeEvent="resizeWithContentsChanged">resizeWithContents</field><field toGet="automaticDragging" toSet="automaticDragging:" changeEvent="automaticDraggingChanged">automaticDragging</field></fields>'	classVariableNames: ''	poolDictionaries: ''	category: 'Tweak-Behaviors'!!CWindowResizeBehavior commentStamp: 'ar 5/3/2004 22:45' prior: 0!CWindowResizeBehavior is a simple event behavior which allows any object to be resized in a "window style" that is showing appropriate resize cursors when the mouse enters the object and resizing by the appropriate edge when the mouse is pressed. When a window resize behavior is attached to a player the player should not handle mouse down events nor use any of its own cursors.Instance variables:	resizeWithContents	<Boolean>	If true, the object will be resized with its contents shown, if false, a frame is shown instead of the object.	automaticDragging	<Boolean>	If true, the object will be automatically dragged when the user clicks outside the resizer border area.!CCodeHolder subclass: #CWorkspace	instanceVariableNames: '<?xml  version="1.0"?><fields><field toGet="bindings" toSet="bindings:" changeEvent="bindingsChanged">bindings</field></fields>'	classVariableNames: ''	poolDictionaries: ''	category: 'Tweak-DevTools'!CPrimitiveCostume subclass: #CWorldCostume	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'Tweak-Worlds'!CPlayer subclass: #CWorldPlayer	instanceVariableNames: '<?xml  version="1.0"?><fields><field instanceVariable="true">sensor</field><field instanceVariable="true">hands</field><field instanceVariable="true">scheduler</field><field instanceVariable="true" toSet="maxLayoutRounds:">maxLayoutRounds</field><field instanceVariable="true">damageRecorder</field><field instanceVariable="true">bltRects</field><field instanceVariable="true" toSet="eventQueue:">eventQueue</field><field instanceVariable="true" toSet="display:">display</field><field instanceVariable="true" toSet="ownerMorph:">ownerMorph</field><field instanceVariable="true">frameNumber</field><field instanceVariable="true" toSet="activeProject:" changeEvent="activeProjectChanged">activeProject</field></fields>'	classVariableNames: ''	poolDictionaries: ''	category: 'Tweak-Worlds'!CBorder class	instanceVariableNames: ''!CCanvasCache class	instanceVariableNames: ''!CChangeRecord class	instanceVariableNames: ''!CClipboard class	instanceVariableNames: ''!CCollectionMatcher class	instanceVariableNames: ''!CAllMatcher class	instanceVariableNames: ''!CAnyMatcher class	instanceVariableNames: ''!CComponentBinding class	instanceVariableNames: ''!CCornerRounder class	instanceVariableNames: ''!CCostumePen class	instanceVariableNames: ''!CCursorLibrary class	instanceVariableNames: ''!CDamageRecorder class	instanceVariableNames: ''!CDeserializer class	instanceVariableNames: ''!CDisplayTransform class	instanceVariableNames: ''!CFormCache class	instanceVariableNames: ''!CGraphicsFill class	instanceVariableNames: ''!CGraphicsShape class	instanceVariableNames: ''!CIconLibrary class	instanceVariableNames: ''!CIdentityTransform class	instanceVariableNames: ''!CKeyboardDispatchTable class	instanceVariableNames: ''!CLayoutCell class	instanceVariableNames: ''!CLayoutFrame class	instanceVariableNames: ''!CLayoutProperties class	instanceVariableNames: ''!CMD5Hasher class	instanceVariableNames: ''!CMakerPart class	instanceVariableNames: ''!CGlobalPart class	instanceVariableNames: ''!CMatrixTransform class	instanceVariableNames: ''!CMouseClickState class	instanceVariableNames: ''!CMouseOverHandler class	instanceVariableNames: ''!CObject class	instanceVariableNames: 'uuid '!CCollectionBase class	instanceVariableNames: ''!CCollection class	instanceVariableNames: ''!CCollectionClient class	instanceVariableNames: ''!CArrayedCollectionClient class	instanceVariableNames: ''!CCostumeAspect class	instanceVariableNames: ''!CCostumeBorder class	instanceVariableNames: ''!CCostumeFill class	instanceVariableNames: ''!CCostumeGraphic class	instanceVariableNames: ''!CCostumeGrid class	instanceVariableNames: ''!CCostumeHighlight class	instanceVariableNames: ''!CBorderHighlight class	instanceVariableNames: ''!CCoronaHighlight class	instanceVariableNames: ''!CCostumeTextHolder class	instanceVariableNames: ''!CCursorHighlight class	instanceVariableNames: ''!CDialog class	instanceVariableNames: ''!CDirectoryEntry class	instanceVariableNames: ''!CDropShadowHighlight class	instanceVariableNames: ''!CEventBehavior class	instanceVariableNames: ''!CExampleBehavior class	instanceVariableNames: ''!CFillingHighlight class	instanceVariableNames: ''!CFramingHighlight class	instanceVariableNames: ''!CLayoutPolicy class	instanceVariableNames: ''!CLibraryEntry class	instanceVariableNames: ''!CListLayout class	instanceVariableNames: ''!CMenuItem class	instanceVariableNames: ''!CMultiColumnListSpec class	instanceVariableNames: ''!CNoBorder class	instanceVariableNames: ''!CNoFill class	instanceVariableNames: ''!CObjectMakerDeserializer class	instanceVariableNames: ''!CObjectMakerImporter class	instanceVariableNames: ''!COffsetTransform class	instanceVariableNames: ''!COrientedFill class	instanceVariableNames: ''!CBitmapFill class	instanceVariableNames: ''!CGradientFill class	instanceVariableNames: ''!CPartBinding class	instanceVariableNames: ''!CPlayer class	instanceVariableNames: ''!CBorderStyleReadout class	instanceVariableNames: ''!CCodeHolder class	instanceVariableNames: ''!CChangeSorter class	instanceVariableNames: ''!CClassBrowser class	instanceVariableNames: ''!CColorPicker class	instanceVariableNames: ''!CColorTool class	instanceVariableNames: ''!CColorToolBorderPage class	instanceVariableNames: ''!CColorToolFillPage class	instanceVariableNames: ''!CColorToolFlagsPage class	instanceVariableNames: ''!CCostume class	instanceVariableNames: ''!CCustomDrawListTarget class	instanceVariableNames: ''!CDebugger class	instanceVariableNames: ''!CFieldReference class	instanceVariableNames: ''!CFileDialog class	instanceVariableNames: ''!CFileDialogCostume class	instanceVariableNames: ''!CFileDialogPattern class	instanceVariableNames: ''!CFileDialogSorter class	instanceVariableNames: ''!CFileOpenDialog class	instanceVariableNames: ''!CFileOpenDialogCostume class	instanceVariableNames: ''!CFileSaveDialog class	instanceVariableNames: ''!CFileSaveDialogCostume class	instanceVariableNames: ''!CFillStyleReadout class	instanceVariableNames: ''!CHalo class	instanceVariableNames: ''!CHaloButton class	instanceVariableNames: ''!CHaloResizer class	instanceVariableNames: ''!CHandPlayer class	instanceVariableNames: ''!CHolder class	instanceVariableNames: ''!CImagePlayer class	instanceVariableNames: ''!CInspector class	instanceVariableNames: ''!CContextVariablesInspector class	instanceVariableNames: ''!CLibraryEntryCostume class	instanceVariableNames: ''!CList class	instanceVariableNames: ''!CDropDownList class	instanceVariableNames: ''!CMenuItemSeparator class	instanceVariableNames: ''!CMessageSet class	instanceVariableNames: ''!CChangedMessageSet class	instanceVariableNames: ''!CMoviePlayer class	instanceVariableNames: ''!CMultiColorPicker class	instanceVariableNames: ''!CMultiColumnList class	instanceVariableNames: ''!CMultiSelectionHalo class	instanceVariableNames: ''!CPlayerCollection class	instanceVariableNames: ''!CPreDebugger class	instanceVariableNames: ''!CPrimitiveCostume class	instanceVariableNames: ''!CHandCostume class	instanceVariableNames: ''!CProject class	instanceVariableNames: ''!CProjectBuilder class	instanceVariableNames: ''!CProjectCostume class	instanceVariableNames: ''!CProjectLibrary class	instanceVariableNames: ''!CProjectLoader class	instanceVariableNames: ''!CPropertyChange class	instanceVariableNames: ''!CProportionalLayout class	instanceVariableNames: ''!CResource class	instanceVariableNames: ''!CMaker class	instanceVariableNames: ''!CMediaResource class	instanceVariableNames: ''!CImageResource class	instanceVariableNames: ''!CMovieResource class	instanceVariableNames: ''!CObjectMaker class	instanceVariableNames: ''!CResourceManager class	instanceVariableNames: ''!CRootMorph class	instanceVariableNames: ''!CScriptChange class	instanceVariableNames: ''!CScriptForObject class	instanceVariableNames: ''!CEnglishForObject class	instanceVariableNames: ''!CEnglishObjOutline class	instanceVariableNames: ''!CKeywordsForObject class	instanceVariableNames: ''!CScriptorHeader class	instanceVariableNames: ''!CSerializer class	instanceVariableNames: ''!CObjectMakerSerializer class	instanceVariableNames: ''!CSharedPart class	instanceVariableNames: ''!CObjectPart class	instanceVariableNames: ''!CBitsArrayPart class	instanceVariableNames: ''!CReferencePart class	instanceVariableNames: ''!CResourcePart class	instanceVariableNames: ''!CSequencePart class	instanceVariableNames: ''!CSimpleBorder class	instanceVariableNames: ''!CComplexBorder class	instanceVariableNames: ''!CInsetBorder class	instanceVariableNames: ''!CRaisedBorder class	instanceVariableNames: ''!CSimpleLayout class	instanceVariableNames: ''!CSimpleTextEditor class	instanceVariableNames: ''!CSolidFill class	instanceVariableNames: ''!CSoundPlayer class	instanceVariableNames: ''!CSoundResource class	instanceVariableNames: ''!CSpinnerList class	instanceVariableNames: ''!CStringList class	instanceVariableNames: ''!CStyleReadoutList class	instanceVariableNames: ''!CTabButtonList class	instanceVariableNames: ''!CTableLayout class	instanceVariableNames: ''!CTableLayoutProperties class	instanceVariableNames: ''!CTextComposer class	instanceVariableNames: ''!CTextConverter class	instanceVariableNames: ''!CDateConverter class	instanceVariableNames: ''!CNumberConverter class	instanceVariableNames: ''!CStringConverter class	instanceVariableNames: ''!CTextEditorPane class	instanceVariableNames: ''!CTextParagraph class	instanceVariableNames: ''!CTextParagraphEditor class	instanceVariableNames: ''!CTextTool class	instanceVariableNames: ''!CTileCostume class	instanceVariableNames: ''!CColorTileCostume class	instanceVariableNames: ''!CEnumListCostume class	instanceVariableNames: ''!CEnumTileCostume class	instanceVariableNames: ''!CImageResourceTileCostume class	instanceVariableNames: ''!CMessageAndArgsCostume class	instanceVariableNames: ''!CMessagePartCostume class	instanceVariableNames: ''!CMessageTileCostume class	instanceVariableNames: ''!CNumberTileCostume class	instanceVariableNames: ''!COperatorTileCostume class	instanceVariableNames: ''!CPropertyTileCostume class	instanceVariableNames: ''!CReceiverTileCostume class	instanceVariableNames: ''!CSequenceTileCostume class	instanceVariableNames: ''!CScriptorTileCostume class	instanceVariableNames: ''!CSoundTileCostume class	instanceVariableNames: ''!CStringTileCostume class	instanceVariableNames: ''!CTileDefinition class	instanceVariableNames: ''!CArgumentDefinition class	instanceVariableNames: ''!CCategoryDefinition class	instanceVariableNames: ''!CMessageDefinition class	instanceVariableNames: ''!COperatorDefinition class	instanceVariableNames: ''!CSlotDefinition class	instanceVariableNames: ''!CTileInspector class	instanceVariableNames: ''!CTileLibrary class	instanceVariableNames: ''!CTilePlayer class	instanceVariableNames: ''!CMessageTile class	instanceVariableNames: ''!COperatorTile class	instanceVariableNames: ''!CPropertyTile class	instanceVariableNames: ''!CSequenceTile class	instanceVariableNames: ''!CScriptorTile class	instanceVariableNames: ''!CTileReadout class	instanceVariableNames: ''!CTileType class	instanceVariableNames: ''!CColorType class	instanceVariableNames: ''!CEnumType class	instanceVariableNames: ''!CBooleanType class	instanceVariableNames: ''!CNumberType class	instanceVariableNames: ''!CIntegerType class	instanceVariableNames: ''!CPlayerType class	instanceVariableNames: ''!CResourceType class	instanceVariableNames: ''!CImageResourceType class	instanceVariableNames: ''!CSoundNameType class	instanceVariableNames: ''!CStringType class	instanceVariableNames: ''!CSymbolType class	instanceVariableNames: ''!CBorderStyleType class	instanceVariableNames: ''!CButtonStateType class	instanceVariableNames: ''!CFillStyleType class	instanceVariableNames: ''!CTileViewer class	instanceVariableNames: ''!CTileViewerPage class	instanceVariableNames: ''!CTreeItem class	instanceVariableNames: ''!CFileDirectoryTreeItem class	instanceVariableNames: ''!CServerDirectoryTreeItem class	instanceVariableNames: ''!CTreeItemCostume class	instanceVariableNames: ''!CTreeWidget class	instanceVariableNames: ''!CTweakDeserializer class	instanceVariableNames: ''!CTweakMaker class	instanceVariableNames: ''!CTweakSerializer class	instanceVariableNames: ''!CTweakedPart class	instanceVariableNames: ''!CUserDialog class	instanceVariableNames: ''!CValuePlayer class	instanceVariableNames: ''!CListItem class	instanceVariableNames: ''!CMenuItemCostume class	instanceVariableNames: ''!CValueTile class	instanceVariableNames: ''!CValueTileCostume class	instanceVariableNames: ''!CVariableTile class	instanceVariableNames: ''!CVariableTileCostume class	instanceVariableNames: ''!CVectorShape class	instanceVariableNames: ''!CViewerCategoryHeader class	instanceVariableNames: ''!CViewerDefinition class	instanceVariableNames: ''!CViewerRow class	instanceVariableNames: ''!CWidget class	instanceVariableNames: ''!CButton class	instanceVariableNames: ''!CCheckBox class	instanceVariableNames: ''!CConstraintValueWidget class	instanceVariableNames: ''!CImageButton class	instanceVariableNames: ''!CLabel class	instanceVariableNames: ''!CMenu class	instanceVariableNames: ''!CMenuBar class	instanceVariableNames: ''!CPushButton class	instanceVariableNames: ''!CRadioButton class	instanceVariableNames: ''!CScrollPane class	instanceVariableNames: ''!CSlider class	instanceVariableNames: ''!CScrollBar class	instanceVariableNames: ''!CSpinner class	instanceVariableNames: ''!CSpinnerButtons class	instanceVariableNames: ''!CTabButton class	instanceVariableNames: ''!CTextEditor class	instanceVariableNames: ''!CInputField class	instanceVariableNames: ''!CTileButton class	instanceVariableNames: ''!CToolBarButton class	instanceVariableNames: ''!CWheelWidget class	instanceVariableNames: ''!CWidgetCostume class	instanceVariableNames: ''!CButtonCostume class	instanceVariableNames: ''!CCheckBoxCostume class	instanceVariableNames: ''!CDropDownListCostume class	instanceVariableNames: ''!CLabelCostume class	instanceVariableNames: ''!CMenuCostume class	instanceVariableNames: ''!CMenuBarCostume class	instanceVariableNames: ''!CPushButtonCostume class	instanceVariableNames: ''!CRadioButtonCostume class	instanceVariableNames: ''!CScrollButtonCostume class	instanceVariableNames: ''!CScrollableCostume class	instanceVariableNames: ''!CCustomDrawListCostume class	instanceVariableNames: ''!CListCostume class	instanceVariableNames: ''!CMultiColumnListCostume class	instanceVariableNames: ''!CScrollPaneCostume class	instanceVariableNames: ''!CScrollableTextEditorCostume class	instanceVariableNames: ''!CSliderCostume class	instanceVariableNames: ''!CScrollBarCostume class	instanceVariableNames: ''!CSpinnerButtonsCostume class	instanceVariableNames: ''!CSpinnerCostume class	instanceVariableNames: ''!CSpinnerListCostume class	instanceVariableNames: ''!CStringListCostume class	instanceVariableNames: ''!CTabButtonCostume class	instanceVariableNames: ''!CTabButtonListCostume class	instanceVariableNames: ''!CTextEditorCostume class	instanceVariableNames: ''!CInputFieldCostume class	instanceVariableNames: ''!CTileButtonCostume class	instanceVariableNames: ''!CToolBarButtonCostume class	instanceVariableNames: ''!CTreeWidgetCostume class	instanceVariableNames: ''!CWheelWidgetCostume class	instanceVariableNames: ''!CWidgetLibrary class	instanceVariableNames: ''!CWindow class	instanceVariableNames: ''!CWindowButtonCostume class	instanceVariableNames: ''!CWindowCostume class	instanceVariableNames: ''!CWindowCostumeFrame class	instanceVariableNames: ''!CWindowResizeBehavior class	instanceVariableNames: ''!CWorkspace class	instanceVariableNames: ''!CWorldCostume class	instanceVariableNames: ''!CWorldPlayer class	instanceVariableNames: ''!FormCanvas subclass: #CTransformCanvas	instanceVariableNames: 'backup transform maskCanvas forceWarp warpTransform font fontColor fontChanged '	classVariableNames: ''	poolDictionaries: ''	category: 'Tweak-Costumes-Support'!CTransformCanvas class	instanceVariableNames: ''!Object subclass: #HaloFont	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'Tweak-Fonts'!HaloFont class	instanceVariableNames: ''!ListItemWrapper subclass: #NSPluggableListItemWrapper	instanceVariableNames: 'string getContentsSelector getStringSelector hasContentsSelector '	classVariableNames: ''	poolDictionaries: ''	category: 'Tweak-Hacks'!NSPluggableListItemWrapper class	instanceVariableNames: ''!Browser subclass: #NSTweakBrowser	instanceVariableNames: 'environment envListIndex selectedWrapper selectedSystemCategory '	classVariableNames: ''	poolDictionaries: ''	category: 'Tweak-Hacks'!NSTweakBrowser class	instanceVariableNames: ''!WriteStream subclass: #CTextStream	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'Tweak-Misc'!CTextStream class	instanceVariableNames: ''!InstructionClient subclass: #TweakTestMethodAnalyzer	instanceVariableNames: 'dubiousReturn '	classVariableNames: ''	poolDictionaries: ''	category: 'Tweak-Tests'!TweakTestMethodAnalyzer class	instanceVariableNames: ''!TestCase subclass: #TweakTests	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'Tweak-Tests'!TweakTests class	instanceVariableNames: ''!SystemWindow subclass: #UpdateLoaderUI	instanceVariableNames: 'managers updateInfo managerIndex '	classVariableNames: ''	poolDictionaries: ''	category: 'Tweak-Updates-Support'!UpdateLoaderUI class	instanceVariableNames: ''!Object subclass: #UpdateManager	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'Tweak-Updates'!UpdateManager subclass: #SqueakUpdateStreamManager	instanceVariableNames: 'uploadUrl downloadUrl smCard '	classVariableNames: ''	poolDictionaries: ''	category: 'Tweak-Updates'!!SqueakUpdateStreamManager commentStamp: 'ar 5/14/2003 19:55' prior: 0!#(ServerDirectory SystemVersion Utilities ChangeSet ChangeSorter) do:[:each|	| binding |	binding := Smalltalk associationAt: each.	SqueakUpdateStreamManager browseAllCallsOn: binding.].| mgr |mgr := TestUpdateStreamManager new.mgr uploadUrl: 'ftp://raab@luxator.cs.uni-magdeburg.de/~/public_html/squeak/updates/test'.mgr downloadUrl: 'http://isgwww.cs.uni-magdeburg.de/~raab/squeak/updates/test'.mgr applyUpdatesFromDisk.mgr highestUpdate."mgr publishUpdate: (FileStream readOnlyFileNamed: 'test-update')."!SqueakUpdateStreamManager subclass: #DefaultUpdateStreamManager	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'Tweak-Updates'!!DefaultUpdateStreamManager commentStamp: 'ar 5/14/2003 19:46' prior: 0!(DefaultUpdateStreamManager new initialize) availableUpdatesDescriptionHTTPClient httpGet: 'http://squeak.cs.uiuc.edu/Squeak2.0/updates/updates.list'!SqueakUpdateStreamManager subclass: #SMCardUpdateStreamManager	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'Tweak-Updates'!SqueakUpdateStreamManager subclass: #SimpleUpdateStreamManager	instanceVariableNames: 'packageVersion '	classVariableNames: 'Registry '	poolDictionaries: ''	category: 'Tweak-Updates'!SimpleUpdateStreamManager subclass: #TweakUpdateStreamManager	instanceVariableNames: ''	classVariableNames: 'TrackingVersion '	poolDictionaries: ''	category: 'Tweak-Updates'!UpdateManager class	instanceVariableNames: ''!SqueakUpdateStreamManager class	instanceVariableNames: ''!DefaultUpdateStreamManager class	instanceVariableNames: ''!SMCardUpdateStreamManager class	instanceVariableNames: ''!SimpleUpdateStreamManager class	instanceVariableNames: ''!TweakUpdateStreamManager class	instanceVariableNames: ''!Object subclass: #WindowFont	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'Tweak-Fonts'!WindowFont class	instanceVariableNames: ''!XMLWriter subclass: #XMLWriterIndenting	instanceVariableNames: 'indent '	classVariableNames: ''	poolDictionaries: ''	category: 'Tweak-Maker'!XMLWriterIndenting class	instanceVariableNames: ''!!CCollectionMatcher methodsFor: 'private' stamp: 'ar 3/14/2004 16:23'!doesNotUnderstand: aMessage	^self pvtMatchSelector: aMessage selector arguments: aMessage arguments.! !!CCollectionMatcher methodsFor: 'private' stamp: 'ar 3/14/2004 16:30'!privateSetCollectionTarget: aCollection	target := aCollection.! !!CCollectionMatcher methodsFor: 'private' stamp: 'ar 3/14/2004 16:23'!pvtMatchSelector: aSelector arguments: arguments	^false! !!CAllMatcher methodsFor: 'private' stamp: 'ar 3/14/2004 16:24'!pvtMatchSelector: aSelector arguments: arguments	^target allSatisfy:[:each| each perform: aSelector withArguments: arguments]! !!CAnyMatcher methodsFor: 'private' stamp: 'ar 3/14/2004 16:24'!pvtMatchSelector: aSelector arguments: arguments	^target anySatisfy:[:each| each perform: aSelector withArguments: arguments]! !!Object methodsFor: '*Tweak-Components' stamp: 'ar 3/15/2004 20:30'!componentBinding	"Answer nil"	^nil! !!Object methodsFor: '*Tweak-Components' stamp: 'ar 3/15/2004 20:30'!componentBinding: aBinding	"Do nothing"	^nil! !!Object methodsFor: '*Tweak-Components' stamp: 'ar 3/15/2004 20:30'!componentName	"Answer the name of this component"	^(self componentBinding ifNil:[^nil]) key! !!Object methodsFor: '*Tweak-Components' stamp: 'ar 3/15/2004 20:29'!componentOwner	"Answer the owner of this component"	^(self componentBinding ifNil:[^nil]) home! !!Object methodsFor: '*Tweak' stamp: 'ar 3/25/2004 18:45'!asPlayer	^CValuePlayer on: self! !!Object methodsFor: '*Tweak' stamp: 'ar 12/8/2002 03:38'!asText	^self asString asText! !!Object methodsFor: '*Tweak' stamp: 'ar 5/24/2003 00:57'!copyFrom: anotherObject	"Copy to myself all instance variables I have in common with anotherObject.  This is dangerous because it ignores an object's control over its own inst vars.  "	| mine his |	self class == anotherObject class ifTrue:[		1 to: self class instSize do:[:i|			self instVarAt: i put: (anotherObject instVarAt: i).		].		1 to: (self basicSize min: anotherObject basicSize) do: [:i|			self basicAt: i put: (anotherObject basicAt: i).		].		^self].	mine _ self class allInstVarNames.	his _ anotherObject class allInstVarNames.	1 to: (mine size min: his size) do: [:ind |		(mine at: ind) = (his at: ind) ifTrue: [			self instVarAt: ind put: (anotherObject instVarAt: ind)]].	self class isVariable & anotherObject class isVariable ifTrue: [		1 to: (self basicSize min: anotherObject basicSize) do: [:ind |			self basicAt: ind put: (anotherObject basicAt: ind)]].! !!Object methodsFor: '*Tweak'!debug	Smalltalk debug: thisContext label: 'Debugger'.! !!Object methodsFor: '*Tweak' stamp: 'ar 3/30/2004 02:41'!deselect	"Graphically deselect the receiver"! !!Object methodsFor: '*Tweak' stamp: 'ar 12/8/2003 22:16'!displayFrom: gDev	"Display me on the given graphics device"	^self displayOn: gDev! !!Object methodsFor: '*Tweak' stamp: 'ar 12/9/2003 00:35'!displayOn: gDev	"Display me on the given graphics device"	gDev display: self asString.! !!Object methodsFor: '*Tweak' stamp: 'ar 3/12/2004 22:07'!displayText	^self asText! !!Object methodsFor: '*Tweak' stamp: 'ar 2/10/2004 14:18'!equals: anObject	"Safely determine whether I am equal to anObject.	Meaning:		- If I am identical to anObject, I am equal		- If I am not of the same class as anObject I am not equal		- If I am of the same class as anObject use #= to see whether I am equal	"	self == anObject ifTrue:[^true].	self class == anObject class ifFalse:[^false].	^self = anObject! !!Object methodsFor: '*Tweak' stamp: 'ar 6/20/2003 18:28'!fieldNamed: fieldName	^nil! !!Object methodsFor: '*Tweak' stamp: 'md 5/3/2004 14:23'!ifTweak: trueBlock	^ActiveHand isPlayer ifTrue: trueBlock! !!Object methodsFor: '*Tweak' stamp: 'md 5/3/2004 13:53'!ifTweak: trueBlock ifNot: falseBlock	^ActiveHand isPlayer ifTrue: trueBlock ifFalse: falseBlock! !!Object methodsFor: '*Tweak' stamp: 'tk 6/19/2004 17:02'!isCObject	^ false! !!Object methodsFor: '*Tweak' stamp: 'ar 3/15/2004 20:14'!isComponentBinding	"Answer true if I represent a component binding"	^false! !!Object methodsFor: '*Tweak' stamp: 'ar 2/24/2004 15:56'!isMakerPart	^false! !!Object methodsFor: '*Tweak' stamp: 'ar 2/5/2003 17:52'!isPlayer	^false! !!Object methodsFor: '*Tweak' stamp: 'tk 6/22/2004 17:47'!isPrimitiveCostume	^false! !!Object methodsFor: '*Tweak'!isRectangle	^false! !!Object methodsFor: '*Tweak' stamp: 'ar 3/24/2004 00:51'!maker	^self class! !!Object methodsFor: '*Tweak' stamp: 'ar 10/16/2003 12:21'!maker: aMaker! !!Object methodsFor: '*Tweak' stamp: 'ar 9/24/2003 13:49'!postBuildWith: aFactory! !!Object methodsFor: '*Tweak' stamp: 'ar 10/16/2003 13:03'!readFieldsFrom: deSerializer	"Write the fields of the receiver on the given serializer."	| ivNames v |	ivNames := self class allInstVarNames.	1 to: ivNames size do:[:i|		v := deSerializer readField: (ivNames at: i) ifAbsent:[self instVarAt: i].		self instVarAt: i put: v.	].	self class isVariable ifFalse:[^self].	1 to: self basicSize do:[:i|		v := deSerializer readField: i ifAbsent:[self basicAt: i].		self basicAt: i put: v.	].! !!Object methodsFor: '*Tweak' stamp: 'ar 3/30/2004 02:41'!select	"Graphically select the receiver"! !!Object methodsFor: '*Tweak' stamp: 'ar 9/17/2003 17:50'!serializeOn: aSerializer	^aSerializer writeObject: self! !!Object methodsFor: '*Tweak' stamp: 'ar 3/25/2004 18:56'!swapEndsIn: aMaker	"Reverse endianness in some word-like object while being constructed in a factory.	The default here assumes that we do in fact have 32bit quantities; specific subclasses	may implement this differently."	(self class isWords and:[self class isPointers not])		ifTrue:[aMaker swapWordsIn: self].! !!Object methodsFor: '*Tweak'!value	^self! !!Object methodsFor: '*Tweak' stamp: 'ar 2/14/2004 22:25'!valueInMaker: aMaker	^self! !!Object methodsFor: '*Tweak' stamp: 'ar 9/18/2003 21:16'!writeFieldsOn: aSerializer	"Write the fields of the receiver on the given serializer."	| ivNames |	ivNames := self class allInstVarNames.	1 to: ivNames size do:[:i|		aSerializer writeField: (ivNames at: i) value: (self instVarAt: i).	].	self class isVariable ifFalse:[^self].	1 to: self basicSize do:[:i|		aSerializer writeField: i value: (self basicAt: i).	].! !!Object methodsFor: '*Tweak-Tweaking' stamp: 'ar 2/27/2004 18:32'!isTweaked	"Answer whether I have any tweaks to write out"	^self tweaks notNil! !!Object methodsFor: '*Tweak-Tweaking' stamp: 'ar 2/27/2004 18:33'!isTweakedFrom: oldValue	"Answer true if I have been tweaked from oldValue"	self == oldValue ifTrue:[^self isTweaked].	self class == oldValue class ifFalse:[^true]. "definitely changed"	^(self = oldValue) not! !!Object methodsFor: '*Tweak-Tweaking' stamp: 'ar 2/27/2004 18:33'!readTweakedFieldsFrom: deSerializer	"I don't record changes so read all my fields"	^self readFieldsFrom: deSerializer! !!Object methodsFor: '*Tweak-Tweaking' stamp: 'ar 2/27/2004 18:30'!tweak: propertyName to: newValue	| oldValue |	oldValue := self perform: propertyName.	self perform: (propertyName,':') asSymbol with: newValue.	self tweaked: propertyName from: oldValue to: newValue.! !!Object methodsFor: '*Tweak-Tweaking' stamp: 'ar 2/27/2004 18:30'!tweaked: propName after: aBlock	| oldValue newValue |	oldValue := self perform: propName.	aBlock value.	newValue := self perform: propName.	self tweaked: propName from: oldValue to: newValue.! !!Object methodsFor: '*Tweak-Tweaking' stamp: 'ar 2/27/2004 18:31'!tweaked: propName from: oldValue to: newValue	"Remember the change of the given property from its previous to its new value.	Answer true if the receiver is newly changed or reverted back to unchanged."	| tweaks chgRec update |	propName ifNil:[self error: 'What are you trying to do???'. ^false].	update := false.	(tweaks := self tweaks) ifNil:[		update := update not.		self tweaks: (tweaks := Dictionary new)].	chgRec := tweaks at: propName ifAbsentPut:[CPropertyChange new value: oldValue].	(newValue isTweakedFrom: chgRec value) ifFalse:[		tweaks removeKey: propName.		tweaks isEmpty ifTrue:[			update := update not.			self tweaks: nil].	].	^update! !!Object methodsFor: '*Tweak-Tweaking' stamp: 'ar 2/27/2004 18:32'!tweaks	"Answer the tweaks associated with the receiver. By default we answer nil here as it is a responsibility of our subclasses to provide the place where to put tweaks."	^nil! !!Object methodsFor: '*Tweak-Tweaking' stamp: 'ar 2/27/2004 18:32'!tweaks: aDictionary	"Set the tweaks associated with the receiver. By default we ignore this message as it is a responsibility of our subclasses to provide the place where to put tweaks."! !!Object methodsFor: '*Tweak-Tweaking' stamp: 'ar 2/27/2004 18:33'!writeTweakedFieldsOn: aSerializer	"I don't record tweaks so write all my fields"	^self writeFieldsOn: aSerializer! !!Object methodsFor: '*Tweak-Scripts' stamp: 'ar 7/28/2004 22:55'!autoStartScripts	"Start all the scripts that should be automatically initiated when the object is created"	| theClass triggers |	theClass := self class.	[theClass == Object] whileFalse:[		triggers := theClass methodTriggers.		1 to: triggers size do:[:i|			(triggers at: i) installIn: self.		].		theClass := theClass superclass	].! !!Object methodsFor: '*Tweak-Fields' stamp: 'ar 3/11/2004 19:43'!definedFields	^self class allFields, self instanceFields! !!Object methodsFor: '*Tweak-Fields' stamp: 'ar 2/21/2004 21:03'!get: fieldName	^self instVarAt: (self class allInstVarNames indexOf: fieldName ifAbsent:[^nil])! !!Object methodsFor: '*Tweak-Fields'!getField: aField	aField accessKey 		ifNil:[^self perform: aField toGet]		ifNotNil:[^self perform: aField toGet with: aField accessKey]! !!Object methodsFor: '*Tweak-Fields'!instanceFields	"Answer the fields defined only for this instance"	self basicSize = 0 ifTrue:[^#()].	^Array streamContents:[:s|		1 to: self basicSize do:[:i|			| fieldDef |			fieldDef := CFieldDefinition named: i asString.			fieldDef toGet: #basicAt:.			fieldDef toSet: #basicAt:put:.			fieldDef accessKey: i.			s nextPut: fieldDef.		].	]! !!Object methodsFor: '*Tweak-Fields'!setField: aField to: aValue	aField accessKey		ifNil:[^self perform: aField toSet with: aValue]		ifNotNil:[^self perform: aField toSet with: aField accessKey with: aValue]! !!Behavior methodsFor: '*Tweak'!addUniClass: aClass	"(Weakly) remember aClass as one my subclasses. 	For now, this is a hack."	self addObsoleteSubclass: aClass.! !!Behavior methodsFor: '*Tweak' stamp: 'ar 2/17/2004 15:13'!defaultCostumeMaker	^CLabel! !!Behavior methodsFor: '*Tweak' stamp: 'tk 6/20/2004 23:47'!fieldNamed: aSymbol	| aGetter |	^self allFields detect:[:any| any name = aSymbol] ifNone:[		(aGetter _ aSymbol) last == $: 			ifTrue: ["allow a setter like borderWidth:, to retrieve field borderWidth"				aGetter _ (aSymbol copyFrom: 1 to: (aSymbol indexOf: $:)-1) asSymbol.				self fieldNamed: aGetter]			ifFalse: [nil]].! !!Behavior methodsFor: '*Tweak' stamp: 'ar 2/7/2004 21:45'!findUniClass: uuid	"For now, this is a hack."	^(ObsoleteSubclasses at: self ifAbsent:[^nil]) 		detect:[:any| any notNil and:[any isUniClass and:[any uuid = uuid]]]		ifNone:[nil]! !!Behavior methodsFor: '*Tweak'!printSubclassesOn: aStream level: level	"Behaviors don't know their subclasses"! !!Behavior methodsFor: '*Tweak-Resources' stamp: 'ar 2/24/2004 15:24'!allImportsDo: aBlock	^nil! !!Behavior methodsFor: '*Tweak-Resources' stamp: 'ar 2/24/2004 15:24'!allImportsDo: aBlock excluding: aSet	^nil! !!Behavior methodsFor: '*Tweak-Resources' stamp: 'ar 12/2/2003 18:59'!embedResourceIn: zipArchive	"For now, do nothing."	^self embedResourceIn: zipArchive notifying: nil! !!Behavior methodsFor: '*Tweak-Resources' stamp: 'ar 12/2/2003 23:20'!embedResourceIn: zipArchive notifying: bar	"For now, do nothing."	| aStream |	false ifTrue:[		bar ifNotNil:[bar value: 'Exporting ', self name,'...'].		aStream := (String new: 1000) writeStream.		self fileOutOn: aStream.		zipArchive addDeflateString: aStream contents as: self resourceDirectory, self name, '.st'.	].	^self! !!Behavior methodsFor: '*Tweak-Resources' stamp: 'ar 2/21/2004 21:37'!exportXmlOn: xmlWriter	"When exporting an object that uses a shared resource, this method needs to write out an appropriate description of the receiver. This method should provide enough information for the loader to construct the resource even if it hasn't been loaded yet."	xmlWriter startTag: self resourceType.	xmlWriter attribute: 'id' value: self resourceID asString.	xmlWriter attribute: 'extends' value: self superclass resourceID asString.	xmlWriter endEmptyTag:  self resourceType.! !!Behavior methodsFor: '*Tweak-Resources' stamp: 'ar 12/2/2003 23:20'!resourceDirectory	"Helper to get a consistent location"	^'resources/', self resourceType,'/', self resourceID asString,'/'! !!Behavior methodsFor: '*Tweak-Resources' stamp: 'ar 12/2/2003 18:40'!resourceID	"Answer a unique ID for this resource"	^self name! !!Behavior methodsFor: '*Tweak-Resources' stamp: 'ar 12/2/2003 18:40'!resourceType	^#class! !!BitBlt methodsFor: '*Tweak' stamp: 'ar 4/4/2004 19:25'!displayString: aString from: startIndex to: stopIndex at: aPoint ttcFont: aFont kern: kernDelta	| ascii form minAscii maxAscii |	minAscii := aFont minAscii.	maxAscii := aFont maxAscii.	destX := aPoint x.	destY := aPoint y.	sourceX := sourceY := 0.	startIndex to: stopIndex do: [:charIndex | 		ascii _ (aString at: charIndex) asciiValue bitAnd: 16rFFFFFF.		(ascii < minAscii or:[ascii > maxAscii]) ifTrue:[ascii := maxAscii].		form _ aFont formOf: (aString at: charIndex).		self sourceForm: form.		width := form width.		height := form height.		self copyBits.		destX := destX + form width + kernDelta.	].! !!Boolean methodsFor: '*Tweak' stamp: 'ar 12/1/2003 20:53'!exportXmlOn: xmlWriter key: aKey	xmlWriter startTag: aKey.	xmlWriter attribute: 'type' value: 'Boolean'.	xmlWriter attribute: 'value' value: self printString.	xmlWriter endEmptyTag: aKey.! !!Boolean methodsFor: '*Tweak' stamp: 'ar 9/17/2003 17:37'!serializeOn: aSerializer	^aSerializer writeBoolean: self! !!Browser methodsFor: '*Tweak' stamp: 'ar 5/6/2004 00:36'!addField	"Add a new instance field"	| fieldName aClass toGet toSet |	aClass := self selectedClass ifNil:[^self].	fieldName := FillInTheBlank request:'Field name?'.	fieldName isEmptyOrNil ifTrue:[^self].	fieldName := fieldName asSymbol.	(aClass allVariableNames anySatisfy:[:varName| varName = fieldName]) ifTrue:[		(self confirm: 'A field named "', fieldName, '" already exists. Proceed?') ifFalse:[^nil].	].	toGet := fieldName.	toSet := (fieldName,':') asSymbol.	"Check for conflicting methods"	(aClass includesSelector: toGet) ifTrue:[		(self confirm: 'A method with the name "', toGet,'" already exists.Proceed?') ifFalse:[^self].	].	(aClass includesSelector: toSet) ifTrue:[		(self confirm: 'A method with the name "', toSet,'" already exists.Proceed?') ifFalse:[^self].	].	((aClass canUnderstand: toGet) or:[aClass canUnderstand: toSet]) ifTrue:[		| proceed |		proceed := self confirm: 'The definition of "', fieldName, '" will override \methods which have been defined \(but may be invisible) in this object.\Do you wish to proceed?' withCRs.		proceed ifFalse:[^nil].	].	aClass addField: fieldName.! !!Browser methodsFor: '*Tweak' stamp: 'ar 7/25/2003 13:50'!classListMenu: aMenu shifted: shifted	"Set up the menu to apply to the receiver's class list, honoring the #shifted boolean"	shifted		ifTrue:			[^ self shiftedClassListMenu: aMenu].	aMenu addList: #(		('add field'					addField)		-		('browse full (b)'			browseMethodFull)		('browse hierarchy (h)'		spawnHierarchy)		('browse protocol (p)'		browseFullProtocol)		-		('printOut'					printOutClass)		('fileOut'					fileOutClass)		-		('show hierarchy'			hierarchy)		('show definition'			editClass)		('show comment'			editComment)		-		('inst var refs...'			browseInstVarRefs)		('inst var defs...'			browseInstVarDefs)		-		('class var refs...'			browseClassVarRefs)		('class vars'					browseClassVariables)		('class refs (N)'				browseClassRefs)		-		('rename class ...'			renameClass)		('copy class'				copyClass)		('remove class (x)'			removeClass)		-		('find method...'				findMethod)		-		('more...'					offerShiftedClassListMenu)).	^ aMenu! !!Browser methodsFor: '*Tweak' stamp: 'ar 5/5/2004 23:33'!contents	"Depending on the current selection, different information is retrieved.	Answer a string description of that information. This information is the	method of the currently selected class and message."	| comment theClass latestCompiledMethod |	latestCompiledMethod _ currentCompiledMethod.	currentCompiledMethod _ nil.	editSelection == #none ifTrue: [^ ''].	editSelection == #editSystemCategories 		ifTrue: [^ systemOrganizer printString].	editSelection == #newClass 		ifTrue: [^ (theClass _ self selectedClass)			ifNil:				[Class template: self selectedSystemCategoryName]			ifNotNil:				[Class templateForSubclassOf: theClass category: self selectedSystemCategoryName]].	editSelection == #editClass 		ifTrue:			[^ (theClass _ self selectedClassOrMetaClass)				ifNil:					['']				ifNotNil:			 		[theClass browserDefinition: #default]].	editSelection == #editComment 		ifTrue:			[(theClass _ self selectedClass) ifNil: [^ ''].			comment _ theClass comment.			currentCompiledMethod _ theClass organization commentRemoteStr.			^ comment size = 0				ifTrue: ['This class has not yet been commented.']				ifFalse: [comment]].	editSelection == #hierarchy 		ifTrue: [^ self selectedClassOrMetaClass printHierarchy].	editSelection == #editMessageCategories 		ifTrue: [^ self classOrMetaClassOrganizer printString].	editSelection == #newMessage		ifTrue:			[^ (theClass _ self selectedClassOrMetaClass) 				ifNil: ['']				ifNotNil: [theClass sourceCodeTemplate]].	editSelection == #editMessage		ifTrue:			[self showingByteCodes ifTrue: [^ self selectedBytecodes].			currentCompiledMethod _ latestCompiledMethod.			^ self selectedMessage].	self error: 'Browser internal error: unknown edit selection.'! !!Browser methodsFor: '*Tweak' stamp: 'das 7/14/2002 08:02'!selectedMessage	"Answer a copy of the source code for the selected message."	| class selector method |	contents == nil ifFalse: [^ contents copy].	self showingDecompile ifTrue:		[^ self decompiledSourceIntoContents].	class _ self selectedClassOrMetaClass.	selector _ self selectedMessageName.	method _ class compiledMethodAt: selector ifAbsent: [^ ''].	"method deleted while in another project"	currentCompiledMethod _ method.	(method fileIndex > 0 and: [(SourceFiles at: method fileIndex) == nil])		ifTrue:		["Emergency or no source file -- decompile without temp names"		contents _ (class decompilerClass new decompile: selector in: class method: method)			decompileString.		contents _ contents asText makeSelectorBoldIn: class.		^ contents copy].	self showingDocumentation		ifFalse:			[contents _ self sourceStringPrettifiedAndDiffed]		ifTrue:			[contents _ self commentContents].	^ contents _ contents copy asText makeSelectorBoldIn: class! !!CBorder methodsFor: 'initialize'!releaseCachedState	"Release any associated cached state"! !!CBorder methodsFor: 'drawing'!drawLineFrom: startPoint to: stopPoint on: aCanvas	^aCanvas line: startPoint to: stopPoint width: self width color: self color! !!CBorder methodsFor: 'drawing'!frameOval: aRectangle on: aCanvas	"Frame the given rectangle on aCanvas"	aCanvas frameOval: aRectangle width: self width color: self color! !!CBorder methodsFor: 'drawing'!framePolygon: vertices on: aCanvas	"Frame the given rectangle on aCanvas"	self framePolyline: vertices on: aCanvas.	self drawLineFrom: vertices last to: vertices first on: aCanvas.! !!CBorder methodsFor: 'drawing'!framePolyline: vertices on: aCanvas	"Frame the given rectangle on aCanvas"	| prev next |	prev _ vertices at: 1.	2 to: vertices size do:[:i|		next _ vertices at: i.		self drawLineFrom: prev to: next on: aCanvas.		prev _ next].! !!CBorder methodsFor: 'drawing'!frameRectangle: aRectangle on: aCanvas	"Frame the given rectangle on aCanvas"	aCanvas frameRectangle: aRectangle width: self width color: self color! !!CBorder methodsFor: 'drawing' stamp: 'ar 6/8/2003 16:59'!frameRoundRect: aRectangle radius: radius on: aCanvas	"Frame the given rectangle on aCanvas"	aCanvas frameRoundRect: aRectangle radius: radius width: self width color: self color! !!CBorder methodsFor: 'accessing'!baseColor	^Color transparent! !!CBorder methodsFor: 'accessing'!baseColor: aColor	"Ignored"! !!CBorder methodsFor: 'accessing'!color	^Color transparent! !!CBorder methodsFor: 'accessing'!color: aColor	"Ignored"! !!CBorder methodsFor: 'accessing'!colorsAtCorners	^Array new: 4 withAll: self color! !!CBorder methodsFor: 'accessing'!dotOfSize: diameter forDirection: aDirection	| form |	form _ Form extent: diameter@diameter depth: Display depth.	form getCanvas fillOval: form boundingBox color: self color.	^form! !!CBorder methodsFor: 'accessing'!style	^#none! !!CBorder methodsFor: 'accessing'!width	^0! !!CBorder methodsFor: 'accessing' stamp: 'bf 3/30/2004 13:51'!width: aNumber	"Ignored"	^aNumber! !!CBorder methodsFor: 'accessing'!widthForRounding	^self width! !!CBorder methodsFor: 'testing'!isBorderStyle	^true! !!CBorder methodsFor: 'testing'!isComplex	^false! !!CBorder methodsFor: 'comparing'!= aCBorder	^self species = aCBorder species		and:[self style == aCBorder style		and:[self width = aCBorder width		and:[self color = aCBorder color]]].! !!CBorder methodsFor: 'comparing'!hash	"hash is implemented because #= is implemented"	^self species hash bitXor: (self width hash bitXor: self color hash)! !!CBorder methodsFor: 'converting'!asBorder	^self! !!CBorder methodsFor: 'color tracking'!trackColorFrom: aCostume	"If necessary, update our color to reflect a change in aCostumes color"! !!CClipboard methodsFor: 'primitives' stamp: 'ar 12/17/2002 15:23'!primitiveClipboardAt: formatName	"Answer the contents of the OS clipboard with the given format name"	<primitive: 'primitiveClipboardAt' module: 'ClipboardPlugin'>	^nil! !!CClipboard methodsFor: 'primitives' stamp: 'ar 12/17/2002 15:23'!primitiveClipboardAt: formatName put: bytes	"Set the contents of the OS clipboard with the given format name"	<primitive: 'primitiveClipboardPut' module: 'ClipboardPlugin'>	^nil! !!CClipboard methodsFor: 'primitives' stamp: 'ar 12/17/2002 15:26'!primitiveClipboardChanged	"Answer whether the contents of the OS clipboard has changed.	If supported, the primitive will answer true if the contents changed	since the LAST TIME THIS PRIMITIVE WAS INVOKED."	<primitive: 'primitiveClipboardChanged' module: 'ClipboardPlugin'>	^false "if not supported assume no changes"! !!CClipboard methodsFor: 'primitives' stamp: 'ar 12/17/2002 15:26'!primitiveClipboardClear	"Primitive. Clear the OS clipboard."	<primitive: 'primitiveClipboardClear' module: 'ClipboardPlugin'>	^nil! !!CClipboard methodsFor: 'primitives' stamp: 'ar 12/17/2002 15:26'!primitiveClipboardFormat: index	"Answer a textual representation of the clipboard format with the given index 	(starting at one)."	<primitive: 'primitiveClipboardFormat' module: 'ClipboardPlugin'>	^nil! !!CClipboard methodsFor: 'primitives' stamp: 'ar 12/17/2002 15:34'!primitiveClipboardPresent	"Answer whether primitive support for clipboard exchange with the OS exists"	<primitive: 'primitiveClipboardPresent' module: 'ClipboardPlugin'>	^false! !!CClipboard methodsFor: 'initialize' stamp: 'ar 12/17/2002 15:43'!clipboardClear	contents := OrderedCollection new.	self primitiveClipboardClear.	self primitiveClipboardText: ''.! !!CClipboard methodsFor: 'initialize' stamp: 'ar 12/17/2002 15:21'!initialize	self clipboardClear.! !!CClipboard methodsFor: 'accessing' stamp: 'ar 7/25/2003 23:40'!clipboardAt: formatName	"Answer the clipboard contents for the given format name."	| data s |	data := self primitiveClipboardAt: formatName.	data ifNil:[data := self contentsAt: formatName].	formatName = 'Squeak Text' ifTrue:[		s _ self primitiveClipboardText.		data ifNil:[^s].		(s isEmpty or: [s = data asString])			ifTrue: [^ data]			ifFalse: [^ s asText]	].	^data! !!CClipboard methodsFor: 'accessing' stamp: 'ar 12/17/2002 15:38'!clipboardAt: formatName put: bytes	"Set the contents of the clipboard for the specified format name"	self primitiveClipboardAt: formatName put: bytes.	self contentsAt: formatName put: bytes.	formatName = 'Squeak Text' ifTrue:[		self primitiveClipboardAt: formatName put: bytes asString.		self primitiveClipboardText: bytes asString.	].! !!CClipboard methodsFor: 'accessing' stamp: 'ar 12/17/2002 15:35'!clipboardFormats	| index format |	^Array streamContents:[:s|		self primitiveClipboardPresent ifTrue:[			index := 0.			[format := self primitiveClipboardFormat: (index := index+1).			format == nil] whileFalse:[s nextPut: format].		] ifFalse:[			contents do:[:assoc| s nextPut: assoc key].		].	].! !!CClipboard methodsFor: 'accessing' stamp: 'ar 12/17/2002 15:27'!clipboardText	"Return the text currently in the clipboard. If the system clipboard is empty, or if it differs from the Smalltalk clipboard text, use the Smalltalk clipboard. This is done since (a) the Mac clipboard gives up on very large chunks of text and (b) since not all platforms support the notion of a clipboard."	^self clipboardAt: 'Squeak Text'! !!CClipboard methodsFor: 'accessing' stamp: 'ar 12/17/2002 15:28'!clipboardText: text	"Set text currently on the clipboard.  Also export to OS"	self clipboardClear.	self clipboardAt: 'Squeak Text' put: text! !!CClipboard methodsFor: 'private' stamp: 'ar 12/17/2002 15:37'!contentsAt: format	^(contents detect:[:any| any key = format] ifNone:[^nil]) value! !!CClipboard methodsFor: 'private' stamp: 'ar 12/17/2002 15:37'!contentsAt: format put: value	contents add: format->value! !!CClipboard methodsFor: 'private' stamp: 'ar 7/25/2003 23:40'!primitiveClipboardText	"Get the current clipboard text. Return the empty string if the primitive fails."	<primitive: 141>	^ ''! !!CClipboard methodsFor: 'private' stamp: 'ar 12/17/2002 15:33'!primitiveClipboardText: aString	"Set the current clipboard text to the given string."	<primitive: 141>	"don't fail if the primitive is not implemented"! !!CComponentBinding methodsFor: 'accessing' stamp: 'ar 3/15/2004 20:14'!home	^home! !!CComponentBinding methodsFor: 'accessing' stamp: 'ar 3/15/2004 21:19'!home: anObject	home ifNotNil:[^self error: 'Cannot change home'].	anObject == value ifTrue:[^self error:'Invalid ownership relation'].	home := anObject.! !!CComponentBinding methodsFor: 'accessing' stamp: 'ar 3/15/2004 20:14'!name	^home name,'''s ', key! !!CComponentBinding methodsFor: 'accessing' stamp: 'ar 3/15/2004 21:19'!value: aValue	value == aValue ifTrue:[^value].	aValue == home ifTrue:[^self error:'Invalid ownership relation'].	aValue componentBinding: self.	^value := aValue! !!CComponentBinding methodsFor: 'testing' stamp: 'ar 3/15/2004 20:58'!isComponentBinding	^true! !!CComponentBinding methodsFor: 'printing' stamp: 'ar 3/15/2004 20:14'!printOn: aStream	home printOn: aStream.	aStream nextPutAll:'''s '; nextPutAll: key asString.	aStream nextPutAll:' -> '; print: value.! !!CComponentBinding methodsFor: '*Tweak-Tweaks' stamp: 'ar 3/15/2004 20:34'!tweakedComponent: aComponent	aComponent == value ifFalse:[^self error:'We *really* screwed up'].	home tweaked: key from: value to: value.! !!CCornerRounder methodsFor: 'all' stamp: 'ar 12/8/2002 01:56'!masterMask: maskForm masterOverlay: overlayForm	cornerMasks _ #(none left pi right) collect:		[:dir | (maskForm rotateBy: dir centerAt: 0@0) offset: 0@0].	cornerOverlays _ #(none left pi right) collect:		[:dir | (overlayForm rotateBy: dir centerAt: 0@0) offset: 0@0].! !!CCornerRounder methodsFor: 'all' stamp: 'ar 12/8/2002 01:56'!saveBitsUnderCornersOf: aMorph on: aCanvas in: bounds corners: cornerList	| offset corner mask form corners rect |	underBits _ Array new: 4.	corners _ bounds corners.	cornerList do:[:i|		mask _ cornerMasks at: i.		corner _ corners at: i.		i = 1 ifTrue: [offset _ 0@0].		i = 2 ifTrue: [offset _ 0@mask height negated].		i = 3 ifTrue: [offset _ mask extent negated].		i = 4 ifTrue: [offset _ mask width negated@0].		rect _ corner + offset extent: mask extent.		(aCanvas isVisible: rect) ifTrue:[			form _ aCanvas contentsOfArea: rect.			form copyBits: form boundingBox from: mask at: 0@0 clippingBox: form boundingBox rule: Form and fillColor: nil map: (Bitmap with: 16rFFFFFFFF with: 0).			underBits at: i put: form]].! !!CCornerRounder methodsFor: 'all' stamp: 'ar 12/8/2002 01:57'!tweakCornersOf: aMorph on: aCanvas in: bounds borderWidth: w corners: cornerList	"This variant has a cornerList argument, to allow some corners to be rounded and others not"	| offset corner saveBits fourColors mask outBits shadowColor corners |	shadowColor _ aCanvas shadowColor.	aCanvas shadowColor: nil. "for tweaking it's essential"	w > 0 ifTrue:[			fourColors _ shadowColor 				ifNil:[aMorph border colorsAtCorners]				ifNotNil:[Array new: 4 withAll: shadowColor]].	mask _ Form extent: cornerMasks first extent depth: aCanvas depth.	corners _ bounds corners.	cornerList do:[:i|		corner _ corners at: i.		saveBits _ underBits at: i.		saveBits ifNotNil:[			i = 1 ifTrue: [offset _ 0@0].			i = 2 ifTrue: [offset _ 0@saveBits height negated].			i = 3 ifTrue: [offset _ saveBits extent negated].			i = 4 ifTrue: [offset _ saveBits width negated@0].			"Mask out corner area (painting saveBits won't clear if transparent)."			mask copyBits: mask boundingBox from: (cornerMasks at: i) at: 0@0 clippingBox: mask boundingBox rule: Form over fillColor: nil map: (Bitmap with: 0 with: 16rFFFFFFFF).			outBits _ aCanvas contentsOfArea: (corner + offset extent: mask extent).			mask displayOn: outBits at: 0@0 rule: Form and.			"Paint back corner bits."			saveBits displayOn: outBits at: 0@0 rule: Form paint.			"Paint back corner bits."			aCanvas drawImage: outBits at: corner + offset.			w > 0 ifTrue:[				"Paint over with border if any"				aCanvas stencil: (cornerOverlays at: i) at: corner + offset						color: (fourColors at: i)]]].	aCanvas shadowColor: shadowColor. "restore shadow color"! !!CCostumePen methodsFor: 'accessing'!color	^color! !!CCostumePen methodsFor: 'accessing' stamp: 'bf 3/30/2004 11:17'!color: newColor	^ color := newColor.! !!CCostumePen methodsFor: 'accessing'!isDown	^isDown! !!CCostumePen methodsFor: 'accessing' stamp: 'bf 3/30/2004 11:17'!isDown: aBool	^ isDown := aBool! !!CCostumePen methodsFor: 'accessing'!moveFrom: lastPt to: nextPt	| prevPt |	isDown ifFalse:[^self].	lastPt = nextPt ifTrue:[^self].	(points size > 0 and:[points last = lastPt]) ifFalse:[points add: lastPt].	points size >  1 ifTrue:[		"see if we're just extending the current stroke"		prevPt := points at: points size - 1.		((prevPt x - lastPt x) * (nextPt y * lastPt y)) - 			((prevPt y - lastPt y) * (nextPt x - lastPt x)) = 0 				ifTrue:[points at: points size put: nextPt]				ifFalse:[points add: nextPt].	] ifFalse:[points add: nextPt].	pathLength := pathLength + (lastPt dist: nextPt).! !!CCostumePen methodsFor: 'accessing'!width	^width! !!CCostumePen methodsFor: 'accessing' stamp: 'bf 3/30/2004 10:45'!width: newWidth	^width := newWidth! !!CCostumePen methodsFor: 'initialize'!defaultColor	^self class defaultColor! !!CCostumePen methodsFor: 'initialize'!defaultWidth	^self class defaultWidth! !!CCostumePen methodsFor: 'initialize'!initialize	color := self defaultColor.	width := self defaultWidth.	pathLength := 0.	isDown := false.	points := OrderedCollection new.! !!CCostumePen methodsFor: 'drawing'!drawOn: aCanvas	| lastPt |	lastPt := nil.	points do:[:nextPt|		lastPt ifNotNil:[aCanvas line: lastPt to: nextPt width: width color: color].		lastPt := nextPt.	].! !!CDamageRecorder methodsFor: 'testing'!hasDamageInRect: aRectangle	"Answer if there is any pending damage in the rectangle"	totalRepaint ifTrue:[^true]. "oh yes"	1 to: invalidRects size do:[:i|		((invalidRects at: i) intersects: aRectangle) ifTrue:[^true].	].	^false! !!CDamageRecorder methodsFor: 'testing'!updateIsNeeded	"Return true if the display needs to be updated."	^ totalRepaint or: [invalidRects size > 0]! !!CDamageRecorder methodsFor: 'recording' stamp: 'ar 8/17/2003 19:10'!areaMerged: rect1 with: rect2	"very much unoptimized"	^(rect1 merge: rect2) area	! !!CDamageRecorder methodsFor: 'recording'!doFullRepaint	"Record that a full redisplay is needed. No further damage rectangles will be recorded until after the next reset."	^ totalRepaint _ true.! !!CDamageRecorder methodsFor: 'recording'!invalidRectsFullBounds: aRectangle	"Return a collection of damaged rectangles for the given canvas. If a total repaint has been requested, return the given rectangle."	totalRepaint		ifTrue: [^ Array with: aRectangle]		ifFalse: [^ invalidRects copy].! !!CDamageRecorder methodsFor: 'recording'!invalidate	"Record that a full redisplay is needed. No further damage rectangles will be recorded until after the next reset."	^ totalRepaint _ true.! !!CDamageRecorder methodsFor: 'recording' stamp: 'ar 8/17/2003 20:01'!invalidate: newRect	"Record the given rectangle in my damage list, a list of rectangular areas of the display that should be redraw on the next display cycle."	"Details: Damaged rectangles are often identical or overlap significantly. In these cases, we merge them to reduce the number of damage rectangles that must be processed when the display is updated. Moreover, above a certain threshold, we ignore the individual rectangles completely, and simply do a complete repaint on the next cycle."	| mergeRect a |true ifTrue:[^self recordInvalidRect2: newRect].	totalRepaint ifTrue: [^ self].  "planning full repaint; don't bother collecting damage"	invalidRects do:		[:rect |		((a _ (rect intersect: newRect) area) > 40			and: ["Avoid combining a vertical and horizontal rects.				  Can make a big diff and we only test when likely."				  a > (newRect area // 4) or: [a > (rect area // 4)]])			ifTrue:			["merge rectangle in place (see note below) if there is significant overlap"			rect setOrigin: (rect origin min: newRect origin) truncated				corner: (rect corner max: newRect corner) truncated.			^ self]].	invalidRects size >= 15 ifTrue:		["if there are too many separate areas, merge them all"		mergeRect _ Rectangle merging: invalidRects.		self reset.		invalidRects addLast: mergeRect].	"add the given rectangle to the damage list"	"Note: We make a deep copy of all rectangles added to the damage list,		since rectangles in this list may be extended in place."	invalidRects addLast:		(newRect topLeft truncated corner: newRect bottomRight truncated).! !!CDamageRecorder methodsFor: 'recording' stamp: 'ar 8/17/2003 19:10'!recordInvalidRect2: aRectangle	"Record the given rectangle in my damage list, a list of rectangular areas of the display that should be redraw on the next display cycle."	"Details: Damaged rectangles are often identical or overlap significantly. In these cases, we merge them to reduce the number of damage rectangles that must be processed when the display is updated."	| rectToMerge matchIndex acceptingRect |	totalRepaint ifTrue: [^ self].  "planning full repaint; don't bother collecting damage"	"if the new rectangle is contained by any existing damage, ignore it"	invalidRects do: [:rect |		(rect containsRect: aRectangle) ifTrue: [^self]].	"Add the new rectangle as new damage if there is no existing damage that it would profitable to merge it with. Note the arbitrary parameter (10000) which should model the overhead of starting another rectangle and of maintaining this rectangle until drawing time. If an old rectangle swallows the new one and is thus changed, remove it and try to merge it with the other oldies."	rectToMerge _ aRectangle.	[matchIndex _ invalidRects findFirst: [:r | (self areaMerged: r with: rectToMerge) <= (r area + rectToMerge area + 10000)].	(matchIndex = 0)] whileFalse: [acceptingRect _ (invalidRects at: matchIndex).			acceptingRect setOrigin: (acceptingRect origin min: rectToMerge origin) truncated				corner: (acceptingRect corner max: rectToMerge corner) truncated.			invalidRects removeAt: matchIndex.			rectToMerge _ acceptingRect.].		"Eventually some rectangle will not want to match with any other remaining damage (this may be because it's now empty). Add it (back?) to the list."	"Note: We make a deep copy of all rectangles added to the damage list,	 since rectangles in this list may be extended in place."	invalidRects addLast: (rectToMerge topLeft truncated corner: rectToMerge bottomRight truncated).! !!CDamageRecorder methodsFor: 'recording' stamp: 'ar 8/17/2003 19:55'!recordInvalidRect: aRectangle	"Record the given rectangle in my damage list, a list of rectangular areas of the display that should be redraw on the next display cycle."	"Details: Damaged rectangles are often identical or overlap significantly. In these cases, we merge them to reduce the number of damage rectangles that must be processed when the display is updated. Moreover, above a certain threshold, we ignore the individual rectangles completely, and simply do a complete repaint on the next cycle."	| mergeRect a newRect |	totalRepaint ifTrue: [^ self].  "planning full repaint; don't bother collecting damage"	newRect := aRectangle origin truncated corner: aRectangle corner ceiling.	invalidRects do:[:rect |		((a _ (rect intersect: newRect) area) > 400			and: ["Avoid combining a vertical and horizontal rects.				  Can make a big diff and we only test when likely."				  a > (newRect area // 4) or: [a > (rect area // 4)]])			ifTrue:			["merge rectangle in place (see note below) if there is significant overlap"			rect setOrigin: (rect origin min: newRect origin)				corner: (rect corner max: newRect corner).			^ self]].true ifTrue:[	invalidRects size >= 100 ifTrue:		["if there are too many separate areas, merge them all"		mergeRect _ Rectangle merging: invalidRects.		self reset.		invalidRects addLast: mergeRect].].	"add the given rectangle to the damage list"	"Note: We make a deep copy of all rectangles added to the damage list,		since rectangles in this list may be extended in place."	invalidRects addLast:		(newRect topLeft corner: newRect bottomRight).! !!CDamageRecorder methodsFor: 'initialization'!reset	"Clear the damage list."	invalidRects _ OrderedCollection new: 15.	totalRepaint _ false! !!CDeserializer methodsFor: 'interface' stamp: 'ar 10/16/2003 13:05'!deserialize: data	^self readField: #root ifAbsent:[nil]! !!CDeserializer methodsFor: 'interface' stamp: 'ar 2/22/2004 03:52'!fieldsDo: aBlock	"Evaluate aBlock with all of the field names available in the receiver"	^self subclassResponsibility! !!CDeserializer methodsFor: 'interface' stamp: 'ar 9/24/2003 18:44'!readField: aFieldName	"Answer the value of the given field name"	^self readField: aFieldName ifAbsent:[nil]! !!CDeserializer methodsFor: 'interface' stamp: 'ar 9/22/2003 01:07'!readField: aFieldName ifAbsent: aBlock	"Answer the value of the given field name"	^self subclassResponsibility! !!CDeserializer methodsFor: 'initialize' stamp: 'ar 9/24/2003 18:47'!initialize! !!CDeserializer methodsFor: 'deprecated' stamp: 'ar 9/24/2003 18:46'!undefinedToken	^nil! !!CDisplayTransform methodsFor: 'transforming rects'!globalBoundsToLocal: aRectangle	"Transform aRectangle from global coordinates into local coordinates"	^Rectangle encompassing: (self globalPointsToLocal: aRectangle corners)! !!CDisplayTransform methodsFor: 'transforming rects'!localBoundsToGlobal: aRectangle	"Transform aRectangle from local coordinates into global coordinates"	^Rectangle encompassing: (self localPointsToGlobal: aRectangle corners)! !!CDisplayTransform methodsFor: 'transforming rects'!sourceQuadFor: aRectangle	^ aRectangle innerCorners collect: 		[:p | self globalPointToLocal: p]! !!CDisplayTransform methodsFor: 'testing'!isIdentity	"Return true if the receiver is the identity transform; that is, if applying to a point returns the point itself."	^self subclassResponsibility! !!CDisplayTransform methodsFor: 'testing'!isMatrixTransform2x3	"Return true if the receiver is 2x3 matrix transformation"	^false! !!CDisplayTransform methodsFor: 'testing'!isNoRotationWithin: bounds	"Return true if the receiver has no rotation within the given bounds"	| p0 p1 p2 |	p0 _ self localPointToGlobal: bounds topLeft.	p1 _ self localPointToGlobal: bounds topRight.	p0 y truncated = p1 y truncated ifFalse:[^false].	p0 x <= p1 x ifFalse:[^false].	p2 _ self localPointToGlobal: bounds bottomLeft.	p0 x truncated = p2 x truncated ifFalse:[^false].	p0 y <= p1 y ifFalse:[^false].	^true! !!CDisplayTransform methodsFor: 'testing'!isNoTransformWithin: aRectangle	"Return true if the receiver represents no transformation within the given bounding rectangle. This method basically determines if the receiver should be seen as a pure translation for the purposes of drawing in the given rectangle."	| pt1 pt2 pDelta rDelta |	pt1 _ self localPointToGlobal: aRectangle origin.	pt2 _ self localPointToGlobal: aRectangle corner.	pDelta _ pt2 asIntegerPoint - pt1 asIntegerPoint.	rDelta _ aRectangle corner asIntegerPoint - aRectangle origin asIntegerPoint.	^rDelta = pDelta! !!CDisplayTransform methodsFor: 'testing'!isPureTranslation	"Return true if the receiver specifies no rotation or scaling."	^self subclassResponsibility! !!CDisplayTransform methodsFor: 'transforming'!invertPoint: aPoint	^self globalPointToLocal: aPoint! !!CDisplayTransform methodsFor: 'transforming'!invertRect: aRectangle	^self globalBoundsToLocal: aRectangle! !!CDisplayTransform methodsFor: 'transforming'!transformPoint: aPoint	^self localPointToGlobal: aPoint! !!CDisplayTransform methodsFor: 'transforming'!transformRect: aRectangle	^self localBoundsToGlobal: aRectangle! !!CDisplayTransform methodsFor: 'transforming'!transformedBy: aTransform	^self composedWithGlobal: aTransform! !!CDisplayTransform methodsFor: 'transforming points'!globalPointToLocal: aPoint	"Transform aPoint from global coordinates into local coordinates"	^self subclassResponsibility! !!CDisplayTransform methodsFor: 'transforming points'!globalPointsToLocal: inArray	"Transform all the points of inArray from global into local coordinates"	^inArray collect:[:pt| self globalPointToLocal: pt]! !!CDisplayTransform methodsFor: 'transforming points'!invertBoundsRect: aRectangle	"Return a rectangle whose coordinates have been transformed	from local back to global coordinates."	^self subclassResponsibility! !!CDisplayTransform methodsFor: 'transforming points'!localPointToGlobal: aPoint	"Transform aPoint from local coordinates into global coordinates"	^self subclassResponsibility! !!CDisplayTransform methodsFor: 'transforming points'!localPointsToGlobal: inArray	"Transform all the points of inArray from local into global coordinates"	^inArray collect:[:pt| self localPointToGlobal: pt]! !!CDisplayTransform methodsFor: 'initialize'!setIdentity	"Initialize the receiver to the identity transformation (e.g., not affecting points)"	^self subclassResponsibility! !!CDisplayTransform methodsFor: 'converting'!asMatrixTransform2x3	"Represent the receiver as a 2x3 matrix transformation"	^self subclassResponsibility! !!CDisplayTransform methodsFor: 'accessing'!inverseTransformation	"Return the inverse transformation of the receiver"	^self subclassResponsibility! !!CDisplayTransform methodsFor: 'accessing' stamp: 'ar 6/9/2003 00:07'!warpCellSize	^1! !!CDisplayTransform methodsFor: 'composing'!composedWithGlobal: aTransformation	"Return the composition of the receiver and the global transformation passed in.	A 'global' transformation is defined as a transformation that takes place	between the receiver (the 'local') transformation and any 'global' point	computations, e.g., for the methods		globalPointToLocal: globalPoint			globalPoint -> globalTransform -> localTransform -> locaPoint		localPointToGlobal: localPoint			localPoint -> localTransform -> globalTransform -> globalPoint		"	^aTransformation composedWithLocal: self! !!CDisplayTransform methodsFor: 'composing'!composedWithLocal: aTransformation	"Return the composition of the receiver and the local transformation passed in.	A 'local' transformation is defined as a transformation that takes place	between the receiver (the 'global') transformation and any 'local' point	computations, e.g., for the methods		globalPointToLocal: globalPoint			globalPoint -> globalTransform -> localTransform -> locaPoint		localPointToGlobal: localPoint			localPoint -> localTransform -> globalTransform -> globalPoint		"	self isIdentity ifTrue:[^ aTransformation].	aTransformation isIdentity ifTrue:[^ self].	^self asMatrixTransform2x3 composedWithLocal: aTransformation asMatrixTransform2x3! !!CFormCache methodsFor: 'accessing' stamp: 'ar 1/28/2003 00:26'!damageRecorder	^damageRecorder! !!CFormCache methodsFor: 'accessing'!form	^form! !!CFormCache methodsFor: 'accessing' stamp: 'ar 1/28/2003 00:31'!form: aForm	form _ aForm.	damageRecorder doFullRepaint.! !!CFormCache methodsFor: 'accessing'!isValid	^valid! !!CFormCache methodsFor: 'accessing'!isValid: aBool	valid _ aBool! !!CFormCache methodsFor: 'invalidating' stamp: 'ar 8/17/2003 19:16'!invalidate: aRectangle	damageRecorder invalidate: aRectangle.	valid := false.! !!CFormCache methodsFor: 'initialize' stamp: 'ar 1/28/2003 02:03'!initialize	valid := false.	damageRecorder := CDamageRecorder new.	damageRecorder doFullRepaint.! !!CFormCache methodsFor: 'initialize'!release	"Flush the cache"	form := nil.! !!CFormCache methodsFor: 'drawing' stamp: 'ar 1/28/2003 03:03'!drawCached: aBlock on: aCanvas in: bounds	(valid and:[form notNil and:[form extent = bounds extent and:[form depth = aCanvas depth]]])		ifTrue:[^aCanvas paintImage: form at: bounds origin].	(form == nil or:[form extent ~= bounds extent or:[form depth ~= aCanvas depth]]) ifTrue:[		form := nil.		form := Form extent: bounds extent depth: aCanvas depth.		damageRecorder doFullRepaint.	].	self repairDamage: bounds using: aBlock.	valid := true.	aCanvas paintImage: form at: bounds origin.! !!CFormCache methodsFor: 'drawing' stamp: 'ar 1/28/2003 04:03'!repairDamage: bounds using: drawingBlock	| myCanvas rectList validList rectToFill |	damageRecorder updateIsNeeded ifFalse:[^#()].	myCanvas := CTransformCanvas on: form.	myCanvas transformBy: (COffsetTransform withOffset: bounds origin negated).	rectList := damageRecorder invalidRectsFullBounds: bounds.	"sort by areas to draw largest portions first"	rectList := rectList asArray sort:[:r1 :r2| r1 area > r2 area].	damageRecorder reset.	validList := OrderedCollection new: rectList size.	rectToFill := nil.	rectList do: [:dirtyRect |		dirtyRect allAreasOutsideList: validList do:[:r| 			rectToFill 				ifNil:[rectToFill := r copy]				ifNotNil:[rectToFill := rectToFill quickMerge: r].			validList add: r]].	rectToFill ifNotNil:[		validList do:[:rect|			myCanvas clipBy: rect during:[:cc| 				cc fillColor: Color transparent.				drawingBlock value: cc].		].	].	myCanvas finish.	^validList! !!CGraphicsFill methodsFor: 'testing'!isBitmapFill	^false! !!CGraphicsFill methodsFor: 'testing'!isGradientFill	^false! !!CGraphicsFill methodsFor: 'testing'!isOrientedFill	"Return true if the receiver keeps an orientation (e.g., origin, direction, and normal)"	^false! !!CGraphicsFill methodsFor: 'testing'!isSolidFill	^false! !!CGraphicsFill methodsFor: 'testing'!isTranslucent	^true "Since we don't know better"! !!CGraphicsFill methodsFor: 'testing'!isTransparent	^false! !!CGraphicsFill methodsFor: 'accessing'!scaledPixelValue32	"Return a pixel value of depth 32 for the primary color in the fill style"	^self asColor scaledPixelValue32! !!CGraphicsFill methodsFor: 'converting'!asB3DColor	^self asColor asB3DColor! !!CGraphicsFill methodsFor: 'converting'!asColor	^self subclassResponsibility! !!CGraphicsFill methodsFor: 'converting'!mixed: fraction with: aColor	^self asColor mixed: fraction with: aColor! !!CGraphicsShape methodsFor: 'testing' stamp: 'ar 6/8/2003 21:38'!containsPoint: aPoint in: box	"Answer whether the receiver contains the given point"! !!CGraphicsShape methodsFor: 'drawing' stamp: 'ar 6/8/2003 21:35'!drawShapeOn: aCanvas in: drawingBounds fill: aFill border: aBorder	"draw the receiver's shape on aCanvas"! !!CIconLibrary methodsFor: 'accessing' stamp: 'ar 12/8/2002 02:49'!at: iconName	^icons at: iconName ifAbsent:[Form extent: 10@10 depth: 1]! !!CIconLibrary methodsFor: 'accessing'!icons	^icons! !!CIconLibrary methodsFor: 'initialize'!initialize	icons := Dictionary new.! !!CIconLibrary methodsFor: 'initialize'!loadDefaultIcons	self loadIconsFrom:		(((FileDirectory default 			directoryNamed: 'SqueakScript') 			directoryNamed: 'UI') 			directoryNamed: 'icons').! !!CIconLibrary methodsFor: 'initialize'!loadIconsFrom: dir	| file iconName form |	dir fileNames do:[:fName|		iconName := fName copyFrom: 1 to: (fName lastIndexOf: $. ifAbsent:[fName size+1])-1.		[file := dir readOnlyFileNamed: fName.		form := ImageReadWriter formFromStream: file.		] on: Error do:[:ex| ex return].		form ifNotNil:[icons at: iconName asSymbol put: form].	].! !!CIdentityTransform methodsFor: 'transforming points'!globalPointToLocal: aPoint	"Transform aPoint from global coordinates into local coordinates"	^aPoint! !!CIdentityTransform methodsFor: 'transforming points'!globalPointsToLocal: inArray	"Transform all the points of inArray from global into local coordinates"	^inArray! !!CIdentityTransform methodsFor: 'transforming points'!invertBoundsRect: aRectangle	"Return a rectangle whose coordinates have been transformed	from local back to global coordinates. Since I am the identity matrix	no transformation is made."	^aRectangle! !!CIdentityTransform methodsFor: 'transforming points'!localPointToGlobal: aPoint	"Transform aPoint from local coordinates into global coordinates"	^aPoint! !!CIdentityTransform methodsFor: 'transforming points'!localPointsToGlobal: inArray	"Transform all the points of inArray from local into global coordinates"	^inArray! !!CIdentityTransform methodsFor: 'composing'!composedWith: aTransform	^aTransform! !!CIdentityTransform methodsFor: 'composing'!composedWithGlobal: aTransformation	^aTransformation! !!CIdentityTransform methodsFor: 'composing'!composedWithLocal: aTransformation	^aTransformation! !!CIdentityTransform methodsFor: 'transforming rects'!globalBoundsToLocal: aRectangle	"Transform aRectangle from global coordinates into local coordinates"	^aRectangle! !!CIdentityTransform methodsFor: 'transforming rects'!localBoundsToGlobal: aRectangle	"Transform aRectangle from local coordinates into global coordinates"	^aRectangle! !!CIdentityTransform methodsFor: 'transforming rects'!sourceQuadFor: aRectangle	^ aRectangle innerCorners! !!CIdentityTransform methodsFor: 'accessing'!angle	^ 0.0! !!CIdentityTransform methodsFor: 'accessing'!inverseTransformation	"Return the inverse transformation of the receiver"	^self! !!CIdentityTransform methodsFor: 'accessing'!offset	^0@0! !!CIdentityTransform methodsFor: 'testing'!isIdentity	"Return true if the receiver is the identity transform; that is, if applying to a point returns the point itself."	^true! !!CIdentityTransform methodsFor: 'testing'!isPureTranslation	"Return true if the receiver specifies no rotation or scaling."	^true! !!CIdentityTransform methodsFor: 'initialize'!setIdentity	"I *am* the identity transform"	^self! !!CIdentityTransform methodsFor: 'converting'!asMatrixTransform2x3	"Represent the receiver as a 2x3 matrix transformation"	^CMatrixTransform identity! !!CKeyboardDispatchTable methodsFor: 'initialize'!initialize	metaTable := Array new: 16.! !!CKeyboardDispatchTable methodsFor: 'accessing' stamp: 'ar 3/24/2004 01:14'!add: keySpec action: eventName	| state |	state := self analyze: keySpec.	self bind: state last to: eventName metaState: state first.! !!CKeyboardDispatchTable methodsFor: 'accessing' stamp: 'ar 3/24/2004 03:27'!addAll: specList	specList do:[:each| self add: each first action: each last].! !!CKeyboardDispatchTable methodsFor: 'accessing' stamp: 'ar 3/24/2004 01:17'!isEmpty	^metaTable allSatisfy:[:each| each isEmptyOrNil].! !!CKeyboardDispatchTable methodsFor: 'accessing'!lookupEvent: anEvent	"Look up any associated short cut for the given event"	| metaState character |	metaState := anEvent metaState.	character := anEvent keyCharacter.	^self lookup: character meta: metaState! !!CKeyboardDispatchTable methodsFor: 'accessing' stamp: 'ar 3/24/2004 01:16'!remove: keySpec	| state |	state := self analyze: keySpec.	self remove: state last meta: state first.! !!CKeyboardDispatchTable methodsFor: 'private' stamp: 'ar 3/24/2004 01:21'!analyze: keySpec	| char meta modifier bit |	keySpec class == Character 		ifTrue:[^Array with: 0 with: keySpec].	keySpec last isInteger ifTrue:[		char := Character value: keySpec last.	] ifFalse:[		(keySpec size < 1 or:[keySpec last size ~= 1]) 			ifTrue:[^self error: 'Character expected'].		char := keySpec last first.	].	meta := 0.	1 to: keySpec size - 1 do:[:i|		modifier := keySpec at: i.		bit := #(shift ctrl opt cmd) indexOf: modifier asLowercase.		modifier = 0 ifTrue:[self error:'Unknown modifier: ', modifier].		meta := meta bitOr: (1 bitShift: bit-1).	].	^Array with: meta with: char! !!CKeyboardDispatchTable methodsFor: 'private'!bind: aCharacter to: anObject metaState: metaState	"Install a character binding"	| dispatchTable metaIndex |	metaIndex := metaState + 1.	dispatchTable := metaTable at: metaIndex.	dispatchTable ifNil:[		dispatchTable := IdentityDictionary new.		metaTable at: metaIndex put: dispatchTable].	anObject isNil ifTrue:[		dispatchTable removeKey: aCharacter ifAbsent:[].		dispatchTable isEmpty ifTrue:[metaTable at: metaIndex put: nil].	] ifFalse:[		dispatchTable at: aCharacter put: anObject.	].! !!CKeyboardDispatchTable methodsFor: 'private' stamp: 'ar 3/24/2004 01:26'!lookup: aCharacter meta: metaState	| metaIndex dispatchTable |	metaIndex := metaState + 1.	"First look up modified entry"	dispatchTable := metaTable at: metaIndex.	^dispatchTable ifNotNil:[dispatchTable at: aCharacter ifAbsent:[nil]].! !!CKeyboardDispatchTable methodsFor: 'private' stamp: 'ar 3/24/2004 01:15'!remove: aCharacter meta: metaState	| metaIndex dispatchTable |	metaIndex := metaState + 1.	"First look up modified entry"	dispatchTable := metaTable at: metaIndex.	^dispatchTable ifNotNil:[dispatchTable removeKey: aCharacter ifAbsent:[nil]].! !!CLayoutCell methodsFor: 'collection'!do: aBlock	aBlock value: self.	nextCell ifNotNil:[nextCell do: aBlock].! !!CLayoutCell methodsFor: 'collection'!inject: thisValue into: binaryBlock		 	"Accumulate a running value associated with evaluating the argument, 	binaryBlock, with the current value of the argument, thisValue, and the 	receiver as block arguments. For instance, to sum the numeric elements 	of a collection, aCollection inject: 0 into: [:subTotal :next | subTotal + 	next]."	| nextValue |	nextValue _ thisValue.	self do: [:each | nextValue _ binaryBlock value: nextValue value: each].	^nextValue! !!CLayoutCell methodsFor: 'collection'!size	| n cell |	n _ 0.	cell _ self.	[cell == nil] whileFalse:[		n _ n + 1.		cell _ cell nextCell].	^n! !!CLayoutCell methodsFor: 'accessing'!addExtraSpace: aPoint	extraSpace 		ifNil:[extraSpace _ aPoint]		ifNotNil:[extraSpace _ extraSpace + aPoint]! !!CLayoutCell methodsFor: 'accessing'!cellSize	^cellSize! !!CLayoutCell methodsFor: 'accessing'!cellSize: aPoint	cellSize _ aPoint! !!CLayoutCell methodsFor: 'accessing'!extraSpace	^extraSpace ifNil:[0@0]! !!CLayoutCell methodsFor: 'accessing'!extraSpace: aPoint	extraSpace _ aPoint! !!CLayoutCell methodsFor: 'accessing'!hSpaceFill	^flags anyMask: 1! !!CLayoutCell methodsFor: 'accessing'!hSpaceFill: aBool	flags ifNil:[flags _ 0].	flags _ aBool ifTrue:[flags bitOr: 1] ifFalse:[flags bitClear: 1].! !!CLayoutCell methodsFor: 'accessing'!nextCell	^nextCell! !!CLayoutCell methodsFor: 'accessing'!nextCell: aCell	nextCell _ aCell! !!CLayoutCell methodsFor: 'accessing'!target	^target! !!CLayoutCell methodsFor: 'accessing'!target: newTarget	target _ newTarget! !!CLayoutCell methodsFor: 'accessing'!vSpaceFill	^flags anyMask: 2! !!CLayoutCell methodsFor: 'accessing'!vSpaceFill: aBool	flags ifNil:[flags _ 0].	flags _ aBool ifTrue:[flags bitOr: 2] ifFalse:[flags bitClear: 2].! !!CLayoutFrame methodsFor: 'accessing'!bottomFraction	^bottomFraction! !!CLayoutFrame methodsFor: 'accessing'!bottomFraction: aNumber	bottomFraction _ aNumber! !!CLayoutFrame methodsFor: 'accessing'!bottomFraction: aNumber offset: anInteger	bottomFraction _ aNumber.	bottomOffset _ anInteger! !!CLayoutFrame methodsFor: 'accessing'!bottomOffset	^bottomOffset! !!CLayoutFrame methodsFor: 'accessing'!bottomOffset: anInteger	bottomOffset _ anInteger! !!CLayoutFrame methodsFor: 'accessing'!leftFraction	^leftFraction! !!CLayoutFrame methodsFor: 'accessing'!leftFraction: aNumber	leftFraction _ aNumber! !!CLayoutFrame methodsFor: 'accessing'!leftFraction: aNumber offset: anInteger	leftFraction _ aNumber.	leftOffset _ anInteger! !!CLayoutFrame methodsFor: 'accessing'!leftOffset	^leftOffset! !!CLayoutFrame methodsFor: 'accessing'!leftOffset: anInteger	leftOffset _ anInteger! !!CLayoutFrame methodsFor: 'accessing'!rightFraction	^rightFraction! !!CLayoutFrame methodsFor: 'accessing'!rightFraction: aNumber	rightFraction _ aNumber! !!CLayoutFrame methodsFor: 'accessing'!rightFraction: aNumber offset: anInteger	rightFraction _ aNumber.	rightOffset _ anInteger! !!CLayoutFrame methodsFor: 'accessing'!rightOffset	^rightOffset! !!CLayoutFrame methodsFor: 'accessing'!rightOffset: anInteger	rightOffset _ anInteger! !!CLayoutFrame methodsFor: 'accessing'!topFraction	^topFraction! !!CLayoutFrame methodsFor: 'accessing'!topFraction: aNumber	topFraction _ aNumber! !!CLayoutFrame methodsFor: 'accessing'!topFraction: aNumber offset: anInteger	topFraction _ aNumber.	topOffset _ anInteger! !!CLayoutFrame methodsFor: 'accessing'!topOffset	^topOffset! !!CLayoutFrame methodsFor: 'accessing'!topOffset: anInteger	topOffset _ anInteger! !!CLayoutFrame methodsFor: 'layout'!layout: oldBounds in: newBounds	"Return the proportional rectangle insetting the given bounds"	| left right top bottom |	leftFraction ifNotNil:[		left _ newBounds left + (newBounds width * leftFraction).		leftOffset ifNotNil:[left _ left + leftOffset]].	rightFraction ifNotNil:[		right _ newBounds right - (newBounds width * (1.0 - rightFraction)).		rightOffset ifNotNil:[right _ right + rightOffset]].	topFraction ifNotNil:[		top _ newBounds top + (newBounds height * topFraction).		topOffset ifNotNil:[top _ top + topOffset]].	bottomFraction ifNotNil:[		bottom _ newBounds bottom - (newBounds height * (1.0 - bottomFraction)).		bottomOffset ifNotNil:[bottom _ bottom + bottomOffset]].	left ifNil:[ right 			ifNil:[left _ oldBounds left. right _ oldBounds right]			ifNotNil:[left _ right - oldBounds width]].	right ifNil:[right _ left + oldBounds width].	top ifNil:[ bottom 			ifNil:[top _ oldBounds top. bottom _ oldBounds bottom]			ifNotNil:[top _ bottom - oldBounds height]].	bottom ifNil:[bottom _ top + oldBounds height].	^(left rounded @ top rounded) corner: (right rounded @ bottom rounded)! !!CLayoutFrame methodsFor: 'layout' stamp: 'ar 3/16/2003 18:45'!minExtentFrom: minExtent	"Return the minimal extent the given bounds can be represented in"	| left right top bottom width height lOfs rOfs tOfs bOfs |	width := minExtent x.	height := minExtent y.	lOfs := rOfs := tOfs := bOfs := 0.	leftFraction ifNotNil:[leftOffset ifNotNil:[lOfs := leftOffset]].	rightFraction ifNotNil:[rightOffset ifNotNil:[rOfs := rightOffset]].	topFraction ifNotNil:[topOffset ifNotNil:[tOfs := topOffset]].	bottomFraction ifNotNil:[bottomOffset ifNotNil:[bOfs := bottomOffset]].	lOfs < 0 ifTrue:[width := width + lOfs].	rOfs < 0 ifTrue:[width := width + rOfs].	tOfs < 0 ifTrue:[height := height + tOfs].	bOfs < 0 ifTrue:[height := height + bOfs].	left := top := 0.0.	right := bottom := 1.0.	leftFraction ifNotNil:[left := leftFraction].	rightFraction ifNotNil:[right := rightFraction].	topFraction ifNotNil:[top := topFraction].	bottomFraction ifNotNil:[bottom := bottomFraction].	left = right ifFalse:[width := width / (right - left)].	top = bottom ifFalse:[height := height / (bottom - top)].	lOfs > 0 ifTrue:[width := width + lOfs].	rOfs > 0 ifTrue:[width := width + rOfs].	tOfs > 0 ifTrue:[height := height + tOfs].	bOfs > 0 ifTrue:[height := height + bOfs].	^width truncated @ height truncated! !!CLayoutFrame methodsFor: 'layout' stamp: 'ar 3/16/2003 18:45'!minExtentFromNEW: minExtent	"Return the minimal extent the given bounds can be represented in"	| left right top bottom width height lOfs rOfs tOfs bOfs |	width := minExtent x.	height := minExtent y.	lOfs := rOfs := tOfs := bOfs := 0.	leftFraction ifNotNil:[leftOffset ifNotNil:[lOfs := leftOffset]].	rightFraction ifNotNil:[rightOffset ifNotNil:[rOfs := rightOffset]].	topFraction ifNotNil:[topOffset ifNotNil:[tOfs := topOffset]].	bottomFraction ifNotNil:[bottomOffset ifNotNil:[bOfs := bottomOffset]].	lOfs < 0 ifTrue:[width := width + lOfs].	rOfs < 0 ifTrue:[width := width + rOfs].	tOfs < 0 ifTrue:[height := height + tOfs].	bOfs < 0 ifTrue:[height := height + bOfs].	left := top := 0.0.	right := bottom := 1.0.	leftFraction ifNotNil:[left := leftFraction].	rightFraction ifNotNil:[right := rightFraction].	topFraction ifNotNil:[top := topFraction].	bottomFraction ifNotNil:[bottom := bottomFraction].	left = right ifFalse:[width := width / (right - left)].	top = bottom ifFalse:[height := height / (bottom - top)].	lOfs > 0 ifTrue:[width := width + lOfs].	rOfs > 0 ifTrue:[width := width + rOfs].	tOfs > 0 ifTrue:[height := height + tOfs].	bOfs > 0 ifTrue:[height := height + bOfs].	^width truncated @ height truncated! !!CLayoutFrame methodsFor: 'layout' stamp: 'ar 3/16/2003 18:32'!minExtentFromOLD: minExtent	"Return the minimal extent the given bounds can be represented in"	| left right top bottom width height x y |	left := top := 0.0.	right := bottom := 1.0.	width := height := 0.	x := minExtent x.	y := minExtent y.	leftFraction ifNotNil:[left := leftFraction].	rightFraction ifNotNil:[right := rightFraction].	topFraction ifNotNil:[top := topFraction].	bottomFraction ifNotNil:[bottom := bottomFraction].	left = right ifFalse:[width := x / (right - left)].	top = bottom ifFalse:[height := y / (bottom - top)].	leftOffset ifNotNil:[width _ width + leftOffset].	rightOffset ifNotNil:[width _ width + rightOffset].	topOffset ifNotNil:[height _ height + topOffset].	bottomOffset ifNotNil:[height _ height + bottomOffset].	^width truncated @ height truncated! !!CLayoutFrame methodsFor: 'objects from disk'!convertToCurrentVersion: varDict refStream: smartRefStrm	| className oldClassVersion |	"JW 2/1/2001"	"Since class version isn't passed in varDict, look it up through smartRefSrm."	className := varDict at: #ClassName.	oldClassVersion := (smartRefStrm structures at: className) first.	(oldClassVersion = 0) ifTrue: [ self negateBottomRightOffsets ].	^super convertToCurrentVersion: varDict refStream: smartRefStrm.! !!CLayoutFrame methodsFor: 'objects from disk'!negateBottomRightOffsets	bottomOffset ifNotNil: [ bottomOffset := bottomOffset negated ].	rightOffset ifNotNil: [ rightOffset := rightOffset negated ].! !!CLayoutFrame methodsFor: 'converting' stamp: 'ar 3/6/2004 19:40'!asLayoutFrame	^self! !!CLayoutProperties methodsFor: 'accessing'!hResizing	^hResizing! !!CLayoutProperties methodsFor: 'accessing'!hResizing: aSymbol	hResizing _ aSymbol! !!CLayoutProperties methodsFor: 'accessing' stamp: 'ar 3/24/2004 03:40'!layoutInset	^layoutInset ifNil:[0@0]! !!CLayoutProperties methodsFor: 'accessing' stamp: 'ar 3/24/2004 03:42'!layoutInset: newInset	layoutInset := newInset! !!CLayoutProperties methodsFor: 'accessing'!vResizing	^vResizing! !!CLayoutProperties methodsFor: 'accessing'!vResizing: aSymbol	vResizing _ aSymbol! !!CLayoutProperties methodsFor: 'initialize' stamp: 'ar 3/24/2004 03:41'!initialize	hResizing _ vResizing _ #rigid.	layoutInset := 0@0.! !!CLayoutProperties methodsFor: 'initialize' stamp: 'ar 3/24/2004 02:31'!initializeFrom: defaultProvider	"Initialize the receiver from a default provider"	self hResizing: defaultProvider hResizing.	self vResizing: defaultProvider vResizing.! !!CMD5Hasher methodsFor: 'initialization' stamp: 'ar 3/14/2004 01:57'!initialize	"Some magic numbers to get the process started"	state _ {		(ThirtyTwoBitRegister new load: 16r67452301).		(ThirtyTwoBitRegister new load: 16rEFCDAB89).		(ThirtyTwoBitRegister new load: 16r98BADCFE).		(ThirtyTwoBitRegister new load: 16r10325476)	}.! !!CMD5Hasher methodsFor: 'public' stamp: 'DSM 1/20/2000 15:29'!hashMessage: aStringOrByteArray	"MD5 new hashMessage: 'foo'"	^ self hashStream: (ReadStream on: aStringOrByteArray asByteArray)! !!CMD5Hasher methodsFor: 'public' stamp: 'ar 3/14/2004 01:34'!hashStream: aPositionableStream	"MD5 new hashStream: (ReadStream on: 'foo')"	| startPosition buf bitLength |	self initialize.	"aPositionableStream atEnd ifTrue: [self error: 'empty stream']."	startPosition _ aPositionableStream position.	[aPositionableStream atEnd] whileFalse: [		buf _ aPositionableStream next: 64.		(aPositionableStream atEnd not and: [buf size = 64])			ifTrue: [self processBuffer: buf]			ifFalse: [				bitLength _ (aPositionableStream position - startPosition) * 8.				self processFinalBuffer: buf bitLength: bitLength]].	^ self finalValue! !!CMD5Hasher methodsFor: 'private-functions' stamp: 'DSM 1/20/2000 01:47'!fX: x Y: y Z: z	" compute 'xy or (not x)z'"	^ x copy bitAnd: y; bitOr: (x copy bitInvert; bitAnd: z)	! !!CMD5Hasher methodsFor: 'private-functions' stamp: 'DSM 1/20/2000 13:38'!ffA: a B: b C: c D: d M: m S: s T: t	"compute a = b + ((a + f(b,c,d) + m + t) <<< s)"	^ a += (self fX: b Y: c Z: d); += m; += t; leftRotateBy: s; += b.! !!CMD5Hasher methodsFor: 'private-functions' stamp: 'DSM 1/20/2000 01:48'!gX: x Y: y Z: z	" compute 'xz or y(not z)'"	^ x copy bitAnd: z; bitOr: (z copy bitInvert; bitAnd: y)	! !!CMD5Hasher methodsFor: 'private-functions' stamp: 'DSM 1/20/2000 13:38'!ggA: a B: b C: c D: d M: m S: s T: t	"compute a = b + ((a + g(b,c,d) + m + t) <<< s)"	^ a += (self gX: b Y: c Z: d); += m; += t; leftRotateBy: s; += b.! !!CMD5Hasher methodsFor: 'private-functions' stamp: 'DSM 1/20/2000 01:48'!hX: x Y: y Z: z	" compute 'x xor y xor z'"	^ x copy bitXor: y; bitXor: z	! !!CMD5Hasher methodsFor: 'private-functions' stamp: 'DSM 1/20/2000 13:38'!hhA: a B: b C: c D: d M: m S: s T: t	"compute a = b + ((a + h(b,c,d) + m + t) <<< s)"	^ a += (self hX: b Y: c Z: d); += m; += t; leftRotateBy: s; += b.! !!CMD5Hasher methodsFor: 'private-functions' stamp: 'DSM 1/20/2000 01:48'!iX: x Y: y Z: z	" compute 'y xor (x or (not z))'"	^ y copy bitXor: (z copy bitInvert; bitOr: x)! !!CMD5Hasher methodsFor: 'private-functions' stamp: 'DSM 1/20/2000 13:39'!iiA: a B: b C: c D: d M: m S: s T: t	"compute a = b + ((a + i(b,c,d) + m + t) <<< s)"	^ a += (self iX: b Y: c Z: d); += m; += t; leftRotateBy: s; += b.! !!CMD5Hasher methodsFor: 'private-functions' stamp: 'ar 3/14/2004 01:56'!step: data template: item selector: selector	"Perform one step in the round"	| args |	args _  Array new: 7.	args at: 1 put: (state at: (item at: 1)).	args at: 2 put: (state at: (item at: 2)).	args at: 3 put: (state at: (item at: 3)).	args at: 4 put: (state at: (item at: 4)).	args at: 5 put: (data at: (item at: 5)).	args at: 6 put: (item at: 6).	args at: 7 put: (item at: 7).	(self perform: selector withArguments: args).! !!CMD5Hasher methodsFor: 'private-buffers' stamp: 'DSM 1/20/2000 17:56'!finalValue	"Concatenate the state values to produce the 128-bite result"	^ (( state at: 1) asReverseInteger bitShift: 96) +	  (( state at: 2) asReverseInteger bitShift: 64) +	  (( state at: 3) asReverseInteger bitShift: 32) +	  (( state at: 4) asReverseInteger)! !!CMD5Hasher methodsFor: 'private-buffers' stamp: 'ar 3/14/2004 01:34'!processBuffer: aByteArray	"Process a 64-byte buffer"	| saveState data |	saveState _ state collect: [ :item | item copy ].	data _ Array new: 16.	1 to: 16 do: [ :index |		data at: index put:			(ThirtyTwoBitRegister new reverseLoadFrom: aByteArray at: (index * 4) - 3)].	self rounds: data.	1 to: 4 do: [ :index | (state at: index) += (saveState at: index) ].! !!CMD5Hasher methodsFor: 'private-buffers' stamp: 'DSM 1/20/2000 17:55'!processFinalBuffer: aByteArray bitLength: bitLength	"Pad the buffer until we have an even 64 bytes, then transform"	| out |	out _ ByteArray new: 64.	out replaceFrom: 1 to: aByteArray size with: aByteArray startingAt: 1.	aByteArray size < 56 ifTrue: [		out at: aByteArray size + 1 put: 128. "trailing bit"		self storeLength: bitLength in: out.		self processBuffer: out.		^ self].	"not enough room for the length, so just pad this one, then..."	aByteArray size < 64 ifTrue: [ out at: aByteArray size + 1 put: 128 ].	self processBuffer: out.	"process one additional block of padding ending with the length"	out _ ByteArray new: 64.  "filled with zeros"	aByteArray size = 64 ifTrue: [ out at: 1 put: 128].	self storeLength: bitLength in: out.	self processBuffer: out.! !!CMD5Hasher methodsFor: 'private-buffers' stamp: 'DSM 1/20/2000 17:19'!storeLength: bitLength in: aByteArray	"Fill in the final 8 bytes of the given ByteArray with a 64-bit	little-endian representation of the original message length in bits."	| n i |	n _ bitLength.	i _ aByteArray size - 8 + 1.	[n > 0] whileTrue: [		aByteArray at: i put: (n bitAnd: 16rFF).		n _ n bitShift: -8.		i _ i + 1].! !!CMD5Hasher methodsFor: 'private-rounds' stamp: 'ar 3/14/2004 02:02'!round: data selector: selector round: round	"Do one round with the given function"	| shiftIndex template abcd |	1 to: 16 do: [ :i |		shiftIndex _ (i - 1) \\ 4 + 1.		abcd _ ABCDTable at: shiftIndex.		template _ Array new: 7.		template at: 1 put: (abcd at: 1).		template at: 2 put: (abcd at: 2).		template at: 3 put: (abcd at: 3).		template at: 4 put: (abcd at: 4).		template at: 5 put: ((IndexTable at: round) at: i).		template at: 6 put: ((ShiftTable at: round) at: shiftIndex).		template at: 7 put: (SinTable at: round - 1 * 16 + i).		self step: data template: template selector: selector ].! !!CMD5Hasher methodsFor: 'private-rounds' stamp: 'ar 3/14/2004 02:05'!rounds: data	"Perform the four rounds with different functions"	self round: data selector: #ffA:B:C:D:M:S:T: round: 1.	self round: data selector: #ggA:B:C:D:M:S:T: round: 2.	self round: data selector: #hhA:B:C:D:M:S:T: round: 3.	self round: data selector: #iiA:B:C:D:M:S:T: round: 4.! !!CMakerPart methodsFor: '*Tweak-Tweaks' stamp: 'ar 2/27/2004 19:40'!tdlPrintOn: aStream indent: level	self subclassResponsibility.! !!CMakerPart methodsFor: '*Tweak-Tweaks' stamp: 'ar 2/27/2004 19:42'!tdlPrintString	^String streamContents:[:s|		self tdlPrintOn: s indent: 0.	].! !!CMakerPart methodsFor: '*Tweak-Tweaks' stamp: 'ar 2/27/2004 19:37'!tweak: oldValue in: aMaker	"Tweak the old value"	^self subclassResponsibility! !!CMakerPart methodsFor: 'accessing' stamp: 'ar 2/24/2004 21:12'!partID	^nil! !!CMakerPart methodsFor: 'accessing' stamp: 'ar 2/27/2004 20:07'!value	^value! !!CMakerPart methodsFor: 'accessing' stamp: 'ar 10/18/2003 23:02'!value: aValue	value := aValue! !!CMakerPart methodsFor: 'accessing' stamp: 'ar 2/14/2004 22:24'!valueInMaker: aMaker	^value ifNil:[		self createPartIn: aMaker.		self constructPartIn: aMaker.		value].! !!CMakerPart methodsFor: 'importing' stamp: 'ar 11/20/2003 12:41'!remapIn: aMap	"Replace all references to some object using the given map."! !!CMakerPart methodsFor: 'importing' stamp: 'ar 12/2/2003 14:08'!resolveIn: importer	"Replace all shared references by references to their contents"! !!CMakerPart methodsFor: 'creating' stamp: 'ar 2/14/2004 22:02'!constructPartIn: aMaker	"Construct this part"	^self subclassResponsibility! !!CMakerPart methodsFor: 'creating' stamp: 'ar 2/14/2004 21:54'!createPartIn: aMaker	"Create this part"	^self subclassResponsibility! !!CMakerPart methodsFor: 'creating' stamp: 'ar 10/19/2003 13:26'!postBuildIn: aMaker	value := nil.! !!CMakerPart methodsFor: 'testing' stamp: 'ar 2/24/2004 15:56'!isMakerPart	^true! !!CMakerPart methodsFor: 'exporting' stamp: 'ar 12/2/2003 14:15'!exportMaker: aMaker on: xmlWriter	xmlWriter attribute: 'maker' value: aMaker resourceID asString! !!CMakerPart methodsFor: 'exporting' stamp: 'ar 12/1/2003 20:55'!exportXmlOn: xmlWriter	^self exportXmlOn: xmlWriter key: self xmlTagName.! !!CMakerPart methodsFor: 'exporting' stamp: 'ar 12/1/2003 20:53'!exportXmlOn: xmlWriter key: aKey	^self subclassResponsibility! !!CMakerPart methodsFor: 'exporting' stamp: 'ar 2/28/2004 20:37'!xmlString	| stream writer |	stream := WriteStream on: String new.	writer := XMLWriterIndenting on: stream.	self exportXmlOn: writer.	^stream contents! !!CMakerPart methodsFor: 'exporting' stamp: 'ar 11/14/2003 20:55'!xmlTagName	^self subclassResponsibility! !!CGlobalPart methodsFor: 'creating' stamp: 'ar 2/14/2004 22:02'!constructPartIn: aMaker	"Construct this part"! !!CGlobalPart methodsFor: 'creating' stamp: 'ar 2/14/2004 21:54'!createPartIn: aMaker	"Create this part"	value := Smalltalk at: globalName ifAbsent:[^nil].	globalSelector ifNotNil:[		value := value perform: globalSelector withArguments: globalArgs.	].! !!CGlobalPart methodsFor: 'accessing' stamp: 'ar 10/18/2003 22:37'!globalArgs	^globalArgs! !!CGlobalPart methodsFor: 'accessing' stamp: 'ar 10/18/2003 22:38'!globalArgs: args	globalArgs := args! !!CGlobalPart methodsFor: 'accessing' stamp: 'ar 10/18/2003 22:37'!globalName	^globalName! !!CGlobalPart methodsFor: 'accessing' stamp: 'ar 10/18/2003 22:38'!globalName: aSymbol	globalName := aSymbol! !!CGlobalPart methodsFor: 'accessing' stamp: 'ar 10/18/2003 22:37'!globalSelector	^globalSelector! !!CGlobalPart methodsFor: 'accessing' stamp: 'ar 10/18/2003 23:10'!globalSelector: aSymbol	globalSelector := aSymbol.	globalSelector ifNotNil:[globalSelector := globalSelector asSymbol].! !!CGlobalPart methodsFor: 'accessing' stamp: 'ar 10/18/2003 23:04'!partMaker	^nil! !!CGlobalPart methodsFor: '*Tweak-Tweaks' stamp: 'ar 2/27/2004 19:41'!tdlPrintOn: aStream indent: level	| nArgs |	aStream nextPut: $(.	aStream nextPutAll: globalName asString.	globalSelector ifNotNil:[		nArgs := globalSelector numArgs.		nArgs = 0 ifTrue:[			aStream space; nextPutAll: globalSelector.		] ifFalse:[			(globalSelector findTokens: ':') with: globalArgs do:[:sel :arg|				aStream space; nextPutAll: sel; nextPutAll:': '; print: arg.			].		].	].	aStream nextPut: $).! !!CGlobalPart methodsFor: 'exporting' stamp: 'ar 12/1/2003 20:54'!exportXmlOn: xmlWriter key: aKey	xmlWriter startTag: aKey.	xmlWriter attribute: 'global' value: globalName asString.	globalSelector ifNotNil:[xmlWriter attribute: 'selector' value: globalSelector asString].	xmlWriter endTag.	globalArgs ifNotNil:[globalArgs do:[:arg| arg exportXmlOn: xmlWriter key: 'argument']].	xmlWriter endTag: aKey.! !!CGlobalPart methodsFor: 'exporting' stamp: 'ar 11/14/2003 20:55'!xmlTagName	^'global'! !!CMatrixTransform methodsFor: 'testing'!isIdentity	"Return true if the receiver is the identity transform; that is, if applying to a point returns the point itself."	<primitive: 'primitiveIsIdentity' module: 'Matrix2x3Plugin'>	^self isPureTranslation and:[self a13 = 0.0 and:[self a23 = 0.0]]! !!CMatrixTransform methodsFor: 'testing'!isMatrixTransform2x3	"Return true if the receiver is 2x3 matrix transformation"	^true! !!CMatrixTransform methodsFor: 'testing'!isPureTranslation	"Return true if the receiver specifies no rotation or scaling."	<primitive: 'primitiveIsPureTranslation' module: 'Matrix2x3Plugin'>	^self a11 = 1.0 and:[self a12 = 0.0 and:[self a22 = 0.0 and:[self a21 = 1.0]]]! !!CMatrixTransform methodsFor: 'accessing'!at: index	<primitive: 'primitiveAt' module: 'FloatArrayPlugin'>	^Float fromIEEE32Bit: (self basicAt: index)! !!CMatrixTransform methodsFor: 'accessing'!at: index put: value	<primitive: 'primitiveAtPut' module: 'FloatArrayPlugin'>	value isFloat 		ifTrue:[self basicAt: index put: value asIEEE32BitWord]		ifFalse:[self at: index put: value asFloat].	^value! !!CMatrixTransform methodsFor: 'accessing'!inverseTransformation	"Return the inverse transformation of the receiver.	The inverse transformation is computed by first calculating	the inverse offset and then computing transformations	for the two identity vectors (1@0) and (0@1)"	| r1 r2 r3 m |	r3 _ self invertPoint: 0@0.	r1 _ (self invertPoint: 1@0) - r3.	r2 _ (self invertPoint: 0@1) - r3.	m _ self species new.	m		a11: r1 x; a12: r2 x; a13: r3 x;		a21: r1 y; a22: r2 y; a23: r3 y.	^m! !!CMatrixTransform methodsFor: 'accessing'!offset	^self a13 @ self a23! !!CMatrixTransform methodsFor: 'accessing'!offset: aPoint	self a13: aPoint x asFloat.	self a23: aPoint y asFloat.! !!CMatrixTransform methodsFor: 'accessing' stamp: 'ar 3/18/2003 23:29'!scale	| a11 a12 a21 a22 |	a11 := self a11.	a12 := self a12.	a21 := self a21.	a22 := self a22.	^((a11*a11) + (a12*a12)) sqrt @ ((a21 * a21) + (a22 * a22)) sqrt! !!CMatrixTransform methodsFor: 'accessing' stamp: 'ar 6/9/2003 00:07'!warpCellSize	| a11 a12 a21 a22 |	a11 := self a11.	a12 := self a12.	a21 := self a21.	a22 := self a22.	((a11*a11) + (a12*a12)) < 1.01 ifTrue:[^2].	((a21 * a21) + (a22 * a22)) < 1.01 ifTrue:[^2].	(a12 - a21) abs < 0.01		ifTrue:[^1]		ifFalse:[^2]! !!CMatrixTransform methodsFor: 'transforming points'!globalPointToLocal: aPoint	"Transform aPoint from global coordinates into local coordinates"	<primitive: 'primitiveInvertPoint' module: 'Matrix2x3Plugin'>	^(self invertPoint: aPoint) rounded! !!CMatrixTransform methodsFor: 'transforming points'!invertPoint: aPoint	"Transform aPoint from global coordinates into local coordinates"	| x y det a11 a12 a21 a22 detX detY |	x _ aPoint x asFloat - (self a13).	y _ aPoint y asFloat - (self a23).	a11 _ self a11.	a12 _ self a12.	a21 _ self a21.	a22 _ self a22.	det _ (a11 * a22) - (a12 * a21).	det = 0.0 ifTrue:[^0@0]. "So we have at least a valid result"	det _ 1.0 / det.	detX _ (x * a22) - (a12 * y).	detY _ (a11 * y) - (x * a21).	^(detX * det) @ (detY * det)! !!CMatrixTransform methodsFor: 'transforming points'!localPointToGlobal: aPoint	"Transform aPoint from local coordinates into global coordinates"	<primitive: 'primitiveTransformPoint' module: 'Matrix2x3Plugin'>	^(self transformPoint: aPoint) rounded! !!CMatrixTransform methodsFor: 'transforming points'!transformDirection: aPoint	"Transform aPoint from local coordinates into global coordinates"	| x y |	x _ (aPoint x * self a11) + (aPoint y * self a12).	y _ (aPoint x * self a21) + (aPoint y * self a22).	^x @ y! !!CMatrixTransform methodsFor: 'transforming points'!transformPoint: aPoint	"Transform aPoint from local coordinates into global coordinates"	| x y |	x _ (aPoint x * self a11) + (aPoint y * self a12) + self a13.	y _ (aPoint x * self a21) + (aPoint y * self a22) + self a23.	^x @ y! !!CMatrixTransform methodsFor: 'element access'!a11	^self at: 1! !!CMatrixTransform methodsFor: 'element access'!a11: value	 self at: 1 put: value! !!CMatrixTransform methodsFor: 'element access'!a12	^self at: 2! !!CMatrixTransform methodsFor: 'element access'!a12: value	 self at: 2 put: value! !!CMatrixTransform methodsFor: 'element access'!a13	^self at: 3! !!CMatrixTransform methodsFor: 'element access'!a13: value	 self at: 3 put: value! !!CMatrixTransform methodsFor: 'element access'!a21	 ^self at: 4! !!CMatrixTransform methodsFor: 'element access'!a21: value	 self at: 4 put: value! !!CMatrixTransform methodsFor: 'element access'!a22	 ^self at: 5! !!CMatrixTransform methodsFor: 'element access'!a22: value	 self at: 5 put: value! !!CMatrixTransform methodsFor: 'element access'!a23	 ^self at: 6! !!CMatrixTransform methodsFor: 'element access'!a23: value	 self at: 6 put: value! !!CMatrixTransform methodsFor: 'composing'!composedWithLocal: aTransformation	"Return the composition of the receiver and the local transformation passed in"	^self composedWithLocal: aTransformation asMatrixTransform2x3 into: self class new! !!CMatrixTransform methodsFor: 'composing'!composedWithLocal: aTransformation into: result	"Return the composition of the receiver and the local transformation passed in.	Store the composed matrix into result."	| a11 a12 a13 a21 a22 a23 b11 b12 b13 b21 b22 b23 matrix |	<primitive: 'primitiveComposeMatrix' module: 'Matrix2x3Plugin'>	matrix _ aTransformation asMatrixTransform2x3.	a11 _ self a11.		b11 _ matrix a11.	a12 _ self a12.		b12 _ matrix a12.	a13 _ self a13.		b13 _ matrix a13.	a21 _ self a21.		b21 _ matrix a21.	a22 _ self a22.		b22 _ matrix a22.	a23 _ self a23.		b23 _ matrix a23.	result a11: (a11 * b11) + (a12 * b21).	result a12: (a11 * b12) + (a12 * b22).	result a13: a13 + (a11 * b13) + (a12 * b23).	result a21: (a21 * b11) + (a22 * b21).	result a22: (a21 * b12) + (a22 * b22).	result a23: a23 + (a21 * b13) + (a22 * b23).	^result! !!CMatrixTransform methodsFor: 'serializing' stamp: 'ar 11/19/2003 19:19'!serializeOn: aSerializer	^aSerializer writeBitsArray: self! !!CMatrixTransform methodsFor: 'printing'!encodePostscriptOn: aStream	aStream writeMatrix:self.! !!CMatrixTransform methodsFor: 'printing'!printOn: aStream	aStream 		nextPutAll: self class name;		nextPut: $(;		cr; print: self a11; tab; print: self a12; tab; print: self a13;		cr; print: self a21; tab; print: self a22; tab; print: self a23;		cr; nextPut:$).! !!CMatrixTransform methodsFor: 'comparing'!= aMatrixTransform2x3	 	| length |	<primitive: 'primitiveEqual' module: 'FloatArrayPlugin'>	self class = aMatrixTransform2x3 class ifFalse: [^ false].	length _ self size.	length = aMatrixTransform2x3 size ifFalse: [^ false].	1 to: self size do: [:i | (self at: i)			= (aMatrixTransform2x3 at: i) ifFalse: [^ false]].	^ true! !!CMatrixTransform methodsFor: 'comparing'!hash	| result |	<primitive: 'primitiveHashArray' module: 'FloatArrayPlugin'>	result _ 0.	1 to: self size do:[:i| result _ result + (self basicAt: i) ].	^result bitAnd: 16r1FFFFFFF! !!CMatrixTransform methodsFor: 'transforming rects'!globalBounds: srcRect toLocal: dstRect	"Transform aRectangle from global coordinates into local coordinates"	<primitive: 'primitiveInvertRectInto' module: 'Matrix2x3Plugin'>	^super globalBoundsToLocal: srcRect! !!CMatrixTransform methodsFor: 'transforming rects'!globalBoundsToLocal: aRectangle	"Transform aRectangle from global coordinates into local coordinates"	^self globalBounds: aRectangle toLocal: Rectangle new! !!CMatrixTransform methodsFor: 'transforming rects' stamp: 'ar 6/22/2003 20:07'!localBounds: srcRect toGlobal: dstRect	"Transform aRectangle from local coordinates into global coordinates"	"<primitive: 'primitiveTransformRectInto' module: 'Matrix2x3Plugin'>"	^super localBoundsToGlobal: srcRect! !!CMatrixTransform methodsFor: 'transforming rects'!localBoundsToGlobal: aRectangle	"Transform aRectangle from local coordinates into global coordinates"	^self localBounds: aRectangle toGlobal: Rectangle new! !!CMatrixTransform methodsFor: 'initialize'!setIdentiy	"Initialize the receiver to the identity transformation (e.g., not affecting points)"	self		a11: 1.0; a12: 0.0; a13: 0.0;		a21: 0.0; a22: 1.0; a23: 0.0.! !!CMatrixTransform methodsFor: 'converting'!asMatrixTransform2x3	^self! !!CMatrixTransform methodsFor: 'private'!setAngle: angle	"Set the raw rotation angle in the receiver"	| rad s c |	rad := angle degreesToRadians.	s := rad sin.	c := rad cos.	self a11: c.	self a12: s negated.	self a21: s.	self a22: c.! !!CMatrixTransform methodsFor: 'private'!setOffset: aPoint	"Set the raw offset in the receiver"	| pt |	pt _ aPoint asPoint.	self a13: pt x asFloat.	self a23: pt y asFloat.! !!CMatrixTransform methodsFor: 'private'!setScale: aPoint	"Set the raw scale in the receiver"	| pt |	pt _ aPoint asPoint.	self a11: pt x asFloat.	self a22: pt y asFloat.! !!CMatrixTransform methodsFor: 'encoding'!encodeForRemoteCanvas	"encode this transform into a string for use by a RemoteCanvas"	^String streamContents: [ :str |		str nextPutAll: 'Matrix,'.		1 to: 6 do: [ :i |			str print: (self basicAt: i).			str nextPut: $, ].	]! !!CMatrixTransform methodsFor: 'objects from disk'!writeOn: aStream	aStream nextWordsPutAll: self.! !!CMouseClickState methodsFor: 'initialize'!client: aCostume click: aClickSelector dblClick: aDblClickSelector dblClickTime: timeOut dblClickTimeout: aDblClickTimeoutSelector drag: aDragSelector threshold: aNumber event: firstClickEvent	clickClient _ aCostume.	clickSelector _ aClickSelector.	dblClickSelector _ aDblClickSelector.	dblClickTime _ timeOut.	dblClickTimeoutSelector _ aDblClickTimeoutSelector.	dragSelector _ aDragSelector.	dragThreshold _ aNumber.	firstClickDown _ firstClickEvent.	firstClickTime _ firstClickEvent timeStamp.	clickState _ #firstClickDown.! !!CMouseClickState methodsFor: 'event handling'!click	clickSelector ifNotNil: [clickClient perform: clickSelector with: firstClickDown]! !!CMouseClickState methodsFor: 'event handling'!doubleClick	dblClickSelector ifNotNil: [clickClient perform: dblClickSelector with: firstClickDown]! !!CMouseClickState methodsFor: 'event handling'!doubleClickTimeout	dblClickTimeoutSelector ifNotNil: [		clickClient perform: dblClickTimeoutSelector with: firstClickDown]! !!CMouseClickState methodsFor: 'event handling'!drag: event	dragSelector ifNotNil: [clickClient perform: dragSelector with: event]! !!CMouseClickState methodsFor: 'event handling'!handleEvent: evt from: aHand	"Process the given mouse event to detect a click, double-click, or drag.	Return true if the event should be processed by the sender, false if it shouldn't.	NOTE: This method heavily relies on getting *all* mouse button events."	| localEvt timedOut isDrag |	timedOut _ (evt timeStamp - firstClickTime) > dblClickTime.	localEvt _ evt transformedBy: clickClient globalToLocal.	isDrag _ (localEvt cursorPoint - firstClickDown cursorPoint) r > dragThreshold.	clickState == #firstClickDown ifTrue: [		"Careful here - if we had a slow cycle we may have a timedOut mouseUp event"		(timedOut and:[localEvt isMouseUp not]) ifTrue:[			"timeout before #mouseUp -> keep waiting for drag if requested"			clickState _ #firstClickTimedOut.			dragSelector ifNil:[				aHand resetClickState.				self doubleClickTimeout; click "***"].			^true].		localEvt isMouseUp ifTrue:[			(timedOut or:[dblClickSelector isNil]) ifTrue:[				self click.				aHand resetClickState.				^true].			"Otherwise transfer to #firstClickUp"			firstClickUp _ evt copy.			clickState _ #firstClickUp.			"If timedOut or the client's not interested in dbl clicks get outta here"			self click.			aHand handleEvent: firstClickUp.			^false].		isDrag ifTrue:["drag start"			self doubleClickTimeout. "***"			aHand resetClickState.			dragSelector "If no drag selector send #click instead"				ifNil: [self click]				ifNotNil: [self drag: localEvt].			^true].		^false].	clickState == #firstClickTimedOut ifTrue:[		localEvt isMouseUp ifTrue:["neither drag nor double click"			aHand resetClickState.			self doubleClickTimeout; click. "***"			^true].		isDrag ifTrue:["drag start"			aHand resetClickState.			self doubleClickTimeout; drag: localEvt. "***"			^true].		^false].	clickState = #firstClickUp ifTrue:[		(timedOut) ifTrue:[			"timed out after mouseUp - send #click: and mouseUp"			aHand resetClickState.			self doubleClickTimeout. "***"			^true].		localEvt isMouseDown ifTrue:["double click"			aHand resetClickState.			self doubleClick.			^false]].	^true! !!CMouseOverHandler methodsFor: 'initialize-release'!initialize	mouseOverList := #().! !!CMouseOverHandler methodsFor: 'accessing'!mouseOverList	^mouseOverList! !!CMouseOverHandler methodsFor: 'event handling' stamp: 'ar 3/18/2003 13:54'!noticeMouseOver: aCostume event: anEvent	"Remember that the mouse is currently over some costume"	(leftList includes: aCostume) 		ifTrue:[leftList remove: aCostume]		ifFalse:[enteredList nextPut: aCostume].	overList nextPut: aCostume.! !!CMouseOverHandler methodsFor: 'event handling' stamp: 'ar 6/23/2003 02:05'!processMouseOver: anEvent	"Re-establish the z-order for all costumes wrt the given event"	| hand localEvt focus evt |	hand := anEvent hand.	leftList := mouseOverList asIdentitySet.	"Assume some coherence for the number of objects in over list"	overList := WriteStream on: (Array new: leftList size).	enteredList := WriteStream on: #().	"Now go looking for eventual mouse overs"	hand dispatchEvent: anEvent asMouseOver.	"Get out early if there's no change"	(leftList size = 0 and:[enteredList position = 0]) 		ifTrue:[^leftList := enteredList := overList := nil].	focus := hand mouseFocus.	"Send #mouseLeave as appropriate"	evt := anEvent asMouseLeave.	"Keep the order of the left costumes by recreating it from the mouseOverList"	leftList size > 1 ifTrue:[leftList := mouseOverList select:[:m| leftList includes: m]].	leftList do:[:m|		m signal: #mouseOverChanged.		localEvt := evt transformedBy: m costume globalToLocal.		m costume handleEvent: localEvt].	"Send #mouseEnter as appropriate"	evt := anEvent asMouseEnter.	enteredList ifNil: ["inform: was called in handleEvent:"		^leftList := enteredList := overList := nil].	enteredList := enteredList contents.	enteredList reverseDo:[:m|		m signal: #mouseOverChanged.		localEvt := evt transformedBy: m costume globalToLocal.		m costume handleEvent: localEvt].	"And remember the over list"	overList ifNil: ["inform: was called in handleEvent:"		^leftList := enteredList := overList := nil].	mouseOverList := overList contents.	leftList := enteredList := overList := nil.! !!CObject methodsFor: 'initialize' stamp: 'ar 3/1/2004 10:59'!becomeUniClass	"Make the receiver an instance of a unique class"	[self primitiveChangeClassTo: self class newUniClass basicNew] 		on: CDeprecatedFeature do:[:ex| ex resume: true].! !!CObject methodsFor: 'initialize' stamp: 'ar 3/21/2003 19:10'!destroy	"Destroy the receiver"	self signal: #destroy with: self. "the last message you ever hear"	self myEventMap: nil.	self myScripts do:[:script| script terminateScript].	self myScripts: nil.! !!CObject methodsFor: 'initialize' stamp: 'ar 9/25/2003 15:47'!initialize	"Initialize the receiver"! !!CObject methodsFor: 'user data' stamp: 'ar 3/24/2004 15:49'!userData	"Answer the receiver's userData properties. User data is intended for clients which want to associate certain idiosynchratic properties with objects in a specific context."	^self propertyValueAt: #userData! !!CObject methodsFor: 'user data' stamp: 'ar 3/24/2004 15:45'!userData: aDictionary	^self propertyValueAt: #userData put: aDictionary with: #userDataChanged! !!CObject methodsFor: 'user data' stamp: 'ar 3/24/2004 15:44'!userDataAt: aKey	^(self userData ifNil:[^nil]) at: aKey! !!CObject methodsFor: 'user data' stamp: 'ar 3/24/2004 15:44'!userDataAt: aKey ifAbsent: aBlock	^(self userData ifNil:[^aBlock value]) at: aKey ifAbsent: aBlock! !!CObject methodsFor: 'user data' stamp: 'ar 3/24/2004 15:48'!userDataAt: aKey put: aValue	| data |	data := self userData.	data ifNil:[		data := IdentityDictionary new.		self userData: data.	].	aValue ifNil:[		data removeKey: aKey ifAbsent:[].		data isEmpty ifTrue:[^self userData: nil].	].	self signal: #userDataChanged.	^data at: aKey put: aValue.! !!CObject methodsFor: 'basic' stamp: 'ar 3/15/2004 21:25'!components	"Answer the components defined in the receiver."	^self myComponents! !!CObject methodsFor: 'basic' stamp: 'ar 3/1/2004 10:52'!costume	"Answer the receiver's costume"	^nil! !!CObject methodsFor: 'basic' stamp: 'ar 3/1/2004 10:52'!costume: aCostume	"Make the receiver wear the given costume"	^nil! !!CObject methodsFor: 'basic' stamp: 'ar 3/15/2004 21:12'!define: componentName as: anObject	"Define the given object as being a component inside the receiver"	^self addComponent: anObject named: componentName! !!CObject methodsFor: 'basic' stamp: 'bf 7/22/2004 12:40'!name	"Answer the name of the receiver"	<bewareOf: #nameChanged>	^(self propertyValueAt: #name) ifNil:[self class nameForDisplay]! !!CObject methodsFor: 'basic' stamp: 'bf 3/30/2004 12:31'!name: aString	"Set the name of the receiver"	^self propertyValueAt: #name put: aString with: #nameChanged.! !!CObject methodsFor: 'basic' stamp: 'ar 3/1/2004 10:52'!player	"Answer the receiver's player"	^nil! !!CObject methodsFor: 'basic' stamp: 'ar 3/1/2004 10:52'!player: aPlayer	"Indicate the receiver's player"	^nil! !!CObject methodsFor: 'basic' stamp: 'ar 3/29/2004 00:38'!value	<bewareOf: #valueChanged>	^self propertyValueAt: #value ifAbsent:[nil]! !!CObject methodsFor: 'basic' stamp: 'ar 3/29/2004 00:38'!value: newValue	^self propertyValueAt: #value put: newValue with: #valueChanged! !!CObject methodsFor: 'basic' stamp: 'ar 3/6/2004 15:53'!valueType	^self value class! !!CObject methodsFor: 'testing' stamp: 'tk 6/19/2004 17:02'!isCObject	^ true! !!CObject methodsFor: 'testing' stamp: 'ar 3/1/2004 11:00'!isUniClass	"Answer whether I am a uniquely scripted object"	^self class isUniClass! !!CObject methodsFor: 'copying' stamp: 'ar 3/25/2004 19:08'!copy	"Create a copy of the receiver"	^self shallowCopy postCopy! !!CObject methodsFor: 'copying' stamp: 'ar 3/1/2004 10:53'!postCopy	"Perform any necessary operations after copying completed"	^self! !!CObject methodsFor: 'components' stamp: 'ar 3/15/2004 21:12'!addComponent: anObject named: componentName	"Define the given object as being a component inside the receiver"	| binding |	"Create a new binding"	binding := CComponentBinding new.	binding home: self.	binding key: componentName asSymbol.	binding value: anObject.	self addComponentBinding: binding.	^anObject! !!CObject methodsFor: 'components' stamp: 'ar 3/15/2004 21:03'!addComponentBinding: aBinding	"Add aBinding as a component binding to the receiver"	| oldBinding |	(aBinding isComponentBinding and:[aBinding home == self])		ifFalse:[^self error: 'Invalid component binding'].	myProperties ifNil:[myProperties := IdentityDictionary new].	oldBinding := myProperties removeBinding: aBinding key ifAbsent:[nil].	oldBinding ifNotNil:[oldBinding value: nil].	myProperties add: aBinding.! !!CObject methodsFor: 'components' stamp: 'ar 3/15/2004 20:09'!componentBinding	"Answer the receiver's component binding, e.g., the 'back link' to the component owner"	<bewareOf: #componentBindingChanged>	^self propertyValueAt: #componentBinding! !!CObject methodsFor: 'components' stamp: 'ar 3/15/2004 20:09'!componentBinding: aBinding	"Change the component binding associated with the receiver."	| myBinding |	"Carefully release the previous binding first"	(myBinding := self componentBinding) ifNotNil:[myBinding value: nil].	^self propertyValueAt: #componentBinding put: aBinding with: #componentBindingChanged! !!CObject methodsFor: 'components' stamp: 'tk 6/28/2004 12:33'!componentHome	"Answer the receiver's component owner (back link)"	| cb |	^ (cb _ self propertyValueAt: #componentBinding) 		ifNil: [nil]		ifNotNil: [cb home]! !!CObject methodsFor: 'components' stamp: 'ar 3/15/2004 20:11'!componentNamed: aSymbol	"Answer the component with the given name"	^self componentNamed: aSymbol ifAbsent:[nil]! !!CObject methodsFor: 'components' stamp: 'ar 3/15/2004 20:16'!componentNamed: aSymbol ifAbsent: aBlock	"Answer the component of the receiver with the given name"	| binding |	myProperties ifNil:[^aBlock value].	binding := myProperties bindingOf: aSymbol.	(binding == nil or:[binding isComponentBinding not]) ifTrue:[^aBlock value].	^binding value! !!CObject methodsFor: 'components' stamp: 'ar 3/24/2004 00:47'!fieldNamed: fieldName	"answer a reference to the field named fieldName"	^(CFieldReference new)		target: self;		fieldName: fieldName;		yourself! !!CObject methodsFor: 'components' stamp: 'ar 3/15/2004 21:10'!myComponents	"Private. Answer the components of the receiver. This is severely screwed up below since what we *mean* to do when being asked for the components is to respond with a read-only mapped collection. Since there is no such thing (and I am too tired to write a proper one right now) we:	a) Stupidly answer an empty id-dict if we have no properties at all. The reason we need to do this is that a client might ask for the 'keys' to get the names (Arrays don't answer their keys) and use it via #at:ifAbsent: (Array's screw up here).	b) Use our own implementation of #collect: since Dictionary>>collect: is severely screwed up too (answering an OrderedCollection instead of what it *should* answer - another dictionary)."	| result |	myProperties ifNil:[^IdentityDictionary new].	result := IdentityDictionary new.	myProperties associationsDo:[:binding|		binding isComponentBinding ifTrue:[result add: binding].	].	^result! !!CObject methodsFor: 'components' stamp: 'ar 3/15/2004 20:25'!removeComponentBinding: aBinding	"Remove aBinding from my components."	| oldBinding |	(aBinding isComponentBinding and:[aBinding home == self])		ifFalse:[^self error: 'Invalid component binding'].	myProperties ifNil:[^self].	oldBinding := myProperties removeKey: aBinding key ifAbsent:[nil].	oldBinding ifNotNil:[oldBinding value: nil].! !!CObject methodsFor: 'tweaking' stamp: 'ar 3/1/2004 10:53'!isTweaked	"Answer whether the receiver has been tweaked by the user"	self tweaks ifNotNil:[^true].	^self costume isTweaked! !!CObject methodsFor: 'tweaking' stamp: 'ar 3/1/2004 10:54'!readTweakedFieldsFrom: deSerializer	"Read all of the tweaked fields from the deSerializer"	| field oldValue newValue |	deSerializer fieldsDo:[:fieldName|		field := self class fieldNamed: fieldName.		field ifNotNil:[			oldValue := self getField: field.			newValue := deSerializer tweakField: fieldName value: oldValue.			(newValue equals: oldValue) ifFalse:[				self setField: field to: newValue.				self tweaked: fieldName from: oldValue to: newValue.			].		].	].! !!CObject methodsFor: 'tweaking' stamp: 'ar 3/15/2004 20:33'!tweaked: propName from: oldValue to: newValue	"Remember the tweak of the given property from its previous to its new value.	Answer true if the receiver is newly changed or reverted back to unchanged."	| owner |	(super tweaked: propName from: oldValue to: newValue) ifFalse:[^false].	"Note: we need to notify the player so the player can notify its home (if any).	This feels wrong (don't ask me why)... but right now that seems to be the only	way to make it work."	(owner := self player) ifNotNil:[owner tweakedCostume: self].	"Finally, notify my model if any"	(owner := self componentBinding) ifNotNil:[owner tweakedComponent: self].	^true! !!CObject methodsFor: 'tweaking' stamp: 'ar 2/29/2004 00:41'!tweakedCostume: aCostume	"Broadcast tweaks happened to aCostume.	This feels wrong ... see the senders"	self costume == aCostume 		ifTrue:[self tweaked: #costume from: aCostume to: aCostume].! !!CObject methodsFor: 'tweaking' stamp: 'ar 3/1/2004 10:54'!tweaks	"Answer the tweaks associated with the receiver"	^self propertyValueAt: #myTweaks! !!CObject methodsFor: 'tweaking' stamp: 'ar 3/1/2004 10:54'!tweaks: aDictionary	"Set the tweaks associated with the receiver"	^self propertyValueAt: #myTweaks put: aDictionary with: #tweaksChanged! !!CObject methodsFor: 'tweaking' stamp: 'ar 3/3/2004 16:40'!writeTweakedFieldsOn: aSerializer	"Write all of the tweaked fields on aSerializer"	| changeList newValue |	changeList := self tweaks ifNil:[^self].	changeList removeKey: #costume ifAbsent:[].	self costume isTweaked ifTrue:[		aSerializer writeField: #costume value: self costume.	].	changeList keysAndValuesDo:[:fieldName :chgRec|		newValue := self get: fieldName.		aSerializer writeField: fieldName value: newValue.	].! !!CObject methodsFor: 'serializing' stamp: 'ar 3/1/2004 10:56'!postBuildWith: aMaker	"Do any necessary post-construction activity"	myScripts ifNotNil:[myScripts do:[:each| each resumeScript]].! !!CObject methodsFor: 'serializing' stamp: 'ar 3/14/2004 15:02'!readFieldsFrom: deserializer	"Read my fields from the given deSerializer"	self readFixedFieldsFrom: deserializer.	self readPropertiesFrom: deserializer.! !!CObject methodsFor: 'serializing' stamp: 'ar 3/14/2004 15:24'!readFixedFieldsFrom: deserializer	"Read all of the fixed fields from the deserializer. 	Fixed fields in this context means all of the receiver's 	instance variables which must be deserialized before	the variable properties in the receiver."	myScripts := deserializer readField: #scripts ifAbsent:[myScripts].! !!CObject methodsFor: 'serializing' stamp: 'ar 3/14/2004 15:22'!readPropertiesFrom: deserializer	"Read my fields from the given deSerializer"	| theClass fields theField |	theClass := self class.	[theClass == Object] whileFalse:[		fields := theClass classFields.		1 to: fields size do:[:i|			theField := fields at: i.			theField deserializer 				ifNil:[self readProperty: theField name from: deserializer]				ifNotNil:[self perform: theField deserializer with: deserializer].		].		theClass := theClass superclass	].! !!CObject methodsFor: 'serializing' stamp: 'ar 3/27/2004 20:53'!readProperty: propName from: deSerializer	"Read the given property from deSerializer"	| aValue |	aValue := deSerializer readField: propName ifAbsent:[^nil].	^self propertyValueAt: propName put: aValue! !!CObject methodsFor: 'serializing' stamp: 'ar 3/27/2004 20:44'!readProperty: propName from: deSerializer with: changeEvent	"Read the given property from deSerializer"	| aValue |	aValue := deSerializer readField: propName ifAbsent:[^nil].	^self propertyValueAt: propName put: aValue" with: changeEvent"! !!CObject methodsFor: 'serializing' stamp: 'ar 3/11/2004 03:14'!readValueFrom: deSerializer	"Read the my value from deSerializer"	<deserialize: #value>	self readProperty: #value from: deSerializer! !!CObject methodsFor: 'serializing' stamp: 'ar 3/1/2004 10:57'!serializeOn: aSerializer	"Serialize the receiver on aSerializer"	^aSerializer writeScripted: self.! !!CObject methodsFor: 'serializing' stamp: 'ar 3/14/2004 15:02'!writeFieldsOn: serializer	"Write my fields on the given serializer"	self writeFixedFieldsOn: serializer.	self writePropertiesOn: serializer.! !!CObject methodsFor: 'serializing' stamp: 'ar 3/14/2004 15:43'!writeFixedFieldsOn: serializer	"Write all of the fixed fields on the serializer. 	Fixed fields in this context means all of the receiver's 	instance variables which must be serialized before	the variable properties in the receiver."	serializer writeField: #scripts value: myScripts.! !!CObject methodsFor: 'serializing' stamp: 'ar 3/14/2004 15:01'!writePropertiesOn: aSerializer	"Write my property fields on the given serializer"	| theClass fields theField |	theClass := self class.	[theClass == Object] whileFalse:[		fields := theClass classFields.		1 to: fields size do:[:i|			theField := fields at: i.			theField serializer 				ifNil:[self writeProperty: theField name on: aSerializer]				ifNotNil:[self perform: theField serializer with: aSerializer].		].		theClass := theClass superclass	].! !!CObject methodsFor: 'serializing' stamp: 'ar 3/1/2004 10:58'!writeProperty: propName on: serializer	"Write the given property on the serializer"	myProperties ifNil:[^self].	serializer writeField: propName value: (myProperties at: propName ifAbsent:[^self]).! !!CObject methodsFor: 'serializing' stamp: 'ar 3/11/2004 02:10'!writeValueOn: aSerializer	"Write my value on aSerializer"	<serialize: #value>	self writeProperty: #value on: aSerializer.! !!CObject methodsFor: 'properties' stamp: 'ar 3/1/2004 10:58'!propertyValueAt: key	"Answer the value of my property at key"	myProperties ifNil:[^nil].	^myProperties at: key ifAbsent:[nil]! !!CObject methodsFor: 'properties' stamp: 'ar 3/1/2004 10:58'!propertyValueAt: key ifAbsent: aBlock	"Answer the value of my property at key"	myProperties ifNil:[^aBlock value].	^myProperties at: key ifAbsent: aBlock! !!CObject methodsFor: 'properties' stamp: 'ar 3/1/2004 10:58'!propertyValueAt: key ifAbsentPut: aBlock	"Answer the value of my property at key"	^self propertyValueAt: key ifAbsent:[		self propertyValueAt: key put: aBlock value	].! !!CObject methodsFor: 'properties' stamp: 'ar 3/27/2004 21:10'!propertyValueAt: key put: aValue	"Store the value of my property at key"	myProperties ifNil:[myProperties := IdentityDictionary new].	myProperties at: key put: aValue.	^aValue! !!CObject methodsFor: 'properties' stamp: 'ar 9/8/2004 16:23'!propertyValueAt: key put: newValue with: changeEvent	"Store the value of my property at key"	| oldValue |	myProperties ifNil:[myProperties := IdentityDictionary new].	oldValue := myProperties atProperty: key put: newValue.	oldValue == newValue ifTrue:[^newValue].	self signalChanged: changeEvent from: oldValue to: newValue.	^newValue! !!CObject methodsFor: 'properties' stamp: 'ar 3/1/2004 10:59'!removePropertyNamed: key	"Remove the property with the given key"	myProperties ifNil:[^nil].	^myProperties removeKey: key ifAbsent:[nil]! !!CObject methodsFor: 'private' stamp: 'ar 8/13/2003 00:26'!confirm: queryString	ActiveHand isPlayer ifTrue:[^CDialog confirm: queryString].	^super confirm: queryString! !!CObject methodsFor: 'private' stamp: 'tk 6/19/2004 17:09'!get: varName		| aGetter |	(aGetter _ varName) last == $: ifTrue: ["allow borderWidth:, and retrieve borderWidth"		aGetter _ (varName copyFrom: 1 to: (varName indexOf: $:)) asSymbol].	^ [self perform: aGetter] on: MessageNotUnderstood do:[:ex| ex return: nil].! !!CObject methodsFor: 'private' stamp: 'ar 3/27/2004 00:53'!inform: queryString	ActiveHand isPlayer ifTrue:[^CDialog inform: queryString].	^super inform: queryString! !!CObject methodsFor: 'private' stamp: 'ar 2/11/2003 15:19'!myEventMap	^myEventMap! !!CObject methodsFor: 'private' stamp: 'ar 2/11/2003 15:19'!myEventMap: anEventMap	myEventMap := anEventMap.! !!CObject methodsFor: 'private' stamp: 'tk 6/13/2004 13:10'!myProperties	^myProperties! !!CObject methodsFor: 'private' stamp: 'ar 2/11/2003 15:19'!myScripts	^myScripts ifNil:[#()]! !!CObject methodsFor: 'private' stamp: 'ar 2/11/2003 15:19'!myScripts: scriptList	myScripts := scriptList.! !!CObject methodsFor: 'private' stamp: 'ar 8/13/2003 00:43'!printOn: aStream	"| vv |	vv := self value."	aStream nextPutAll: self name.	"vv == self ifFalse:[		aStream nextPutAll: '<'; print: vv; nextPutAll:'>'.	]."! !!CObject methodsFor: 'private' stamp: 'ar 3/11/2004 15:01'!set: varName to: newValue	^self perform: (varName,':') asSymbol with: newValue! !!CObject methodsFor: '* tk script' stamp: 'tk 6/13/2004 14:57'!equiv: anotherCObject	"Return true if self has all of the same fields and values as anotherObject.  Used to tell if a script that reconstructs an object is actually working."	| strm1 strm2 frag1 frag2 pos1 refs lens zz |	strm1 _ ReadWriteStream on: (String new: 20000).	CObjectMakerSerializer serialize: self on: strm1.	strm2 _ ReadWriteStream on: (String new: 20000).	CObjectMakerSerializer serialize: anotherCObject on: strm2.	"Compare the two streams, ignoring all 'object ref's and all 'player refs'. "	"strm1 size = strm2 size ifFalse: [^ 'size mismatch']."	"rare exception: refs are diff size"	strm1 reset. strm2 reset.	refs _ #(object player receiver item).	lens _ refs collect: [:ss | (ss, ' ref="') size].	[	frag1 _ strm1 upTo: $<.		frag2 _ strm2 upTo: $<.		frag1 = frag2 ifFalse: [self error: frag1, ' IS NOT ', frag2].		1 to: refs size do: [:ii | 			pos1 _ strm1 position.			(strm1 next: (lens at: ii)) = (zz _ (refs at: ii), ' ref="')				ifTrue: [(strm2 next: (lens at: ii)) = zz ifFalse: [^ 'strm2 does not have', zz].					strm1 upTo: $".	"skip the actual unique ref"					strm2 upTo: $"]				ifFalse: [strm1 position: pos1]].		strm1 atEnd] whileFalse.	^ true! !!CCollectionBase methodsFor: 'accessing' stamp: 'ar 3/16/2004 15:36'!at: aKey	"Answer the element at the given key"	^elements at: aKey! !!CCollectionBase methodsFor: 'accessing' stamp: 'ar 3/16/2004 15:36'!at: aKey ifAbsent: aBlock	"Answer the element at the given key or evaluate the given block if there is no element with the given key"	^elements at: aKey ifAbsent: aBlock! !!CCollectionBase methodsFor: 'accessing' stamp: 'ar 3/16/2004 15:37'!at: aKey put: anObject	"Store anObject under the given key in the receiver"	^elements at: aKey put: anObject! !!CCollectionBase methodsFor: 'accessing' stamp: 'ar 3/16/2004 10:45'!contentType	"Answer the type of the elements stored in the receiver"	^elements contentType! !!CCollectionBase methodsFor: 'accessing' stamp: 'ar 3/16/2004 11:01'!contents	"Answer the contents of the receiver"	^self copyFrom: 1 to: self size! !!CCollectionBase methodsFor: 'accessing' stamp: 'ar 3/16/2004 11:01'!contents: newContents	"Set the contents of the receiver"	self removeAll.	self addAll: newContents.! !!CCollectionBase methodsFor: 'accessing' stamp: 'ar 3/16/2004 15:38'!cursor	"Answer the receiver's cursor"	<bewareOf: #cursorChanged>	^elements cursor! !!CCollectionBase methodsFor: 'accessing' stamp: 'ar 3/16/2004 15:38'!cursor: aValue	"Modifiy the receiver's cursor"	^elements cursor: aValue! !!CCollectionBase methodsFor: 'accessing' stamp: 'ar 3/16/2004 17:06'!defaultElement	"Answer the default element for the receiver"	^nil! !!CCollectionBase methodsFor: 'accessing' stamp: 'ar 3/16/2004 10:57'!elements	"Answer the elements of the receiver"	<bewareOf: #elementsChanged>	^self propertyValueAt: #elements! !!CCollectionBase methodsFor: 'accessing' stamp: 'ar 3/16/2004 10:57'!elements: aCollectionClient	"Answer the elements of the receiver"	^self propertyValueAt: #elements put: aCollectionClient with: #elementsChanged! !!CCollectionBase methodsFor: 'accessing' stamp: 'ar 3/16/2004 10:46'!first	"Answer the first element of the receiver"	^self at: 1! !!CCollectionBase methodsFor: 'accessing' stamp: 'ar 3/16/2004 10:46'!last	"Answer the last element in the receiver"	^self at: self size! !!CCollectionBase methodsFor: 'accessing' stamp: 'bf 5/4/2004 17:00'!selection	"Answer the currently selected object - that is the object at the cursor's position"	<bewareOf: #cursorChanged>	(self cursor between: 1 and: self size) ifFalse:[^self defaultElement].	^self at: cursor! !!CCollectionBase methodsFor: 'accessing' stamp: 'ar 3/16/2004 10:46'!selection: anObject	"Set the currently selected object - that is move the cursor's position to point to anObject"	cursor := self indexOf: anObject.	^anObject! !!CCollectionBase methodsFor: 'accessing' stamp: 'bf 5/4/2004 17:00'!selectionIndex	"a convenient alias to the cursor"	<bewareOf: #cursorChanged>	^cursor! !!CCollectionBase methodsFor: 'accessing' stamp: 'ar 3/16/2004 10:46'!selectionIndex: newIndex	"a convenient alias to the cursor"	^cursor := newIndex! !!CCollectionBase methodsFor: 'accessing' stamp: 'ar 3/16/2004 10:46'!size	"Delegate to our elements"	^elements size! !!CCollectionBase methodsFor: 'accessing' stamp: 'ar 3/16/2004 16:57'!species	^CCollection! !!CCollectionBase methodsFor: 'adding' stamp: 'ar 3/16/2004 10:46'!add: newObject 	"Include newObject as one of the receiver's elements. Answer newObject."	^self addLast: newObject! !!CCollectionBase methodsFor: 'adding' stamp: 'ar 3/16/2004 15:10'!add: newObject after: oldObject	"Insert newObject after oldObject"	^self add: newObject at: (self indexOf: oldObject ifAbsent:[1])! !!CCollectionBase methodsFor: 'adding' stamp: 'ar 3/16/2004 14:34'!add: anObject at: anIndex	"Insert the given object at the specified index"	^elements add: anObject at: anIndex.! !!CCollectionBase methodsFor: 'adding' stamp: 'ar 3/16/2004 14:38'!add: newObject before: oldObject				 	 	"Add the argument, newObject, as an element of the receiver. Put it in 	the sequence just preceding oldObject. Answer newObject."	^self add: newObject at: (self indexOf: oldObject ifAbsent:[1])! !!CCollectionBase methodsFor: 'adding' stamp: 'ar 3/16/2004 14:32'!addAll: aCollection 	"Include all the elements of aCollection as the receiver's elements."	^self addAll: aCollection at: self size+1! !!CCollectionBase methodsFor: 'adding' stamp: 'ar 3/16/2004 15:12'!addAll: aCollection after: oldObject	"Insert the given object before the specified index"	^self addAll: aCollection at: (self indexOf: oldObject ifAbsent:[self size]) + 1.! !!CCollectionBase methodsFor: 'adding' stamp: 'ar 3/16/2004 14:43'!addAll: aCollection at: anIndex	"Insert the given object before the specified index"	^elements addAll: aCollection at: anIndex! !!CCollectionBase methodsFor: 'adding' stamp: 'ar 3/16/2004 15:12'!addAll: aCollection before: oldObject	"Insert the given object before the specified index"	^self addAll: aCollection at: (self indexOf: oldObject ifAbsent:[1]).! !!CCollectionBase methodsFor: 'adding' stamp: 'ar 3/16/2004 14:35'!addFirst: newObject 	"Include newObject as one of the receiver's elements. Answer newObject. 	ArrayedCollections cannot respond to this message."	^self add: newObject at: 1.! !!CCollectionBase methodsFor: 'adding' stamp: 'ar 3/16/2004 14:35'!addLast: newObject 	"Include newObject as one of the receiver's elements. Answer newObject. 	ArrayedCollections cannot respond to this message."	self add: newObject at: self size+1.! !!CCollectionBase methodsFor: 'removing' stamp: 'ar 3/16/2004 10:47'!remove: oldObject 	"Remove oldObject from the receiver's elements. Answer oldObject 	unless no element is equal to oldObject, in which case, raise an error.	ArrayedCollections cannot respond to this message."	^ self remove: oldObject ifAbsent: [nil]! !!CCollectionBase methodsFor: 'removing' stamp: 'ar 3/16/2004 10:48'!remove: oldObject ifAbsent: aBlock 	"Remove oldObject from the receiver's elements. If several of the 	elements are equal to oldObject, only one is removed. If no element is 	equal to oldObject, answer the result of evaluating anExceptionBlock. 	Otherwise, answer the argument, oldObject. ArrayedCollections cannot 	respond to this message."	^self removeAt: (self indexOf: oldObject ifAbsent:[^aBlock value])! !!CCollectionBase methodsFor: 'removing' stamp: 'ar 3/16/2004 10:48'!removeAll	"Remove all elements from the receiver"	elements removeAll.! !!CCollectionBase methodsFor: 'removing' stamp: 'ar 3/16/2004 10:48'!removeAll: aCollection 	"Remove each element of aCollection from the receiver. If successful for 	each, answer aCollection. Otherwise create an error notification.	ArrayedCollections cannot respond to this message."	aCollection do: [:each | self remove: each].! !!CCollectionBase methodsFor: 'removing' stamp: 'ar 3/16/2004 10:48'!removeAt: index	"Remove an element from the receiver"	^self removeFrom: index to: index! !!CCollectionBase methodsFor: 'removing' stamp: 'ar 3/16/2004 10:48'!removeFirst	"Remove the first element of the receiver"	self removeAt: 1! !!CCollectionBase methodsFor: 'removing' stamp: 'ar 3/16/2004 10:48'!removeFrom: firstIndex to: lastIndex	"Remove all the elements from firstIndex to lastIndex"	^elements removeFrom: firstIndex to: lastIndex! !!CCollectionBase methodsFor: 'removing' stamp: 'ar 3/16/2004 10:48'!removeLast	"Remove the last element from the receiver"	^self removeAt: self size! !!CCollectionBase methodsFor: 'testing' stamp: 'ar 3/16/2004 10:48'!isEmpty	"Answer whether the receiver contains any elements."	^self size = 0! !!CCollectionBase methodsFor: 'searching' stamp: 'ar 3/16/2004 10:48'!detect: aBlock 	"Evaluate aBlock with each of the receiver's elements as the argument. 	Answer the first element for which aBlock evaluates to true."	^self detect: aBlock ifNone:[nil]! !!CCollectionBase methodsFor: 'searching' stamp: 'ar 3/16/2004 10:48'!detect: aBlock ifNone: exceptionBlock 	"Evaluate aBlock with each of the receiver's elements as the argument.  	Answer the first element for which aBlock evaluates to true. If none  	evaluate to true, then evaluate the argument, exceptionBlock."	self do: [:each | (aBlock value: each) ifTrue: [^ each]].	^exceptionBlock value! !!CCollectionBase methodsFor: 'searching' stamp: 'ar 3/16/2004 17:22'!findFirstElement: aBlock	"Answer my first element for which aBlock evaluates as true."	self do:[:each| (aBlock value: each) ifTrue:[^each]].	^self defaultElement! !!CCollectionBase methodsFor: 'searching' stamp: 'ar 3/16/2004 17:23'!findFirstIndex: aBlock	"Answer the index of my first element for which aBlock evaluates as true."	1 to: self size do:[:i| (aBlock value: (self at: i)) ifTrue:[^i]].	^0! !!CCollectionBase methodsFor: 'searching' stamp: 'ar 3/16/2004 17:22'!findLastElement: aBlock	"Answer my last element for which aBlock evaluates as true."	self reverseDo:[:each| (aBlock value: each) ifTrue:[^each]].	^self defaultElement! !!CCollectionBase methodsFor: 'searching' stamp: 'ar 3/16/2004 17:24'!findLastIndex: aBlock	"Answer the index of my first element for which aBlock evaluates as true."	self size to: 1 by: -1 do:[:i| (aBlock value: (self at: i)) ifTrue:[^i]].	^0! !!CCollectionBase methodsFor: 'searching' stamp: 'ar 3/16/2004 10:51'!includes: anObject 	"Answer whether anObject is one of the receiver's elements."	^ self anySatisfy: [:each | each = anObject]! !!CCollectionBase methodsFor: 'searching' stamp: 'ar 3/16/2004 10:52'!indexOf: anObject	"Answer the index of the given object within the receiver"	^self indexOf: anObject ifAbsent:[0]! !!CCollectionBase methodsFor: 'searching' stamp: 'ar 3/16/2004 10:52'!indexOf: anElement ifAbsent: exceptionBlock	"Answer the index of the first occurence of anElement within the  	receiver. If the receiver does not contain anElement, answer the 	result of evaluating the argument, exceptionBlock."	^self indexOf: anElement startingAt: 1 ifAbsent: exceptionBlock! !!CCollectionBase methodsFor: 'searching' stamp: 'ar 3/16/2004 10:52'!indexOf: anElement startingAt: start ifAbsent: exceptionBlock	"Answer the index of the first occurence of anElement after start	within the receiver. If the receiver does not contain anElement, 	answer the 	result of evaluating the argument, exceptionBlock."	^elements indexOf: anElement startingAt: start ifAbsent: exceptionBlock! !!CCollectionBase methodsFor: 'replacing' stamp: 'ar 3/16/2004 12:49'!replace: oldObject with: newObject	"Replace oldObject with newObject"	| index |	oldObject == newObject ifTrue:[^self].	newObject ifNil:[^self remove: oldObject].	oldObject ifNil:[^self add: newObject].	index := self indexOf: oldObject ifAbsent:[^nil].	^self replaceFrom: index to: index with: (Array with: newObject)! !!CCollectionBase methodsFor: 'replacing' stamp: 'ar 3/16/2004 10:53'!replaceFrom: firstIndex to: lastIndex with: aCollection	"Replace the elements in the receiver"	^self replaceFrom: firstIndex to: lastIndex with: aCollection startingAt: 1! !!CCollectionBase methodsFor: 'replacing' stamp: 'ar 3/16/2004 10:53'!replaceFrom: firstIndex to: lastIndex with: aCollection startingAt: replStart	^elements replaceFrom: firstIndex to: lastIndex with: aCollection startingAt: replStart! !!CCollectionBase methodsFor: 'streaming' stamp: 'ar 3/16/2004 10:53'!atEnd	"answer whether the receiver is at its end"	^cursor >= self size! !!CCollectionBase methodsFor: 'streaming' stamp: 'ar 3/16/2004 10:53'!atStart	"answer whether the receiver is at its start"	^cursor <= 1! !!CCollectionBase methodsFor: 'streaming' stamp: 'bf 5/10/2004 17:44'!next	"go to the next element in the receiver"	self isEmpty ifTrue:[^self defaultElement].	self atEnd ifTrue:[		wrapCursor ifFalse:[^self defaultElement].		^self at: (cursor := 1).	].	^self at: (cursor := cursor  + 1)! !!CCollectionBase methodsFor: 'streaming' stamp: 'ar 3/16/2004 10:53'!peek	"answer the element at the receiver's cursor"	(cursor between: 1 and: self size) ifFalse:[^self defaultElement].	^self at: cursor! !!CCollectionBase methodsFor: 'streaming' stamp: 'bf 5/10/2004 17:45'!prev	"go to the previous element in the receiver"	self isEmpty ifTrue:[^self defaultElement].	self atStart ifTrue:[		wrapCursor ifFalse:[^self defaultElement].		^self at: (cursor := self size).	].	^self at: (cursor := cursor - 1)! !!CCollectionBase methodsFor: 'streaming' stamp: 'ar 3/16/2004 10:53'!wrapCursor	"Delegate wrapCursor to our elements"	<bewareOf: #wrapCursorChanged>	^elements wrapCursor! !!CCollectionBase methodsFor: 'streaming' stamp: 'ar 3/16/2004 10:54'!wrapCursor: aBool	"Delegate wrapCursor to our elements"	^elements wrapCursor: aBool! !!CCollectionBase methodsFor: 'enumerating' stamp: 'ar 3/16/2004 10:54'!allSatisfy: aBlock	"Evaluate aBlock with the elements of the receiver.	If aBlock returns false for any element return false.	Otherwise return true."	self do: [:each | (aBlock value: each) ifFalse: [^false]].	^true! !!CCollectionBase methodsFor: 'enumerating' stamp: 'ar 3/16/2004 10:54'!anySatisfy: aBlock	"Evaluate aBlock with the elements of the receiver.	If aBlock returns true for any element return true.	Otherwise return false."	self do: [:each | (aBlock value: each) ifTrue: [^ true]].	^ false! !!CCollectionBase methodsFor: 'enumerating' stamp: 'ar 3/16/2004 15:47'!collect: aBlock	"Evaluate aBlock with each of the receiver's elements as the argument.  	Collect the resulting values into a collection like the receiver. Answer  	the new collection."	^self collect: aBlock species: self species! !!CCollectionBase methodsFor: 'enumerating' stamp: 'ar 3/16/2004 15:49'!collect: aBlock species: aClass	"Evaluate aBlock with each of the receiver's elements as the argument.  	Collect the resulting values into a collection like aClass. Answer  	the new collection."	| newCollection |	newCollection _ aClass new.	1 to: self size do:[:i | newCollection add: (aBlock value: (self at: i))].	^ newCollection! !!CCollectionBase methodsFor: 'enumerating' stamp: 'ar 3/16/2004 10:54'!do: aBlock	"Evaluate aBlock with each of the receiver's elements as the argument."	^elements do: aBlock! !!CCollectionBase methodsFor: 'enumerating' stamp: 'ar 3/16/2004 10:55'!keysAndValuesDo: aBlock	"Evaluate aBlock with each of the receiver's keys and values"	^elements keysAndValuesDo: aBlock! !!CCollectionBase methodsFor: 'enumerating' stamp: 'ar 3/16/2004 17:20'!reverseDo: aBlock	^elements do: aBlock! !!CCollectionBase methodsFor: 'enumerating' stamp: 'ar 3/16/2004 10:55'!select: aBlock 	"Evaluate aBlock with each of the receiver's elements as the argument. 	Collect into a new collection like the receiver, only those elements for 	which aBlock evaluates to true. Answer the new collection."	| newCollection |	newCollection _ self species new.	self do: [:each | (aBlock value: each) ifTrue: [newCollection add: each]].	^newCollection! !!CCollectionBase methodsFor: 'enumerating' stamp: 'ar 3/16/2004 15:48'!select: aBlock species: aClass	"Evaluate aBlock with each of the receiver's elements as the argument. 	Collect into a new collection like aClass, only those elements for 	which aBlock evaluates to true. Answer the new collection."	| newCollection |	newCollection _ aClass new.	self do: [:each | (aBlock value: each) ifTrue: [newCollection add: each]].	^newCollection! !!CCollectionBase methodsFor: 'copying' stamp: 'ar 3/16/2004 10:55'!copyFrom: firstIndex to: lastIndex	"Answer a copy of a subset of the receiver, starting from element at 	index start until element at index stop."	^elements copyFrom: firstIndex to: lastIndex! !!CCollectionBase methodsFor: 'copying' stamp: 'ar 3/16/2004 17:59'!reversed	"Answer a copy of the receiver with element order reversed."	| newCollection |	newCollection _ self class new. "@@@ Is this correct??? @@@"	self reverseDo:[:each| newCollection add: each].	^newCollection! !!CCollectionBase methodsFor: 'matching' stamp: 'ar 3/16/2004 10:55'!all	"Answer a new all matcher"	^CAllMatcher on: self! !!CCollectionBase methodsFor: 'matching' stamp: 'ar 3/16/2004 10:55'!any	"Answer a new any matcher"	^CAnyMatcher on: self! !!CCollectionBase methodsFor: 'printing' stamp: 'ar 3/16/2004 16:58'!printElementsOn: aStream	aStream nextPut: $(.	self do: [:element | aStream print: element; space].	self isEmpty ifFalse: [aStream skip: -1].	aStream nextPut: $)! !!CCollectionBase methodsFor: 'printing' stamp: 'ar 3/16/2004 16:58'!printNameOn: aStream	super printOn: aStream! !!CCollectionBase methodsFor: 'printing' stamp: 'ar 3/16/2004 16:58'!printOn: aStream 	"Append a sequence of characters that identify the receiver to aStream."	self printNameOn: aStream.	self printElementsOn: aStream! !!CCollectionBase methodsFor: 'converting' stamp: 'ar 3/22/2004 21:14'!asArray	^Array withAll: self! !!CCollectionBase methodsFor: 'sorting' stamp: 'bf 9/30/2004 13:44'!sort	"Sort this collection into ascending order using the '<=' operator."	self sort: [:a :b | a <= b]! !!CCollectionBase methodsFor: 'sorting' stamp: 'bf 9/30/2004 13:45'!sort: aSortBlock	"Sort this collection using aSortBlock. The block should take two arguments and return true if the first element should preceed the second one."	elements sort: aSortBlock! !!CCollection methodsFor: 'initialize' stamp: 'ar 3/16/2004 12:38'!initialize	super initialize.	values := #().	cursor := 0.! !!CCollection methodsFor: 'accessing' stamp: 'ar 3/16/2004 10:59'!at: aKey	"Answer the element at the given key"	^values at: aKey! !!CCollection methodsFor: 'accessing' stamp: 'ar 3/16/2004 10:59'!at: aKey ifAbsent: aBlock	"Answer the element at the given key or evaluate the given block if there is no element with the given key"	^values at: aKey ifAbsent: aBlock! !!CCollection methodsFor: 'accessing' stamp: 'ar 3/24/2004 20:54'!at: aKey put: anObject	"Store anObject under the given key in the receiver"	values at: aKey put: anObject.	self contentsChanged: #replace with: aKey with: aKey.	^anObject! !!CCollection methodsFor: 'accessing' stamp: 'ar 3/7/2004 17:42'!contentType	"Answer the type of the elements stored in the receiver"	^nil! !!CCollection methodsFor: 'accessing' stamp: 'ar 3/16/2004 11:00'!contents	"Answer the contents of the receiver"	^values shallowCopy! !!CCollection methodsFor: 'accessing' stamp: 'ar 3/16/2004 11:01'!contents: newContents	"Set the contents of the receiver"	| selected |	newContents == self ifTrue:[^self].	selected := self selection.	self removeAll.	self addAll: newContents.	self selection: selected.	^newContents! !!CCollection methodsFor: 'accessing' stamp: 'ar 3/11/2004 14:12'!cursor	^cursor! !!CCollection methodsFor: 'accessing' stamp: 'ar 9/8/2004 16:21'!cursor: aValue	| oldCursor |	cursor = aValue ifTrue:[^aValue].	oldCursor := cursor.	cursor := (aValue min: self size max: 0).	self signalChanged: #cursorChanged from: oldCursor to: cursor.	^aValue! !!CCollection methodsFor: 'accessing' stamp: 'ar 6/28/2003 20:55'!defaultElement	^nil! !!CCollection methodsFor: 'accessing' stamp: 'ar 3/16/2004 11:02'!size	"Answer the number of elements in the receiver"	^values size! !!CCollection methodsFor: 'accessing' stamp: 'ar 3/16/2004 12:39'!wrapCursor	^self propertyValueAt: #wrapCursor ifAbsent:[false]! !!CCollection methodsFor: 'accessing' stamp: 'ar 3/16/2004 12:39'!wrapCursor: aBool	^self propertyValueAt: #wrapCursor put: aBool with: #wrapCursorChanged! !!CCollection methodsFor: 'adding' stamp: 'ar 3/24/2004 20:54'!add: anObject at: index	"Insert the given object before the specified index"	| newData |	newData _ Array new: values size+1.	newData replaceFrom: 1 to: index-1 with: values startingAt: 1.	newData at: index put: anObject.	newData replaceFrom: index+1 to: newData size with: values startingAt: index.	values _ newData.	self contentsChanged: #insert with: index with: index.	index <= cursor ifTrue:[self cursor: cursor + 1].	^anObject! !!CCollection methodsFor: 'adding' stamp: 'ar 3/24/2004 20:54'!addAll: aCollection at: index	"Insert the given object before the specified index"	| sz newData |	sz _ aCollection size.	newData _ Array new: values size + sz.	newData replaceFrom: 1 to: index-1 with: values startingAt: 1.	newData replaceFrom: index to: index+sz-1 with: aCollection startingAt: 1.	newData replaceFrom: index+sz to: newData size with: values startingAt: index.	values _ newData.	self contentsChanged: #insert with: index with: index+sz-1.	index <= cursor ifTrue:[self cursor: cursor + sz].	^aCollection! !!CCollection methodsFor: 'removing' stamp: 'ar 3/24/2004 20:54'!removeAll	"Remove all elements from the receiver"	| sz |	sz _ values size.	values _ #().	sz > 0 ifTrue:[self contentsChanged: #remove with: 1 with: sz].	self cursor: 0.! !!CCollection methodsFor: 'removing' stamp: 'ar 3/24/2004 20:54'!removeFrom: firstIndex to: lastIndex	"Remove all the elements from firstIndex to lastIndex"	| sz newData |	sz _ lastIndex - firstIndex+1.	sz <= 0 ifTrue:[^self].	newData _ Array new: values size - sz.	newData replaceFrom: 1 to: firstIndex-1 with: values startingAt: 1.	newData replaceFrom: firstIndex to: newData size with: values startingAt: lastIndex+1.	values _ newData.	self contentsChanged: #remove with: firstIndex with: lastIndex.	cursor < firstIndex ifFalse:[		cursor <= lastIndex			ifTrue:[self cursor: 0]			ifFalse:[self cursor: cursor - sz]].! !!CCollection methodsFor: 'enumerating' stamp: 'ar 2/22/2004 01:55'!do: aBlock	"Evaluate aBlock with each of the receiver's elements as the argument."	1 to: values size do:[:i| aBlock value: (values at: i)].! !!CCollection methodsFor: 'enumerating' stamp: 'ar 3/16/2004 11:07'!keysAndValuesDo: aBlock	"Evaluate aBlock with each of the receiver's keys and values"	1 to: values size do:[:i| aBlock value: i value: (values at: i)].! !!CCollection methodsFor: 'enumerating' stamp: 'ar 3/16/2004 17:20'!reverseDo: aBlock	"Evaluate aBlock with each of the receiver's elements as the argument."	values size to: 1 by: -1 do:[:i| aBlock value: (values at: i)].! !!CCollection methodsFor: 'copying' stamp: 'ar 3/17/2004 02:26'!copyFrom: firstIndex to: lastIndex	"Answer a copy of a subset of the receiver, starting from element at 	index start until element at index stop."	| newCollection |	newCollection _ self species new.	firstIndex to: lastIndex do:[:i| newCollection add: (self at: i)].	^newCollection! !!CCollection methodsFor: 'copying' stamp: 'ar 3/24/2004 20:54'!replaceFrom: firstIndex to: lastIndex with: aCollection startingAt: replStart	values replaceFrom: firstIndex to: lastIndex with: aCollection startingAt: replStart.	self contentsChanged: #replace with: firstIndex with: lastIndex.! !!CCollection methodsFor: 'searching' stamp: 'ar 3/13/2004 03:17'!indexOf: anElement startingAt: start ifAbsent: exceptionBlock	"Answer the index of the first occurence of anElement after start	within the receiver. If the receiver does not contain anElement, 	answer the 	result of evaluating the argument, exceptionBlock."	start to: self size do:[:index |		((self at: index) equals: anElement) ifTrue: [^ index]].	^ exceptionBlock value! !!CCollection methodsFor: 'serializing' stamp: 'ar 3/22/2004 02:37'!readFixedFieldsFrom: deSerializer	values := deSerializer readField: #values.	cursor := deSerializer readField: #cursor.	^super readFixedFieldsFrom: deSerializer.! !!CCollection methodsFor: 'serializing' stamp: 'ar 3/22/2004 02:37'!writeFixedFieldsOn: aSerializer	aSerializer writeField: #values value: values.	aSerializer writeField: #cursor value: cursor.	^super writeFixedFieldsOn: aSerializer.! !!CCollection methodsFor: 'private' stamp: 'ar 3/24/2004 22:39'!contentsChanged: aSymbol with: firstIndex with: lastIndex	self signal: #changed with: aSymbol with: firstIndex with: lastIndex.! !!CCollection methodsFor: 'sorting' stamp: 'bf 9/30/2004 13:42'!sort: aSortBlock 	"Sort this collection using aSortBlock. The block should take two arguments and return true if the first element should preceed the second one."	values sort: aSortBlock! !!CCollectionClient methodsFor: 'initialize' stamp: 'ar 3/15/2004 16:11'!initialize: numElements	"Initialize the receiver to a capacity of numElements"	^self subclassResponsibility! !!CCollectionClient methodsFor: 'accessing' stamp: 'ar 3/15/2004 15:41'!at: aKey	"Answer the element at the given key"	^self subclassResponsibility! !!CCollectionClient methodsFor: 'accessing' stamp: 'ar 3/15/2004 15:42'!at: aKey ifAbsent: aBlock	"Answer the element at the given key or evaluate the given block if there is no element with the given key"	^self subclassResponsibility! !!CCollectionClient methodsFor: 'accessing' stamp: 'ar 3/15/2004 15:42'!at: aKey put: anObject	"Store anObject under the given key in the receiver"	^self subclassResponsibility! !!CCollectionClient methodsFor: 'accessing' stamp: 'ar 3/15/2004 15:52'!contentType	"Answer the type of the elements stored in the receiver"	^self subclassResponsibility! !!CCollectionClient methodsFor: 'accessing' stamp: 'ar 3/15/2004 15:43'!cursor	"Answer the cursor"	^self subclassResponsibility! !!CCollectionClient methodsFor: 'accessing' stamp: 'ar 3/15/2004 15:43'!cursor: aValue	"Set the cursor to the given value"	^self subclassResponsibility! !!CCollectionClient methodsFor: 'accessing' stamp: 'ar 3/15/2004 15:43'!size	"Answer the number of elements in the receiver"	^self subclassResponsibility! !!CCollectionClient methodsFor: 'accessing' stamp: 'ar 3/15/2004 15:43'!wrapCursor	"Answer whether the cursor should wrap when streaming"	^self subclassResponsibility! !!CCollectionClient methodsFor: 'accessing' stamp: 'ar 3/15/2004 15:44'!wrapCursor: aBool	"Indicate whether the cursor should wrap when streaming"	^self subclassResponsibility! !!CCollectionClient methodsFor: 'adding' stamp: 'ar 3/15/2004 15:44'!add: anObject at: anIndex	"Insert the given object at the specified index"	^self addAll: (Array with: anObject) at: anIndex! !!CCollectionClient methodsFor: 'adding' stamp: 'ar 3/15/2004 15:44'!addAll: aCollection at: anIndex	"Insert the given collection before the specified index"	^self subclassResponsibility! !!CCollectionClient methodsFor: 'removing' stamp: 'ar 3/15/2004 15:45'!removeAll	"Remove all the elements from the receiver"	^self removeFrom: 1 to: self size! !!CCollectionClient methodsFor: 'removing' stamp: 'ar 3/15/2004 15:45'!removeFrom: firstIndex to: lastIndex	"Remove all the elements from firstIndex to lastIndex"	^self subclassResponsibility! !!CCollectionClient methodsFor: 'removing' stamp: 'ar 3/15/2004 15:45'!replaceFrom: firstIndex to: lastIndex with: aCollection startingAt: replStart	"Replace the elements in the receiver with the given collection"	^self subclassResponsibility! !!CCollectionClient methodsFor: 'copying' stamp: 'ar 3/15/2004 15:45'!copyFrom: firstIndex to: lastIndex	"Answer a copy of a subset of the receiver, starting from element at 	index start until element at index stop."	^self subclassResponsibility! !!CCollectionClient methodsFor: 'enumerating' stamp: 'ar 3/15/2004 15:46'!do: aBlock	"Evaluate aBlock with each of the receiver's elements as the argument."	^self subclassResponsibility! !!CCollectionClient methodsFor: 'enumerating' stamp: 'ar 3/15/2004 15:46'!keysAndValuesDo: aBlock	"Evaluate aBlock with all of the receiver's keys and values"	^self subclassResponsibility! !!CArrayedCollectionClient methodsFor: 'initialize' stamp: 'ar 3/15/2004 16:17'!initialize	"Initialize the receiver"	super initialize.	values := #().! !!CArrayedCollectionClient methodsFor: 'initialize' stamp: 'ar 3/15/2004 16:12'!initialize: numElements	"Initialize the receiver to a capacity of numElements"	values := Array new: numElements.! !!CArrayedCollectionClient methodsFor: 'accessing' stamp: 'ar 3/15/2004 15:54'!at: aKey	"Answer the element at the given key"	^values at: aKey! !!CArrayedCollectionClient methodsFor: 'accessing' stamp: 'ar 3/15/2004 16:19'!at: aKey ifAbsent: aBlock	"Answer the element at the given key or evaluate the given block 	if there is no element with the given key"	(aKey < 1 or:[aKey > values size]) ifTrue:[^aBlock value].	^self at: aKey! !!CArrayedCollectionClient methodsFor: 'accessing' stamp: 'ar 3/15/2004 15:55'!at: aKey put: anObject	"Store anObject under the given key in the receiver"	values at: aKey put: anObject! !!CArrayedCollectionClient methodsFor: 'accessing' stamp: 'ar 3/15/2004 16:19'!contentType	"Actually, answering nil is incorrect since values might be homogenous... 	but what the hey..."	^nil! !!CArrayedCollectionClient methodsFor: 'accessing' stamp: 'ar 3/15/2004 16:18'!cursor	"Answer the cursor of the receiver"	<bewareOf: #cursorChanged>	^self propertyValueAt: #cursor ifAbsent:[0]! !!CArrayedCollectionClient methodsFor: 'accessing' stamp: 'ar 3/15/2004 16:18'!cursor: aValue	"Modify the receiver's cursor"	^self propertyValueAt: #cursor put: (aValue min: self size max: 0) with: #cursorChanged! !!CArrayedCollectionClient methodsFor: 'accessing' stamp: 'ar 3/15/2004 15:57'!size	"Answer the number of elements in the receiver"	^values size! !!CArrayedCollectionClient methodsFor: 'accessing' stamp: 'ar 3/15/2004 16:19'!wrapCursor	"Answer the wrapCursor of the receiver"	<bewareOf: #wrapCursorChanged>	^self propertyValueAt: #wrapCursor ifAbsent:[false]! !!CArrayedCollectionClient methodsFor: 'accessing' stamp: 'ar 3/15/2004 15:58'!wrapCursor: aValue	"Modify the receiver's wrapCursor"	^self propertyValueAt: #wrapCursor put: aValue with: #wrapCursorChanged! !!CArrayedCollectionClient methodsFor: 'adding' stamp: 'ar 3/15/2004 15:58'!add: anObject at: index	"Insert the given object before the specified index"	| newData |	newData _ Array new: values size+1.	newData replaceFrom: 1 to: index-1 with: values startingAt: 1.	newData at: index put: anObject.	newData replaceFrom: index+1 to: newData size with: values startingAt: index.	values _ newData.	self signal: #changed with: #insert with: index with: index.	index <= cursor ifTrue:[self cursor: cursor + 1].	^anObject! !!CArrayedCollectionClient methodsFor: 'adding' stamp: 'ar 3/15/2004 15:58'!addAll: aCollection at: index	"Insert the given object before the specified index"	| sz newData |	sz _ aCollection size.	newData _ Array new: values size + sz.	newData replaceFrom: 1 to: index-1 with: values startingAt: 1.	newData replaceFrom: index to: index+sz-1 with: aCollection startingAt: 1.	newData replaceFrom: index+sz to: newData size with: values startingAt: index.	values _ newData.	self signal: #changed with: #insert with: index with: index+sz-1.	index <= cursor ifTrue:[self cursor: cursor + sz].	^aCollection! !!CArrayedCollectionClient methodsFor: 'removing' stamp: 'ar 3/15/2004 16:00'!copyFrom: firstIndex to: lastIndex	"Answer a copy of a subset of the receiver, starting from element at 	index start until element at index stop."	| newCollection sz |	sz _ lastIndex - firstIndex + 1.	newCollection _ self species new: sz.	newCollection replaceFrom: 1 to: sz with: values startingAt: firstIndex.	^newCollection! !!CArrayedCollectionClient methodsFor: 'removing' stamp: 'ar 3/15/2004 16:20'!removeAll	| sz |	sz _ values size.	values _ #().	sz > 0 ifTrue:[self signal: #changed with: #remove with: 1 with: sz].	self cursor: 0.! !!CArrayedCollectionClient methodsFor: 'removing' stamp: 'ar 3/15/2004 15:59'!removeFrom: firstIndex to: lastIndex	| sz newData |	sz _ lastIndex - firstIndex+1.	sz <= 0 ifTrue:[^self].	newData _ Array new: values size - sz.	newData replaceFrom: 1 to: firstIndex-1 with: values startingAt: 1.	newData replaceFrom: firstIndex to: newData size with: values startingAt: lastIndex+1.	values _ newData.	self signal: #changed with: #remove with: firstIndex with: lastIndex.	cursor < firstIndex ifFalse:[		cursor <= lastIndex			ifTrue:[self cursor: 0]			ifFalse:[self cursor: cursor - sz]].! !!CArrayedCollectionClient methodsFor: 'removing' stamp: 'ar 3/15/2004 16:20'!replaceFrom: firstIndex to: lastIndex with: aCollection startingAt: replStart	values replaceFrom: firstIndex to: lastIndex with: aCollection startingAt: replStart.	self signal: #changed with: #replace with: firstIndex with: lastIndex.! !!CArrayedCollectionClient methodsFor: 'enumerating' stamp: 'ar 3/15/2004 16:01'!do: aBlock	"Evaluate aBlock with each of the receiver's elements as the argument."	1 to: self size do:[:i| aBlock value: (values at: i)]! !!CArrayedCollectionClient methodsFor: 'enumerating' stamp: 'ar 3/15/2004 16:01'!keysAndValuesDo: aBlock	"Evaluate aBlock with all of the receiver's keys and values"	1 to: self size do:[:i| aBlock value: i value: (values at: i)]! !!CCostumeAspect methodsFor: 'initialize' stamp: 'ar 3/23/2004 15:31'!changed	"Notify my costume about a change in this aspect"! !!CCostumeAspect methodsFor: 'initialize' stamp: 'ar 3/23/2004 15:30'!initialize	"Initialize the receiver"! !!CCostumeAspect methodsFor: 'initialize' stamp: 'ar 3/23/2004 15:35'!invalidate	"The receiver has become invalid. Release caches and invalidate my costume."	self releaseCachedState.	costume ifNotNil:[		costume invalidate.		self changed.	].! !!CCostumeAspect methodsFor: 'initialize' stamp: 'ar 3/23/2004 19:53'!invalidateLayout	"Invalidate my costume's layout"	costume ifNotNil:[costume invalidateLayout].! !!CCostumeAspect methodsFor: 'initialize' stamp: 'ar 3/25/2004 17:30'!loadFrom: anAspect	"Assign all my properties from anAspect"	^self subclassResponsibility! !!CCostumeAspect methodsFor: 'initialize' stamp: 'ar 3/23/2004 15:32'!releaseCachedState	"Release any associated cache information"! !!CCostumeAspect methodsFor: 'accessing' stamp: 'ar 3/23/2004 15:30'!costume	^costume! !!CCostumeAspect methodsFor: 'accessing' stamp: 'ar 3/23/2004 15:30'!costume: aCostume	costume := aCostume.! !!CCostumeAspect methodsFor: 'copying' stamp: 'ar 3/23/2004 15:31'!copy	"Copy the receiver"	^self shallowCopy postCopy! !!CCostumeAspect methodsFor: 'copying' stamp: 'ar 3/23/2004 15:31'!postCopy	"Perform post-copy operations"	costume := nil.	self releaseCachedState.! !!CCostumeBorder methodsFor: 'initialize' stamp: 'ar 3/23/2004 15:35'!changed	costume signal: #borderChanged.! !!CCostumeBorder methodsFor: 'initialize' stamp: 'ar 3/23/2004 15:34'!initialize	super initialize.	style := #none.	width := 0.	color := Color transparent.! !!CCostumeBorder methodsFor: 'initialize' stamp: 'ar 3/23/2004 18:04'!loadFrom: aBorder	"Assign all my properties from aBorder"	self = aBorder ifTrue:[^self].	style := aBorder style.	width := aBorder width.	color := aBorder color.	self invalidate.! !!CCostumeBorder methodsFor: 'initialize' stamp: 'ar 9/21/2003 19:12'!releaseCachedState	cachedBorder := nil.! !!CCostumeBorder methodsFor: 'initialize' stamp: 'ar 9/21/2003 18:44'!style: aStyle width: aWidth color: aColor	style := aStyle.	width := aWidth.	color := aColor.! !!CCostumeBorder methodsFor: 'accessing' stamp: 'ar 9/21/2003 18:38'!color	^color! !!CCostumeBorder methodsFor: 'accessing' stamp: 'ar 3/23/2004 16:51'!color: aColor	color = aColor ifTrue:[aColor].	color := aColor asColor.	self invalidate.	^aColor! !!CCostumeBorder methodsFor: 'accessing' stamp: 'ar 9/21/2003 18:38'!style	^style! !!CCostumeBorder methodsFor: 'accessing' stamp: 'ar 3/23/2004 16:51'!style: newStyle	style = newStyle ifTrue:[^newStyle].	style := newStyle asSymbol.	self invalidate.	^newStyle! !!CCostumeBorder methodsFor: 'accessing' stamp: 'ar 9/21/2003 18:38'!width	^width! !!CCostumeBorder methodsFor: 'accessing' stamp: 'ar 3/23/2004 17:33'!width: aNumber	width = aNumber ifTrue:[^aNumber].	width := aNumber asNumber max: 0.	self invalidate.	costume ifNotNil:[costume invalidateLayout].	^aNumber! !!CCostumeBorder methodsFor: 'drawing' stamp: 'ar 9/21/2003 19:24'!drawLineFrom: startPoint to: stopPoint on: aCanvas	^cachedBorder drawLineFrom: startPoint to: stopPoint on: aCanvas! !!CCostumeBorder methodsFor: 'drawing' stamp: 'ar 9/21/2003 19:24'!frameOval: aRectangle on: aCanvas	^cachedBorder frameOval: aRectangle on: aCanvas! !!CCostumeBorder methodsFor: 'drawing' stamp: 'ar 9/21/2003 19:24'!framePolygon: vertices on: aCanvas	^cachedBorder framePolygon: vertices on: aCanvas! !!CCostumeBorder methodsFor: 'drawing' stamp: 'ar 9/21/2003 19:24'!framePolyline: vertices on: aCanvas	^cachedBorder framePolyline: vertices on: aCanvas! !!CCostumeBorder methodsFor: 'drawing' stamp: 'ar 9/21/2003 19:24'!frameRectangle: aRectangle on: aCanvas	^cachedBorder frameRectangle: aRectangle on: aCanvas! !!CCostumeBorder methodsFor: 'drawing' stamp: 'ar 9/21/2003 19:24'!frameRoundRect: aRectangle radius: radius on: aCanvas	^cachedBorder frameRoundRect: aRectangle radius: radius on: aCanvas! !!CCostumeBorder methodsFor: 'operations' stamp: 'ar 1/8/2004 00:42'!expandBounds: aRectangle	"Answer the rectangle needed to draw this border around the argument"	width = 0 ifTrue:[^aRectangle].	^aRectangle expandBy: width! !!CCostumeBorder methodsFor: 'operations' stamp: 'ar 1/8/2004 00:42'!insetBounds: aRectangle	"Answer the inner rectangle for the argument"	width = 0 ifTrue:[^aRectangle].	^aRectangle insetBy: width! !!CCostumeBorder methodsFor: 'serializing' stamp: 'ar 9/22/2003 01:58'!readFieldsFrom: deSerializer	style := deSerializer readField: #style ifAbsent:[style].	width := deSerializer readField: #width ifAbsent:[width].	color := deSerializer readField: #color ifAbsent:[color].	cachedBorder := nil.! !!CCostumeBorder methodsFor: 'serializing' stamp: 'ar 9/22/2003 01:55'!writeFieldsOn: aSerializer	aSerializer writeField: #style value: style.	aSerializer writeField: #width value: width.	aSerializer writeField: #color value: color.! !!CCostumeBorder methodsFor: 'testing' stamp: 'ar 3/23/2004 17:48'!isNoBorder	^false! !!CCostumeBorder methodsFor: 'testing' stamp: 'ar 1/8/2004 00:32'!isTranslucent	^color isTranslucent! !!CCostumeBorder methodsFor: 'comparing' stamp: 'ar 9/21/2003 18:47'!= aBorder	"Compare receiver and argument"	self class == aBorder class ifFalse:[^false].	^self style = aBorder style and:[self width = aBorder width and:[self color = aBorder color]]! !!CCostumeBorder methodsFor: 'comparing' stamp: 'ar 9/21/2003 18:47'!hash	^(style hash bitXor: color hash) bitXor: width hash! !!CCostumeBorder methodsFor: 'color tracking' stamp: 'ar 9/21/2003 19:24'!colorsAtCorners	^cachedBorder colorsAtCorners! !!CCostumeBorder methodsFor: 'color tracking' stamp: 'ar 9/21/2003 18:36'!trackColorFrom: aCostume	^self cachedBorder trackColorFrom: aCostume! !!CCostumeBorder methodsFor: 'private' stamp: 'ar 9/21/2003 18:38'!cachedBorder	^cachedBorder ifNil:[cachedBorder := self updateBorder].! !!CCostumeBorder methodsFor: 'private' stamp: 'ar 9/21/2003 19:18'!updateBorder	| newBorder |	newBorder := CBorder perform: self style.	newBorder width: self width.	newBorder baseColor: self color.	^newBorder! !!CCostumeFill methodsFor: 'initialize' stamp: 'ar 3/23/2004 16:52'!changed	costume signal: #fillChanged.! !!CCostumeFill methodsFor: 'initialize' stamp: 'ar 3/23/2004 18:16'!initialize	"Initialize the receiver"	style := #solid.	colors := Array with: Color white.	alpha := 1.0.	offset := 0@0.	angle := 0.! !!CCostumeFill methodsFor: 'initialize' stamp: 'ar 3/23/2004 18:14'!loadFrom: aFill	"Assign all my properties from aFill"	self = aFill ifTrue:[^self].	aFill isColor ifTrue:[^self color: aFill].	self style: aFill style.	colors := aFill colors.	alpha := aFill alpha.	offset := aFill offset.	angle := aFill angle.	self invalidate.! !!CCostumeFill methodsFor: 'initialize' stamp: 'ar 3/12/2003 19:49'!releaseCachedState	cachedFill := nil.! !!CCostumeFill methodsFor: 'accessing' stamp: 'ar 3/12/2003 19:49'!alpha	^alpha! !!CCostumeFill methodsFor: 'accessing' stamp: 'ar 3/23/2004 16:53'!alpha: newAlpha	alpha = newAlpha ifTrue:[^newAlpha].	alpha := newAlpha asFloat min: 1.0 max: 0.0.	self invalidate.	^newAlpha! !!CCostumeFill methodsFor: 'accessing' stamp: 'ar 3/12/2003 21:44'!angle	style == #linearGradient ifTrue:[^angle] ifFalse:[^0].! !!CCostumeFill methodsFor: 'accessing' stamp: 'ar 3/23/2004 16:53'!angle: newAngle	angle = newAngle ifTrue:[^newAngle].	angle := newAngle asNumber.	self invalidate.	^newAngle! !!CCostumeFill methodsFor: 'accessing' stamp: 'tk 6/19/2004 10:47'!color	alpha = 0 ifTrue: [^ Color transparent].	"be consistent with input"	^self primaryColor! !!CCostumeFill methodsFor: 'accessing' stamp: 'tk 6/24/2004 15:46'!color: aColor	self asColor = aColor ifTrue:[^aColor].	style := aColor alpha = 0.0 ifTrue: [#none] ifFalse: [#solid].	self primaryColor: aColor asNontranslucentColor.	self alpha: aColor alpha.	^aColor! !!CCostumeFill methodsFor: 'accessing' stamp: 'ar 3/12/2003 19:49'!colors	^colors! !!CCostumeFill methodsFor: 'accessing' stamp: 'ar 3/23/2004 17:19'!colors: newColors	newColors size = 0 ifTrue:[^self style: #none].	newColors size = 1 ifTrue:[^self color: newColors first].	colors := newColors.	self invalidate.	^newColors! !!CCostumeFill methodsFor: 'accessing' stamp: 'ar 3/12/2003 20:15'!frame	^frame! !!CCostumeFill methodsFor: 'accessing' stamp: 'ar 3/23/2004 16:54'!frame: aRectangle	frame := aRectangle.	self invalidate.	^aRectangle! !!CCostumeFill methodsFor: 'accessing' stamp: 'ar 3/12/2003 20:01'!gradientColor	^colors last! !!CCostumeFill methodsFor: 'accessing' stamp: 'ar 3/23/2004 16:55'!gradientColor: aColor	self gradientColor = aColor ifTrue:[^aColor].	colors at: colors size put: aColor.	self invalidate.	^aColor! !!CCostumeFill methodsFor: 'accessing' stamp: 'ar 3/12/2003 19:49'!offset	^offset! !!CCostumeFill methodsFor: 'accessing' stamp: 'ar 3/23/2004 16:55'!offset: newOffset	offset = newOffset ifTrue:[^newOffset].	offset := newOffset asPoint.	self invalidate.	^newOffset! !!CCostumeFill methodsFor: 'accessing' stamp: 'ar 9/21/2003 19:39'!primaryColor	^colors at: 1! !!CCostumeFill methodsFor: 'accessing' stamp: 'ar 3/23/2004 16:55'!primaryColor: aColor	self primaryColor = aColor ifTrue:[^aColor].	colors at: 1 put: aColor.	self invalidate.	^aColor! !!CCostumeFill methodsFor: 'accessing' stamp: 'ar 11/14/2003 16:53'!scaledPixelValue32	^self cachedFill scaledPixelValue32! !!CCostumeFill methodsFor: 'accessing' stamp: 'ar 3/23/2004 16:59'!style	^self verboseStyle! !!CCostumeFill methodsFor: 'accessing' stamp: 'ar 3/23/2004 17:00'!style: newStyle	self style = newStyle ifTrue:[^newStyle].	self verboseStyle: newStyle.	self invalidate.	^newStyle! !!CCostumeFill methodsFor: 'accessing' stamp: 'ar 3/13/2004 22:47'!verboseStyle	style == #linearGradient ifTrue:[		angle = 0 ifTrue:[^#horizontalGradient].		angle = 45 ifTrue:[^#diagonalGradient].		angle = 90 ifTrue:[^#verticalGradient].	].	^style! !!CCostumeFill methodsFor: 'accessing' stamp: 'ar 3/23/2004 20:50'!verboseStyle: aStyle	aStyle == #solid ifTrue:[		style := #solid.		^self ensureCorrectColors].	aStyle == #horizontalGradient ifTrue:[		style := #linearGradient.		angle := 0.		^self ensureCorrectColors].	aStyle == #diagonalGradient ifTrue:[		style := #linearGradient.		angle := 45.		^self ensureCorrectColors].	aStyle == #verticalGradient ifTrue:[		style := #linearGradient.		angle := 90.		^self ensureCorrectColors].	(aStyle == #linearGradient and:[self verboseStyle ~~ #linearGradient]) ifTrue:[		style := #linearGradient.		angle := 45.		^self ensureCorrectColors].	aStyle == #radialGradient ifTrue:[		style := #radialGradient.		^self ensureCorrectColors].	style := #none.	^self ensureCorrectColors! !!CCostumeFill methodsFor: 'testing' stamp: 'ar 3/12/2003 19:49'!isBitmapFill	^false! !!CCostumeFill methodsFor: 'testing' stamp: 'ar 3/12/2003 19:49'!isGradientFill	^self isSolidFill not! !!CCostumeFill methodsFor: 'testing' stamp: 'ar 3/23/2004 17:53'!isNoFill	^false! !!CCostumeFill methodsFor: 'testing' stamp: 'ar 3/12/2003 20:32'!isOrientedFill	^style == #linearGradient or:[style == #radialGradient]! !!CCostumeFill methodsFor: 'testing' stamp: 'ar 3/12/2003 20:32'!isRadialFill	^style == #radialGradient! !!CCostumeFill methodsFor: 'testing' stamp: 'ar 3/12/2003 19:49'!isSolidFill	^style == #solid! !!CCostumeFill methodsFor: 'testing' stamp: 'ar 3/12/2003 19:49'!isTranslucent	^alpha < 1.0! !!CCostumeFill methodsFor: 'testing' stamp: 'ar 3/12/2003 20:00'!isTransparent	^style == #none or:[alpha = 0.0]! !!CCostumeFill methodsFor: 'comparing' stamp: 'ar 9/21/2003 19:58'!= aFill	self class == aFill class ifFalse:[^false].	style = aFill style ifFalse:[^false].	colors = aFill colors ifFalse:[^false].	alpha = aFill alpha ifFalse:[^false].	offset = aFill offset ifFalse:[^false].	angle = aFill angle ifFalse:[^false].	^true! !!CCostumeFill methodsFor: 'comparing' stamp: 'ar 9/21/2003 19:59'!hash	^(style hash bitXor: colors hash) bitXor: (angle hash bitXor: offset hash)! !!CCostumeFill methodsFor: 'converting' stamp: 'ar 3/12/2003 20:36'!asColor	^self primaryColor alpha: alpha! !!CCostumeFill methodsFor: 'converting' stamp: 'ar 3/12/2003 19:49'!mixed: fraction with: aColor	^self copy colors: (colors collect:[:each| each mixed: fraction with: aColor])! !!CCostumeFill methodsFor: 'copying' stamp: 'ar 3/23/2004 17:00'!postCopy	super postCopy.	colors := colors clone.! !!CCostumeFill methodsFor: 'private' stamp: 'ar 3/16/2004 17:03'!cachedFill	cachedFill ifNil:[cachedFill := self computeFill].	^cachedFill! !!CCostumeFill methodsFor: 'private' stamp: 'ar 3/12/2003 20:32'!computeFill	"update my fill"	| newFill radians dir |	style == #none ifTrue:[^Color transparent].	alpha = 0.0 ifTrue:[^Color transparent].	style == #solid ifTrue:[^colors at: 1].	newFill := CGradientFill new.	alpha = 1.0 ifTrue:[		newFill colors: colors.	] ifFalse:[		newFill colors: (colors collect:[:each| each alpha: alpha]).	].	style == #radialGradient ifTrue:[		newFill origin: frame center + offset.		newFill direction: 0@(frame width abs max: 1).	] ifFalse:[		radians _ angle asFloat degreesToRadians.		dir := radians cos @ radians sin.		newFill origin: (self computeGradientOrigin: dir).		newFill direction: dir * ((self computeGradientLength: dir) abs max: 1).	].	^newFill! !!CCostumeFill methodsFor: 'private' stamp: 'ar 3/12/2003 19:55'!computeGradientLength: dir	| origin corner dv min max |	origin := frame origin.	corner := frame corner.	dv := origin dotProduct: dir.	min := dv. max := dv.	dv := corner dotProduct: dir.	dv < min ifTrue:[min := dv]. dv > max ifTrue:[max := dv].	dv := (corner x @ origin y) dotProduct: dir.	dv < min ifTrue:[min := dv]. dv > max ifTrue:[max := dv].	dv := (origin x @ corner y) dotProduct: dir.	dv < min ifTrue:[min := dv]. dv > max ifTrue:[max := dv].	^(max - min - (offset r * 2)) truncated! !!CCostumeFill methodsFor: 'private' stamp: 'ar 3/12/2003 19:49'!computeGradientOrigin: dir	dir x >= 0 ifTrue:["fill goes right"		dir y >= 0 			ifTrue:[^offset] "topLeft + offset"			ifFalse:[^(0 @ frame height) + offset] "bottomLeft + offset"	] ifFalse:["fill goes left"		dir y >= 0 			ifTrue:[^(frame width @ 0) + offset] "topRight + offset"			ifFalse:[^frame extent + offset] "bottomRight + offset"	].! !!CCostumeFill methodsFor: 'private' stamp: 'ar 3/12/2003 19:49'!computePixelRampOfSize: length	"Compute the pixel ramp in the receiver"	| bits lastColor lastIndex nextIndex nextColor distance theta lastValue lastWord nextWord step |	bits _ Bitmap new: length.	lastColor _ colors at: 1.	lastWord _ lastColor pixelWordForDepth: 32.	lastIndex _ 0.	1 to: colors size do:[:i|		nextIndex _ (i * length) // colors size.		nextColor := colors at: i.		nextWord _ nextColor pixelWordForDepth: 32.		distance _ (nextIndex - lastIndex).		distance = 0 ifTrue:[distance _ 1].		step _ 1.0 / distance asFloat.		theta _ 0.0.		lastIndex+1 to: nextIndex do:[:j|			theta _ theta + step.			"The following is an open-coded version of:				color _ nextColor alphaMixed: theta with: lastColor.				bits at: j put: (color scaledPixelValue32).			"			bits at: j put: (self scaledAlphaMix: theta of: lastWord with: nextWord).		].		lastIndex _ nextIndex.		lastColor _ nextColor.		lastWord _ nextWord.	].	lastValue _ lastColor scaledPixelValue32.	lastIndex+1 to: length do:[:i| bits at: i put: lastValue].	^bits! !!CCostumeFill methodsFor: 'private' stamp: 'ar 3/12/2003 19:49'!direction	^self cachedFill direction! !!CCostumeFill methodsFor: 'private' stamp: 'ar 3/12/2003 21:42'!ensureCorrectColors	| cc |	self isGradientFill ifFalse:[		^self colors: (Array with: self primaryColor).	].	colors size < 2 ifTrue:[		cc := colors size = 1 ifTrue:[colors first] ifFalse:[Color white].		cc brightness < 0.7			ifTrue:[colors := Array with: cc with: (cc mixed: 0.5 with: Color white)]			ifFalse:[colors := Array with: cc with: (cc mixed: 0.5 with: Color black)].		self colors: colors.	].! !!CCostumeFill methodsFor: 'private' stamp: 'ar 3/12/2003 19:49'!normal	^self cachedFill normal! !!CCostumeFill methodsFor: 'private' stamp: 'ar 3/12/2003 19:49'!origin	^self cachedFill origin! !!CCostumeFill methodsFor: 'private' stamp: 'ar 3/12/2003 19:49'!pixelRamp	^self cachedFill pixelRamp! !!CCostumeFill methodsFor: 'private' stamp: 'ar 4/8/2004 16:52'!scaledAlphaMix: theta of: lastWord with: nextWord	"Open-coded version of alpha mixing two 32bit pixel words and returning the scaled pixel value."	| word0 word1 a0 a1 alphaPart v0 v1 vv newValue |	word0 _ lastWord.	word1 _ nextWord.	"note: extract alpha first so we'll be in SmallInteger range afterwards"	a0 _ word0 bitShift: -24. a1 _ word1 bitShift: -24.	alphaPart _ a0 + (a1 - a0 * theta) truncated.	"Now make word0 and word1 SmallIntegers"	word0 _ word0 bitAnd: 16rFFFFFF. word1 _ word1 bitAnd: 16rFFFFFF.	"Compute first component value"	v0 _ (word0 bitAnd: 255). v1 _ (word1 bitAnd: 255).	vv _ (v0 + (v1 - v0 * theta) truncated) * alphaPart // 255.	newValue _ vv.	"Compute second component value"	v0 _ ((word0 bitShift: -8) bitAnd: 255). v1 _ ((word1 bitShift: -8) bitAnd: 255).	vv _ (v0 + (v1 - v0 * theta) truncated) * alphaPart // 255.	newValue _ newValue bitOr: (vv bitShift: 8).	"Compute third component value"	v0 _ ((word0 bitShift: -16) bitAnd: 255). v1 _ ((word1 bitShift: -16) bitAnd: 255).	vv _ (v0 + (v1 - v0 * theta) truncated) * alphaPart // 255.	newValue _ newValue bitOr: (vv bitShift: 16).	"Return result"	^newValue bitOr: (alphaPart bitShift: 24)! !!CCostumeFill methodsFor: 'private' stamp: 'ar 3/12/2003 19:49'!updateFrame: aFrame	frame = aFrame ifTrue:[^self].	frame := aFrame.	cachedFill := self computeFill.! !!CCostumeFill methodsFor: '*Tweak-Factory' stamp: 'ar 9/22/2003 01:57'!readFieldsFrom: deSerializer	style := deSerializer readField: #style ifAbsent:[style].	colors := deSerializer readField: #colors ifAbsent:[colors].	alpha := deSerializer readField: #alpha ifAbsent:[alpha].	offset := deSerializer readField: #offset ifAbsent:[offset].	angle := deSerializer readField: #angle ifAbsent:[angle].	cachedFill := nil.! !!CCostumeFill methodsFor: '*Tweak-Factory' stamp: 'ar 9/22/2003 01:56'!writeFieldsOn: aSerializer	aSerializer writeField: #style value: style.	aSerializer writeField: #colors value: colors.	aSerializer writeField: #alpha value: alpha.	aSerializer writeField: #offset value: offset.	aSerializer writeField: #angle value: angle.! !!CCostumeGraphic methodsFor: 'initialize' stamp: 'ar 3/23/2004 19:18'!changed	costume signal: #graphicChanged.! !!CCostumeGraphic methodsFor: 'initialize' stamp: 'ar 3/23/2004 19:14'!initialize	fit := #rigid.	opaque := false.	offset := 0@0.	anchorPoint := #center.! !!CCostumeGraphic methodsFor: 'initialize' stamp: 'bf 4/2/2004 23:17'!loadFrom: aGraphic	aGraphic isForm ifTrue:[^self form: aGraphic].	form := aGraphic form.	fit := aGraphic fit.	opaque := aGraphic opaque.	offset := aGraphic offset.	anchorPoint := aGraphic anchorPoint.	sourceRect := aGraphic sourceRect.	self invalidate.! !!CCostumeGraphic methodsFor: 'initialize' stamp: 'ar 3/23/2004 19:09'!minHeight	^0! !!CCostumeGraphic methodsFor: 'initialize' stamp: 'ar 3/23/2004 19:09'!minWidth	^0! !!CCostumeGraphic methodsFor: 'accessing' stamp: 'ar 3/23/2004 19:09'!anchorPoint	^anchorPoint! !!CCostumeGraphic methodsFor: 'accessing' stamp: 'ar 3/23/2004 19:14'!anchorPoint: aSymbol	anchorPoint = aSymbol ifTrue:[^self].	anchorPoint := aSymbol asSymbol.	self invalidate.! !!CCostumeGraphic methodsFor: 'accessing' stamp: 'bf 4/2/2004 20:24'!bounds	form ifNil:[^0@0 extent: 0@0].	^0@0 extent: self extent! !!CCostumeGraphic methodsFor: 'accessing' stamp: 'bf 4/2/2004 20:22'!extent	^sourceRect		ifNil: [form extent]		ifNotNil: [sourceRect extent]! !!CCostumeGraphic methodsFor: 'accessing' stamp: 'ar 3/23/2004 19:09'!fit	^fit! !!CCostumeGraphic methodsFor: 'accessing' stamp: 'ar 3/23/2004 19:10'!fit: aSymbol	fit == aSymbol ifTrue:[^self].	fit := aSymbol asSymbol.	self invalidate.! !!CCostumeGraphic methodsFor: 'accessing' stamp: 'ar 3/23/2004 19:15'!form	^form! !!CCostumeGraphic methodsFor: 'accessing' stamp: 'bf 4/2/2004 22:58'!form: aForm	form := aForm.	aForm ifNotNil:[opaque := aForm isOpaque].	sourceRect := nil.	self invalidate.! !!CCostumeGraphic methodsFor: 'accessing' stamp: 'bf 4/2/2004 23:27'!height	^sourceRect		ifNil: [form height]		ifNotNil: [sourceRect height]! !!CCostumeGraphic methodsFor: 'accessing' stamp: 'ar 3/23/2004 19:09'!isOpaque	^opaque! !!CCostumeGraphic methodsFor: 'accessing' stamp: 'ar 3/23/2004 19:09'!isOpaque: aBool	opaque := aBool.! !!CCostumeGraphic methodsFor: 'accessing' stamp: 'ar 3/23/2004 19:09'!offset	^offset! !!CCostumeGraphic methodsFor: 'accessing' stamp: 'ar 3/23/2004 19:11'!offset: newOffset	offset = newOffset ifTrue:[^self].	offset := newOffset asPoint.	self invalidate.! !!CCostumeGraphic methodsFor: 'accessing' stamp: 'ar 3/23/2004 20:28'!opaque	^opaque! !!CCostumeGraphic methodsFor: 'accessing' stamp: 'ar 3/23/2004 20:28'!opaque: aBool	opaque := aBool.	self invalidate.! !!CCostumeGraphic methodsFor: 'accessing' stamp: 'bf 4/2/2004 23:17'!sourceRect	^sourceRect! !!CCostumeGraphic methodsFor: 'accessing' stamp: 'bf 4/2/2004 23:41'!sourceRect: aRectangle	sourceRect = aRectangle ifTrue: [^self].	sourceRect := aRectangle.	self invalidate! !!CCostumeGraphic methodsFor: 'accessing' stamp: 'bf 4/2/2004 23:27'!width	^sourceRect		ifNil: [form width]		ifNotNil: [sourceRect width]! !!CCostumeGraphic methodsFor: 'drawing' stamp: 'ar 3/25/2004 23:07'!containsPoint: aPoint	form ifNil:[^false].	^true! !!CCostumeGraphic methodsFor: 'drawing' stamp: 'ar 5/5/2004 13:47'!drawOn: aCanvas in: drawingBounds	"see if we can just blt"	| noPaint |	form ifNil:[^self].	form isForm 		ifTrue:[noPaint := opaque or:[costume notNil and:[costume fill = Color black]]]		ifFalse:[noPaint := false].	(drawingBounds extent = self extent or:[fit == #rigid]) 		ifTrue:[^self drawRigidOn: aCanvas in: drawingBounds opaque: noPaint].	(fit == #scale) 		ifTrue:[^self drawScaledOn: aCanvas in: drawingBounds opaque: noPaint].	(fit == #stretch) 		ifTrue:[^self drawStretchedOn: aCanvas in: drawingBounds opaque: noPaint].	(fit == #tile)		ifTrue:[^self drawTiledOn: aCanvas in: drawingBounds opaque: noPaint].	(fit == #autoScale)		ifTrue:[			self extent < drawingBounds extent 				ifTrue:[^self drawRigidOn: aCanvas in: drawingBounds opaque: noPaint]				ifFalse:[^self drawScaledOn: aCanvas in: drawingBounds opaque: noPaint]].! !!CCostumeGraphic methodsFor: 'drawing' stamp: 'bf 4/3/2004 02:06'!drawRigidOn: aCanvas in: drawingBounds opaque: aBool	| ofs |	anchorPoint ifNil:[anchorPoint := #center].	ofs := ((0@0 extent: drawingBounds extent) perform: anchorPoint) - 				(self bounds perform: anchorPoint).	offset ifNotNil:[ofs := ofs + offset].	aBool ifTrue:[^aCanvas drawImage: form at: drawingBounds origin + ofs sourceRect: (sourceRect ifNil: [form boundingBox])].	^form drawOn: aCanvas		in: (drawingBounds origin + ofs extent: self extent)		sourceRect: (sourceRect ifNil: [form boundingBox])! !!CCostumeGraphic methodsFor: 'drawing' stamp: 'bf 4/2/2004 23:31'!drawScaledOn: aCanvas in: drawingBounds opaque: aBool	| scale ofs box |	drawingBounds height = 0 ifTrue:[^self].	drawingBounds width = 0 ifTrue:[^self].	anchorPoint ifNil:[anchorPoint := #center].	scale := (self width / drawingBounds width)		max: (self height / drawingBounds height).	box := form offset extent: (self extent / scale) truncated.	ofs := ((0@0 extent: drawingBounds extent) perform: anchorPoint) - 				(box perform: anchorPoint).	offset ifNotNil:[ofs := ofs + offset].	^form drawOn: aCanvas		in: (drawingBounds origin + ofs extent: box extent)		sourceRect: (sourceRect ifNil: [form boundingBox])! !!CCostumeGraphic methodsFor: 'drawing' stamp: 'bf 4/3/2004 00:59'!drawStretchedOn: aCanvas in: drawingBounds opaque: aBool	^form drawOn: aCanvas in: drawingBounds sourceRect: (sourceRect ifNil: [form boundingBox])! !!CCostumeGraphic methodsFor: 'drawing' stamp: 'bf 4/2/2004 23:34'!drawTiledOn: aCanvas in: drawingBounds opaque: aBool	| w h y x box ext |	w := self width.	h := self height.	box := sourceRect ifNil: [form boundingBox].	ext := box extent.	y := drawingBounds top.	[y < drawingBounds bottom] whileTrue:[		x := drawingBounds left.		[x < drawingBounds right] whileTrue:[			aBool				ifTrue:[aCanvas drawImage: form at: x@y sourceRect: box]				ifFalse:[form drawOn: aCanvas in: (x@y extent: ext) sourceRect: box].			x := x + w.		].		y := y + h.	].! !!CCostumeGraphic methodsFor: 'serializing' stamp: 'bf 4/2/2004 20:24'!readFieldsFrom: deSerializer	form := deSerializer readField: #form ifAbsent:[form].	fit := deSerializer readField: #fit ifAbsent:[fit].	opaque := deSerializer readField: #opaque ifAbsent:[opaque].	offset := deSerializer readField: #offset ifAbsent:[offset].	anchorPoint := deSerializer readField: #anchorPoint ifAbsent:[anchorPoint].	sourceRect := deSerializer readField: #sourceRect ifAbsent:[sourceRect].! !!CCostumeGraphic methodsFor: 'serializing' stamp: 'bf 4/2/2004 23:15'!writeFieldsOn: aSerializer	aSerializer writeField: #form value: form.	aSerializer writeField: #fit value: fit.	aSerializer writeField: #opaque value: opaque.	aSerializer writeField: #offset value: offset.	aSerializer writeField: #anchorPoint value: anchorPoint.	aSerializer writeField: #sourceRect value: sourceRect.! !!CCostumeGrid methodsFor: 'initialize' stamp: 'ar 3/23/2004 15:33'!changed	"Notify my costume about a change in this aspect"	costume signal: #gridChanged.! !!CCostumeGrid methodsFor: 'initialize' stamp: 'ar 3/23/2004 15:20'!initialize	super initialize.	origin := 0@0.	extent := 8@8.	visible := true.	enabled := true.	color := Color black.! !!CCostumeGrid methodsFor: 'initialize' stamp: 'ar 3/25/2004 17:31'!loadFrom: aGrid	aGrid isPoint ifTrue:[^self extent: aGrid].	origin := aGrid origin.	extent := aGrid extent.	enabled := aGrid enabled.	visible := aGrid visible.	color := aGrid color.! !!CCostumeGrid methodsFor: 'accessing' stamp: 'ar 3/23/2004 15:20'!color	^color! !!CCostumeGrid methodsFor: 'accessing' stamp: 'ar 3/23/2004 16:49'!color: aColor	color = aColor ifTrue:[^aColor].	color := aColor asColor.	self invalidate.	^aColor! !!CCostumeGrid methodsFor: 'accessing' stamp: 'ar 3/23/2004 15:20'!enabled	^enabled! !!CCostumeGrid methodsFor: 'accessing' stamp: 'ar 3/23/2004 16:50'!enabled: aBool	enabled = aBool ifTrue:[^aBool].	enabled := aBool.	self invalidate.	^aBool! !!CCostumeGrid methodsFor: 'accessing' stamp: 'ar 3/23/2004 15:21'!extent	^extent! !!CCostumeGrid methodsFor: 'accessing' stamp: 'ar 3/23/2004 16:50'!extent: aPoint	extent = aPoint ifTrue:[^aPoint].	extent := aPoint asPoint.	self invalidate.	^aPoint! !!CCostumeGrid methodsFor: 'accessing' stamp: 'ar 3/23/2004 15:21'!origin	^origin! !!CCostumeGrid methodsFor: 'accessing' stamp: 'ar 3/23/2004 16:50'!origin: aPoint	origin = aPoint ifTrue:[^aPoint].	origin := aPoint asPoint.	self invalidate.	^aPoint! !!CCostumeGrid methodsFor: 'accessing' stamp: 'ar 3/23/2004 15:21'!visible	^visible! !!CCostumeGrid methodsFor: 'accessing' stamp: 'ar 3/23/2004 16:50'!visible: aBool	visible = aBool ifTrue:[^aBool].	visible := aBool.	self invalidate.	^aBool! !!CCostumeGrid methodsFor: 'gridding' stamp: 'ar 4/29/2004 17:02'!drawGridOn: aCanvas in: drawingBounds	"Draw the grid"	| x y clip gridX gridY cached |	visible ifFalse:[^self].	cached := self class gridCacheAt: extent.	cached ifNil:[^self uncachedDrawGridOn: aCanvas in: drawingBounds].	(cached colors at: 2) = color ifFalse:[		cached colors: (Array with: Color transparent with: color).	].	"Get the starting point"	clip := drawingBounds intersect: aCanvas clipRect.	gridX := clip left truncateTo: extent x.	gridX < clip left ifTrue:[gridX := gridX + extent x].	gridY := clip top truncateTo: extent y.	gridY < clip top ifTrue:[gridY := gridY + extent y].	"Now draw"	aCanvas clipBy: clip during:[:cc|		y := gridY.		[y < clip bottom] whileTrue:[			x := gridX.			[x < clip right] whileTrue:[				cc paintImage: cached at: x@y.				x := x + cached width.			].			y := y + cached height.		].	].! !!CCostumeGrid methodsFor: 'gridding' stamp: 'ar 3/23/2004 15:23'!drawOn: aCanvas in: drawingBounds	"Draw the grid"	^self drawGridOn: aCanvas in: drawingBounds.! !!CCostumeGrid methodsFor: 'gridding' stamp: 'ar 3/23/2004 15:22'!gridPoint: aPoint	enabled ifFalse:[^aPoint].	^(aPoint - origin grid: extent) + origin! !!CCostumeGrid methodsFor: 'gridding' stamp: 'ar 3/23/2004 15:23'!uncachedDrawGridOn: aCanvas in: drawingBounds	"Draw an uncached grid"	| x y clip rect gridX gridY |	clip := (aCanvas clipRect intersect: drawingBounds).	"Get the starting point"	gridX := clip left truncateTo: extent x.	gridX < clip left ifTrue:[gridX := gridX + extent x].	gridY := clip top truncateTo: extent y.	gridY < clip top ifTrue:[gridY := gridY + extent y].	"Now draw"	y := gridY.	[y < clip bottom] whileTrue:[		x := gridX.		[x < clip right] whileTrue:[			rect := x@y extent: 1@1.			aCanvas fillRectangle: rect color: color.			x := x + extent x.		].		y := y + extent y.	].! !!CCostumeHighlight methodsFor: 'initialize' stamp: 'ar 3/23/2004 21:49'!changed	costume signal: (name,'Changed') asSymbol.! !!CCostumeHighlight methodsFor: 'initialize' stamp: 'ar 3/23/2004 21:19'!initialize	super initialize.	active := true.! !!CCostumeHighlight methodsFor: 'accessing'!active	^active! !!CCostumeHighlight methodsFor: 'accessing' stamp: 'ar 3/26/2004 00:29'!active: aBool	active = aBool ifTrue:[^self].	active ifTrue:[self unhighlight].	active _ aBool.	active ifTrue:[self highlight].! !!CCostumeHighlight methodsFor: 'accessing'!isActive	"Return true if this highlight is active"	^active == true! !!CCostumeHighlight methodsFor: 'accessing'!isActive: aBool	self active: aBool.! !!CCostumeHighlight methodsFor: 'accessing' stamp: 'ar 3/23/2004 21:12'!name	^name! !!CCostumeHighlight methodsFor: 'accessing' stamp: 'ar 3/23/2004 21:12'!name: aSymbol	name := aSymbol! !!CCostumeHighlight methodsFor: 'support' stamp: 'ar 4/28/2004 16:05'!expandBounds: aRectangle	"If the highlight draws beyound the given rectangle, 	return the bounds including the receiver."	self isActive ifFalse:[^aRectangle].	costume ifNil:[^aRectangle].	^aRectangle merge: costume highlightBounds.! !!CCostumeHighlight methodsFor: 'support' stamp: 'ar 3/23/2004 21:24'!noteInvalidationOf: aRectangle	"This message is sent when the costume the receiver highlights invalidates any of its areas."! !!CCostumeHighlight methodsFor: 'support'!priority	"Return the priority for this particular highlight. Possible values are:		< 0	- the highlight needs to be drawn *underneith* the target			  Example: drop shadows.		= 0	- the highlight does *NOT* need to be drawn 			  but performs a state based modification of the target			  Example: change of border style		> 0	- the highlight needs to be drawn *on top* of the target			  Example: framing highlights.	"	^1! !!CCostumeHighlight methodsFor: 'highlighting' stamp: 'ar 3/23/2004 21:33'!drawHighlightOn: aCanvas	self isActive ifTrue:[^self drawOn: aCanvas].! !!CCostumeHighlight methodsFor: 'highlighting' stamp: 'ar 3/23/2004 21:32'!drawOn: aCanvas	"If the highlight is a procedural highlight, draw it for our costume on the target canvas."! !!CCostumeHighlight methodsFor: 'highlighting' stamp: 'ar 3/23/2004 22:00'!highlight	"Highlight the given costume."	(self isActive and:[costume notNil]) ifTrue:[costume invalidate]. "trigger redraw"! !!CCostumeHighlight methodsFor: 'highlighting' stamp: 'ar 4/28/2004 16:06'!unhighlight	"Unhighlight the given costume."	self isActive ifTrue:[costume ifNotNil:[costume invalidate]]. "trigger redraw"! !!CBorderHighlight methodsFor: 'accessing' stamp: 'ar 3/23/2004 21:35'!border	^border! !!CBorderHighlight methodsFor: 'accessing' stamp: 'bf 3/30/2004 10:37'!border: aBorder	border := aBorder.	self invalidate.	^ aBorder! !!CBorderHighlight methodsFor: 'highlighting' stamp: 'ar 3/23/2004 21:41'!highlight	"Highlight the given costume."	prior := nil.	self isActive ifTrue:[		prior _ costume border copy.		costume border: border.	].! !!CBorderHighlight methodsFor: 'highlighting' stamp: 'ar 3/23/2004 21:41'!unhighlight	"Unhighlight the given costume."	self isActive ifTrue:[costume border: prior].	prior := nil.! !!CBorderHighlight methodsFor: 'support'!priority	"Return the priority for this particular highlight. Possible values are:		< 0	- the highlight needs to be drawn *underneith* the target			  Example: drop shadows.		= 0	- the highlight does *NOT* need to be drawn 			  but performs a state based modification of the target			  Example: change of border style		> 0	- the highlight needs to be drawn *on top* of the target			  Example: framing highlights.	"	^0! !!CCoronaHighlight methodsFor: 'highlighting' stamp: 'ar 3/27/2004 17:50'!drawOn: aCanvas	| colorToUse offsetToUse newForm f aShadow |	(aCanvas seesNothingOutside: costume localBounds) ifTrue:[^self].	colorToUse := self color.	offsetToUse := self width.	active := false. "disable the receiver for drawing the shadow"	aShadow := costume shadowForm.	active := true.	aShadow offset: 0@0.	f := ColorForm extent: aShadow extent depth: 1.	aShadow displayOn: f.	f colors: {Color transparent. colorToUse}.	newForm _ Form extent: offsetToUse * 2 + aShadow extent depth: 32.     (WarpBlt toForm: newForm)		sourceForm: f;		cellSize: 2; 		combinationRule: 3;		copyQuad: f boundingBox innerCorners toRect: newForm boundingBox.	aCanvas 		translateBy: offsetToUse negated		during: [ :shadowCanvas |			shadowCanvas shadowColor: colorToUse.			shadowCanvas paintImage: newForm at: costume origin.		].! !!CCoronaHighlight methodsFor: 'highlighting' stamp: 'ar 3/23/2004 21:46'!highlight: aCostume	"Highlight the given costume."	self isActive ifTrue:[aCostume invalidateLayout; invalidate]. "trigger redraw"! !!CCoronaHighlight methodsFor: 'highlighting' stamp: 'ar 3/23/2004 21:46'!unhighlight: aCostume	"Highlight the given costume."	self isActive ifTrue:[aCostume invalidateLayout; invalidate]. "trigger redraw"! !!CCoronaHighlight methodsFor: 'support' stamp: 'ar 3/23/2004 21:21'!expandBounds: aRectangle	"If the highlight draws beyound the given rectangle, 	return the bounds including the receiver."	self isActive ifFalse:[^aRectangle].	^aRectangle expandBy: self width! !!CCoronaHighlight methodsFor: 'support'!priority	"Return the priority for this particular highlight. Possible values are:		< 0	- the highlight needs to be drawn *underneith* the target			  Example: drop shadows.		= 0	- the highlight does *NOT* need to be drawn 			  but performs a state based modification of the target			  Example: change of border style		> 0	- the highlight needs to be drawn *on top* of the target			  Example: framing highlights.	"	^-1! !!CCoronaHighlight methodsFor: 'accessing'!color	^color ifNil:[Color blue alpha: 0.5]! !!CCoronaHighlight methodsFor: 'accessing' stamp: 'ar 3/23/2004 21:46'!color: aColor	color _ aColor.	self invalidate.! !!CCoronaHighlight methodsFor: 'accessing'!width	^width ifNil:[10@10]! !!CCoronaHighlight methodsFor: 'accessing' stamp: 'bf 3/30/2004 10:45'!width: aPoint	width _ aPoint.	self invalidate.	^ aPoint! !!CCostumeTextHolder methodsFor: 'initialize' stamp: 'ar 3/23/2004 19:52'!changed	costume signal: #textChanged.! !!CCostumeTextHolder methodsFor: 'initialize' stamp: 'ar 3/23/2004 19:50'!initialize	displaying := false.	color := Color black.	inset := 3@1.	offset := 0@0.	wrapContents := false.	anchorPoint := #center.	borderWidth := 0.	borderColor := Color transparent.	self text:''.! !!CCostumeTextHolder methodsFor: 'initialize' stamp: 'ar 3/25/2004 17:34'!loadFrom: aTextHolder	(aTextHolder isString or:[aTextHolder isText])		ifTrue:[^self text: aTextHolder].	text := aTextHolder text.	offset := aTextHolder offset.	color := aTextHolder color.	borderWidth := aTextHolder borderWidth.	borderColor := aTextHolder borderColor.	anchorPoint := aTextHolder anchorPoint.	inset := aTextHolder inset.	showCaret := aTextHolder showCaret.	wrapContents := aTextHolder wrapContents.	emphasis := aTextHolder emphasis.	font := aTextHolder font.! !!CCostumeTextHolder methodsFor: 'accessing' stamp: 'ar 3/23/2004 19:46'!anchorPoint	^anchorPoint! !!CCostumeTextHolder methodsFor: 'accessing' stamp: 'ar 3/23/2004 19:56'!anchorPoint: aSymbol	anchorPoint = aSymbol ifTrue:[^self].	anchorPoint := aSymbol asSymbol.	self invalidate.! !!CCostumeTextHolder methodsFor: 'accessing' stamp: 'ar 3/23/2004 19:46'!asText	^text! !!CCostumeTextHolder methodsFor: 'accessing' stamp: 'ar 3/23/2004 19:46'!attributes	^self text attributesAt: 1! !!CCostumeTextHolder methodsFor: 'accessing' stamp: 'ar 3/23/2004 19:46'!attributes: attrs	self text: (Text string: self text string attributes: attrs)! !!CCostumeTextHolder methodsFor: 'accessing' stamp: 'ar 3/23/2004 19:58'!borderColor	^borderColor! !!CCostumeTextHolder methodsFor: 'accessing' stamp: 'bf 3/30/2004 10:38'!borderColor: aColor	borderColor = aColor ifTrue:[^self].	borderColor := aColor.	self invalidate.	^ aColor! !!CCostumeTextHolder methodsFor: 'accessing' stamp: 'ar 3/23/2004 19:59'!borderWidth	^borderWidth! !!CCostumeTextHolder methodsFor: 'accessing' stamp: 'bf 3/30/2004 10:40'!borderWidth: aNumber	| newWidth oldWidth |	oldWidth := borderWidth.	newWidth := (aNumber ifNil:[0]) asNumber max: 0.	newWidth = oldWidth ifTrue:[^self].	newWidth > oldWidth ifTrue:[self invalidate].	borderWidth := newWidth.	newWidth <= oldWidth ifTrue:[self invalidate].	self invalidateLayout.	^aNumber! !!CCostumeTextHolder methodsFor: 'accessing' stamp: 'ar 3/23/2004 19:46'!bounds	^0@0 extent: self paragraph extent + (inset*2)! !!CCostumeTextHolder methodsFor: 'accessing' stamp: 'ar 3/23/2004 19:57'!color	^color! !!CCostumeTextHolder methodsFor: 'accessing' stamp: 'ar 3/23/2004 19:58'!color: aColor	color = aColor ifTrue:[^self].	color _ aColor asColor.	self invalidate.! !!CCostumeTextHolder methodsFor: 'accessing' stamp: 'ar 3/23/2004 19:46'!contents	^self text asString! !!CCostumeTextHolder methodsFor: 'accessing' stamp: 'ar 3/23/2004 19:46'!contents: aText	^self text: aText! !!CCostumeTextHolder methodsFor: 'accessing' stamp: 'ar 4/4/2004 21:10'!editor	editor ifNil:[		editor := CTextParagraphEditor new.		editor costume: self.		editor paragraph: self paragraph.	].	^editor! !!CCostumeTextHolder methodsFor: 'accessing' stamp: 'ar 3/23/2004 19:46'!emphasis	^emphasis ifNil:[0]! !!CCostumeTextHolder methodsFor: 'accessing' stamp: 'ar 3/23/2004 19:46'!emphasis: emph	| copy code attr |	emphasis := emph.	copy := self text copy.	1 to: 3 do:[:i|		code := 1 bitShift: i-1.		attr := TextEmphasis new emphasisCode: code.		copy removeAttribute: attr from: 1 to: copy size.	].	self text: copy.! !!CCostumeTextHolder methodsFor: 'accessing' stamp: 'ar 3/23/2004 19:46'!font	font ifNotNil:[^font].	(self text attributesAt: 1) do:[:each|		each class == TextFontReference ifTrue:[^each font].	].	^TextStyle defaultFont! !!CCostumeTextHolder methodsFor: 'accessing' stamp: 'ar 3/23/2004 19:46'!font: aFont	font := aFont.	self text: self text copy.! !!CCostumeTextHolder methodsFor: 'accessing' stamp: 'ar 4/4/2004 21:11'!getEditor	^editor! !!CCostumeTextHolder methodsFor: 'accessing' stamp: 'ar 3/23/2004 19:46'!inset	^inset! !!CCostumeTextHolder methodsFor: 'accessing' stamp: 'ar 3/23/2004 19:55'!inset: aPoint	inset := aPoint.	self invalidate.	self invalidateLayout.! !!CCostumeTextHolder methodsFor: 'accessing' stamp: 'ar 3/23/2004 19:46'!minHeight	^0! !!CCostumeTextHolder methodsFor: 'accessing' stamp: 'ar 3/23/2004 19:46'!minWidth	self text isEmpty ifTrue:[^0].	^2*(inset asPoint x) + 2! !!CCostumeTextHolder methodsFor: 'accessing' stamp: 'ar 3/23/2004 19:46'!minimalTextExtent	"Answer the minimal extent this text can be represented in.	Note: For both, wrapped and non-wrapped text	we take the current editor extent. Obviously, this is correct for wrapped	text but also for non-wrapped since the editor has layed out the text	in its current extent which means that it is possible to represent the	text in these minimal bounds."	^self paragraph minimalTextExtent + (inset * 2)! !!CCostumeTextHolder methodsFor: 'accessing' stamp: 'ar 3/23/2004 19:49'!modified: aBool	costume ifNotNil:[costume signal: #textModified].! !!CCostumeTextHolder methodsFor: 'accessing' stamp: 'ar 3/23/2004 19:46'!offset	^offset! !!CCostumeTextHolder methodsFor: 'accessing' stamp: 'ar 3/23/2004 19:57'!offset: aPoint	offset := aPoint.	self invalidate.! !!CCostumeTextHolder methodsFor: 'accessing' stamp: 'ar 3/23/2004 19:46'!paragraph	paragraph ifNil:[self updateParagraphExtent].	^paragraph! !!CCostumeTextHolder methodsFor: 'accessing' stamp: 'ar 3/23/2004 19:46'!showCaret	"Answer the value of the receiver's showCaret property.	Values:		false	-	never show the caret		nil		-	show the caret if the receiver has the input focus		true	-	show the caret unless nothing is selected and not input focus"	^showCaret! !!CCostumeTextHolder methodsFor: 'accessing' stamp: 'ar 5/19/2004 15:20'!showCaret: aBoolOrNil	"Set the value of the receiver's showCaret property.	Values:		false	-	never show the caret		nil		-	show the caret if the receiver has the input focus		true	-	show the caret unless nothing is selected and not input focus"	showCaret := aBoolOrNil.	editor ifNotNil:[self invalidate: editor selectionRect].! !!CCostumeTextHolder methodsFor: 'accessing' stamp: 'ar 3/23/2004 19:46'!text	^text! !!CCostumeTextHolder methodsFor: 'accessing' stamp: 'bf 3/30/2004 11:33'!text: aText	| code attr newFont newEmphasis |	text == aText ifTrue:[^aText].	costume ifNotNil:[costume scrollOffset: 0@0].	newFont := nil.	newEmphasis := 0.	aText isText ifTrue:[		newFont := aText font.		newEmphasis := aText emphasis.	].	text := aText asText.	(newFont isNil and:[font notNil]) ifTrue:[		text addAttribute: (TextFontReference toFont: font).		newFont := font.	].	(newEmphasis = 0 and:[self emphasis ~= 0]) ifTrue:[		1 to: 3 do:[:i|			code := 1 bitShift: i-1.			(self emphasis bitAnd: code) = 0 ifFalse:[				attr := TextEmphasis new emphasisCode: code.				text addAttribute: attr]].		newEmphasis := emphasis.	].	font := newFont.	emphasis := newEmphasis.	paragraph := editor := nil.	self updateParagraphExtent.	costume ifNotNil:[		self invalidate.		self invalidateLayout.		costume signal: #textModified.		costume signal: #textSelectionChanged.	].	^aText! !!CCostumeTextHolder methodsFor: 'accessing' stamp: 'ar 3/23/2004 19:49'!textBounds	^costume ifNil:[0@0 extent: 999999@999999] ifNotNil:[costume layoutBounds]! !!CCostumeTextHolder methodsFor: 'accessing' stamp: 'ar 3/24/2004 12:50'!textSelectionChanged	costume ifNotNil:[costume signal: #textSelectionChanged].! !!CCostumeTextHolder methodsFor: 'accessing' stamp: 'ar 3/23/2004 19:46'!wrapContents	^wrapContents! !!CCostumeTextHolder methodsFor: 'accessing' stamp: 'ar 3/23/2004 19:56'!wrapContents: aBool	wrapContents = aBool ifTrue:[^self].	wrapContents := aBool.	costume ifNotNil:[		self updateParagraphExtent.		self invalidate.		self invalidateLayout.	].! !!CCostumeTextHolder methodsFor: 'testing' stamp: 'ar 3/23/2004 19:46'!hasKeyboardFocus	costume ifNil:[^false] ifNotNil:[^costume hasKeyboardFocus]! !!CCostumeTextHolder methodsFor: 'testing' stamp: 'ar 5/6/2004 16:52'!wantsCaretShowingIn: myEditor	"Answer whether the receiver would like to have the caret showing."	showCaret ifNotNil:[^showCaret].	costume ifNil:[^false].	"otherwise, always show it if I have the focus"	costume hasKeyboardFocus ifTrue:[^true].	"and then only if there is a range selected"	^myEditor markBlock ~= myEditor pointBlock! !!CCostumeTextHolder methodsFor: 'serializing' stamp: 'ar 3/23/2004 20:01'!readFieldsFrom: deSerializer	text := deSerializer readField: #text ifAbsent:[text].	offset := deSerializer readField: #offset ifAbsent:[offset].	color := deSerializer readField: #color ifAbsent:[color].	borderColor := deSerializer readField: #borderColor ifAbsent:[borderColor].	borderWidth := deSerializer readField: #borderWidth ifAbsent:[borderColor].	anchorPoint := deSerializer readField: #anchorPoint ifAbsent:[anchorPoint].	inset := deSerializer readField: #inset ifAbsent:[inset].	showCaret := deSerializer readField: #showCaret ifAbsent:[showCaret].	wrapContents := deSerializer readField: #wrapContents ifAbsent:[wrapContents].	emphasis := deSerializer readField: #emphasis ifAbsent:[emphasis].	font := deSerializer readField: #font ifAbsent:[font].! !!CCostumeTextHolder methodsFor: 'serializing' stamp: 'ar 3/23/2004 20:01'!writeFieldsOn: aSerializer	aSerializer writeField: #text value: text.	aSerializer writeField: #offset value: offset.	aSerializer writeField: #color value: color.	aSerializer writeField: #borderWidth value: borderWidth. 	aSerializer writeField: #borderColor value: borderColor.	aSerializer writeField: #anchorPoint value: anchorPoint.	aSerializer writeField: #inset value: inset.	aSerializer writeField: #showCaret value: showCaret.	aSerializer writeField: #wrapContents value: wrapContents.	aSerializer writeField: #emphasis value: emphasis.	aSerializer writeField: #font value: font.! !!CCostumeTextHolder methodsFor: 'scrolling' stamp: 'ar 3/23/2004 19:47'!scrollOffset	^costume scrollOffset! !!CCostumeTextHolder methodsFor: 'scrolling' stamp: 'ar 3/23/2004 19:49'!scrollToSelection	"Make the current selection visible"	| rect |	costume ifNil:[^nil].	rect := (self editor markBlock merge: self editor pointBlock) 		translateBy: self editorOffset.	costume player scrollToShow: rect.! !!CCostumeTextHolder methodsFor: 'drawing' stamp: 'ar 3/25/2004 22:54'!containsPoint: aPoint	"Later, we might do a better test"	^true! !!CCostumeTextHolder methodsFor: 'drawing' stamp: 'ar 3/23/2004 19:59'!drawBorderedTextOn: aCanvas	| para rect form x y bc |	para := self paragraph.	bc := borderColor.	bc isTransparent ifTrue:[		aCanvas translateBy: 1@1.		aCanvas paragraph: para bounds: para bounds color: self color.		aCanvas translateBy: -1@-1.		^self.	].	rect := para bounds intersect: (aCanvas clipRect expandBy: 1).	form := Form extent: rect extent depth: 8.	(CTransformCanvas on: form) 		translateBy: rect origin negated;		paragraph: para bounds: para bounds color: self color.	x := rect left + 1.	y := rect top + 1.	aCanvas stencil: form  at: (x+1)@(y) color: bc.	aCanvas stencil: form  at: (x+1)@(y+1) color: bc.	aCanvas stencil: form  at: (x)@(y+1) color: bc.	aCanvas stencil: form  at: (x-1)@(y+1) color: bc.	aCanvas stencil: form  at: (x-1)@(y) color: bc.	aCanvas stencil: form  at: (x-1)@(y-1) color: bc.	aCanvas stencil: form  at: (x)@(y-1) color: bc.	aCanvas stencil: form  at: (x+1)@(y-1) color: bc.	aCanvas paintImage: form at: x@y.! !!CCostumeTextHolder methodsFor: 'drawing' stamp: 'ar 3/23/2004 19:59'!drawOn: aCanvas in: drawingBounds	| para box ofs |	text size = 0 ifTrue:[^self].	displaying := true.	para := self paragraph.	box := 0@0 extent: para extent + (inset * 2).	ofs := (drawingBounds perform: anchorPoint) - (box perform: anchorPoint).	ofs := ofs + offset.	aCanvas translateBy: ofs + inset during:[:cc|		(borderWidth > 0) ifTrue:[			self drawBorderedTextOn: cc.		] ifFalse:[			cc clipBy: (0@0 extent: para extent) during:[:clip|				clip paragraph: para bounds: para bounds color: color.			].		].	].	displaying := false.! !!CCostumeTextHolder methodsFor: 'drawing' stamp: 'ar 3/23/2004 19:48'!invalidate: aRectangle	costume ifNotNil:[costume invalidate: (aRectangle translateBy: self editorOffset)].! !!CCostumeTextHolder methodsFor: 'anchoring' stamp: 'ar 3/23/2004 19:46'!adjustTextAnchor: aCostume	"NOTE: Embedded costumes are relocated during display phase"	aCostume textAnchorType == #document ifTrue:[^self].	displaying ifFalse:[self editor adjustTextAnchor: aCostume]! !!CCostumeTextHolder methodsFor: 'keyboard' stamp: 'ar 3/23/2004 19:46'!keyboardFocusEnter	showCaret == false ifFalse:[self invalidate: self editor selectionRect].! !!CCostumeTextHolder methodsFor: 'keyboard' stamp: 'ar 3/23/2004 19:46'!keyboardFocusLeave	showCaret == true ifFalse:[self invalidate: self editor selectionRect].! !!CCostumeTextHolder methodsFor: 'private' stamp: 'ar 5/19/2004 14:49'!cursorPoint	^costume cursorPoint - self editorOffset.! !!CCostumeTextHolder methodsFor: 'private' stamp: 'ar 3/23/2004 19:49'!editorOffset	| ofs |	ofs := inset.	costume ifNotNil:[ofs := ofs + costume border width].	^ofs! !!CCostumeTextHolder methodsFor: 'private' stamp: 'ar 4/4/2004 21:10'!updateParagraphExtent	| rightX |	paragraph ifNil:[paragraph := CTextParagraph new].	rightX := (self textBounds insetBy: inset) extent x.	(self wrapContents) ifTrue:[		paragraph			compose: text			style: paragraph textStyle			from: 1			in: (0@0 extent: rightX @ 999999999).	] ifFalse:[		paragraph			compose:  text			style: paragraph textStyle			from: 1			in: (0@0 extent: 999999999 @ 999999999).		paragraph adjustRightXBy: 999999999 - paragraph width.	].! !!CCursorHighlight methodsFor: 'accessing'!cursor	^cursor! !!CCursorHighlight methodsFor: 'accessing'!cursor: aCursor	cursor _ aCursor.! !!CCursorHighlight methodsFor: 'highlighting' stamp: 'ar 3/23/2004 21:37'!highlight	priorCursor _ nil.	self isActive ifTrue:[		priorCursor _ costume mouseCursor.		costume mouseCursor: cursor.	].! !!CCursorHighlight methodsFor: 'highlighting' stamp: 'ar 3/23/2004 21:38'!unhighlight	self isActive ifTrue:[costume mouseCursor: priorCursor].	priorCursor _ nil.! !!CDirectoryEntry methodsFor: 'accessing' stamp: 'ar 3/14/2004 02:30'!creationTime	^entry creationTime! !!CDirectoryEntry methodsFor: 'accessing' stamp: 'ar 3/14/2004 02:28'!directory	"Answer the directory of the receiver"	<bewareOf: #directoryChanged>	^self propertyValueAt: #directory! !!CDirectoryEntry methodsFor: 'accessing' stamp: 'ar 3/14/2004 02:28'!directory: aValue	"Modify the receiver's directory"	^self propertyValueAt: #directory put: aValue with: #directoryChanged! !!CDirectoryEntry methodsFor: 'accessing' stamp: 'ar 3/14/2004 02:28'!entry	"Answer the entry of the receiver"	<bewareOf: #entryChanged>	^self propertyValueAt: #entry! !!CDirectoryEntry methodsFor: 'accessing' stamp: 'ar 3/14/2004 02:28'!entry: aValue	"Modify the receiver's entry"	^self propertyValueAt: #entry put: aValue with: #entryChanged! !!CDirectoryEntry methodsFor: 'accessing' stamp: 'ar 3/14/2004 02:33'!extension	self isDirectory ifTrue:[^''].	^entry name 		copyFrom: (entry name lastIndexOf: directory class extensionDelimiter ifAbsent:[name size]) + 1 		to: entry name size! !!CDirectoryEntry methodsFor: 'accessing' stamp: 'ar 3/14/2004 02:30'!fileName	^entry name! !!CDirectoryEntry methodsFor: 'accessing' stamp: 'ar 3/14/2004 02:31'!fileSize	^entry fileSize! !!CDirectoryEntry methodsFor: 'accessing' stamp: 'ar 3/14/2004 03:21'!icon	"Answer the icon of the receiver"	<bewareOf: #iconChanged>	^(self propertyValueAt: #icon) ifNil:[		icon := self getIcon.		icon]! !!CDirectoryEntry methodsFor: 'accessing' stamp: 'ar 3/14/2004 03:17'!icon: aValue	"Modify the receiver's icon"	^self propertyValueAt: #icon put: aValue with: #iconChanged! !!CDirectoryEntry methodsFor: 'accessing' stamp: 'ar 3/14/2004 02:31'!isDirectory	^entry isDirectory! !!CDirectoryEntry methodsFor: 'accessing' stamp: 'ar 3/25/2004 19:27'!md5Hash	^CMD5Hasher hashMessage: entry name, entry fileSize, entry modificationTime.! !!CDirectoryEntry methodsFor: 'accessing' stamp: 'ar 3/14/2004 02:31'!modificationTime	^entry modificationTime! !!CDirectoryEntry methodsFor: 'accessing' stamp: 'ar 3/14/2004 02:31'!name	^entry name! !!CDirectoryEntry methodsFor: 'utilities' stamp: 'ar 3/14/2004 03:18'!appIcon	^self defaultIcon! !!CDirectoryEntry methodsFor: 'utilities' stamp: 'ar 3/14/2004 03:18'!defaultIcon	^DefaultIcon ifNil:[DefaultIcon := Form extent: 64@64 depth: 8]! !!CDirectoryEntry methodsFor: 'utilities' stamp: 'ar 3/14/2004 03:18'!defaultImageIcon	^self defaultIcon! !!CDirectoryEntry methodsFor: 'utilities' stamp: 'ar 3/14/2004 03:19'!directoryIcon	^self defaultIcon! !!CDirectoryEntry methodsFor: 'utilities' stamp: 'ar 3/14/2004 03:17'!getIcon	"Retrieve the icon for this entry"	| types mimeType |	self isDirectory ifTrue:[^self directoryIcon].	types := directory mimeTypesFor: name.	types isEmptyOrNil ifTrue:[^self defaultIcon].	mimeType := types first.	('image/gif' = mimeType) ifTrue:[^self imageIcon].	('image/bmp' = mimeType) ifTrue:[^self imageIcon].	('image/png' = mimeType) ifTrue:[^self imageIcon].	('image/jpeg' = mimeType) ifTrue:[^self imageIcon].	('image/*' match: mimeType) ifTrue:[^self defaultImageIcon].	('audio/*' match: mimeType) ifTrue:[^self soundIcon].	('video/*' match: mimeType) ifTrue:[^self videoIcon].	('application/*' match: mimeType) ifTrue:[^self appIcon].	('text/*' match: mimeType) ifTrue:[^self textIcon].	^self defaultIcon! !!CDirectoryEntry methodsFor: 'utilities' stamp: 'ar 3/14/2004 04:04'!getImageIcon	| cacheDir hashName file form newIcon scale extent hash |	hash := self md5Hash.	IconCache ifNil:[IconCache := WeakValueDictionary new].	newIcon := IconCache at: hash ifAbsent:[nil].	newIcon ifNotNil:[^newIcon].	cacheDir := FileDirectory default directoryNamed: '.thumbs'.	cacheDir assureExistence.	"Stage 1: Try to find image in cache"	hashName := hash hex allButFirst: 3.	file := [cacheDir readOnlyFileNamed: hashName] 		on: FileDoesNotExistException do:[:ex| ex return: nil].	file ifNotNil:[		[			newIcon := [Form fromBinaryStream: file] on: Error do:[:ex| ex return: nil].		] ensure:[file close].		newIcon ifNotNil:[IconCache at: hash put: newIcon].		^newIcon ifNil:[self defaultImageIcon]	].	"Stage 2: Create a new icon"	file := [directory readOnlyFileNamed: self fileName] on: Error do:[:ex| ex return: nil].	file ifNil:[^self defaultImageIcon].	[		[form := Form fromBinaryStream: file] ensure:[file close].		newIcon := Form extent: 64@64 depth: form depth.		scale := 64.0 / (form width max: form height) min: 8.		extent := (form extent * scale) truncated.		form drawOn: (CTransformCanvas on: newIcon) in: (newIcon extent - extent // 2 extent: extent).	] on: Error do:[:ex| ex return].	"If reading the image failed create a new (empty) cache entry 	to indicate broken file and avoid future read attempts"	file := cacheDir forceNewFileNamed: hashName.	[		newIcon ifNotNil:[PNGReadWriter putForm: newIcon onStream: file].	] ensure:[file close].	IconCache at: hash put: newIcon.	^newIcon ifNil:[self defaultImageIcon]! !!CDirectoryEntry methodsFor: 'utilities' stamp: 'ar 3/26/2004 03:43'!imageIcon	^self getImageIcon ifNil:[DefaultIcon]! !!CDirectoryEntry methodsFor: 'utilities' stamp: 'ar 3/14/2004 03:19'!soundIcon	^self defaultIcon! !!CDirectoryEntry methodsFor: 'utilities' stamp: 'ar 3/14/2004 03:19'!textIcon	^self defaultIcon! !!CDirectoryEntry methodsFor: 'utilities' stamp: 'ar 3/14/2004 03:19'!videoIcon	^self defaultIcon! !!CDropShadowHighlight methodsFor: 'initialize-release' stamp: 'ar 3/23/2004 21:42'!initialize	super initialize.	offset := 3@3.	color := Color black alpha: 0.5.! !!CDropShadowHighlight methodsFor: 'initialize-release' stamp: 'ar 12/8/2002 03:42'!releaseCachedState	shadowForm := nil.! !!CDropShadowHighlight methodsFor: 'accessing' stamp: 'ar 3/23/2004 21:42'!color	^color! !!CDropShadowHighlight methodsFor: 'accessing' stamp: 'ar 3/23/2004 21:41'!color: shadowColor	color _ shadowColor.	self invalidate.! !!CDropShadowHighlight methodsFor: 'accessing' stamp: 'ar 3/23/2004 21:42'!offset	^offset! !!CDropShadowHighlight methodsFor: 'accessing' stamp: 'ar 3/23/2004 21:41'!offset: shadowOffset	offset _ shadowOffset.	self invalidate.! !!CDropShadowHighlight methodsFor: 'highlighting' stamp: 'ar 3/25/2004 21:54'!drawOn: aCanvas	"Fix this. Should only need to recreate shadow if aCostume changes substantially"	| box localOffset |	localOffset := (costume globalToLocal transformDirection: self offset) rounded.	box := costume localBounds.	active := false. "disable to avoid recursion"	(shadowForm == nil or:[shadowForm extent ~= box extent]) 		ifTrue:[shadowForm := Form extent: box extent depth: 1.				dirty := true].	dirty == true ifTrue:[		shadowForm unhibernate.		shadowForm bits atAllPut: 0. "the fastest way"		(CTransformCanvas on: shadowForm) 			translateBy: box origin negated during:[:cc|				cc shadowColor: Color black.				cc roundCornersOf: costume in: box during:[cc draw: costume].		].		dirty := false.	].	(costume localAreasRemainingToFill: (box translateBy: localOffset)) do:[:clip|		aCanvas clipBy: clip during:[:cc| cc stencil: shadowForm at: localOffset color: self color].	].	active := true.! !!CDropShadowHighlight methodsFor: 'support' stamp: 'ar 3/23/2004 21:58'!expandBounds: aRectangle	"If the highlight draws beyound the given rectangle, 	return the bounds including the receiver."	| delta box |	self isActive ifFalse:[^aRectangle].	costume ifNil:[^aRectangle].	box := aRectangle.	delta := (costume globalToLocal transformDirection: self offset) rounded.	box := delta x >= 0 		ifTrue:[box right: aRectangle right + delta x]		ifFalse:[box left: aRectangle left + delta x].	box := delta y >= 0		ifTrue:[box bottom: aRectangle bottom + delta y]		ifFalse:[box top: aRectangle top + delta y].	^box! !!CDropShadowHighlight methodsFor: 'support' stamp: 'ar 3/23/2004 21:27'!noteInvalidationOf: aRectangle	dirty := true.! !!CDropShadowHighlight methodsFor: 'support'!priority	"Return the priority for this particular highlight. Possible values are:		< 0	- the highlight needs to be drawn *underneith* the target			  Example: drop shadows.		= 0	- the highlight does *NOT* need to be drawn 			  but performs a state based modification of the target			  Example: change of border style		> 0	- the highlight needs to be drawn *on top* of the target			  Example: framing highlights.	"	^-1! !!CDropShadowHighlight methodsFor: '*Tweak-Factory' stamp: 'ar 9/23/2003 00:17'!readFieldsFrom: deSerializer	active := deSerializer readField: #active ifAbsent:[active].	color := deSerializer readField: #color ifAbsent:[color].	offset := deSerializer readField: #offset ifAbsent:[offset].! !!CDropShadowHighlight methodsFor: '*Tweak-Factory' stamp: 'ar 9/23/2003 00:17'!writeFieldsOn: aSerializer	aSerializer writeField: #active value: active.	aSerializer writeField: #color value: color.	aSerializer writeField: #offset value: offset.! !!CEventBehavior methodsFor: 'initialize' stamp: 'ar 4/30/2004 17:51'!attachTo: anObject	"Attach the receiver to anObject"	target := anObject.	anObject attachBehavior: self.! !!CEventBehavior methodsFor: 'initialize' stamp: 'ar 4/30/2004 17:52'!detach	"Detach the receiver from its target"	| oldTarget |	target ifNil:[^self]. "I am not attached"	oldTarget := target.	target := nil.	oldTarget detachBehavior: self.! !!CEventBehavior methodsFor: 'accessing' stamp: 'ar 4/30/2004 17:42'!target	"Answer the target of the receiver"	<bewareOf: #targetChanged>	^self propertyValueAt: #target! !!CEventBehavior methodsFor: 'accessing' stamp: 'ar 4/30/2004 17:42'!target: aValue	"Modify the receiver's target"	^self propertyValueAt: #target put: aValue with: #targetChanged! !!CExampleBehavior methodsFor: 'events' stamp: 'ar 4/30/2004 17:57'!onMouseEnter	"The mouse goes over the target - make it opaque"	<on: mouseEnter in: target>	target fillAlpha := 1.! !!CExampleBehavior methodsFor: 'events' stamp: 'ar 4/30/2004 17:57'!onMouseLeave	"The mouse leaves the target - make it translucent"	<on: mouseLeave in: target>	target fillAlpha := 0.5.! !!CFillingHighlight methodsFor: 'accessing' stamp: 'ar 3/23/2004 21:48'!fill	^fill! !!CFillingHighlight methodsFor: 'accessing' stamp: 'ar 3/23/2004 21:48'!fill: aFill	fill _ aFill.	self invalidate.! !!CFillingHighlight methodsFor: 'highlighting' stamp: 'ar 4/28/2004 16:06'!drawOn: aCanvas	costume ifNil:[^self].	aCanvas 		fillRectangle: costume innerBounds 		fillStyle: fill 		borderStyle: CBorder default.! !!CFillingHighlight methodsFor: 'support'!priority	"Return the priority for this particular highlight. Possible values are:		< 0	- the highlight needs to be drawn *underneith* the target			  Example: drop shadows.		= 0	- the highlight does *NOT* need to be drawn 			  but performs a state based modification of the target			  Example: change of border style		> 0	- the highlight needs to be drawn *on top* of the target			  Example: framing highlights.	"	^1! !!CFramingHighlight methodsFor: 'accessing' stamp: 'ar 3/23/2004 21:46'!border	^border! !!CFramingHighlight methodsFor: 'accessing' stamp: 'bf 3/30/2004 10:37'!border: aBorder	border _ aBorder.	self invalidate.	^ aBorder! !!CFramingHighlight methodsFor: 'accessing'!inset	^inset ifNil:[0]! !!CFramingHighlight methodsFor: 'accessing'!inset: aNumberOrPoint	inset _ aNumberOrPoint.! !!CFramingHighlight methodsFor: 'highlighting' stamp: 'ar 3/23/2004 21:59'!drawOn: aCanvas	aCanvas 		fillRectangle: (costume localBounds insetBy: self inset) 		fillStyle: Color transparent 		borderStyle: border.! !!CFramingHighlight methodsFor: 'highlighting' stamp: 'ar 3/23/2004 21:59'!highlight	"Highlight the given costume."	costume ifNil:[^self].	self isActive ifTrue:[		costume invalidate. "trigger redraw"		self inset < 0 ifTrue:[costume invalidateLayout].	].! !!CFramingHighlight methodsFor: 'highlighting' stamp: 'ar 3/23/2004 21:45'!unhighlight	"Highlight the given costume."	self isActive ifTrue:[		costume invalidate. "trigger redraw"		self inset < 0 ifTrue:[costume invalidateLayout].	].! !!CFramingHighlight methodsFor: 'support' stamp: 'ar 3/23/2004 21:21'!expandBounds: aRectangle	"If the highlight draws beyound the given rectangle, 	return the bounds including the receiver."	self isActive ifFalse:[^aRectangle].	^aRectangle insetBy: self inset! !!CFramingHighlight methodsFor: 'support'!priority	"Return the priority for this particular highlight. Possible values are:		< 0	- the highlight needs to be drawn *underneith* the target			  Example: drop shadows.		= 0	- the highlight does *NOT* need to be drawn 			  but performs a state based modification of the target			  Example: change of border style		> 0	- the highlight needs to be drawn *on top* of the target			  Example: framing highlights.	"	^1! !!CLayoutPolicy methodsFor: 'initialize' stamp: 'ar 3/24/2004 02:19'!changed	^costume signal: #layoutChanged! !!CLayoutPolicy methodsFor: 'initialize' stamp: 'ar 3/24/2004 02:45'!invalidateLayout	costume ifNotNil:[		costume invalidateLayout.		self changed.	].! !!CLayoutPolicy methodsFor: 'initialize' stamp: 'ar 3/25/2004 18:03'!loadFrom: aLayout	"Do nothing - most layouts won't have any state"! !!CLayoutPolicy methodsFor: 'initialize' stamp: 'ar 3/24/2004 02:19'!releaseCachedState	^self flushLayoutCache! !!CLayoutPolicy methodsFor: 'accessing' stamp: 'ar 3/24/2004 03:32'!cellPositioning	^#center! !!CLayoutPolicy methodsFor: 'accessing' stamp: 'ar 3/24/2004 02:46'!hResizing	^costume hResizing! !!CLayoutPolicy methodsFor: 'accessing' stamp: 'ar 3/24/2004 02:46'!hResizing: aSymbol	^costume hResizing: aSymbol! !!CLayoutPolicy methodsFor: 'accessing' stamp: 'ar 3/24/2004 03:42'!layoutInset	^costume layoutInset! !!CLayoutPolicy methodsFor: 'accessing' stamp: 'ar 3/24/2004 03:42'!layoutInset: newInset	^costume layoutInset: newInset! !!CLayoutPolicy methodsFor: 'accessing' stamp: 'ar 3/24/2004 02:46'!vResizing	^costume vResizing! !!CLayoutPolicy methodsFor: 'accessing' stamp: 'ar 3/24/2004 02:46'!vResizing: aSymbol	^costume vResizing: aSymbol! !!CLayoutPolicy methodsFor: 'layout'!flushLayoutCache	"Flush any cached information associated with the receiver"! !!CLayoutPolicy methodsFor: 'layout'!layout: aMorph in: newBounds	"Compute the layout for the given morph based on the new bounds"! !!CLayoutPolicy methodsFor: 'layout'!minExtentOf: aMorph in: newBounds	"Return the minimal size aMorph's children would require given the new bounds"	^0@0! !!CLayoutPolicy methodsFor: 'testing'!isProportionalLayout	^false! !!CLayoutPolicy methodsFor: 'testing' stamp: 'ar 3/15/2003 17:01'!isSimpleLayout	^false! !!CLayoutPolicy methodsFor: 'testing'!isTableLayout	^false! !!CLayoutPolicy methodsFor: 'tk script' stamp: 'tk 7/8/2004 16:33'!entireObjectOn: converter using: myTempName	"Write squeak code for all my changes on the stream."	converter assign: myTempName new: self class.	"No details needed"! !!CLayoutPolicy methodsFor: 'serializing' stamp: 'ar 9/24/2003 18:04'!writeFieldsOn: aSerializer	self flushLayoutCache.	super writeFieldsOn: aSerializer! !!CLibraryEntry methodsFor: 'accessing' stamp: 'ar 3/17/2004 15:09'!image	"This method was automatically generated"	<bewareOf: #imageChanged>	^self propertyValueAt: #image! !!CLibraryEntry methodsFor: 'accessing' stamp: 'ar 3/11/2004 14:22'!image: aValue	"This method was automatically generated"	^self propertyValueAt: #image put: aValue with: #imageChanged! !!CLibraryEntry methodsFor: 'accessing' stamp: 'ar 3/17/2004 15:09'!label	"This method was automatically generated"	<bewareOf: #labelChanged>	^self propertyValueAt: #label! !!CLibraryEntry methodsFor: 'accessing' stamp: 'ar 3/11/2004 14:22'!label: aValue	"This method was automatically generated"	^self propertyValueAt: #label put: aValue with: #labelChanged! !!CLibraryEntry methodsFor: 'accessing' stamp: 'ar 3/17/2004 15:10'!library	"This method was automatically generated"	<bewareOf: #libraryChanged>	^self propertyValueAt: #library! !!CLibraryEntry methodsFor: 'accessing' stamp: 'ar 3/11/2004 14:22'!library: aValue	"This method was automatically generated"	^self propertyValueAt: #library put: aValue with: #libraryChanged! !!CLibraryEntry methodsFor: 'maker' stamp: 'ar 3/14/2004 15:18'!next	^value next! !!CListLayout methodsFor: 'layout' stamp: 'ar 3/21/2004 02:32'!flushLayoutCache	"Flush any cached information associated with the receiver"	minExtentCache _ nil.! !!CListLayout methodsFor: 'layout' stamp: 'ar 3/21/2004 02:49'!layout: aCostume in: newBounds	aCostume listDirection == #topToBottom		ifTrue:[^self layoutVertical: aCostume in: newBounds]		ifFalse:[^self layoutHorizontal: aCostume in: newBounds]! !!CListLayout methodsFor: 'layout' stamp: 'ar 3/21/2004 02:57'!layoutHorizontal: aCostume in: newBounds	"An optimized left-to-right list layout"	| min extraPerCell x y h w lastExtra nextExtra |	minExtentCache ifNil:[self minExtentHorizontal: aCostume in: newBounds].	min := minExtentCache x.	fillers > 0 ifTrue:[extraPerCell := (newBounds width - min max: 0) / fillers asFloat].	x := newBounds left.	y := newBounds top.	h := newBounds height.	nextExtra := lastExtra := 0.	aCostume layoutTargets do:[:cc|		(cc hResizing == #spaceFill) ifTrue:[			lastExtra := nextExtra.			nextExtra _ nextExtra + extraPerCell.			w _ nextExtra truncated - lastExtra truncated.		] ifFalse:[			w := cc bounds width.		].		cc bounds: (x@y extent: w@h).		x := x + w.	].! !!CListLayout methodsFor: 'layout' stamp: 'ar 3/21/2004 02:58'!layoutVertical: aCostume in: newBounds	"An optimized left-to-right list layout"	| min extraPerCell x y h w lastExtra nextExtra |	minExtentCache ifNil:[self minExtentVertical: aCostume in: newBounds].	min := minExtentCache y.	fillers > 0 ifTrue:[extraPerCell := (newBounds height - min max: 0) / fillers asFloat].	x := newBounds left.	y := newBounds top.	w := newBounds width.	nextExtra := lastExtra := 0.	aCostume layoutTargets do:[:cc|		(cc vResizing == #spaceFill) ifTrue:[			lastExtra := nextExtra.			nextExtra _ nextExtra + extraPerCell.			h _ nextExtra truncated - lastExtra truncated.		] ifFalse:[			h := cc bounds height.		].		cc bounds: (x@y extent: w@h).		y := y + h.	].! !!CListLayout methodsFor: 'layout' stamp: 'ar 3/21/2004 02:57'!minExtentHorizontal: aCostume in: newBounds	"An optimized left-to-right list layout"	| min |	min := fillers := 0.	aCostume layoutTargets do:[:cc|		(cc hResizing == #spaceFill) 			ifTrue:[fillers _ fillers + 1]			ifFalse:[min := min + cc width].	].	^minExtentCache := min @ 0! !!CListLayout methodsFor: 'layout' stamp: 'ar 3/21/2004 02:49'!minExtentOf: aCostume in: newBounds	minExtentCache ifNotNil:[^minExtentCache].	aCostume listDirection == #topToBottom		ifTrue:[^self minExtentVertical: aCostume in: newBounds]		ifFalse:[^self minExtentHorizontal: aCostume in: newBounds]! !!CListLayout methodsFor: 'layout' stamp: 'ar 3/21/2004 02:58'!minExtentVertical: aCostume in: newBounds	"An optimized left-to-right list layout"	| min |	min := fillers := 0.	aCostume layoutTargets do:[:cc|		(cc vResizing == #spaceFill) 			ifTrue:[fillers _ fillers + 1]			ifFalse:[min := min + cc height]	].	^minExtentCache := 0@min! !!CMenuItem methodsFor: 'initialize' stamp: 'ar 3/6/2004 22:31'!initialize	super initialize.	self checked: false.	self enabled: true.	self separator: false.	self label: 'MenuItem'.! !!CMenuItem methodsFor: 'accessing' stamp: 'ar 3/17/2004 15:10'!action	"This method was automatically generated"	<bewareOf: #actionChanged>	^self propertyValueAt: #action! !!CMenuItem methodsFor: 'accessing' stamp: 'ar 3/11/2004 14:23'!action: aValue	"This method was automatically generated"	^self propertyValueAt: #action put: aValue with: #actionChanged! !!CMenuItem methodsFor: 'accessing' stamp: 'ar 3/17/2004 15:10'!checked	"This method was automatically generated"	<bewareOf: #checkedChanged>	^self propertyValueAt: #checked! !!CMenuItem methodsFor: 'accessing' stamp: 'ar 3/11/2004 14:23'!checked: aValue	"This method was automatically generated"	^self propertyValueAt: #checked put: aValue with: #checkedChanged! !!CMenuItem methodsFor: 'accessing' stamp: 'ar 3/8/2004 15:26'!disable	^self enabled: false! !!CMenuItem methodsFor: 'accessing' stamp: 'ar 3/12/2004 15:10'!disabled	^self enabled not! !!CMenuItem methodsFor: 'accessing' stamp: 'ar 3/12/2004 15:10'!disabled: aBool	^self enabled: aBool not! !!CMenuItem methodsFor: 'accessing' stamp: 'ar 3/8/2004 15:26'!enable	^self enabled: true! !!CMenuItem methodsFor: 'accessing' stamp: 'ar 3/17/2004 15:10'!enabled	"This method was automatically generated"	<bewareOf: #enabledChanged>	^self propertyValueAt: #enabled! !!CMenuItem methodsFor: 'accessing' stamp: 'ar 3/11/2004 14:23'!enabled: aValue	"This method was automatically generated"	^self propertyValueAt: #enabled put: aValue with: #enabledChanged! !!CMenuItem methodsFor: 'accessing' stamp: 'ar 3/17/2004 15:10'!label	"This method was automatically generated"	<bewareOf: #labelChanged>	^self propertyValueAt: #label! !!CMenuItem methodsFor: 'accessing' stamp: 'ar 3/11/2004 14:23'!label: aValue	"This method was automatically generated"	^self propertyValueAt: #label put: aValue with: #labelChanged! !!CMenuItem methodsFor: 'accessing' stamp: 'ar 3/17/2004 15:11'!separator	"This method was automatically generated"	<bewareOf: #separatorChanged>	^self propertyValueAt: #separator! !!CMenuItem methodsFor: 'accessing' stamp: 'ar 3/11/2004 14:23'!separator: aValue	"This method was automatically generated"	^self propertyValueAt: #separator put: aValue with: #separatorChanged! !!CMenuItem methodsFor: 'accessing' stamp: 'ar 3/17/2004 15:11'!subMenu	"This method was automatically generated"	<bewareOf: #subMenuChanged>	^self propertyValueAt: #subMenu! !!CMenuItem methodsFor: 'accessing' stamp: 'ar 3/11/2004 14:23'!subMenu: aValue	"This method was automatically generated"	^self propertyValueAt: #subMenu put: aValue with: #subMenuChanged! !!CMultiColumnListSpec methodsFor: 'accessing' stamp: 'ar 3/12/2004 14:06'!action	"Answer the action of the receiver"	<bewareOf: #actionChanged>	^self propertyValueAt: #action! !!CMultiColumnListSpec methodsFor: 'accessing' stamp: 'ar 3/12/2004 10:49'!action: aValue	"Modify the receiver's action"	^self propertyValueAt: #action put: aValue with: #actionChanged! !!CMultiColumnListSpec methodsFor: 'accessing' stamp: 'ar 3/12/2004 14:06'!color	"Answer the color of the receiver"	<bewareOf: #colorChanged>	^self propertyValueAt: #color! !!CMultiColumnListSpec methodsFor: 'accessing' stamp: 'ar 3/12/2004 10:49'!color: aValue	"Modify the receiver's color"	^self propertyValueAt: #color put: aValue with: #colorChanged! !!CMultiColumnListSpec methodsFor: 'accessing' stamp: 'ar 3/12/2004 14:06'!drawSelector	"Answer the drawSelector of the receiver"	<bewareOf: #drawSelectorChanged>	^self propertyValueAt: #drawSelector! !!CMultiColumnListSpec methodsFor: 'accessing' stamp: 'ar 3/12/2004 10:49'!drawSelector: aValue	"Modify the receiver's drawSelector"	^self propertyValueAt: #drawSelector put: aValue with: #drawSelectorChanged! !!CMultiColumnListSpec methodsFor: 'accessing' stamp: 'ar 3/12/2004 14:06'!drawer	"Answer the drawer of the receiver"	<bewareOf: #drawerChanged>	^self propertyValueAt: #drawer! !!CMultiColumnListSpec methodsFor: 'accessing' stamp: 'ar 3/12/2004 10:49'!drawer: aValue	"Modify the receiver's drawer"	^self propertyValueAt: #drawer put: aValue with: #drawerChanged! !!CMultiColumnListSpec methodsFor: 'accessing' stamp: 'ar 3/12/2004 14:06'!label	"Answer the label of the receiver"	<bewareOf: #labelChanged>	^self propertyValueAt: #label! !!CMultiColumnListSpec methodsFor: 'accessing' stamp: 'ar 3/12/2004 10:49'!label: aValue	"Modify the receiver's label"	^self propertyValueAt: #label put: aValue with: #labelChanged! !!CMultiColumnListSpec methodsFor: 'accessing' stamp: 'ar 3/12/2004 14:06'!width	"Answer the width of the receiver"	<bewareOf: #widthChanged>	^self propertyValueAt: #width! !!CMultiColumnListSpec methodsFor: 'accessing' stamp: 'ar 3/12/2004 10:49'!width: aValue	"Modify the receiver's width"	^self propertyValueAt: #width put: aValue with: #widthChanged! !!CNoBorder methodsFor: 'accessing' stamp: 'ar 3/23/2004 17:02'!color	| aBorder |	(aBorder := costume border) == self 		ifTrue:[^Color transparent] 		ifFalse:[^aBorder color].! !!CNoBorder methodsFor: 'accessing' stamp: 'ar 3/23/2004 17:58'!color: aColor	| aBorder |	(aBorder := costume border) == self ifFalse:[^aBorder color: aColor].	aBorder := costume allocateBorder.	^aBorder color: aColor! !!CNoBorder methodsFor: 'accessing' stamp: 'ar 3/23/2004 17:02'!style	| aBorder |	(aBorder := costume border) == self 		ifTrue:[^#none] 		ifFalse:[^aBorder style].! !!CNoBorder methodsFor: 'accessing' stamp: 'ar 3/23/2004 17:58'!style: aSymbol	| aBorder |	(aBorder := costume border) == self ifFalse:[^aBorder style: aSymbol].	aSymbol == #none ifTrue:[^aSymbol].	aBorder := costume allocateBorder.	^aBorder style: aSymbol! !!CNoBorder methodsFor: 'accessing' stamp: 'ar 3/23/2004 17:02'!width	| aBorder |	(aBorder := costume border) == self 		ifTrue:[^0] 		ifFalse:[^aBorder width].! !!CNoBorder methodsFor: 'accessing' stamp: 'ar 3/23/2004 17:58'!width: aNumber	| aBorder |	(aBorder := costume border) == self ifFalse:[^aBorder width: aNumber].	aNumber isZero ifTrue:[^aNumber].	aBorder := costume allocateBorder.	^aBorder width: aNumber! !!CNoBorder methodsFor: 'testing' stamp: 'ar 3/23/2004 17:48'!isNoBorder	^true! !!CNoBorder methodsFor: 'testing' stamp: 'ar 3/23/2004 17:49'!isTranslucent	^false! !!CNoBorder methodsFor: 'copying' stamp: 'ar 3/25/2004 20:03'!copy	^CCostumeBorder new loadFrom: self! !!CNoBorder methodsFor: 'private' stamp: 'ar 3/23/2004 17:35'!expandBounds: box	^box! !!CNoBorder methodsFor: 'private' stamp: 'ar 3/23/2004 17:35'!insetBounds: box	^box! !!CNoBorder methodsFor: 'private' stamp: 'ar 3/23/2004 17:33'!trackColorFrom: aCostume! !!CNoFill methodsFor: 'accessing' stamp: 'ar 3/27/2004 17:32'!alpha	| aFill |	(aFill := costume fill) == self 		ifTrue:[^1] 		ifFalse:[^aFill alpha].! !!CNoFill methodsFor: 'accessing' stamp: 'ar 3/23/2004 17:56'!alpha: aNumber	| aFill |	(aFill := costume fill) == self ifFalse:[^aFill alpha: aNumber].	aNumber isZero ifTrue:[^aNumber].	aFill := costume allocateFill.	^aFill alpha: aNumber.! !!CNoFill methodsFor: 'accessing' stamp: 'ar 3/23/2004 17:06'!angle	| aFill |	(aFill := costume fill) == self 		ifTrue:[^0] 		ifFalse:[^aFill angle].! !!CNoFill methodsFor: 'accessing' stamp: 'ar 3/23/2004 17:56'!angle: aNumber	| aFill |	(aFill := costume fill) == self ifFalse:[^aFill angle: aNumber].	aNumber isZero ifTrue:[^aNumber].	aFill := costume allocateFill.	^aFill angle: aNumber.! !!CNoFill methodsFor: 'accessing' stamp: 'ar 3/27/2004 17:32'!color	| aFill |	(aFill := costume fill) == self 		ifTrue:[^Color white] 		ifFalse:[^aFill color].! !!CNoFill methodsFor: 'accessing' stamp: 'ar 3/23/2004 17:56'!color: aColor	| aFill |	(aFill := costume fill) == self ifFalse:[^aFill color: aColor].	aColor = Color transparent ifTrue:[^aColor].	aFill := costume allocateFill.	^aFill color: aColor! !!CNoFill methodsFor: 'accessing' stamp: 'ar 3/27/2004 17:32'!colors	| aFill |	(aFill := costume fill) == self 		ifTrue:[^Array with: Color white] 		ifFalse:[^aFill colors].! !!CNoFill methodsFor: 'accessing' stamp: 'ar 3/23/2004 17:57'!colors: colors	| aFill |	(aFill := costume fill) == self ifFalse:[^aFill colors: colors].	aFill := costume allocateFill.	^aFill colors: colors! !!CNoFill methodsFor: 'accessing' stamp: 'ar 3/27/2004 17:32'!gradientColor	| aFill |	(aFill := costume fill) == self 		ifTrue:[^Color white] 		ifFalse:[^aFill gradientColor].! !!CNoFill methodsFor: 'accessing' stamp: 'ar 3/23/2004 17:57'!gradientColor: aColor	| aFill |	(aFill := costume fill) == self ifFalse:[^aFill gradientColor: aColor].	aFill := costume allocateFill.	^aFill gradientColor: aColor! !!CNoFill methodsFor: 'accessing' stamp: 'ar 3/23/2004 17:07'!offset	| aFill |	(aFill := costume fill) == self 		ifTrue:[^0@0] 		ifFalse:[^aFill offset].! !!CNoFill methodsFor: 'accessing' stamp: 'ar 3/23/2004 17:57'!offset: aPoint	| aFill |	(aFill := costume fill) == self ifFalse:[^aFill offset: aPoint].	aFill := costume allocateFill.	^aFill offset: aPoint! !!CNoFill methodsFor: 'accessing' stamp: 'ar 3/27/2004 17:33'!primaryColor	| aFill |	(aFill := costume fill) == self 		ifTrue:[^Color white] 		ifFalse:[^aFill primaryColor].! !!CNoFill methodsFor: 'accessing' stamp: 'ar 3/23/2004 17:57'!primaryColor: aColor	| aFill |	(aFill := costume fill) == self ifFalse:[^aFill primaryColor: aColor].	aFill := costume allocateFill.	^aFill primaryColor: aColor! !!CNoFill methodsFor: 'accessing' stamp: 'ar 3/25/2004 19:56'!style	| aFill |	(aFill := costume fill) == self 		ifTrue:[^#none] 		ifFalse:[^aFill style].! !!CNoFill methodsFor: 'accessing' stamp: 'ar 3/23/2004 17:57'!style: aSymbol	| aFill |	(aFill := costume fill) == self ifFalse:[^aFill style: aSymbol].	aSymbol == #none ifTrue:[^aSymbol].	aFill := costume allocateFill.	^aFill style: aSymbol! !!CNoFill methodsFor: 'testing' stamp: 'ar 3/23/2004 17:08'!isBitmapFill	^false! !!CNoFill methodsFor: 'testing' stamp: 'ar 3/23/2004 17:08'!isGradientFill	^self isSolidFill not! !!CNoFill methodsFor: 'testing' stamp: 'ar 3/23/2004 17:53'!isNoFill	^true! !!CNoFill methodsFor: 'testing' stamp: 'ar 3/23/2004 17:08'!isOrientedFill	^false! !!CNoFill methodsFor: 'testing' stamp: 'ar 3/23/2004 17:08'!isRadialFill	^false! !!CNoFill methodsFor: 'testing' stamp: 'ar 3/23/2004 17:08'!isSolidFill	^false! !!CNoFill methodsFor: 'testing' stamp: 'ar 3/23/2004 17:08'!isTranslucent	^true! !!CNoFill methodsFor: 'testing' stamp: 'ar 3/23/2004 17:08'!isTransparent	^true! !!CNoFill methodsFor: 'converting' stamp: 'ar 3/23/2004 17:09'!asColor	^Color transparent! !!CNoFill methodsFor: 'copying' stamp: 'ar 3/25/2004 20:03'!copy	^CCostumeFill new loadFrom: self! !!CObjectMakerDeserializer methodsFor: 'importing' stamp: 'ar 10/18/2003 21:43'!import: data from: xmlNode	(xmlNode attributeAt: 'value') ifNotNil:[^self importLiteral: data from: xmlNode].	(xmlNode attributeAt: 'reference') ifNotNil:[^self importReference: data from: xmlNode].	(xmlNode attributeAt: 'data') ifNotNil:[^self importBitsArray: data from: xmlNode].	(xmlNode attributeAt: 'size') ifNotNil:[^self importSequence: data from: xmlNode].	(xmlNode attributeAt: 'class') ifNotNil:[^self importObject: data from: xmlNode].self error: 'cannot identify node type'! !!CObjectMakerDeserializer methodsFor: 'importing' stamp: 'ar 10/18/2003 21:43'!importBitsArray: data from: xmlNode	data fieldName: xmlNode name asSymbol.	data fieldType: #bits.	data fieldContents: (self importBitsOf: xmlNode).	data fieldClass: data fieldContents class.! !!CObjectMakerDeserializer methodsFor: 'importing' stamp: 'ar 10/18/2003 21:43'!importBitsOf: xmlNode	| src dst bits aClass size data |	aClass := self importClassAttribute: 'class' from: xmlNode.	size := self importIntegerAttribute: 'size' from: xmlNode.	data := self importStringAttribute: 'data' from: xmlNode.	bits := aClass basicNew: size.	src := data base64Decoded.	bits class isWords ifTrue:[		src := Form new hackBits: data.		dst := Form new hackBits: bits.		(BitBlt toForm: dst) sourceForm: src; combinationRule: 3; copyBits.		"(attributes at: #swapEnds) ifTrue:[bits swapEndsInFactory: self]."	] ifFalse:[		bits replaceFrom: 1 to: bits size with: data startingAt: 1.	].	^bits! !!CObjectMakerDeserializer methodsFor: 'importing' stamp: 'ar 10/18/2003 21:43'!importClassAttribute: key from: node	| className |	className := self importStringAttribute: key from: node.	className := self mapClassName: className.	^Smalltalk at: className asSymbol! !!CObjectMakerDeserializer methodsFor: 'importing' stamp: 'ar 10/18/2003 21:43'!importIntegerAttribute: key from: node	^(node attributeAt: key ifAbsent:[self errorNotFound: key]) asInteger! !!CObjectMakerDeserializer methodsFor: 'importing' stamp: 'ar 10/18/2003 21:43'!importLiteral: data from: xmlNode	data fieldName: xmlNode name asSymbol.	data fieldType: #literal.	data fieldContents: (self importValueFrom: xmlNode).	data fieldClass: data fieldContents class.! !!CObjectMakerDeserializer methodsFor: 'importing' stamp: 'ar 10/18/2003 21:43'!importObject: data from: xmlNode	| out |	data fieldName: xmlNode name asSymbol.	data partID: (xmlNode attributeAt: 'id').	data fieldType: #object.	data fieldClass: (self importClassAttribute: 'class' from: xmlNode).	out := WriteStream on: (Array new: 10).	xmlNode elementsDo:[:aNode| out nextPut: (self import: aNode)].	data fieldContents: out contents.! !!CObjectMakerDeserializer methodsFor: 'importing' stamp: 'ar 10/18/2003 21:43'!importReference: data from: xmlNode	data fieldName: xmlNode name asSymbol.	data fieldType: #reference.	data partID: (xmlNode attributeAt: 'reference').! !!CObjectMakerDeserializer methodsFor: 'importing' stamp: 'ar 10/18/2003 21:43'!importSequence: data from: xmlNode	| size out |	data fieldName: xmlNode name asSymbol.	data fieldType: #sequence.	data fieldClass: (self importClassAttribute: 'class' from: xmlNode).	size := self importIntegerAttribute: 'size' from: xmlNode.	out := WriteStream on: (Array new: size).	xmlNode elementsDo:[:aNode| out nextPut: (self import: aNode)].	data fieldContents: out contents.! !!CObjectMakerDeserializer methodsFor: 'importing' stamp: 'ar 10/18/2003 21:43'!importStringAttribute: key from: node	^node attributeAt: key ifAbsent:[self errorNotFound: key].! !!CObjectMakerDeserializer methodsFor: 'accessing' stamp: 'ar 2/14/2004 22:09'!objectMaker	^objectMaker! !!CObjectMakerDeserializer methodsFor: 'accessing' stamp: 'ar 2/14/2004 22:10'!objectMaker: aMaker	objectMaker := aMaker.! !!CObjectMakerDeserializer methodsFor: 'interface' stamp: 'ar 2/22/2004 03:55'!fieldsDo: aBlock	"Evaluate aBlock with all of the field names available in the receiver.	Note: We use a copy here since #readField: may swap elements."	makerPart contents clone do:[:assoc|		aBlock value: assoc key.	].! !!CObjectMakerDeserializer methodsFor: 'interface' stamp: 'ar 3/5/2004 15:40'!readField: fieldName ifAbsent: aBlock	| field pos fieldSymbol |	fieldSymbol := fieldName isString ifTrue:[fieldName asSymbol] ifFalse:[fieldName].	(field := contents next) ifNil:[^aBlock value].	field key == fieldSymbol ifTrue:[^field value valueInMaker: objectMaker].	pos := contents position.	[(field := contents next) == nil] whileFalse:[		field key == fieldSymbol ifTrue:[			contents originalContents swap: pos with: contents position.			contents position: pos.			^field value valueInMaker: objectMaker		].	].	contents position: pos-1.	^aBlock value! !!CObjectMakerDeserializer methodsFor: 'interface' stamp: 'ar 2/22/2004 03:53'!readObjectFrom: partData	makerPart := partData.	contents := ReadStream on: partData contents.	self readContentsOf: (partData valueInMaker: objectMaker)! !!CObjectMakerDeserializer methodsFor: 'private' stamp: 'ar 2/14/2004 22:08'!readContentsOf: anObject	^anObject readFieldsFrom: self! !!CObjectMakerImporter methodsFor: 'import-primitives' stamp: 'ar 3/25/2004 18:56'!importBits: bits from: xmlNode	| data src dst |	data := (xmlNode attributeAt: 'bits') base64Decoded unzipped.	bits class isWords ifTrue:[		src := Form new hackBits: data.		dst := Form new hackBits: bits.		(BitBlt toForm: dst) sourceForm: src; combinationRule: 3; copyBits.		swapEnds ifTrue:[bits swapEndsIn: self].	] ifFalse:[		bits replaceFrom: 1 to: bits size with: data startingAt: 1.	].	^bits! !!CObjectMakerImporter methodsFor: 'import-primitives' stamp: 'ar 11/17/2003 21:56'!importBoolean: xmlNode	^(xmlNode attributeAt: 'value') = 'true'! !!CObjectMakerImporter methodsFor: 'import-primitives' stamp: 'ar 11/17/2003 21:57'!importColor: xmlNode	| r g b a cc |	r := Number readFrom: (xmlNode attributeAt: 'red').	g := Number readFrom: (xmlNode attributeAt: 'green').	b := Number readFrom: (xmlNode attributeAt: 'blue').	a := Number readFrom: (xmlNode attributeAt: 'alpha').	cc := Color r: r g: g b: b.	a = 1.0 ifFalse:[cc := cc alpha: a].	^cc! !!CObjectMakerImporter methodsFor: 'import-primitives' stamp: 'ar 11/17/2003 21:57'!importLiteralAttribute: key from: node	| attr |	attr := node attributeAt: key ifAbsent:[self errorNotFound: key].	^self importLiteralFrom: attr! !!CObjectMakerImporter methodsFor: 'import-primitives' stamp: 'ar 11/17/2003 22:00'!importLiteralFrom: aString	| ch num |	aString = 'nil' ifTrue:[^nil].	aString = 'true' ifTrue:[^true].	aString = 'false' ifTrue:[^false].	ch := (aString at: 1).	"strings"	ch = $' ifTrue:[^self convertLiteralString: aString].	"symbols"	ch = $# ifTrue:[^self convertLiteralSymbol: aString].	"globals"	(ch isLetter and:[ch isUppercase]) ifTrue:[^Smalltalk at: (aString asSymbol)].	"numbers/points"	(ch = $- or:[ch isDigit]) ifTrue:[		num := self convertLiteralNumeric: aString.		num ifNotNil:[^num].	].	^Object readFrom: aString! !!CObjectMakerImporter methodsFor: 'import-primitives' stamp: 'ar 11/17/2003 21:57'!importNumber: xmlNode	^Number readFrom: (xmlNode attributeAt: 'value')! !!CObjectMakerImporter methodsFor: 'import-primitives' stamp: 'ar 11/17/2003 21:57'!importPoint: xmlNode	^(Number readFrom: (xmlNode attributeAt: 'x')) @		(Number readFrom: (xmlNode attributeAt: 'y'))! !!CObjectMakerImporter methodsFor: 'import-primitives' stamp: 'ar 11/17/2003 21:57'!importString: xmlNode	^xmlNode attributeAt: 'value'! !!CObjectMakerImporter methodsFor: 'import-primitives' stamp: 'ar 11/17/2003 21:58'!importStringAttribute: key from: node	^node attributeAt: key ifAbsent:[self errorNotFound: key].! !!CObjectMakerImporter methodsFor: 'import-primitives' stamp: 'ar 11/17/2003 21:58'!importSymbol: xmlNode	^(xmlNode attributeAt: 'value') asSymbol! !!CObjectMakerImporter methodsFor: 'import-primitives' stamp: 'ar 11/17/2003 21:58'!importUUID: xmlNode	^UUID fromString: (xmlNode attributeAt: 'value')! !!CObjectMakerImporter methodsFor: 'import-primitives' stamp: 'ar 11/17/2003 21:58'!importUndefinedObject: xmlNode	^nil! !!CObjectMakerImporter methodsFor: 'importing' stamp: 'ar 11/17/2003 21:54'!import: xmlNode	"Dispatch based on attributes"	| attr |	attr := xmlNode attributeAt: 'maker'.	attr ifNotNil:[^self import: xmlNode maker: attr].	attr := xmlNode attributeAt: 'type'.	attr ifNotNil:[^self import: xmlNode type: attr].	attr := xmlNode attributeAt: 'ref'.	attr ifNotNil:[^self import: xmlNode ref: attr].	attr := xmlNode attributeAt: 'global'.	attr ifNotNil:[^self import: xmlNode global: attr].	^self error: 'Unknown node type'! !!CObjectMakerImporter methodsFor: 'importing' stamp: 'ar 12/3/2003 01:23'!import: xmlNode global: globalName	| selector args part |	selector := xmlNode attributeAt: 'selector'.	args := Array streamContents:[:s|		xmlNode elementsDo:[:each|			s nextPut: (self import: each).		].	].	part := CGlobalPart new.	part globalName: globalName asSymbol.	selector ifNotNil:[part globalSelector: selector asSymbol].	part globalArgs: args.	parts nextPut: part.	^part! !!CObjectMakerImporter methodsFor: 'importing' stamp: 'ar 11/17/2003 23:30'!import: xmlNode maker: makerString	| size bits maker |	maker := self getMaker: makerString.	bits := xmlNode attributeAt: 'bits'.	bits ifNotNil:[^self importBits: xmlNode maker: maker data: bits].	size := xmlNode attributeAt: 'size'.	size ifNotNil:[^self importSequence: xmlNode maker: maker size: (Integer readFrom: size readStream)].	^self importObject: xmlNode maker: maker! !!CObjectMakerImporter methodsFor: 'importing' stamp: 'ar 11/17/2003 23:05'!import: xmlNode ref: refKey	^CReferencePart new partID: refKey! !!CObjectMakerImporter methodsFor: 'importing' stamp: 'ar 11/17/2003 21:54'!import: xmlNode type: typeName	^self perform: ('import',typeName,':') asSymbol with: xmlNode! !!CObjectMakerImporter methodsFor: 'importing' stamp: 'ar 11/17/2003 23:40'!importBits: xmlNode maker: maker data: bits	| size id part |	id := xmlNode attributeAt: 'id'.	size := Integer readFrom: (xmlNode attributeAt: 'size') readStream.	part := CBitsArrayPart new.	id ifNotNil:[		part partID: id.		partMap at: id put: part	].	part partMaker: maker.	part contents: (self importBits: (maker basicNew: size) from: xmlNode).	parts nextPut: part.	^part! !!CObjectMakerImporter methodsFor: 'importing' stamp: 'ar 11/17/2003 23:29'!importObject: xmlNode maker: maker	| contents index obj id part |	id := xmlNode attributeAt: 'id'.	part := CObjectPart new.	part partMaker: maker.	parts nextPut: part.	id ifNotNil:[		part partID: id.		partMap at: id put: part	].	contents := Array new: xmlNode elements size.	index := 0.	xmlNode elementsDo:[:each| 		obj := self import: each.		contents at: (index := index + 1) put: each name asSymbol -> obj.	].	part contents: contents.	^part! !!CObjectMakerImporter methodsFor: 'importing' stamp: 'ar 11/17/2003 23:29'!importSequence: xmlNode maker: maker size: size	| contents index obj id part |	id := xmlNode attributeAt: 'id'.	part := CSequencePart new.	part partMaker: maker.	part partSize: size.	parts nextPut: part.	id ifNotNil:[		part partID: id.		partMap at: id put: part	].	contents := Array new: xmlNode elements size.	index := 0.	xmlNode elementsDo:[:each| 		obj := self import: each.		contents at: (index := index + 1) put: obj.	].	part contents: contents.	^part! !!CObjectMakerImporter methodsFor: 'private' stamp: 'ar 11/17/2003 22:01'!convertLiteralNumeric: aString	"Convert aString from a literal number/point - this needs to be ultra-fast"	| stream num ch |	stream := ReadStream on: aString.	num := Number readFrom: stream.	ch := stream peek ifNil:[^num].	ch = $@ ifTrue:[		stream next.		num := num @ (Number readFrom: stream).	].	stream atEnd ifTrue:[^num].	"bail for everything else"	^nil! !!CObjectMakerImporter methodsFor: 'private' stamp: 'ar 11/17/2003 22:01'!convertLiteralString: aString	"Convert aString from a literal string - this needs to be ultra-fast"	| out nextIndex lastIndex |	(aString at: 1) = $' ifFalse:[self error: 'string quote expected'].	"do a quick match for a single-quoted string"	nextIndex := aString indexOf: $' startingAt: 2.	nextIndex = aString size ifTrue:[^aString copyFrom: 2 to: aString size-1].	"do it the slow way"	out := WriteStream on: (String new: aString size - 2).	lastIndex := 1.	[nextIndex := aString indexOf: $' startingAt: lastIndex+1.	nextIndex = 0 ifTrue:[self error: 'string quote expected'].	nextIndex < aString size] whileTrue:[		out nextPutAll: (aString copyFrom: lastIndex+1 to: nextIndex-1).		(aString at: nextIndex + 1) = $' ifFalse:[self error: 'string quote expected'].		out nextPut: $'.		lastIndex := nextIndex+1.	].	out nextPutAll: (aString copyFrom: lastIndex+1 to: aString size-1).	^out contents! !!CObjectMakerImporter methodsFor: 'private' stamp: 'ar 11/17/2003 22:01'!convertLiteralSymbol: aString	"Convert aString from a literal symbol - this needs to be ultra-fast"	(aString at: 1) = $# ifFalse:[self error: 'hash mark expected'].	(aString at: 2) = $' ifFalse:[^Symbol intern: (aString copyFrom: 2 to: aString size)].	^(self convertLiteralString: (aString copyFrom: 2 to: aString size)) asSymbol! !!CObjectMakerImporter methodsFor: 'private' stamp: 'ar 11/17/2003 21:56'!errorNotFound: aKey	self error: aKey, ' not found'.! !!CObjectMakerImporter methodsFor: 'private' stamp: 'ar 12/2/2003 20:27'!getMaker: makerString	"Answer the maker for the given string"	^imports at: makerString ifAbsentPut:[Smalltalk at: makerString asSymbol ifAbsent:[loader loadResource: makerString]]! !!CObjectMakerImporter methodsFor: 'private' stamp: 'ar 12/7/2003 17:47'!resolve: uid	^partMap at: uid "ifAbsent:[imports at: uid]"! !!CObjectMakerImporter methodsFor: 'import-library' stamp: 'ar 12/7/2003 17:46'!importResources: xmlNode	| type id object part |	xmlNode ifNil:[^self error: 'no resources'].	xmlNode elementsDo:[:each|		type := each name.		id := each attributeAt: 'id'.		object := loader loadResource: id type: type xmlNode: each.		imports at: id put: object.		part := CResourcePart new.		part value: object.		part partID: object resourceID.		partMap at: id put: part.	].! !!CObjectMakerImporter methodsFor: 'interface' stamp: 'ar 12/2/2003 21:42'!importFrom: xmlNode in: aLoader	"Create a new factory from the given stream"	| list |	xmlNode name = 'maker' ifFalse:[^nil].	loader := aLoader.	partMap := Dictionary new.	imports := Dictionary new.	swapEnds := (xmlNode attributeAt: 'endianness') ~= Smalltalk endianness.	self importResources: (xmlNode elementAt: 'resources').	parts := WriteStream on: Array new.	list := xmlNode elementAt: 'parts'.	list ifNotNil:[list elementsDo:[:each| self import: each]].	parts := parts contents.	1 to: parts size do:[:i| (parts at: i) resolveIn: self].	imports := imports asArray.! !!CObjectMakerImporter methodsFor: 'interface' stamp: 'ar 11/17/2003 22:01'!imports	^imports! !!CObjectMakerImporter methodsFor: 'interface' stamp: 'ar 11/17/2003 22:01'!parts	^parts! !!COffsetTransform methodsFor: 'composing'!composedWithLocal: aTransform	aTransform isPureTranslation		ifTrue:[^self clone offset: (offset + aTransform offset)].	^self asMatrixTransform2x3 composedWithLocal: aTransform! !!COffsetTransform methodsFor: 'accessing'!inverseTransformation	"Return the inverse transformation of the receiver."	^self clone offset: offset negated! !!COffsetTransform methodsFor: 'accessing'!offset	^offset! !!COffsetTransform methodsFor: 'accessing'!offset: aPoint	offset := aPoint! !!COffsetTransform methodsFor: 'accessing'!scale	^1@1! !!COffsetTransform methodsFor: 'comparing'!= aTransform	^aTransform isPureTranslation and:[self offset = aTransform offset]! !!COffsetTransform methodsFor: 'comparing'!hash	^offset hash! !!COffsetTransform methodsFor: 'testing'!isIdentity	^offset isZero! !!COffsetTransform methodsFor: 'testing'!isNoRotationWithin: bounds	^true! !!COffsetTransform methodsFor: 'testing'!isNoTransformWithin: aRectangle	^true! !!COffsetTransform methodsFor: 'testing'!isPureTranslation	^true! !!COffsetTransform methodsFor: 'transforming'!globalBoundsToLocal: aRectangle	^aRectangle translateBy: offset negated! !!COffsetTransform methodsFor: 'transforming'!globalPointToLocal: aPoint	^aPoint - offset! !!COffsetTransform methodsFor: 'transforming'!localBoundsToGlobal: aRectangle	^aRectangle translateBy: offset! !!COffsetTransform methodsFor: 'transforming'!localPointToGlobal: aPoint	^offset + aPoint! !!COffsetTransform methodsFor: 'transforming'!transformDirection: aPoint	^aPoint! !!COffsetTransform methodsFor: 'transforming'!transformPoint: aPoint	^offset + aPoint! !!COffsetTransform methodsFor: 'converting'!asMatrixTransform2x3	^CMatrixTransform withOffset: offset! !!COffsetTransform methodsFor: 'initialize'!setIdentity	offset := 0@0.! !!COffsetTransform methodsFor: 'printing' stamp: 'bf 4/3/2004 00:50'!printOn: aStream	aStream 		nextPutAll: self class name;		nextPut: $(;		print: offset;		nextPut:$).! !!COrientedFill methodsFor: 'accessing'!direction	^direction ifNil:[direction _ normal y @ normal x negated]! !!COrientedFill methodsFor: 'accessing'!direction: aPoint	direction _ aPoint! !!COrientedFill methodsFor: 'accessing'!frame	^frame! !!COrientedFill methodsFor: 'accessing'!frame: aRectangle	frame := aRectangle.! !!COrientedFill methodsFor: 'accessing'!normal	^normal ifNil:[normal _ direction y negated @ direction x]! !!COrientedFill methodsFor: 'accessing'!normal: aPoint	normal _ aPoint! !!COrientedFill methodsFor: 'accessing' stamp: 'ar 3/11/2003 18:24'!offset	^origin! !!COrientedFill methodsFor: 'accessing' stamp: 'ar 3/11/2003 18:24'!offset: aPoint	self origin: aPoint.! !!COrientedFill methodsFor: 'accessing' stamp: 'ar 3/12/2003 20:16'!origin	^origin ifNil:[0@0]! !!COrientedFill methodsFor: 'accessing'!origin: aPoint	origin _ aPoint.! !!COrientedFill methodsFor: 'updating'!updateFrame: aRectangle	"Update the receiver to represent the same relative fill in aRectangle as previously in its frame. This message is sent by clients who wish to preserve the relative orientation (origin, length) across changes of the shape of the client."	| oldExtent newExtent delta length |	frame = aRectangle ifTrue:[^self].	frame ifNil:[frame := aRectangle. ^self].	frame = aRectangle ifTrue:[frame := aRectangle. ^self].	"Update the origin"	[oldExtent := frame extent.	newExtent := aRectangle extent.	delta := origin - frame origin.	delta := delta asFloatPoint / oldExtent.	delta := (delta * newExtent).	delta := aRectangle origin + delta.	origin = delta ifFalse:[origin := delta].	"Update the direction, based on its angle and relative length"	direction ifNotNil:[		delta := (origin + direction) - frame origin.		delta := delta asFloatPoint / oldExtent.		delta := (delta * newExtent).		delta := aRectangle origin + delta - origin.		length := delta r. "This is what we want to scale the direction to"		delta := direction normalized * length.		delta = direction ifFalse:[direction := delta].	].	"Update the normal, based on its angle and relative length"	normal ifNotNil:[		delta := (origin + normal) - frame origin.		delta := delta asFloatPoint / oldExtent.		delta := (delta * newExtent).		delta := aRectangle origin + delta - origin.		length := delta r. "This is what we want to scale the direction to"		delta := normal normalized * length.		delta = normal ifFalse:[normal := delta].	].	frame := aRectangle.	] on: ZeroDivide do:[:ex| ex return: ex dividend].! !!COrientedFill methodsFor: 'testing'!isOrientedFill	"Return true if the receiver keeps an orientation (e.g., origin, direction, and normal)"	^true! !!CBitmapFill methodsFor: 'accessing'!form	^form! !!CBitmapFill methodsFor: 'accessing'!form: aForm	form _ aForm! !!CBitmapFill methodsFor: 'accessing'!tileFlag	^tileFlag! !!CBitmapFill methodsFor: 'accessing'!tileFlag: aBoolean	tileFlag _ aBoolean! !!CBitmapFill methodsFor: 'testing'!isBitmapFill	^true! !!CBitmapFill methodsFor: 'testing'!isTiled	"Return true if the receiver should be repeated if the fill shape is larger than the form"	^tileFlag == true! !!CBitmapFill methodsFor: 'testing'!isTranslucent	"Return true since the bitmap may be translucent and we don't really want to check"	^true! !!CBitmapFill methodsFor: 'converting'!asColor	^form colorAt: 0@0! !!CGradientFill methodsFor: 'testing'!isGradientFill	^true! !!CGradientFill methodsFor: 'testing'!isRadialFill	^radial == true! !!CGradientFill methodsFor: 'testing'!isSolidFill	^false! !!CGradientFill methodsFor: 'testing'!isTranslucent	^isTranslucent ifNil:[isTranslucent _ self checkTranslucency]! !!CGradientFill methodsFor: 'accessing' stamp: 'ar 3/12/2003 16:42'!alpha	^colorRamp first value alpha! !!CGradientFill methodsFor: 'accessing' stamp: 'ar 3/12/2003 16:42'!alpha: newAlpha	colorRamp := colorRamp collect:[:each|		each key -> (each value alpha: newAlpha).	].	pixelRamp := nil.	^self! !!CGradientFill methodsFor: 'accessing'!colorRamp	^colorRamp! !!CGradientFill methodsFor: 'accessing'!colorRamp: anArray	colorRamp _ anArray.	pixelRamp _ nil.	isTranslucent _ nil.! !!CGradientFill methodsFor: 'accessing' stamp: 'ar 12/9/2002 23:01'!colors	"Create a gradient fill style from an array of equally spaced colors"	^self colorRamp collect:[:each| each value]! !!CGradientFill methodsFor: 'accessing'!colors: colorArray	"Create a gradient fill style from an array of equally spaced colors"	^self colorRamp: (colorArray withIndexCollect:		[:color :index| (index-1 asFloat / (colorArray size - 1 max: 1)) -> color]).! !!CGradientFill methodsFor: 'accessing' stamp: 'ar 3/11/2003 18:20'!gradientColor	^colorRamp last value! !!CGradientFill methodsFor: 'accessing' stamp: 'ar 3/11/2003 18:20'!gradientColor: aColor	colorRamp at: colorRamp size put: colorRamp last key -> aColor.	pixelRamp := nil.! !!CGradientFill methodsFor: 'accessing' stamp: 'ar 12/8/2002 18:54'!pixelRamp	| rampSize |	pixelRamp ifNotNil:[^pixelRamp].	frame ifNil:[^pixelRamp _ self computePixelRampOfSize: 512].	rampSize := ((frame width max: frame height) // 2 max: 4) asLargerPowerOfTwo.	^pixelRamp := self computePixelRampOfSize: rampSize.! !!CGradientFill methodsFor: 'accessing'!pixelRamp: aBitmap	pixelRamp _ aBitmap! !!CGradientFill methodsFor: 'accessing' stamp: 'ar 3/11/2003 18:21'!primaryColor	^colorRamp first value! !!CGradientFill methodsFor: 'accessing' stamp: 'ar 3/11/2003 18:21'!primaryColor: aColor	colorRamp at: 1 put: colorRamp first key -> aColor.	pixelRamp := nil.! !!CGradientFill methodsFor: 'accessing'!radial	^radial! !!CGradientFill methodsFor: 'accessing'!radial: aBoolean	radial _ aBoolean! !!CGradientFill methodsFor: 'private'!checkTranslucency	^colorRamp anySatisfy: [:any| any value isTranslucent]! !!CGradientFill methodsFor: 'private'!computePixelRampOfSize: length	"Compute the pixel ramp in the receiver"	| bits lastColor lastIndex nextIndex nextColor distance theta lastValue ramp lastWord nextWord step |	ramp _ colorRamp asSortedCollection:[:a1 :a2| a1 key < a2 key].	bits _ Bitmap new: length.	lastColor _ ramp first value.	lastWord _ lastColor pixelWordForDepth: 32.	lastIndex _ 0.	ramp do:[:assoc|		nextIndex _ (assoc key * length) rounded.		nextColor _ assoc value.		nextWord _ nextColor pixelWordForDepth: 32.		distance _ (nextIndex - lastIndex).		distance = 0 ifTrue:[distance _ 1].		step _ 1.0 / distance asFloat.		theta _ 0.0.		lastIndex+1 to: nextIndex do:[:i|			theta _ theta + step.			"The following is an open-coded version of:				color _ nextColor alphaMixed: theta with: lastColor.				bits at: i put: (color scaledPixelValue32).			"			bits at: i put: (self scaledAlphaMix: theta of: lastWord with: nextWord).		].		lastIndex _ nextIndex.		lastColor _ nextColor.		lastWord _ nextWord.	].	lastValue _ lastColor scaledPixelValue32.	lastIndex+1 to: length do:[:i| bits at: i put: lastValue].	^bits! !!CGradientFill methodsFor: 'private'!display	| f ramp |	ramp _ self pixelRamp.	f _ Form extent: ramp size @ 1 depth: 32 bits: ramp.	1 to: 100 do:[:i| f displayAt: 1@i].	[Sensor anyButtonPressed] whileFalse.	[Sensor anyButtonPressed] whileTrue.! !!CGradientFill methodsFor: 'private' stamp: 'ar 4/8/2004 16:52'!scaledAlphaMix: theta of: lastWord with: nextWord	"Open-coded version of alpha mixing two 32bit pixel words and returning the scaled pixel value."	| word0 word1 a0 a1 alpha v0 v1 vv newValue |	word0 _ lastWord.	word1 _ nextWord.	"note: extract alpha first so we'll be in SmallInteger range afterwards"	a0 _ word0 bitShift: -24. a1 _ word1 bitShift: -24.	alpha _ a0 + (a1 - a0 * theta) truncated.	"Now make word0 and word1 SmallIntegers"	word0 _ word0 bitAnd: 16rFFFFFF. word1 _ word1 bitAnd: 16rFFFFFF.	"Compute first component value"	v0 _ (word0 bitAnd: 255). v1 _ (word1 bitAnd: 255).	vv _ (v0 + (v1 - v0 * theta) truncated) * alpha // 255.	newValue _ vv.	"Compute second component value"	v0 _ ((word0 bitShift: -8) bitAnd: 255). v1 _ ((word1 bitShift: -8) bitAnd: 255).	vv _ (v0 + (v1 - v0 * theta) truncated) * alpha // 255.	newValue _ newValue bitOr: (vv bitShift: 8).	"Compute third component value"	v0 _ ((word0 bitShift: -16) bitAnd: 255). v1 _ ((word1 bitShift: -16) bitAnd: 255).	vv _ (v0 + (v1 - v0 * theta) truncated) * alpha // 255.	newValue _ newValue bitOr: (vv bitShift: 16).	"Return result"	^newValue bitOr: (alpha bitShift: 24)! !!CGradientFill methodsFor: 'private' stamp: 'ar 12/8/2002 18:53'!updateFrame: aRectangle	| rampSize |	super updateFrame: aRectangle.	pixelRamp ifNil:[^self].	rampSize := (frame width max: frame height) // 2.	rampSize > pixelRamp size ifTrue:[pixelRamp := nil].! !!CGradientFill methodsFor: 'converting'!asColor	"Guess..."	^colorRamp first value mixed: 0.5 with: colorRamp last value! !!CGradientFill methodsFor: 'converting'!mixed: fraction with: aColor	^self copy colorRamp: (colorRamp collect:[:assoc| assoc key -> (assoc value mixed: fraction with: aColor)])! !!CPartBinding methodsFor: 'accessing' stamp: 'ar 2/29/2004 01:27'!home	^home! !!CPartBinding methodsFor: 'accessing' stamp: 'ar 2/29/2004 01:28'!home: anObject	home ifNotNil:[^self error: 'Cannot change home'].	home := anObject.! !!CPartBinding methodsFor: 'accessing' stamp: 'ar 2/29/2004 02:21'!name	^home name,'''s ', key! !!CPartBinding methodsFor: 'accessing' stamp: 'ar 2/29/2004 01:10'!value: aValue	value := aValue.	aValue partBinding: self.! !!CPartBinding methodsFor: 'printing' stamp: 'ar 3/3/2004 15:43'!printOn: aStream	home printOn: aStream.	aStream nextPutAll:'''s '; nextPutAll: key asString.	aStream nextPutAll:' -> '; print: value.! !!CPlayer methodsFor: 'initialize' stamp: 'ar 3/24/2004 16:34'!defaultCostume	"Answer the default costume maker for this kind of player"	^CPrimitiveCostume! !!CPlayer methodsFor: 'initialize' stamp: 'ar 3/16/2004 15:17'!defaultPlayer	"Answer the default player maker for the receiver."	^nil! !!CPlayer methodsFor: 'initialize' stamp: 'ar 3/16/2004 15:19'!destroy	"Destroy this object"	| oldObject |	oldObject := myCostume.	myCostume := nil.	oldObject ifNotNil:[oldObject destroy].	oldObject := myPlayer.	myPlayer := nil.	oldObject ifNotNil:[oldObject destroy].	super destroy.! !!CPlayer methodsFor: 'initialize' stamp: 'tk 6/17/2004 10:12'!initialize	"Initialize the receiver"	super initialize.	myPlayer ifNil:[		myPlayer := self makeDefaultPlayer.		myPlayer ifNotNil:[myPlayer costume: self]].	self propertyValueAt: #creationTime put: TimeStamp current.! !!CPlayer methodsFor: 'initialize' stamp: 'ar 3/7/2004 22:00'!makeDefaultPlayer	"Create a default player for the receiver if one is needed"	| playerMaker |	playerMaker := self defaultPlayer ifNil:[^nil].	^playerMaker makePlayerFor: self! !!CPlayer methodsFor: 'initialize' stamp: 'ar 2/9/2003 01:55'!on: aValue	"Initialize the receivers 'value'"	self value: aValue.! !!CPlayer methodsFor: 'initialize' stamp: 'ar 3/7/2004 18:19'!onPlayerChanged	"backstop"! !!CPlayer methodsFor: 'initialize' stamp: 'ar 4/30/2004 16:00'!setupCostume	"Set up the receiver's costume when it is lazily instantiated. "! !!CPlayer methodsFor: 'initialize' stamp: 'ar 3/24/2004 15:05'!wearCostume: aCostumeMaker	"Make me wear the costume provided by the given costume maker"	self costume: (aCostumeMaker makeCostumeFor: self).	myCostume ifNotNil:[myCostume onPlayerChanged].! !!CPlayer methodsFor: 'initialize' stamp: 'ar 4/30/2004 16:09'!wearDefaultCostume	"Make me wear my default costume"	self wearCostume: self defaultCostume.	self setupCostume.	"For now, call #makeDefaultCostume so that we keep compatibility"		self makeDefaultCostume.	^myCostume! !!CPlayer methodsFor: 'basic' stamp: 'ar 3/23/2004 23:57'!balloonHelp	"Answer the balloon help message"	<bewareOf: #balloonHelpChanged>	^self costume balloonHelp! !!CPlayer methodsFor: 'basic' stamp: 'ar 3/23/2004 23:57'!balloonHelp: aText	"Set the balloon help message"	^self costume balloonHelp: aText! !!CPlayer methodsFor: 'basic' stamp: 'ar 5/24/2004 13:49'!container	"Answer the container of the receiver"	<bewareOf: #containerChanged>	"@@@ FIXME: Costumes should really answer proper players by default but the primitive ones still have too many assumptions about it. So we probably send #asPlayer WAY to often, we need to check for nil containers and all that crap. What this SHOULD say (and bless you if you fix the primitive costumes to make that work!!) is:		^costume container	but we ain't quite there yet..."	^(costume container ifNil:[^nil]) asPlayer! !!CPlayer methodsFor: 'basic' stamp: 'bf 3/30/2004 11:22'!container: aPlayer	"Modify the container of the receiver"	(aPlayer isIn: self) 		ifTrue:[aPlayer container: self container].	aPlayer elements add: self.	^aPlayer! !!CPlayer methodsFor: 'basic' stamp: 'ar 3/16/2004 15:21'!costume	"Answer the receiver's costume"	<bewareOf: #costumeChanged>	^myCostume ifNil:[self wearDefaultCostume].! !!CPlayer methodsFor: 'basic' stamp: 'ar 3/17/2004 18:11'!costume: newCostume	"Modify the receiver's costume"	^self privateChangeCostumeTo: newCostume! !!CPlayer methodsFor: 'basic' stamp: 'ar 3/16/2004 15:21'!elements	"Answer the receiver's elements"	<bewareOf: #elementsChanged>	^costume elements! !!CPlayer methodsFor: 'basic' stamp: 'ar 3/24/2004 20:31'!elements: aCollection	"Modify the receiver's elements"	^elements contents: aCollection! !!CPlayer methodsFor: 'basic' stamp: 'ar 3/23/2004 22:09'!fill	<bewareOf: #fillChanged>	^costume fill! !!CPlayer methodsFor: 'basic' stamp: 'bf 3/30/2004 11:26'!fill: aValue	^costume fill: aValue.! !!CPlayer methodsFor: 'basic' stamp: 'ar 3/23/2004 22:08'!geometry	"Answer the receiver's geometry"	^costume geometry! !!CPlayer methodsFor: 'basic' stamp: 'ar 3/24/2004 00:14'!geometry: aGeometry	"Modify the receiver's geometry"	^costume geometry: aGeometry! !!CPlayer methodsFor: 'basic' stamp: 'ar 3/23/2004 15:18'!grid	"Answer the receiver's grid"	^costume grid! !!CPlayer methodsFor: 'basic' stamp: 'ar 3/23/2004 15:27'!grid: aGrid	"Modify the receiver's grid"	^costume grid: aGrid! !!CPlayer methodsFor: 'basic' stamp: 'ar 3/23/2004 15:25'!gridEnabled	"Answer true if the receiver's grid is present and enabled"	| myGrid |	myGrid := self grid.	myGrid ifNil:[^false].	^myGrid enabled! !!CPlayer methodsFor: 'basic' stamp: 'bf 3/30/2004 11:26'!gridEnabled: aBool	"Enable gridding. If no grid is present and aBool is true, associate a default grid."	| myGrid |	self gridEnabled = aBool ifTrue:[^self].	myGrid := self grid.	myGrid ifNil:[		myGrid := CCostumeGrid new.		self grid: myGrid.	].	^myGrid enabled: aBool.! !!CPlayer methodsFor: 'basic' stamp: 'ar 3/24/2004 00:30'!hand	^self costume hand! !!CPlayer methodsFor: 'basic' stamp: 'ar 3/16/2004 15:22'!menu	"Answer the receiver's menu"	<bewareOf: #menuChanged>	^self propertyValueAt: #menu! !!CPlayer methodsFor: 'basic' stamp: 'ar 3/16/2004 15:22'!menu: aValue	"Modify the receiver's menu"	^self propertyValueAt: #menu put: aValue with: #menuChanged! !!CPlayer methodsFor: 'basic' stamp: 'ar 3/24/2004 00:30'!mouseCursor	<bewareOf: #mouseCursorChanged>	^self costume mouseCursor! !!CPlayer methodsFor: 'basic' stamp: 'bf 3/30/2004 10:36'!mouseCursor: aCursor	^ self costume mouseCursor: aCursor.! !!CPlayer methodsFor: 'basic' stamp: 'ar 3/16/2004 15:21'!player	"Answer the receiver's player"	<bewareOf: #playerChanged>	^myPlayer! !!CPlayer methodsFor: 'basic' stamp: 'bf 3/30/2004 10:35'!player: newPlayer	"Modify the receiver's player"	^ self privateChangePlayerTo: newPlayer.! !!CPlayer methodsFor: 'basic' stamp: 'ar 3/24/2004 00:31'!root	^self costume root! !!CPlayer methodsFor: 'basic' stamp: 'ar 3/23/2004 22:10'!textHolder	<bewareOf: #textChanged>	^costume textHolder! !!CPlayer methodsFor: 'basic' stamp: 'ar 3/23/2004 22:10'!textHolder: aTextHolder	^costume textHolder: aTextHolder.! !!CPlayer methodsFor: 'basic' stamp: 'ar 3/26/2004 00:51'!value	"Answer the receiver's value"	^self privateGetValue! !!CPlayer methodsFor: 'basic' stamp: 'ar 3/17/2004 18:32'!value: newValue	"Modify the receiver's value"	^self privateSetValueTo: newValue! !!CPlayer methodsFor: 'basic' stamp: 'ar 3/24/2004 00:17'!windowColor	"Answer the receiver's window color"	container ifNil:[^color] ifNotNil:[^container windowColor].! !!CPlayer methodsFor: 'basic' stamp: 'bf 3/30/2004 11:27'!windowColor: aColor	"Make the receiver use the given window color"	^costume windowColor: aColor! !!CPlayer methodsFor: 'basic' stamp: 'ar 3/24/2004 00:32'!world	"Answer the receiver's world"	myCostume ifNil:[^nil].	^self costume world! !!CPlayer methodsFor: 'queries' stamp: 'ar 3/25/2004 22:04'!allContainersDo: aBlock	"Evaluate aBlock with all containers of the receiver"	| parent |	parent := container.	[parent == nil] whileFalse:[		aBlock value: parent.		parent := parent container].! !!CPlayer methodsFor: 'queries' stamp: 'ar 3/23/2004 23:55'!colorAt: aPoint	^self colorAt: aPoint behind: nil! !!CPlayer methodsFor: 'queries' stamp: 'ar 3/23/2004 23:56'!colorAt: aPoint behind: aPlayer	^self costume colorAt: aPoint behind: aPlayer! !!CPlayer methodsFor: 'queries' stamp: 'ar 3/23/2004 23:56'!colorUnder	| aContainer |	aContainer := self container ifNil:[^Color transparent].	^aContainer colorAt: self position behind: self.! !!CPlayer methodsFor: 'queries' stamp: 'ar 3/24/2004 00:30'!cursorPoint	^self globalToLocal: hand position! !!CPlayer methodsFor: 'queries' stamp: 'ar 3/23/2004 23:56'!distanceTo: aPlayer	^self position distanceTo: aPlayer position! !!CPlayer methodsFor: 'queries' stamp: 'ar 3/23/2004 23:58'!findPlayerAt: aPoint	"Search the receiver to find the first player located at the given position."	^costume findPlayerAt: aPoint! !!CPlayer methodsFor: 'events' stamp: 'ar 4/30/2004 17:48'!attachBehavior: anEventBehavior	anEventBehavior target == self ifFalse:[^anEventBehavior attachTo: self].	self eventBehaviors: (self eventBehaviors copyWith: anEventBehavior).! !!CPlayer methodsFor: 'events' stamp: 'ar 4/30/2004 17:50'!detachBehavior: anEventBehavior	anEventBehavior target == nil ifFalse:[		anEventBehavior target == self 			ifFalse:[^self error: anEventBehavior name, ' is not owned by me'].		^anEventBehavior detach].	self eventBehaviors: (self eventBehaviors copyWithout: anEventBehavior).! !!CPlayer methodsFor: 'events' stamp: 'ar 4/30/2004 17:50'!eventBehaviors	"Answer the eventBehaviors of the receiver"	<bewareOf: #eventBehaviorsChanged>	^self propertyValueAt: #eventBehaviors ifAbsent:[#()]! !!CPlayer methodsFor: 'events' stamp: 'ar 4/30/2004 17:50'!eventBehaviors: aValue	"Modify the receiver's eventBehaviors"	^self propertyValueAt: #eventBehaviors put: aValue with: #eventBehaviorsChanged! !!CPlayer methodsFor: 'events' stamp: 'ar 3/24/2004 01:36'!onKeyDown: keySpec signal: eventName	"Signal the given event when the key specified by keySpec is pressed.	Examples:		editor onKeyDown: $1 signal: #onePressed.		editor onKeyDown: #(cmd $1) signal: #cmdOnePressed.		editor onKeyDown: #(ctrl shift a) signal: #ctrlShiftAPressed.		editor onKeyDown: #(13) signal: #crPressed.		editor onKeyDown: #(27) signal: #cancel.	To remove a key specification use nil as event name, e.g.,		editor onKeyDown: $1 signal: nil.		editor onKeyDown: #(13) signal: nil.	This method can be used by clients who don't want to handle *all* keyDown events."	^costume onKeyDown: keySpec signal: eventName! !!CPlayer methodsFor: 'events' stamp: 'ar 3/24/2004 01:19'!onKeyStroke: keySpec signal: eventName	"Signal the given event when the key specified by keySpec is input.	To remove a key specification use nil as event name.	This method can be used by clients who don't want to handle *all* keyStroke events."	^costume onKeyStroke: keySpec signal: eventName! !!CPlayer methodsFor: 'events' stamp: 'ar 3/24/2004 01:07'!onKeyUp: keySpec signal: eventName	"Signal the given event when the key specified by keySpec is released.	To remove a key specification use nil as event name.	This method can be used by clients who don't want to handle *all* keyUp events."	^costume onKeyUp: keySpec signal: eventName! !!CPlayer methodsFor: 'properties' stamp: 'ar 3/23/2004 23:01'!clipping	"Answer the receiver's clipping property"	<bewareOf: #flagsChanged>	^costume clipping! !!CPlayer methodsFor: 'properties' stamp: 'ar 3/23/2004 23:00'!clipping: aBool	"Modify the receiver's clipping property"	^costume clipping: aBool.! !!CPlayer methodsFor: 'properties' stamp: 'ar 3/23/2004 23:02'!floating	"Answer the receiver's floating property"	<bewareOf: #flagsChanged>	^costume floating! !!CPlayer methodsFor: 'properties' stamp: 'ar 3/23/2004 23:02'!floating: aBool	"Modify the receiver's floating property"	^costume floating: aBool! !!CPlayer methodsFor: 'properties' stamp: 'ar 3/23/2004 23:03'!infinite	"Answer the receiver's infinite property"	<bewareOf: #flagsChanged>	^costume infinite! !!CPlayer methodsFor: 'properties' stamp: 'ar 3/23/2004 23:03'!infinite: aBool	"Modify the receiver's infinite property"	^costume infinite: aBool! !!CPlayer methodsFor: 'properties' stamp: 'ar 3/23/2004 23:04'!locked	"Answer the receiver's locked property"	<bewareOf: #flagsChanged>	^costume locked! !!CPlayer methodsFor: 'properties' stamp: 'ar 3/23/2004 23:04'!locked: aBool	"Modify the receiver's locked property"	^costume locked: aBool.! !!CPlayer methodsFor: 'properties' stamp: 'ar 3/23/2004 23:04'!sticky	"Answer the receiver's sticky property"	<bewareOf: #flagsChanged>	^costume sticky! !!CPlayer methodsFor: 'properties' stamp: 'ar 3/23/2004 23:05'!sticky: aBool	"Modify the receiver's sticky property"	^costume sticky: aBool! !!CPlayer methodsFor: 'properties' stamp: 'bf 3/30/2004 11:28'!userDraw	"Answer the receiver's userDraw property"	<bewareOf: #flagsChanged>	^costume userDraw! !!CPlayer methodsFor: 'properties' stamp: 'bf 3/30/2004 11:28'!userDraw: aBool	"Modify the receiver's userDraw property"	^costume userDraw: aBool! !!CPlayer methodsFor: 'properties' stamp: 'ar 3/23/2004 23:05'!visible	"Answer the receiver's visible property"	<bewareOf: #flagsChanged>	^costume visible! !!CPlayer methodsFor: 'properties' stamp: 'ar 3/23/2004 23:05'!visible: aValue	"Modify the receiver's visible property"	^costume visible: aValue.! !!CPlayer methodsFor: 'geometry' stamp: 'ar 3/24/2004 00:19'!angle	<bewareOf: #geometryChanged>	^geometry angle! !!CPlayer methodsFor: 'geometry' stamp: 'bf 3/30/2004 10:47'!angle: aValue	^geometry angle: aValue.! !!CPlayer methodsFor: 'geometry' stamp: 'ar 3/24/2004 00:19'!bottom	<bewareOf: #geometryChanged>	^geometry bottom! !!CPlayer methodsFor: 'geometry' stamp: 'bf 3/30/2004 11:18'!bottom: aValue	^geometry bottom: aValue.! !!CPlayer methodsFor: 'geometry' stamp: 'ar 3/24/2004 00:21'!bottomLeft	<bewareOf: #geometryChanged>	^geometry bottomLeft! !!CPlayer methodsFor: 'geometry' stamp: 'bf 3/30/2004 11:19'!bottomLeft: aValue	^geometry bottomLeft: aValue.! !!CPlayer methodsFor: 'geometry' stamp: 'ar 3/24/2004 00:21'!bottomRight	<bewareOf: #geometryChanged>	^geometry bottomRight! !!CPlayer methodsFor: 'geometry' stamp: 'bf 3/30/2004 11:19'!bottomRight: aValue	^geometry bottomRight: aValue.! !!CPlayer methodsFor: 'geometry' stamp: 'ar 3/24/2004 00:21'!bounds	<bewareOf: #geometryChanged>	^geometry bounds! !!CPlayer methodsFor: 'geometry' stamp: 'bf 3/30/2004 11:19'!bounds: newBounds	^geometry bounds: newBounds.! !!CPlayer methodsFor: 'geometry' stamp: 'ar 3/24/2004 00:21'!center	<bewareOf: #geometryChanged>	^geometry center! !!CPlayer methodsFor: 'geometry' stamp: 'bf 3/30/2004 11:19'!center: aValue	^geometry center: aValue.! !!CPlayer methodsFor: 'geometry' stamp: 'ar 3/24/2004 00:21'!corner	<bewareOf: #geometryChanged>	^geometry corner! !!CPlayer methodsFor: 'geometry' stamp: 'bf 3/30/2004 11:19'!corner: aValue	^geometry corner: aValue.! !!CPlayer methodsFor: 'geometry' stamp: 'ar 3/24/2004 00:21'!extent	<bewareOf: #geometryChanged>	^geometry extent! !!CPlayer methodsFor: 'geometry' stamp: 'bf 3/30/2004 10:46'!extent: aValue	^geometry extent: aValue.! !!CPlayer methodsFor: 'geometry' stamp: 'ar 3/24/2004 00:21'!fullBounds	^geometry fullBounds! !!CPlayer methodsFor: 'geometry' stamp: 'ar 3/24/2004 00:23'!globalBounds	<bewareOf: #frameChanged>	^geometry globalBounds! !!CPlayer methodsFor: 'geometry' stamp: 'bf 3/30/2004 11:19'!globalBounds: aRectangle	^geometry globalBounds: aRectangle! !!CPlayer methodsFor: 'geometry' stamp: 'ar 3/24/2004 00:23'!globalPosition	<bewareOf: #frameChanged>	^geometry globalPosition! !!CPlayer methodsFor: 'geometry' stamp: 'ar 3/24/2004 14:28'!globalPosition: aPoint	^geometry globalPosition: aPoint! !!CPlayer methodsFor: 'geometry' stamp: 'ar 3/24/2004 12:46'!globalToLocal	^costume globalToLocal! !!CPlayer methodsFor: 'geometry' stamp: 'ar 3/24/2004 12:47'!globalToLocal: anObject	^costume globalToLocal: anObject! !!CPlayer methodsFor: 'geometry' stamp: 'ar 3/24/2004 00:21'!heading	<bewareOf: #geometryChanged>	^geometry heading! !!CPlayer methodsFor: 'geometry' stamp: 'ar 3/24/2004 00:21'!heading: newHeading	^geometry heading: newHeading! !!CPlayer methodsFor: 'geometry' stamp: 'ar 3/24/2004 00:19'!height	<bewareOf: #geometryChanged>	^geometry height! !!CPlayer methodsFor: 'geometry' stamp: 'bf 3/30/2004 10:46'!height: aValue	^geometry height: aValue.! !!CPlayer methodsFor: 'geometry' stamp: 'ar 3/24/2004 00:19'!left	<bewareOf: #geometryChanged>	^geometry left! !!CPlayer methodsFor: 'geometry' stamp: 'bf 3/30/2004 11:29'!left: aValue	^geometry left: aValue.! !!CPlayer methodsFor: 'geometry' stamp: 'ar 3/24/2004 00:21'!localBounds	^geometry localBounds! !!CPlayer methodsFor: 'geometry' stamp: 'ar 3/27/2004 21:14'!localExtent: aPoint	^geometry localExtent: aPoint! !!CPlayer methodsFor: 'geometry' stamp: 'ar 3/24/2004 12:46'!localToGlobal	^costume localToGlobal! !!CPlayer methodsFor: 'geometry' stamp: 'ar 3/24/2004 12:47'!localToGlobal: anObject	^costume localToGlobal: anObject! !!CPlayer methodsFor: 'geometry' stamp: 'ar 3/24/2004 00:21'!origin	<bewareOf: #geometryChanged>	^geometry origin! !!CPlayer methodsFor: 'geometry' stamp: 'bf 3/30/2004 11:20'!origin: aValue	^geometry origin: aValue.! !!CPlayer methodsFor: 'geometry' stamp: 'ar 3/24/2004 00:22'!position	<bewareOf: #geometryChanged>	^geometry position! !!CPlayer methodsFor: 'geometry' stamp: 'bf 3/30/2004 10:43'!position: aValue	^geometry position: aValue.! !!CPlayer methodsFor: 'geometry' stamp: 'ar 3/24/2004 00:20'!right	<bewareOf: #geometryChanged>	^geometry right! !!CPlayer methodsFor: 'geometry' stamp: 'bf 3/30/2004 11:18'!right: aValue	^geometry right: aValue.! !!CPlayer methodsFor: 'geometry' stamp: 'ar 3/24/2004 00:20'!scale	<bewareOf: #geometryChanged>	^geometry scale! !!CPlayer methodsFor: 'geometry' stamp: 'bf 3/30/2004 10:47'!scale: aValue	^geometry scale: aValue.! !!CPlayer methodsFor: 'geometry' stamp: 'ar 3/24/2004 00:20'!top	<bewareOf: #geometryChanged>	^geometry top! !!CPlayer methodsFor: 'geometry' stamp: 'bf 3/30/2004 11:18'!top: aValue	^geometry top: aValue.! !!CPlayer methodsFor: 'geometry' stamp: 'ar 3/24/2004 00:22'!topLeft	<bewareOf: #geometryChanged>	^geometry topLeft! !!CPlayer methodsFor: 'geometry' stamp: 'bf 3/30/2004 11:20'!topLeft: aValue	^geometry topLeft: aValue.! !!CPlayer methodsFor: 'geometry' stamp: 'ar 3/24/2004 00:22'!topRight	<bewareOf: #geometryChanged>	^geometry topRight! !!CPlayer methodsFor: 'geometry' stamp: 'bf 3/30/2004 11:20'!topRight: aValue	^geometry topRight: aValue.! !!CPlayer methodsFor: 'geometry' stamp: 'ar 3/24/2004 00:20'!transform	<bewareOf: #geometryChanged>	^geometry transform! !!CPlayer methodsFor: 'geometry' stamp: 'bf 3/30/2004 11:20'!transform: aTransform	^geometry transform: aTransform! !!CPlayer methodsFor: 'geometry' stamp: 'ar 3/24/2004 12:47'!transformBy: aTransform	^costume transformBy: aTransform! !!CPlayer methodsFor: 'geometry' stamp: 'ar 3/24/2004 00:20'!width	<bewareOf: #geometryChanged>	^geometry width! !!CPlayer methodsFor: 'geometry' stamp: 'bf 3/30/2004 10:45'!width: aValue	^geometry width: aValue.! !!CPlayer methodsFor: 'geometry' stamp: 'ar 3/24/2004 00:20'!x	<bewareOf: #geometryChanged>	^geometry x! !!CPlayer methodsFor: 'geometry' stamp: 'bf 3/30/2004 10:42'!x: aValue	^geometry x: aValue.! !!CPlayer methodsFor: 'geometry' stamp: 'ar 3/24/2004 00:20'!y	<bewareOf: #geometryChanged>	^geometry y! !!CPlayer methodsFor: 'geometry' stamp: 'bf 3/30/2004 10:43'!y: aValue	^geometry y: aValue! !!CPlayer methodsFor: 'color and fill' stamp: 'ar 3/23/2004 17:25'!color	<bewareOf: #fillChanged>	^fill color! !!CPlayer methodsFor: 'color and fill' stamp: 'tk 6/24/2004 15:47'!color: aValue"When aValue = Color transparent, (fill color:) will set fillStyle to be #none.  This is to force there to be a single way to be transparent"	^fill color: aValue.! !!CPlayer methodsFor: 'color and fill' stamp: 'ar 3/23/2004 17:25'!fillAlpha	<bewareOf: #fillChanged>	^fill alpha! !!CPlayer methodsFor: 'color and fill' stamp: 'tk 6/23/2004 10:29'!fillAlpha: aValue	fill alpha: aValue.	(aValue = 0.0 and: [fillStyle ~~ #none]) ifTrue: [self fillStyle: #none].	^ aValue.! !!CPlayer methodsFor: 'color and fill' stamp: 'ar 3/23/2004 17:25'!fillAngle	<bewareOf: #fillChanged>	^fill angle! !!CPlayer methodsFor: 'color and fill' stamp: 'bf 3/30/2004 11:30'!fillAngle: aValue	^fill angle: aValue.! !!CPlayer methodsFor: 'color and fill' stamp: 'ar 3/24/2004 00:26'!fillColor	<bewareOf: #fillChanged>	^fill color! !!CPlayer methodsFor: 'color and fill' stamp: 'bf 3/30/2004 11:30'!fillColor: aValue	^fill color: aValue.! !!CPlayer methodsFor: 'color and fill' stamp: 'ar 3/23/2004 17:25'!fillColors	<bewareOf: #fillChanged>	^fill colors! !!CPlayer methodsFor: 'color and fill' stamp: 'bf 3/30/2004 11:30'!fillColors: aValue	^fill colors: aValue.! !!CPlayer methodsFor: 'color and fill' stamp: 'ar 3/23/2004 17:26'!fillOffset	<bewareOf: #fillChanged>	^fill offset! !!CPlayer methodsFor: 'color and fill' stamp: 'bf 3/30/2004 11:30'!fillOffset: aValue	^fill offset: aValue.! !!CPlayer methodsFor: 'color and fill' stamp: 'ar 3/23/2004 17:26'!fillStyle	<bewareOf: #fillChanged>	^fill style! !!CPlayer methodsFor: 'color and fill' stamp: 'tk 6/23/2004 10:32'!fillStyle: aValue	fill style: aValue.	(aValue == #none and: [fillAlpha > 0.0]) ifTrue: [self fillAlpha: 0.0].	^ aValue.! !!CPlayer methodsFor: 'border' stamp: 'ar 3/23/2004 17:27'!border	<bewareOf: #borderChanged>	^costume border! !!CPlayer methodsFor: 'border' stamp: 'bf 3/30/2004 11:31'!border: aValue	^costume border: aValue.! !!CPlayer methodsFor: 'border' stamp: 'ar 3/23/2004 17:27'!borderColor	<bewareOf: #borderChanged>	^border color! !!CPlayer methodsFor: 'border' stamp: 'bf 3/30/2004 11:31'!borderColor: aValue	^border color: aValue.! !!CPlayer methodsFor: 'border' stamp: 'ar 3/23/2004 17:28'!borderStyle	<bewareOf: #borderChanged>	^border style! !!CPlayer methodsFor: 'border' stamp: 'bf 3/30/2004 11:31'!borderStyle: aValue	^border style: aValue.! !!CPlayer methodsFor: 'border' stamp: 'ar 3/25/2004 17:10'!borderWidth	<bewareOf: #borderChanged>	^border width! !!CPlayer methodsFor: 'border' stamp: 'bf 3/30/2004 10:40'!borderWidth: aValue	^border width: aValue.! !!CPlayer methodsFor: 'graphic' stamp: 'ar 3/23/2004 23:57'!aspectRatio	<bewareOf: #geometryChanged>	^self costume aspectRatio! !!CPlayer methodsFor: 'graphic' stamp: 'bf 3/30/2004 11:31'!aspectRatio: aValue	^costume aspectRatio: aValue.! !!CPlayer methodsFor: 'graphic' stamp: 'ar 3/23/2004 19:19'!graphic	<bewareOf: #graphicChanged>	^costume graphic! !!CPlayer methodsFor: 'graphic' stamp: 'bf 3/30/2004 11:31'!graphic: aValue	^costume graphic: aValue.! !!CPlayer methodsFor: 'graphic' stamp: 'ar 3/23/2004 19:20'!graphicAnchorPoint	<bewareOf: #graphicChanged>	^graphic anchorPoint! !!CPlayer methodsFor: 'graphic' stamp: 'bf 3/30/2004 11:31'!graphicAnchorPoint: aValue	^graphic anchorPoint: aValue.! !!CPlayer methodsFor: 'graphic' stamp: 'ar 3/23/2004 20:26'!graphicEnabled	^graphic notNil! !!CPlayer methodsFor: 'graphic' stamp: 'bf 3/30/2004 11:31'!graphicEnabled: aBool	self graphicEnabled = aBool ifFalse:[		graphic := aBool ifTrue:[CCostumeGraphic new] ifFalse:[nil].	].	^aBool! !!CPlayer methodsFor: 'graphic' stamp: 'ar 3/23/2004 19:20'!graphicFit	<bewareOf: #graphicChanged>	^graphic fit! !!CPlayer methodsFor: 'graphic' stamp: 'bf 3/30/2004 11:37'!graphicFit: aValue	"Determine how textures should be drawn within its bounds:		#rigid - use original size		#scale - scale to size (preserving aspect ratio)		#stretch - stretch to bounds.		#tile - draw the graphic repeatedly		#autoScale - scale down but never up	"	^graphic fit: aValue.! !!CPlayer methodsFor: 'graphic' stamp: 'ar 3/23/2004 19:33'!graphicForm	<bewareOf: #graphicChanged>	^(graphic ifNil:[^nil]) form! !!CPlayer methodsFor: 'graphic' stamp: 'bf 3/29/2004 19:03'!graphicForm: aForm	^ graphic 		ifNil:[graphic := aForm]		ifNotNil:[graphic form: aForm].! !!CPlayer methodsFor: 'graphic' stamp: 'ar 3/23/2004 19:20'!graphicOffset	<bewareOf: #graphicChanged>	^graphic offset! !!CPlayer methodsFor: 'graphic' stamp: 'bf 3/30/2004 11:37'!graphicOffset: aPoint	^graphic offset: aPoint.! !!CPlayer methodsFor: 'text' stamp: 'ar 3/24/2004 15:02'!font	^self textFont! !!CPlayer methodsFor: 'text' stamp: 'ar 3/24/2004 15:02'!font: aFont	^self textFont: aFont! !!CPlayer methodsFor: 'text' stamp: 'ar 3/23/2004 20:15'!text	<bewareOf: #textChanged>	^(textHolder ifNil:[^'']) text! !!CPlayer methodsFor: 'text' stamp: 'bf 3/30/2004 11:33'!text: aText	^textHolder		ifNil:[textHolder := aText]		ifNotNil:[textHolder text: aText].! !!CPlayer methodsFor: 'text' stamp: 'ar 3/23/2004 20:09'!textAnchorPoint	<bewareOf: #textChanged>	^textHolder anchorPoint! !!CPlayer methodsFor: 'text' stamp: 'ar 3/23/2004 20:09'!textAnchorPoint: aValue	^textHolder anchorPoint: aValue.! !!CPlayer methodsFor: 'text' stamp: 'ar 3/23/2004 20:09'!textAttributes	<bewareOf: #textChanged>	^textHolder attributes! !!CPlayer methodsFor: 'text' stamp: 'ar 3/23/2004 20:10'!textAttributes: aValue	^textHolder attributes: aValue.! !!CPlayer methodsFor: 'text' stamp: 'ar 3/23/2004 20:10'!textBorderColor	<bewareOf: #textChanged>	^textHolder borderColor! !!CPlayer methodsFor: 'text' stamp: 'ar 3/23/2004 20:10'!textBorderColor: aValue	^textHolder borderColor: aValue.! !!CPlayer methodsFor: 'text' stamp: 'ar 3/23/2004 20:10'!textBorderWidth	<bewareOf: #textChanged>	^textHolder borderWidth! !!CPlayer methodsFor: 'text' stamp: 'ar 3/28/2004 23:37'!textBorderWidth: aValue	^textHolder borderWidth: aValue.! !!CPlayer methodsFor: 'text' stamp: 'ar 3/23/2004 20:11'!textColor	<bewareOf: #textChanged>	^textHolder color! !!CPlayer methodsFor: 'text' stamp: 'ar 3/23/2004 20:11'!textColor: aValue	^textHolder color: aValue.! !!CPlayer methodsFor: 'text' stamp: 'ar 3/23/2004 20:30'!textEditor	^textHolder editor! !!CPlayer methodsFor: 'text' stamp: 'ar 3/23/2004 20:11'!textEmphasis	<bewareOf: #textChanged>	^textHolder emphasis! !!CPlayer methodsFor: 'text' stamp: 'ar 3/23/2004 20:11'!textEmphasis: aValue	^textHolder emphasis: aValue.! !!CPlayer methodsFor: 'text' stamp: 'ar 3/23/2004 20:23'!textEnabled	^textHolder notNil! !!CPlayer methodsFor: 'text' stamp: 'bf 3/30/2004 11:40'!textEnabled: aBool	self textEnabled = aBool ifFalse:[		textHolder := aBool ifTrue:[Text new] ifFalse:[nil].	].	^ aBool! !!CPlayer methodsFor: 'text' stamp: 'ar 3/24/2004 01:45'!textFont	<bewareOf: #textChanged>	^(textHolder ifNil:[^TextStyle defaultFont]) font! !!CPlayer methodsFor: 'text' stamp: 'ar 3/23/2004 20:11'!textFont: aValue	^textHolder font: aValue.! !!CPlayer methodsFor: 'text' stamp: 'ar 3/23/2004 20:12'!textInset	<bewareOf: #textChanged>	^textHolder inset! !!CPlayer methodsFor: 'text' stamp: 'ar 3/23/2004 20:12'!textInset: aValue	^textHolder inset: aValue.! !!CPlayer methodsFor: 'text' stamp: 'ar 3/23/2004 20:12'!textOffset	<bewareOf: #textChanged>	^textHolder offset! !!CPlayer methodsFor: 'text' stamp: 'ar 3/23/2004 20:12'!textOffset: aValue	^textHolder offset: aValue.! !!CPlayer methodsFor: 'text' stamp: 'ar 3/23/2004 20:12'!textWrap	<bewareOf: #textChanged>	^textHolder wrapContents! !!CPlayer methodsFor: 'text' stamp: 'ar 3/23/2004 20:12'!textWrap: aValue	^textHolder wrapContents: aValue.! !!CPlayer methodsFor: 'shadow' stamp: 'ar 3/23/2004 21:02'!dropShadow	<bewareOf: #dropShadowChanged>	^costume dropShadow! !!CPlayer methodsFor: 'shadow' stamp: 'bf 3/30/2004 11:41'!dropShadow: aDropShadow	^costume dropShadow: aDropShadow! !!CPlayer methodsFor: 'shadow' stamp: 'ar 3/23/2004 21:04'!dropShadowColor	<bewareOf: #shadowChanged>	^dropShadow color! !!CPlayer methodsFor: 'shadow' stamp: 'bf 3/30/2004 11:41'!dropShadowColor: aValue	^dropShadow color: aValue.! !!CPlayer methodsFor: 'shadow' stamp: 'ar 3/23/2004 21:01'!dropShadowEnabled	<bewareOf: #dropShadowChanged>	^dropShadow notNil! !!CPlayer methodsFor: 'shadow' stamp: 'bf 3/30/2004 11:41'!dropShadowEnabled: aBool	self dropShadowEnabled == aBool ifFalse:[		dropShadow := aBool ifTrue:[CDropShadowHighlight new] ifFalse:[nil].	].	^aBool! !!CPlayer methodsFor: 'shadow' stamp: 'ar 3/23/2004 21:05'!dropShadowOffset	<bewareOf: #shadowChanged>	^dropShadow offset! !!CPlayer methodsFor: 'shadow' stamp: 'bf 3/30/2004 11:34'!dropShadowOffset: aValue	^dropShadow offset: aValue.! !!CPlayer methodsFor: 'corners' stamp: 'ar 3/24/2004 14:27'!roundCornerSpec	<bewareOf: #roundCornersChanged>	^costume roundCornerSpec! !!CPlayer methodsFor: 'corners' stamp: 'bf 3/30/2004 11:41'!roundCornerSpec: anArray	^costume roundCornerSpec: anArray.! !!CPlayer methodsFor: 'corners' stamp: 'ar 3/24/2004 14:27'!roundCorners	"Answer true if the receiver should round its corners"	<bewareOf: #roundCornersChanged>	^costume roundCorners! !!CPlayer methodsFor: 'corners' stamp: 'bf 3/30/2004 11:41'!roundCorners: aBool	"Indicate whether the receiver should round its corners"	^costume roundCorners: aBool.! !!CPlayer methodsFor: 'highlights' stamp: 'ar 3/24/2004 01:58'!addHighlight: aHighlight	"Add the given highlight to the receiver"	^costume addHighlight: aHighlight! !!CPlayer methodsFor: 'highlights' stamp: 'ar 3/24/2004 01:59'!removeHighlight: highlightName	"Remove the highlight from the receiver"	^costume removeHighlight: highlightName! !!CPlayer methodsFor: 'collisions' stamp: 'ar 3/23/2004 23:49'!collisionsEnabled	"Answer whether the receiver's will participate in collision detection"	<bewareOf: #collisionsEnabledChanged>	^costume collisionsEnabled! !!CPlayer methodsFor: 'collisions' stamp: 'ar 3/23/2004 23:49'!collisionsEnabled: aBool	"Indicate whether the receiver's will participate in collision detection"	^costume collisionsEnabled: aBool! !!CPlayer methodsFor: 'collisions' stamp: 'ar 3/23/2004 23:50'!preciseCollisions	"Answer whether the receiver will do pixel-precise collisions"	<bewareOf: #preciseCollisionsChanged>	^self costume preciseCollisions! !!CPlayer methodsFor: 'collisions' stamp: 'bf 3/30/2004 11:42'!preciseCollisions: aBool	"Indicate whether the receiver will do pixel-precise collisions"	^costume preciseCollisions: aBool.! !!CPlayer methodsFor: 'layout' stamp: 'ar 3/11/2004 12:44'!hResizing	^self costume hResizing! !!CPlayer methodsFor: 'layout' stamp: 'bf 3/30/2004 11:42'!hResizing: aValue	^costume hResizing: aValue.! !!CPlayer methodsFor: 'layout' stamp: 'bf 3/30/2004 11:42'!layout	^costume layout! !!CPlayer methodsFor: 'layout' stamp: 'bf 3/30/2004 11:42'!layout: aLayout	^costume layout: aLayout! !!CPlayer methodsFor: 'layout' stamp: 'ar 3/24/2004 02:15'!layoutBounds	^costume layoutBounds! !!CPlayer methodsFor: 'layout' stamp: 'ar 3/24/2004 02:15'!layoutBounds: newBounds	^costume layoutBounds! !!CPlayer methodsFor: 'layout' stamp: 'ar 3/11/2004 12:43'!layoutFrame	^self costume layoutFrame! !!CPlayer methodsFor: 'layout' stamp: 'bf 4/27/2004 01:14'!layoutFrame: aFrame	^ self costume layoutFrame: aFrame! !!CPlayer methodsFor: 'layout' stamp: 'ar 3/24/2004 03:40'!layoutInset	^costume layoutInset! !!CPlayer methodsFor: 'layout' stamp: 'ar 3/24/2004 03:40'!layoutInset: aPoint	costume layoutInset: aPoint! !!CPlayer methodsFor: 'layout' stamp: 'ar 3/24/2004 02:08'!layoutNeeded	^costume layoutNeeded! !!CPlayer methodsFor: 'layout' stamp: 'ar 3/24/2004 02:08'!layoutNeeded: aBool	costume layoutNeeded: aBool! !!CPlayer methodsFor: 'layout' stamp: 'ar 3/11/2004 12:44'!vResizing	^self costume vResizing! !!CPlayer methodsFor: 'layout' stamp: 'bf 3/30/2004 13:58'!vResizing: aValue	^self costume vResizing: aValue.	! !!CPlayer methodsFor: 'adding' stamp: 'ar 4/2/2004 14:27'!add: newObject 	"Include newObject as one of the receiver's elements. Answer newObject."	^self addLast: newObject! !!CPlayer methodsFor: 'adding' stamp: 'ar 3/16/2004 15:11'!add: newObject after: oldObject	"Insert newObject after oldObject"	^elements add: newObject after: oldObject! !!CPlayer methodsFor: 'adding' stamp: 'ar 3/16/2004 15:11'!add: anObject at: anIndex	"Insert the given object at the specified index"	^elements add: anObject at: anIndex.! !!CPlayer methodsFor: 'adding' stamp: 'ar 3/16/2004 15:14'!add: newObject before: oldObject				 	 	"Add the argument, newObject, as an element of the receiver."	^elements add: newObject before: oldObject! !!CPlayer methodsFor: 'adding' stamp: 'ar 3/16/2004 15:11'!addAll: aCollection 	"Include all the elements of aCollection as the receiver's elements."	^elements addAll: aCollection! !!CPlayer methodsFor: 'adding' stamp: 'ar 3/16/2004 15:12'!addAll: aCollection after: oldObject	"Insert the given object before the specified index"	^elements addAll: aCollection after: oldObject! !!CPlayer methodsFor: 'adding' stamp: 'ar 3/16/2004 14:38'!addAll: aCollection at: anIndex	"Insert the given object before the specified index"	^elements addAll: aCollection at: anIndex! !!CPlayer methodsFor: 'adding' stamp: 'ar 3/16/2004 15:13'!addAll: aCollection before: oldObject	"Insert the given object before the specified index"	^elements addAll: aCollection before: oldObject! !!CPlayer methodsFor: 'adding' stamp: 'ar 3/16/2004 15:13'!addFirst: newObject 	"Include newObject as the first of the receiver's elements. Answer newObject."	^elements addFirst: newObject! !!CPlayer methodsFor: 'adding' stamp: 'ar 3/16/2004 15:13'!addLast: newObject	"Include newObject as the last of the receiver's elements."	^elements addLast: newObject! !!CPlayer methodsFor: 'removing' stamp: 'ar 3/16/2004 15:14'!remove: oldObject 	"Remove oldObject from the receiver's elements."	^elements remove: oldObject! !!CPlayer methodsFor: 'removing' stamp: 'ar 3/16/2004 15:15'!remove: oldObject ifAbsent: aBlock 	"Remove oldObject from the receiver's elements. If several of the 	elements are equal to oldObject, only one is removed. If no element is 	equal to oldObject, answer the result of evaluating anExceptionBlock."	^elements remove: oldObject ifAbsent: aBlock! !!CPlayer methodsFor: 'removing' stamp: 'ar 3/16/2004 14:44'!removeAll	"Remove all elements from the receiver"	elements removeAll.! !!CPlayer methodsFor: 'removing' stamp: 'ar 3/16/2004 15:15'!removeAll: aCollection 	"Remove each element of aCollection from the receiver."	elements removeAll: aCollection! !!CPlayer methodsFor: 'removing' stamp: 'ar 3/16/2004 15:15'!removeAt: index	"Remove an element from the receiver"	^elements removeAt: index! !!CPlayer methodsFor: 'removing' stamp: 'ar 3/16/2004 15:15'!removeFirst	"Remove the first element of the receiver"	^elements removeFirst! !!CPlayer methodsFor: 'removing' stamp: 'ar 3/16/2004 14:47'!removeFrom: firstIndex to: lastIndex	"Remove all the elements from firstIndex to lastIndex"	^elements removeFrom: firstIndex to: lastIndex! !!CPlayer methodsFor: 'removing' stamp: 'ar 3/16/2004 15:16'!removeLast	"Remove the last element from the receiver"	^elements removeLast! !!CPlayer methodsFor: 'animating' stamp: 'ar 3/13/2004 15:43'!bounce	"Bounce myself in my container."	| oldHeading newHeading |	oldHeading := self heading.	newHeading := self bounce: oldHeading.	"Set my heading to the new heading.	This is optimized since changing the heading is somewhat expensive."	newHeading = oldHeading 		ifFalse:[self heading: newHeading].! !!CPlayer methodsFor: 'animating' stamp: 'ar 3/27/2004 21:11'!bounce: aHeading	"Bounce off my container's wall using the given heading.	Answer the new heading after the bounce, or the original	one if no change in heading occurs."	| innerBox outerBox newHeading |	innerBox := self bounds.	outerBox := 0@0 extent: self container extent.	(outerBox containsRect: innerBox)		ifTrue:[^aHeading].	newHeading := aHeading.	(innerBox left < 0 and:[aHeading x < 0]) "left"		ifTrue:[newHeading := aHeading x negated @ aHeading y].	(innerBox right > outerBox width and:[aHeading x > 0]) "right" 		ifTrue:[newHeading := aHeading x negated @ aHeading y].	(innerBox top < 0 and:[aHeading y < 0])  "top"		ifTrue:[newHeading := aHeading x @ aHeading y negated].	(innerBox bottom > outerBox height and:[aHeading y > 0]) "bottom"		ifTrue:[newHeading := aHeading x @ aHeading y negated].	^newHeading! !!CPlayer methodsFor: 'animating' stamp: 'ar 3/21/2004 14:03'!forwardBy: amount	"Move me forward by the specified amount"	self moveBy: self heading * amount.! !!CPlayer methodsFor: 'animating' stamp: 'ar 3/21/2004 14:03'!makeSound: soundName	| snd |	snd := SampledSound soundNamed: soundName.	(snd == nil or:[snd isPlaying]) ifTrue:[^nil].	snd play.! !!CPlayer methodsFor: 'animating' stamp: 'ar 3/29/2003 22:45'!moveBy: delta	^self costume moveBy: delta asPoint! !!CPlayer methodsFor: 'animating' stamp: 'ar 3/28/2004 16:10'!turnBy: degrees	self costume turnBy: degrees! !!CPlayer methodsFor: 'animating' stamp: 'ar 8/17/2003 15:34'!wrap	"Wrap me in my container"	| innerBox outerBox |	innerBox := self bounds.	outerBox := 0@0 extent: self container extent.	innerBox right < 0 "left"		ifTrue:[self left: outerBox width].	innerBox left > outerBox width "right"		ifTrue:[self right: 0].	innerBox bottom < 0 "top"		ifTrue:[self top: outerBox height].	innerBox top > outerBox height "bottom"		ifTrue:[self bottom: 0].! !!CPlayer methodsFor: 'selecting' stamp: 'ar 3/23/2004 23:43'!deselect	"Deselect the receiver"	^self costume deselect! !!CPlayer methodsFor: 'selecting' stamp: 'ar 3/23/2004 23:43'!disable	"Disable the receiver"	self costume disable.! !!CPlayer methodsFor: 'selecting' stamp: 'ar 3/23/2004 23:43'!enable	"(Re-)enable the receiver"	self costume enable! !!CPlayer methodsFor: 'selecting' stamp: 'ar 3/23/2004 23:44'!fire	"Any player can be asked to act as a button and fire"	self signal: #fire.! !!CPlayer methodsFor: 'selecting' stamp: 'ar 3/6/2004 22:59'!flash	^self costume flash! !!CPlayer methodsFor: 'selecting' stamp: 'ar 3/23/2004 23:42'!select	"Select the receiver"	^self costume select! !!CPlayer methodsFor: 'scrolling' stamp: 'ar 3/19/2004 13:21'!hScrollable	"Answer the hScrollable of the receiver"	<bewareOf: #hScrollableChanged>	^self propertyValueAt: #hScrollable! !!CPlayer methodsFor: 'scrolling' stamp: 'ar 3/19/2004 13:21'!hScrollable: aValue	"Modify the receiver's hScrollable"	^self propertyValueAt: #hScrollable put: aValue with: #hScrollableChanged! !!CPlayer methodsFor: 'scrolling' stamp: 'ar 3/24/2004 01:50'!scrollArea	"Answer the area that should be scrolled in the receiver"	^(self propertyValueAt: #scrollArea) ifNil:[self costume scrollArea].! !!CPlayer methodsFor: 'scrolling' stamp: 'ar 3/24/2004 01:51'!scrollArea: newBounds	"Indicate the area that should be scrolled in the receiver"	^self propertyValueAt: #scrollArea put: newBounds! !!CPlayer methodsFor: 'scrolling' stamp: 'ar 3/24/2004 01:46'!scrollDelta	"Answer the amount by which the receiver should be scrolled"	<bewareOf: #scrollDeltaChanged>	^(self propertyValueAt: #scrollDelta) ifNil:[1@self textFont height].! !!CPlayer methodsFor: 'scrolling' stamp: 'ar 3/24/2004 01:46'!scrollDelta: aPoint	"Indicate the amount by which the receiver should be scrolled"	^self propertyValueAt: #scrollDelta put: aPoint with: #scrollDeltaChanged! !!CPlayer methodsFor: 'scrolling' stamp: 'ar 3/24/2004 01:46'!scrollOffset	"Answer the amount by which the receiver is scrolled"	<bewareOf: #scrollOffsetChanged>	^self costume scrollOffset! !!CPlayer methodsFor: 'scrolling' stamp: 'bf 3/30/2004 14:02'!scrollOffset: aPoint	"Indicate the amount by which the receiver is scrolled"	^self costume scrollOffset: aPoint! !!CPlayer methodsFor: 'scrolling' stamp: 'ar 3/24/2004 01:54'!scrollToShow: aRectangleOrPlayer	"Scroll the receiver to show the given player"	| box trial xOffset yOffset |	aRectangleOrPlayer ifNil:[^self].	aRectangleOrPlayer isPlayer 		ifTrue:[box := aRectangleOrPlayer bounds]		ifFalse:[box := aRectangleOrPlayer].	trial := self visibleScrollArea.	(trial containsRect: box) ifTrue:[^self].	xOffset := yOffset := 0.	"check right/bottom first"	box right > trial right 		ifTrue:[xOffset := box right - trial right].	box bottom > trial bottom 		ifTrue:[yOffset := box bottom - trial bottom].	"if the box doesn't fit, prefer left/top over bottom/right"	box := box origin - (xOffset @ yOffset) extent: box extent.	"check left/top"	box left < trial left 		ifTrue:[xOffset := xOffset + box left - trial left].	box top < trial top		ifTrue:[yOffset := yOffset + box top - trial top].	self scrollOffset: self scrollOffset + (xOffset @ yOffset).! !!CPlayer methodsFor: 'scrolling' stamp: 'ar 3/24/2004 01:47'!scrollingDisabled	"Answer whether the receiver should NOT be scrolled in its owner"	<bewareOf: #scrollingDisabledChanged>	^self costume scrollingDisabled! !!CPlayer methodsFor: 'scrolling' stamp: 'bf 3/30/2004 14:01'!scrollingDisabled: aBool	"Indicate whether the receiver should NOT be scrolled in its owner"	^self costume scrollingDisabled: aBool! !!CPlayer methodsFor: 'scrolling' stamp: 'ar 3/19/2004 13:22'!vScrollable	"Answer the vScrollable of the receiver"	<bewareOf: #vScrollableChanged>	^self propertyValueAt: #vScrollable! !!CPlayer methodsFor: 'scrolling' stamp: 'ar 3/19/2004 13:22'!vScrollable: aValue	"Modify the receiver's vScrollable"	^self propertyValueAt: #vScrollable put: aValue with: #vScrollableChanged! !!CPlayer methodsFor: 'scrolling' stamp: 'ar 3/24/2004 01:54'!visibleScrollArea	"Answer the visible portion of the scroll area"	^costume visibleScrollArea! !!CPlayer methodsFor: 'testing' stamp: 'ar 3/16/2004 15:23'!isIn: aContainer	"Answer whether the receiver inside the given container"	| cc |	"Answer true for a query against nil since ultimately all player hierarchies end up there"	aContainer ifNil:[^true].	"Open-coded for speed."	cc := self container.	[cc == nil] whileFalse:[		aContainer == cc ifTrue:[^true].		cc := cc container].	^false! !!CPlayer methodsFor: 'testing' stamp: 'ar 8/3/2004 17:20'!isKeyPressed: aKey	"Answer whether the given key is currently pressed"	"FIXME: This is most definitely not correct ...."	| w |	(w := self world) ifNotNil:[^w costume pressedKeys includes: aKey].	^false! !!CPlayer methodsFor: 'testing' stamp: 'ar 3/16/2004 15:24'!isPlayer	"Answer whether the receiver represents a player"	^true! !!CPlayer methodsFor: 'testing' stamp: 'ar 3/16/2004 15:24'!isTilePlayer	"Answer whether the receiver represents a tile-scripting element"	^false! !!CPlayer methodsFor: 'testing' stamp: 'ar 3/16/2004 15:25'!isUnderMouse	"Answer whether the receiver is currently under the hand"	<bewareOf: #mouseOverChanged>	^self hand isOver: self! !!CPlayer methodsFor: 'testing' stamp: 'ar 7/15/2003 16:36'!isWorld	"Do I act as a world?	Note: Later we will modify this based on what exactly a 'world' means"	^self costume isWorld! !!CPlayer methodsFor: 'converting' stamp: 'ar 2/12/2004 16:41'!asCostume	"Answer myself as a costume"	^self costume asCostume! !!CPlayer methodsFor: 'converting' stamp: 'ar 3/16/2004 15:31'!asForm	"Answer a form representing the receiver"	^costume asForm! !!CPlayer methodsFor: 'converting' stamp: 'ar 3/29/2004 22:36'!asPlayer	"Answer this object's player representation."	myPlayer == nil ifTrue:[^self].	myPlayer getCostume == self ifFalse:[^self].	^myPlayer asPlayer! !!CPlayer methodsFor: 'converting' stamp: 'tk 7/14/2004 11:25'!asPrimCostume	"Answer my lowest level costume"	^self costume asPrimCostume! !!CPlayer methodsFor: 'drawing' stamp: 'bf 5/10/2004 13:49'!containsPoint: aPoint	"Answer whether aPoint is in the receiver.	Used for hit-detection in userDraw components."	^self costume containsPoint: aPoint! !!CPlayer methodsFor: 'drawing' stamp: 'bf 5/10/2004 13:49'!drawOn: aCanvas in: drawingBounds	"Draw the receiver in the provided bounds on aCanvas. 	NOTE: This will only work if userDraw is enabled."	^self costume drawOn: aCanvas in: drawingBounds! !!CPlayer methodsFor: 'drawing' stamp: 'ar 3/11/2004 12:44'!icon	<bewareOf: #iconChanged>	^(self propertyValueAt: #icon) ifNil:[self makeIcon]! !!CPlayer methodsFor: 'drawing' stamp: 'ar 3/13/2003 22:31'!icon: newIcon	^self propertyValueAt: #icon put: newIcon with: #iconChanged! !!CPlayer methodsFor: 'drawing' stamp: 'ar 1/1/2003 21:30'!invalidate	"Invalidate the receiver"	^self costume invalidate! !!CPlayer methodsFor: 'drawing' stamp: 'ar 1/28/2003 00:32'!invalidate: aRectangle	"Invalidate the receiver"	^self costume invalidate: aRectangle! !!CPlayer methodsFor: 'drawing' stamp: 'ar 3/9/2003 21:38'!makeIcon	"Create an icon for the receiver"	^self makeIcon: 32@32! !!CPlayer methodsFor: 'drawing' stamp: 'tk 7/14/2004 11:25'!makeIcon: iconExtent	"Create an icon for the receiver"	| form |	form := self asPrimCostume makeThumbnail: iconExtent-2.	form := form shapeBorder: Color black width: 1.	^form! !!CPlayer methodsFor: 'opening' stamp: 'ar 8/13/2003 14:50'!beOnScreen	"Make sure the receiver shows on the screen (and not outside)"	| trial box |	box := self world standardBounds.	trial := self costume fullBounds.	self costume moveBy: (trial amountToTranslateWithin: box).! !!CPlayer methodsFor: 'opening' stamp: 'ar 9/4/2003 22:09'!close	"Close this player, e.g. remove it from the screen"	myCostume ifNotNil:[myCostume close].! !!CPlayer methodsFor: 'opening' stamp: 'ar 2/23/2004 22:51'!defaultContainer	"Answer the default container to use when open the receiver"	^self! !!CPlayer methodsFor: 'opening' stamp: 'tk 7/14/2004 11:25'!isOpen	"Answer whether I exist in some world"	^self asPrimCostume isInWorld! !!CPlayer methodsFor: 'opening' stamp: 'ar 2/23/2004 22:50'!open	"@@@@: Fix this. Should use RealEstateAgent to determine position. :@@@@"	^self open: self defaultContainer at: self hand position - 100! !!CPlayer methodsFor: 'opening' stamp: 'bf 9/8/2004 12:38'!open: aPlayer at: aPoint	"FIXME: Where to open the player should probably be a policy decision but where would we put it???"	| root |	root := ActiveHand world activeProject "a project builder".	"for non-floating, make open in the current project"	aPlayer floating ifFalse:[root := root project ifNil:[root]].	^self open: aPlayer in: root at: aPoint! !!CPlayer methodsFor: 'opening' stamp: 'ar 2/23/2004 22:51'!open: aPlayer in: aContainer	^self open: self defaultContainer in: aContainer at: self hand position - 100! !!CPlayer methodsFor: 'opening' stamp: 'ar 4/2/2004 15:00'!open: aPlayer in: aContainer at: aPoint	| parent |	parent := aContainer ifNil:[self error: 'Fix this - nil container does not work'].	aPlayer costume position: (parent globalToLocal: aPoint).	(aContainer ifNil:[self world]) add: aPlayer.	aPlayer beOnScreen.! !!CPlayer methodsFor: 'opening' stamp: 'ar 2/23/2004 22:51'!openAt: aPoint	self open: self defaultContainer at: aPoint! !!CPlayer methodsFor: 'opening' stamp: 'ar 2/23/2004 22:51'!openAt: aPoint in: aContainer	self open: self defaultContainer in: aContainer at: aPoint! !!CPlayer methodsFor: 'opening' stamp: 'ar 2/23/2004 22:51'!openCenteredAt: aPoint	^self open: self defaultContainer at: aPoint - (self costume fullBounds extent // 2)! !!CPlayer methodsFor: 'opening' stamp: 'tk 7/6/2004 17:01'!openColored	"When the user asks for a player from the Widgets menu, give it a color so it can be seen."	self color: (Color r: 1.0 g: 0.839 b: 0.548).	self hand attach: self! !!CPlayer methodsFor: 'opening' stamp: 'ar 2/23/2004 22:52'!openIn: aContainer	^self open: self defaultContainer in: aContainer! !!CPlayer methodsFor: 'opening' stamp: 'ar 2/23/2004 22:52'!openIn: aContainer at: aPoint	^self open: self defaultContainer in: aContainer at: aPoint! !!CPlayer methodsFor: 'opening' stamp: 'ar 3/7/2004 19:56'!openInHand	self hand attach: self! !!CPlayer methodsFor: 'tk script' stamp: 'tk 6/28/2004 12:03'!adjustColorSpec: converter 	"Return my tweaks dictionary.  Adjust it for special cases of color, transparency, and gradients."	| theTweaks |	(theTweaks _ self tweaks copy) ifNil: [^ Dictionary new].	self hasColorSpec ifTrue: [		(self fillStyle == #solid) & (self fillAlpha = 0) ifTrue: [			"Write fillStyle if it changed"			theTweaks at: #color: put: 'write Color transparent'.		"value is place holder"			theTweaks removeKey: #colors: ifAbsent: [].			theTweaks removeKey: #fillAlpha: ifAbsent: [].			theTweaks removeKey: #fillColor: ifAbsent: [].			theTweaks removeKey: #fillColors: ifAbsent: [].			].		(self fillStyle == #none) ifTrue: [			theTweaks at: #fillStyle: put: 'write current value'.		"value is place holder"			theTweaks removeKey: #color: ifAbsent: [].			theTweaks removeKey: #colors: ifAbsent: [].			theTweaks removeKey: #fillAlpha: ifAbsent: [].			theTweaks removeKey: #fillColor: ifAbsent: [].			theTweaks removeKey: #fillColors: ifAbsent: [].			].		(self fillStyle == #solid) & (self fillAlpha = 1.0) ifTrue: [			"Write fillStyle if it changed"			theTweaks at: #color: put: 'write current value'.		"value is place holder"			theTweaks removeKey: #colors: ifAbsent: [].			theTweaks removeKey: #fillAlpha: ifAbsent: [].			theTweaks removeKey: #fillColor: ifAbsent: [].			theTweaks removeKey: #fillColors: ifAbsent: [].			].		].	^ theTweaks! !!CPlayer methodsFor: 'tk script' stamp: 'tk 6/28/2004 15:17'!asCode	"Return Squeak code to construct an identical object to self.  Use the tweaks."	| myTempName converter |	converter _ (CScriptForObject new initialize) sqkCodeStrm: 					(WriteStream on: (String new: 2000)).	myTempName _ converter tempNameFor: self.	self entireObjectOn: converter using: myTempName.	converter returnTempVar: myTempName.	^ String streamContents: [:sst | 		converter methodHeader: 'tempCode' for: self on: sst.		sst nextPutAll: converter strm contents]! !!CPlayer methodsFor: 'tk script' stamp: 'tk 6/16/2004 07:51'!asCodeCompiled	"Create the code to regenerate self from scratch.  Run it.  Test if the resulting objects has exactly the same structure as self.  See method tempCode to see the code."	| code |	code _ self asCode.	"May want to store this elsewhere"	"compile"	CPlayer compile: code classified: '* tk script'.! !!CPlayer methodsFor: 'tk script' stamp: 'tk 7/6/2004 10:43'!asCodeOn: converter using: myTempName	"With a temp var name already assigned for me, write Squeak code to make the changes from my default state.     Cases:  Set value or add TweakscurValue has tweaks  -> Put in a temp var. tell him to write his tweaks.						Runtime test if his class is the same as now.curValue has no tweaks itself, but it is the new value of a tweak  ->   parent setter: curValue  "	| theTweaks fldDesc hisTempName fldValue |	theTweaks _ self adjustColorSpec: converter. 	#(position: extent:) do: [:aKey | 		((theTweaks includesKey: aKey) not and: [myPlayer == nil "not a costume"]) ifTrue: [			(converter objToName includesKey: self componentHome) ifFalse: ["this is top object"				fldDesc _ self fieldNamed: aKey.				(theTweaks includesKey: fldDesc fieldDefinition toGet) ifFalse: [					(fldValue _ fldDesc value "the current value") tweaks ~~ nil  						ifTrue: [							hisTempName _ converter tempNameFor: fldValue.							"Another level down"							converter assign: hisTempName gets: myTempName 								field: fldDesc fieldDefinition toGet value: fldValue.							"debug"							converter testClassOf: fldValue tempName: hisTempName.														fldValue asCodeOn: converter using: hisTempName]						ifFalse: ["Direct setter"							converter store: fldValue withSetter: fldDesc fieldDefinition toSet in: self]]]]].	theTweaks associationsDo: [:asc | 		fldDesc _ self fieldNamed: asc key.		(fldValue _ fldDesc value "the current value") tweaks ~~ nil  			ifTrue: [				hisTempName _ converter tempNameFor: fldValue.				"Another level down"				converter assign: hisTempName gets: myTempName 					field: fldDesc fieldDefinition toGet value: fldValue.				"debug"				converter testClassOf: fldValue tempName: hisTempName.								fldValue asCodeOn: converter using: hisTempName]			ifFalse: ["Direct setter"				converter store: fldValue withSetter: fldDesc fieldDefinition toSet in: self]].	self propertiesOn: converter using: myTempName. 	"record unusual properties" ! !!CPlayer methodsFor: 'tk script' stamp: 'tk 7/1/2004 16:00'!asEnglish	"Return Squeak code to construct an identical object to self.  Use the tweaks."	| myTempName converter |	converter _ (CEnglishForObject new initialize) sqkCodeStrm: 					(WriteStream on: (String new: 2000)).	myTempName _ converter tempNameFor: self.	self entireObjectOn: converter using: myTempName.	converter returnTempVar: myTempName.	^ String streamContents: [:sst | 		converter methodHeader: 'tempCode' for: self on: sst.		sst nextPutAll: converter strm contents]! !!CPlayer methodsFor: 'tk script' stamp: 'tk 7/13/2004 14:25'!asEnglishOutline	"Return Squeak code to construct an identical object to self.  Use the tweaks."	| myTempName converter |	converter _ (CEnglishObjOutline new initialize) sqkCodeStrm: 					(TextStream on: (Text new: 2000)).	myTempName _ converter tempNameFor: self.	self entireObjectOn: converter using: myTempName.	converter returnTempVar: myTempName.	^ Text streamContents: [:sst | 		converter methodHeader: 'tempCode' for: self on: sst.		sst nextPutAll: converter strm contents]! !!CPlayer methodsFor: 'tk script' stamp: 'tk 7/6/2004 11:11'!asKeywords	"Return Squeak code to construct an identical object to self.  Use the tweaks."	| myTempName converter |	converter _ (CKeywordsForObject new initialize) sqkCodeStrm: (Set new: 200).	myTempName _ converter tempNameFor: self.	self entireObjectOn: converter using: myTempName.	converter returnTempVar: myTempName.	String streamContents: [:sst | 		converter methodHeader: 'tempCode' for: self on: sst].	^ converter keywords! !!CPlayer methodsFor: 'tk script' stamp: 'tk 6/28/2004 15:23'!elementsOn: converter using: myTempName	"Figure out which elements of me were created by my initialization code.  They will be recreated when a new object like me is created.  The other user-added elements need to be written out.  Use timestamp to decide which elements are original.	Tricky things is getting the front-to-back order correct."	| myTime map hisTempName |	myTime _ (self propertyValueAt: #creationTime ifAbsent: [^ false]) asSeconds.	map _ self elements collect: [:ele | converter createTime: myTime near: ele].	"true means mine, don't write"	map detect: [:original | original not] ifNone: [^ self].		self elements keysAndValuesDo: [ :ind :cObj |		(map at: ind)			ifTrue: [converter elementPresent: ind]			ifFalse: [				hisTempName _ converter tempNameAndStore: cObj.	"stores him"				converter elementsOf: myTempName add: hisTempName at: ind]].! !!CPlayer methodsFor: 'tk script' stamp: 'tk 6/28/2004 15:26'!entireObjectOn: converter using: myTempName	"Write squeak code for all my changes on the stream."	converter assign: myTempName new: self class.	self asCodeOn: converter using: myTempName. 	"mods from my tweaks"	self elementsOn: converter using: myTempName.		"Write submorphs first"! !!CPlayer methodsFor: 'tk script' stamp: 'tk 6/28/2004 12:03'!hasColorSpec	"Return true of any of the color variables are in tweaks"	| tw |	tw _ self tweaks.	#(color: colors: fillAlpha: fillColor: fillColors:) do: [:symb |		(tw includesKey: symb) ifTrue: [^ true]].	^ false! !!CPlayer methodsFor: 'tk script' stamp: 'tk 7/1/2004 16:07'!propertiesOn: converter using: myTempName	"This is only for very special properties, such as (CheckBox value)."	"With a temp var name already assigned for me, write Squeak code to make the changes from the default state of my properties.     Always use a setter to store an object. "	| myProps theKeys tweaksDict setter asc |	(myProps _ self myProperties) ifNil: [^ self].	theKeys _ #(value). 	"only these"	self tweaks ifNotNil: [		tweaksDict _ self tweaks.		theKeys copy do: [:kk | 			setter _ (kk,':') asSymbol.			(tweaksDict includesKey: setter) ifTrue: [theKeys _ theKeys copyWithout: kk]]].	theKeys do: [:aKey |		(asc _ myProps associationAt: aKey ifAbsent: [nil]) ifNotNil: [			asc value == self ifFalse: [				"Direct setter"				converter store: asc value withSetter: aKey, ':' in: self]]].! !!CPlayer methodsFor: 'tk script' stamp: 'tk 6/21/2004 09:44'!tempCode	"This code regenerates the CPlayer: CheckBox"| checkBox1 |checkBox1 _ CCheckBox new.checkBox1 value:  true.checkBox1 extent: 77@16.checkBox1 color: (Color r: 0.376 g: 0.0 b: 1.0).checkBox1 label: 'some label'.checkBox1 position: 397@39.checkBox1 fillStyle: #solid.^ checkBox1! !!CPlayer methodsFor: 'tk script' stamp: 'tk 6/15/2004 14:22'!verifyObjGen	"Create the code to regenerate self from scratch.  Run it.  Test if the resulting objects has exactly the same structure as self.  See method tempCode to see the code."	| code |	code _ self asCode.	"May want to store this elsewhere"	"compile"	CPlayer compile: code classified: '* tk script'.	^ self equiv: self tempCode	"See self tempCode for the code produced"! !!CPlayer methodsFor: 'serializing' stamp: 'ar 3/14/2004 15:03'!readFixedFieldsFrom: deSerializer	| varNames vv |	super readFixedFieldsFrom: deSerializer.	myPlayer := deSerializer readField: #player ifAbsent:[myPlayer].	myCostume := deSerializer readField: #costume ifAbsent:[myCostume].	CPlayer instSize+1 to: self class instSize do:[:i|		varNames ifNil:[varNames := self class allInstVarNames].		vv := deSerializer readField: (varNames at: i) ifAbsent:[self instVarAt: i].		self instVarAt: i put: vv.	].! !!CPlayer methodsFor: 'serializing' stamp: 'ar 3/14/2004 15:03'!writeFixedFieldsOn: aSerializer	| varNames |	super writeFixedFieldsOn: aSerializer.	aSerializer writeField: #player value: myPlayer.	aSerializer writeField: #costume value: myCostume.	CPlayer instSize+1 to: self class instSize do:[:i|		varNames ifNil:[varNames := self class allInstVarNames].		aSerializer writeField: (varNames at: i) value: (self instVarAt: i).	].! !!CPlayer methodsFor: 'private' stamp: 'ar 2/7/2004 21:28'!dispatchEvent: event	^self costume dispatchEvent: event! !!CPlayer methodsFor: 'private' stamp: 'ar 3/22/2004 02:33'!getCostume	^myCostume! !!CPlayer methodsFor: 'private' stamp: 'ar 3/22/2004 02:33'!getPlayer	^myPlayer! !!CPlayer methodsFor: 'private' stamp: 'ar 5/6/2004 16:19'!handlesAnyOf: eventNames	(super handlesAnyOf: eventNames) ifTrue:[^true].	myPlayer ifNil:[^false].	myPlayer getCostume == self ifFalse:[^false].	^myPlayer handlesAnyOf: eventNames! !!CPlayer methodsFor: 'private' stamp: 'ar 5/6/2004 16:18'!handlesEvent: eventName	(super handlesEvent: eventName) ifTrue:[^true].	myPlayer ifNil:[^false].	myPlayer getCostume == self ifFalse:[^false].	^myPlayer handlesEvent: eventName! !!CPlayer methodsFor: 'private' stamp: 'ar 3/25/2004 12:05'!listItemValue: aValue	"Request the receiver to represent a particular value in a list. In most situations, we will simply carry the value as our own (since many, if not most, elements in lists will be bare-bone objects rather than players) but in some situations we may want to interpret it differently. Most importantly we may want to have the lists element represent another costume for the object in the list and this situation cannot be handled well via a #valueChanged handler since setting one's player via #valueChanged will implicitly modify the receiver's value (which causes all sorts of trouble since it is never clear if the value is now the player or the player's value). For this situations, one can simply implement #listItemValue: to provide the appropriate conversion. Here, we simply assume that most list items will show their value."	self value: aValue! !!CPlayer methodsFor: 'private' stamp: 'ar 4/30/2004 16:09'!makeDefaultCostume	"This method is deprecated, but for now keep it around for compatibility"! !!CPlayer methodsFor: 'private' stamp: 'ar 6/21/2003 02:41'!onDrag	^self costume onDrag! !!CPlayer methodsFor: 'private' stamp: 'tk 7/1/2004 16:16'!printOn: aStream	super printOn: aStream.	self componentBinding ifNotNil:[		aStream nextPut:$[; 			nextPutAll: self componentBinding name; 		nextPut: $].	].! !!CPlayer methodsFor: 'private' stamp: 'ar 9/8/2004 16:24'!privateChangeCostumeTo: newCostume	"Private!! Change my costume to be newCostume.	WARNING: This method must maintain the fundamental invariants of the framework and changing it is likely to get you entirely unpredictable results. Don't do it okay? At least not until you know precisely what you're doing."	| oldCostume |	"get out quickly if we can"	(oldCostume := myCostume) == newCostume ifTrue:[^self].	"Set my costume"	myCostume := newCostume.	"Let my costume know about having a new player"	newCostume ifNotNil:[newCostume player: self].	"And notify anyone interested in the change"	self signalChanged: #costumeChanged from: oldCostume to: newCostume.	^newCostume! !!CPlayer methodsFor: 'private' stamp: 'ar 9/8/2004 16:24'!privateChangePlayerTo: newPlayer	"Private!! Change my player to be newPlayer.	WARNING: This method must maintain the fundamental invariants of the framework and changing it is likely to get you entirely unpredictable results. Don't do it okay? At least not until you know precisely what you're doing."	| oldPlayer |	"get out quickly if we can"	(oldPlayer := myPlayer) == newPlayer ifTrue:[^newPlayer].	"Release myPlayer here to prevent any recursion problems"	myPlayer := nil.	oldPlayer ifNotNil:[		"If I was the costume (primary view) for the old player release it"		oldPlayer privateReleaseCostume: self.		"Stop my value updating script."		self stopScript: #privateChangeValueTo:.	].	"Prevent another set of recursion issues by setting newPlayer here"	myPlayer := newPlayer.	"Note: Do NOT set the new costume here - inside this method 	we don't know if a sender really wants us to be the primary 	costume for the new player."	"But signal #playerChanged here and now before we update the value."	self signalChanged: #playerChanged from: oldPlayer to: newPlayer.	"Update my value from the new player"	newPlayer ifNotNil:[		value := newPlayer value.		"And start the value updating script"		self startScript: #privateChangeValueTo:			when:{newPlayer. #valueChanged}.	].	^newPlayer! !!CPlayer methodsFor: 'private' stamp: 'ar 3/17/2004 18:30'!privateChangeValueTo: newValue	"Private. Really. Change my value to be newValue after our player's value has changed. 	WARNING: This method must maintain the fundamental invariants of the framework and changing it is likely to get you entirely unpredictable results. Don't do it okay? At least not until you know precisely what you're doing.	BTW, we could have just used #value: for updating from the player's value but this would get us into trouble if a user *ever* uses the same technique - say, setting its value using something like 'self startScript: #value: when:{foo. #valueChanged}.' While it is unlikely that someone uses that technique I would not like to have a naive 'self stopScript: #value:' to break the framework. So we deliberately use an obscure name to keep it out of the user space, even though all it does is just:"	value := newValue.! !!CPlayer methodsFor: 'private' stamp: 'ar 3/26/2004 00:58'!privateGetValue	"Private!! Answer my value.	WARNING: This method must maintain the fundamental invariants of the framework and changing it is likely to get you entirely unpredictable results. Don't do it okay? At least not until you know precisely what you're doing."	^super value! !!CPlayer methodsFor: 'private' stamp: 'ar 3/17/2004 18:30'!privateReleaseCostume: aCostume	"Private!! Release aCostume as my primary costume if it had acted in this role.	WARNING: This method must maintain the fundamental invariants of the framework and changing it is likely to get you entirely unpredictable results. Don't do it okay? At least not until you know precisely what you're doing."	myCostume == aCostume ifTrue:[costume := nil].! !!CPlayer methodsFor: 'private' stamp: 'ar 3/28/2004 20:05'!privateSetValueTo: newValue	"Private!! Change my value to be newValue. 	WARNING: This method must maintain the fundamental invariants of the framework and changing it is likely to get you entirely unpredictable results. Don't do it okay? At least not until you know precisely what you're doing.	OPTIMIZATIONS: Actually, there is absolutely no reason to push the #valueChanged message over to the player since setting its value anyway. We could just nil out myPlayer while we write our own value. I haven't done this (yet) simply because having the extra notification pointed out an important bug in the architecture so I'll leave it in until it hurts too much."	"First set my value - this allows synchronously acting players to	signal a valueChanged *after* our valueChanged which can be critical."	super value: newValue.	"Now notify my player"	myPlayer ifNotNil:[myPlayer value: newValue].	"And answer the new value"	^newValue! !!CPlayer methodsFor: 'private' stamp: 'ar 5/6/2004 16:19'!signalEvent: anEvent	super signalEvent: anEvent.	myPlayer ifNil:[^nil].	myPlayer getCostume == self ifFalse:[^nil].	anEvent setSender: myPlayer.	myPlayer signalEvent: anEvent.! !!CPlayer methodsFor: 'private' stamp: 'ar 3/24/2004 00:34'!tweakedCostume: aCostume	"Broadcast tweaks happened to aCostume.	This feels wrong ... see the senders"	myCostume == aCostume 		ifTrue:[self tweaked: #costume from: aCostume to: aCostume].! !!CBorderStyleReadout methodsFor: 'initialize' stamp: 'bf 3/30/2004 18:24'!initialize	super initialize.	self extent: 20@20.	self color: CWidgetLibrary default frameColor.	self borderColor: CWidgetLibrary default frameColor.	borderStyle := #simple.	borderWidth := 4.! !!CBorderStyleReadout methodsFor: 'events' stamp: 'ar 3/24/2004 02:03'!deselect	self removeHighlight: #selectionHighlight.! !!CBorderStyleReadout methodsFor: 'events' stamp: 'tk 6/23/2004 10:52'!onValueChanged	<on: valueChanged>	value ifNil:[^self].	self borderStyle: value.	value == #simple ifTrue:[		color := Color transparent.		borderWidth := 5.	"see it better when selected"	].	value == #none ifTrue:[		color := Color transparent.		borderWidth := 1.		borderColor := Color gray.		borderStyle := #simple.	].! !!CBorderStyleReadout methodsFor: 'events' stamp: 'ar 3/24/2004 02:01'!select	| highlight |	highlight := CFramingHighlight new.	highlight border: (CBorder width: 2 color: Color black).	highlight name: #selectionHighlight.	self addHighlight: highlight.! !!CCodeHolder methodsFor: 'initialize' stamp: 'ar 3/6/2004 23:50'!defaultContainer	^window ifNil:[self]! !!CCodeHolder methodsFor: 'initialize' stamp: 'ar 3/31/2004 15:39'!initialize	super initialize.	"Define our components"	self define: #window as: CWindow new.	self define: #codePane as: CTextEditor new.	self initializeStandardCodingKeys.! !!CCodeHolder methodsFor: 'initialize' stamp: 'ar 3/31/2004 15:37'!initializeStandardCodingKeys	"Initialize the default coding keys"	"CTextEditor initializeStandardCodingKeys"	codingKeys := CKeyboardDispatchTable new.	Smalltalk platformName = 'Win32' ifTrue:[		codingKeys addAll: self win32CodingKeys.		^self].	"Put all others here"	"Fall back to Mac by default"	codingKeys addAll: self macCodingKeys.! !!CCodeHolder methodsFor: 'initialize' stamp: 'md 5/3/2004 14:07'!macCodingKeys	^#(			((ctrl i) exploreIt)			((ctrl t) pasteIfTrue)			((ctrl f) pasteIfFalse)			((ctrl v) pasteInitials)			((cmd d) doIt)			((cmd p) printIt)			((cmd i) inspectIt)			((cmd b) definitionsOfIt)			((cmd shift n) referencesToIt)			((cmd m) browseImplementors)			((cmd n) browseSenders)	)! !!CCodeHolder methodsFor: 'initialize' stamp: 'ar 7/29/2004 21:31'!setupCostume	"Create the default costume"	self costume: window.	self extent: 400@265.	self layout: CProportionalLayout new.	codePane color: Color transparent.	codePane layoutFrame: (0@0 corner: 1@1).	codePane hResizing: #spaceFill; vResizing: #spaceFill.	codePane textWrap: true.	codePane hScrollable: false; vScrollable: true.	window add: codePane.	"Give all of my contents the default look"	window elements do:[:each|		each borderWidth: 2.		each borderStyle: #complexAltInset.		each borderColor: (Color r: 0.995 g: 0.788 b: 0.353).		each windowColor: (Color r: 0.67 g: 0.67 b: 0.67).	].	window label: self class name.	window color: (Color r: 0.67 g: 0.67 b: 0.67).! !!CCodeHolder methodsFor: 'initialize' stamp: 'ar 3/31/2004 15:37'!win32CodingKeys	^#(			((cmd T) pasteIfTrue)			((cmd F) pasteIfFalse)			((ctrl D) doIt)			((ctrl E) exploreIt)			((ctrl P) printIt)			((ctrl I) inspectIt)			((ctrl M) definitionsOfIt)			((ctrl N) referencesToIt)			((ctrl B) browseIt)	)! !!CCodeHolder methodsFor: 'accessing' stamp: 'ar 3/14/2004 15:27'!codePane	"Answer the codePane of the receiver"	<bewareOf: #codePaneChanged>	^self propertyValueAt: #codePane! !!CCodeHolder methodsFor: 'accessing' stamp: 'ar 3/14/2004 15:27'!codePane: aValue	"Modify the receiver's codePane"	^self propertyValueAt: #codePane put: aValue with: #codePaneChanged! !!CCodeHolder methodsFor: 'accessing' stamp: 'ar 3/31/2004 15:37'!codingKeys	"Answer the codingKeys of the receiver"	<bewareOf: #codingKeysChanged>	^self propertyValueAt: #codingKeys! !!CCodeHolder methodsFor: 'accessing' stamp: 'ar 3/31/2004 15:37'!codingKeys: aValue	"Modify the receiver's codingKeys"	^self propertyValueAt: #codingKeys put: aValue with: #codingKeysChanged! !!CCodeHolder methodsFor: 'accessing' stamp: 'ar 3/28/2004 01:33'!contents	^codePane contents! !!CCodeHolder methodsFor: 'accessing' stamp: 'ar 3/28/2004 01:33'!contents: newContents	codePane contents: newContents! !!CCodeHolder methodsFor: 'accessing' stamp: 'tk 6/29/2004 14:09'!geometry	"My window has my bounds"	^window geometry! !!CCodeHolder methodsFor: 'accessing' stamp: 'ar 3/28/2004 01:34'!label	^window label! !!CCodeHolder methodsFor: 'accessing' stamp: 'ar 3/28/2004 01:34'!label: aString	window label: aString! !!CCodeHolder methodsFor: 'accessing' stamp: 'md 4/21/2004 10:44'!selectedClassOrMetaClass	^ self selectedClass	"I don't know any better"! !!CCodeHolder methodsFor: 'accessing' stamp: 'ar 3/14/2004 15:27'!window	"Answer the window of the receiver"	<bewareOf: #windowChanged>	^self propertyValueAt: #window! !!CCodeHolder methodsFor: 'accessing' stamp: 'ar 3/14/2004 15:27'!window: aValue	"Modify the receiver's window"	^self propertyValueAt: #window put: aValue with: #windowChanged! !!CCodeHolder methodsFor: 'selection access' stamp: 'ar 3/31/2004 14:42'!selectedClass	"Answer the currently selected class (not just its name)"	^nil! !!CCodeHolder methodsFor: 'selection access' stamp: 'ar 3/31/2004 14:43'!selectedClassName	"Answer the name of the currently selected"	^(self selectedClass ifNil:[^nil]) name! !!CCodeHolder methodsFor: 'selection access' stamp: 'ar 3/31/2004 15:00'!selectedSelector	"Try to make a selector out of the current text selection"	^codePane selection string findSelector! !!CCodeHolder methodsFor: 'events' stamp: 'ar 3/31/2004 15:39'!onCodePaneKeyDown: evt	"Update the message category list when the class list's cursor changes"	| action |	<on: keyDown in: codePane>	codingKeys ifNil:[^nil].	action := codingKeys lookupEvent: evt.	action ifNotNil:[self perform: action].! !!CCodeHolder methodsFor: 'events' stamp: 'ar 7/29/2004 21:59'!onWindowColorChanged: newColor	<on: windowColorChanged in: window>	window elements do:[:each| each windowColor: newColor].! !!CCodeHolder methodsFor: 'validation' stamp: 'ar 3/7/2004 00:07'!okToChange	"See if there is unaccepted input"	codePane modified ifFalse:[^true].	(CDialog confirm: 'Changes have not been saved.Is it OK to cancel those changes?') ifFalse:[^false].	codePane modified: false.	^true! !!CCodeHolder methodsFor: 'validation' stamp: 'ar 3/7/2004 00:07'!okToChangeList: aList from: prevValue	"This is a slightly modified version of okToChange so that the user is not presented with weird changes in the selection. It silently sets back the list selection to its previous value until the user has decided what to do."	| nextValue |	nextValue := aList selection.	nextValue = prevValue ifTrue:[^false]. "No need to change it"	aList selection: prevValue.	self okToChange ifFalse:[^false].	aList selection: nextValue.	^true! !!CCodeHolder methodsFor: 'evaluating' stamp: 'ar 3/31/2004 14:26'!doIt	"Set the context to include pool vars of the model.  Then evaluate."	^ self evaluateSelection.! !!CCodeHolder methodsFor: 'evaluating' stamp: 'ar 3/31/2004 14:45'!doItContext	"Answer the context in which a text selection can be evaluated."	^nil! !!CCodeHolder methodsFor: 'evaluating' stamp: 'ar 3/31/2004 14:44'!doItReceiver	"Answer the object that should be informed of the result of evaluating a text selection."	^nil! !!CCodeHolder methodsFor: 'evaluating' stamp: 'ar 3/31/2004 15:12'!evaluateSelection	| rcvr ctxt result |	codePane editor selectLineIfEmpty.	FakeClassPool adopt: self selectedClass.  "Include pool vars if any"	rcvr _ self doItReceiver.	ctxt _ self doItContext.	result _ [		CCompiler new 			evaluate: codePane selection readStream			in: ctxt			to: rcvr			notifying: self			ifFail: [FakeClassPool adopt: nil. ^ #failedDoit]	] 		on: OutOfScopeNotification 		do: [ :ex | ex resume: true].	FakeClassPool adopt: nil.	Smalltalk logChange: codePane selection string.	^ result! !!CCodeHolder methodsFor: 'evaluating' stamp: 'ar 4/4/2004 16:44'!inspectIt	"Treat the current text selection as an expression; evaluate it.	Open an inspector on the result of the expression."	| result |	result _ self evaluateSelection.	((result isKindOf: FakeClassPool) or: [result == #failedDoit])		ifTrue: [^codePane flash].	result inspect! !!CCodeHolder methodsFor: 'evaluating' stamp: 'ar 3/31/2004 15:03'!printIt	"Treat the current text selection as an expression; evaluate it. Insert the 	description of the result of evaluation after the selection and then make 	this description the new text selection."	| result |	result _ self evaluateSelection.	((result isKindOf: FakeClassPool) or: [result == #failedDoit])		ifTrue: [^codePane flash].	codePane selectionStart: codePane selectionStop.	codePane paste: ' ', result printString select: true.! !!CCodeHolder methodsFor: 'evaluating' stamp: 'ar 3/31/2004 15:11'!selectFrom: start to: stop	codePane selectFrom: start to: stop! !!CCodeHolder methodsFor: 'evaluating' stamp: 'ar 3/31/2004 14:46'!selectionInterval	^codePane selectionStart to: codePane selectionStop! !!CCodeHolder methodsFor: 'browsing' stamp: 'ar 3/31/2004 14:54'!allCallsOn: aLiteral 	"Answer a Collection of all the methods that call on aLiteral even deeply embedded in 	literal array."	^SystemNavigation new allCallsOn: aLiteral! !!CCodeHolder methodsFor: 'browsing' stamp: 'ar 3/31/2004 14:54'!browseAllAccesses: aClass to: instVarName	"Create and schedule a Message Set browser for all the receiver's methods 	or any methods of a subclass/superclass that refer to the instance variable name."	| coll |	coll _ OrderedCollection new.	Cursor wait showWhile: [		aClass withAllSubAndSuperclassesDo: [:class | 			(class whichSelectorsAccess: instVarName) do: [:sel |				sel == #DoIt ifFalse: [					coll add: (						MethodReference new							setStandardClass: class 							methodSymbol: sel					)				]			]		].	].	^ self 		browseMessageList: coll 		name: 'Accesses to ' , instVarName 		autoSelect: instVarName! !!CCodeHolder methodsFor: 'browsing' stamp: 'ar 3/31/2004 14:52'!browseAllCallsOn: aLiteral 	"Create and schedule a message browser on each method that refers to aLiteral"	(aLiteral isKindOf: LookupKey)		ifTrue: [^ self				browseMessageList: (self allCallsOn: aLiteral) asSortedCollection				name: 'Users of ' , aLiteral key				autoSelect: aLiteral key].	self		browseMessageList: (self allCallsOn: aLiteral) asSortedCollection		name: 'Senders of ' , aLiteral		autoSelect: aLiteral keywords first! !!CCodeHolder methodsFor: 'browsing' stamp: 'ar 3/31/2004 14:57'!browseAllImplementorsOf: selector 	"Create and schedule a message browser on each method that implements 	the message whose selector is the argument, selector."	^ self		browseMessageList: (self allImplementorsOf: selector)		name: 'Implementors of ' , selector		autoSelect: nil.! !!CCodeHolder methodsFor: 'browsing' stamp: 'ar 3/31/2004 14:53'!browseAllStores: aClass into: instVarName	"Create and schedule a Message Set browser for all the receiver's methods 	or any methods of a subclass/superclass that refer to the instance variable name."	| coll |	coll _ OrderedCollection new.	Cursor wait showWhile: [		aClass withAllSubAndSuperclassesDo: [:class | 			(class whichSelectorsStoreInto: instVarName) do: [:sel |				sel == #DoIt ifFalse: [					coll add: (						MethodReference new							setStandardClass: class 							methodSymbol: sel					)				]			]		].	].	^ self		browseMessageList: coll 		name: 'Stores into ' , instVarName 		autoSelect: instVarName! !!CCodeHolder methodsFor: 'browsing' stamp: 'ar 3/31/2004 14:53'!browseClassRefs	| aClass |	aClass _ self selectedClass ifNil:[^self flash].	self browseAllCallsOn: (Smalltalk associationAt: aClass theNonMetaClass name).! !!CCodeHolder methodsFor: 'browsing' stamp: 'ar 3/31/2004 14:53'!browseClassVarRefs	self browseClassVarRefs: self selectedClass.! !!CCodeHolder methodsFor: 'browsing' stamp: 'ar 3/31/2004 14:53'!browseClassVarRefs: aClass	| binding |	aClass ifNil:[^self].	self chooseClassVar: aClass thenDo:[:varName| 		aClass withAllSuperclasses do:[:cls|			binding := cls classPool associationAt: varName ifAbsent:[nil].			binding ifNotNil:[^self browseAllCallsOn: binding]]].! !!CCodeHolder methodsFor: 'browsing' stamp: 'ar 3/31/2004 14:53'!browseInstVarDefs	self browseInstVarDefs: self selectedClassOrMetaClass.! !!CCodeHolder methodsFor: 'browsing' stamp: 'ar 3/31/2004 14:53'!browseInstVarDefs: aClass	aClass ifNil:[^self flash].	self chooseInstVar: aClass 		thenDo:[:varName| self browseAllStores: aClass into: varName]! !!CCodeHolder methodsFor: 'browsing' stamp: 'ar 3/31/2004 14:53'!browseInstVarRefs	self browseInstVarRefs: self selectedClassOrMetaClass.! !!CCodeHolder methodsFor: 'browsing' stamp: 'ar 3/31/2004 14:53'!browseInstVarRefs: aClass	aClass ifNil:[^self flash].	self chooseInstVar: aClass 		thenDo:[:varName| self browseAllAccesses: aClass to: varName]! !!CCodeHolder methodsFor: 'browsing' stamp: 'ar 3/31/2004 14:57'!browseMessageList: aMessageList name: labelString autoSelect: autoSelectString	"Create and schedule a MessageSet browser on the message list."	| title sz |	sz := aMessageList size.	sz = 0 ifTrue:[^CDialog inform: ('There are no\' , labelString) withCRs].	sz > 1		ifTrue:	[title := labelString, ' [', sz, ']']		ifFalse:	[title := labelString].	CMessageSet 		openMessageList: aMessageList 		name: title 		autoSelect: autoSelectString! !!CCodeHolder methodsFor: 'browsing' stamp: 'ar 3/31/2004 14:53'!chooseClassVar: aClass thenDo: aBlock 	"Put up a menu of all the instance variables in the selected class, and when the user chooses one, evaluate aBlock with the chosen variable as its parameter.  If the list is 6 or larger, then offer an alphabetical formulation as an alternative. triggered by a 'show alphabetically' item at the top of the list."	| vars count list varMenu result |	(count _ aClass allClassVarNames size) = 0 ifTrue: 		[^ CDialog inform: 'There are noinstance variables.'].	list := Array new writeStream.	(count > 5) ifTrue:[		list nextPut: {'show alphabetically'. 'show alphabetically'}.		list nextPut: #-.	].	aClass withAllSuperclasses reverseDo:[:class |		vars _ class classVarNames.		vars do:[:var | list nextPut: {var. var} ].		vars isEmpty ifFalse:[list nextPut: #-].	].	varMenu := CMenu new.	varMenu label: 'Class variables in', aClass name.	result := varMenu chooseFrom: list contents.	result = 'show alphabetically' ifFalse:[^aBlock value: result].	self chooseClassVarAlphabetically: aClass thenDo: aBlock! !!CCodeHolder methodsFor: 'browsing' stamp: 'ar 3/31/2004 14:54'!chooseInstVar: aClass thenDo: aBlock 	"Put up a menu of all the instance variables in the selected class, and when the user chooses one, evaluate aBlock with the chosen variable as its parameter.  If the list is 6 or larger, then offer an alphabetical formulation as an alternative. triggered by a 'show alphabetically' item at the top of the list."	| vars count list varMenu result |	(count _ aClass allInstVarNames size) = 0 ifTrue: 		[^ CDialog inform: 'There are noinstance variables.'].	list := Array new writeStream.	(count > 5) ifTrue:[		list nextPut: {'show alphabetically'. 'show alphabetically'}.		list nextPut: #-.	].	aClass withAllSuperclasses reverseDo:[:class |		vars _ class instVarNames.		vars do:[:var | list nextPut: {var. var} ].		vars isEmpty ifFalse:[list nextPut: #-].	].	varMenu := CMenu new.	varMenu label: 'Instance variables in', aClass name.	result := varMenu chooseFrom: list contents.	result = 'show alphabetically' ifFalse:[^aBlock value: result].	self chooseInstVarAlphabetically: aClass thenDo: aBlock! !!CCodeHolder methodsFor: 'browsing' stamp: 'ar 3/31/2004 14:57'!definitionsOfIt	"Open an implementors browser on the selected selector"	| aSelector |	self lineSelectAndEmptyCheck: [^ self].	(aSelector _ self selectedSelector) == nil ifTrue: [^ self flash].	self browseAllImplementorsOf: aSelector.! !!CCodeHolder methodsFor: 'browsing' stamp: 'ar 3/31/2004 14:59'!lineSelectAndEmptyCheck: aBlock	codePane editor selectLineIfEmpty.	codePane selection size = 0 ifTrue:[^aBlock value].! !!CCodeHolder methodsFor: 'browsing' stamp: 'md 5/1/2004 14:05'!referencesToIt	| aSymbol |	self lineSelectAndEmptyCheck: [^ self].	((aSymbol _ self selectedMessage) == nil or:		[(Smalltalk includesKey: aSymbol) not])			ifTrue: [^self flash].	self browseAllCallsOn: (Smalltalk associationAt: aSymbol)! !!CCodeHolder methodsFor: 'text' stamp: 'ar 3/31/2004 14:49'!textHolder	"Ugly... but what can we do..."	^codePane textHolder! !!CCodeHolder methodsFor: 'actions - message list' stamp: 'md 4/23/2004 16:42'!allImplementorsOf: aSelector	^SystemNavigation default allImplementorsOf: aSelector! !!CCodeHolder methodsFor: 'actions - message list' stamp: 'md 4/23/2004 17:34'!browseAllImplementorsOfList: selectorList title: aTitle 	"Create and schedule a message browser on each method that implements 	the message whose selector is in the argument selectorList."	| implementorLists flattenedList |	implementorLists _ selectorList				collect: [:each | self allImplementorsOf: each].	flattenedList _ SortedCollection new.	implementorLists		do: [:each | flattenedList addAll: each].	Cursor normal show.	self		browseMessageList: flattenedList		name: 'aTitle'		autoSelect: nil.! !!CCodeHolder methodsFor: 'actions - message list' stamp: 'md 4/22/2004 16:32'!browseImplementors	self selectMessage: 'Implementors of ...' 		andEvaluate:[:msg| self browseAllImplementorsOf: msg].! !!CCodeHolder methodsFor: 'actions - message list' stamp: 'md 4/21/2004 10:41'!browseMethodFull	"Create and schedule a full Browser and then select the current class and message."	| myClass browser |	(myClass _ self selectedClassOrMetaClass) ifNil:[^self].	browser := CClassBrowser new.	browser selectClass: myClass selector: self selectedMessage.	browser open.! !!CCodeHolder methodsFor: 'actions - message list' stamp: 'md 4/22/2004 16:45'!browseMethodHierarchy	"Create and schedule a message set browser on all implementors of the 	currently selected message selector. Do nothing if no message is selected."	| list aClassNonMeta isMeta theClassOrMeta aClass selector |	aClass := self selectedClassOrMetaClass ifNil: [^ self].	selector := self selectedMessage ifNil: [^ self].	aClassNonMeta _ aClass theNonMetaClass.	isMeta _ aClassNonMeta ~~ aClass.	list _ OrderedCollection new.	aClass allSuperclasses reverseDo:[:cl |		(cl includesSelector: selector) ifTrue:[			list addLast: (MethodReference new setStandardClass: cl methodSymbol: selector)]].	aClassNonMeta allSubclassesWithLevelDo:[:cl :level |		theClassOrMeta _ isMeta ifTrue: [cl class] ifFalse: [cl].		(theClassOrMeta includesSelector: selector) ifTrue:[			list addLast: (MethodReference new 				setStandardClass: theClassOrMeta methodSymbol: selector)]]	 	startingLevel: 0.	self browseMessageList: list		name: 'Inheritance of ' , selector		autoSelect: nil.! !!CCodeHolder methodsFor: 'actions - message list' stamp: 'md 4/23/2004 16:34'!browseSenders	self selectMessage:'Senders of ...'		andEvaluate:[:msg| self browseAllCallsOn: msg].! !!CCodeHolder methodsFor: 'actions - message list' stamp: 'md 4/23/2004 16:16'!fileOutMessage	"Put a description of the selected message on a file"	self selectedMessageName ifNotNil:		[Cursor write showWhile:			[self selectedClassOrMetaClass fileOutMethod: self selectedMessageName]]! !!CCodeHolder methodsFor: 'actions - message list' stamp: 'md 4/23/2004 15:13'!findMethodInChangeSets	"Find and open a changeSet containing the current method."	| aName |	(aName _ self selectedMessageName) ifNotNil: [		CChangeSorter browseChangeSetsWithClass: self selectedClassOrMetaClass					selector: aName]! !!CCodeHolder methodsFor: 'actions - message list' stamp: 'md 4/23/2004 16:41'!methodHierarchy	"Create and schedule a method browser on the hierarchy of implementors."	self cNotYet.	"Utilities methodHierarchyBrowserForClass: self selectedClassOrMetaClass 			selector: self selectedMessageName"! !!CCodeHolder methodsFor: 'actions - message list' stamp: 'md 4/23/2004 16:16'!openSingleMessageBrowser	| msgName mr |	"Create and schedule a message list browser populated only by the currently selected message"	(msgName _ self selectedMessageName) ifNil: [^ self].	mr _ MethodReference new		setStandardClass: self selectedClassOrMetaClass		methodSymbol: msgName.	self  		browseMessageList: (Array with: mr)		name: mr asStringOrText		autoSelect: nil! !!CCodeHolder methodsFor: 'actions - message list' stamp: 'md 4/23/2004 16:17'!printOutMessage	"Write a file with the text of the selected message, for printing by a web browser"	self selectedMessageName ifNotNil: [		self selectedClassOrMetaClass fileOutMethod: self selectedMessageName							asHtml: true]! !!CCodeHolder methodsFor: 'actions - message list' stamp: 'md 4/23/2004 17:44'!removeFromCurrentChanges	"Tell the changes mgr to forget that the current msg was changed."	ChangeSet current removeSelectorChanges: self selectedMessageName 			class: self selectedClassOrMetaClass.! !!CCodeHolder methodsFor: 'actions - message list' stamp: 'md 4/23/2004 17:41'!revertAndForget	"Revert to the previous version of the current method, and tell the changes mgr to forget that it was ever changed.  Danger!!  Use only if you really know what you're doing!!"	self okToChange ifFalse: [^ self].	self revertToPreviousVersion.	self removeFromCurrentChanges.	self signal: #updateCodePane.! !!CCodeHolder methodsFor: 'actions - message list' stamp: 'md 4/23/2004 17:43'!revertToPreviousVersion	"Revert to the previous version of the current method"	| aClass aSelector  changeRecords |	self okToChange ifFalse: [^ self].	aClass _ self selectedClassOrMetaClass.	aClass ifNil: [^ self changed: #flash].	aSelector _ self selectedMessageName.	changeRecords _ aClass changeRecordsAt: aSelector.	(changeRecords == nil or: [changeRecords size <= 1]) ifTrue: [self changed: #flash.  ^ self beep].	changeRecords second fileIn.	self signal: #updateCodePane.! !!CCodeHolder methodsFor: 'actions - message list' stamp: 'md 4/23/2004 16:35'!selectMessage: label andEvaluate: aBlock	"Allow the user to choose one selector, chosen from the currently selected message's selector, as well as those of all messages sent by it, and evaluate aBlock on behalf of chosen selector.  If there is only one possible choice, simply make it; if there are multiple choices, put up a menu, and evaluate aBlock on behalf of the the chosen selector, doing nothing if the user declines to choose any"	| selector method messages msgMenu result |	selector _ self selectedMessage ifNil: [^ self].	method _ (self selectedClassOrMetaClass ifNil: [^ self])		compiledMethodAt: selector ifAbsent:[nil].	method ifNil:[^aBlock value: selector].	messages _ method messages copyWithout: selector.	messages isEmpty ifTrue: [^ aBlock value: selector].	msgMenu := CMenu new.	msgMenu label: (label ifNil:['Choose message']).	result := msgMenu chooseFromValues: messages default: selector.	result ifNotNil:[aBlock value: result].! !!CCodeHolder methodsFor: 'actions - class list' stamp: 'md 4/23/2004 14:02'!browseClassVariables	"Browse the class variables of the selected class. 2/5/96 sw"	| cls |	cls _ self selectedClass.	cls		ifNotNil: [self systemNavigation  browseClassVariables: cls]! !!CCodeHolder methodsFor: 'actions - class list' stamp: 'md 4/23/2004 14:32'!browseFullProtocol	"Open up a protocol-category browser on the value of the receiver's current selection.  If in mvc, an old-style protocol browser is opened instead."	self cNotYet.	"| objectToRepresent |	Smalltalk isMorphic ifFalse: [^ self spawnProtocol].	objectToRepresent _ self selectionIndex == 0 ifTrue: [object] ifFalse: [self selection].	InstanceBrowser new openOnObject: objectToRepresent inWorld: ActiveWorld showingSelector: nil"! !!CCodeHolder methodsFor: 'actions - class list' stamp: 'md 4/23/2004 14:43'!browseUnusedMethods	| classes unsent messageList cls |	(cls _ self selectedClass)		ifNil: [^ self].	classes _ Array with: cls with: cls class.	unsent _ Set new.	classes		do: [:c | unsent addAll: c selectors].	unsent _ self systemNavigation allUnSentMessagesIn: unsent.	messageList _ OrderedCollection new.	classes		do: [:c | (c selectors				select: [:s | unsent includes: s]) asSortedCollection				do: [:sel | messageList add: c name , ' ' , sel]].	CMessageSet openMessageList: messageList name: 'Unsent Methods in ' , cls name.	"self systemNavigation browseMessageList: messageList name: 'Unsent Methods in ' , cls name"! !!CCodeHolder methodsFor: 'actions - class list' stamp: 'md 4/22/2004 17:12'!classHierarchy	"Create and schedule a class list browser on the receiver's hierarchy."	self cNotYet.	"Utilities spawnHierarchyForClass: self selectedClassOrMetaClass 		selector: self selectedMessageName"! !!CCodeHolder methodsFor: 'actions - class list' stamp: 'md 4/23/2004 15:04'!inspectInstances	"Inspect all instances of the selected class."	| myClass |	(myClass _ self selectedClassOrMetaClass) ifNotNil:		[myClass theNonMetaClass inspectAllInstances]. ! !!CCodeHolder methodsFor: 'actions - class list' stamp: 'md 4/23/2004 15:04'!inspectSubInstances	"Inspect all instances of the selected class and all its subclasses"	| aClass |	(aClass _ self selectedClassOrMetaClass) ifNotNil: [		aClass theNonMetaClass inspectSubInstances].! !!CCodeHolder methodsFor: 'actions - class list' stamp: 'md 4/23/2004 15:02'!makeSampleInstance	| aClass nonMetaClass anInstance |	(aClass _ self selectedClassOrMetaClass) ifNil: [^ self].	nonMetaClass _ aClass theNonMetaClass.	anInstance _ self sampleInstanceOfSelectedClass.	(anInstance isNil and: [nonMetaClass ~~ UndefinedObject]) ifTrue: 		[^ self inform: 'Sorry, cannot make an instance of ', nonMetaClass name].	anInstance inspectWithLabel: 'An instance of ', nonMetaClass name.! !!CCodeHolder methodsFor: 'actions - class list' stamp: 'md 4/23/2004 14:36'!printOutClass	"Print a description of the selected class onto a file whose name is the 	category name followed by .html."	Cursor write showWhile:		[self selectedClass fileOutAsHtml: true]! !!CCodeHolder methodsFor: 'actions - class list' stamp: 'md 4/23/2004 14:28'!removeClass	"Remove the selected class from the system, at interactive user request.  Make certain the user really wants to do this, since it is not reversible.  Answer true if removal actually happened."	| message  className classToRemove |	self okToChange ifFalse: [^ false].	classToRemove _ self selectedClassOrMetaClass ifNil: [self flash. ^ false].	classToRemove _ classToRemove theNonMetaClass.	className _ classToRemove name.	message _ 'Are you certain that you want to REMOVE	', className, 'from the system?'.	(CDialog confirm: message) ifFalse:[^false].	classToRemove subclasses size > 0 ifTrue: [		CDialog inform:  className, ' has subclasses!!It cannot be removed'.		^false].	classToRemove removeFromSystem.	self selectedClassName: nil.	self onSelectedSystemCategoryChanged.	^true! !!CCodeHolder methodsFor: 'actions - class list' stamp: 'md 4/23/2004 15:03'!sampleInstanceOfSelectedClass	| aClass |	"Return a sample instance of the class currently being pointed at"	(aClass _ self selectedClassOrMetaClass) ifNil: [^ nil].	^ aClass theNonMetaClass initializedInstance! !!CCodeHolder methodsFor: 'actions - class list' stamp: 'md 4/23/2004 15:40'!showUnreferencedClassVars	"Search for all class variables known to the selected class, and put up a 	list of those that have no references anywhere in the system. The 	search includes superclasses, so that you don't need to navigate your 	way to the class that defines each class variable in order to determine 	whether it is unreferenced"	| cls aList aReport varMenu |	(cls _ self selectedClass)		ifNil: [^ self].	aList _ self systemNavigation allUnreferencedClassVariablesOf: cls.	aList size == 0		ifTrue: [^ self inform: 'There are no unreferencedclass variables in' , cls name].	aReport _ String				streamContents: [:aStream | 					aStream nextPutAll: 'Unreferenced class variable(s) in ' , cls name;						 cr.					aList						do: [:el | aStream tab; nextPutAll: el; cr]].	Transcript cr; show: aReport.	"(SelectionMenu labels: aList selections: aList)		startUpWithCaption: 'Unreferencedclass variables in ' , cls name"	varMenu := CMenu new.	varMenu label:  'Unreferenced class variables in ' , cls name.	varMenu chooseFrom: (aList collect: [:each | Array with: each with: each]).! !!CCodeHolder methodsFor: 'actions - class list' stamp: 'md 4/23/2004 15:41'!showUnreferencedInstVars	"Search for all instance variables known to the selected class, and put up a list of those that have no references anywhere in the system.  The search includes superclasses, so that you don't need to navigate your way to the class that defines each inst variable in order to determine whether it is unreferenced"	| cls aList aReport varMenu |	(cls _ self selectedClassOrMetaClass) ifNil: [^ self].	aList _ cls allUnreferencedInstanceVariables.	aList size == 0 ifTrue: [^ self inform: 'There are no unreferencedinstance variables in', cls name].	aReport _ String streamContents:		[:aStream |			aStream nextPutAll: 'Unreferenced instance variable(s) in ', cls name; cr.			aList do: [:el | aStream tab; nextPutAll: el; cr]].	Transcript cr; show: aReport.	"(SelectionMenu labels: aList selections: aList) startUpWithCaption: 'Unreferencedinstance variables in ', cls name"		varMenu := CMenu new.	varMenu label:  'Unreferenced instance variables in ' , cls name.	varMenu chooseFrom: (aList collect: [:each | Array with: each with: each]).! !!CCodeHolder methodsFor: 'actions - class list' stamp: 'md 4/22/2004 17:12'!spawnHierarchy	"Create and schedule a new hierarchy browser on the currently selected class or meta."	self cNotYet.! !!CCodeHolder methodsFor: 'as yet unclassified' stamp: 'md 4/22/2004 17:24'!cNotYet	(CDialog confirm: 'not yet implemented. Edit?') ifTrue: [		| class selector browser |		class := thisContext sender  mclass.		selector := thisContext sender  selector.		browser := CClassBrowser new.		browser selectClass: class selector: selector.		browser open.	].	! !!CChangeSorter methodsFor: 'TODO' stamp: 'md 4/25/2004 12:31'!openAsMorphIn: awindow rect: rect	"Add a set of change sorter views to the given top view offset by the given amount. To create a single change sorter, call this once with an offset of 0@0. To create a dual change sorter, call it twice with offsets of 0@0 and 0.5@0.""	| csListHeight msgListHeight csMsgListHeight |	contents _ ''.	csListHeight _ 0.25.	msgListHeight _ 0.25.	csMsgListHeight _ csListHeight + msgListHeight.	self addDependent: window.			window addMorph: ((PluggableListMorphByItem on: self				list: #changeSetList				selected: #currentCngSet				changeSelected: #showChangeSetNamed:				menu: #changeSetMenu:shifted:				keystroke: #changeSetListKey:from:)			autoDeselect: false)		frame: (((0@0 extent: 0.5@csListHeight)			scaleBy: rect extent) translateBy: rect origin).	window addMorph: (PluggableListMorphByItem on: self				list: #classList				selected: #currentClassName				changeSelected: #currentClassName:				menu: #classListMenu:shifted:				keystroke: #classListKey:from:)		frame: (((0.5@0 extent: 0.5@csListHeight)			scaleBy: rect extent) translateBy: rect origin).	window addMorph: (PluggableListMorphByItem on: self				list: #messageList				selected: #currentSelector				changeSelected: #currentSelector:				menu: #messageMenu:shifted:				keystroke: #messageListKey:from:)		frame: (((0@csListHeight extent: 1@msgListHeight)			scaleBy: rect extent) translateBy: rect origin).	 self addLowerPanesTo: window		at: (((0@csMsgListHeight corner: 1@1) scaleBy: rect extent) translateBy: rect origin)		with: nil."! !!CChangeSorter methodsFor: 'TODO' stamp: 'md 4/25/2004 12:32'!openView: topView offsetBy: offset	"Add a set of change sorter views to the given top view offset by the given amount. To create a single change sorter, call this once with an offset of 0@0. To create a dual change sorter, call it twice with offsets of 0@0 and 360@0.""	| classView messageView codeView cngSetListView basePane annoPane annoHeight |	contents _ ''.	annoHeight _ 20.	self addDependent: topView. 	cngSetListView _ PluggableListViewByItem on: self		list: #changeSetList		selected: #currentCngSet		changeSelected: #showChangeSetNamed:		menu: #changeSetMenu:shifted:		keystroke: #changeSetListKey:from:.	cngSetListView window: ((0@0 extent: 180@100) translateBy: offset).	topView addSubView: cngSetListView.	classView _ PluggableListViewByItem on: self		list: #classList		selected: #currentClassName		changeSelected: #currentClassName:		menu: #classListMenu:shifted:		keystroke: #classListKey:from:.	classView window: ((0@0 extent: 180@100) translateBy: offset).	topView addSubView: classView toRightOf: cngSetListView.	messageView _ PluggableListViewByItem on: self		list: #messageList		selected: #currentSelector		changeSelected: #currentSelector:		menu: #messageMenu:shifted:		keystroke: #messageListKey:from:.	messageView menuTitleSelector: #messageListSelectorTitle.	messageView window: ((0@0 extent: 360@100) translateBy: offset).	topView addSubView: messageView below: cngSetListView.	 self wantsAnnotationPane		ifFalse:			[basePane _ messageView]		ifTrue:			[annoPane _ PluggableTextView on: self				text: #annotation				accept: nil				readSelection: nil				menu: nil.			annoPane window: ((0@0 extent: 360@annoHeight) translateBy: offset).			topView addSubView: annoPane below: messageView.			basePane _ annoPane].	codeView _ PluggableTextView on: self 		text: #contents		accept: #contents:notifying:		readSelection: #contentsSelection		menu: #codePaneMenu:shifted:.	codeView window: ((0 @ 0 extent: 360 @ 180) translateBy: offset).	topView addSubView: codeView below: basePane."! !!CChangeSorter methodsFor: 'accessing' stamp: 'md 4/6/2004 16:49'!changeSet	^ myChangeSet! !!CChangeSorter methodsFor: 'accessing' stamp: 'ar 6/2/2004 16:35'!changeSetCategory	"Answer the changeSetCategory of the receiver"	<bewareOf: #changeSetCategoryChanged>	^self propertyValueAt: #changeSetCategory! !!CChangeSorter methodsFor: 'accessing' stamp: 'ar 6/2/2004 16:35'!changeSetCategory: aValue	"Modify the receiver's changeSetCategory"	^self propertyValueAt: #changeSetCategory put: aValue with: #changeSetCategoryChanged! !!CChangeSorter methodsFor: 'accessing' stamp: 'md 4/6/2004 16:49'!changeSetCurrentlyDisplayed	^ myChangeSet! !!CChangeSorter methodsFor: 'accessing' stamp: 'md 4/6/2004 16:49'!label	^ self labelString! !!CChangeSorter methodsFor: 'accessing' stamp: 'md 4/25/2004 13:56'!labelString	"The label for my entire window.  The large button that displays my name is gotten via mainButtonName"	^ String streamContents:		[:aStream |			aStream nextPutAll: (ChangeSet current == self selectedChangeSet				ifTrue: ['Changes go to "', selectedChangeSetName, '"']				ifFalse: ['ChangeSet: ', selectedChangeSetName]).		(self changeSetCategory categoryName ~~ #All)			ifTrue:				[aStream nextPutAll:  ' - ', self parenthesizedCategoryName]]! !!CChangeSorter methodsFor: 'accessing' stamp: 'ar 6/2/2004 16:34'!myChangeSet	"Answer the myChangeSet of the receiver"	<bewareOf: #myChangeSetChanged>	^self propertyValueAt: #myChangeSet! !!CChangeSorter methodsFor: 'accessing' stamp: 'ar 6/2/2004 16:34'!myChangeSet: aValue	"Modify the receiver's myChangeSet"	^self propertyValueAt: #myChangeSet put: aValue with: #myChangeSetChanged! !!CChangeSorter methodsFor: 'accessing' stamp: 'ar 6/2/2004 16:34'!parent	"Answer the parent of the receiver"	<bewareOf: #parentChanged>	^self propertyValueAt: #parent! !!CChangeSorter methodsFor: 'accessing' stamp: 'ar 6/2/2004 16:34'!parent: aValue	"Modify the receiver's parent"	^self propertyValueAt: #parent put: aValue with: #parentChanged! !!CChangeSorter methodsFor: 'accessing' stamp: 'md 4/6/2004 16:49'!parenthesizedCategoryName	"Answer my category name in parentheses"	^ ' (', self changeSetCategory categoryName, ')'! !!CChangeSorter methodsFor: 'accessing' stamp: 'ar 6/2/2004 16:34'!priorChangeSetList	"Answer the priorChangeSetList of the receiver"	<bewareOf: #priorChangeSetListChanged>	^self propertyValueAt: #priorChangeSetList! !!CChangeSorter methodsFor: 'accessing' stamp: 'ar 6/2/2004 16:34'!priorChangeSetList: aValue	"Modify the receiver's priorChangeSetList"	^self propertyValueAt: #priorChangeSetList put: aValue with: #priorChangeSetListChanged! !!CChangeSorter methodsFor: 'accessing' stamp: 'md 4/25/2004 12:55'!selectedChangeSet	^ CChangeSorter changeSetNamed: selectedChangeSetName! !!CChangeSorter methodsFor: 'annotation' stamp: 'md 4/6/2004 16:49'!addPriorVersionsCountForSelector: aSelector ofClass: aClass to: aStream	"Add an annotation detailing the prior versions count.  Specially handled here for the case of a selector no longer in the system, whose prior version is pointed to by the lost-method pointer in the change held on to by the changeset"	(aClass includesSelector: aSelector) ifTrue:		[^ super addPriorVersionsCountForSelector: aSelector ofClass: aClass to: aStream].	aStream nextPutAll:		((myChangeSet methodInfoFromRemoval: {aClass name. aSelector})			ifNil:				['no prior versions']			ifNotNil:				['version(s) retrievable here']), self annotationSeparator! !!CChangeSorter methodsFor: 'changeSet menu' stamp: 'md 4/25/2004 13:17'!addPreamble	self selectedChangeSet assurePreambleExists.	self okToChange ifTrue:		[self selectedChangeSetName: myChangeSet name]! !!CChangeSorter methodsFor: 'changeSet menu' stamp: 'md 4/23/2004 17:49'!addToCategoryOpposite	"Add the current change set to the category viewed on the opposite side, if it's of the sort to accept things like that"	| categoryOpposite |	categoryOpposite _ (parent other: self) changeSetCategory.	categoryOpposite acceptsManualAdditions		ifTrue:			[categoryOpposite addChangeSet: myChangeSet.			categoryOpposite reconstituteList.			self update]		ifFalse:			[CDialog inform: 'sorry, this command only makes senseif the category showing on the oppositeside is a static category whosemembers are manually maintained']! !!CChangeSorter methodsFor: 'changeSet menu' stamp: 'md 4/23/2004 17:20'!browseChangeSet	"Open a message list browser on the new and changed methods in the current change set"	CChangedMessageSet openFor: myChangeSet! !!CChangeSorter methodsFor: 'changeSet menu' stamp: 'md 4/25/2004 16:21'!browseMethodConflicts	"Check to see if any other change set also holds changes to any methods in the selected change set; if so, open a browser on all such."	| aList |	aList _ myChangeSet 		messageListForChangesWhich: [ :aClass :aSelector |			(CChangeSorter allChangeSetsWithClass: aClass selector: aSelector) size > 1		]		ifNone: [^ CDialog inform: 'No other change set has changesfor any method in this change set.'].		CMessageSet 		openMessageList: aList 		name: 'Methods in "', myChangeSet name, '" that are also in other change sets (', aList size printString, ')'	! !!CChangeSorter methodsFor: 'changeSet menu' stamp: 'md 4/20/2004 16:21'!categorySubmenu: aMenu	"Fill aMenu with less-frequently-needed category items"		aMenu label: 'Change set category'.	aMenu addList: #(		('make a new category...' makeNewCategory)		('make a new category with class...' makeNewCategoryShowingClassChanges)		('rename this category' renameCategory)		('remove this category' removeCategory)		('show categories of this changeset' showCategoriesOfChangeSet)	-) target: self..	parent ifNotNil:		[aMenu addList: #(			('add change set to category opposite' addToCategoryOpposite)) target: self. ].	aMenu addList: #(		('remove change set from this category' removeFromCategory)		-		('file out category''s change sets' fileOutAllChangeSets)		('set recent-updates marker' setRecentUpdatesMarker)		('fill aggregate change set' fillAggregateChangeSet) ) target: self.	^ aMenu! !!CChangeSorter methodsFor: 'changeSet menu' stamp: 'md 4/6/2004 16:49'!changeSetList	"Answer a list of ChangeSet names to be shown in the change sorter."	^ self changeSetCategory changeSetList! !!CChangeSorter methodsFor: 'changeSet menu' stamp: 'md 4/6/2004 16:49'!changeSetListKey: aChar from: view	"Respond to a Command key.  I am a model with a listView that has a list of changeSets."	aChar == $b ifTrue: [^ self browseChangeSet].	aChar == $B ifTrue: [^ self openChangeSetBrowser].	aChar == $c ifTrue: [^ self copyAllToOther].	aChar == $D ifTrue: [^ self toggleDiffing]. 	aChar == $f ifTrue: [^ self findCngSet].	aChar == $m ifTrue: [^ self newCurrent].	aChar == $n ifTrue: [^ self newSet].	aChar == $o ifTrue: [^ self fileOut].	aChar == $p ifTrue: [^ self addPreamble].	aChar == $r ifTrue: [^ self rename].	aChar == $s ifTrue: [^ self chooseChangeSetCategory].	aChar == $x ifTrue: [^ self remove].	aChar == $- ifTrue: [^ self subtractOtherSide].	^ self messageListKey: aChar from: view! !!CChangeSorter methodsFor: 'changeSet menu' stamp: 'md 4/20/2004 16:20'!changeSetListMenu	"Set up aMenu to hold commands for the change-set-list pane.  This could be for a single or double changeSorter"	| aMenu subMenu |	aMenu := CMenu new.	aMenu label: 'Change Set'.	aMenu add: 'make changes go to me (m)' target: self action: #newCurrent.	aMenu addSeparator.	aMenu add: 'new change set... (n)'  target: self action: #newSet.	aMenu add: 'find...(f)'  target: self action: #findCngSet.	aMenu add: 'show category... (s)'  target: self action:  #chooseChangeSetCategory.	aMenu add: 'select change set...'  target: self action: #chooseCngSet.	aMenu addSeparator.	aMenu add: 'rename change set (r)'  target: self action: #rename.	aMenu add: 'file out (o)'  target: self action: #fileOut.	aMenu add: 'mail to list'  target: self action: #mailOut.	aMenu add: 'browse methods (b)'  target: self action: #browseChangeSet.	aMenu add: 'browse change set (B)'  target: self action: #openChangeSetBrowser.	aMenu addSeparator.	parent		ifNotNil: 			[aMenu add: 'copy all to other side (c)'  target: self action: #copyAllToOther.			aMenu add: 'submerge into other side'  target: self action: #submergeIntoOtherSide.			aMenu add: 'subtract other side (-)'  target: self action: #subtractOtherSide.			aMenu addSeparator].	myChangeSet hasPreamble		ifTrue: 			[aMenu add: 'edit preamble (p)'  target: self action: #addPreamble.			aMenu add: 'remove preamble'  target: self action: #removePreamble]		ifFalse: [aMenu add: 'add preamble (p)'  target: self action: #addPreamble].	myChangeSet hasPostscript		ifTrue: 			[aMenu add: 'edit postscript...'  target: self action: #editPostscript.			aMenu add: 'remove postscript'  target: self action: #removePostscript]		ifFalse: [aMenu add: 'add postscript...'  target: self action: #editPostscript].	aMenu addSeparator.	aMenu add: 'category functions...' subMenu: (subMenu := CMenu new).	self categorySubmenu: subMenu.	aMenu addSeparator.	aMenu add: 'destroy change set (x)'  target: self action: #remove.	aMenu addSeparator.	aMenu add: 'more...' subMenu: (subMenu := CMenu new).	self shiftedChangeSetMenu: subMenu.	^ aMenu.! !!CChangeSorter methodsFor: 'changeSet menu' stamp: 'md 4/6/2004 16:49'!checkForAlienAuthorship	"Open a message list browser on all uncommented methods in the current change set that have alien authorship"	myChangeSet checkForAlienAuthorship! !!CChangeSorter methodsFor: 'changeSet menu' stamp: 'md 4/6/2004 16:49'!checkForAnyAlienAuthorship	"Open a message list browser on all uncommented methods in the current change set that have alien authorship, even historically"	myChangeSet checkForAnyAlienAuthorship! !!CChangeSorter methodsFor: 'changeSet menu' stamp: 'md 4/6/2004 16:49'!checkForUnclassifiedMethods	"Open a message list browser on all methods in the current change set that have not been categorized"	myChangeSet checkForUnclassifiedMethods! !!CChangeSorter methodsFor: 'changeSet menu' stamp: 'md 4/6/2004 16:49'!checkForUncommentedClasses	"Open a class list browser on classes in the change set that lack class comments"	myChangeSet checkForUncommentedClasses! !!CChangeSorter methodsFor: 'changeSet menu' stamp: 'md 4/6/2004 16:49'!checkForUncommentedMethods	"Open a message list browser on all uncommented methods in the current change set"	myChangeSet checkForUncommentedMethods! !!CChangeSorter methodsFor: 'changeSet menu' stamp: 'md 4/6/2004 16:49'!checkForUnsentMessages	"Open a message list browser on all unsent messages in the current change set"	myChangeSet checkForUnsentMessages! !!CChangeSorter methodsFor: 'changeSet menu' stamp: 'md 4/23/2004 17:50'!checkThatSidesDiffer: escapeBlock	"If the change sets on both sides of the dual sorter are the same, put up an error message and escape via escapeBlock, else proceed happily"	(myChangeSet == (parent other: self) changeSet)		ifTrue:			[CDialog inform: 'This command requires that thechange sets selected on the twosides of the change sorter *not*be the same.'.			^ escapeBlock value]! !!CChangeSorter methodsFor: 'changeSet menu' stamp: 'md 4/25/2004 15:36'!chooseChangeSetCategory	"Present the user with a list of change-set-categories and let her choose one.  In this morphic variant, we include balloon help"	|  aMenu item |		self okToChange ifFalse: [^ self].	aMenu _ CMenu new.	aMenu label: 'Choose the category of\change sets to show in\this Change Sorter' withCRs.	ChangeSetCategories elementsInOrder do:		[:aCategory |			item := aMenu 						add: aCategory categoryName 						target: self 						action: #showChangeSetCategory: 						argument: aCategory.			item checked: aCategory == changeSetCategory].	aMenu run.! !!CChangeSorter methodsFor: 'changeSet menu' stamp: 'md 4/25/2004 15:41'!chooseCngSet	"Present the user with an alphabetical list of change set names, and let her choose one"	| changeSetsSortedAlphabetically chosen |	self okToChange ifFalse: [^ self].	changeSetsSortedAlphabetically _ self changeSetList asSortedCollection:		[:a :b | a asLowercase withoutLeadingDigits < b asLowercase withoutLeadingDigits].		chosen _ (CMenu new chooseFromValues: changeSetsSortedAlphabetically).	chosen ifNil: [^ self].	self showChangeSet: (ChangeSorter changeSetNamed: chosen)! !!CChangeSorter methodsFor: 'changeSet menu' stamp: 'md 4/25/2004 16:23'!clearChangeSet	"Clear out the current change set, after getting a confirmation."	| message |	self okToChange ifFalse: [^ self].	myChangeSet isEmpty ifFalse:		[message _ 'Are you certain that you want to\forget all the changes in this set?' withCRs.		(CDialog confirm: message) ifFalse: [^ self]].	myChangeSet clear.	self changed.! !!CChangeSorter methodsFor: 'changeSet menu' stamp: 'md 4/25/2004 16:23'!copyAllToOther	"Copy this entire change set into the one on the other side"	| companionSorter |	self checkThatSidesDiffer: [^ self].	(companionSorter _ parent other: self) changeSetCurrentlyDisplayed assimilateAllChangesFoundIn: myChangeSet.	companionSorter changed.! !!CChangeSorter methodsFor: 'changeSet menu' stamp: 'md 4/6/2004 16:49'!currentCngSet	^ myChangeSet name! !!CChangeSorter methodsFor: 'changeSet menu' stamp: 'md 4/6/2004 16:49'!editPostscript	"Allow the user to edit the receiver's change-set's postscript -- in a separate window"	myChangeSet editPostscript! !!CChangeSorter methodsFor: 'changeSet menu' stamp: 'md 4/6/2004 16:49'!editPreamble	"Allow the user to edit the receiver's change-set's preamble -- in a separate window."	myChangeSet editPreamble! !!CChangeSorter methodsFor: 'changeSet menu' stamp: 'md 4/25/2004 16:23'!expungeUniclasses	"remove all memory of uniclasses in the receiver"	self okToChange ifFalse: [^ self].	myChangeSet expungeUniclasses.	self changed.! !!CChangeSorter methodsFor: 'changeSet menu' stamp: 'md 4/25/2004 16:24'!fileIntoNewChangeSet	"Obtain a file designation from the user, and file its contents into a new change set whose name is a function of the filename.  Show the new set and leave the current changeSet unaltered."	| aFileName  aNewChangeSet |	self okToChange ifFalse: [^ self].	aFileName _ CDialog request: 'Name of file to be imported: '.	aFileName size == 0 ifTrue: [^ self].	(FileDirectory default fileExists: aFileName) ifFalse:		[^ CDialog inform: 'Sorry -- cannot find that file'].	aNewChangeSet _ self class 			newChangesFromStream: (FileStream readOnlyFileNamed: aFileName) 			named: aFileName.	aNewChangeSet ifNotNil: [self showChangeSet: aNewChangeSet]! !!CChangeSorter methodsFor: 'changeSet menu' stamp: 'md 4/25/2004 16:24'!fileOut	"File out the current change set."	myChangeSet fileOut.! !!CChangeSorter methodsFor: 'changeSet menu' stamp: 'md 4/6/2004 16:49'!fileOutAllChangeSets	"File out all nonempty change sets in the current category, probably"	self changeSetCategory fileOutAllChangeSets! !!CChangeSorter methodsFor: 'changeSet menu' stamp: 'md 4/6/2004 16:49'!fillAggregateChangeSet	"Create a change-set named Aggregate and pour into it all the changes in all the change-sets of the currently-selected category"	self changeSetCategory fillAggregateChangeSet! !!CChangeSorter methodsFor: 'changeSet menu' stamp: 'md 4/25/2004 15:01'!findCngSet 	"Search for a changeSet by name.  Pop up a menu of all changeSets whose name contains the string entered by the user.  If only one matches, then the pop-up menu is bypassed"	| pattern candidates nameList varMenu result |	self okToChange ifFalse: [^ self].	pattern _ CDialog request: 'ChangeSet name or fragment?'.	pattern isEmpty ifTrue: [^ self].	nameList _ self changeSetList asSet.	candidates _ AllChangeSets select:			[:c | (nameList includes: c name) and: 				[c name includesSubstring: pattern caseSensitive: false]].	candidates size = 0 ifTrue: [^ self beep].	candidates size = 1 ifTrue:		[^ self showChangeSet: candidates first].	candidates := candidates collect: [:each | Array with: each name with: each].	varMenu := CMenu new.	result := varMenu chooseFrom: candidates.	self showChangeSet: result.! !!CChangeSorter methodsFor: 'changeSet menu' stamp: 'md 4/6/2004 16:49'!goToChangeSetsProject	"Transport the user to a project which bears the selected changeSet as its current changeSet"	| aProject |	(aProject _ myChangeSet correspondingProject) 		ifNotNil:			[aProject enter: false revert: false saveForRevert: false]		ifNil:			[self inform: 'Has no project']! !!CChangeSorter methodsFor: 'changeSet menu' stamp: 'md 4/6/2004 16:49'!inspectChangeSet	"Open a message list browser on the new and changed methods in the current change set"	myChangeSet inspectWithLabel: 'Change set: ', myChangeSet name! !!CChangeSorter methodsFor: 'changeSet menu' stamp: 'md 4/6/2004 16:49'!lookForSlips	"Open a message list browser on the new and changed methods in the current change set"	myChangeSet lookForSlips! !!CChangeSorter methodsFor: 'changeSet menu' stamp: 'md 4/23/2004 17:11'!mailOut	"Create a mail with a gzipped attachment holding out the current change 	set. "		self cNotYet.	"	myChangeSet mailOut.	parent modelWakeUp	"! !!CChangeSorter methodsFor: 'changeSet menu' stamp: 'md 4/6/2004 16:49'!mainButtonName	^ myChangeSet name! !!CChangeSorter methodsFor: 'changeSet menu' stamp: 'md 4/25/2004 16:25'!makeNewCategory	"Create a new, static change-set category, which will be populated entirely by change sets that have been manually placed in it"	| catName aCategory |	catName _ CDialog request: 'Please give the new category a name' initialAnswer: ''.	catName isEmptyOrNil ifTrue: [^ self].	catName _ catName asSymbol.	(ChangeSetCategories includesKey: catName) ifTrue:		[^ CDialog inform: 'Sorry, there is already a category of that name'].	aCategory _ StaticChangeSetCategory new categoryName: catName.	ChangeSetCategories elementAt: catName put: aCategory.	aCategory addChangeSet: myChangeSet.	self showChangeSetCategory: aCategory! !!CChangeSorter methodsFor: 'changeSet menu' stamp: 'md 4/25/2004 16:25'!makeNewCategoryShowingClassChanges	"Create a new, static change-set category, which will be populated entirely by change sets that have been manually placed in it"	| catName aCategory clsName |	clsName _ self selectedClass ifNotNil: [self selectedClass name ] ifNil: [''].	clsName _ CDialog request: 'Which class?' initialAnswer: clsName.	clsName isEmptyOrNil ifTrue: [^ self].	catName _ ('Changes to ', clsName) asSymbol.	(ChangeSetCategories includesKey: catName) ifTrue:		[^ CDialog inform: 'Sorry, there is already a category of that name'].	aCategory _ ChangeSetCategoryWithParameters new categoryName: catName.	aCategory membershipSelector: #changeSet:containsClass: ; parameters: { clsName }.	ChangeSetCategories elementAt: catName put: aCategory.	aCategory reconstituteList.	self showChangeSetCategory: aCategory! !!CChangeSorter methodsFor: 'changeSet menu' stamp: 'md 4/25/2004 16:25'!methodConflictsWithOppositeCategory	"Check to see if ANY change set on the other side shares any methods with the selected change set; if so, open a browser on all such."	| aList otherCategory |	otherCategory _ (parent other: self) changeSetCategory.	aList _ myChangeSet 		messageListForChangesWhich: [ :aClass :aSelector |			aClass notNil and: 				[otherCategory 					hasChangeForClassName: aClass name 					selector: aSelector 					otherThanIn: myChangeSet]		]		ifNone: [^ CDialog inform: 'There are no methods that appear both inthis change set and in any change set(other than this one) on the other side.'].		CMessageSet 		openMessageList: aList 		name: 'Methods in "', myChangeSet name, '" also in some other change set in category ', otherCategory categoryName,' (', aList size printString, ')'	! !!CChangeSorter methodsFor: 'changeSet menu' stamp: 'md 4/25/2004 16:25'!methodConflictsWithOtherSide	"Check to see if the change set on the other side shares any methods with the selected change set; if so, open a browser on all such."	| aList other |	self checkThatSidesDiffer: [^ self].	other _ (parent other: self) changeSet.	aList _ myChangeSet 		messageListForChangesWhich: [ :aClass :aSelector |			aClass notNil and: [(other methodChangesAtClass: aClass name) includesKey: aSelector]		]		ifNone:  [^ CDialog inform: 'There are no methods that appearboth in this change set andin the one on the other side.'].		CMessageSet 		openMessageList: aList 		name: 'Methods in "', myChangeSet name, '" that are also in ', other name,' (', aList size printString, ')'	! !!CChangeSorter methodsFor: 'changeSet menu' stamp: 'md 4/25/2004 16:26'!newCurrent	"make my change set be the current one that changes go into"	ChangeSet  newChanges: myChangeSet.	self update.  "Because list of changes in a category may thus have changed"	! !!CChangeSorter methodsFor: 'changeSet menu' stamp: 'md 4/25/2004 14:02'!newSet	"Create a new changeSet and show it., making it the current one.  Reject name if already in use."	| aSet |	self okToChange ifFalse: [^ self].	aSet _ self class newChangeSet.	aSet ifNotNil:		[		self changeSetCategory acceptsManualAdditions ifTrue:			[changeSetCategory addChangeSet: aSet].		self update.		(changeSetCategory includesChangeSet: aSet) ifTrue:			[self showChangeSet: aSet].		]! !!CChangeSorter methodsFor: 'changeSet menu' stamp: 'md 4/23/2004 17:17'!openChangeSetBrowser	"Open a ChangeSet browser on the current change set"	self browseChangeSet ! !!CChangeSorter methodsFor: 'changeSet menu' stamp: 'md 4/25/2004 16:02'!promoteToTopChangeSet	self class promoteToTop: myChangeSet.	self showChangeSet: ChangeSet current.! !!CChangeSorter methodsFor: 'changeSet menu' stamp: 'md 4/6/2004 16:49'!remove	"Completely destroy my change set.  Check if it's OK first"	self okToChange ifFalse: [^ self].	self removePrompting: true.	self update! !!CChangeSorter methodsFor: 'changeSet menu' stamp: 'md 4/25/2004 16:27'!removeCategory	"Remove the current category"	| itsName |	self changeSetCategory acceptsManualAdditions ifFalse:		[^ CDialog inform: 'sorry, you can only remove manually-added categories.'].	(CDialog confirm: 'Really remove the change-set-categorynamed ', (itsName _ changeSetCategory categoryName), '?') ifFalse: [^ self].	ChangeSetCategories removeElementAt: itsName.	self setDefaultChangeSetCategory.	self update! !!CChangeSorter methodsFor: 'changeSet menu' stamp: 'md 4/25/2004 16:27'!removeFromCategory	"Add the current change set to the category viewed on the opposite side, if it's of the sort to accept things like that"	| aCategory |	(aCategory _ self changeSetCategory) acceptsManualAdditions		ifTrue:			[aCategory removeElementAt: myChangeSet name.			aCategory reconstituteList.			self update]		ifFalse:			[CDialog inform: 'sorry, this command only makessense for static categories whosemembers are manually maintained']! !!CChangeSorter methodsFor: 'changeSet menu' stamp: 'md 4/25/2004 15:43'!removePostscript	myChangeSet removePostscript.	self showChangeSet: myChangeSet! !!CChangeSorter methodsFor: 'changeSet menu' stamp: 'md 4/6/2004 16:49'!removePreamble	myChangeSet removePreamble.	self showChangeSet: myChangeSet! !!CChangeSorter methodsFor: 'changeSet menu' stamp: 'md 4/25/2004 16:28'!removePrompting: doPrompt	"Completely destroy my change set.  Check if it's OK first, and if doPrompt is true, get the user to confirm his intentions first."	| message aName changeSetNumber msg |	aName _ myChangeSet name.	myChangeSet okayToRemove ifFalse: [^ self]. "forms current changes for some project"	(myChangeSet isEmpty or: [doPrompt not]) ifFalse:		[message _ 'Are you certain that you want to remove (destroy) the change setnamed  "', aName, '" ?'.		(CDialog confirm: message) ifFalse: [^ self]].	doPrompt ifTrue:		[msg _ myChangeSet hasPreamble			ifTrue:				[myChangeSet hasPostscript					ifTrue:						['a preamble and a postscript']					ifFalse:						['a preamble']]			ifFalse:				[myChangeSet hasPostscript					ifTrue:						['a postscript']					ifFalse:						['']].		msg isEmpty ifFalse:			[(CDialog confirm: 'Caution!!  This change set has', msg, ' which will belost if you destroy the change set.Do you really want to go ahead with this?') ifFalse: [^ self]]].	"Go ahead and remove the change set"	changeSetNumber _ myChangeSet name initialIntegerOrNil.	changeSetNumber ifNotNil: [SystemVersion current unregisterUpdate: changeSetNumber].	CChangeSorter removeChangeSet: myChangeSet.	self showChangeSet: ChangeSet current.! !!CChangeSorter methodsFor: 'changeSet menu' stamp: 'md 4/25/2004 16:28'!rename	"Store a new name string into the selected ChangeSet.  reject duplicate name; allow user to back out"	| newName |	newName _ CDialog request: 'New name for this change set'						initialAnswer: myChangeSet name.	(newName = myChangeSet name or: [newName size == 0]) ifTrue:			[^ self beep].	(self class changeSetNamed: newName) ifNotNil:			[^ Utilities inform: 'Sorry that name is already used'].	myChangeSet name: newName.	changeSetListPane contents: self changeSetList.	self update.! !!CChangeSorter methodsFor: 'changeSet menu' stamp: 'md 4/25/2004 16:28'!renameCategory	"Obtain a new name for the category and, if acceptable, apply it"	| catName oldName |	self changeSetCategory acceptsManualAdditions ifFalse:		[^ CDialog inform: 'sorry, you can only rename manually-added categories.'].	catName _ CDialog request: 'Please give the new category a name' initialAnswer:  (oldName _ changeSetCategory categoryName).	catName isEmptyOrNil ifTrue: [^ self].	(catName _ catName asSymbol) = oldName ifTrue: [^ CDialog inform: 'no change.'].	(ChangeSetCategories includesKey: catName) ifTrue:		[^ CDialog inform: 'Sorry, there is already a category of that name'].	changeSetCategory categoryName: catName.	ChangeSetCategories removeElementAt: oldName.	ChangeSetCategories elementAt: catName put: changeSetCategory.	self update! !!CChangeSorter methodsFor: 'changeSet menu' stamp: 'md 4/6/2004 16:49'!reorderChangeSets	"apply a standard reordering -- let the class handle this"	^ self class reorderChangeSets! !!CChangeSorter methodsFor: 'changeSet menu' stamp: 'md 4/25/2004 16:29'!setRecentUpdatesMarker	"Allow the user to change the recent-updates marker"	| result |	result _ CDialog request: ('Enter the lowest change-set numberthat you wish to consider "recent"?(note: highest change-set numberin this image at this time is ', self class highestNumberedChangeSet asString, ')') initialAnswer: self class recentUpdateMarker asString.	(result notNil and: [result startsWithDigit]) ifTrue:		[self class recentUpdateMarker: result asInteger].! !!CChangeSorter methodsFor: 'changeSet menu' stamp: 'md 4/25/2004 16:04'!shiftedChangeSetMenu: aMenu	"Set up aMenu to hold items relating to the change-set-list pane when the shift key is down"	"CONFLICTS SECTION"	aMenu add: 'conflicts with other change sets' target: self action: #browseMethodConflicts.	"aMenu balloonTextForLastItem: 'Browse all methods that occur both in this change set and in at least one other change set.'."	parent ifNotNil:		[aMenu add: 'conflicts with change set opposite' target: self action: #methodConflictsWithOtherSide.			"aMenu balloonTextForLastItem: 'Browse all methods that occur both in this change set and in the one on the opposite side of the change sorter.'."			aMenu add: 'conflicts with category opposite' target: self action: #methodConflictsWithOppositeCategory.			"aMenu balloonTextForLastItem: 'Browse all methods that occur both in this change set and in ANY change set in the category list on the opposite side of this change sorter, other of course than this change set itself.  (Caution -- this could be VERY slow)'"].	aMenu addSeparator.	"CHECKS SECTION"	aMenu add: 'check for slips' target: self action: #lookForSlips.	"aMenu balloonTextForLastItem: 'Check this change set for halts and references to Transcript.'."	aMenu add: 'check for unsent messages' target: self action: #checkForUnsentMessages.	"aMenu balloonTextForLastItem:'Check this change set for messages that are not sent anywhere in the system'."	aMenu add: 'check for uncommented methods' target: self action: #checkForUncommentedMethods.	"aMenu balloonTextForLastItem:'Check this change set for methods that do not have comments'."	aMenu add: 'check for uncommented classes' target: self action: #checkForUncommentedClasses.	"aMenu balloonTextForLastItem:'Check for classes with code in this changeset which lack class comments'."	Utilities authorInitialsPerSe isEmptyOrNil ifFalse:		[aMenu add: 'check for other authors' target: self action: #checkForAlienAuthorship.		"aMenu balloonTextForLastItem:'Check this change set for methods whose current authoring stamp does not start with "', Utilities authorInitials, '"'".	aMenu add: 'check for any other authors' target: self action: #checkForAnyAlienAuthorship.	"aMenu balloonTextForLastItem:'Check this change set for methods any of whose authoring stamps do not start with "', Utilities authorInitials, '"'"].	aMenu add: 'check for uncategorized methods' target: self action: #checkForUnclassifiedMethods.	"aMenu balloonTextForLastItem:'Check to see if any methods in the selected change set have not yet been assigned to a category.  If any are found, open a browser on them.'".	aMenu addSeparator.	aMenu add: 'inspect change set' target: self action: #inspectChangeSet.	"aMenu balloonTextForLastItem: 'Open an inspector on this change set. (There are some details in a change set which you don''t see in a change sorter.)'."	aMenu add: 'go to change set''s project' target: self action: #goToChangeSetsProject.	"aMenu balloonTextForLastItem: 'If this change set is currently associated with a Project, go to that project right now.'."	aMenu add: 'promote to top of list' target: self action: #promoteToTopChangeSet.	"aMenu balloonTextForLastItem:'Make this change set appear first in change-set lists in all change sorters.'."	aMenu add: 'trim history' target: self action: #trimHistory.	"aMenu balloonTextForLastItem: ' Drops any methods added and then removed, as well as renaming and reorganization of newly-added classes.  NOTE: can cause confusion if later filed in over an earlier version of these changes'."	aMenu add: 'clear this change set' target: self action: #clearChangeSet.	"aMenu balloonTextForLastItem: 'Reset this change set to a pristine state where it holds no information. CAUTION: this is destructive and irreversible!!'."	aMenu add: 'expunge uniclasses' target: self action: #expungeUniclasses.	"aMenu balloonTextForLastItem:'Remove from the change set all memory of uniclasses, e.g. classes added on behalf of etoys, fabrik, etc., whose classnames end with a digit.'."	aMenu add: 'uninstall this change set' target: self action: #uninstallChangeSet.	"aMenu balloonTextForLastItem: 'Attempt to uninstall this change set. CAUTION: this may not work completely and is irreversible!!'."	aMenu addSeparator.	aMenu add: 'reorder all change sets' action: #reorderChangeSets.	"aMenu balloonTextForLastItem:'Applies a standard reordering of all change-sets in the system -- at the bottom will come the sets that come with the release; next will come all the numbered updates; finally, at the top, will come all other change sets'."	^ aMenu! !!CChangeSorter methodsFor: 'changeSet menu' stamp: 'md 4/25/2004 15:37'!showCategoriesOfChangeSet	"Show a list of all the categories in which the selected change-set occurs at the moment.  Install the one the user chooses, if any."	| aMenu item |	aMenu _ CMenu new.	aMenu label: 'Categories whichcontain change set"', myChangeSet name, '"'.		ChangeSetCategories elementsInOrder do: [:aCategory |					(aCategory includesChangeSet: myChangeSet) ifTrue: [							item := aMenu 										add: aCategory categoryName										target: self 										action: #showChangeSetCategory: 										argument: aCategory.							item checked: aCategory == changeSetCategory].						].			aMenu run.! !!CChangeSorter methodsFor: 'changeSet menu' stamp: 'md 4/25/2004 15:30'!showChangeSetCategory: aChangeSetCategory	"Show the given change-set category"		changeSetCategory _ aChangeSetCategory.	self changed: #changeSetList.	(self changeSetList includes: myChangeSet name) ifFalse:			[self showChangeSet: (ChangeSorter changeSetNamed: self changeSetList first)].! !!CChangeSorter methodsFor: 'changeSet menu' stamp: 'md 4/25/2004 16:29'!submergeIntoOtherSide	"Copy the contents of the receiver to the other side, then remove the receiver -- all after checking that all is well."	| other message nextToView i |	self checkThatSidesDiffer: [^ self].	self okToChange ifFalse: [^ self].	other _ (parent other: self) changeSet.	other == myChangeSet ifTrue: [^ self inform: 'Both sides are the same!!'].	myChangeSet isEmpty ifTrue: [^ self inform: 'Nothing to copy.  To remove,simply choose "remove".'].	myChangeSet okayToRemove ifFalse: [^ self].	message _ 'Please confirm:  copy all changesin "', myChangeSet name, '" into "', other name, '"and then destroy the change setnamed "', myChangeSet name, '"?'. 	(CDialog confirm: message) ifFalse: [^ self].	(myChangeSet hasPreamble or: [myChangeSet hasPostscript]) ifTrue:		[(self confirm: 'Caution!!  This change set has a preamble ora postscript or both.  If you submerge it intothe other side, these will be lost.Do you really want to go ahead with this?') ifFalse: [^ self]].	other assimilateAllChangesFoundIn: myChangeSet.	nextToView _ ((AllChangeSets includes: myChangeSet)		and: [(i _ AllChangeSets indexOf: myChangeSet) < AllChangeSets size])		ifTrue: [AllChangeSets at: i+1]		ifFalse: [other].	self removePrompting: false.	self showChangeSet: nextToView.	! !!CChangeSorter methodsFor: 'changeSet menu' stamp: 'md 4/6/2004 16:49'!subtractOtherSide	"Subtract the changes found on the other side from the requesting side."	self checkThatSidesDiffer: [^ self].	myChangeSet forgetAllChangesFoundIn: ((parent other: self) changeSet).	self showChangeSet: myChangeSet! !!CChangeSorter methodsFor: 'changeSet menu' stamp: 'md 4/6/2004 16:49'!trimHistory	"Drop non-essential history (rename, reorg, method removals) from newly-added classes."	myChangeSet trimHistory! !!CChangeSorter methodsFor: 'changeSet menu' stamp: 'md 4/25/2004 16:29'!uninstallChangeSet	"Attempt to uninstall the current change set, after confirmation."	self okToChange ifFalse: [^ self].	(CDialog confirm: 'Uninstalling a changeSet is unreliable at best.It will only work if the changeSet consists only of singlechanges, additions and removals of methods, and ifno subsequent changes have been to any of them.No changes to classes will be undone.The changeSet will be cleared after uninstallation.Do you still wish to attempt to uninstall this changeSet?')	ifFalse: [^ self].	myChangeSet uninstall.	self update.! !!CChangeSorter methodsFor: 'changeSet menu' stamp: 'md 4/25/2004 14:23'!update	"recompute all of my panes" 	self showChangeSet: myChangeSet.	parent ifNotNil: [(parent other: self) update]! !!CChangeSorter methodsFor: 'class list' stamp: 'md 4/6/2004 16:49'!classList	"Computed.  View should try to preserve selections, even though index changes"	^ myChangeSet ifNotNil: [myChangeSet changedClassNames] ifNil: [OrderedCollection new]! !!CChangeSorter methodsFor: 'class list' stamp: 'md 4/6/2004 16:49'!classListKey: aChar from: view	"Respond to a Command key in the class-list pane."	aChar == $x ifTrue: [^ self removeClass].	aChar == $d ifTrue: [^ self forgetClass]. 	^ self messageListKey: aChar from: view "picks up b,h,p"! !!CChangeSorter methodsFor: 'class list' stamp: 'md 4/20/2004 16:28'!classListMenu	"Fill aMenu with items appropriate for the class list"	| aMenu subMenu |	aMenu := CMenu new.	aMenu label: 'class list'.		(parent notNil)		ifTrue: [aMenu addList: #( "These two only apply to dual change sorters"			('copy class chgs to other side'			copyClassToOther)				('move class chgs to other side'			moveClassToOther)) target: self].	aMenu addList: 		#(			-			('delete class from change set (d)'		forgetClass)			('remove class from system (x)'			removeClass)			-			('browse full (b)'						browseMethodFull)			('browse hierarchy (h)'					spawnHierarchy)			('browse protocol (p)'					browseFullProtocol)			-			('printOut'								printOutClass)			('fileOut'								fileOutClass)			-			('inst var refs...'						browseInstVarRefs)			('inst var defs...'						browseInstVarDefs)			('class var refs...'						browseClassVarRefs)			('class vars'								browseClassVariables)			('class refs (N)'							browseClassRefs)			-)			target: self.			aMenu add: 'more...' subMenu: (subMenu := CMenu new).				subMenu addList: #(			('unsent methods'						browseUnusedMethods)			('unreferenced inst vars'				showUnreferencedInstVars)			('unreferenced class vars'				showUnreferencedClassVars)			-			('sample instance'						makeSampleInstance)			('inspect instances'						inspectInstances)			('inspect subinstances'					inspectSubInstances)) target: self.	^ aMenu! !!CChangeSorter methodsFor: 'class list' stamp: 'md 4/25/2004 13:20'!copyClassToOther	"Place these changes in the other changeSet also"	| otherSorter otherChangeSet |	self checkThatSidesDiffer: [^ self].	self okToChange ifFalse: [^ self beep].	selectedClassName ifNil: [^ self beep].	otherSorter _ parent other: self.	otherChangeSet _ otherSorter changeSet.	otherChangeSet absorbClass: self selectedClassOrMetaClass name from: myChangeSet.	otherSorter showChangeSet: otherChangeSet.! !!CChangeSorter methodsFor: 'class list' stamp: 'md 4/25/2004 16:19'!fileOutClass	"this is a hack!!!! makes a new change set, called the class name, adds author initials to try to make a unique change set name, files it out and removes it. kfr 16 june 2000" 	| aSet |	"File out the selected class set."     aSet _ self class newChangeSet: selectedClassName.	aSet absorbClass: self selectedClassOrMetaClass name from: myChangeSet.	aSet fileOut.	self class removeChangeSet: aSet.	! !!CChangeSorter methodsFor: 'class list' stamp: 'md 5/3/2004 14:21'!forgetClass	"Remove all mention of this class from the changeSet"	self okToChange ifFalse: [^ self].	selectedClassName ifNotNil: [		self selectedChangeSet removeClassChanges: selectedClassName].	classListPane selection: classListPane prev.	self onSelectedChangeSetNameChanged.		! !!CChangeSorter methodsFor: 'class list' stamp: 'md 4/6/2004 16:49'!messageListKey: aChar from: view	"Respond to a Command key in the message-list pane."	aChar == $d ifTrue: [^ self forget].	super messageListKey: aChar from: view! !!CChangeSorter methodsFor: 'class list' stamp: 'md 4/25/2004 13:19'!moveClassToOther	"Place class changes in the other changeSet and remove them from this one"	self checkThatSidesDiffer: [^ self].	(self okToChange and: [selectedClassName notNil]) ifFalse: [^ self beep].	self copyClassToOther.	self forgetClass! !!CChangeSorter methodsFor: 'class list' stamp: 'md 4/23/2004 14:30'!removeClass	"Remove the selected class from the system, at interactive user request.  Make certain the user really wants to do this, since it is not reversible.  Answer true if removal actually happened."	| message  className classToRemove |	self okToChange ifFalse: [^ false].	classToRemove _ self selectedClassOrMetaClass ifNil: [self flash. ^ false].	classToRemove _ classToRemove theNonMetaClass.	className _ classToRemove name.	message _ 'Are you certain that you want to REMOVE	', className, 'from the system?'.	(CDialog confirm: message) ifFalse:[^false].	classToRemove subclasses size > 0 ifTrue: [		CDialog inform:  className, ' has subclasses!!It cannot be removed'.		^false].	classToRemove removeFromSystem.	self onUpdateClassListPane.	^true! !!CChangeSorter methodsFor: 'class list' stamp: 'md 4/25/2004 15:53'!selectedClass	"Answer the currently-selected class.  If there is no selection, or if the selection refers to a class no longer extant, return nil"	| c |	^ selectedClassName ifNotNil: [(c _ self selectedClassOrMetaClass)		ifNotNil: [c theNonMetaClass]]! !!CChangeSorter methodsFor: 'class list' stamp: 'md 4/25/2004 13:22'!selectedClassOrMetaClass	"Careful, the class may have been removed!!"	| cName |	selectedClassName ifNil: [^ nil].	(selectedClassName endsWith: ' class')		ifTrue: [cName _ (selectedClassName copyFrom: 1 to: selectedClassName size-6) asSymbol.				^ (Smalltalk at: cName ifAbsent: [^nil]) class]		ifFalse: [cName _ selectedClassName asSymbol.				^ Smalltalk at: cName ifAbsent: [nil]]! !!CChangeSorter methodsFor: 'code pane' stamp: 'md 4/25/2004 16:19'!contents: aString notifying: aController 	"Compile the code in aString. Notify aController of any syntax errors. 	Create an error if the category of the selected message is unknown. 	Answer false if the compilation fails. Otherwise, if the compilation 	created a new method, deselect the current selection. Then answer true."	| category selector class oldSelector |	(class _ self selectedClassOrMetaClass) ifNil:		[(myChangeSet preambleString == nil or: [aString size == 0]) ifTrue: [ ^ false].		(aString count: [:char | char == $"]) odd 			ifTrue: [self inform: 'unmatched double quotes in preamble']			ifFalse: [(Scanner new scanTokens: aString) size > 0 ifTrue: [				self inform: 'Part of the preamble is not within double-quotes.To put a double-quote inside a comment, type two double-quotes in a row.(Ignore this warning if you are including a doIt in the preamble.)']].		myChangeSet preambleString: aString.		^ true].	oldSelector _ self selectedMessageName.	category _ class organization categoryOfElement: oldSelector.	selector _ class compile: aString				classified: category				notifying: aController. 	selector ifNil: [^ false].	self update.	^ true! !!CChangeSorter methodsFor: 'code pane' stamp: 'md 4/25/2004 13:25'!setContents	"return the source code that shows in the bottom pane"	| sel class strm changeType contents contentsSymbol |	selectedClassName ifNil: [	myChangeSet ifNil: [^''].								^ myChangeSet preambleString ifNil: ['']].	class _ self selectedClassOrMetaClass.	(sel _ selectedMessage) == nil		ifFalse: [changeType _ (myChangeSet atSelector: (sel _ sel asSymbol) class: class).			changeType == #remove				ifTrue: [^   'Method has been removed (see versions)'].			changeType == #addedThenRemoved				ifTrue: [^  'Added then removed (see versions)'].			class ifNil: [^   'Method was added, but cannot be found!!'].			(class includesSelector: sel)				ifFalse: [^  'Method was added, but cannot be found!!'].			contents _ class sourceCodeAt: sel.			(#(prettyPrint colorPrint prettyDiffs altSyntax) includes: contents) ifTrue:				[contents _ class compilerClass new					format: contents in: class notifying: nil contentsSymbol: contentsSymbol].			"self showingAnyKindOfDiffs" false				ifTrue: [contents _ self diffFromPriorSourceFor: contents].			^ contents asText makeSelectorBoldIn: class]		ifTrue: [strm _ WriteStream on: (String new: 100).			(myChangeSet classChangeAt: selectedClassName) do:				[:each |				each = #remove ifTrue: [strm nextPutAll: 'Entire class was removed.'; cr].				each = #addedThenRemoved ifTrue: [strm nextPutAll: 'Class was added then removed.'].				each = #rename ifTrue: [strm nextPutAll: 'Class name was changed.'; cr].				each = #add ifTrue: [strm nextPutAll: 'Class definition was added.'; cr].				each = #change ifTrue: [strm nextPutAll: 'Class definition was changed.'; cr].				each = #reorganize ifTrue: [strm nextPutAll: 'Class organization was changed.'; cr].				each = #comment ifTrue: [strm nextPutAll: 'New class comment.'; cr.				]].			^ strm contents].! !!CChangeSorter methodsFor: 'code pane' stamp: 'md 4/23/2004 17:25'!toggleDiffing	"Toggle whether diffs should be shown in the code pane"	self cNotYet.	"self okToChange ifTrue:		[super toggleDiffing.		self changed: #contents.		self update]	"! !!CChangeSorter methodsFor: 'code pane' stamp: 'md 4/6/2004 16:49'!wantsOptionalButtons	"No optional buttons for ChangeSorter"	^false! !!CChangeSorter methodsFor: 'creation' stamp: 'md 4/25/2004 13:44'!open	"ChangeSorter new open"	super open.	self showChangeSet: ChangeSet current 		! !!CChangeSorter methodsFor: 'creation' stamp: 'md 4/6/2004 16:49'!setDefaultChangeSetCategory	"Set a default ChangeSetCategory for the receiver, and answer it"	^ changeSetCategory _ self class changeSetCategoryNamed: #All! !!CChangeSorter methodsFor: 'creation' stamp: 'md 4/25/2004 14:54'!showChangeSet: aChangeSet	self selectedChangeSetName: aChangeSet name.	changeSetListPane contents: self changeSetList.	changeSetListPane selection: aChangeSet name asSymbol.	self onSelectedChangeSetNameChanged.! !!CChangeSorter methodsFor: 'events' stamp: 'md 4/21/2004 19:39'!onAcceptCodePane	"Update the class list when the system category list's cursor changes"	<on: save in: codePane> 	self contents: codePane contents notifying: nil! !!CChangeSorter methodsFor: 'events' stamp: 'md 4/25/2004 13:55'!onSelectedChangeSetNameChanged	"Get the current selection from the list"	| selected |	<on: selectedChangeSetNameChanged>	selected := selectedChangeSetName.		selected ifNil:[^classListPane contents: #()].	myChangeSet := self selectedChangeSet.	changeSetListPane menu: self changeSetListMenu.	classListPane menu: self classListMenu.	classListPane contents: self classList.	self signal: #updateWindowLabel.	self signal: #updateCodePane.! !!CChangeSorter methodsFor: 'events' stamp: 'md 4/25/2004 13:13'!onSelectedClassNameChanged	"Get the current selection from the list"	| selected |	<on: selectedClassNameChanged>	selected := self selectedClassName.	"Update the class list accordingly"	selected ifNil:[^methodListPane contents: #()].	methodListPane contents: self messageList.	methodListPane menu: self messageMenu.! !!CChangeSorter methodsFor: 'events' stamp: 'md 4/25/2004 13:13'!onSelectedMessageChanged	<on: selectedMessageChanged>	self signal: #updateCodePane.! !!CChangeSorter methodsFor: 'events' stamp: 'md 4/20/2004 13:08'!onUpdateCodePane	"Update the contents of the code pane"	<on: updateCodePane>	codePane contents: self setContents.! !!CChangeSorter methodsFor: 'events' stamp: 'md 4/25/2004 12:43'!onUpdateWindowLabel	<on: updateWindowLabel>	window label: self labelString.! !!CChangeSorter methodsFor: 'events - lists' stamp: 'md 4/25/2004 13:09'!onChangeSetListCursorChanged	"Update the class list when the system category list's cursor changes"	<on: cursorChanged in: changeSetListPane> 	self selectedChangeSetName: changeSetListPane selection! !!CChangeSorter methodsFor: 'events - lists' stamp: 'md 4/25/2004 13:09'!onClassListCursorChanged	"Update the class list when the system category list's cursor changes"	<on: cursorChanged in: classListPane> 	self selectedClassName: classListPane selection.	! !!CChangeSorter methodsFor: 'events - lists' stamp: 'md 4/25/2004 13:38'!onMethodListCursorChanged	"Update the class list when the system category list's cursor changes"	<on: cursorChanged in: methodListPane> 	self selectedMessage: methodListPane selection.	! !!CChangeSorter methodsFor: 'field access' stamp: 'md 4/20/2004 12:37'!changeSetListPane	"Answer the changeSetListPane of the receiver"	<bewareOf: #changeSetListPaneChanged>	^self propertyValueAt: #changeSetListPane! !!CChangeSorter methodsFor: 'field access' stamp: 'md 4/20/2004 12:37'!changeSetListPane: aValue	"Modify the receiver's changeSetListPane"	^self propertyValueAt: #changeSetListPane put: aValue with: #changeSetListPaneChanged! !!CChangeSorter methodsFor: 'field access' stamp: 'md 4/20/2004 12:35'!classListPane	"Answer the classListPane of the receiver"	<bewareOf: #classListPaneChanged>	^self propertyValueAt: #classListPane! !!CChangeSorter methodsFor: 'field access' stamp: 'md 4/20/2004 12:35'!classListPane: aValue	"Modify the receiver's classListPane"	^self propertyValueAt: #classListPane put: aValue with: #classListPaneChanged! !!CChangeSorter methodsFor: 'field access' stamp: 'md 4/20/2004 12:35'!methodListPane	"Answer the methodListPane of the receiver"	<bewareOf: #methodListPaneChanged>	^self propertyValueAt: #methodListPane! !!CChangeSorter methodsFor: 'field access' stamp: 'md 4/20/2004 12:35'!methodListPane: aValue	"Modify the receiver's methodListPane"	^self propertyValueAt: #methodListPane put: aValue with: #methodListPaneChanged! !!CChangeSorter methodsFor: 'field access' stamp: 'md 4/25/2004 12:51'!selectedChangeSetName	"Answer the selectedChangeSetName of the receiver"	<bewareOf: #selectedChangeSetNameChanged>	^self propertyValueAt: #selectedChangeSetName! !!CChangeSorter methodsFor: 'field access' stamp: 'md 4/25/2004 12:51'!selectedChangeSetName: aValue	"Modify the receiver's selectedChangeSetName"	^self propertyValueAt: #selectedChangeSetName put: aValue with: #selectedChangeSetNameChanged! !!CChangeSorter methodsFor: 'field access' stamp: 'md 4/25/2004 12:52'!selectedClassName	"Answer the selectedClassName of the receiver"	<bewareOf: #selectedClassNameChanged>	^self propertyValueAt: #selectedClassName! !!CChangeSorter methodsFor: 'field access' stamp: 'md 4/25/2004 12:52'!selectedClassName: aValue	"Modify the receiver's selectedClassName"	^self propertyValueAt: #selectedClassName put: aValue with: #selectedClassNameChanged! !!CChangeSorter methodsFor: 'field access' stamp: 'md 4/25/2004 12:39'!selectedMessage	"Answer the selectedMessage of the receiver"	<bewareOf: #selectedMessageChanged>	^self propertyValueAt: #selectedMessage! !!CChangeSorter methodsFor: 'field access' stamp: 'md 4/25/2004 12:39'!selectedMessage: aValue	"Modify the receiver's selectedMessage"	^self propertyValueAt: #selectedMessage put: aValue with: #selectedMessageChanged! !!CChangeSorter methodsFor: 'initialize' stamp: 'ar 6/2/2004 16:36'!initialize	super initialize.	"Define our components"		self define: #changeSetListPane as: CList new.	changeSetListPane allowDeselect: false.	self define: #classListPane as: CList new.	classListPane allowDeselect: true.	self define: #methodListPane as: CList new.	methodListPane allowDeselect: false.	self setDefaultChangeSetCategory.! !!CChangeSorter methodsFor: 'initialize' stamp: 'ar 7/29/2004 21:29'!setupCostume	"Create the default costume"	window player: self.	window extent: 360@360.	window layout: CProportionalLayout new.	changeSetListPane costume: CStringListCostume new.	changeSetListPane color: Color transparent.	changeSetListPane layoutFrame: (0@0 extent: 0.5@0.25).	window add: changeSetListPane.	classListPane costume: CStringListCostume new.	classListPane color: Color transparent.	classListPane layoutFrame: (0.5@0 extent: 0.5@0.25).	window add: classListPane.	methodListPane costume: CStringListCostume new.	methodListPane color: Color transparent.	methodListPane layoutFrame: (0@0.25 extent: 1@0.25).	window add: methodListPane.	codePane color: Color transparent.	codePane layoutFrame: (0@0.5 corner: 1@1).	codePane hResizing: #spaceFill; vResizing: #spaceFill.	codePane textWrap: true.	codePane hScrollable: false; vScrollable: true.	window add: codePane.	"Give all of my contents the default look"	window elements do:[:each|		each borderWidth: 2.		each borderStyle: #complexAltInset.		each borderColor: (Color r: 0.995 g: 0.788 b: 0.353).		each windowColor:  (Color r: 0.664 g: 0.8 b: 0.8).	].	window color:  (Color r: 0.664 g: 0.8 b: 0.8).! !!CChangeSorter methodsFor: 'message list' stamp: 'md 4/23/2004 16:40'!browseVersions	"Create and schedule a changelist browser on the versions of the 	selected message."	| class selector method category pair sourcePointer |	(selector _ self selectedMessageName) ifNil: [^ self].	class _ self selectedClassOrMetaClass.	(class includesSelector: selector)		ifTrue: [method _ class compiledMethodAt: selector.				category _ class whichCategoryIncludesSelector: selector.				sourcePointer _ nil]		ifFalse: [pair _ myChangeSet methodInfoFromRemoval: {class name. selector}.				pair ifNil: [^ nil].				sourcePointer _ pair first.				method _ CompiledMethod toReturnSelf setSourcePointer: sourcePointer.				category _ pair last].	self cNotYet.	"VersionsBrowser		browseVersionsOf: method		class: self selectedClass meta: class isMeta		category: category selector: selector		lostMethodPointer: sourcePointer."! !!CChangeSorter methodsFor: 'message list' stamp: 'md 4/25/2004 13:23'!copyMethodToOther	"Place this change in the other changeSet also"	| other cls sel |	self checkThatSidesDiffer: [^ self].	selectedMessage ifNotNil:		[other _ (parent other: self) changeSet.		cls _ self selectedClassOrMetaClass.		sel _ selectedMessage asSymbol.		other absorbMethod: sel class: cls from: myChangeSet.		(parent other: self) showChangeSet: other]! !!CChangeSorter methodsFor: 'message list' stamp: 'md 4/25/2004 13:23'!forget	"Drop this method from the changeSet"	self okToChange ifFalse: [^ self].	selectedMessage ifNotNil: [		myChangeSet removeSelectorChanges: self selectedMessageName 			class: self selectedClassOrMetaClass.		selectedMessage _ nil.		self showChangeSet: myChangeSet]! !!CChangeSorter methodsFor: 'message list' stamp: 'md 4/25/2004 13:26'!messageList 	| probe newSelectors |	probe _ (selectedClassName endsWith: ' class')		ifTrue: [selectedClassName]		ifFalse: [selectedClassName asSymbol].	newSelectors _ myChangeSet selectorsInClass: probe.	(newSelectors includes: selectedMessage) ifFalse: [selectedMessage _ nil].	^ newSelectors asSortedCollection! !!CChangeSorter methodsFor: 'message list' stamp: 'md 4/23/2004 16:34'!messageMenu	"Fill aMenu with items appropriate for the message list; could be for a single or double changeSorter"	| aMenu subMenu |	aMenu := CMenu new.	aMenu label: 'message list'.	parent ifNotNil:		[aMenu addList: #(			('copy method to other side'			copyMethodToOther)			('move method to other side'			moveMethodToOther)) target: self].	aMenu addList: #(			('delete method from changeSet (d)'	forget)			-			('remove method from system (x)'	removeMessage)				-			('browse full (b)'					browseMethodFull)			('browse hierarchy (h)'				spawnHierarchy)			('browse method (O)'				openSingleMessageBrowser)			('browse protocol (p)'				browseFullProtocol)			-			('fileOut'							fileOutMessage)			('printOut'							printOutMessage)			-			('senders of... (n)'					browseSenders)			('implementors of... (m)'				browseImplementors)			('inheritance (i)'					methodHierarchy)			('versions (v)'						browseVersions)			-			) target: self.			aMenu add: 'more...' subMenu: (subMenu := CMenu new).				self shiftedMessageMenu: subMenu.	^ aMenu! !!CChangeSorter methodsFor: 'message list' stamp: 'md 4/25/2004 13:26'!moveMethodToOther	"Place this change in the other changeSet and remove it from this side"	| other cls sel |	self checkThatSidesDiffer: [^ self].	self okToChange ifFalse: [^ self beep].	selectedMessage ifNotNil:		[other _ (parent other: self) changeSet.		other == myChangeSet ifTrue: [^ self beep].		cls _ self selectedClassOrMetaClass.		sel _ selectedMessage asSymbol.		other absorbMethod: sel class: cls from: myChangeSet.			(parent other: self) showChangeSet: other.		self forget "removes the method from this side"]! !!CChangeSorter methodsFor: 'message list' stamp: 'md 4/25/2004 13:25'!removeFromCurrentChanges	"Redisplay after removal in case we are viewing the current changeSet"	super removeFromCurrentChanges.	self signal: #selectedChangeSetNameChanged.! !!CChangeSorter methodsFor: 'message list' stamp: 'md 4/25/2004 13:23'!removeMessage	"Remove the selected msg from the system. Real work done by the 	parent, a ChangeSorter"	| confirmation sel |	self okToChange		ifFalse: [^ self].	selectedMessage		ifNotNil: [confirmation _ self systemNavigation   confirmRemovalOf: (sel _ self selectedMessageName) on: self selectedClassOrMetaClass.			confirmation == 3				ifTrue: [^ self].			self selectedClassOrMetaClass removeSelector: sel.			self update.			confirmation == 2				ifTrue: [self systemNavigation browseAllCallsOn: sel]]! !!CChangeSorter methodsFor: 'message list' stamp: 'md 4/25/2004 13:23'!selectedMessageName	selectedMessage ifNil: [^ nil].	^ selectedMessage asSymbol! !!CChangeSorter methodsFor: 'message list' stamp: 'md 4/23/2004 17:37'!shiftedMessageMenu: aMenu	"Arm the menu so that it holds items appropriate to the message-list while the shift key is down.  Answer the menu."	^ aMenu addList: #(		-		('toggle diffing (D)'					toggleDiffing)		('implementors of sent messages'		browseAllMessages)			-		('sample instance'					makeSampleInstance)		('inspect instances'					inspectInstances)		('inspect subinstances'				inspectSubInstances)		-		('change sets with this method'		findMethodInChangeSets)		('revert to previous version'			revertToPreviousVersion)		('revert & remove from changes'	revertAndForget)) target: self.! !!CClassBrowser methodsFor: 'accessing' stamp: 'md 4/29/2004 13:10'!classButton	"Answer the classButton of the receiver"	<bewareOf: #classButtonChanged>	^self propertyValueAt: #classButton! !!CClassBrowser methodsFor: 'accessing' stamp: 'md 4/29/2004 13:10'!classButton: aValue	"Modify the receiver's classButton"	^self propertyValueAt: #classButton put: aValue with: #classButtonChanged! !!CClassBrowser methodsFor: 'accessing' stamp: 'ar 3/14/2004 15:27'!classList	"Answer the classList of the receiver"	<bewareOf: #classListChanged>	^self propertyValueAt: #classList! !!CClassBrowser methodsFor: 'accessing' stamp: 'ar 3/14/2004 15:27'!classList: aValue	"Modify the receiver's classList"	^self propertyValueAt: #classList put: aValue with: #classListChanged! !!CClassBrowser methodsFor: 'accessing' stamp: 'md 5/1/2004 15:27'!commentButton	"Answer the commentButton of the receiver"	<bewareOf: #commentButtonChanged>	^self propertyValueAt: #commentButton! !!CClassBrowser methodsFor: 'accessing' stamp: 'md 5/1/2004 15:27'!commentButton: aValue	"Modify the receiver's commentButton"	^self propertyValueAt: #commentButton put: aValue with: #commentButtonChanged! !!CClassBrowser methodsFor: 'accessing' stamp: 'md 4/29/2004 13:10'!instanceButton	"Answer the instanceButton of the receiver"	<bewareOf: #instanceButtonChanged>	^self propertyValueAt: #instanceButton! !!CClassBrowser methodsFor: 'accessing' stamp: 'md 4/29/2004 13:10'!instanceButton: aValue	"Modify the receiver's instanceButton"	^self propertyValueAt: #instanceButton put: aValue with: #instanceButtonChanged! !!CClassBrowser methodsFor: 'accessing' stamp: 'ar 3/14/2004 15:27'!messageCategoryList	"Answer the messageCategoryList of the receiver"	<bewareOf: #messageCategoryListChanged>	^self propertyValueAt: #messageCategoryList! !!CClassBrowser methodsFor: 'accessing' stamp: 'ar 3/14/2004 15:27'!messageCategoryList: aValue	"Modify the receiver's messageCategoryList"	^self propertyValueAt: #messageCategoryList put: aValue with: #messageCategoryListChanged! !!CClassBrowser methodsFor: 'accessing' stamp: 'ar 3/14/2004 15:27'!messageList	"Answer the messageList of the receiver"	<bewareOf: #messageListChanged>	^self propertyValueAt: #messageList! !!CClassBrowser methodsFor: 'accessing' stamp: 'ar 3/14/2004 15:27'!messageList: aValue	"Modify the receiver's messageList"	^self propertyValueAt: #messageList put: aValue with: #messageListChanged! !!CClassBrowser methodsFor: 'accessing' stamp: 'ar 3/6/2004 23:29'!selectClass: theClass	self selectClass: theClass selector: nil.! !!CClassBrowser methodsFor: 'accessing' stamp: 'ar 3/6/2004 23:31'!selectClass: theClass selector: theSelector	"Set everything so that theClass is selected"	self selectedSystemCategory: theClass category.	systemCategoryList selection: self selectedSystemCategory.	self onSelectedSystemCategoryChanged.	self selectedClassName: theClass theNonMetaClass name.	classList selection: self selectedClassName.	self onSelectedClassNameChanged.	self selectedMessageCategory: (theClass organization categoryOfElement: theSelector).	messageCategoryList selection: self selectedMessageCategory.	self onSelectedMessageCategoryChanged.	self selectedMessage: theSelector.	messageList selection: self selectedMessage.	self onSelectedMessageChanged.! !!CClassBrowser methodsFor: 'accessing' stamp: 'ar 3/6/2004 19:59'!selectedClass	"Answer the currently selected class (not just its name)"	^Smalltalk at: self selectedClassName ifAbsent:[nil]! !!CClassBrowser methodsFor: 'accessing' stamp: 'ar 3/17/2004 15:02'!selectedClassName	"This method was automatically generated"	<bewareOf: #selectedClassNameChanged>	^self propertyValueAt: #selectedClassName! !!CClassBrowser methodsFor: 'accessing' stamp: 'ar 3/11/2004 14:18'!selectedClassName: aValue	"This method was automatically generated"	^self propertyValueAt: #selectedClassName put: aValue with: #selectedClassNameChanged! !!CClassBrowser methodsFor: 'accessing' stamp: 'ar 3/17/2004 15:02'!selectedMessage	"This method was automatically generated"	<bewareOf: #selectedMessageChanged>	^self propertyValueAt: #selectedMessage! !!CClassBrowser methodsFor: 'accessing' stamp: 'ar 3/11/2004 14:18'!selectedMessage: aValue	"This method was automatically generated"	^self propertyValueAt: #selectedMessage put: aValue with: #selectedMessageChanged! !!CClassBrowser methodsFor: 'accessing' stamp: 'ar 3/17/2004 15:03'!selectedMessageCategory	"This method was automatically generated"	<bewareOf: #selectedMessageCategoryChanged>	^self propertyValueAt: #selectedMessageCategory! !!CClassBrowser methodsFor: 'accessing' stamp: 'ar 3/11/2004 14:18'!selectedMessageCategory: aValue	"This method was automatically generated"	^self propertyValueAt: #selectedMessageCategory put: aValue with: #selectedMessageCategoryChanged! !!CClassBrowser methodsFor: 'accessing' stamp: 'md 5/1/2004 15:07'!selectedMessageName	^selectedMessage! !!CClassBrowser methodsFor: 'accessing' stamp: 'ar 3/17/2004 15:03'!selectedSystemCategory	"This method was automatically generated"	<bewareOf: #selectedSystemCategoryChanged>	^self propertyValueAt: #selectedSystemCategory! !!CClassBrowser methodsFor: 'accessing' stamp: 'ar 3/11/2004 14:18'!selectedSystemCategory: aValue	"This method was automatically generated"	^self propertyValueAt: #selectedSystemCategory put: aValue with: #selectedSystemCategoryChanged! !!CClassBrowser methodsFor: 'accessing' stamp: 'ar 3/14/2004 15:27'!systemCategoryList	"Answer the systemCategoryList of the receiver"	<bewareOf: #systemCategoryListChanged>	^self propertyValueAt: #systemCategoryList! !!CClassBrowser methodsFor: 'accessing' stamp: 'ar 3/14/2004 15:27'!systemCategoryList: aValue	"Modify the receiver's systemCategoryList"	^self propertyValueAt: #systemCategoryList put: aValue with: #systemCategoryListChanged! !!CClassBrowser methodsFor: 'accessing' stamp: 'ar 3/6/2004 23:12'!systemOrganizer	^SystemOrganization! !!CClassBrowser methodsFor: 'actions-class list' stamp: 'md 5/1/2004 15:26'!addField	"Add a new instance field"	| fieldName aClass toGet toSet |	aClass := self selectedClass ifNil:[^self].	fieldName := FillInTheBlank request:'Field name?'.	fieldName isEmptyOrNil ifTrue:[^self].	fieldName := fieldName asSymbol.	(aClass allVariableNames anySatisfy:[:varName| varName = fieldName]) ifTrue:[		(self confirm: 'A field named "', fieldName, '" already exists. Proceed?') ifFalse:[^nil].	].	toGet := fieldName.	toSet := (fieldName,':') asSymbol.	"Check for conflicting methods"	(aClass includesSelector: toGet) ifTrue:[		(self confirm: 'A method with the name "', toGet,'" already exists.Proceed?') ifFalse:[^self].	].	(aClass includesSelector: toSet) ifTrue:[		(self confirm: 'A method with the name "', toSet,'" already exists.Proceed?') ifFalse:[^self].	].	((aClass canUnderstand: toGet) or:[aClass canUnderstand: toSet]) ifTrue:[		| proceed |		proceed := self confirm: 'The definition of "', fieldName, '" will override \methods which have been defined \(but may be invisible) in this object.\Do you wish to proceed?' withCRs.		proceed ifFalse:[^nil].	].	aClass fieldNames: (aClass fieldNames,' ', fieldName).	aClass compilePropertyFor: fieldName defaultValue: nil.	ChangeSet current changeClass: aClass from: aClass.	aClass signal: #fieldsChanged.! !!CClassBrowser methodsFor: 'actions-class list' stamp: 'ar 3/7/2004 03:14'!classListKeyMap	"Set up the keymap to apply to the receiver's class list"	| map |	map := CKeyboardDispatchTable new.	map add: #(ctrl B) action: #browseMethodFull.	map add: #(ctrl H) action: #spawnHierarchy.	map add: #(ctrl P) action: #browseFullProtocol.	map add: #(ctrl shift N) action: #browseClassRefs.	map add: #(ctrl X) action: #removeClass.	^map! !!CClassBrowser methodsFor: 'actions-class list' stamp: 'ar 3/27/2004 20:48'!classListMenu	"Set up the menu to apply to the receiver's class list, honoring the #shifted boolean"	| classMenu |	classMenu := CMenu new.	classMenu label: 'Class menu'.	classMenu addList: #(		('add field'					addField)		-		('browse full (b)'			browseMethodFull)		('browse hierarchy (h)'		spawnHierarchy)		('browse protocol (p)'		browseFullProtocol)		-		('printOut'					printOutClass)		('fileOut'					fileOutClass)		-		('show hierarchy'			hierarchy)		('show definition'			editClass)		('show comment'			editComment)		-		('inst var refs...'			browseInstVarRefs)		('inst var defs...'			browseInstVarDefs)		-		('class var refs...'			browseClassVarRefs)		('class refs (N)'				browseClassRefs)		-		('rename class ...'			renameClass)		('copy class'				copyClass)		('remove class (x)'			removeClass)		-		('find method...'				findMethod)		-		('more...'					offerShiftedClassListMenu)	) target: self.	^classMenu! !!CClassBrowser methodsFor: 'actions-class list' stamp: 'ar 3/26/2004 15:51'!copyClass	| oldDefinition newDefinition oldClass newName newClass |	oldClass := self selectedClass ifNil:[^self].	self okToChange ifFalse: [^ self].	newName _ CDialog request: 'Please type new class name' initialAnswer: oldClass name.	newName isEmptyOrNil ifTrue: [^ self].	newName _ newName asSymbol.	newName = oldClass name ifTrue: [^ self].	(Smalltalk includesKey: newName)		ifTrue: [^ CDialog inform: newName , ' already exists'].	oldDefinition _ oldClass definition.	newDefinition _ oldDefinition 		copyReplaceAll: '#' , oldClass name asString 		with: '#' , newName asString.	Cursor wait showWhile: [		newClass _ CCompiler evaluate: newDefinition logged: true.		newClass copyAllCategoriesFrom: oldClass.		newClass class copyAllCategoriesFrom: oldClass class.	].	self selectClass: newClass.! !!CClassBrowser methodsFor: 'actions-class list' stamp: 'ar 3/27/2004 20:47'!findMethod	"Pop up a list of the current class's methods, and select the one chosen by the user"	| aClass selectors reply msgMenu |	aClass _ self selectedClassOrMetaClass ifNil:[^self].	self okToChange ifFalse: [^ self].	selectors _ aClass selectors asSortedArray.	selectors isEmpty ifTrue: [^CDialog inform: aClass name, ' has no methods.'].	msgMenu := CMenu new.	msgMenu label: 'Choose Selector'.	reply := msgMenu chooseFromValues: selectors.	reply ifNil:[^ self].	self selectClass: aClass selector: reply.! !!CClassBrowser methodsFor: 'actions-class list' stamp: 'ar 3/7/2004 00:43'!renameClass	| oldName newName obs aClass |	self selectedClassName ifNil:[^self flash].	self okToChange ifFalse: [^ self].	oldName _ self selectedClass name.	newName _ CDialog request: 'Please type new class name' initialAnswer: oldName.	newName isEmptyOrNil ifTrue: [^ self].	newName _ newName asSymbol.	newName = oldName ifTrue: [^ self].	(Smalltalk includesKey: newName)		ifTrue: [^CDialog inform: newName , ' already exists'].	aClass := self selectedClass.	aClass rename: newName.	self selectClass: aClass.	obs _ self allCallsOn: (Smalltalk associationAt: newName).	obs isEmpty ifFalse:[		self			browseMessageList: obs			name: 'Obsolete References to ' , oldName			autoSelect: oldName].! !!CClassBrowser methodsFor: 'actions-codepane' stamp: 'md 5/2/2004 16:16'!defineClass: defString	"The receiver's textual content is a request to define a new class. The	source code is defString. If any errors occur in compilation, notify	aController."	| oldClass class newClassName defTokens keywdIx envt |	oldClass _ self selectedClassOrMetaClass.	defTokens _ defString findTokens: Character separators.	keywdIx _ defTokens findFirst: [:t | t beginsWith: 'category'].	envt _ Smalltalk environmentForCategory: ((defTokens at: keywdIx+1) copyWithout: $').	keywdIx _ defTokens findFirst: [:t | '*subclass*' match: t].	newClassName _ (defTokens at: keywdIx+1) copyWithoutAll: '#()'.	((oldClass isNil or: [oldClass name asString ~= newClassName])		and: [envt includesKeyOrAbove: newClassName asSymbol]) ifTrue:			["Attempting to define new class over existing one when				not looking at the original one in this browser..."			(CDialog confirm: ((newClassName , ' is an existing class in this system.Redefining it might cause serious problems.Is this really what you want to do?') asText makeBoldFrom: 1 to: newClassName size))				ifFalse: [^ false]].	"ar 8/29/1999: Use oldClass superclass for defining oldClass	since oldClass superclass knows the definerClass of oldClass."	oldClass ifNotNil:[oldClass _ oldClass superclass].	class _ oldClass subclassDefinerClass				evaluate: defString				notifying: self				logged: true.	(class isKindOf: Behavior)		ifTrue: [				self onSelectedSystemCategoryChanged.				classList selection:						((class isKindOf: Metaclass)							ifTrue: [class soleInstance name asSymbol]							ifFalse: [class name asSymbol]).				self selectedClassName: classList selection.				^ true]		ifFalse: [^ false]! !!CClassBrowser methodsFor: 'actions-codepane' stamp: 'md 5/2/2004 12:48'!defineMessageFrom: aString	"Compile the expressions in aString. Install the compiled method in the selected class 	classified under  the currently selected message category name. Answer the selector 	obtained if compilation succeeds, nil otherwise."	| selectedMessageName selector category oldMessageList |		selectedMessageName _ self selectedMessage.	oldMessageList _ self messageList.	selector _ (Parser new parseSelector: aString)."	(self metaClassIndicated		and: [(self selectedClassOrMetaClass includesSelector: selector) not		and: [Metaclass isScarySelector: selector]])		ifTrue: [""A frist-time definition overlaps the protocol of Metaclasses""				(self confirm: ((selector , ' is used in the existing class system.Overriding it could cause serious problems.Is this really what you want to do?') asText makeBoldFrom: 1 to: selector size))				ifFalse: [^nil]]."	selector _ self selectedClassOrMetaClass				compile: aString				classified: (category _ self selectedMessageCategory)				notifying: self.	selector == nil ifTrue: [^ nil].	codePane contents: aString copy.	selector ~~ selectedMessageName 		ifTrue: 			[category = ClassOrganizer nullCategory				ifTrue: [self onSelectedClassNameChanged.						messageCategoryList selectionIndex: 1.						self onSelectedMessageCategoryChanged].			"self setClassOrganizer."  "In case organization not cached"			(oldMessageList includes: selector)				ifFalse: [self onSelectedMessageCategoryChanged].			messageList selection: selector].	^ selector! !!CClassBrowser methodsFor: 'actions-codepane' stamp: 'md 5/1/2004 14:54'!notify: aString at: location in: source	codePane selectionStart: location.	codePane selectionStop: location.	codePane paste: aString select: true.		! !!CClassBrowser methodsFor: 'actions-message categories' stamp: 'ar 3/27/2004 20:46'!addMessageCategory	"Present a choice of categories or prompt for a new category name and add it before the current selection, or at the end if no current selection"	| reject cats newName aClass list newToken msgMenu |	aClass := self selectedClassOrMetaClass ifNil:[^self].	self okToChange ifFalse: [^ self].	list := Array new writeStream.	newToken := Object new. "any token that is unique"	list nextPut: {'new...'. newToken}.	list nextPut: #-.	reject _ Set new.	reject		addAll: aClass organization categories;		add: ClassOrganizer nullCategory;		add: ClassOrganizer default.	self selectedClassOrMetaClass allSuperclasses do: [:cls |		cls = Object ifFalse: [			cats _ cls organization categories reject:[:cat | reject includes: cat].			cats isEmpty ifFalse: [				cats asSortedCollection do:[:cc| list nextPut: {cc. cc}].				list nextPut: #-.				reject addAll: cats.			].		].	].	msgMenu := CMenu new.	msgMenu label: 'Add Category'.	newName := msgMenu chooseFrom: list contents.	newName == newToken ifTrue:[		newName := CDialog request: 'Please type new category name' initialAnswer: 'category name'.	].	newName isEmpty ifTrue: [^ self].	newName _ newName asSymbol.	self selectedClassOrMetaClass organization		addCategory: newName		before: self selectedMessageCategory.	self onSelectedClassNameChanged.	messageCategoryList selection: newName.! !!CClassBrowser methodsFor: 'actions-message categories' stamp: 'md 4/23/2004 14:17'!alphabetizeMessageCategories	self okToChange ifFalse: [^ false].	ChangeSet current reorganizeClass: self selectedClassOrMetaClass.	self selectedClassOrMetaClass organization sortCategories.	self onSelectedClassNameChanged.	^ true! !!CClassBrowser methodsFor: 'actions-message categories' stamp: 'ar 3/7/2004 03:05'!messageCategoryListKeyMap	"Set up the keymap to apply to the receiver's message category list"	^nil! !!CClassBrowser methodsFor: 'actions-message categories' stamp: 'ar 3/27/2004 20:49'!messageCategoryListMenu	| aMenu |	aMenu := CMenu new.	aMenu label: 'Message Categories'.	aMenu addList: #(		('browse' browseMessageCategories)		('printOut' printOutMessageCategories)		('fileOut' fileOutMessageCategories)		-		('reorganize' editMessageCategories)		('alphabetize' alphabetizeMessageCategories)		('remove empty categories' removeEmptyCategories)		('categorize all uncategorized' categorizeAllUncategorizedMethods)		-		('new category...' addMessageCategory)		('rename category...' renameMessageCategory)		('remove category' removeMessageCategory)	) target: self.	^aMenu! !!CClassBrowser methodsFor: 'actions-message categories' stamp: 'md 5/3/2004 14:13'!removeEmptyCategories	self okToChange ifFalse: [^ self].	self selectedClassOrMetaClass organization removeEmptyCategories.	self onSelectedClassNameChanged.! !!CClassBrowser methodsFor: 'actions-message categories' stamp: 'ar 3/7/2004 01:20'!removeMessageCategory	"If a message category is selected, create a Confirmer so the user can 	verify that the currently selected message category should be removed 	from the system. If so, remove it."	| messageCategoryName |	messageCategoryName := self selectedMessageCategory ifNil:[^self].	self okToChange ifFalse: [^ self].	(messageList size = 0 or: [CDialog confirm: 'Are you sure you want toremove this method category and all its methods?']) ifFalse:[^self].	self selectedClassOrMetaClass removeCategory: messageCategoryName.	self onSelectedClassNameChanged.! !!CClassBrowser methodsFor: 'actions-message categories' stamp: 'ar 3/7/2004 01:17'!renameMessageCategory	"Prompt for a new category name and add it before the	current selection, or at the end if no current selection"	| oldName newName oldClass |	oldClass := self selectedClassOrMetaClass ifNil:[^self].	oldName _ self selectedMessageCategory ifNil:[^self].	self okToChange ifFalse: [^ self].	newName _ CDialog		request: 'Please type new category name'		initialAnswer: oldName.	newName isEmpty ifTrue: [^ self].	newName _ newName asSymbol.	newName = oldName ifTrue: [^ self].	ChangeSet current reorganizeClass: oldClass.	oldClass organization		renameCategory: oldName		toBe: newName.	self selectClass: oldClass selector: self selectedMessage.! !!CClassBrowser methodsFor: 'actions-message list' stamp: 'md 5/3/2004 14:06'!browseAllMessages	"Create and schedule a message set browser on all implementors of all the messages sent by the current method."	| aClass aName method filteredList |	(aName _ self selectedSelector) ifNotNil: [		method _ (aClass _ self selectedClassOrMetaClass) compiledMethodAt: aName.		filteredList _ method messages reject: 			[:each | #(new initialize = ) includes: each].		self browseAllImplementorsOfList: filteredList asSortedCollection			 title: 'All messages sent in ', aClass name, '.', aName]! !!CClassBrowser methodsFor: 'actions-message list' stamp: 'ar 3/7/2004 01:42'!browseMethodVersions	"Create and schedule a Versions Browser, showing all versions of the currently selected message."	^self flash.! !!CClassBrowser methodsFor: 'actions-message list' stamp: 'ar 3/27/2004 20:48'!confirmRemovalOf: aSelector in: aClass 	"Determine if it is okay to remove the given selector. Answer true if it  should be removed, nil if it should be removed followed by a senders  browse, and false if it should not be removed."	| count answer allCalls aMenu |	allCalls _ self allCallsOn: aSelector.	count _ allCalls size.	count = 0 ifTrue: [^true]. "no senders"	count == 1 ifTrue: [		"If only one sender see if it it's sent by itself"		(allCalls first actualClass == aClass 			and: [allCalls first methodSymbol == aSelector])				ifTrue: [^true]].	aMenu := CMenu new.	aMenu label: 'This message has ' , count , ' sender(s)'.	answer := aMenu chooseFrom:#(		('Remove it' 1)		('Remove, then browse senders' 2)		('Don''t remove, but show me those senders' 3)		('Forget it -- do nothing -- sorry I asked' 4)	).	answer = 1 ifTrue:[^true].	answer = 2 ifTrue:[^nil].	answer = 3 ifTrue: [		self			browseMessageList: allCalls			name: 'Senders of ' , aSelector			autoSelect: aSelector keywords first].	^false! !!CClassBrowser methodsFor: 'actions-message list' stamp: 'md 5/1/2004 14:24'!messageListKeyMap	"Answer the message-list menu"	| map |	map := CKeyboardDispatchTable new.	map add: #(ctrl b) action: #browseMethodFull.	map add: #(ctrl h) action: #browseClassHierarchy.	map add: #(ctrl p) action: #browseFullProtocol.	map add: #(ctrl o) action: #fileOutMessage.	map add: #(cmd c) action: #copySelector.	map add: #(cmd n) action: #browseSenders.	map add: #(cmd m) action: #browseAllMessages.	map add: #(ctrl i) action: #browseMethodHierary.	map add: #(ctrl shift n) action: #browseClassRefs.	map add: #(ctrl x) action: #removeMessage.	^map! !!CClassBrowser methodsFor: 'actions-message list' stamp: 'ar 3/27/2004 20:49'!messageListMenu	"Answer the message-list menu"	| aMenu |	aMenu := CMenu new.	aMenu label: 'Messages'.	aMenu addList:#(			('browse full (b)' 						browseMethodFull)			('browse hierarchy (h)'					classHierarchy)			('browse method (O)'					openSingleMessageBrowser)			('browse protocol (p)'					browseFullProtocol)			-			('fileOut (o)'							fileOutMessage)			('printOut'								printOutMessage)			('copy selector (c)'						copySelector)			-			('senders of... (n)'						browseSenders)			('implementors of... (m)'					browseImplementors)			('inheritance (i)'						browseMethodHierarchy)			('versions (v)'							browseMethodVersions)			-			('inst var refs...'						browseInstVarRefs)			('inst var defs...'						browseInstVarDefs)			('class var refs...'						browseClassVarRefs)			('class refs (N)'							browseClassRefs)			-			('remove method (x)'					removeMessage)	) target: self.	^aMenu! !!CClassBrowser methodsFor: 'actions-message list' stamp: 'ar 3/7/2004 01:53'!removeMessage	"If a message is selected, create a Confirmer so the user can verify that  	the currently selected message should be removed from the system. If 	so,  remove it."	| messageName removal |	messageName _ self selectedMessage ifNil:[^self].	self okToChange ifFalse: [^ self].	removal := self confirmRemovalOf: messageName in: self selectedClassOrMetaClass.	removal == false ifTrue:[^self].	self selectedClassOrMetaClass removeSelector: messageName.	removal ifNil:[self browseAllCallsOn: messageName].	self onSelectedMessageCategoryChanged.! !!CClassBrowser methodsFor: 'actions-system categories' stamp: 'ar 3/6/2004 23:15'!addSystemCategory	"Prompt for a new category name and add it before the	current selection, or at the end if no current selection"	| newName |	self okToChange ifFalse: [^ self].	newName _ CDialog		request: 'Please type new category name'		initialAnswer: 'Category-Name'.	newName isEmpty		ifTrue: [^ self]		ifFalse: [newName _ newName asSymbol].	self systemOrganizer		addCategory: newName		before: systemCategoryList selection.	self updateSystemCategories.	systemCategoryList selection: newName.! !!CClassBrowser methodsFor: 'actions-system categories' stamp: 'ar 3/6/2004 23:09'!browseAllClasses	self flash.! !!CClassBrowser methodsFor: 'actions-system categories' stamp: 'ar 3/6/2004 23:09'!browseSystemCategory	self flash! !!CClassBrowser methodsFor: 'actions-system categories' stamp: 'ar 3/6/2004 22:59'!classNotFound	codePane flash.! !!CClassBrowser methodsFor: 'actions-system categories' stamp: 'ar 3/6/2004 23:10'!editSystemCategories	self flash.! !!CClassBrowser methodsFor: 'actions-system categories' stamp: 'ar 3/6/2004 23:10'!fileOutSystemCategory	self flash.! !!CClassBrowser methodsFor: 'actions-system categories' stamp: 'ar 3/25/2004 20:06'!findClass	"Search for a class by name."	| pattern foundClass classNames toMatch exactMatch potentialClassNames choice |	self okToChange ifFalse: [^ self classNotFound].	pattern _ CDialog request: 'Class name or fragment?'.	pattern isEmptyOrNil ifTrue: [^ self classNotFound].	toMatch _ (pattern copyWithout: $.) asLowercase.	potentialClassNames _ self potentialClassNames asOrderedCollection.	classNames _ pattern last = $. 		ifTrue: [potentialClassNames select:					[:nm |  nm asLowercase = toMatch]]		ifFalse: [potentialClassNames select: 					[:n | n includesSubstring: toMatch caseSensitive: false]].	classNames isEmpty ifTrue: [^ self classNotFound].	exactMatch _ classNames detect: [:each | each asLowercase = toMatch] ifNone: [nil].	choice _ classNames size = 1		ifTrue:	[classNames first]		ifFalse:	[(CMenu new) label: 'Select class';					chooseFromValues: classNames default: exactMatch].	choice ifNil:[^ self classNotFound].	foundClass _ Smalltalk at: choice asSymbol.	self selectClass: foundClass! !!CClassBrowser methodsFor: 'actions-system categories' stamp: 'ar 3/6/2004 22:50'!potentialClassNames	"Answer the names of all the classes that could be viewed in this browser.  This hook is provided so that HierarchyBrowsers can indicate their restricted subset.  For generic Browsers, the entire list of classes known to Smalltalk is provided, though of course that really only is accurate in the case of full system browsers."	^ Smalltalk classNames! !!CClassBrowser methodsFor: 'actions-system categories' stamp: 'ar 3/6/2004 23:09'!printOutSystemCategory	self flash.! !!CClassBrowser methodsFor: 'actions-system categories' stamp: 'ar 3/6/2004 23:09'!recentClass	self flash.! !!CClassBrowser methodsFor: 'actions-system categories' stamp: 'ar 3/6/2004 23:17'!removeSystemCategory	"If a class category is selected, create a Confirmer so the user can 	verify that the currently selected class category and all of its classes 	should be removed from the system. If so, remove it."	self selectedSystemCategory ifNil:[^self].	self okToChange ifFalse: [^ self].	(classList size = 0 or: [self confirm: 'Are you sure you want toremove this system category and all its classes?']) ifFalse:[^self].	self systemOrganizer removeSystemCategory: self selectedSystemCategory.	self updateSystemCategories.	systemCategoryList selection: nil.! !!CClassBrowser methodsFor: 'actions-system categories' stamp: 'ar 3/6/2004 23:16'!renameSystemCategory	"Prompt for a new category name and add it before the	current selection, or at the end if no current selection"	| oldName newName |	oldName _ self selectedSystemCategory ifNil:[^self].	self okToChange ifFalse: [^ self].	newName _ CDialog		request: 'Please type new category name'		initialAnswer: oldName.	newName isEmpty		ifTrue: [^ self]		ifFalse: [newName _ newName asSymbol].	oldName = newName ifTrue: [^ self].	self systemOrganizer		renameCategory: oldName		toBe: newName.	self updateSystemCategories.	systemCategoryList selection: newName.! !!CClassBrowser methodsFor: 'actions-system categories' stamp: 'md 5/1/2004 14:24'!systemCategoryListKeyMap	"Set up the keymap to apply to the receiver's system category list"	| map |	map := CKeyboardDispatchTable new.	map add: #(cmd f) action: #findClass.	map add: #(cmd r) action: #recentClass.	^map! !!CClassBrowser methodsFor: 'actions-system categories' stamp: 'ar 3/17/2004 11:45'!systemCategoryListMenu	| menu |	menu := CMenu new.	menu label: 'System Categories'.	menu addList: #(		('find class... (f)' findClass)		('recent classes... (r)' recentClass)		-		('browse all' browseAllClasses)		('browse' browseSystemCategory)		-		('printOut' printOutSystemCategory)		('fileOut' fileOutSystemCategory)		-		('reorganize' editSystemCategories)		('update' updateSystemCategories)		-		('add category...' addSystemCategory)		('rename category...' renameSystemCategory)		('remove category' removeSystemCategory)	) target: self.	^menu! !!CClassBrowser methodsFor: 'actions-system categories' stamp: 'ar 3/6/2004 23:10'!updateSystemCategories	"The class categories were changed in another browser. The receiver must 	reorganize its lists based on these changes."	self okToChange ifFalse: [^ self].	systemCategoryList contents: SystemOrganization categories.! !!CClassBrowser methodsFor: 'comments' stamp: 'md 5/1/2004 15:51'!classComment	| theClass comment |	(theClass _ self selectedClass) ifNil: [^ ''].		comment _ theClass comment.	comment isEmpty ifTrue: [comment := 'This class has not yet been commented.'].	^comment! !!CClassBrowser methodsFor: 'comments' stamp: 'md 5/1/2004 15:52'!commentIndicated	^commentButton selected.! !!CClassBrowser methodsFor: 'comments' stamp: 'md 5/2/2004 13:02'!defineComment: aText	| theClass |	theClass _ self selectedClass.	theClass ifNil: [CDialog 						inform: 'You must select a class\before giving it a comment.' withCRs.					^ false].	theClass comment: aText stamp: Utilities changeStamp.	codePane contents: aText copy.	^ true.! !!CClassBrowser methodsFor: 'evaluating' stamp: 'ar 3/31/2004 14:44'!doItReceiver	"This class's classPool has been jimmied to be the classPool of the class 	being browsed. A doIt in the code pane will let the user see the value of 	the class variables."	^ self selectedClass ifNil: [FakeClassPool new]! !!CClassBrowser methodsFor: 'events' stamp: 'ar 6/2/2004 16:51'!codePaneContents	"Answer the current contents of the code pane"	self commentIndicated ifTrue: [^self classComment].	self selectedSystemCategory 		ifNil:[^''].	self selectedClassName 		ifNil:[^Class template: self selectedSystemCategory].	self selectedMessageCategory		ifNil:[^self selectedClass browserDefinition: #default].	self selectedMessage		ifNil:[^self selectedClass sourceCodeTemplate].	^(self selectedClassOrMetaClass sourceCodeAt: self selectedMessage ifAbsent:['']) asText				makeSelectorBoldIn: self selectedClass.! !!CClassBrowser methodsFor: 'events' stamp: 'md 5/2/2004 16:16'!onAcceptCodePane	"Update the class list when the system category list's cursor changes"	| str |	<on: save in: codePane> 	self commentIndicated ifTrue: [^self defineComment: codePane contents].	str := codePane contents asString.	self selectedClassName ifNil: [^self defineClass: str].	self selectedMessageCategory ifNil: [^self defineClass: str].	self defineMessageFrom: str.	! !!CClassBrowser methodsFor: 'events' stamp: 'md 5/1/2004 15:54'!onClassButton	<on: fire in: classButton>	classButton selected: classButton selected not.	instanceButton selected: classButton selected not.	commentButton selected: classButton selected not.	self signal: #selectedClassNameChanged.! !!CClassBrowser methodsFor: 'events' stamp: 'md 5/1/2004 15:58'!onCommentButton	<on: fire in: commentButton>	commentButton selected: commentButton selected not.	self signal: #selectedClassNameChanged.	! !!CClassBrowser methodsFor: 'events' stamp: 'md 5/1/2004 15:54'!onInstnaceButton	<on: fire in: instanceButton>	instanceButton selected: instanceButton selected not.	classButton selected: instanceButton selected not.	commentButton selected: instanceButton selected not.	self signal: #selectedClassNameChanged.! !!CClassBrowser methodsFor: 'events' stamp: 'md 5/2/2004 16:14'!onSelectedClassNameChanged	"Get the current selection from the list"	| selected |	<on: selectedClassNameChanged>	self selectedMessageCategory: nil.	messageCategoryList selection: nil.	self signal: #updateWindowLabel.	self signal: #updateCodePane.	selected := self selectedClassOrMetaClass.	"Update the class list accordingly"	selected ifNil:[^messageCategoryList contents: #()].	messageCategoryList contents: selected organization categories.! !!CClassBrowser methodsFor: 'events' stamp: 'md 4/29/2004 12:41'!onSelectedMessageCategoryChanged	| selected |	<on: selectedMessageCategoryChanged>	self signal: #updateCodePane.	"Get the current selection from the list"	selected := self selectedMessageCategory.	"Update the class list accordingly"	selected ifNil:[^messageList contents: #()].	messageList contents: (self selectedClassOrMetaClass organization listAtCategoryNamed: selected)! !!CClassBrowser methodsFor: 'events' stamp: 'ar 3/6/2004 21:34'!onSelectedMessageChanged	<on: selectedMessageChanged>	self signal: #updateCodePane.! !!CClassBrowser methodsFor: 'events' stamp: 'ar 3/6/2004 21:35'!onSelectedSystemCategoryChanged	| selected |	<on: selectedSystemCategoryChanged>	self signal: #updateWindowLabel.	self signal: #updateCodePane.	"Get the current selection from the list"	selected := self selectedSystemCategory.	"Update the class list accordingly"	selected ifNil:[^classList contents: #()].	classList contents: (SystemOrganization listAtCategoryNamed: selected).! !!CClassBrowser methodsFor: 'events' stamp: 'md 5/1/2004 15:56'!onUpdateCodePane	"Update the contents of the code pane"	<on: updateCodePane>	codePane contents: self codePaneContents.! !!CClassBrowser methodsFor: 'events' stamp: 'ar 3/6/2004 23:52'!onUpdateWindowLabel	| selected |	<on: updateWindowLabel>	selected := self selectedClassName ifNil:[self selectedSystemCategory].	selected ifNil:[^window label: 'System Browser'].	window label: 'System Browser: ', selected.! !!CClassBrowser methodsFor: 'events' stamp: 'ar 3/6/2004 21:45'!onWindowCloseRequest	<on: closeRequest in: window>	self okToChange ifFalse:[^self].	window destroy. "bye, bye"! !!CClassBrowser methodsFor: 'initialize' stamp: 'md 5/1/2004 15:28'!initialize	"Initialize the receiver"	super initialize.	self define: #systemCategoryList as: CList new.	systemCategoryList menu: self systemCategoryListMenu.	systemCategoryList userDataAt: #keyMap put: self systemCategoryListKeyMap.	systemCategoryList allowDeselect: true.	self define: #classList as: CList new.	classList menu: self classListMenu.	classList userDataAt: #keyMap put: self classListKeyMap.	classList allowDeselect: true.	self define: #instanceButton as: CToolBarButton new.	self define: #classButton as: CToolBarButton new.	self define: #commentButton as: CToolBarButton new.	self define: #messageCategoryList as: CList new.	messageCategoryList menu: self messageCategoryListMenu.	messageCategoryList userDataAt: #keyMap put: self messageCategoryListKeyMap.	messageCategoryList allowDeselect: true.	self define: #messageList as: CList new.	messageList menu: self messageListMenu.	messageList userDataAt: #keyMap put: self messageListKeyMap.	messageList allowDeselect: true.	"Finally, add the default system categories"	systemCategoryList contents: SystemOrganization categories.	self onUpdateWindowLabel.! !!CClassBrowser methodsFor: 'initialize' stamp: 'ar 7/29/2004 21:29'!setupCostume	"Create the default costume"	super setupCostume.	window extent: 550@350.	systemCategoryList costume: CStringListCostume new.	systemCategoryList color: Color transparent.	systemCategoryList layoutFrame: (0@0 extent: 0.25@0.5).	window add: systemCategoryList.	classList costume: CStringListCostume new.	classList color: Color transparent.	classList layoutFrame: (0.25@0 extent: 0.25@0.4).	window add: classList.	instanceButton label: 'instance'.	instanceButton layoutFrame: (0.25@0.4 extent: 0.10@0.1).	instanceButton hResizing: #spaceFill; vResizing: #spaceFill.	window add: instanceButton.	commentButton label: '?'.	commentButton layoutFrame: (0.35@0.4 extent: 0.05@0.1).	commentButton hResizing: #spaceFill; vResizing: #spaceFill.	window add: commentButton.	classButton label: 'class'.	classButton layoutFrame: (0.40@0.4 extent: 0.10@0.1).	classButton hResizing: #spaceFill; vResizing: #spaceFill.	window add: classButton.	messageCategoryList costume: CStringListCostume new.	messageCategoryList color: Color transparent.	messageCategoryList layoutFrame: (0.5@0 extent: 0.25@0.5).	window add: messageCategoryList.	messageList costume: CStringListCostume new.	messageList color: Color transparent.	messageList layoutFrame: (0.75@0 extent: 0.25@0.5).	window add: messageList.	codePane layoutFrame: (0@0.5 corner: 1@1).	"Give all of my contents the default look"	window elements do:[:each|		each borderWidth: 2.		each borderStyle: #complexAltInset.		each borderColor: (Color r: 0.995 g: 0.788 b: 0.353).		each windowColor: (Color r: 0.652 g: 0.8 b: 0.504).	].	window color:  (Color r: 0.652 g: 0.8 b: 0.504).! !!CClassBrowser methodsFor: 'list events' stamp: 'ar 3/6/2004 21:22'!onClassListCursorChanged	"Update the message category list when the class list's cursor changes"	<on: cursorChanged in: classList>	(self okToChangeList: classList from: self selectedClassName)		ifTrue:[self selectedClassName: classList selection]! !!CClassBrowser methodsFor: 'list events' stamp: 'ar 3/7/2004 02:58'!onClassListKeyDown: evt	"Update the message category list when the class list's cursor changes"	<on: keyDown in: classList>	^self onKeyDown: evt in: classList! !!CClassBrowser methodsFor: 'list events' stamp: 'md 5/1/2004 14:05'!onKeyDown: event in: aWidget	"Perform the action bound via the given key event in aWidget"	| aMap action |	aMap := (aWidget userDataAt: #keyMap) ifNil:[^self].	action := aMap lookupEvent: event.	action ifNotNil:[self perform: action].! !!CClassBrowser methodsFor: 'list events' stamp: 'ar 3/6/2004 21:23'!onMessageCategoryCursorChanged	"Update the message list when the message category list's cursor changes"	<on: cursorChanged in: messageCategoryList>	(self okToChangeList: messageCategoryList from: self selectedMessageCategory)		ifTrue:[self selectedMessageCategory: messageCategoryList selection]! !!CClassBrowser methodsFor: 'list events' stamp: 'ar 3/7/2004 02:57'!onMessageCategoryListKeyDown: evt	<on: keyDown in: messageCategoryList>	^self onKeyDown: evt in: messageCategoryList! !!CClassBrowser methodsFor: 'list events' stamp: 'ar 3/6/2004 21:22'!onMessageListCursorChanged	"Update the code pane when the message list's cursor changes"	<on: cursorChanged in: messageList>	(self okToChangeList: messageList from: self selectedMessage)		ifTrue:[self selectedMessage: messageList selection]! !!CClassBrowser methodsFor: 'list events' stamp: 'ar 3/7/2004 02:57'!onMessageListKeyDown: evt	"Update the class list when the system category list's cursor changes"	<on: keyDown in: messageList>	^self onKeyDown: evt in: messageList! !!CClassBrowser methodsFor: 'list events' stamp: 'ar 3/6/2004 21:23'!onSystemCategoryListCursorChanged	"Update the class list when the system category list's cursor changes"	<on: cursorChanged in: systemCategoryList>	(self okToChangeList: systemCategoryList from: self selectedSystemCategory)		ifTrue:[self selectedSystemCategory: systemCategoryList selection].! !!CClassBrowser methodsFor: 'list events' stamp: 'ar 3/7/2004 02:58'!onSystemCategoryListKeyDown: evt	"Update the class list when the system category list's cursor changes"	<on: keyDown in: systemCategoryList>	^self onKeyDown: evt in: systemCategoryList! !!CClassBrowser methodsFor: 'metaclass' stamp: 'md 4/29/2004 13:46'!metaClassIndicated	^classButton selected.! !!CClassBrowser methodsFor: 'metaclass' stamp: 'md 4/29/2004 12:27'!selectedClassOrMetaClass	"Answer the selected class or metaclass."	| cls |	self metaClassIndicated		ifTrue: [^ (cls _ self selectedClass) ifNil: [nil] ifNotNil: [cls class]]		ifFalse: [^ self selectedClass]! !!CColorPicker methodsFor: 'initialize' stamp: 'ar 3/14/2004 00:39'!initialize	super initialize.	graphicForm := self colorPalette.	graphicFit := #rigid.	"Need some room for the pickers around me so fake a transparent border"	extent := graphicForm extent + 8.	borderWidth := 4.	borderColor := Color transparent.	self setupPicker.! !!CColorPicker methodsFor: 'initialize' stamp: 'ar 3/13/2004 23:22'!setupPicker	colorValues := #().	primaryPicker := self playerForColor: Color white.	self value: Color white.! !!CColorPicker methodsFor: 'accessing' stamp: 'ar 3/13/2004 23:01'!colorValues	"Answer the colorValues of the receiver"	<bewareOf: #colorValuesChanged>	^self propertyValueAt: #colorValues! !!CColorPicker methodsFor: 'accessing' stamp: 'ar 3/13/2004 23:01'!colorValues: aValue	"Modify the receiver's colorValues"	^self propertyValueAt: #colorValues put: aValue with: #colorValuesChanged! !!CColorPicker methodsFor: 'accessing' stamp: 'ar 3/26/2004 23:43'!colors	"Answer a list of all colors"	^colorValues collect:[:aPlayer| aPlayer value]! !!CColorPicker methodsFor: 'accessing' stamp: 'ar 3/26/2004 23:43'!colors: colorList	"Install a list of colors"	| max |	self newPrimaryPicker: nil.	max := colorList size min: colorValues size.	1 to: max do:[:i|		| aPlayer aColor |		aPlayer := colorValues at: i.		aColor := colorList at: i.		aPlayer value: aColor.		aPlayer center: (self positionOfColor: aColor).	].	colorValues size > max ifTrue:[		"remove some of the indicators"		max+1 to: colorValues size do:[:i|			(colorValues at: i) destroy.		].		colorValues := colorValues copyFrom: 1 to: max.	].	colorList size > max ifTrue:[		"add some color indicators"		max+1 to: colorList size do:[:i|			colorValues := colorValues copyWith: (self playerForColor: (colorList at: i)).		].	].	colorValues size > 0 ifTrue:[		self newPrimaryPicker: colorValues first.	].! !!CColorPicker methodsFor: 'accessing' stamp: 'ar 3/13/2004 23:17'!primaryPicker	"Answer the primaryPicker of the receiver"	<bewareOf: #primaryPickerChanged>	^self propertyValueAt: #primaryPicker! !!CColorPicker methodsFor: 'accessing' stamp: 'ar 3/13/2004 23:17'!primaryPicker: aValue	"Modify the receiver's primaryPicker"	^self propertyValueAt: #primaryPicker put: aValue with: #primaryPickerChanged! !!CColorPicker methodsFor: 'events' stamp: 'ar 3/13/2004 23:21'!onColorsChanged	self value: primaryPicker value.! !!CColorPicker methodsFor: 'events' stamp: 'ar 3/13/2004 23:18'!onMouseDown	<on: mouseDown>	primaryPicker ifNil:[^self].	self pickColorFor: primaryPicker.! !!CColorPicker methodsFor: 'events' stamp: 'ar 3/13/2004 23:18'!onValueChanged	<on: valueChanged>	primaryPicker ifNil:[^self].	primaryPicker value: value.	primaryPicker center: (self positionOfColor: value).! !!CColorPicker methodsFor: 'picking' stamp: 'ar 3/21/2004 19:38'!pickColor	self pickColorFor: primaryPicker.	self close.! !!CColorPicker methodsFor: 'picking' stamp: 'ar 3/13/2004 22:58'!pickColorAt: aPoint	| aWorld |	aWorld := self world.	aWorld ifNil:[^Color transparent].	^aWorld colorAt: aPoint! !!CColorPicker methodsFor: 'picking' stamp: 'ar 3/23/2004 23:16'!pickColorFor: aPlayer	self newPrimaryPicker: aPlayer.	self pauseScript: #onValueChanged.	aPlayer visible: false.	hand mouseFocus: self.	self waitTick. "for mouse cursor to restore and player to hide"	self mouseCursor: Cursor crossHair.	hand forEach: #mouseMove do:[		| show |		show := (self containsPoint: self cursorPoint) not.		show = aPlayer visible ifFalse:[aPlayer visible: show].		self newPrimaryColor: (self pickColorAt: world cursorPoint).	] until: #mouseUp.	self mouseCursor: nil.	aPlayer visible: true.	self resumeScript: #onValueChanged.! !!CColorPicker methodsFor: 'private' stamp: 'ar 3/13/2004 22:59'!colorPalette	StandardColorPalette ifNil:[		StandardColorPalette := self colorPaletteForDepth: 32 extent: 120@60.	].	^StandardColorPalette! !!CColorPicker methodsFor: 'private' stamp: 'ar 3/27/2004 20:50'!colorPaletteForDepth: depth extent: chartExtent	"Note: It is slow to build this palette, so it should be cached for quick access."	| basicHue xx yy c startHue palette transHt vSteps grayWidth hSteps |	palette _ Form extent: chartExtent depth: depth.	transHt _ -1.	palette fillWhite: (0@0 extent: palette width@transHt).	palette fillBlack: (0@transHt extent: palette width@1).	grayWidth _ 10.	startHue _ 338.0.	vSteps _ palette height - transHt // 2.	hSteps _ palette width - grayWidth.	xx _ 0.	startHue to: startHue + 360.0 by: 360.0/hSteps do: [:h |		basicHue _ Color h: h asFloat s: 1.0 v: 1.0.		yy _ transHt+1.		0 to: vSteps do: [:n | 			c _ basicHue mixed: (n asFloat / vSteps asFloat) with: Color white.			palette fill: (xx@yy extent: 1@1) fillColor: c.			yy _ yy + 1].		1 to: vSteps do: [:n | 			c _ Color black mixed: (n asFloat / vSteps asFloat) with: basicHue.			palette fill: (xx@yy extent: 1@1) fillColor: c.			yy _ yy + 1].		xx _ xx + 1].	yy _ transHt + 1.	1 to: vSteps * 2 do: [:n | 		c _ Color black mixed: (n asFloat / (vSteps*2) asFloat) with: Color white.		palette fill: (xx@yy extent: 10@1) fillColor: c.		yy _ yy + 1].	^ palette! !!CColorPicker methodsFor: 'private' stamp: 'ar 3/14/2004 00:41'!newPrimaryColor: aColor	primaryPicker value: aColor.	primaryPicker center: (self positionOfColor: aColor).	self onColorsChanged.! !!CColorPicker methodsFor: 'private' stamp: 'ar 3/13/2004 23:18'!newPrimaryPicker: aPlayer	primaryPicker ifNotNil:[primaryPicker borderColor: Color white].	primaryPicker := aPlayer.	primaryPicker ifNotNil:[primaryPicker borderColor: Color red].! !!CColorPicker methodsFor: 'private' stamp: 'ar 3/27/2004 20:50'!playerForColor: aColor	| aPlayer |	aPlayer := CPlayer on: aColor.	aPlayer fill: Color transparent.	aPlayer borderWidth: 1.	aPlayer borderStyle: #simple.	aPlayer borderColor: Color white.	aPlayer extent: 6@6.	aPlayer center: (self positionOfColor: aColor).	aPlayer mouseCursor: Cursor crossHair.	self startScript: #pickColorFor: 		withArguments:{aPlayer} 		when:{aPlayer. #mouseDown}.	self add: aPlayer.	^aPlayer! !!CColorPicker methodsFor: 'private' stamp: 'ar 3/27/2004 20:51'!positionInPalette: aColor	"Compute the position of the given color in the color chart form.	Note: This assumes that the costume's graphicForm was created by	colorPaletteForDepth: depth extent: chartExtent"	| rgbRect xx yy h s v |	rgbRect := 0@0 extent: graphicForm extent - (10@0).	h := aColor hue.	s := aColor saturation.	v := aColor brightness.	h = 0.0 ifTrue:["gray"		^(rgbRect right + 6) @ (rgbRect height * (1.0 - v) + rgbRect top)].	xx := (h + 22 \\ 360 / 360.0 * rgbRect width) rounded.	yy := 0.5.	s < 1.0 ifTrue:[yy _ yy - (1.0 - s * 0.5)].	v < 1.0 ifTrue:[yy _ yy + (1.0 - v * 0.5)].	yy := (yy * rgbRect height) rounded.	^xx@yy! !!CColorPicker methodsFor: 'private' stamp: 'ar 3/14/2004 00:40'!positionOfColor: aColor	^borderWidth + (self positionInPalette: aColor)! !!CColorTool methodsFor: 'initialize' stamp: 'ar 3/22/2004 14:40'!initialize	super initialize.	self define: #flagsPage as: CColorToolFlagsPage new.	self define: #fillPage as: CColorToolFillPage new.	self define: #borderPage as: CColorToolBorderPage new.	self define: #window as: CWindow new.! !!CColorTool methodsFor: 'initialize' stamp: 'ar 6/2/2004 15:32'!setupCostume	super setupCostume.	window player: self.	window extent: 284@266.	window hResizing: #rigid; vResizing: #rigid.	flagsPage borderStyle: #complexAltInset.	flagsPage borderWidth: 2.	flagsPage borderColor: CWidgetLibrary default frameColor.	flagsPage extent: 280@50.	window add: flagsPage.	fillPage borderStyle: #complexAltInset.	fillPage borderWidth: 2.	fillPage borderColor: CWidgetLibrary default frameColor.	fillPage position: 0@50.	fillPage extent: 140@190.	window add: fillPage.	borderPage borderStyle: #complexAltInset.	borderPage borderWidth: 2.	borderPage borderColor: CWidgetLibrary default frameColor.	borderPage position: 140@50.	borderPage extent: 140@190.	window add: borderPage.! !!CColorTool methodsFor: 'events' stamp: 'ar 3/17/2004 14:29'!onClose	<on: closed>	self pauseScript: #onHaloChanged.! !!CColorTool methodsFor: 'events' stamp: 'ar 3/17/2004 14:46'!onHaloChanged	<on: haloChanged in: hand>	target := hand halo target.! !!CColorTool methodsFor: 'events' stamp: 'ar 3/17/2004 19:37'!onNameChanged	<on: nameChanged in: target>	window label: target name.! !!CColorTool methodsFor: 'events' stamp: 'ar 3/17/2004 14:28'!onOpen	<on: opened>	self resumeScript: #onHaloChanged.! !!CColorTool methodsFor: 'events' stamp: 'ar 3/17/2004 19:37'!onTargetChanged	"Broadcast target changes to my pages"	<on: targetChanged>	target ifNil:[^self].	flagsPage target: target.	fillPage target: target.	borderPage target: target.	self onNameChanged.! !!CColorTool methodsFor: 'accessing' stamp: 'ar 3/16/2004 22:26'!borderPage	"Answer the borderPage of the receiver"	<bewareOf: #borderPageChanged>	^self propertyValueAt: #borderPage! !!CColorTool methodsFor: 'accessing' stamp: 'ar 3/16/2004 22:26'!borderPage: aValue	"Modify the receiver's borderPage"	^self propertyValueAt: #borderPage put: aValue with: #borderPageChanged! !!CColorTool methodsFor: 'accessing' stamp: 'ar 3/17/2004 18:51'!defaultContainer	^window! !!CColorTool methodsFor: 'accessing' stamp: 'ar 3/16/2004 22:26'!fillPage	"Answer the fillPage of the receiver"	<bewareOf: #fillPageChanged>	^self propertyValueAt: #fillPage! !!CColorTool methodsFor: 'accessing' stamp: 'ar 3/16/2004 22:26'!fillPage: aValue	"Modify the receiver's fillPage"	^self propertyValueAt: #fillPage put: aValue with: #fillPageChanged! !!CColorTool methodsFor: 'accessing' stamp: 'ar 3/16/2004 22:26'!flagsPage	"Answer the flagsPage of the receiver"	<bewareOf: #flagsPageChanged>	^self propertyValueAt: #flagsPage! !!CColorTool methodsFor: 'accessing' stamp: 'ar 3/16/2004 22:26'!flagsPage: aValue	"Modify the receiver's flagsPage"	^self propertyValueAt: #flagsPage put: aValue with: #flagsPageChanged! !!CColorTool methodsFor: 'accessing' stamp: 'tk 6/29/2004 14:02'!geometry	"My window has my bounds"	^window geometry! !!CColorTool methodsFor: 'accessing' stamp: 'ar 3/16/2004 22:39'!target	"Answer the target of the receiver"	<bewareOf: #targetChanged>	^self propertyValueAt: #target! !!CColorTool methodsFor: 'accessing' stamp: 'ar 3/16/2004 22:39'!target: aValue	"Modify the receiver's target"	^self propertyValueAt: #target put: aValue with: #targetChanged! !!CColorTool methodsFor: 'accessing' stamp: 'ar 3/17/2004 18:51'!window	"Answer the window of the receiver"	<bewareOf: #windowChanged>	^self propertyValueAt: #window! !!CColorTool methodsFor: 'accessing' stamp: 'ar 3/17/2004 18:51'!window: aValue	"Modify the receiver's window"	^self propertyValueAt: #window put: aValue with: #windowChanged! !!CColorToolBorderPage methodsFor: 'initialize' stamp: 'ar 3/22/2004 14:40'!initialize	super initialize.	self define: #label as: CLabel new.	self define: #borderColorChooser as: CColorPicker new.	self define: #borderWidthField as: CSpinner new.	self define: #borderStyleList as: CStyleReadoutList new.! !!CColorToolBorderPage methodsFor: 'initialize' stamp: 'tk 6/23/2004 10:54'!setupCostume	super setupCostume.	#(complexInset complexAltFramed complexAltRaised complexAltInset	complexRaised complexFramed inset raised simple none) 		do:[:style| borderStyleList add: (CBorderStyleReadout on: style)].	borderStyleList height: 10.	self layout: CTableLayout new.	self hResizing: #rigid; vResizing: #rigid.	self layout layoutInset: 4; cellInset: 2.	self extent: 140@190.		label value: 'Border:'.	self add: label.	self add: borderColorChooser.		borderWidthField label: 'Width:'.		borderWidthField vResizing: #rigid.		borderWidthField height: 20.	self add: borderWidthField.	self add: borderStyleList.! !!CColorToolBorderPage methodsFor: 'accessing' stamp: 'ar 3/16/2004 22:22'!borderColorChooser	"Answer the borderColorChooser of the receiver"	<bewareOf: #borderColorChooserChanged>	^self propertyValueAt: #borderColorChooser! !!CColorToolBorderPage methodsFor: 'accessing' stamp: 'ar 3/16/2004 22:22'!borderColorChooser: aValue	"Modify the receiver's borderColorChooser"	^self propertyValueAt: #borderColorChooser put: aValue with: #borderColorChooserChanged! !!CColorToolBorderPage methodsFor: 'accessing' stamp: 'ar 3/16/2004 22:22'!borderStyleList	"Answer the borderStyleList of the receiver"	<bewareOf: #borderStyleListChanged>	^self propertyValueAt: #borderStyleList! !!CColorToolBorderPage methodsFor: 'accessing' stamp: 'ar 3/16/2004 22:22'!borderStyleList: aValue	"Modify the receiver's borderStyleList"	^self propertyValueAt: #borderStyleList put: aValue with: #borderStyleListChanged! !!CColorToolBorderPage methodsFor: 'accessing' stamp: 'ar 3/16/2004 22:22'!borderWidthField	"Answer the borderWidthField of the receiver"	<bewareOf: #borderWidthFieldChanged>	^self propertyValueAt: #borderWidthField! !!CColorToolBorderPage methodsFor: 'accessing' stamp: 'ar 3/16/2004 22:22'!borderWidthField: aValue	"Modify the receiver's borderWidthField"	^self propertyValueAt: #borderWidthField put: aValue with: #borderWidthFieldChanged! !!CColorToolBorderPage methodsFor: 'accessing' stamp: 'ar 3/16/2004 22:23'!label	"Answer the label of the receiver"	<bewareOf: #labelChanged>	^self propertyValueAt: #label! !!CColorToolBorderPage methodsFor: 'accessing' stamp: 'ar 3/16/2004 22:23'!label: aValue	"Modify the receiver's label"	^self propertyValueAt: #label put: aValue with: #labelChanged! !!CColorToolBorderPage methodsFor: 'accessing' stamp: 'ar 3/16/2004 22:22'!target	"Answer the target of the receiver"	<bewareOf: #targetChanged>	^self propertyValueAt: #target! !!CColorToolBorderPage methodsFor: 'accessing' stamp: 'ar 3/16/2004 22:22'!target: aValue	"Modify the receiver's target"	^self propertyValueAt: #target put: aValue with: #targetChanged! !!CColorToolBorderPage methodsFor: 'events' stamp: 'ar 3/16/2004 22:38'!onTargetChanged	<on: targetChanged>	borderStyleList player: (target fieldNamed: #borderStyle).	borderColorChooser player: (target fieldNamed: #borderColor).	borderWidthField player: (target fieldNamed: #borderWidth).! !!CColorToolFillPage methodsFor: 'initialize' stamp: 'ar 3/22/2004 14:40'!initialize	super initialize.	self define: #label as: CLabel new.	self define: #fillColorChooser as: CMultiColorPicker new.	self define: #fillStyleList as: CStyleReadoutList new.	self define: #fillAlphaField as: CSpinner new.	self define: #fillAngleField as: CSpinner new.! !!CColorToolFillPage methodsFor: 'initialize' stamp: 'ar 4/30/2004 15:57'!setupCostume	#(radialGradient verticalGradient diagonalGradient horizontalGradient solid none) 		do:[:style| fillStyleList add: (CFillStyleReadout on: style)].	fillStyleList height: 10.	self layout: CTableLayout new.	self hResizing: #rigid; vResizing: #rigid.	self layout layoutInset: 4; cellInset: 2.		label value: 'Fill:'.	self add: label.	self add: fillColorChooser.	self add: fillStyleList.		fillAlphaField label: 'Fill Alpha:'.		fillAlphaField min: 0.0.		fillAlphaField max: 1.0.		fillAlphaField step: 0.01.		fillAlphaField vResizing: #rigid.		fillAlphaField height: 20.	self add: fillAlphaField.		fillAngleField label: 'Fill Angle:'.		fillAngleField min: -360.		fillAngleField max: 360.		fillAngleField vResizing: #rigid.		fillAngleField height: 20.	self add: fillAngleField.! !!CColorToolFillPage methodsFor: 'accessing' stamp: 'ar 3/16/2004 22:20'!fillAlphaField	"Answer the fillAlphaField of the receiver"	<bewareOf: #fillAlphaFieldChanged>	^self propertyValueAt: #fillAlphaField! !!CColorToolFillPage methodsFor: 'accessing' stamp: 'ar 3/16/2004 22:20'!fillAlphaField: aValue	"Modify the receiver's fillAlphaField"	^self propertyValueAt: #fillAlphaField put: aValue with: #fillAlphaFieldChanged! !!CColorToolFillPage methodsFor: 'accessing' stamp: 'ar 3/16/2004 22:20'!fillAngleField	"Answer the fillAngleField of the receiver"	<bewareOf: #fillAngleFieldChanged>	^self propertyValueAt: #fillAngleField! !!CColorToolFillPage methodsFor: 'accessing' stamp: 'ar 3/16/2004 22:20'!fillAngleField: aValue	"Modify the receiver's fillAngleField"	^self propertyValueAt: #fillAngleField put: aValue with: #fillAngleFieldChanged! !!CColorToolFillPage methodsFor: 'accessing' stamp: 'ar 3/16/2004 22:20'!fillColorChooser	"Answer the fillColorChooser of the receiver"	<bewareOf: #fillColorChooserChanged>	^self propertyValueAt: #fillColorChooser! !!CColorToolFillPage methodsFor: 'accessing' stamp: 'ar 3/16/2004 22:20'!fillColorChooser: aValue	"Modify the receiver's fillColorChooser"	^self propertyValueAt: #fillColorChooser put: aValue with: #fillColorChooserChanged! !!CColorToolFillPage methodsFor: 'accessing' stamp: 'ar 3/16/2004 22:20'!fillStyleList	"Answer the fillStyleList of the receiver"	<bewareOf: #fillStyleListChanged>	^self propertyValueAt: #fillStyleList! !!CColorToolFillPage methodsFor: 'accessing' stamp: 'ar 3/16/2004 22:20'!fillStyleList: aValue	"Modify the receiver's fillStyleList"	^self propertyValueAt: #fillStyleList put: aValue with: #fillStyleListChanged! !!CColorToolFillPage methodsFor: 'accessing' stamp: 'ar 3/16/2004 22:23'!label	"Answer the label of the receiver"	<bewareOf: #labelChanged>	^self propertyValueAt: #label! !!CColorToolFillPage methodsFor: 'accessing' stamp: 'ar 3/16/2004 22:23'!label: aValue	"Modify the receiver's label"	^self propertyValueAt: #label put: aValue with: #labelChanged! !!CColorToolFillPage methodsFor: 'accessing' stamp: 'ar 3/16/2004 22:19'!target	"Answer the target of the receiver"	<bewareOf: #targetChanged>	^self propertyValueAt: #target! !!CColorToolFillPage methodsFor: 'accessing' stamp: 'ar 3/16/2004 22:19'!target: aValue	"Modify the receiver's target"	^self propertyValueAt: #target put: aValue with: #targetChanged! !!CColorToolFillPage methodsFor: 'events' stamp: 'ar 3/16/2004 22:37'!onTargetChanged	<on: targetChanged>	fillStyleList player: (target fieldNamed: #fillStyle).	fillColorChooser player: (target fieldNamed: #fillColors).	fillAlphaField player: (target fieldNamed: #fillAlpha).	fillAngleField player: (target fieldNamed: #fillAngle).! !!CColorToolFlagsPage methodsFor: 'initialize' stamp: 'ar 3/22/2004 14:40'!initialize	super initialize.	self define: #roundedFlag as: CCheckBox new.	self define: #lockedFlag as: CCheckBox new.	self define: #shadowFlag as: CCheckBox new.	self define: #floatingFlag as: CCheckBox new.	self define: #visibleFlag as: CCheckBox new.	self define: #stickyFlag as: CCheckBox new.	self define: #clippingFlag as: CCheckBox new.	self define: #infiniteFlag as: CCheckBox new.! !!CColorToolFlagsPage methodsFor: 'initialize' stamp: 'ar 4/30/2004 15:49'!setupCostume	super setupCostume.	self layout: CTableLayout new.	self layout listDirection: #topToBottom; wrapDirection: #leftToRight.	self layout layoutInset: 4; cellInset: 4.	roundedFlag label: 'rounded'.	self add: roundedFlag.	visibleFlag label: 'visible'.	self add: visibleFlag.	lockedFlag label: 'locked'.	self add: lockedFlag.	stickyFlag label: 'sticky'.	self add: stickyFlag.	shadowFlag label: 'shadow'.	self add: shadowFlag.	clippingFlag label: 'clipping'.	self add: clippingFlag.	floatingFlag label: 'floating'.	self add: floatingFlag.	infiniteFlag label: 'infinite'.	self add: infiniteFlag.! !!CColorToolFlagsPage methodsFor: 'accessing' stamp: 'ar 3/16/2004 22:11'!clippingFlag	"Answer the clippingFlag of the receiver"	<bewareOf: #clippingFlagChanged>	^self propertyValueAt: #clippingFlag! !!CColorToolFlagsPage methodsFor: 'accessing' stamp: 'ar 3/16/2004 22:11'!clippingFlag: aValue	"Modify the receiver's clippingFlag"	^self propertyValueAt: #clippingFlag put: aValue with: #clippingFlagChanged! !!CColorToolFlagsPage methodsFor: 'accessing' stamp: 'ar 3/16/2004 22:10'!floatingFlag	"Answer the floatingFlag of the receiver"	<bewareOf: #floatingFlagChanged>	^self propertyValueAt: #floatingFlag! !!CColorToolFlagsPage methodsFor: 'accessing' stamp: 'ar 3/16/2004 22:10'!floatingFlag: aValue	"Modify the receiver's floatingFlag"	^self propertyValueAt: #floatingFlag put: aValue with: #floatingFlagChanged! !!CColorToolFlagsPage methodsFor: 'accessing' stamp: 'ar 3/16/2004 22:11'!infiniteFlag	"Answer the infiniteFlag of the receiver"	<bewareOf: #infiniteFlagChanged>	^self propertyValueAt: #infiniteFlag! !!CColorToolFlagsPage methodsFor: 'accessing' stamp: 'ar 3/16/2004 22:11'!infiniteFlag: aValue	"Modify the receiver's infiniteFlag"	^self propertyValueAt: #infiniteFlag put: aValue with: #infiniteFlagChanged! !!CColorToolFlagsPage methodsFor: 'accessing' stamp: 'ar 3/16/2004 22:10'!lockedFlag	"Answer the lockedFlag of the receiver"	<bewareOf: #lockedFlagChanged>	^self propertyValueAt: #lockedFlag! !!CColorToolFlagsPage methodsFor: 'accessing' stamp: 'ar 3/16/2004 22:10'!lockedFlag: aValue	"Modify the receiver's lockedFlag"	^self propertyValueAt: #lockedFlag put: aValue with: #lockedFlagChanged! !!CColorToolFlagsPage methodsFor: 'accessing' stamp: 'ar 3/16/2004 22:10'!roundedFlag	"Answer the roundedFlag of the receiver"	<bewareOf: #roundedFlagChanged>	^self propertyValueAt: #roundedFlag! !!CColorToolFlagsPage methodsFor: 'accessing' stamp: 'ar 3/16/2004 22:10'!roundedFlag: aValue	"Modify the receiver's roundedFlag"	^self propertyValueAt: #roundedFlag put: aValue with: #roundedFlagChanged! !!CColorToolFlagsPage methodsFor: 'accessing' stamp: 'ar 3/16/2004 22:10'!shadowFlag	"Answer the shadowFlag of the receiver"	<bewareOf: #shadowFlagChanged>	^self propertyValueAt: #shadowFlag! !!CColorToolFlagsPage methodsFor: 'accessing' stamp: 'ar 3/16/2004 22:10'!shadowFlag: aValue	"Modify the receiver's shadowFlag"	^self propertyValueAt: #shadowFlag put: aValue with: #shadowFlagChanged! !!CColorToolFlagsPage methodsFor: 'accessing' stamp: 'ar 3/16/2004 22:10'!stickyFlag	"Answer the stickyFlag of the receiver"	<bewareOf: #stickyFlagChanged>	^self propertyValueAt: #stickyFlag! !!CColorToolFlagsPage methodsFor: 'accessing' stamp: 'ar 3/16/2004 22:10'!stickyFlag: aValue	"Modify the receiver's stickyFlag"	^self propertyValueAt: #stickyFlag put: aValue with: #stickyFlagChanged! !!CColorToolFlagsPage methodsFor: 'accessing' stamp: 'ar 3/16/2004 22:10'!target	"Answer the target of the receiver"	<bewareOf: #targetChanged>	^self propertyValueAt: #target! !!CColorToolFlagsPage methodsFor: 'accessing' stamp: 'ar 3/16/2004 22:10'!target: aValue	"Modify the receiver's target"	^self propertyValueAt: #target put: aValue with: #targetChanged! !!CColorToolFlagsPage methodsFor: 'accessing' stamp: 'ar 3/16/2004 22:10'!visibleFlag	"Answer the visibleFlag of the receiver"	<bewareOf: #visibleFlagChanged>	^self propertyValueAt: #visibleFlag! !!CColorToolFlagsPage methodsFor: 'accessing' stamp: 'ar 3/16/2004 22:10'!visibleFlag: aValue	"Modify the receiver's visibleFlag"	^self propertyValueAt: #visibleFlag put: aValue with: #visibleFlagChanged! !!CColorToolFlagsPage methodsFor: 'events' stamp: 'ar 3/25/2004 14:20'!onTargetChanged	"Update my fields"	<on: targetChanged>	target ifNil:[^self].	roundedFlag player: (target fieldNamed: #roundCorners).	lockedFlag player: (target fieldNamed: #locked).	shadowFlag player: (target fieldNamed: #dropShadowEnabled).	floatingFlag player: (target fieldNamed: #floating).	visibleFlag player: (target fieldNamed: #visible).	stickyFlag player: (target fieldNamed: #sticky).	clippingFlag player: (target fieldNamed: #clipping).	infiniteFlag player: (target fieldNamed: #infinite).! !!CCostume methodsFor: 'initialize' stamp: 'ar 3/13/2004 00:35'!defaultColor	^Color white! !!CCostume methodsFor: 'initialize' stamp: 'ar 3/7/2004 22:02'!defaultPlayer	^self subclassResponsibility! !!CCostume methodsFor: 'initialize' stamp: 'ar 4/30/2004 15:58'!setupCostume	self color: self defaultColor.	self clipping: true.! !!CCostume methodsFor: 'events' stamp: 'ar 3/25/2004 19:51'!onPlayerChanged	<on: playerChanged>! !!CCostume methodsFor: 'serializing' stamp: 'ar 9/8/2004 16:21'!postBuildWith: aMaker	"Now that the player is fully loaded, make sure we're initialized correctly"	self autoStartScripts.	self setupCostume.	"For now, call #makeDefaultCostume so that we keep compatibility"		self makeDefaultCostume.	self signalChanged: #playerChanged from: nil to: myPlayer.! !!CCostume methodsFor: 'serializing' stamp: 'ar 3/25/2004 23:59'!readFieldsFrom: deSerializer	"By default, costumes only remember their player since they can be perfectly recreated after the player came back in. Note that the process is a little tricky since the player may not have been fully loaded yet and therefore we cannot initialize the receiver quite yet. This only happens in #postBuildWith: which is invoked once everything is loaded"	myPlayer := deSerializer readField: #player ifAbsent:[myPlayer].	myPlayer privateChangeCostumeTo: self.	self initialize.	transform := deSerializer readField: #transform ifAbsent:[transform].	extent := deSerializer readField: #extent ifAbsent:[extent].! !!CCostume methodsFor: 'serializing' stamp: 'ar 3/25/2004 23:52'!writeFieldsOn: aSerializer	"By default, costumes only remember their player since they can be perfectly recreated after the player came back in"	aSerializer writeField: #player value: player.	aSerializer writeField: #transform value: transform.	aSerializer writeField: #extent value: extent.! !!CCustomDrawListTarget methodsFor: 'accessing' stamp: 'ar 3/25/2004 11:36'!list	"Answer the list of the receiver"	<bewareOf: #listChanged>	^self propertyValueAt: #list! !!CCustomDrawListTarget methodsFor: 'accessing' stamp: 'ar 3/25/2004 11:36'!list: aValue	"Modify the receiver's list"	^self propertyValueAt: #list put: aValue with: #listChanged! !!CCustomDrawListTarget methodsFor: 'drawing' stamp: 'ar 3/25/2004 12:17'!drawOn: aCanvas in: drawingBounds	super drawOn: aCanvas in: drawingBounds.	list ifNotNil:[list drawOn: aCanvas in: drawingBounds].! !!CDebugger methodsFor: '*Tweak' stamp: 'md 4/8/2004 15:21'!openNotifierContents: msgString label: label	"Create and schedule a notifier view with the given label and message. A notifier view shows just the message or the first several lines of the stack, with a menu that allows the user to open a full debugger if so desired."	"NOTE: When this method returns, a new process has been scheduled to run the windows, and thus this notifier, but the previous active porcess has not been suspended.  The sender will do this."	| msg |	interruptedProcess ifNotNil:[		interruptedProcess isScriptingProcess ifTrue:[			(self openTweakNotifier: label) ifTrue:[^self].		].	].	Sensor flushKeyboard.	savedCursor _ Sensor currentCursor.	Sensor currentCursor: Cursor normal.	(label beginsWith: 'Space is low')		ifTrue: [msg _ self lowSpaceChoices, (msgString ifNil: [''])]		ifFalse: [msg _ msgString].	isolationHead ifNotNil:		["We have already revoked the isolation layer -- now jump to the parent project."		msg _ self isolationRecoveryAdvice, msgString.		failedProject _ Project current.		isolationHead parent enterForEmergencyRecovery].	self buildNotifierLabelled: label message: msg.	errorWasInUIProcess _ CurrentProjectRefactoring newProcessIfUI: interruptedProcess.		! !!CDebugger methodsFor: '*Tweak' stamp: 'md 4/6/2004 16:26'!openTweakNotifier: label	"See if there's a player in the receiver chain"	| ctx aPlayer |	ctx := contextStackTop.	[[ctx == nil] whileFalse:[		(ctx receiver isPlayer and:[ctx receiver world notNil]) ifTrue:[			aPlayer := ctx receiver.			ctx := nil.		] ifFalse:[ctx := ctx sender].	]] on: Error do:[:ex| ex return].	aPlayer ifNil:[^false].	^false! !!CDebugger methodsFor: 'accessing' stamp: 'md 4/28/2004 11:16'!contents: aText notifying: aController 	"The retrieved information has changed and its source must now be 	updated. In this case, the retrieved information is the method of the 	selected context."	| selector classOfMethod category h ctxt |	contextStackIndex = 0 ifTrue: [self halt.^ false].	self selectedContext isExecutingBlock ifTrue: [		h _ self selectedContext finalBlockHome.		h ifNil: [self inform: 'Method not found for block, can''t edit'. ^ false].		(self confirm: 'I will have to revert to the method fromwhich this block originated.  Is that OK?')			ifTrue: [self resetContext: h]			ifFalse: [^ false]	].	classOfMethod _ self selectedClass.	category _ self selectedMessageCategoryName.	selector _ Compiler parserClass new parseSelector: aText.	selector == self selectedMessageName		ifFalse: [self inform: 'can''t change selector'. ^ false].	selector _ classOfMethod		compile: aText		classified: category		notifying: aController.	selector ifNil: [^ false].  "compile cancelled"	ctxt _ self selectedContext.	interruptedProcess		popTo: ctxt;		restartTopWith: (classOfMethod compiledMethodAt: selector);		stepToSendOrReturn.	contextVariablesInspector object: nil.	theMethodNode _ ctxt methodNode.	sourceMap _ theMethodNode sourceMap.	tempNames _ theMethodNode tempNames.	self resetContext: ctxt.	^true! !!CDebugger methodsFor: 'accessing' stamp: 'md 4/6/2004 16:26'!interruptedContext	"Answer the suspended context of the interrupted process."	^contextStackTop! !!CDebugger methodsFor: 'accessing' stamp: 'md 4/6/2004 16:26'!interruptedProcess	"Answer the interrupted process."	^interruptedProcess! !!CDebugger methodsFor: 'accessing' stamp: 'md 4/6/2004 16:26'!isNotifier	"Return true if this debugger has not been expanded into a full sized window"	^ receiverInspector == nil! !!CDebugger methodsFor: 'accessing' stamp: 'md 4/6/2004 16:26'!labelString	^labelString! !!CDebugger methodsFor: 'accessing' stamp: 'md 4/28/2004 11:09'!labelString: aString	labelString _ aString.	self signal: #updateWindowLabel! !!CDebugger methodsFor: 'accessing' stamp: 'md 4/6/2004 16:26'!proceedValue	"Answer the value to return to the selected context when the interrupted 	process proceeds."	^proceedValue! !!CDebugger methodsFor: 'accessing' stamp: 'md 4/6/2004 16:26'!proceedValue: anObject 	"Set the value to be returned to the selected context when the interrupted 	process proceeds."	proceedValue _ anObject! !!CDebugger methodsFor: 'accessing' stamp: 'md 4/6/2004 16:26'!receiver	"Answer the receiver of the selected context, if any. Answer nil 	otherwise."	contextStackIndex = 0		ifTrue: [^nil]		ifFalse: [^self selectedContext receiver]! !!CDebugger methodsFor: 'accessing' stamp: 'md 4/6/2004 16:26'!receiverInspector	"Answer the instance of Inspector that is providing a view of the 	variables of the selected context's receiver."	^receiverInspector! !!CDebugger methodsFor: 'class list' stamp: 'md 4/6/2004 16:26'!selectedClass	"Answer the class in which the currently selected context's method was 	found."	^self selectedContext mclass! !!CDebugger methodsFor: 'class list' stamp: 'md 4/6/2004 16:26'!selectedClassOrMetaClass	"Answer the class in which the currently selected context's method was 	found."	^self selectedContext mclass! !!CDebugger methodsFor: 'code pane' stamp: 'md 4/6/2004 16:26'!contentsSelection	^ self pcRange! !!CDebugger methodsFor: 'code pane' stamp: 'md 4/6/2004 16:26'!doItContext	"Answer the context in which a text selection can be evaluated."	contextStackIndex = 0		ifTrue: [^super doItContext]		ifFalse: [^self selectedContext]! !!CDebugger methodsFor: 'code pane' stamp: 'md 4/6/2004 16:26'!doItReceiver	"Answer the object that should be informed of the result of evaluating a	text selection."	^self receiver! !!CDebugger methodsFor: 'code pane' stamp: 'md 4/6/2004 16:26'!pc	^ self pcRange! !!CDebugger methodsFor: 'code pane' stamp: 'md 4/28/2004 11:19'!pcRange	"Answer the indices in the source code for the method corresponding to 	the selected context's program counter value."	| i pc end |	(selectingPC and: [contextStackIndex ~= 0])		ifFalse: [^1 to: 0].	sourceMap == nil ifTrue:		[sourceMap _ theMethodNode sourceMap.		tempNames _ theMethodNode tempNames.		self selectedContext method cacheTempNames: tempNames].	(sourceMap size = 0 or: [ self selectedContext isDead ]) ifTrue: [^1 to: 0].	Smalltalk at: #RBProgramNode ifPresent:[:nodeClass|		(theMethodNode isKindOf: nodeClass) ifTrue: [			pc _ contextStackIndex = 1				ifTrue: [self selectedContext pc]				ifFalse: [self selectedContext previousPc].			i _ sourceMap findLast:[:pcRange | pcRange key <= pc].			i = 0 ifTrue:[^ 1 to: 0].			^ (sourceMap at: i) value		].	].	pc_ self selectedContext pc -		(("externalInterrupt" true and: [contextStackIndex=1])			ifTrue: [1]			ifFalse: [2]).	i _ sourceMap indexForInserting: (Association key: pc value: nil).	i < 1 ifTrue: [^1 to: 0].	i > sourceMap size		ifTrue:			[end _ sourceMap inject: 0 into:				[:prev :this | prev max: this value last].			^ end+1 to: end].	^(sourceMap at: i) value! !!CDebugger methodsFor: 'code pane menu' stamp: 'md 4/6/2004 16:26'!perform: selector orSendTo: otherTarget	"Selector was just chosen from a menu by a user.  If can respond, then perform it on myself.  If not, send it to otherTarget, presumably the editPane from which the menu was invoked." 	| result |	(#(debug proceed) includes: selector)		"When I am a notifier window"		ifTrue: [^ self perform: selector]		ifFalse: [result _ super perform: selector orSendTo: otherTarget.				selector == #doIt ifTrue: [					result ~~ #failedDoit ifTrue: [self proceedValue: result]].				^ result]! !!CDebugger methodsFor: 'context stack (message list)' stamp: 'md 4/6/2004 16:26'!contextStackIndex	"Answer the index of the selected context."	^contextStackIndex! !!CDebugger methodsFor: 'context stack (message list)' stamp: 'md 4/6/2004 16:26'!contextStackList	"Answer the array of contexts."	^contextStackList! !!CDebugger methodsFor: 'context stack (message list)' stamp: 'md 4/21/2004 12:04'!expandStack	"A Notifier is being turned into a full debugger.  Show a substantial amount of stack in the context pane."	self newStack: (contextStackTop stackOfSize: 20).	contextStackIndex _ 0.	receiverInspector _ CInspector inspect: nil.	receiverInspectorList menu: receiverInspector fieldListMenu.	contextVariablesInspector _ CContextVariablesInspector inspect: nil.	contextVariableInspectorList menu: contextVariablesInspector fieldListMenu.	proceedValue _ nil! !!CDebugger methodsFor: 'context stack (message list)' stamp: 'md 4/28/2004 11:47'!fullyExpandStack	"Expand the stack to include all of it, rather than the first four or five	contexts."	self okToChange ifFalse: [^ self].	self newStack: contextStackTop contextStack.	self signal: #updateContextStackList.! !!CDebugger methodsFor: 'context stack (message list)' stamp: 'md 4/6/2004 16:26'!messageListIndex	"Answer the index of the currently selected context."	^contextStackIndex! !!CDebugger methodsFor: 'context stack (message list)' stamp: 'md 4/23/2004 19:11'!selectedMessage	"Answer the message selector of the currently selected context."	^self selectedContext methodSelector! !!CDebugger methodsFor: 'context stack (message list)' stamp: 'md 4/6/2004 16:26'!selectedMessageName	"Answer the message selector of the currently selected context."	^self selectedContext methodSelector! !!CDebugger methodsFor: 'context stack (message list)' stamp: 'md 4/23/2004 19:11'!selectedMessageText	"Answer the source code of the currently selected context."	| contents |	contents _ theMethodNode sourceText.	Preferences browseWithPrettyPrint ifTrue: [		contents _ self selectedClass compilerClass new				format: contents				in: self selectedClass				notifying: nil				decorated: Preferences colorWhenPrettyPrinting].	^ contents asText makeSelectorBold! !!CDebugger methodsFor: 'context stack (message list)' stamp: 'md 4/6/2004 16:26'!toggleContextStackIndex: anInteger 	"If anInteger is the same as the index of the selected context, deselect it. 	Otherwise, the context whose index is anInteger becomes the selected 	context."	self contextStackIndex: 		(contextStackIndex = anInteger			ifTrue: [0]			ifFalse: [anInteger])		oldContextWas:		(contextStackIndex = 0			ifTrue: [nil]			ifFalse: [contextStack at: contextStackIndex])! !!CDebugger methodsFor: 'context stack menu' stamp: 'md 4/23/2004 19:13'!browseMessages	"Present a menu of all messages sent by the currently selected message.	Open a message set browser of all implementors of the message chosen.	Do nothing if no message is chosen."	contextStackIndex = 0 ifTrue: [^ self].	super browseImplementors.! !!CDebugger methodsFor: 'context stack menu' stamp: 'md 4/23/2004 19:00'!browseSendersOfMessages	"Present a menu of the currently selected message, as well as all	messages sent by it.  Open a message set browser of all implementors	of the message chosen."	contextStackIndex = 0 ifTrue: [^ self].	super browseSenders! !!CDebugger methodsFor: 'context stack menu' stamp: 'md 4/6/2004 16:26'!browseVersions	"Create and schedule a message set browser on all versions of the 	currently selected message selector."	| class selector |	class _ self selectedClassOrMetaClass.	selector _ self selectedMessageName.	VersionsBrowser		browseVersionsOf: (class compiledMethodAt: selector)		class: self selectedClass theNonMetaClass		meta: class isMeta		category: self selectedMessageCategoryName		selector: selector! !!CDebugger methodsFor: 'context stack menu' stamp: 'md 4/6/2004 16:26'!buildMessageBrowser	"Create and schedule a message browser on the current method."	contextStackIndex = 0 ifTrue: [^ self].	^ Browser		openMessageBrowserForClass: self selectedClassOrMetaClass		selector: self selectedMessageName		editString: nil! !!CDebugger methodsFor: 'context stack menu' stamp: 'md 4/28/2004 15:57'!buildNotifierLabelled: label message: messageString	| w |	self expandStack.		w _ CPreDebugger new.	w window label: label.	w player: self.	w open.	w notifyPane contents: self contextStackList.	^w! !!CDebugger methodsFor: 'context stack menu' stamp: 'md 4/6/2004 16:26'!contextStackKey: aChar from: view	"Respond to a keystroke in the context list" 	| selector |	selector _ ContextStackKeystrokes at: aChar ifAbsent: [nil].	selector ifNil: [self messageListKey: aChar from: view]		ifNotNil: [self perform: selector]! !!CDebugger methodsFor: 'context stack menu' stamp: 'md 4/28/2004 16:14'!doStep	"Send the selected message in the accessed method, and regain control 	after the invoked method returns."		| currentContext newContext |	self okToChange ifFalse: [^ self].	self checkContextSelection.	currentContext _ self selectedContext.	newContext _ interruptedProcess completeStep: currentContext.	newContext == currentContext ifTrue: [		newContext _ interruptedProcess stepToSendOrReturn].	self contextStackIndex > 1		ifTrue: [self resetContext: newContext]		ifFalse: [newContext == currentContext				ifTrue: [self signal: #updateCodePane.						self updateInspectors]				ifFalse: [self resetContext: newContext]].! !!CDebugger methodsFor: 'context stack menu' stamp: 'md 4/6/2004 16:26'!down	"move down the context stack to the previous (enclosing) context"	self toggleContextStackIndex: contextStackIndex+1! !!CDebugger methodsFor: 'context stack menu' stamp: 'md 4/28/2004 16:16'!fullStack	"Change from displaying the minimal stack to a full one."	self contextStackList size > 20 "Already expanded"		ifTrue:			[self signal: #flash]		ifFalse:			[self contextStackIndex = 0 ifFalse: [				self toggleContextStackIndex: self contextStackIndex].			self fullyExpandStack]! !!CDebugger methodsFor: 'context stack menu' stamp: 'md 4/23/2004 18:54'!mailOutBugReport	"Compose a useful bug report showing the state of the process as well as vital image statistics as suggested by Chris Norton - 'Squeak could pre-fill the bug form with lots of vital, butoft-repeated, information like what is the image version, last updatenumber, VM version, platform, available RAM, author...'and address it to the list with the appropriate subject prefix."	self cNotYet."	| messageStrm |	MailSender default ifNil: [^self].	Cursor write		showWhile: 			[""Prepare the message""			messageStrm _ WriteStream on: (String new: 1500).			messageStrm nextPutAll: 'From: ';			 nextPutAll: MailSender userName;			 cr;			 nextPutAll: 'To: squeak-dev@lists.squeakfoundation.org';			 cr;			 nextPutAll: 'Subject: ';			 nextPutAll: '[BUG]'; nextPutAll: self interruptedContext printString;			 cr;cr;			 nextPutAll: 'here insert explanation of what you were doing, suspect changes you''ve made and so forth.';cr;cr.			self interruptedContext errorReportOn: messageStrm.			MailSender sendMessage: (MailMessage from: messageStrm contents)]."! !!CDebugger methodsFor: 'context stack menu' stamp: 'md 4/6/2004 16:26'!peelToFirst	"Peel the stack back to the second occurance of the currently selected message.  Very useful for an infinite recursion.  Gets back to the second call so you can see one complete recursion cycle, and how it was called at the beginning.  Also frees a lot of space!!"	| upperGuy meth second |	contextStackIndex = 0 ifTrue: [^ self beep].	"self okToChange ifFalse: [^ self]."	upperGuy _ contextStack at: contextStackIndex.	meth _ upperGuy method.	contextStackIndex+1 to: contextStack size do: [:ind |		(contextStack at: ind) method == meth ifTrue: [			second _ upperGuy.			upperGuy _ contextStack at: ind]].	second ifNil: [second _ upperGuy].	self resetContext: second.	interruptedProcess popTo: self selectedContext.! !!CDebugger methodsFor: 'context stack menu' stamp: 'md 4/28/2004 16:12'!proceed	"Proceed execution of the receiver's model, starting after the expression at 	which an interruption occurred."	Smalltalk okayToProceedEvenIfSpaceIsLow ifTrue: [		self proceed: self window].! !!CDebugger methodsFor: 'context stack menu' stamp: 'md 4/6/2004 16:26'!proceed: aTopView 	"Proceed from the interrupted state of the currently selected context. The 	argument is the topView of the receiver. That view is closed."	self okToChange ifFalse: [^ self].	self checkContextSelection.	self resumeProcess: aTopView! !!CDebugger methodsFor: 'context stack menu' stamp: 'md 4/28/2004 16:13'!restart	"Proceed from the initial state of the currently selected context. The 	argument is a controller on a view of the receiver. That view is closed."	"Closing now depends on a preference #restartAlsoProceeds - hmm 9/7/2001 16:46"	self okToChange ifFalse: [^ self].	self checkContextSelection.	interruptedProcess		popTo: self selectedContext;		restartTop;		stepToSendOrReturn.	self resetContext: self selectedContext.	Preferences restartAlsoProceeds ifTrue: [self proceed]! !!CDebugger methodsFor: 'context stack menu' stamp: 'md 4/6/2004 16:26'!selectPC	"Toggle the flag telling whether to automatically select the expression 	currently being executed by the selected context."	selectingPC _ selectingPC not! !!CDebugger methodsFor: 'context stack menu' stamp: 'md 4/28/2004 16:14'!send	"Send the selected message in the accessed method, and take control in 	the method invoked to allow further step or send."	self okToChange ifFalse: [^ self].	self checkContextSelection.	interruptedProcess step: self selectedContext.	self resetContext: interruptedProcess stepToSendOrReturn.! !!CDebugger methodsFor: 'context stack menu' stamp: 'md 4/20/2004 14:14'!stackListMenu	"Set up the menu appropriately for the context-stack-list"	| menu subMenu |	menu := CMenu new.	menu add: 'fullStack (f)' target: self action: #fullStack.	menu add: 'restart (r)' target: self action: #restart.	menu add: 'proceed (p)' target: self action: #proceed.		menu add: 'step (t)' target: self action: #doStep.		menu add: 'step through (T)' target: self action: #stepIntoBlock.		menu add: 'send (e)' target: self action: #send.		menu add: 'where (w)' target: self action: #where.		menu add: 'peel to first like this' target: self action: #peelToFirst.		menu addSeparator.	menu add: 'senders of... (n)' target: self action: #browseSendersOfMessages.	menu add: 'implementors of... (m)' target: self action: #browseMessages.	menu add: 'inheritance (i)' target: self action: #methodHierarchy.	menu add: 'versions (v)' target: self action: #browseVersions.	menu addSeparator.	menu add: 'inst var refs...' target: self action: #browseInstVarRefs.	menu add: 'class var refs...' target: self action: #browseClassVarRefs.	menu add: 'class variables' target: self action:  #browseClassVariables.	menu add: 'class refs (N)' target: self action: #browseClassRefs.	menu addSeparator.	menu add: 'browse full (b)' target: self action: #browseMethodFull.	menu add: 'file out' target: self action: #fileOutMessage.		menu add: 'mail out bug report' target: self action: #mailOutBugReport.	menu addSeparator.	menu add: 'more...' subMenu: (subMenu := CMenu new).		subMenu add: 'browse class hierarchy' target: self action: #classHierarchy.	subMenu add: 'browse class' target: self action: #browseClass.	subMenu add: 'browse method (O)' target: self action: #openSingleMessageBrowser.	subMenu add: 'implementors of sent messages' target: self action: #browseAllMessages.	subMenu add: 'change sets with this method' target: self action: #findMethodInChangeSets.	subMenu addSeparator.	subMenu add: 'inspect instances' target: self action: #inspectInstances.	subMenu add: 'inspect subinstances' target: self action: #inspectSubInstances.	subMenu addSeparator.	subMenu add: 'revert to previous version' target: self action: #revertToPreviousVersion.	subMenu add: 'remove from current change set' target: self action: #removeFromCurrentChanges.	subMenu add: 'revert & remove from changes' target: self action: #revertAndForget.		^menu ! !!CDebugger methodsFor: 'context stack menu' stamp: 'md 4/28/2004 16:16'!stepIntoBlock	"Send messages until you return to the present method context.	 Used to step into a block in the method."		interruptedProcess stepToHome: self selectedContext.	self resetContext: interruptedProcess stepToSendOrReturn.! !!CDebugger methodsFor: 'context stack menu' stamp: 'md 4/6/2004 16:26'!up	"move up the context stack to the next (enclosed) context"	contextStackIndex > 1 ifTrue: [self toggleContextStackIndex: contextStackIndex-1]! !!CDebugger methodsFor: 'context stack menu' stamp: 'md 4/28/2004 16:17'!where	"Select the expression whose evaluation was interrupted."	selectingPC _ true.	self contextStackIndex: contextStackIndex oldContextWas: self selectedContext! !!CDebugger methodsFor: 'events - buttons' stamp: 'md 4/28/2004 16:14'!onDoStepButton	<on: fire in: doStepButton>	self doStep.! !!CDebugger methodsFor: 'events - buttons' stamp: 'md 4/28/2004 16:19'!onFullStackButton	<on: fire in: fullStackButton>	self fullStack.! !!CDebugger methodsFor: 'events - buttons' stamp: 'md 4/28/2004 16:13'!onProceedButton	<on: fire in: proceedButton>	self proceed.! !!CDebugger methodsFor: 'events - buttons' stamp: 'md 4/28/2004 16:13'!onRestartButton	<on: fire in: restartButton>	self restart.! !!CDebugger methodsFor: 'events - buttons' stamp: 'md 4/28/2004 16:14'!onSendButton	<on: fire in: sendButton>	self send.! !!CDebugger methodsFor: 'events - buttons' stamp: 'md 4/28/2004 16:16'!onStepIntoBlockButton	<on: fire in: stepIntoBlockButton>	self stepIntoBlock! !!CDebugger methodsFor: 'events - buttons' stamp: 'md 4/28/2004 16:17'!onWhereButton	<on: fire in: whereButton>	self where.! !!CDebugger methodsFor: 'events - lists' stamp: 'md 4/28/2004 11:01'!onContextVariableInspectorListChanged	"Update the class list when the system category list's cursor changes"	<on: cursorChanged in: contextVariableInspectorList> 	self contextVariableInspectorUpdate.! !!CDebugger methodsFor: 'events - lists' stamp: 'md 4/28/2004 11:33'!onListCursorChanged	| oldContext |	"Update the class list when the system category list's cursor changes"	<on: cursorChanged in: stackListPane> 	oldContext _ self selectedContext.	contextStackIndex := stackListPane selectionIndex.	self contextStackIndex: contextStackIndex oldContextWas: oldContext.	self signal: #updateCodePane.	receiverInspectorList contents: receiverInspector fieldList.	contextVariableInspectorList contents: contextVariablesInspector fieldList.	! !!CDebugger methodsFor: 'events - lists' stamp: 'md 4/28/2004 11:02'!onReceiverInspectorListChanged	"Update the class list when the system category list's cursor changes"	<on: cursorChanged in: receiverInspectorList> 	self receiverInspectorUpdate.! !!CDebugger methodsFor: 'events' stamp: 'md 4/28/2004 17:52'!onAcceptCodePane	"Update the class list when the system category list's cursor changes"	<on: save in: codePane> 	self contents: codePane contents notifying: nil 	! !!CDebugger methodsFor: 'events' stamp: 'md 4/28/2004 12:24'!onUpdateCodePane	| sel |	"Update the contents of the code pane"	<on: updateCodePane>		"(contextStackIndex > 1) ifTrue: ["			sel := self contentsSelection.			codePane selectFrom: sel first to: (sel last + 1).	"]"! !!CDebugger methodsFor: 'events' stamp: 'md 4/28/2004 11:48'!onUpdateContextStackList	<on: updateContextStackList>	stackListPane contents: self contextStackList.! !!CDebugger methodsFor: 'events' stamp: 'md 4/28/2004 11:08'!onUpdateWindowLabel	<on: updateWindowLabel>	window label: self labelString.! !!CDebugger methodsFor: 'events' stamp: 'ar 7/19/2004 18:59'!onWindowCloseRequest	<on: closeRequest in: window>	self abort.	window destroy. "bye, bye"! !!CDebugger methodsFor: 'events' stamp: 'ar 7/29/2004 22:00'!onWindowColorChanged: newColor	super onWindowColorChanged: newColor.	self debuggerButtons do:[:each| each windowColor: newColor].! !!CDebugger methodsFor: 'field-access' stamp: 'md 4/9/2004 14:50'!contextVariableInspectorContents	"Answer the contextVariableInspectorContents of the receiver"	<bewareOf: #contextVariableInspectorContentsChanged>	^self propertyValueAt: #contextVariableInspectorContents! !!CDebugger methodsFor: 'field-access' stamp: 'md 4/9/2004 14:50'!contextVariableInspectorContents: aValue	"Modify the receiver's contextVariableInspectorContents"	^self propertyValueAt: #contextVariableInspectorContents put: aValue with: #contextVariableInspectorContentsChanged! !!CDebugger methodsFor: 'field-access' stamp: 'md 4/9/2004 14:50'!contextVariableInspectorList	"Answer the contextVariableInspectorList of the receiver"	<bewareOf: #contextVariableInspectorListChanged>	^self propertyValueAt: #contextVariableInspectorList! !!CDebugger methodsFor: 'field-access' stamp: 'md 4/9/2004 14:50'!contextVariableInspectorList: aValue	"Modify the receiver's contextVariableInspectorList"	^self propertyValueAt: #contextVariableInspectorList put: aValue with: #contextVariableInspectorListChanged! !!CDebugger methodsFor: 'field-access' stamp: 'md 4/6/2004 16:26'!contextVariablesInspector	"Answer the instance of Inspector that is providing a view of the 	variables of the selected context."	^contextVariablesInspector! !!CDebugger methodsFor: 'field-access' stamp: 'md 4/27/2004 16:33'!doStepButton	"Answer the doStepButton of the receiver"	<bewareOf: #doStepButtonChanged>	^self propertyValueAt: #doStepButton! !!CDebugger methodsFor: 'field-access' stamp: 'md 4/27/2004 16:33'!doStepButton: aValue	"Modify the receiver's doStepButton"	^self propertyValueAt: #doStepButton put: aValue with: #doStepButtonChanged! !!CDebugger methodsFor: 'field-access' stamp: 'md 4/27/2004 16:33'!fullStackButton	"Answer the fullStackButton of the receiver"	<bewareOf: #fullStackButtonChanged>	^self propertyValueAt: #fullStackButton! !!CDebugger methodsFor: 'field-access' stamp: 'md 4/27/2004 16:33'!fullStackButton: aValue	"Modify the receiver's fullStackButton"	^self propertyValueAt: #fullStackButton put: aValue with: #fullStackButtonChanged! !!CDebugger methodsFor: 'field-access' stamp: 'md 4/27/2004 16:32'!proceedButton	"Answer the proceedButton of the receiver"	<bewareOf: #proceedButtonChanged>	^self propertyValueAt: #proceedButton! !!CDebugger methodsFor: 'field-access' stamp: 'md 4/27/2004 16:32'!proceedButton: aValue	"Modify the receiver's proceedButton"	^self propertyValueAt: #proceedButton put: aValue with: #proceedButtonChanged! !!CDebugger methodsFor: 'field-access' stamp: 'md 4/9/2004 14:49'!receiverInspectorContents	"Answer the receiverInspectorContents of the receiver"	<bewareOf: #receiverInspectorContentsChanged>	^self propertyValueAt: #receiverInspectorContents! !!CDebugger methodsFor: 'field-access' stamp: 'md 4/9/2004 14:49'!receiverInspectorContents: aValue	"Modify the receiver's receiverInspectorContents"	^self propertyValueAt: #receiverInspectorContents put: aValue with: #receiverInspectorContentsChanged! !!CDebugger methodsFor: 'field-access' stamp: 'md 4/9/2004 14:49'!receiverInspectorList	"Answer the receiverInspectorList of the receiver"	<bewareOf: #receiverInspectorListChanged>	^self propertyValueAt: #receiverInspectorList! !!CDebugger methodsFor: 'field-access' stamp: 'md 4/9/2004 14:49'!receiverInspectorList: aValue	"Modify the receiver's receiverInspectorList"	^self propertyValueAt: #receiverInspectorList put: aValue with: #receiverInspectorListChanged! !!CDebugger methodsFor: 'field-access' stamp: 'md 4/27/2004 16:32'!restartButton	"Answer the restartButton of the receiver"	<bewareOf: #restartButtonChanged>	^self propertyValueAt: #restartButton! !!CDebugger methodsFor: 'field-access' stamp: 'md 4/27/2004 16:32'!restartButton: aValue	"Modify the receiver's restartButton"	^self propertyValueAt: #restartButton put: aValue with: #restartButtonChanged! !!CDebugger methodsFor: 'field-access' stamp: 'md 4/27/2004 16:32'!sendButton	"Answer the sendButton of the receiver"	<bewareOf: #sendButtonChanged>	^self propertyValueAt: #sendButton! !!CDebugger methodsFor: 'field-access' stamp: 'md 4/27/2004 16:32'!sendButton: aValue	"Modify the receiver's sendButton"	^self propertyValueAt: #sendButton put: aValue with: #sendButtonChanged! !!CDebugger methodsFor: 'field-access' stamp: 'md 4/8/2004 14:49'!stackListPane	"Answer the stackListPane of the receiver"	<bewareOf: #stackListPaneChanged>	^self propertyValueAt: #stackListPane! !!CDebugger methodsFor: 'field-access' stamp: 'md 4/8/2004 14:49'!stackListPane: aValue	"Modify the receiver's stackListPane"	^self propertyValueAt: #stackListPane put: aValue with: #stackListPaneChanged! !!CDebugger methodsFor: 'field-access' stamp: 'md 4/27/2004 16:33'!stepIntoBlockButton	"Answer the stepIntoBlockButton of the receiver"	<bewareOf: #stepIntoBlockButtonChanged>	^self propertyValueAt: #stepIntoBlockButton! !!CDebugger methodsFor: 'field-access' stamp: 'md 4/27/2004 16:33'!stepIntoBlockButton: aValue	"Modify the receiver's stepIntoBlockButton"	^self propertyValueAt: #stepIntoBlockButton put: aValue with: #stepIntoBlockButtonChanged! !!CDebugger methodsFor: 'field-access' stamp: 'md 4/27/2004 16:33'!whereButton	"Answer the whereButton of the receiver"	<bewareOf: #whereButtonChanged>	^self propertyValueAt: #whereButton! !!CDebugger methodsFor: 'field-access' stamp: 'md 4/27/2004 16:33'!whereButton: aValue	"Modify the receiver's whereButton"	^self propertyValueAt: #whereButton put: aValue with: #whereButtonChanged! !!CDebugger methodsFor: 'initialize' stamp: 'ar 7/19/2004 18:59'!abort	interruptedProcess == nil ifTrue: [^ self].	[interruptedProcess terminate] on: Error do: [].	interruptedProcess _ nil.	interruptedController _ nil.	contextStack _ nil.	contextStackTop _ nil.	receiverInspector _ nil.	contextVariablesInspector _ nil.	Smalltalk installLowSpaceWatcher.  "restart low space handler"! !!CDebugger methodsFor: 'initialize' stamp: 'md 4/6/2004 16:26'!debugAt: anInteger	self toggleContextStackIndex: anInteger. 	 ^ self debug.! !!CDebugger methodsFor: 'initialize' stamp: 'md 4/27/2004 16:42'!debuggerButtons	^{proceedButton. restartButton. sendButton. doStepButton. stepIntoBlockButton. fullStackButton. whereButton}! !!CDebugger methodsFor: 'initialize' stamp: 'md 4/6/2004 16:26'!errorWasInUIProcess: boolean	errorWasInUIProcess _ boolean! !!CDebugger methodsFor: 'initialize' stamp: 'md 4/29/2004 14:48'!initialize	super initialize.	"Define our components"		self define: #stackListPane as: CList new.	stackListPane menu: self stackListMenu.	"listPane userDataAt: #keyMap put: self fieldListKeyMap."	stackListPane allowDeselect: true.	self define: #receiverInspectorList as:  CList new.	receiverInspectorList allowDeselect: true.	self define: #receiverInspectorContents as: CTextEditor new.	self define: #contextVariableInspectorList as:  CList new.	contextVariableInspectorList allowDeselect: true.	self define: #contextVariableInspectorContents as: CTextEditor new.		    	"the buttons"	self define: #proceedButton as: CButton new.	self define: #restartButton as: CButton new.	self define: #sendButton as: CButton new.	self define: #doStepButton as: CButton new.	self define: #stepIntoBlockButton as: CButton new.	self define: #fullStackButton as: CButton new.	self define: #whereButton as: CButton new.	 	 	 	 	 		! !!CDebugger methodsFor: 'initialize' stamp: 'md 4/6/2004 16:43'!openFullNoSuspendLabel: aString	"Create and schedule a full debugger with the given label. Do not terminate the current active process."	self openFullLabel: aString.	errorWasInUIProcess _ CurrentProjectRefactoring newProcessIfUI: interruptedProcess.! !!CDebugger methodsFor: 'initialize' stamp: 'ar 7/29/2004 21:30'!setupCostume	"Create the default costume"	| row |	window player: self.	window extent:  600@400.	window layout: CProportionalLayout new.	stackListPane costume: CStringListCostume new.	stackListPane color: Color transparent.	stackListPane layoutFrame: (0@0 corner: 1@0.25).	window add: stackListPane.	proceedButton label: 'Proceed'.	restartButton label: 'Restart'.	sendButton label: 'Send'.		doStepButton label: 'Step'.	stepIntoBlockButton label: 'Through'.	fullStackButton label: 'Full Stack'.	whereButton label: 'Where'.	self debuggerButtons do:[:button|		button hResizing: #spaceFill. "vResizing: #shrinkWrap."		button roundCorners: true.		button height: 20.	].	row := CPlayer new.	row layout: CTableLayout new.	row layoutFrame: (0@0.25 corner: 1@0.25).	row layout listDirection: #leftToRight; layoutInset: 2; cellInset: 2.	row hResizing: #spaceFill; vResizing: #spaceFill.	self debuggerButtons do: [:button | row add: button].	window add: row.	codePane color: Color transparent.	codePane layoutFrame: (CLayoutFrame fractions: (0@0.25 corner: 1@0.8) offsets: (0@26 extent: 0@-26)).	codePane hResizing: #spaceFill; vResizing: #spaceFill.	codePane textWrap: true.	codePane hScrollable: false; vScrollable: true.	window add: codePane.	receiverInspectorList costume: CStringListCostume new.	receiverInspectorList color: Color transparent.	receiverInspectorList layoutFrame: (0.0@0.8 corner: 0.25@1).	window add: receiverInspectorList.		receiverInspectorContents color: Color transparent.	receiverInspectorContents layoutFrame: (0.25@0.8 corner: 0.5@1).	receiverInspectorContents hResizing: #spaceFill; vResizing: #spaceFill.	receiverInspectorContents textWrap: true.	receiverInspectorContents hScrollable: false; vScrollable: true.	window add: receiverInspectorContents.	contextVariableInspectorList costume: CStringListCostume new.	contextVariableInspectorList color: Color transparent.	contextVariableInspectorList layoutFrame: (0.5@0.8 corner: 0.75@1).	window add: contextVariableInspectorList.	contextVariableInspectorContents color: Color transparent.	contextVariableInspectorContents layoutFrame: (0.75@0.8 corner: 1@1).	contextVariableInspectorContents hResizing: #spaceFill; vResizing: #spaceFill.	contextVariableInspectorContents textWrap: true.	contextVariableInspectorContents hScrollable: false; vScrollable: true.	window add: contextVariableInspectorContents.	"Give all of my contents the default look"	window elements do:[:each|		each borderWidth: 2.		each borderStyle: #complexAltInset.		each borderColor: (Color r: 0.995 g: 0.788 b: 0.353).		each windowColor:  (Color r: 0.652 g: 0.8 b: 0.504).	].	window color:  (Color r: 0.652 g: 0.8 b: 0.504).! !!CDebugger methodsFor: 'inspectors' stamp: 'md 4/28/2004 11:01'!contextVariableInspectorUpdate	contextVariablesInspector selectionIndex: (contextVariableInspectorList contents indexOf: contextVariableInspectorList selection).	contextVariableInspectorContents contents: contextVariablesInspector selection.! !!CDebugger methodsFor: 'inspectors' stamp: 'md 4/28/2004 11:01'!receiverInspectorUpdate	receiverInspector selectionIndex: (receiverInspectorList contents indexOf: receiverInspectorList selection).	receiverInspectorContents contents: receiverInspector selection.! !!CDebugger methodsFor: 'inspectors' stamp: 'md 4/28/2004 15:59'!updateInspectors	self contextVariableInspectorUpdate.	self receiverInspectorUpdate.! !!CDebugger methodsFor: 'menu notifier' stamp: 'md 4/28/2004 15:07'!debug	"Open a full DebuggerView."		self signal: #updateContextStackList.	self open.! !!CDebugger methodsFor: 'message category list' stamp: 'md 4/6/2004 16:26'!selectedMessageCategoryName	"Answer the name of the message category of the message of the 	currently selected context."	^self selectedClass organization categoryOfElement: self selectedMessageName! !!CDebugger methodsFor: 'private' stamp: 'md 4/6/2004 16:26'!checkContextSelection	contextStackIndex = 0 ifTrue: [contextStackIndex _ 1]! !!CDebugger methodsFor: 'private' stamp: 'md 4/28/2004 12:02'!contextStackIndex: anInteger oldContextWas: oldContext	| newMethod |	contextStackIndex _ anInteger.	anInteger = 0		ifTrue:			[theMethodNode _ tempNames _ sourceMap _ nil.			self contents: ''.			contextVariablesInspector object: nil.			receiverInspector object: self receiver.			^self].	(newMethod _ oldContext == nil or:		[oldContext method ~~ self selectedContext method] or: [theMethodNode == nil] )		ifTrue:			[tempNames _ sourceMap _ nil.			theMethodNode _ self selectedContext methodNode.			self contents: self selectedMessageText.			self pcRange "will compute tempNamesunless noFrills"].	tempNames == nil		ifTrue: [tempNames _ 					self selectedClassOrMetaClass parserClass new parseArgsAndTemps: self contents notifying: nil].	contextVariablesInspector object: self selectedContext.	receiverInspector object: self receiver.	newMethod ifFalse: [self signal: #updateCodePane]! !!CDebugger methodsFor: 'private' stamp: 'md 4/6/2004 16:26'!externalInterrupt: aBoolean	externalInterrupt _ aBoolean ! !!CDebugger methodsFor: 'private' stamp: 'md 4/6/2004 16:26'!isolationRecoveryAdvice	"Return a notifier message string to be presented in case of recovery from recursive error by revoking the changes in an isolation layer.  This surely ranks as one of Squeak's longer help messages."	^ 'Warning!! You have encountered a recursive error situation.Don''t panic, but do read the following advice.  If you were just fooling around, the simplest thing to do is to quit and NOT save, and restart Squeak.  If you care about recovery, then read on...In the process of diagnosing one error, further errors occurred, making it impossible to give you a debugger to work with.  Squeak has jumped to an outer project where many of the objects and code changes that might have caused this problem are not involved in normal operation.  If you are looking at this window, chances are that this first level of recovery was successful.  If there are changes you care a lot about, try to save them now.  Then, hopefully, from the state in this debugger, you can determine what the problem was and fix it.  Do not save this image until you are confident of its recovery.You are no longer in the world that is damaged.  The two most likely causes of recursive errors are malformed objects (for instance a corrupt value encountered in any display of the desktop) and recurring code errors (such as a change that causes errors in any attempt to display the desktop).In the case of malformed objects, you can attempt to repair them by altering various bindings in the corrupted environment.  Open this debugger and examine the state of the objects closest to the error.In the case of code errors, note that you are no longer in a world where the erroneous code is in effect.  The only simple option available is for you to browse to the changeSet for the project in distress, and remove one or more of the changes (later it will be possible to edit the code remotely from here).If you feel you have repaired the problem, then you may proceed from this debugger.  This will put you back in the project that failed with the changes that failed for another try.  Note that the debugger from which you are proceeding is the second one that occurred;  you will likely find the first one waiting for you when you reenter the failed project!!  Also note that if your error occurred while displaying a morph, it may now be flagged as undisplayable (red with yellow cross);  if so, use the morph debug menu to choose ''start drawing again''.If you have not repaired the problem, you should close this debugger and delete the failed project after retrieving whatever may be of value in it.Good luck.	- The Squeak Fairy GodmotherPS:  If you feel you need the help of a quantum mechanic, do NOT close this window.  Instead, the best thing to do (after saving anything that seems safe to save) would be to use the ''save as...'' command in the world menu, and give it a new image name, such as OOPS.  There is a good chance that someone who knows their way around Squeak can help you out.'! !!CDebugger methodsFor: 'private' stamp: 'md 4/6/2004 16:26'!lowSpaceChoices	"Return a notifier message string to be presented when space is running low."	^ 'Warning!! Squeak is almost out of memory!!Low space detection is now disabled. It will be restored when you close or proceed from this error notifier. Don''t panic, but do proceed with caution.Here are some suggestions: If you suspect an infinite recursion (the same methods calling each other again and again), then close this debugger, and fix the problem. If you want this computation to finish, then make more space available (read on) and choose "proceed" in this debugger. Here are some ways to make more space available...   > Close any windows that are not needed.   > Get rid of some large objects (e.g., images).   > Leave this window on the screen, choose "save as..." from the screen menu, quit, restart the Squeak VM with a larger memory allocation, then restart the image you just saved, and choose "proceed" in this window. If you want to investigate further, choose "debug" in this window.  Do not use the debugger "fullStack" command unless you are certain that the stack is not very deep. (Trying to show the full stack will definitely use up all remaining memory if the low-space problem is caused by an infinite recursion!!).'! !!CDebugger methodsFor: 'private' stamp: 'md 4/6/2004 16:26'!newStack: stack	| oldStack diff |	oldStack _ contextStack.	contextStack _ stack.	(oldStack == nil or: [oldStack last ~~ stack last])		ifTrue: [contextStackList _ contextStack collect: [:ctx | ctx printString].				^ self].	"May be able to re-use some of previous list"	diff _ stack size - oldStack size.	contextStackList _ diff <= 0		ifTrue: [contextStackList copyFrom: 1-diff to: oldStack size]		ifFalse: [diff > 1				ifTrue: [contextStack collect: [:ctx | ctx printString]]				ifFalse: [(Array with: stack first printString) , contextStackList]]! !!CDebugger methodsFor: 'private' stamp: 'md 4/6/2004 16:26'!process: aProcess controller: aController context: aContext	^ self process: aProcess controller: aController context: aContext isolationHead: nil! !!CDebugger methodsFor: 'private' stamp: 'md 4/28/2004 11:52'!process: aProcess controller: aController context: aContext isolationHead: projectOrNil	Smalltalk at: #MessageTally ifPresentAndInMemory: [:c | c new close].	interruptedProcess _ aProcess.	interruptedController _ aController.	contextStackTop _ aContext.	self newStack: (contextStackTop stackOfSize: 1).	contextStackIndex _ 1.	externalInterrupt _ false.	selectingPC _ true.	isolationHead _ projectOrNil.	"Smalltalk isMorphic ifTrue:		[errorWasInUIProcess _ false]."! !!CDebugger methodsFor: 'private' stamp: 'md 4/28/2004 11:52'!resetContext: aContext 	"Used when a new context becomes top-of-stack, for instance when the	method of the selected context is re-compiled, or the simulator steps or	returns to a new method. There is room for much optimization here, first	to save recomputing the whole stack list (and text), and secondly to avoid	recomposing all that text (by editing the paragraph instead of recreating it)."	| oldContext |	oldContext _ self selectedContext.	contextStackTop _ aContext.	self newStack: contextStackTop contextStack.	self signal: #updateContextStackList.	self contextStackIndex: 1 oldContextWas: oldContext.	self signal: #updateCodePane.! !!CDebugger methodsFor: 'private' stamp: 'ar 7/19/2004 19:02'!resumeProcess: aTopView 	savedCursor		ifNotNil: [Sensor currentCursor: savedCursor].	isolationHead		ifNotNil: [failedProject enterForEmergencyRecovery.			isolationHead invoke.			isolationHead _ nil].	interruptedProcess isTerminated ifFalse: [interruptedProcess resume].	"if old process was terminated, just terminate current one"	interruptedProcess _ nil.	"Before delete, so release doesn't terminate it"	aTopView close.		"Smalltalk isMorphic		ifTrue: [aTopView close.			World displayWorld]		ifFalse: [aTopView controller closeAndUnscheduleNoErase]."	Smalltalk installLowSpaceWatcher.	"restart low space handler"	errorWasInUIProcess == false		ifFalse: [Processor terminateActive]! !!CDebugger methodsFor: 'private' stamp: 'md 4/6/2004 16:26'!selectedContext	contextStackIndex = 0		ifTrue: [^contextStackTop]		ifFalse: [^contextStack at: contextStackIndex]! !!CFieldReference methodsFor: 'accessing' stamp: 'ar 3/11/2004 14:12'!fieldName	^self fieldDefinition name! !!CFieldReference methodsFor: 'accessing' stamp: 'bf 3/30/2004 14:02'!fieldName: aString	self fieldDefinition: (self target class fieldNamed: aString).	^aString! !!CFieldReference methodsFor: 'accessing' stamp: 'ar 9/24/2003 13:53'!name	^(self propertyValueAt: #name) ifNil:[target name,'''s ', fieldDefinition name].! !!CFieldReference methodsFor: 'accessing' stamp: 'ar 3/11/2003 19:14'!readValue	^target getField: fieldDefinition! !!CFieldReference methodsFor: 'accessing' stamp: 'ar 3/28/2004 23:36'!target	<bewareOf: #targetChanged>	^target! !!CFieldReference methodsFor: 'accessing' stamp: 'ar 9/8/2004 16:22'!target: aTarget	target == aTarget ifTrue:[^aTarget].	self stopScript: #onUpdateFromTarget.	self signalChanged: #targetChanged from: target to: aTarget.	target := aTarget.	self onTargetChanged.	^aTarget! !!CFieldReference methodsFor: 'accessing' stamp: 'ar 3/17/2004 17:17'!value	^value! !!CFieldReference methodsFor: 'accessing' stamp: 'ar 3/17/2004 19:22'!value: newValue	"Modify the receiver's value"	^self privateSetValueTo: newValue! !!CFieldReference methodsFor: 'accessing' stamp: 'ar 3/19/2004 15:57'!valueType	^fieldDefinition valueType ifNil:[super valueType]! !!CFieldReference methodsFor: 'accessing' stamp: 'ar 6/22/2003 21:12'!writeValue	self isReadOnly ifTrue:[^value := self readValue].	target setField: fieldDefinition to: value.! !!CFieldReference methodsFor: 'testing' stamp: 'ar 3/12/2003 15:29'!isFieldReference	^true! !!CFieldReference methodsFor: 'testing' stamp: 'ar 6/22/2003 21:06'!isReadOnly	^fieldDefinition isReadOnly! !!CFieldReference methodsFor: 'events' stamp: 'ar 7/31/2004 17:50'!onTargetChanged	| script eventName eventVariable varDef |	target ifNil:[^self].	fieldDefinition ifNil:[^self].	eventName := fieldDefinition changeEvent.	eventVariable := nil.	self stopScript: #onUpdateFromTarget.	eventVariable ifNil:[		self startScript: #onUpdateFromTarget 			when:{target. eventName}.	] ifNotNil:[		varDef := target class bindingOf: eventVariable.		varDef ifNil:[^self].		varDef class == CFieldDefinition ifTrue:[			script := self startScript: #onUpdateFromTarget 							when: {target getField: varDef. eventName}.			script startScript: #onUpdateTrigger:from: 				when: {target. varDef changeEvent}.		] ifFalse:[			script := self startScript: #onUpdateFromTarget 							when: {varDef value. eventName}.		].	].	self onUpdateFromTarget.! !!CFieldReference methodsFor: 'events' stamp: 'ar 9/8/2004 16:22'!onUpdateFromTarget	|  aValue |	aValue := [self readValue] on: Error do:[:ex| ex return: FailToken].	aValue == FailToken ifTrue:[^self].	aValue == value ifTrue:[^self].	value := aValue.	self signalChanged: #valueChanged from: value to: aValue.! !!CFieldReference methodsFor: 'private' stamp: 'bf 3/30/2004 12:31'!fieldDefinition	<bewareOf: #fieldDefinitionChanged>	^fieldDefinition! !!CFieldReference methodsFor: 'private' stamp: 'bf 3/30/2004 12:31'!fieldDefinition: aFieldDefinition	self stopScript: #onUpdateFromTarget.	fieldDefinition := aFieldDefinition.	self signal: #fieldDefinitionChanged.	self onTargetChanged.	^fieldDefinition! !!CFieldReference methodsFor: 'private' stamp: 'ar 9/8/2004 16:22'!privateSetValueTo: aValue	"Yes, I *do* know what I'm doing here"	| oldValue |	value == aValue ifTrue:[^self].	oldValue _ value.		"must come before any other action"	myPlayer ifNotNil:[myPlayer value: aValue].	self signalChanged: #valueChanged from: value to: aValue.	value := aValue.	[		self writeValue.		"Notify any interested parties that we pushed a new value to our target"		self signal: #valueSaved with: self.		"Note: the error handler will prevent any clients 		to hear #valueSaved unless it was successful."		target tweaked: fieldDefinition toSet from: oldValue to: value.	"record the tweak"	] on: Error do:[:ex| ex return].	^aValue! !!CFileDialog methodsFor: 'initialize' stamp: 'ar 3/12/2004 20:42'!defaultCostume	^CFileDialogCostume! !!CFileDialog methodsFor: 'initialize' stamp: 'ar 3/13/2004 16:28'!defaultLabel	^self class name allButFirst! !!CFileDialog methodsFor: 'initialize' stamp: 'ar 3/12/2004 23:21'!fileSpec: patternList	| pattern |	filePatternList removeAll.	patternList do:[:spec|		pattern := CFileDialogPattern new.		pattern description: spec first.		pattern patterns: spec last.		filePatternList add: pattern.	].	filePatternList cursor: 1.! !!CFileDialog methodsFor: 'initialize' stamp: 'ar 4/3/2004 13:54'!initialize	super initialize.	showDirectories := true.	self define: #filePatternList as: CCollection new.	self define: #fileList as: CCollection new.	rootDirectories := FileDirectory root directories.	fileName := ''.	self sorter: CFileDialogSorter new.	self showDirectories: true.	directory := FileDirectory default.! !!CFileDialog methodsFor: 'accessing' stamp: 'ar 3/12/2004 20:30'!directory	"Answer the directory of the receiver"	<bewareOf: #directoryChanged>	^self propertyValueAt: #directory! !!CFileDialog methodsFor: 'accessing' stamp: 'ar 3/12/2004 20:30'!directory: aValue	"Modify the receiver's directory"	^self propertyValueAt: #directory put: aValue with: #directoryChanged! !!CFileDialog methodsFor: 'accessing' stamp: 'ar 3/12/2004 20:28'!fileList	"Answer the fileList of the receiver"	<bewareOf: #fileListChanged>	^self propertyValueAt: #fileList! !!CFileDialog methodsFor: 'accessing' stamp: 'ar 3/12/2004 20:28'!fileList: aValue	"Modify the receiver's fileList"	^self propertyValueAt: #fileList put: aValue with: #fileListChanged! !!CFileDialog methodsFor: 'accessing' stamp: 'ar 3/12/2004 20:28'!fileName	"Answer the fileName of the receiver"	<bewareOf: #fileNameChanged>	^self propertyValueAt: #fileName! !!CFileDialog methodsFor: 'accessing' stamp: 'ar 3/12/2004 20:28'!fileName: aValue	"Modify the receiver's fileName"	^self propertyValueAt: #fileName put: aValue with: #fileNameChanged! !!CFileDialog methodsFor: 'accessing' stamp: 'ar 3/12/2004 20:37'!filePatternList	"Answer the filePatternList of the receiver"	<bewareOf: #filePatternListChanged>	^self propertyValueAt: #filePatternList! !!CFileDialog methodsFor: 'accessing' stamp: 'ar 3/12/2004 20:37'!filePatternList: aValue	"Modify the receiver's filePatternList"	^self propertyValueAt: #filePatternList put: aValue with: #filePatternListChanged! !!CFileDialog methodsFor: 'accessing' stamp: 'ar 3/12/2004 22:58'!fullName	"Answer the fullName of the receiver"	<bewareOf: #fullNameChanged>	^self propertyValueAt: #fullName! !!CFileDialog methodsFor: 'accessing' stamp: 'ar 3/12/2004 22:58'!fullName: aValue	"Modify the receiver's fullName"	^self propertyValueAt: #fullName put: aValue with: #fullNameChanged! !!CFileDialog methodsFor: 'accessing' stamp: 'ar 3/13/2004 02:15'!rootDirectories	"Answer the rootDirectories of the receiver"	<bewareOf: #rootDirectoriesChanged>	^self propertyValueAt: #rootDirectories! !!CFileDialog methodsFor: 'accessing' stamp: 'ar 3/13/2004 02:15'!rootDirectories: aValue	"Modify the receiver's rootDirectories"	^self propertyValueAt: #rootDirectories put: aValue with: #rootDirectoriesChanged! !!CFileDialog methodsFor: 'accessing' stamp: 'ar 3/13/2004 16:26'!rootDirectory	^self rootDirectories anyOne! !!CFileDialog methodsFor: 'accessing' stamp: 'ar 3/13/2004 16:26'!rootDirectory: aDirectory	^self rootDirectories: (Array with: aDirectory)! !!CFileDialog methodsFor: 'accessing' stamp: 'ar 3/12/2004 20:37'!selectedPattern	"Answer the selectedPattern of the receiver"	<bewareOf: #selectedPatternChanged>	^self propertyValueAt: #selectedPattern! !!CFileDialog methodsFor: 'accessing' stamp: 'ar 3/12/2004 20:37'!selectedPattern: aValue	"Modify the receiver's selectedPattern"	^self propertyValueAt: #selectedPattern put: aValue with: #selectedPatternChanged! !!CFileDialog methodsFor: 'accessing' stamp: 'ar 3/12/2004 22:05'!showDirectories	"Answer the showDirectories of the receiver"	<bewareOf: #showDirectoriesChanged>	^self propertyValueAt: #showDirectories! !!CFileDialog methodsFor: 'accessing' stamp: 'ar 3/12/2004 22:05'!showDirectories: aValue	"Modify the receiver's showDirectories"	^self propertyValueAt: #showDirectories put: aValue with: #showDirectoriesChanged! !!CFileDialog methodsFor: 'accessing' stamp: 'ar 3/13/2004 02:11'!sorter	"Answer the sorter of the receiver"	<bewareOf: #sorterChanged>	^self propertyValueAt: #sorter! !!CFileDialog methodsFor: 'accessing' stamp: 'ar 3/13/2004 02:11'!sorter: aValue	"Modify the receiver's sorter"	^self propertyValueAt: #sorter put: aValue with: #sorterChanged! !!CFileDialog methodsFor: 'accessing' stamp: 'ar 3/12/2004 22:56'!window	"Answer the window of the receiver"	<bewareOf: #windowChanged>	^self propertyValueAt: #window! !!CFileDialog methodsFor: 'accessing' stamp: 'ar 3/12/2004 22:56'!window: aValue	"Modify the receiver's window"	^self propertyValueAt: #window put: aValue with: #windowChanged! !!CFileDialog methodsFor: 'events' stamp: 'ar 3/13/2004 16:01'!accept	"Accept the current file name and proceed"	| pattern newName |	fileName isEmpty ifTrue:[^self].	pattern := filePatternList selection.	pattern		ifNil:[newName := fileName asString]		ifNotNil:[newName := pattern forceMatch: fileName asString].	(self acceptFile: newName) ifFalse:[^self].	fullName := directory fullNameFor: newName.	(window ifNil:[self]) close.! !!CFileDialog methodsFor: 'events' stamp: 'ar 3/13/2004 16:05'!acceptFile: aString	"Answer whether it is okay to accept the given (local) file name."	^true! !!CFileDialog methodsFor: 'events' stamp: 'ar 3/12/2004 23:16'!cancel	"Cancel the operation"	fullName := nil.	(window ifNil:[self]) close.! !!CFileDialog methodsFor: 'events' stamp: 'ar 3/12/2004 23:08'!doubleClick: entry	entry ifNil:[^self].	entry isDirectory ifTrue:[		directory := directory directoryNamed: entry name.	] ifFalse:[		fileName := entry name.		self accept.	].! !!CFileDialog methodsFor: 'events' stamp: 'ar 3/12/2004 23:23'!onDirectoryChanged	<on: directoryChanged>	self updateFileList.! !!CFileDialog methodsFor: 'events' stamp: 'ar 3/12/2004 22:22'!onFileListCursorChanged	| entry |	<on: cursorChanged in: fileList>	entry := fileList selection.	entry ifNil:[^fileName := ''].	entry isDirectory 		ifTrue:[fileName := '']		ifFalse:[fileName := fileList selection fileName].! !!CFileDialog methodsFor: 'events' stamp: 'ar 3/13/2004 13:32'!onOpen	<on: opened>	self updateFileList.! !!CFileDialog methodsFor: 'events' stamp: 'ar 3/25/2004 11:22'!onPatternChanged	<on: cursorChanged in: filePatternList>	self onDirectoryChanged.! !!CFileDialog methodsFor: 'events' stamp: 'ar 3/14/2004 02:32'!updateFileList	| list pattern item |	self isOpen ifFalse:[^self].	pattern := filePatternList selection ifNil:['*'].	directory ifNil:[^fileList contents: #()].	[Cursor wait showWhile:[		list := directory entries asArray select:[:each| 			(pattern match: each name) or:[each isDirectory and:[showDirectories]]		].		list := list collect:[:each| 			item := CDirectoryEntry new.			item directory: directory.			item entry: each.			item].		fileList contents: (sorter sort: list).	]] on: Error do:[:ex| CDialog abortRetryDebug: ex].! !!CFileDialog methodsFor: 'sorting' stamp: 'ar 3/13/2004 14:42'!resort	fileList contents: (sorter sort: fileList contents)! !!CFileDialog methodsFor: 'sorting' stamp: 'ar 3/13/2004 02:12'!sortByDate	sorter sortByDate.	fileList contents: (sorter sort: fileList contents).! !!CFileDialog methodsFor: 'sorting' stamp: 'ar 3/13/2004 02:12'!sortByName	sorter sortByName.	fileList contents: (sorter sort: fileList contents).! !!CFileDialog methodsFor: 'sorting' stamp: 'ar 3/13/2004 02:12'!sortBySize	sorter sortBySize.	fileList contents: (sorter sort: fileList contents).! !!CFileDialog methodsFor: 'sorting' stamp: 'ar 3/13/2004 02:12'!sortByType	sorter sortByType.	fileList contents: (sorter sort: fileList contents).! !!CFileDialog methodsFor: 'opening' stamp: 'ar 3/13/2004 16:51'!openFile	^self openFile: #()! !!CFileDialog methodsFor: 'opening' stamp: 'ar 3/13/2004 16:29'!openFile: fileSpec	^self openFile: fileSpec label: nil! !!CFileDialog methodsFor: 'opening' stamp: 'ar 3/13/2004 16:51'!openFile: fileSpec label: aString	self fileSpec: fileSpec.	^self openLabel: aString.! !!CFileDialog methodsFor: 'opening' stamp: 'ar 4/3/2004 13:54'!openLabel: label	"Run the file dialog"	self define: #window as: CWindow new.	window player: self.	window maximizeBox: false.	window minimizeBox: false.	window label: (label ifNil:[self defaultLabel]).	window floating: true.	window extent: self extent.	window add: self.	window openCenteredAt: self hand world center..	window waitUntil: #closed.	^self fullName! !!CFileDialogCostume methodsFor: 'initialize' stamp: 'ar 3/12/2004 20:44'!defaultPlayer	^CFileDialog! !!CFileDialogCostume methodsFor: 'initialize' stamp: 'ar 3/17/2004 03:12'!initialize	super initialize.	self define: #directoryList as: CTreeWidget new.	self define: #fileList as: CMultiColumnList new.	self define: #inputField as: CInputField new.	self define: #patternList as: CTabButtonList new.	self define: #okButton as: CPushButton new.	self define: #cancelButton as: CPushButton new.	fileList addColumn: 'Name' for: self		width: 160 color: CWidgetLibrary default noColor		action: nil draw: #drawName:in:on:font:color:.	fileList addColumn: 'Size' for: self		width: 70 color: CWidgetLibrary default paneColor		action: nil draw: #drawSize:in:on:font:color:.	fileList addColumn: 'Type' for: self		width: 60 color: CWidgetLibrary default noColor		action: nil draw: #drawType:in:on:font:color:.	fileList addColumn:'Date' for: self		width: 130 color: CWidgetLibrary default paneColor		action: nil draw: #drawDate:in:on:font:color:.! !!CFileDialogCostume methodsFor: 'initialize' stamp: 'ar 4/30/2004 15:50'!setupFileOpenCostume	| row |	self color: Color transparent.	self extent: 700@450.	self layout: CTableLayout new.	self hResizing: #spaceFill; vResizing: #spaceFill.	self layout layoutInset: 4.	self add: patternList.	row := CPlayer new.	row color: Color white.	row layout: CTableLayout new.	row layout listDirection: #leftToRight; cellInset: 2.	row hResizing: #spaceFill; vResizing: #spaceFill.	directoryList color: Color transparent.	directoryList hResizing: #rigid; vResizing: #spaceFill.	directoryList width: 200.	directoryList borderWidth: 1.	directoryList borderStyle: #simple.	directoryList borderColor: CWidgetLibrary default frameColor.	row add: directoryList.	fileList allowDeselect: false.	fileList color: Color transparent.	fileList borderWidth: 1.	fileList borderStyle: #simple.	fileList borderColor: CWidgetLibrary default frameColor.	row add: fileList.	self add: row.	okButton label: 'OK'.	cancelButton label: 'Cancel'.	{okButton. cancelButton} do:[:button|		button extent: 100@30.		button roundCorners: true.		button borderStyle: #simple.		button borderColor: CWidgetLibrary default frameColor.	].	row := CPlayer new.	row layout: CTableLayout new.	row layout listDirection: #leftToRight; layoutInset: 2; cellInset: 2.	row hResizing: #spaceFill; vResizing: #shrinkWrap.	row layout listCentering: #center.	row add: okButton.	row add: cancelButton.	self add: row.! !!CFileDialogCostume methodsFor: 'initialize' stamp: 'ar 4/30/2004 15:50'!setupFileSaveCostume	| row |	self color: Color transparent.	self extent: 400@250.	self layout: CTableLayout new.	self layout layoutInset: 4.	self add: patternList.	row := CPlayer new.	row color: Color white.	row layout: CTableLayout new.	row layout listDirection: #leftToRight; cellInset: 2.	row hResizing: #spaceFill; vResizing: #spaceFill.	directoryList color: Color transparent.	directoryList hResizing: #rigid; vResizing: #spaceFill.	directoryList width: 200.	directoryList borderWidth: 1.	directoryList borderStyle: #simple.	directoryList borderColor: CWidgetLibrary default frameColor.	directoryList visible: false.	row add: directoryList.	fileList allowDeselect: false.	fileList color: Color transparent.	fileList borderWidth: 1.	fileList borderStyle: #simple.	fileList borderColor: CWidgetLibrary default frameColor.	row add: fileList.	self add: row.	inputField allowEditing: true.	inputField borderColor: CWidgetLibrary default frameColor.	self add: inputField.	okButton label: 'OK'.	cancelButton label: 'Cancel'.	{okButton. cancelButton} do:[:button|		button extent: 100@30.		button roundCorners: true.		button borderStyle: #simple.		button borderColor: CWidgetLibrary default frameColor.	].	row := CPlayer new.	row layout: CTableLayout new.	row layout listDirection: #leftToRight; layoutInset: 2; cellInset: 2.	row hResizing: #spaceFill; vResizing: #shrinkWrap.	row layout listCentering: #center.	row add: okButton.	row add: cancelButton.	self add: row.! !!CFileDialogCostume methodsFor: 'accessing' stamp: 'ar 3/12/2004 20:43'!cancelButton	"Answer the cancelButton of the receiver"	<bewareOf: #cancelButtonChanged>	^self propertyValueAt: #cancelButton! !!CFileDialogCostume methodsFor: 'accessing' stamp: 'ar 3/12/2004 20:43'!cancelButton: aValue	"Modify the receiver's cancelButton"	^self propertyValueAt: #cancelButton put: aValue with: #cancelButtonChanged! !!CFileDialogCostume methodsFor: 'accessing' stamp: 'ar 3/12/2004 20:43'!directoryList	"Answer the directoryList of the receiver"	<bewareOf: #directoryListChanged>	^self propertyValueAt: #directoryList! !!CFileDialogCostume methodsFor: 'accessing' stamp: 'ar 3/12/2004 20:43'!directoryList: aValue	"Modify the receiver's directoryList"	^self propertyValueAt: #directoryList put: aValue with: #directoryListChanged! !!CFileDialogCostume methodsFor: 'accessing' stamp: 'ar 3/12/2004 20:43'!fileList	"Answer the fileList of the receiver"	<bewareOf: #fileListChanged>	^self propertyValueAt: #fileList! !!CFileDialogCostume methodsFor: 'accessing' stamp: 'ar 3/12/2004 20:43'!fileList: aValue	"Modify the receiver's fileList"	^self propertyValueAt: #fileList put: aValue with: #fileListChanged! !!CFileDialogCostume methodsFor: 'accessing' stamp: 'ar 3/12/2004 20:43'!inputField	"Answer the inputField of the receiver"	<bewareOf: #inputFieldChanged>	^self propertyValueAt: #inputField! !!CFileDialogCostume methodsFor: 'accessing' stamp: 'ar 3/12/2004 20:43'!inputField: aValue	"Modify the receiver's inputField"	^self propertyValueAt: #inputField put: aValue with: #inputFieldChanged! !!CFileDialogCostume methodsFor: 'accessing' stamp: 'ar 3/12/2004 20:43'!okButton	"Answer the okButton of the receiver"	<bewareOf: #okButtonChanged>	^self propertyValueAt: #okButton! !!CFileDialogCostume methodsFor: 'accessing' stamp: 'ar 3/12/2004 20:43'!okButton: aValue	"Modify the receiver's okButton"	^self propertyValueAt: #okButton put: aValue with: #okButtonChanged! !!CFileDialogCostume methodsFor: 'accessing' stamp: 'ar 3/12/2004 20:43'!patternList	"Answer the patternList of the receiver"	<bewareOf: #patternListChanged>	^self propertyValueAt: #patternList! !!CFileDialogCostume methodsFor: 'accessing' stamp: 'ar 3/12/2004 20:43'!patternList: aValue	"Modify the receiver's patternList"	^self propertyValueAt: #patternList put: aValue with: #patternListChanged! !!CFileDialogCostume methodsFor: 'events' stamp: 'ar 3/26/2004 01:40'!expandDirectoryTo: aDirectory	| dir aList parent |	(aDirectory equals: directoryList selection) ifTrue:[^self].	directoryList visible ifFalse:[^self].	aDirectory ifNotNil:[		dir := aDirectory.		aList := CCollection new.		[aList add: dir.		parent := dir containingDirectory.		parent == nil or:[parent = dir]] whileFalse:[dir := parent].		directoryList expandPath: aList reversed.	].	self waitTick.	directoryList selection: aDirectory.! !!CFileDialogCostume methodsFor: 'events' stamp: 'ar 3/12/2004 22:40'!onAccept	<on: fire in: okButton>	inputField modified ifTrue:[		player fileName: inputField contents.	].	player accept.! !!CFileDialogCostume methodsFor: 'events' stamp: 'ar 3/12/2004 22:41'!onCancel	<on: fire in: cancelButton>	player cancel.! !!CFileDialogCostume methodsFor: 'events' stamp: 'ar 3/13/2004 03:22'!onDirListCursorChanged	<on: cursorChanged in: directoryList>	player directory: directoryList selection.! !!CFileDialogCostume methodsFor: 'events' stamp: 'ar 3/26/2004 01:37'!onDirectoryChanged	<on: directoryChanged in: player>	self signal: #expandDirectory.! !!CFileDialogCostume methodsFor: 'events' stamp: 'ar 3/12/2004 22:35'!onDoubleClick	<on: doubleClick in: fileList>	player doubleClick: fileList selection.! !!CFileDialogCostume methodsFor: 'events' stamp: 'ar 3/26/2004 01:40'!onExpandDirectory	<on: expandDirectory>	self waitTick.	self waitTick.	self expandDirectoryTo: player directory.! !!CFileDialogCostume methodsFor: 'events' stamp: 'ar 3/12/2004 22:39'!onFileNameChanged	<on: fileNameChanged in: player>	inputField value: player fileName.! !!CFileDialogCostume methodsFor: 'events' stamp: 'ar 3/12/2004 23:09'!onInputFieldChanged	<on: accept in: inputField>	player fileName: inputField value.	player accept.! !!CFileDialogCostume methodsFor: 'events' stamp: 'ar 3/25/2004 11:29'!onPatternChanged	<on: cursorChanged in: patternList>	player filePatternList cursor: patternList cursor.! !!CFileDialogCostume methodsFor: 'events' stamp: 'ar 3/25/2004 11:33'!onPlayerChanged	super onPlayerChanged.	self onRootDirectoriesChanged.	patternList items: player filePatternList.	patternList visible: patternList elements isEmpty not.	fileList items: player fileList.! !!CFileDialogCostume methodsFor: 'events' stamp: 'ar 3/13/2004 02:38'!onRootDirectoriesChanged	| roots |	<on: rootDirectoriesChanged in: player>	roots := player rootDirectories.	directoryList roots: roots.	self onDirectoryChanged.! !!CFileDialogCostume methodsFor: 'drawing' stamp: 'ar 3/12/2004 21:40'!drawDate: item in: itemBox on: aCanvas font: font color: aColor	| string |	string := ((Date fromSeconds: item modificationTime)					printFormat: #(2 1 3 $/ 1 1 2)) , '  ' ,				(String streamContents: [:s |					(Time fromSeconds: item modificationTime \\ 86400)						print24: true showSeconds: false on: s]).	aCanvas drawString: string in: itemBox font: font color: aColor.! !!CFileDialogCostume methodsFor: 'drawing' stamp: 'ar 3/27/2004 20:54'!drawName: item in: itemBox on: aCanvas font: font color: aColor	| icon itemHeight boxOrigin |	itemHeight := itemBox height.	icon := item icon.	boxOrigin := itemBox origin.	icon ifNotNil:[icon drawOn: aCanvas in: (boxOrigin extent: itemHeight asPoint)].	boxOrigin := boxOrigin + (itemHeight + 2 @ 0).	aCanvas drawString: item fileName in: (boxOrigin corner: itemBox corner) font: font color: aColor.! !!CFileDialogCostume methodsFor: 'drawing' stamp: 'ar 3/27/2004 20:53'!drawSize: item in: itemBox on: aCanvas font: font color: aColor	| boxOrigin boxCorner itemWidth string |	item isDirectory ifTrue:[^self].	boxOrigin := itemBox origin.	boxCorner := itemBox corner.	item fileSize > 1023 		ifTrue:[string := (item fileSize // 1024)  asStringWithCommas]		ifFalse:[string := ((item fileSize  / 1024.0) truncateTo: 0.01) printString].	string := string,' KB'.	itemWidth := font widthOfString: string.	itemWidth := itemWidth min: (boxCorner x - boxOrigin x).	boxOrigin := boxCorner x - itemWidth @ boxOrigin y.	aCanvas drawString: string in: (boxOrigin corner: boxCorner) font: font color: aColor.! !!CFileDialogCostume methodsFor: 'drawing' stamp: 'ar 3/12/2004 21:41'!drawType: item in: itemBox on: aCanvas font: font color: aColor	| string |	item isDirectory		ifTrue:[string := 'folder']		ifFalse:[string := item extension].	aCanvas drawString: string in: itemBox font: font color: aColor.! !!CFileDialogPattern methodsFor: 'initialize' stamp: 'ar 3/12/2004 20:34'!initialize	super initialize.	description := 'All files'.	patterns := #('*').! !!CFileDialogPattern methodsFor: 'accessing' stamp: 'ar 3/12/2004 20:33'!description	"Answer the description of the receiver"	<bewareOf: #descriptionChanged>	^self propertyValueAt: #description! !!CFileDialogPattern methodsFor: 'accessing' stamp: 'ar 3/12/2004 20:33'!description: aValue	"Modify the receiver's description"	^self propertyValueAt: #description put: aValue with: #descriptionChanged! !!CFileDialogPattern methodsFor: 'accessing' stamp: 'ar 3/13/2004 05:47'!displayText	^description! !!CFileDialogPattern methodsFor: 'accessing' stamp: 'ar 3/12/2004 20:33'!patterns	"Answer the patterns of the receiver"	<bewareOf: #patternsChanged>	^self propertyValueAt: #patterns! !!CFileDialogPattern methodsFor: 'accessing' stamp: 'ar 3/12/2004 20:33'!patterns: aValue	"Modify the receiver's patterns"	^self propertyValueAt: #patterns put: aValue with: #patternsChanged! !!CFileDialogPattern methodsFor: 'matching' stamp: 'ar 3/12/2004 20:35'!forceMatch: aString	"force a match between the pattern and aString"	(self match: aString) ifTrue:[^aString].	^aString, (patterns first allButFirst)! !!CFileDialogPattern methodsFor: 'matching' stamp: 'ar 3/12/2004 20:35'!match: aFilename	"Answer whether I match the given file name"	^patterns anySatisfy:[:any| any match: aFilename]! !!CFileDialogPattern methodsFor: 'printing' stamp: 'ar 3/12/2004 20:35'!printOn: aStream	description ifNotNil:[aStream nextPutAll: description].	aStream nextPutAll: ' ('.	patterns		do:[:pattern| aStream nextPutAll: pattern] 		separatedBy:[aStream nextPutAll:', '].	aStream nextPutAll: ')'.! !!CFileDialogSorter methodsFor: 'initialize' stamp: 'ar 3/13/2004 02:40'!initialize	super initialize.	self sortBySize.	self sortByName.! !!CFileDialogSorter methodsFor: 'accessing' stamp: 'ar 3/13/2004 02:06'!primarySort	"Answer the primarySort of the receiver"	<bewareOf: #primarySortChanged>	^self propertyValueAt: #primarySort! !!CFileDialogSorter methodsFor: 'accessing' stamp: 'ar 3/13/2004 02:06'!primarySort: aValue	"Modify the receiver's primarySort"	^self propertyValueAt: #primarySort put: aValue with: #primarySortChanged! !!CFileDialogSorter methodsFor: 'accessing' stamp: 'ar 3/13/2004 02:07'!secondarySort	"Answer the secondarySort of the receiver"	<bewareOf: #secondarySortChanged>	^self propertyValueAt: #secondarySort! !!CFileDialogSorter methodsFor: 'accessing' stamp: 'ar 3/13/2004 02:07'!secondarySort: aValue	"Modify the receiver's secondarySort"	^self propertyValueAt: #secondarySort put: aValue with: #secondarySortChanged! !!CFileDialogSorter methodsFor: 'sorting' stamp: 'ar 3/13/2004 02:09'!sort: aList	"Resort the elements according to new settings"	| diff |	^aList sort:[:itemA :itemB|		diff := self perform: primarySort with: itemA with: itemB.		diff = 0 ifTrue:[diff := self perform: secondarySort with: itemA with: itemB].		diff <= 0].! !!CFileDialogSorter methodsFor: 'sorting' stamp: 'ar 3/13/2004 02:10'!sortByDate	self sortBy: #compareDate:with: or: #compareDateNot:with:! !!CFileDialogSorter methodsFor: 'sorting' stamp: 'ar 3/13/2004 02:10'!sortByName	self sortBy: #compareName:with: or: #compareNameNot:with:! !!CFileDialogSorter methodsFor: 'sorting' stamp: 'ar 3/13/2004 02:10'!sortBySize	self sortBy: #compareSize:with: or: #compareSizeNot:with:! !!CFileDialogSorter methodsFor: 'sorting' stamp: 'ar 3/13/2004 02:11'!sortByType	self sortBy: #compareType:with: or: #compareTypeNot:with:! !!CFileDialogSorter methodsFor: 'testing' stamp: 'ar 3/13/2004 02:08'!isSortedByDate	^primarySort == #compareDate:with: or:[ primarySort == #compareDateNot:with:]! !!CFileDialogSorter methodsFor: 'testing' stamp: 'ar 3/13/2004 02:08'!isSortedByName	^primarySort == #compareName:with: or:[ primarySort == #compareNameNot:with:]! !!CFileDialogSorter methodsFor: 'testing' stamp: 'ar 3/13/2004 02:09'!isSortedBySize	^primarySort == #compareSize:with: or:[ primarySort == #compareSizeNot:with:]! !!CFileDialogSorter methodsFor: 'testing' stamp: 'ar 3/13/2004 02:09'!isSortedByType	^primarySort == #compareType:with: or:[ primarySort == #compareTypeNot:with:]! !!CFileDialogSorter methodsFor: 'comparing' stamp: 'ar 3/13/2004 02:07'!compareDate: a with: b	a isDirectory = b isDirectory ifFalse:[		a isDirectory ifTrue:[^-1] ifFalse:[^1]	].	^(a modificationTime - b modificationTime) sign! !!CFileDialogSorter methodsFor: 'comparing' stamp: 'ar 3/13/2004 02:07'!compareDateNot: a with: b	^self compareDate: b with: a! !!CFileDialogSorter methodsFor: 'comparing' stamp: 'ar 3/13/2004 02:07'!compareName: a with: b	a isDirectory = b isDirectory ifFalse:[		a isDirectory ifTrue:[^-1] ifFalse:[^1]	].	^(a fileName compare: b fileName) - 2! !!CFileDialogSorter methodsFor: 'comparing' stamp: 'ar 3/13/2004 02:07'!compareNameNot: a with: b	^self compareName: b with: a! !!CFileDialogSorter methodsFor: 'comparing' stamp: 'ar 3/13/2004 02:08'!compareSize: a with: b	a isDirectory = b isDirectory ifFalse:[		a isDirectory ifTrue:[^-1] ifFalse:[^1]	].	^(a fileSize - b fileSize) sign! !!CFileDialogSorter methodsFor: 'comparing' stamp: 'ar 3/13/2004 02:08'!compareSizeNot: a with: b	^self compareSize: b with: a! !!CFileDialogSorter methodsFor: 'comparing' stamp: 'ar 3/13/2004 02:08'!compareType: a with: b	a isDirectory = b isDirectory ifFalse:[		a isDirectory ifTrue:[^-1] ifFalse:[^1]	].	^(a extension compare: b extension) - 2! !!CFileDialogSorter methodsFor: 'comparing' stamp: 'ar 3/13/2004 02:08'!compareTypeNot: a with: b	^self compareType: b with: a! !!CFileDialogSorter methodsFor: 'private' stamp: 'ar 3/13/2004 02:10'!setSorter: sorter or: sorterRev	primarySort == sorter ifTrue:[^primarySort := sorterRev].	primarySort == sorterRev ifTrue:[^primarySort := sorter].	secondarySort := primarySort.	primarySort := sorter.! !!CFileDialogSorter methodsFor: 'private' stamp: 'ar 3/13/2004 02:10'!sortBy: sorter or: sorterRev	self setSorter: sorter or: sorterRev.! !!CFileOpenDialog methodsFor: 'initialize' stamp: 'ar 3/13/2004 16:50'!acceptFile: newName	"Accept an old file only"	fileList do:[:entry| entry name = newName ifTrue:[^true]].	CDialog inform: 'No such file: ', newName printString			centerAt: self globalBounds center.	^false! !!CFileOpenDialog methodsFor: 'initialize' stamp: 'ar 3/13/2004 15:50'!defaultCostume	^CFileOpenDialogCostume! !!CFileOpenDialog methodsFor: 'initialize' stamp: 'ar 3/13/2004 16:03'!initialize	super initialize.	self showDirectories: false.! !!CFileOpenDialogCostume methodsFor: 'initialize' stamp: 'ar 4/30/2004 15:50'!setupCostume	super setupCostume.	self setupFileOpenCostume.! !!CFileSaveDialog methodsFor: 'initialize' stamp: 'ar 3/13/2004 16:50'!acceptFile: newName	"Accept a new file or ask user if it is okay to overwrite"	fileList do:[:entry| entry name = newName ifTrue:[		^CDialog confirm: newName printString,' already exists.\Do you want to overwrite it?' withCRs centerAt: self globalBounds center	]].	^true! !!CFileSaveDialog methodsFor: 'initialize' stamp: 'ar 3/13/2004 15:50'!defaultCostume	^CFileSaveDialogCostume! !!CFileSaveDialog methodsFor: 'initialize' stamp: 'ar 3/13/2004 16:10'!initialize	super initialize.	self showDirectories: true.	sorter primarySort: #compareTypeNot:with:.	sorter secondarySort: #compareName:with:.! !!CFileSaveDialogCostume methodsFor: 'initialize' stamp: 'ar 4/30/2004 15:51'!setupCostume	super setupCostume.	self setupFileSaveCostume.! !!CFillStyleReadout methodsFor: 'initialize' stamp: 'ar 3/14/2004 00:26'!initialize	super initialize.	self extent: 18@18.	fillColors := {Color white. Color black}.	borderStyle := #simple.	borderWidth := 1.	borderColor := Color black.! !!CFillStyleReadout methodsFor: 'events' stamp: 'ar 3/13/2004 22:45'!deselect	borderWidth := 1.! !!CFillStyleReadout methodsFor: 'events' stamp: 'tk 6/23/2004 11:07'!onValueChanged	<on: valueChanged>	value ifNil:[^self].	self fillStyle: value.	value == #solid ifTrue: [fillColors := {Color gray: 0.75. Color black}].! !!CFillStyleReadout methodsFor: 'events' stamp: 'ar 3/13/2004 22:45'!select	borderWidth := 2.! !!CHalo methodsFor: 'initialize' stamp: 'ar 2/16/2004 21:52'!handleSpecs	^{		{ #haloDismiss. 	0.0.		0.0.		Color red muchLighter. 'x'}.		{ #haloMenu. 	0.25.	0.0.		Color red. 'm'}.		{ #haloGrab. 	0.5.		0.0.		Color black. 'g' }.		{ #haloDrag. 	0.75.	0.0.		Color brown. 'd'}.		{ #haloDup. 	1.0.		0.0.		Color green. 'u'}.		{ #haloRecolor.	1.0.		0.5.		Color magenta. 'R'}.		{ #haloSize.		1.0.		1.0.		Color yellow. 's'}.		{ #haloDebug. 	0.5.		1.0.		Color cyan muchLighter. 'D'}.		{ #haloRotate. 	0.0.		1.0.		Color blue. 'r'}.		{ #haloViewer. 	0.0.		0.5.		Color cyan. 'v'}.	}! !!CHalo methodsFor: 'initialize' stamp: 'ar 4/2/2004 14:51'!initialize	"Note: CHalo should be set to be custom draw by user, so it is possible to edit it."	| handle frame cc haloLabel |	super initialize.	self layout: CProportionalLayout new.	self multiSelections: CMultiSelectionHalo new.	self handleSpecs do:[:spec|		handle := CHaloButton new.		handle value: spec first.		frame := CLayoutFrame new.		frame leftFraction: spec second.		frame leftOffset: 32 * (spec second - 0.5) - (handle width // 2).		frame topFraction: spec third.		frame topOffset: 32 * (spec third - 0.5) - (handle height // 2).		handle layoutFrame: frame.		cc := spec fourth.		cc luminance > 0.5 ifTrue:[			handle fillColors: {cc. cc mixed: 0.5 with: Color black}.		] ifFalse:[			handle textColor: Color white.			handle fillColors: {cc mixed: 0.5 with: Color white. cc}.		].		handle textFont: (TextStyle named: 'HaloFont') defaultFont.		handle text: spec fifth.		self add: handle.	].	self label: (haloLabel := CLabel new).	haloLabel hResizing: #shrinkWrap.	haloLabel color: Color white.	haloLabel borderStyle: #simple.	haloLabel borderColor: Color black.	haloLabel borderWidth: 1.	haloLabel roundCorners: true.	frame := CLayoutFrame new.	frame leftFraction: 0.5.	frame topFraction: 1.0.	frame topOffset: 32.	haloLabel layoutFrame: frame.	self add: haloLabel.! !!CHalo methodsFor: 'accessing' stamp: 'ar 3/17/2004 15:07'!label	"This method was automatically generated"	<bewareOf: #labelChanged>	^self propertyValueAt: #label! !!CHalo methodsFor: 'accessing' stamp: 'ar 3/11/2004 14:21'!label: aValue	"This method was automatically generated"	^self propertyValueAt: #label put: aValue with: #labelChanged! !!CHalo methodsFor: 'accessing' stamp: 'ar 3/17/2004 15:07'!multiSelections	"This method was automatically generated"	<bewareOf: #multiSelectionsChanged>	^self propertyValueAt: #multiSelections! !!CHalo methodsFor: 'accessing' stamp: 'ar 3/11/2004 14:21'!multiSelections: aValue	"This method was automatically generated"	^self propertyValueAt: #multiSelections put: aValue with: #multiSelectionsChanged! !!CHalo methodsFor: 'accessing' stamp: 'ar 3/17/2004 15:07'!rootContext	"This method was automatically generated"	<bewareOf: #rootContextChanged>	^self propertyValueAt: #rootContext! !!CHalo methodsFor: 'accessing' stamp: 'ar 3/11/2004 14:21'!rootContext: aValue	"This method was automatically generated"	^self propertyValueAt: #rootContext put: aValue with: #rootContextChanged! !!CHalo methodsFor: 'accessing' stamp: 'ar 3/17/2004 15:08'!target	"This method was automatically generated"	<bewareOf: #targetChanged>	^self propertyValueAt: #target! !!CHalo methodsFor: 'accessing' stamp: 'ar 3/11/2004 14:21'!target: aValue	"This method was automatically generated"	^self propertyValueAt: #target put: aValue with: #targetChanged! !!CHalo methodsFor: 'testing' stamp: 'ar 12/3/2003 14:25'!containsPoint: aPoint	"hide me from clicks and other"	^false! !!CHalo methodsFor: 'events' stamp: 'ar 2/18/2004 22:06'!onBlueButtonDown	| pos dragThreshold |	dragThreshold := 10. "pixels before drag"	pos := self hand position.	self hand forEach: #mouseMove do:[:event|		(self hand position dist: pos) > dragThreshold 			ifTrue:[^self onDragSelect: pos].	] until: #mouseUp.	^self onSelectTarget! !!CHalo methodsFor: 'events' stamp: 'ar 4/2/2004 14:59'!onDragSelect: startPos	| selections |	self target: nil.	self origin: startPos.	self extent: self hand position - startPos.	self multiSelections bounds: self bounds.	self borderColor: Color black.	self elements do:[:each| each visible: false].	self label visible: true.	self hand world add: self multiSelections.	self hand world add: self.	self hand forEach: #mouseMove do:[		self bounds: (self hand position rect: startPos).		self multiSelections bounds: self bounds.		self selectMultipleTargetsIn: (self rootContext ifNil:[self container]).	] until: #mouseUp.	self elements do:[:each| each visible: true].	self borderColor: Color transparent.	self close.	selections := self multiSelections value.	selections size <= 1 ifTrue:[		selections size = 0 			ifTrue:[self target: nil]			ifFalse:[self target: selections anyOne].		self multiSelections value: #().		self multiSelections close.		^self].	self target: self multiSelections.! !!CHalo methodsFor: 'events' stamp: 'tk 7/14/2004 11:23'!onGeometryChanged	| trial box minExtent targetCostume |	self target ifNil:[^self].	self visible ifFalse:[^self].	targetCostume := self target asPrimCostume.	minExtent := 70@70.	self costume comeToFront.	trial := (targetCostume localToGlobal: targetCostume localBounds) expandBy: 25.	trial extent x < minExtent x 		ifTrue:[trial := trial expandBy: (minExtent x - trial extent x) // 2 @ 0].	trial extent y < minExtent y 		ifTrue:[trial := trial expandBy: 0 @ (minExtent y - trial extent y) // 2].	box := (target world ifNil:[^self]) localBounds.	self bounds: ((trial intersect: box) insetBy: 25).! !!CHalo methodsFor: 'events' stamp: 'ar 2/23/2004 00:32'!onKeyDown: evt	<on: keyDown>	self world signal: #haloKeyDown with: evt.! !!CHalo methodsFor: 'events' stamp: 'tk 7/14/2004 11:24'!onSelectTarget	| index list cc |	list := self hand playersUnder: self hand world activeProject.	list isEmpty ifTrue:[^self].	cc := self target ifNotNil:[self target asPrimCostume].	index := list identityIndexOf: (cc ifNil:[self rootContext]).	index = 0 ifTrue:[		self hand shiftPressed 			ifTrue:[index := 1]			ifFalse:[index := list size - 1]	] ifFalse:[		self hand shiftPressed			ifTrue:[index := index+1]			ifFalse:[index := index-1].	].	"@@@@: Fix this. Later figure out how to wrap and ask guys for interest"	self target: (list atWrap: index) asPlayer! !!CHalo methodsFor: 'events' stamp: 'tk 6/22/2004 17:47'!onTargetChanged: newTarget from: oldTarget	| labelString |	<on: #targetChanged>	"A temporary workaround from an age where not all costumes had players"	newTarget isPrimitiveCostume ifTrue:[self target: newTarget asPlayer].	self stopScript: #onGeometryChanged.	oldTarget ifNotNil:[		oldTarget signal: #haloLost with: self.		self hand ifNotNil:[			self hand world activeProject remove: self.			self hand releaseKeyboardFocus: self.		].	].	newTarget ifNotNil:[		self target signal: #haloObtained with: self.		labelString := self roleNameFor: self target.		self label value: labelString.		self label costume layoutFrame leftOffset: 			self label costume fullBounds width // -2.		self startScript: #onGeometryChanged 			when:{self target. #frameChanged}.		self onGeometryChanged.		self hand ifNotNil:[			self hand world activeProject add: self.			self hand keyboardFocus: self.		].	].	self hand ifNotNil:[self hand signal: #haloChanged].! !!CHalo methodsFor: 'events' stamp: 'tk 7/14/2004 11:29'!selectMultipleTargetsIn: aPlayer	"Drag-select targets in aCostume"	| selections |	selections := IdentitySet new.	aPlayer contents do:[:pp|		(self globalBounds containsRect: pp globalBounds) ifTrue:[			selections add: pp.		].	].	selections remove: self ifAbsent:[].	selections remove: multiSelections ifAbsent:[].	selections := selections asArray sort:[:c1 :c2|		(aPlayer asPrimCostume indexOf: c1) <= (aPlayer asPrimCostume indexOf: c2)	].	multiSelections value: selections.	label value: selections size printString, ' object(s) selected'! !!CHalo methodsFor: 'printing' stamp: 'bf 7/22/2004 12:40'!roleNameFor: aPlayer	"Describe aPlayer's role"	| binding basePlayer |	(binding := aPlayer componentBinding) ifNotNil:[		^(binding home name),'''s ', binding key.	].	basePlayer := aPlayer player ifNil:[^aPlayer name].	basePlayer getCostume == aPlayer ifFalse:[^aPlayer name].	aPlayer class == CPlayer ifTrue:[		^(basePlayer name),'''s costume'	].	^(basePlayer name), '''s ', aPlayer class nameForDisplay withFirstCharacterDownshifted! !!CHaloButton methodsFor: 'events' stamp: 'ar 2/17/2004 00:53'!onButtonFocusLost	<on: buttonFocusLost>	self onMouseUp.	self onMouseLeave.! !!CHaloButton methodsFor: 'events' stamp: 'ar 2/16/2004 21:59'!onMouseDown	<on: mouseDown>	self fillColors: self fillColors reversed.	self world signal: #haloEvent with: self.! !!CHaloButton methodsFor: 'events' stamp: 'ar 2/16/2004 21:20'!onMouseEnter	<on: mouseEnter>	self borderColor: Color white.! !!CHaloButton methodsFor: 'events' stamp: 'ar 2/16/2004 21:21'!onMouseLeave	<on: mouseLeave>	self borderColor: Color black.! !!CHaloButton methodsFor: 'events' stamp: 'ar 3/23/2004 23:44'!onMouseUp	<on: mouseUp>	self fillColors: self fillColors reversed.	(self containsPoint: self cursorPoint)		ifTrue:[self fire]		ifFalse:[self signal: #abortFire].! !!CHaloButton methodsFor: 'initialize' stamp: 'ar 3/24/2004 14:23'!initialize	super initialize.	self extent: 16@16.	self roundCorners: true.	self borderStyle: #simple.	self borderWidth: 1.	self borderColor: Color black.	self fillStyle: #radialGradient.	self fillOffset: -4@-4.	self fillAngle: 45.	self dropShadowEnabled: true.	self dropShadowColor: (Color black alpha: 0.5).! !!CHaloButton methodsFor: 'initialize' stamp: 'tk 7/14/2004 11:24'!setupCostume	super setupCostume.	self textEnabled: true.	self asPrimCostume localCache: CFormCache new.! !!CHaloResizer methodsFor: 'initialize' stamp: 'ar 4/2/2004 14:51'!initialize	super initialize.	target := nil.	self borderWidth: 8.	self borderColor: (Color blue alpha: 0.2).	self borderStyle: #simple.	self mouseCursor: CCursorLibrary dragCursor.	self layout: CProportionalLayout new.	#(topLeft topCenter topRight rightCenter 	bottomRight bottomCenter bottomLeft leftCenter) do:[:pos|		| handle cc |		handle := CPlayer new.		handle extent: 8@8.		handle color: Color white.		handle borderWidth: 1; borderColor: Color black; borderStyle: #simple.		handle value: pos.		handle mouseCursor: (self perform: (pos,'Cursor') asSymbol).		self startScript: #onResizeTarget: withArguments:{handle} when:{handle. #mouseDown}.		handle layoutFrame: CLayoutFrame new.		pos := (0@0 corner: 100@100) perform: pos.		pos x = 0 ifTrue:[handle layoutFrame leftFraction: 0; leftOffset: -8].		pos x = 50 ifTrue:[handle layoutFrame leftFraction: 0.5; leftOffset: -4].		pos x = 100 ifTrue:[handle layoutFrame rightFraction: 1; rightOffset: 8].		pos y = 0 ifTrue:[handle layoutFrame topFraction: 0; topOffset: -8].		pos y = 50 ifTrue:[handle layoutFrame topFraction: 0.5; topOffset: -4].		pos y = 100 ifTrue:[handle layoutFrame bottomFraction: 1; bottomOffset: 8].		self add: handle.	].! !!CHaloResizer methodsFor: 'accessing' stamp: 'ar 3/13/2004 21:39'!target	"Answer the target of the receiver"	<bewareOf: #targetChanged>	^self propertyValueAt: #target! !!CHaloResizer methodsFor: 'accessing' stamp: 'ar 3/13/2004 21:39'!target: aValue	"Modify the receiver's target"	^self propertyValueAt: #target put: aValue with: #targetChanged! !!CHaloResizer methodsFor: 'events' stamp: 'ar 3/13/2004 21:48'!onMoveTarget	| offset delta aTarget |	<on: #mouseDown>	costume comeToFront.	aTarget := target ifNil:[self].	offset := aTarget cursorPoint.	hand forEach: #mouseMove do:[		delta := aTarget cursorPoint - offset.		aTarget moveBy: delta.	] until: #mouseUp.! !!CHaloResizer methodsFor: 'events' stamp: 'ar 3/13/2004 21:48'!onResizeTarget: aHandle	| align pt box offset aTarget |	aTarget := target ifNil:[self].	align := (aHandle value, ':') asSymbol.	offset := aTarget container cursorPoint - (aTarget bounds perform: aHandle value).	hand forEach: #mouseMove do:[		pt := aTarget container cursorPoint - offset.		box := aTarget bounds perform: align with: pt.		aTarget bounds: box.	] until: #mouseUp.! !!CHaloResizer methodsFor: 'events' stamp: 'ar 3/13/2004 21:49'!onTargetChanged	<on: targetChanged>	target ifNotNil:[self onUpdateGeometry]! !!CHaloResizer methodsFor: 'events' stamp: 'ar 3/13/2004 21:49'!onUpdateGeometry	| box |	<on: frameChanged in: target>	target == self ifTrue:[^self].	box := target localToGlobal: target costume localBounds.	box := container globalToLocal: box.	self bounds: (box expandBy: borderWidth).! !!CHaloResizer methodsFor: 'private' stamp: 'ar 3/13/2004 21:46'!bottomCenterCursor	^CCursorLibrary topBottomCursor! !!CHaloResizer methodsFor: 'private' stamp: 'ar 3/13/2004 21:47'!bottomLeftCursor	^CCursorLibrary bottomLeftCursor! !!CHaloResizer methodsFor: 'private' stamp: 'ar 3/13/2004 21:47'!bottomRightCursor	^CCursorLibrary bottomRightCursor! !!CHaloResizer methodsFor: 'private' stamp: 'ar 3/13/2004 21:46'!leftCenterCursor	^CCursorLibrary leftRightCursor! !!CHaloResizer methodsFor: 'private' stamp: 'ar 3/13/2004 21:46'!rightCenterCursor	^CCursorLibrary leftRightCursor! !!CHaloResizer methodsFor: 'private' stamp: 'ar 3/13/2004 21:46'!topCenterCursor	^CCursorLibrary topBottomCursor! !!CHaloResizer methodsFor: 'private' stamp: 'ar 3/13/2004 21:46'!topLeftCursor	^CCursorLibrary topLeftCursor! !!CHaloResizer methodsFor: 'private' stamp: 'ar 3/13/2004 21:46'!topRightCursor	^CCursorLibrary topRightCursor! !!CHandPlayer methodsFor: 'accessing' stamp: 'ar 10/15/2003 16:17'!autoKeyboardFocus	^false! !!CHandPlayer methodsFor: 'accessing' stamp: 'ar 3/18/2003 12:22'!lastEvent	^ lastEvent! !!CHandPlayer methodsFor: 'accessing' stamp: 'ar 3/19/2003 20:50'!mouseCursor	^self costume mouseCursor! !!CHandPlayer methodsFor: 'accessing' stamp: 'ar 9/8/2003 20:43'!mouseCursor: newCursor	| oldPosition aCursor |	aCursor := newCursor ifNil:[Cursor normal].	self mouseCursor == aCursor ifTrue:[^newCursor].	oldPosition := self position.	self costume mouseCursor: aCursor.	self position: oldPosition.	^newCursor! !!CHandPlayer methodsFor: 'accessing' stamp: 'ar 3/18/2003 12:23'!mouseOverHandler	^mouseOverHandler ifNil:[mouseOverHandler _ CMouseOverHandler new].! !!CHandPlayer methodsFor: 'accessing' stamp: 'ar 8/3/2004 17:19'!pressedKeys	^pressedKeys ifNil:[pressedKeys := Set new].! !!CHandPlayer methodsFor: 'initialize' stamp: 'ar 3/23/2004 20:34'!defaultCostume	^CHandCostume! !!CHandPlayer methodsFor: 'initialize' stamp: 'ar 8/3/2004 17:19'!initialize	super initialize.	self name: 'Hand'.	keyboardFocus _ nil.	pressedKeys := Set new.	mouseFocus _ nil.	mouseOverHandler _ nil.	lastEvent _ MouseEvent new setType: #mouseMove position: 0@0 buttons: 0 hand: self.	lastEventBuffer _ {1. 0. 0. 0. 0. 0. nil. nil}.	"Bootstrap the cursor"	self startScript: #mouseCursor: withArguments:{Cursor normal}.	self halo: CHalo new.	self halo userDraw: true.! !!CHandPlayer methodsFor: 'initialize' stamp: 'ar 3/18/2003 12:20'!isSpecialSystemScript: scriptDescriptor	"Some scripts need to be run for debugging and cannot stopped for debugging"	^(super isSpecialSystemScript: scriptDescriptor) or:[scriptDescriptor == #processEvents]! !!CHandPlayer methodsFor: 'initialize' stamp: 'ar 4/30/2004 15:51'!setupCostume	super setupCostume.	self color: Color transparent.	self graphicEnabled: true.! !!CHandPlayer methodsFor: 'private' stamp: 'ar 3/26/2004 02:03'!disableGenieFocus: aMorph! !!CHandPlayer methodsFor: 'private' stamp: 'ar 3/18/2003 12:33'!interrupted	"Something went wrong - we're about to bring up a debugger. 	Release some stuff that could be problematic."	self releaseAllFoci. "or else debugger might not handle clicks"	dragContents := nil.! !!CHandPlayer methodsFor: 'private' stamp: 'ar 3/18/2003 12:34'!releaseAllFoci	mouseFocus _ nil.	keyboardFocus _ nil.! !!CHandPlayer methodsFor: 'private' stamp: 'ar 3/18/2003 12:34'!setKeyboardFocus: newFocus	keyboardFocus _ newFocus! !!CHandPlayer methodsFor: 'private' stamp: 'ar 3/18/2003 12:34'!setMouseFocus: newFocus	mouseFocus _ newFocus.! !!CHandPlayer methodsFor: 'private events' stamp: 'ar 7/15/2003 15:11'!dispatchEvent: anEvent	"@@@@: Fix me. Need to notify listeners (based on event type etc) since they have gone away. Event needs to be signaled at least two times (for generic event listeners and specific event listeners) - alternatively just signal event and leave it to client to figure out... :@@@@"	| evt ofs |	self container ifNil:[^self].	evt := anEvent.	evt setHand: self.	EventStats ifNil:[EventStats _ IdentityDictionary new].	EventStats at: #count put: (EventStats at: #count ifAbsent:[0]) + 1.	EventStats at: evt type put: (EventStats at: evt type ifAbsent:[0]) + 1.	evt isMouseOver ifTrue:[^self sendEvent: evt focus: nil clear:[]].	ShowEvents == true ifTrue:[		ofs _ (self container hands indexOf: self) - 1 * 60.		evt printString displayAt: (0@ofs) + (evt isKeyboard ifTrue:[0@30] ifFalse:[0@0]).		self keyboardFocus printString displayAt: (0@ofs)+(0@45).	].	self signal: evt type with: evt.	evt isKeyboard ifTrue:[^self sendKeyboardEvent: evt].	evt isDropEvent ifTrue:[^self sendEvent: evt focus: nil].	evt isMouse ifTrue:[		lastEvent := evt.		self signal: #updateMouseOver.	].	evt isMove ifTrue:[		self position: evt position.		self sendMouseEvent: evt.	] ifFalse:[		"Issue a synthetic move event if we're not at the position of the event"		(evt position = self position) ifFalse:[self moveToEvent: evt].		self sendMouseEvent: evt.	].	ShowEvents == true ifTrue:[		self mouseFocus printString displayAt: (0@ofs) + (0@15).		self playersUnder printString displayAt: (0@60) + (0@15).	].! !!CHandPlayer methodsFor: 'private events' stamp: 'ar 3/27/2004 20:59'!generateDropFilesEvent: evtBuf	"Generate the appropriate mouse event for the given raw event buffer"	"Note: This is still in an experimental phase and will need more work"	| pos buttons modifiers stamp numFiles dragType |	stamp _ (evtBuf at: 2).	stamp = 0 ifTrue:[stamp _ Time millisecondClockValue].	dragType _ evtBuf at: 3.	pos _ (evtBuf at: 4) @ (evtBuf at: 5).	buttons _ 0.	modifiers _ (evtBuf at: 6).	buttons _ buttons bitOr: (modifiers bitShift: 3).	numFiles _ (evtBuf at: 7).	dragType = 4 ifTrue:[		"e.g., drop"		self container borderWidth: 0.		^DropFilesEvent new 			setPosition: pos 			contents: numFiles 			hand: self.	].	"the others are currently not handled by costumes themselves"	dragType = 1 ifTrue:[		"experimental drag enter"		self container borderWidth: 4; borderColor: self container color negated.	].	dragType = 2 ifTrue:[		"experimental drag move"	].	dragType = 3 ifTrue:[		"experimental drag leave"		self container borderWidth: 0.	].	^nil! !!CHandPlayer methodsFor: 'private events' stamp: 'ar 3/18/2003 14:41'!generateKeyboardEvent: evtBuf	"Generate the appropriate mouse event for the given raw event buffer"	| buttons modifiers type keyValue pressType stamp |	stamp _ (evtBuf at: 2).	stamp = 0 ifTrue:[stamp _ Time millisecondClockValue].	keyValue _ evtBuf at: 3.	pressType _ evtBuf at: 4.	pressType = EventKeyDown ifTrue:[type _ #keyDown].	pressType = EventKeyUp ifTrue:[type _ #keyUp].	pressType = EventKeyChar ifTrue:[type _ #keystroke].	modifiers _ evtBuf at: 5.	buttons _ modifiers bitShift: 3.	^lastEvent := KeyboardEvent new		setType: type		buttons: buttons		position: self position		keyValue: keyValue		hand: self		stamp: stamp! !!CHandPlayer methodsFor: 'private events' stamp: 'ar 3/27/2004 20:59'!generateMouseEvent: evtBuf	"Generate the appropriate mouse event for the given raw event buffer"	| pos buttons modifiers type trail stamp oldButtons evtChanged |	(evtBuf at: 1) = (lastEventBuffer at: 1) ifTrue:[		"Workaround for Mac VM bug, *always* generating 3 events on clicks"		evtChanged _ false.		3 to: evtBuf size do:[:i| (lastEventBuffer at: i) = (evtBuf at: i) ifFalse:[evtChanged _ true]].		evtChanged ifFalse:[^nil]].	stamp _ (evtBuf at: 2).	stamp = 0 ifTrue:[stamp _ Time millisecondClockValue].	pos _ (evtBuf at: 3) @ (evtBuf at: 4).	buttons _ (evtBuf at: 5).	modifiers _ (evtBuf at: 6).	buttons = 0 		ifTrue:[	(lastEventBuffer at: 5) = 0					ifTrue:[type _ #mouseMove]					ifFalse:[type _ #mouseUp]]		ifFalse:[	(lastEventBuffer at: 5) = 0					ifTrue:[type _ #mouseDown]					ifFalse:[type _ #mouseMove]].	buttons _ buttons bitOr: (modifiers bitShift: 3).	oldButtons _ (lastEventBuffer at: 5) bitOr: ((lastEventBuffer at: 6) bitShift: 3).	lastEventBuffer _ evtBuf.	type == #mouseMove ifTrue:[		trail _ self mouseTrailFrom: evtBuf.		^lastEvent := MouseMoveEvent new 			setType: type 			startPoint: trail first			endPoint: trail last 			trail: trail			buttons: buttons			hand: self			stamp: stamp.	].	^lastEvent := MouseButtonEvent new 		setType: type 		position: pos		which: (oldButtons bitXor: buttons)		buttons: buttons 		hand: self		stamp: stamp! !!CHandPlayer methodsFor: 'private events' stamp: 'ar 3/18/2003 12:30'!mouseTrailFrom: currentBuf	"Current event, a mouse event buffer, is about to be processed.  If there are other similar mouse events queued up, then drop them from the queue, and report the positions inbetween."	| nextEvent trail |	trail _ WriteStream on: (Array new: 1).	trail nextPut: ((currentBuf at: 3) @ (currentBuf at: 4)).	[(nextEvent _ Sensor peekEvent) == nil] whileFalse:[		(nextEvent at: 1) = (currentBuf at: 1) ifFalse:			[^ trail contents  "different event type"].		(nextEvent at: 5) = (currentBuf at: 5) ifFalse:			[^ trail contents  "buttons changed"].		(nextEvent at: 6) = (currentBuf at: 6) ifFalse:			[^ trail contents  "modifiers changed"].		"nextEvent is similar.  Remove it from the queue, and check the next."		nextEvent _ Sensor nextEvent.		trail nextPut: ((nextEvent at: 3) @ (nextEvent at: 4))	].	^trail contents! !!CHandPlayer methodsFor: 'private events' stamp: 'ar 3/18/2003 14:41'!moveToEvent: anEvent	"Issue a mouse move event to make the receiver appear at the given position"	self dispatchEvent: (lastEvent := MouseMoveEvent new		setType: #mouseMove 		startPoint: self position 		endPoint: anEvent position 		trail: (Array with: self position with: anEvent position)		buttons: anEvent buttons		hand: self		stamp: anEvent timeStamp)! !!CHandPlayer methodsFor: 'private events' stamp: 'ar 3/18/2003 12:30'!noticeMouseOver: aPlayer event: anEvent	mouseOverHandler ifNil:[^self].	mouseOverHandler noticeMouseOver: aPlayer event: anEvent.! !!CHandPlayer methodsFor: 'private events' stamp: 'ar 3/19/2003 22:18'!processEvents	"Process user input events from the local input devices."	| evt evtBuf type |	ActiveHand := self.	[(evtBuf := Sensor nextEvent) == nil] whileFalse:[		evt := nil. "for unknown event types"		type := evtBuf at: 1.		(type = EventTypeMouse)			ifTrue:[evt := self generateMouseEvent: evtBuf].		(type = EventTypeKeyboard) 			ifTrue:[evt := self generateKeyboardEvent: evtBuf].		(type = EventTypeDragDropFiles)			ifTrue:[evt := self generateDropFilesEvent: evtBuf].		"All other events are ignored"		evt == nil ifTrue: [^ self].		"Finally, handle it"		self dispatchEvent: evt.		"For better user feedback, return immediately after a mouse event has been processed."		evt isMouse ifTrue: [^self].	].	"note: if we come here we didn't have any mouse events"	self signal: #updateMouseOver.! !!CHandPlayer methodsFor: 'private events' stamp: 'ar 3/18/2003 12:30'!sendEvent: anEvent focus: focusHolder	"Send the event to the costume currently holding the focus, or if none to the owner of the hand."	^self sendEvent: anEvent focus: focusHolder clear:[nil]! !!CHandPlayer methodsFor: 'private events' stamp: 'ar 2/17/2004 19:15'!sendEvent: anEvent focus: focusHolder clear: aBlock	"Send the event to the costume currently holding the focus, or if none to the container of the hand."	| result |	focusHolder ifNotNil:[^self sendFocusEvent: anEvent to: focusHolder clear: aBlock].	ActiveEvent _ anEvent.	result _ self container dispatchEvent: anEvent.	ActiveEvent _ nil.	^result! !!CHandPlayer methodsFor: 'private events' stamp: 'tk 7/14/2004 11:25'!sendFocusEvent: anEvent to: focusHolder clear: aBlock	"Send the event to the costume currently holding the focus"	| cc |	cc := self container asPrimCostume.	(focusHolder == cc or:[focusHolder isIn: cc]) ifFalse:[^aBlock value].	ActiveEvent _ anEvent.	^focusHolder 		handleFocusEvent: (anEvent transformedBy: focusHolder globalToLocal)! !!CHandPlayer methodsFor: 'private events' stamp: 'ar 8/3/2004 17:21'!sendKeyboardEvent: anEvent	"Send the event to the costume currently holding the focus, or if none to the owner of the hand."	| keyValue focus context |	keyValue := anEvent keyValue.	focus := self keyboardFocus.	anEvent isKeyDown ifTrue:[		self pressedKeys add: keyValue.		context := focus ifNotNil:[focus world].		context ifNotNil:[context costume pressedKeys add: keyValue].	].	anEvent isKeyUp ifTrue:[		self pressedKeys remove: keyValue ifAbsent:[].		context := focus ifNotNil:[focus world].		context ifNotNil:[context costume pressedKeys remove: keyValue ifAbsent:[]].	].	^self sendEvent: anEvent focus: self keyboardFocus clear:[self keyboardFocus: nil]! !!CHandPlayer methodsFor: 'private events' stamp: 'ar 3/18/2003 12:31'!sendListenEvent: anEvent to: listenerGroup	"Send the event to the given group of listeners"	listenerGroup ifNil:[^self].	listenerGroup do:[:listener| 		listener ifNotNil:[listener handleListenEvent: anEvent copy]].! !!CHandPlayer methodsFor: 'private events' stamp: 'ar 2/17/2004 19:16'!sendMouseEvent: anEvent	"Send the event to the costume currently holding the focus, or if none to the owner of the hand."	^self sendEvent: anEvent focus: self mouseFocus clear:[self mouseFocus: nil].! !!CHandPlayer methodsFor: 'private events' stamp: 'tk 7/14/2004 11:25'!sendMouseOverEvent: anEvent	"Note: Sending mouse overs is slightly different since we want to determine over state for all costumes within the focus but not for those on top (which will get leave/enter events only *after* the current mouse transition is completed)"	| focus |	ActiveEvent := anEvent.	focus := self mouseFocus.	focus ifNil:[^self container dispatchEvent: anEvent].	focus container ifNil:[^focus dispatchEvent: anEvent].	"Note: dispatchEvent: expects parent frame not child so transform into parent local frame"	^focus costume dispatchEvent: (anEvent transformedBy: focus container asPrimCostume globalToLocal)! !!CHandPlayer methodsFor: 'input state' stamp: 'ar 3/18/2003 12:32'!anyButtonPressed	^lastEvent anyButtonPressed! !!CHandPlayer methodsFor: 'input state' stamp: 'ar 3/18/2003 12:32'!anyModifierKeyPressed	^lastEvent anyModifierKeyPressed! !!CHandPlayer methodsFor: 'input state' stamp: 'ar 3/18/2003 12:33'!blueButtonChanged	^lastEvent blueButtonChanged! !!CHandPlayer methodsFor: 'input state' stamp: 'ar 3/18/2003 12:33'!blueButtonPressed	^lastEvent blueButtonPressed! !!CHandPlayer methodsFor: 'input state' stamp: 'ar 3/18/2003 12:33'!commandKeyPressed	^lastEvent commandKeyPressed! !!CHandPlayer methodsFor: 'input state' stamp: 'ar 3/18/2003 12:33'!controlKeyPressed	^lastEvent controlKeyPressed! !!CHandPlayer methodsFor: 'input state' stamp: 'ar 8/3/2004 17:20'!isKeyPressed: aKey	^self pressedKeys includes: aKey! !!CHandPlayer methodsFor: 'input state' stamp: 'ar 3/18/2003 12:33'!macOptionKeyPressed	^lastEvent macOptionKeyPressed! !!CHandPlayer methodsFor: 'input state' stamp: 'ar 3/18/2003 12:33'!redButtonChanged	^lastEvent redButtonChanged! !!CHandPlayer methodsFor: 'input state' stamp: 'ar 3/18/2003 12:33'!redButtonPressed	^lastEvent redButtonPressed! !!CHandPlayer methodsFor: 'input state' stamp: 'ar 3/18/2003 12:33'!shiftPressed	^lastEvent shiftPressed! !!CHandPlayer methodsFor: 'input state' stamp: 'ar 3/18/2003 12:33'!yellowButtonChanged	^lastEvent yellowButtonChanged! !!CHandPlayer methodsFor: 'input state' stamp: 'ar 3/18/2003 12:33'!yellowButtonPressed	^lastEvent yellowButtonPressed! !!CHandPlayer methodsFor: 'drag drop' stamp: 'ar 3/18/2003 12:38'!dragContents	"Answer the dragContents of this hand"	^dragContents! !!CHandPlayer methodsFor: 'drag drop' stamp: 'ar 3/23/2004 23:14'!dragContents: anObject	"Set the dragContents of this hand."	"Note: The event dispatch below essentially models that we move out into the sky, pick up the object and move back to where we were. This is needed in cases where objects may react to dragEnter/dragLeave and should be notified about the change in state."	| evt |	dragContents == anObject ifTrue:[^self].	evt := lastEvent asMouseLeave.	self playersUnder do:[:each| 		each locked ifFalse:[			each costume handleEvent: (evt transformedBy: each costume globalToLocal)]].	dragContents := anObject.	evt := lastEvent asMouseEnter.	self playersUnder reverseDo:[:each| 		each locked ifFalse:[			each costume handleEvent: (evt transformedBy: each costume globalToLocal)]].	^dragContents! !!CHandPlayer methodsFor: 'drag drop' stamp: 'ar 3/18/2003 12:39'!hasDragContents	"Answer whether this hand is in a drag and drop transaction"	^dragContents notNil! !!CHandPlayer methodsFor: 'mouse over' stamp: 'ar 7/8/2003 19:00'!cursorFocus	"answer the current cursor focus"	^cursorFocus! !!CHandPlayer methodsFor: 'mouse over' stamp: 'ar 7/8/2003 19:00'!cursorFocus: aPlayer	"indicate the current cursor focus"	cursorFocus := aPlayer.! !!CHandPlayer methodsFor: 'mouse over' stamp: 'ar 8/17/2003 13:56'!isMouseOver: aPlayer	"Return true if the receiver is over aPlayer"	^self mouseOverHandler mouseOverList anySatisfy:[:over| aPlayer == over].! !!CHandPlayer methodsFor: 'mouse over' stamp: 'ar 3/18/2003 21:20'!isOver: aPlayer	"Return true if the receiver is over aPlayer"	^self mouseOverHandler mouseOverList anySatisfy:[:over| aPlayer == over].! !!CHandPlayer methodsFor: 'mouse over' stamp: 'ar 3/18/2003 12:28'!isOverPlayer: aPlayer	"Return true if the receiver is over aCostume"	^self mouseOverHandler mouseOverList anySatisfy:[:over| aPlayer == over].! !!CHandPlayer methodsFor: 'mouse over' stamp: 'ar 5/6/2004 16:13'!onUpdateMouseCursor	"update the current mouse cursor"	| aCursor |	cursorFocus ifNotNil:[^self mouseCursor: cursorFocus mouseCursor].	mouseFocus ifNil:[		self playersUnder do:[:aPlayer|			aCursor := aPlayer mouseCursor.			aCursor ifNotNil:[^self mouseCursor: aCursor].		].		^self mouseCursor: nil	].	"if we have a mouse focus then only children of the current mouse focus can hold the cursor or one of the current containers of the mouse cursor"	self playersUnder do:[:aPlayer|		(aPlayer == mouseFocus or:[aPlayer isIn: mouseFocus]) ifTrue:[			aCursor := aPlayer mouseCursor.			aCursor ifNotNil:[^self mouseCursor: aCursor].		].	].	mouseFocus withAllContainersDo:[:each|		aCursor := each mouseCursor.		aCursor ifNotNil:[^self mouseCursor: aCursor].	].	^self mouseCursor: nil! !!CHandPlayer methodsFor: 'mouse over' stamp: 'ar 9/23/2003 01:05'!onUpdateMouseOver	"update the mouse over state"	<on: updateMouseOver>	self mouseOverHandler processMouseOver: lastEvent.	self onUpdateMouseCursor.! !!CHandPlayer methodsFor: 'mouse over' stamp: 'ar 3/18/2003 12:28'!playersUnder	"Return the costumes currently under the hand"	^self mouseOverHandler mouseOverList! !!CHandPlayer methodsFor: 'mouse over' stamp: 'tk 7/14/2004 11:24'!playersUnder: topPlayer	"Return the players currently under the hand starting with topPlayer"	| aList |	aList := self mouseOverHandler mouseOverList.	^aList copyFrom: 1 to: (aList indexOf: topPlayer asPrimCostume)! !!CHandPlayer methodsFor: 'mouse over' stamp: 'ar 7/8/2003 19:00'!releaseCursorFocus	"release the current cursor focus unconditionally"	cursorFocus := nil.! !!CHandPlayer methodsFor: 'mouse over' stamp: 'ar 7/8/2003 19:00'!releaseCursorFocus: aPlayer	"release the current cursor focus"	aPlayer == cursorFocus ifTrue:[self releaseCursorFocus].! !!CHandPlayer methodsFor: 'mouse' stamp: 'ar 3/26/2004 01:50'!forEachAndEveryMouseMoveDo: aBlock	"A simple way of querying for *all* mouse move events where it matters"	| moveEvent |	self forEach: #mouseMove do:[:scriptEvent|		"capture events in the order they were received"		scriptEvent withDroppedEvents reverseDo:[:possiblyDropped|			"get the move event out of the argument of the script event"			moveEvent := possiblyDropped arguments first.			moveEvent trail do:[:aPoint| aBlock value: aPoint].			"and pass the last one along explicitly"			aBlock value: moveEvent position.		].	] until: #mouseUp.! !!CHandPlayer methodsFor: 'mouse' stamp: 'ar 3/18/2003 12:38'!mouseFocus	^mouseFocus! !!CHandPlayer methodsFor: 'mouse' stamp: 'ar 9/8/2004 16:23'!mouseFocus: focusHolder	"Make the given costume the new mouse focus, canceling the previous mouse focus if any. If the argument is nil, the current mouse focus is cancelled."	| newFocus oldFocus |	newFocus := focusHolder ifNotNil:[focusHolder asPrimCostume].	oldFocus := self mouseFocus.	self setMouseFocus: newFocus.	self signalChanged: #mouseFocusChanged from: oldFocus to: newFocus.	lastEvent anyButtonPressed ifTrue:[oldFocus signal: #buttonFocusLost].	^focusHolder! !!CHandPlayer methodsFor: 'mouse' stamp: 'ar 3/18/2003 12:38'!releaseMouseFocus	"Release the current mouse focus unconditionally."	self mouseFocus: nil.! !!CHandPlayer methodsFor: 'mouse' stamp: 'tk 7/14/2004 11:24'!releaseMouseFocus: aCostume	"If the given costume had the mouse focus before, release it"	self mouseFocus == aCostume asPrimCostume ifTrue:[self releaseMouseFocus].! !!CHandPlayer methodsFor: 'grabbing/dropping' stamp: 'ar 9/2/2004 11:15'!attach: aPlayer	"Position the center of the given costume under this hand, then grab it. This method is used to grab far away or newly created costumes."	| m pos |	m := aPlayer asPlayer.	m open.	pos := self position - (m asPrimCostume fullBounds extent // 2).	m container ifNotNil:[pos := m container globalToLocal: pos].	m origin: pos.	self releaseMouseFocus.	m costume startScript: #onDrag.! !!CHandPlayer methodsFor: 'grabbing/dropping' stamp: 'ar 3/23/2004 23:14'!drop: aPlayer	"Drop this costume"	| wasLocked event |	wasLocked := aPlayer locked.	aPlayer locked: true.	event := DropEvent new setPosition: self position contents: aPlayer hand: self.	self sendEvent: event focus: nil.	aPlayer locked: wasLocked.! !!CHandPlayer methodsFor: 'grabbing/dropping' stamp: 'ar 3/18/2003 12:26'!dropContents	^dragContents! !!CHandPlayer methodsFor: 'grabbing/dropping' stamp: 'ar 3/18/2003 12:26'!grab: aPlayer	"Grab the given costume (i.e., add it to this hand and remove it from its current container) without changing its position. This is used to pick up a costume under the hand's current position, versus attach: which is used to pick up a costume that may not be near this hand."	| grabbed |	grabbed _ aPlayer asPlayer.	grabbed ifNil:[^self].	^self grab: grabbed from: grabbed container! !!CHandPlayer methodsFor: 'grabbing/dropping' stamp: 'ar 4/2/2004 14:59'!grab: aPlayer from: formerOwner	"Grab the given costume (i.e., add it to this hand and remove it from its current owner) without changing its position. This is used to pick up a costume under the hand's current position, versus attach: which is used to pick up a costume that may not be near this hand."	| grabbed |	formerOwner ifNil:[^self attach: aPlayer].	grabbed := aPlayer asPlayer.	self container add: grabbed.	grabbed transformBy: formerOwner costume localToGlobal.	self mouseFocus: grabbed.	grabbed costume startScript: #onDrag.! !!CHandPlayer methodsFor: 'balloon help' stamp: 'ar 7/24/2003 21:16'!balloon: aPlayer	balloon := aPlayer! !!CHandPlayer methodsFor: 'balloon help' stamp: 'ar 7/24/2003 21:17'!balloonTarget	^balloon value! !!CHandPlayer methodsFor: 'balloon help' stamp: 'ar 3/25/2004 19:02'!balloonTarget: newTarget! !!CHandPlayer methodsFor: 'balloon help' stamp: 'ar 7/24/2003 21:21'!releaseBalloon: aPlayer	"Release balloon help for the given player"	balloon value == aPlayer ifTrue:[		balloon close.		balloon value: nil.	].! !!CHandPlayer methodsFor: 'serializing' stamp: 'ar 9/24/2003 11:32'!serializeOn: aSerializer	^aSerializer writeGlobal: #ActiveHand! !!CHandPlayer methodsFor: 'keyboard' stamp: 'ar 3/18/2003 12:37'!keyboardFocus				 	^ keyboardFocus! !!CHandPlayer methodsFor: 'keyboard' stamp: 'ar 9/8/2004 16:23'!keyboardFocus: focusHolder	"Make the given costume the new keyboard focus, canceling the previous keyboard focus if any. If the argument is nil, the current keyboard focus is cancelled."	| oldFocus newFocus |	oldFocus _ self keyboardFocus.	newFocus := focusHolder ifNotNil:[focusHolder asPrimCostume].	oldFocus == newFocus ifTrue:[^self].	self setKeyboardFocus: newFocus.	oldFocus ifNotNil:[oldFocus keyboardFocusLeave].	newFocus ifNotNil:[newFocus keyboardFocusEnter].	self signalChanged: #keyboardFocusChanged from: oldFocus to: newFocus.! !!CHandPlayer methodsFor: 'keyboard' stamp: 'ar 3/18/2003 12:37'!releaseKeyboardFocus	"Release the current keyboard focus unconditionally"	self keyboardFocus: nil.! !!CHandPlayer methodsFor: 'keyboard' stamp: 'ar 3/18/2003 12:38'!releaseKeyboardFocus: aPlayer	"If the given costume had the keyboard focus before, release it"	self keyboardFocus == aPlayer asPlayer ifTrue:[self releaseKeyboardFocus].! !!CHandPlayer methodsFor: 'halo' stamp: 'ar 3/18/2003 12:35'!halo	"Return the halo associated with this hand, if any"	^(self propertyValueAt: #halo) ifNil:[self installHalo].! !!CHandPlayer methodsFor: 'halo' stamp: 'ar 3/24/2004 00:31'!halo: newHalo	"Set halo associated with this hand"	| oldHalo |	(oldHalo := self propertyValueAt: #halo) == newHalo ifTrue:[^self].	self propertyValueAt: #halo put: newHalo with: #haloChanged.	^newHalo! !!CHandPlayer methodsFor: 'halo' stamp: 'ar 3/29/2004 14:54'!installHalo	| hh |	hh := CHalo new.	hh userDraw: true.	self halo: hh.! !!CHolder methodsFor: 'accessing' stamp: 'ar 3/16/2004 15:37'!at: aKey	"Answer the element at the given key"	^elements at: aKey! !!CHolder methodsFor: 'accessing' stamp: 'ar 3/16/2004 15:36'!at: aKey ifAbsent: aBlock	"Answer the element at the given key or evaluate the given block if there is no element with the given key"	^elements at: aKey ifAbsent: aBlock! !!CHolder methodsFor: 'accessing' stamp: 'ar 3/16/2004 15:37'!at: aKey put: anObject	"Store anObject under the given key in the receiver"	^elements at: aKey put: anObject! !!CHolder methodsFor: 'accessing' stamp: 'ar 3/15/2004 15:52'!contentType	"Answer the type of the elements stored in the receiver"	^elements contentType! !!CHolder methodsFor: 'accessing' stamp: 'ar 3/16/2004 15:39'!contents	"Answer the contents of the receiver"	^elements copyFrom: 1 to: self size! !!CHolder methodsFor: 'accessing' stamp: 'ar 3/16/2004 15:39'!contents: newContents	"Set the contents of the receiver"	^elements contents: newContents! !!CHolder methodsFor: 'accessing' stamp: 'ar 3/16/2004 15:38'!cursor	"Answer the receiver's cursor"	<bewareOf: #cursorChanged>	^elements cursor! !!CHolder methodsFor: 'accessing' stamp: 'ar 3/16/2004 15:38'!cursor: aValue	"Modifiy the receiver's cursor"	^elements cursor: aValue! !!CHolder methodsFor: 'accessing' stamp: 'ar 3/16/2004 15:39'!defaultElement	"Answer the default element for the receiver"	^elements defaultElement! !!CHolder methodsFor: 'accessing' stamp: 'ar 3/16/2004 15:40'!first	"Answer the first element of the receiver"	^elements first! !!CHolder methodsFor: 'accessing' stamp: 'ar 3/16/2004 15:40'!last	"Answer the last element in the receiver"	^elements last! !!CHolder methodsFor: 'accessing' stamp: 'ar 3/16/2004 15:40'!selection	"Answer the currently selected object - that is the object at the cursor's position"	^elements selection! !!CHolder methodsFor: 'accessing' stamp: 'ar 3/16/2004 15:40'!selection: anObject	"Set the currently selected object - that is move the cursor's position to point to anObject"	^elements selection: anObject! !!CHolder methodsFor: 'accessing' stamp: 'ar 3/16/2004 15:40'!selectionIndex	"A convenient alias to the cursor"	^elements selectionIndex! !!CHolder methodsFor: 'accessing' stamp: 'ar 3/16/2004 15:40'!selectionIndex: newIndex	"A convenient alias to the cursor"	^elements selectionIndex: newIndex! !!CHolder methodsFor: 'accessing' stamp: 'ar 3/16/2004 15:41'!size	"Answer the number of elements of the receiver"	^elements size! !!CHolder methodsFor: 'testing' stamp: 'ar 3/16/2004 15:41'!isEmpty	"Answer whether the receiver contains any elements."	^elements isEmpty! !!CHolder methodsFor: 'searching' stamp: 'ar 3/16/2004 15:41'!detect: aBlock 	"Evaluate aBlock with each of the receiver's elements as the argument. 	Answer the first element for which aBlock evaluates to true."	^elements detect: aBlock! !!CHolder methodsFor: 'searching' stamp: 'ar 3/16/2004 15:41'!detect: aBlock ifNone: exceptionBlock 	"Evaluate aBlock with each of the receiver's elements as the argument.  	Answer the first element for which aBlock evaluates to true. If none  	evaluate to true, then evaluate the argument, exceptionBlock."	^elements detect: aBlock ifNone: exceptionBlock! !!CHolder methodsFor: 'searching' stamp: 'ar 3/16/2004 17:24'!findFirstElement: aBlock	"Answer my first element for which aBlock evaluates as true."	^elements findFirstElement: aBlock! !!CHolder methodsFor: 'searching' stamp: 'ar 3/16/2004 17:26'!findFirstIndex: aBlock	"Answer the index of my first element for which aBlock evaluates as true."	^elements findFirstIndex: aBlock! !!CHolder methodsFor: 'searching' stamp: 'ar 3/16/2004 15:42'!findLast: aBlock	"Answer the index of my last element for which aBlock evaluates as true."	^elements findLast: aBlock! !!CHolder methodsFor: 'searching' stamp: 'ar 3/16/2004 17:25'!findLastElement: aBlock	"Answer my last element for which aBlock evaluates as true."	^elements findLastElement: aBlock! !!CHolder methodsFor: 'searching' stamp: 'ar 3/16/2004 15:42'!includes: anObject 	"Answer whether anObject is one of the receiver's elements."	^elements includes: anObject! !!CHolder methodsFor: 'searching' stamp: 'ar 3/16/2004 15:42'!indexOf: anObject	"Answer the index of the given object within the receiver"	^elements indexOf: anObject! !!CHolder methodsFor: 'searching' stamp: 'ar 3/16/2004 15:42'!indexOf: anElement ifAbsent: exceptionBlock	"Answer the index of the first occurence of anElement within the  	receiver. If the receiver does not contain anElement, answer the 	result of evaluating the argument, exceptionBlock."	^elements indexOf: anElement ifAbsent: exceptionBlock! !!CHolder methodsFor: 'searching' stamp: 'ar 3/16/2004 15:42'!indexOf: anElement startingAt: start ifAbsent: exceptionBlock	"Answer the index of the first occurence of anElement after start	within the receiver. If the receiver does not contain anElement, 	answer the 	result of evaluating the argument, exceptionBlock."	^elements indexOf: anElement startingAt: start ifAbsent: exceptionBlock! !!CHolder methodsFor: 'replacing' stamp: 'ar 3/16/2004 15:42'!replace: oldObject with: newObject	"Replace oldObject with newObject"	^elements replace: oldObject with: newObject! !!CHolder methodsFor: 'replacing' stamp: 'ar 3/16/2004 15:43'!replaceFrom: firstIndex to: lastIndex with: aCollection	"Replace the elements in the receiver"	^elements replaceFrom: firstIndex to: lastIndex with: aCollection! !!CHolder methodsFor: 'replacing' stamp: 'ar 3/16/2004 15:43'!replaceFrom: firstIndex to: lastIndex with: aCollection startingAt: replStart	^elements replaceFrom: firstIndex to: lastIndex with: aCollection startingAt: replStart! !!CHolder methodsFor: 'streaming' stamp: 'ar 3/16/2004 15:43'!atEnd	"answer whether the receiver is at its end"	^elements atEnd! !!CHolder methodsFor: 'streaming' stamp: 'ar 3/16/2004 15:43'!atStart	"answer whether the receiver is at its start"	^elements atStart! !!CHolder methodsFor: 'streaming' stamp: 'ar 3/16/2004 15:43'!next	"go to the next element in the receiver"	^elements next! !!CHolder methodsFor: 'streaming' stamp: 'ar 3/16/2004 15:43'!peek	"answer the element at the receiver's cursor"	^elements peek! !!CHolder methodsFor: 'streaming' stamp: 'ar 3/16/2004 15:43'!prev	"go to the previous element in the receiver"	^elements prev! !!CHolder methodsFor: 'streaming' stamp: 'ar 3/16/2004 15:44'!wrapCursor	"Answer whether the cursor can wrap around"	<bewareOf: #wrapCursorChanged>	^elements wrapCursor! !!CHolder methodsFor: 'streaming' stamp: 'ar 3/16/2004 15:44'!wrapCursor: aBool	"Indicate whether the cursor can wrap around"	^elements wrapCursor: aBool! !!CHolder methodsFor: 'enumerating' stamp: 'ar 3/16/2004 15:44'!allSatisfy: aBlock	"Evaluate aBlock with the elements of the receiver.	If aBlock returns false for any element return false.	Otherwise return true."	^elements allSatisfy: aBlock! !!CHolder methodsFor: 'enumerating' stamp: 'ar 3/16/2004 15:45'!anySatisfy: aBlock	"Evaluate aBlock with the elements of the receiver.	If aBlock returns true for any element return true.	Otherwise return false."	^elements anySatisfy: aBlock! !!CHolder methodsFor: 'enumerating' stamp: 'ar 3/16/2004 15:50'!collect: aBlock	"Evaluate aBlock with each of the receiver's elements as the argument.  	Collect the resulting values into a collection like the receiver. Answer  	the new collection."	^self collect: aBlock species: self species! !!CHolder methodsFor: 'enumerating' stamp: 'ar 3/16/2004 15:50'!collect: aBlock species: aClass	"Evaluate aBlock with each of the receiver's elements as the argument.  	Collect the resulting values into a collection like aClass. Answer  	the new collection."	^elements collect: aBlock species: aClass! !!CHolder methodsFor: 'enumerating' stamp: 'ar 3/15/2004 15:35'!do: aBlock	"Evaluate aBlock with each of the receiver's elements as the argument."	^elements do: aBlock! !!CHolder methodsFor: 'enumerating' stamp: 'ar 3/16/2004 15:45'!keysAndValuesDo: aBlock	"Evaluate aBlock with each of the receiver's keys and values"	^elements keysAndValuesDo: aBlock! !!CHolder methodsFor: 'enumerating' stamp: 'ar 3/16/2004 15:50'!select: aBlock 	"Evaluate aBlock with each of the receiver's elements as the argument. 	Collect into a new collection like the receiver, only those elements for 	which aBlock evaluates to true. Answer the new collection."	^self select: aBlock species: self species! !!CHolder methodsFor: 'enumerating' stamp: 'ar 3/16/2004 15:49'!select: aBlock species: aClass	"Evaluate aBlock with each of the receiver's elements as the argument. 	Collect into a new collection like the receiver, only those elements for 	which aBlock evaluates to true. Answer the new collection."	^elements select: aBlock species: aClass! !!CHolder methodsFor: 'copying' stamp: 'ar 3/15/2004 15:22'!copyFrom: firstIndex to: lastIndex	"Answer a copy of a subset of the receiver, starting from element at 	index start until element at index stop."	^elements copyFrom: firstIndex to: lastIndex! !!CHolder methodsFor: 'matching' stamp: 'ar 3/16/2004 15:46'!all	"Answer a new all matcher"	^CAllMatcher on: self! !!CHolder methodsFor: 'matching' stamp: 'ar 3/15/2004 15:36'!any	"Answer a new any matcher"	^CAnyMatcher on: self! !!CInspector methodsFor: 'field access' stamp: 'md 4/8/2004 12:02'!contentsPane	"Answer the contentsPane of the receiver"	<bewareOf: #contentsPaneChanged>	^self propertyValueAt: #contentsPane! !!CInspector methodsFor: 'field access' stamp: 'md 4/8/2004 12:02'!contentsPane: aValue	"Modify the receiver's contentsPane"	^self propertyValueAt: #contentsPane put: aValue with: #contentsPaneChanged! !!CInspector methodsFor: 'field access' stamp: 'md 4/8/2004 12:02'!listPane	"Answer the listPane of the receiver"	<bewareOf: #listPaneChanged>	^self propertyValueAt: #listPane! !!CInspector methodsFor: 'field access' stamp: 'md 4/8/2004 12:02'!listPane: aValue	"Modify the receiver's listPane"	^self propertyValueAt: #listPane put: aValue with: #listPaneChanged! !!CInspector methodsFor: 'accessing' stamp: 'md 4/8/2004 14:17'!baseFieldList	"Answer an Array consisting of 'self'	and the instance variable names of the inspected object."	^ (Array with: 'self' with: 'all inst vars')			, object class allInstVarNames! !!CInspector methodsFor: 'accessing' stamp: 'md 4/8/2004 14:17'!fieldList	"Answer the base field list plus an abbreviated list of indices."	object class isVariable ifFalse: [^ self baseFieldList].	^ self baseFieldList ,		(object basicSize <= (self i1 + self i2)			ifTrue: [(1 to: object basicSize)						collect: [:i | i printString]]			ifFalse: [(1 to: self i1) , (object basicSize-(self i2-1) to: object basicSize)						collect: [:i | i printString]])! !!CInspector methodsFor: 'accessing' stamp: 'md 4/21/2004 11:10'!i1	"This is the max index shown before skipping to the 	last i2 elements of very long arrays"	^ 100! !!CInspector methodsFor: 'accessing' stamp: 'md 4/21/2004 11:10'!i2	"This is the number of elements to show at the end	of very long arrays"	^ 10! !!CInspector methodsFor: 'accessing' stamp: 'md 4/21/2004 14:53'!initialExtent	"Answer the desired extent for the receiver when it is first opened on the screen.  "	^ 250 @ 200! !!CInspector methodsFor: 'accessing' stamp: 'md 4/9/2004 15:49'!object	^object! !!CInspector methodsFor: 'accessing' stamp: 'md 4/27/2004 12:30'!object: anObject 	"Set anObject to be the object being inspected by the receiver."	| oldIndex |	anObject == object		ifFalse:			[oldIndex _ listPane selectionIndex <= 2 ifTrue: [listPane selectionIndex] ifFalse: [0].			self inspect: anObject.			oldIndex _ oldIndex min: self fieldList size.			self changed: #inspectObject.			oldIndex > 0				ifTrue: [self toggleIndex: oldIndex].			self changed: #fieldList.			self changed: #contents]! !!CInspector methodsFor: 'accessing' stamp: 'md 4/21/2004 10:45'!selectedClass	"Answer the class of the receiver's current selection"	self selectionUnmodifiable ifTrue: [^ object class].	^ self selection class! !!CInspector methodsFor: 'accessing' stamp: 'md 4/21/2004 10:49'!selectedMessage	"This method was automatically generated"	^listPane selection.! !!CInspector methodsFor: 'accessing' stamp: 'md 4/21/2004 17:27'!selectionIndex	^listPane selectionIndex.! !!CInspector methodsFor: 'accessing' stamp: 'md 4/21/2004 17:28'!selectionIndex: anIndex	listPane selectionIndex: anIndex.! !!CInspector methodsFor: 'accessing' stamp: 'md 4/27/2004 13:12'!selectionPrintString	| mtext nm |	selectionUpdateTime _ [mtext _ [self selection printStringLimitedTo: 5000]		on: Error do: 		[nm _ self selectionIndex < 3					ifTrue: ['self']					ifFalse: [self selectedSlotName].		mtext _ ('<error in printString: evaluate "' , nm , ' printString" to debug>') asText.		mtext			addAttribute: TextColor red			from: 1			to: mtext size.		mtext]] timeToRun.	^ mtext! !!CInspector methodsFor: 'events' stamp: 'md 4/22/2004 13:18'!onAcceptContentsPane	"Update the class list when the system category list's cursor changes"	| result |	<on: save in: contentsPane> 		result _ self doItReceiver class evaluatorClass new				evaluate: (ReadStream on: contentsPane contents)				in: self doItContext				to: self doItReceiver				notifying: nil	"fix this"				ifFail:  [^ false].	result == #failedDoit ifFalse: 			[contentsPane contents: result printString.			self replaceSelectionValue: result].	self onListCursorChanged.	! !!CInspector methodsFor: 'events' stamp: 'md 4/27/2004 12:58'!onListCursorChanged	"Update the class list when the system category list's cursor changes"	<on: cursorChanged in: listPane> 	self displayContents.	! !!CInspector methodsFor: 'initialize' stamp: 'md 4/27/2004 12:15'!initialize	super initialize.	"Define our components"		self define: #listPane as: CList new.	listPane menu: self fieldListMenu.	"listPane userDataAt: #keyMap put: self fieldListKeyMap."	listPane allowDeselect: true.	self define: #contentsPane as: CTextEditor new.! !!CInspector methodsFor: 'initialize' stamp: 'ar 7/29/2004 21:30'!setupCostume	"Create the default costume"	window player: self.	window extent: self initialExtent.	window layout: CProportionalLayout new.	listPane costume: CStringListCostume new.	listPane color: Color transparent.	listPane layoutFrame: (0@0 extent: 0.25@0.7).	window add: listPane.	contentsPane color: Color transparent.	contentsPane layoutFrame: (0.25@0 extent: 0.75@0.7).	contentsPane hResizing: #spaceFill; vResizing: #spaceFill.	contentsPane textWrap: true.	contentsPane hScrollable: false; vScrollable: true.	window add: contentsPane.	codePane color: Color transparent.	codePane layoutFrame: (0@0.7 corner: 1@1).	codePane hResizing: #spaceFill; vResizing: #spaceFill.	codePane textWrap: true.	codePane hScrollable: false; vScrollable: true.	window add: codePane.	"Give all of my contents the default look"	window elements do:[:each|		each borderWidth: 2.		each borderStyle: #complexAltInset.		each borderColor: (Color r: 0.995 g: 0.788 b: 0.353).		each windowColor:  (Color r: 0.652 g: 0.8 b: 0.504).	].	window color:  (Color r: 0.652 g: 0.8 b: 0.504).! !!CInspector methodsFor: 'menu commands' stamp: 'md 4/21/2004 15:00'!addCollectionItemsTo: aMenu	"If the current selection is an appropriate collection, add items to aMenu that cater to that kind of selection"	| sel |	((((sel _ self selection) isMemberOf: Array) or: [sel isMemberOf: OrderedCollection]) and: 		[sel size > 0]) ifTrue: [			aMenu addList: #(				('inspect element...'					inspectElement))].	(sel isKindOf: MorphExtension) ifTrue: [			aMenu addList: #(				('inspect property...'				inspectElement))].! !!CInspector methodsFor: 'menu commands' stamp: 'md 4/23/2004 14:00'!browseFullProtocol	"Open up a protocol-category browser on the value of the receiver's current selection.  If in mvc, an old-style protocol browser is opened instead."	self cNotYet.	"| objectToRepresent |	Smalltalk isMorphic ifFalse: [^ self spawnProtocol].	objectToRepresent _ self selectionIndex == 0 ifTrue: [object] ifFalse: [self selection].	InstanceBrowser new openOnObject: objectToRepresent inWorld: ActiveWorld showingSelector: nil"! !!CInspector methodsFor: 'menu commands' stamp: 'md 4/21/2004 17:04'!chasePointers	| saved |	self selectionIndex == 0 ifTrue: [^ self changed: #flash].	saved _ self object.	[self object: nil.	(Smalltalk includesKey: #PointerFinder)		ifTrue: [PointerFinder on: saved]		ifFalse: [self inspectPointers]]		ensure: [self object: saved]! !!CInspector methodsFor: 'menu commands' stamp: 'md 4/21/2004 14:42'!classOfSelection	"Answer the class of the receiver's current selection"	self selectionUnmodifiable ifTrue: [^ object class].	^ self selection class! !!CInspector methodsFor: 'menu commands' stamp: 'md 4/22/2004 16:53'!classVarRefs	"Request a browser of methods that store into a chosen instance variable"	| aClass |	(aClass _ self classOfSelection) ifNotNil:		[self  browseClassVarRefs: aClass].! !!CInspector methodsFor: 'menu commands' stamp: 'md 4/21/2004 17:26'!copyName	"Copy the name of the current variable, so the user can paste it into the window below and work with is.  If collection, do (xxx at: 1). "	| sel aClass |	self selectionUnmodifiable ifTrue: [^ self changed: #flash].	(aClass _ self object class) isVariable ifTrue: [^ self changed: #flash].	sel _ aClass allInstVarNames at: listPane selectionIndex - 2.	(self selection isKindOf: Collection) ifTrue: [sel _ '(',sel,' at: 1)'].	Clipboard clipboardText: sel asText.	"no undo allowed"! !!CInspector methodsFor: 'menu commands' stamp: 'md 4/21/2004 17:05'!defsOfSelection	"Open a browser on all defining references to the selected instance variable, if that's what currently selected. "	| aClass sel |	self selectionUnmodifiable ifTrue: [^ self changed: #flash].	(aClass _ self object class) isVariable ifTrue: [^ self changed: #flash].	sel _ aClass allInstVarNames at: self selectionIndex - 2.	self systemNavigation  browseAllStoresInto: sel from: aClass! !!CInspector methodsFor: 'menu commands' stamp: 'md 4/27/2004 13:49'!fieldListKeyMap	"Set up the keymap"	| map |	map := CKeyboardDispatchTable new.	map add: #(cmd i) action: #inspectSelection.	map add: #(cmd I) action: #exploreSelection.	map add: #(cmd b) action: #browseMethodFull.	map add: #(cmd c) action: #copyName.	map add: #(cmd p) action: #browseFullProtocol.	map add: #(cmd r) action: #browseClassRefs.	map add: #(cmd v)  action: #viewerForValue.	^map! !!CInspector methodsFor: 'menu commands' stamp: 'md 4/21/2004 19:21'!fieldListMenu	"Arm the supplied menu with items for the field-list of the receiver"	| menu |	menu := CMenu new.	menu label: 'System Categories'.	menu addList: #(		('inspect (i)'						inspectSelection)		-		('method refs to this inst var'		referencesToSelection)		('methods storing into this inst var'	defsOfSelection)		('objects pointing to this value'		objectReferencesToSelection)		('chase pointers'					chasePointers)		-		('browse full (b)'					browseMethodFull)		('browse class'						browseMethodFull)		('browse hierarchy'					classHierarchy)		('browse protocol (p)'				browseFullProtocol)		-		('inst var refs...'					browseInstVarRefs)		('inst var defs...'					browseInstVarDefs)		('class var refs...'					classVarRefs)		('class variables'					browseClassVariables)		('class refs (N)'						browseClassRefs)		-		('copy name (c)'					copyName)				('basic inspect'						inspectBasic)		) target: self.	^menu				! !!CInspector methodsFor: 'menu commands' stamp: 'md 4/21/2004 17:24'!inspect: anObject 	"Initialize the receiver so that it is inspecting anObject. There is no 	current selection."	object _ anObject.	listPane contents: self fieldList.! !!CInspector methodsFor: 'menu commands' stamp: 'md 4/21/2004 17:25'!inspectBasic	"Bring up a non-special inspector"	listPane selectionIndex = 0 ifTrue: [^ object basicInspect].	self selection basicInspect! !!CInspector methodsFor: 'menu commands' stamp: 'md 4/21/2004 17:11'!inspectElement	| sel selSize countString count nameStrs |	"Create and schedule an Inspector on an element of the receiver's model's currently selected collection."	self selectionIndex = 0 ifTrue: [^ self changed: #flash].	((sel _ self selection) isKindOf: SequenceableCollection) ifFalse:		[(sel isKindOf: MorphExtension) ifTrue: [^ sel inspectElement].		^ sel inspect].	(selSize _ sel size) == 1 ifTrue: [^ sel first inspect].	selSize <= 20 ifTrue:		[nameStrs _ (1 to: selSize) asArray collect: [:ii | 			ii printString, '   ', ((sel at: ii) printStringLimitedTo: 25)].		count _ PopUpMenu withCaption: 'which element?' chooseFrom: nameStrs.		count = 0 ifTrue: [^ self].		^ (sel at: count) inspect].	countString _ FillInTheBlank request: 'Which element? (1 to ', selSize printString, ')' initialAnswer: '1'.	countString isEmptyOrNil ifTrue: [^ self].	count _ Integer readFrom: (ReadStream on: countString).	(count > 0 and: [count <= selSize])		ifTrue: [(sel at: count) inspect]		ifFalse: [self beep]! !!CInspector methodsFor: 'menu commands' stamp: 'md 4/21/2004 11:11'!inspectSelection	"Create and schedule an Inspector on the receiver's model's currently selected object."	self selectionIndex = 0 ifTrue: [^ self changed: #flash].	^CInspector openOn: self selection.! !!CInspector methodsFor: 'menu commands' stamp: 'md 4/21/2004 19:13'!objectReferencesToSelection	"Open a list inspector on all the objects that point to the value of the selected instance variable, if any.  "	self selectionIndex == 0 ifTrue: [^ self changed: #flash].	self systemNavigation		browseAllObjectReferencesTo: self selection		except: (Array with: self object)		ifNone: [:obj | self changed: #flash].! !!CInspector methodsFor: 'menu commands' stamp: 'md 4/21/2004 17:06'!referencesToSelection	"Open a browser on all references to the selected instance variable, if that's what currently selected.  1/25/96 sw"	| aClass sel |	self selectionUnmodifiable ifTrue: [^ self changed: #flash].	(aClass _ self object class) isVariable ifTrue: [^ self changed: #flash].	sel _ aClass allInstVarNames at: self selectionIndex - 2.	self systemNavigation   browseAllAccessesTo: sel from: aClass! !!CInspector methodsFor: 'menu commands' stamp: 'md 4/23/2004 13:59'!spawnFullProtocol	"Spawn a window showing full protocol for the receiver's selection"	self cNotYet.	"| objectToRepresent |	objectToRepresent _ self selectionIndex == 0 ifTrue: [object] ifFalse: [self selection].	ProtocolBrowser openFullProtocolForClass: objectToRepresent class"! !!CInspector methodsFor: 'menu commands' stamp: 'md 4/23/2004 13:59'!spawnProtocol	"Spawn a protocol on browser on the receiver's selection"	self cNotYet.	"| objectToRepresent |	objectToRepresent _ self selectionIndex == 0 ifTrue: [object] ifFalse: [self selection].	ProtocolBrowser openSubProtocolForClass: objectToRepresent class"! !!CInspector methodsFor: 'menu commands' stamp: 'md 4/23/2004 13:59'!viewerForValue	"Open up a viewer on the value of the receiver's current selection"	self cNotYet.	"| objectToRepresent |	objectToRepresent _ self selectionIndex == 0 ifTrue: [object] ifFalse: [self selection].	objectToRepresent beViewed"	! !!CInspector methodsFor: 'selecting' stamp: 'md 4/21/2004 17:26'!contentsIsString	"Hacked so contents empty when deselected and = long printString when item 2"	^ (listPane selectionIndex = 2) | (listPane selectionIndex = 0)! !!CInspector methodsFor: 'selecting' stamp: 'md 4/21/2004 17:29'!replaceSelectionValue: anObject 	"The receiver has a list of variables of its inspected object. One of these 	is selected. The value of the selected variable is set to the value, 	anObject."	| basicIndex si |	listPane selectionIndex <= 2 ifTrue: [		self toggleIndex: (si _ listPane selectionIndex).  		self toggleIndex: si.		^ object].	object class isVariable		ifFalse: [^ object instVarAt: listPane selectionIndex - 2 put: anObject].	basicIndex _ listPane selectionIndex - 2 - object class instSize.	(object basicSize <= (self i1 + self i2)  or: [basicIndex <= self i1])		ifTrue: [^object basicAt: basicIndex put: anObject]		ifFalse: [^object basicAt: object basicSize - (self i1 + self i2) + basicIndex					put: anObject]! !!CInspector methodsFor: 'selecting' stamp: 'md 4/21/2004 17:12'!selectedSlotName	^ self fieldList at: self selectionIndex! !!CInspector methodsFor: 'selecting' stamp: 'md 4/21/2004 17:25'!selection	"The receiver has a list of variables of its inspected object.	One of these is selected. Answer the value of the selected variable."	| basicIndex |	listPane selectionIndex = 0 ifTrue: [^ ''].	listPane selectionIndex = 1 ifTrue: [^ object].	listPane selectionIndex = 2 ifTrue: [^ object longPrintString].	(listPane selectionIndex - 2) <= object class instSize		ifTrue: [^ object instVarAt: listPane selectionIndex - 2].	basicIndex _ listPane selectionIndex - 2 - object class instSize.	(object basicSize <= (self i1 + self i2)  or: [basicIndex <= self i1])		ifTrue: [^ object basicAt: basicIndex]		ifFalse: [^ object basicAt: object basicSize - (self i1 + self i2) + basicIndex]! !!CInspector methodsFor: 'selecting' stamp: 'md 4/21/2004 17:26'!selectionUnmodifiable	"Answer if the current selected variable is modifiable via acceptance in the code pane.  For most inspectors, no selection and a selection of self (selectionIndex = 1) are unmodifiable"	^ listPane selectionIndex <= 2! !!CInspector methodsFor: 'code' stamp: 'md 4/21/2004 14:50'!doItReceiver	"Answer the object that should be informed of the result of evaluating a	text selection."	^object! !!CInspector methodsFor: 'updating' stamp: 'md 4/27/2004 13:12'!displayContents	| newText |	newText _ self contentsIsString		ifTrue: [newText _ self selection]		ifFalse: ["keep it short to reduce time to compute it"			self selectionPrintString ].	newText = contentsPane contents ifFalse: [		self contentsPane contents: newText.	]! !!CInspector methodsFor: 'updating' stamp: 'md 4/27/2004 13:31'!updateContentsPane	<ticking: 2> 	"todo: as fast as possible, update all selectionUpdateTime * 10 mseconds"	self displayContents.! !!CInspector methodsFor: 'updating' stamp: 'md 4/27/2004 13:20'!updateFull	"Full update not more often than once every 5 seconds"	<ticking: 0.2> 		listPane contents: self fieldList.			! !!CContextVariablesInspector methodsFor: 'accessing' stamp: 'md 4/7/2004 16:46'!fieldList 	"Refer to the comment in Inspector|fieldList."	object == nil ifTrue: [^Array with: 'thisContext'].	^(Array with: 'thisContext' with: 'all temp vars') , object tempNames! !!CContextVariablesInspector methodsFor: 'selecting' stamp: 'md 4/21/2004 17:26'!replaceSelectionValue: anObject 	"Refer to the comment in Inspector|replaceSelectionValue:."	listPane selectionIndex = 1		ifTrue: [^object]		ifFalse: [^object tempAt: listPane selectionIndex - 2 put: anObject]! !!CContextVariablesInspector methodsFor: 'selecting' stamp: 'md 4/21/2004 17:26'!selection 	"Refer to the comment in Inspector|selection."	listPane selectionIndex = 0 ifTrue:[^''].	listPane selectionIndex = 1 ifTrue: [^object].	listPane selectionIndex = 2		ifTrue: [^object tempsAndValues]		ifFalse: [^object tempAt: listPane selectionIndex - 2]! !!CContextVariablesInspector methodsFor: 'code' stamp: 'md 4/7/2004 16:46'!doItContext	^object! !!CContextVariablesInspector methodsFor: 'code' stamp: 'md 4/7/2004 16:46'!doItReceiver	^object receiver! !!CLibraryEntryCostume methodsFor: 'events' stamp: 'ar 2/24/2004 23:02'!deselect	self color: Color transparent.! !!CLibraryEntryCostume methodsFor: 'events' stamp: 'ar 3/16/2004 13:52'!onDragStart	| aPlayer event newGuy target |	<on: dragStart>	self value ifNil:[^self].	aPlayer := CPlayer new.	aPlayer extent: self value image extent.	aPlayer color: Color transparent.	aPlayer graphic: self value image.	aPlayer value: self value value. "the maker"	self hand attach: aPlayer.	aPlayer center: self hand position.	"Okay, this looks wrong - see comment in Object>>waitUntil:..."	event := aPlayer waitUntil: #dropped.	target := event arguments first.	newGuy := self value next asPlayer.	newGuy topLeft: aPlayer topLeft.	target elements replace: aPlayer with: newGuy.! !!CLibraryEntryCostume methodsFor: 'events' stamp: 'ar 3/6/2004 15:58'!onValueChanged	<on: valueChanged>	image graphic: self value image.	label value: self value label.! !!CLibraryEntryCostume methodsFor: 'events' stamp: 'ar 2/24/2004 23:04'!select	self color: (Color r: 1 g: 0.7 b: 0.15).! !!CLibraryEntryCostume methodsFor: 'initialize' stamp: 'ar 3/22/2004 14:40'!initialize	super initialize.	self define: #label as: CLabel new.	self define: #image as: CPlayer new.! !!CLibraryEntryCostume methodsFor: 'initialize' stamp: 'ar 4/30/2004 15:58'!setupCostume	self layout: CTableLayout new.	self add: label.	self add: image.	image graphic: CCostumeGraphic new.	image graphicFit: #scale.	self borderStyle: #simple; borderWidth: 1; borderColor: Color black.	self roundCorners: true.	self extent: 64@64.! !!CLibraryEntryCostume methodsFor: 'accessing' stamp: 'ar 3/12/2004 16:25'!image	"Answer the image of the receiver"	<bewareOf: #imageChanged>	^self propertyValueAt: #image! !!CLibraryEntryCostume methodsFor: 'accessing' stamp: 'ar 3/12/2004 16:25'!image: aValue	"Modify the receiver's image"	^self propertyValueAt: #image put: aValue with: #imageChanged! !!CLibraryEntryCostume methodsFor: 'accessing' stamp: 'ar 3/12/2004 16:25'!label	"Answer the label of the receiver"	<bewareOf: #labelChanged>	^self propertyValueAt: #label! !!CLibraryEntryCostume methodsFor: 'accessing' stamp: 'ar 3/12/2004 16:25'!label: aValue	"Modify the receiver's label"	^self propertyValueAt: #label put: aValue with: #labelChanged! !!CList methodsFor: 'initialize' stamp: 'ar 3/1/2004 14:48'!defaultCostume	^CWidgetLibrary default listCostume! !!CList methodsFor: 'initialize' stamp: 'ar 3/25/2004 11:32'!initialize	super initialize.	items := CCollection new.	hScrollable := false.	vScrollable := true.	allowDeselect := true.! !!CList methodsFor: 'accessing' stamp: 'ar 3/17/2004 15:10'!allowDeselect	"This method was automatically generated"	<bewareOf: #allowDeselectChanged>	^(self propertyValueAt: #allowDeselect) ifNil:[false]! !!CList methodsFor: 'accessing' stamp: 'ar 3/11/2004 14:22'!allowDeselect: aValue	"This method was automatically generated"	^self propertyValueAt: #allowDeselect put: aValue with: #allowDeselectChanged! !!CList methodsFor: 'accessing' stamp: 'ar 3/6/2004 19:49'!contents	^self elements contents! !!CList methodsFor: 'accessing' stamp: 'ar 3/6/2004 19:49'!contents: aCollection	self elements contents: aCollection! !!CList methodsFor: 'accessing' stamp: 'ar 3/25/2004 11:32'!elements	"Answer the elements of the receiver"	^items! !!CList methodsFor: 'accessing' stamp: 'ar 3/24/2004 15:01'!itemMaker	"Answer the itemMaker of the receiver"	<bewareOf: #itemMakerChanged>	^self propertyValueAt: #itemMaker! !!CList methodsFor: 'accessing' stamp: 'ar 3/24/2004 15:01'!itemMaker: aValue	"Modify the receiver's itemMaker"	^self propertyValueAt: #itemMaker put: aValue with: #itemMakerChanged! !!CList methodsFor: 'accessing' stamp: 'ar 3/25/2004 11:32'!items	"Answer the items of the receiver"	<bewareOf: #itemsChanged>	^self propertyValueAt: #items! !!CList methodsFor: 'accessing' stamp: 'ar 3/25/2004 11:32'!items: aValue	"Modify the receiver's items"	^self propertyValueAt: #items put: aValue with: #itemsChanged! !!CList methodsFor: 'events' stamp: 'ar 3/25/2004 11:32'!onCursorChanged: newCursor	"Resignal changes from our elements so that clients can listen to them."	<on: cursorChanged in: items>	self signal: #cursorChanged with: newCursor! !!CList methodsFor: 'events' stamp: 'ar 3/25/2004 11:32'!onElementsChanged: typeOfChange from: firstIndex to: lastIndex event: thisEvent	"Resignal changes from our elements so that clients can listen to them."	<on: changed in: items>	(self handlesEvent: #changed) ifFalse:[^nil].	thisEvent withDroppedEvents do:[:each|		each setSender: self.		self signalEvent: each.	].! !!CList methodsFor: 'events' stamp: 'ar 3/25/2004 11:32'!onWrapCursorChanged: newValue	"Resignal changes from our elements so that clients can listen to them."	<on: wrapCursorChanged in: items>	self signal: #wrapCursorChanged with: newValue.! !!CDropDownList methodsFor: 'initialize' stamp: 'ar 3/7/2004 18:03'!defaultCostume	^CWidgetLibrary default dropDownListCostume! !!CDropDownList methodsFor: 'initialize' stamp: 'ar 3/24/2004 23:48'!initialize	super initialize.	allowEditing := false.! !!CDropDownList methodsFor: 'accessing' stamp: 'ar 3/12/2004 15:37'!allowEditing	"Answer the allowEditing of the receiver"	<bewareOf: #allowEditingChanged>	^self propertyValueAt: #allowEditing! !!CDropDownList methodsFor: 'accessing' stamp: 'ar 3/12/2004 15:37'!allowEditing: aValue	"Modify the receiver's allowEditing"	^self propertyValueAt: #allowEditing put: aValue with: #allowEditingChanged! !!CDropDownList methodsFor: 'events' stamp: 'ar 4/4/2004 19:15'!onCursorChanged: newCursor	value := items selection.	super onCursorChanged: newCursor.! !!CDropDownList methodsFor: 'events' stamp: 'ar 4/4/2004 19:15'!onValueChanged	<on: valueChanged>	items selection: value.! !!CMenuItemSeparator methodsFor: 'initialize' stamp: 'ar 3/21/2004 04:50'!initialize	super initialize.	self extent: 2@1.	self color: CWidgetLibrary default baseColor.	self hResizing: #spaceFill; vResizing: #rigid.! !!CMenuItemSeparator methodsFor: 'accessing' stamp: 'ar 3/6/2004 23:07'!action	^nil! !!CMenuItemSeparator methodsFor: 'accessing' stamp: 'ar 3/6/2004 23:07'!deselect	"do nothing"! !!CMenuItemSeparator methodsFor: 'accessing' stamp: 'ar 3/13/2004 18:53'!isSeparator	^true! !!CMenuItemSeparator methodsFor: 'accessing' stamp: 'ar 3/6/2004 23:07'!select	"do nothing"! !!CMenuItemSeparator methodsFor: 'accessing' stamp: 'ar 3/6/2004 23:06'!subMenu	^nil! !!CMessageSet methodsFor: 'initialize' stamp: 'ar 4/3/2004 20:10'!initialize	"Initialize the receiver"	super initialize.	self define: #messageList as: CList new.	messageList allowDeselect: true.	messageList menu: self messageListMenu.! !!CMessageSet methodsFor: 'initialize' stamp: 'ar 7/29/2004 21:31'!setupCostume	"Create the default costume"	super setupCostume.	window extent: 400@265.	messageList costume: CStringListCostume new.	messageList color: Color transparent.	messageList layoutFrame: (0@0 corner: 1@0.3).	window add: messageList.	codePane layoutFrame: (0@0.3 corner: 1@1).	"Give all of my contents the default look"	window elements do:[:each|		each borderWidth: 2.		each borderStyle: #complexAltInset.		each borderColor: (Color r: 0.995 g: 0.788 b: 0.353).		each windowColor: (Color r: 0.664 g: 0.8 b: 0.8).	].	window color: (Color r: 0.664 g: 0.8 b: 0.8).! !!CMessageSet methodsFor: 'field access' stamp: 'ar 3/17/2004 15:11'!autoSelectString	"This method was automatically generated"	<bewareOf: #autoSelectStringChanged>	^self propertyValueAt: #autoSelectString! !!CMessageSet methodsFor: 'field access' stamp: 'ar 3/11/2004 14:23'!autoSelectString: aValue	"This method was automatically generated"	^self propertyValueAt: #autoSelectString put: aValue with: #autoSelectStringChanged! !!CMessageSet methodsFor: 'field access' stamp: 'ar 3/17/2004 15:11'!selectedReference	"This method was automatically generated"	<bewareOf: #selectedReferenceChanged>	^self propertyValueAt: #selectedReference! !!CMessageSet methodsFor: 'field access' stamp: 'ar 3/11/2004 14:23'!selectedReference: aValue	"This method was automatically generated"	^self propertyValueAt: #selectedReference put: aValue with: #selectedReferenceChanged! !!CMessageSet methodsFor: 'events' stamp: 'ar 3/7/2004 00:08'!onMessageListCursorChanged	"Update the code pane when the message list's cursor changes"	<on: cursorChanged in: messageList>	(self okToChangeList: messageList from: self selectedReference)		ifTrue:[self selectedReference: messageList selection]! !!CMessageSet methodsFor: 'events' stamp: 'ar 3/7/2004 00:18'!onSelectedReferenceChanged	| mref code |	<on: selectedReferenceChanged>	mref := self selectedReference ifNil:[^codePane contents: ''].	code := mref sourceCode asText makeSelectorBoldIn: (mref actualClass ifNil:[self]).	codePane contents: code.	self autoSelectString ifNil:[^self].	codePane findText: self autoSelectString wrapping: false caseSensitive: true.	codePane showCaret: true.! !!CMessageSet methodsFor: 'menu' stamp: 'ar 3/6/2004 23:58'!messageListMenu	^nil! !!CMessageSet methodsFor: 'accessing' stamp: 'ar 3/14/2004 15:28'!messageList	"Answer the messageList of the receiver"	<bewareOf: #messageListChanged>	^self propertyValueAt: #messageList! !!CMessageSet methodsFor: 'accessing' stamp: 'ar 3/14/2004 15:28'!messageList: aValue	"Modify the receiver's messageList"	^self propertyValueAt: #messageList put: aValue with: #messageListChanged! !!CChangedMessageSet methodsFor: 'initialization' stamp: 'md 4/23/2004 17:18'!changeSet: aChangeSet	changeSet _ aChangeSet! !!CChangedMessageSet methodsFor: 'acceptance' stamp: 'md 4/23/2004 17:18'!contents: aString notifying: aController	"Accept the string as new source for the current method, and make certain the annotation pane gets invalidated"	| existingSelector existingClass superResult newSelector |	existingSelector _ self selectedMessageName.	existingClass _ self selectedClassOrMetaClass.	superResult _ super contents: aString notifying: aController.	superResult ifTrue:  "succeeded"		[newSelector _ Parser new parseSelector: aString.		newSelector ~= existingSelector			ifTrue:   "Selector changed -- maybe an addition"				[self reformulateList.				self changed: #messageList.				self messageList doWithIndex:					[:aMethodReference :anIndex |						(aMethodReference actualClass == existingClass and:									[aMethodReference methodSymbol == newSelector])							ifTrue:								[self messageListIndex: anIndex]]]].	^ superResult! !!CChangedMessageSet methodsFor: 'message list' stamp: 'md 4/23/2004 17:18'!growable	"Answer whether the receiver can be changed by manual additions & deletions"	^ false! !!CChangedMessageSet methodsFor: 'reformulation' stamp: 'md 4/23/2004 17:18'!reformulateList	"Reformulate the message list of the receiver"	self initializeMessageList: (changeSet changedMessageListAugmented select: 		[:each | each isValid])! !!CMoviePlayer methodsFor: 'initialize' stamp: 'ar 3/14/2004 17:47'!initialize	super initialize.	self color: Color white.! !!CMultiColorPicker methodsFor: 'events' stamp: 'ar 3/13/2004 23:30'!onColorsChanged	self value: (colorValues collect:[:each| each value]).! !!CMultiColorPicker methodsFor: 'events' stamp: 'ar 3/13/2004 23:14'!onValueChanged	<on: valueChanged>	self colors: self value.! !!CMultiColorPicker methodsFor: 'private' stamp: 'ar 3/13/2004 23:23'!setupPicker	colorValues := #().	self value: (Array with: Color white).! !!CMultiColumnList methodsFor: 'initialize' stamp: 'ar 3/12/2004 21:45'!defaultCostume	^CMultiColumnListCostume! !!CMultiColumnList methodsFor: 'initialize' stamp: 'ar 3/12/2004 10:51'!initialize	super initialize.	columns := #().! !!CMultiColumnList methodsFor: 'accessing' stamp: 'ar 3/12/2004 10:50'!addColumn: colLabel for: colOwner width: colWidth color: colColor action: colAction draw: colDraw	| colSpec |	colSpec := CMultiColumnListSpec new.	colSpec		label: colLabel;		width: colWidth;		color: colColor;		action: (colAction ifNotNil:[MessageSend receiver: colOwner selector: colAction]);		drawer: colOwner;		drawSelector: colDraw.	self addColumnSpec: colSpec.! !!CMultiColumnList methodsFor: 'accessing' stamp: 'ar 3/12/2004 10:51'!addColumnSpec: colSpec	columns := columns copyWith: colSpec.! !!CMultiColumnList methodsFor: 'accessing' stamp: 'ar 3/12/2004 14:06'!columns	"Answer the columns of the receiver"	<bewareOf: #columnsChanged>	^self propertyValueAt: #columns! !!CMultiColumnList methodsFor: 'accessing' stamp: 'ar 3/12/2004 10:51'!columns: aValue	"Modify the receiver's columns"	^self propertyValueAt: #columns put: aValue with: #columnsChanged! !!CMultiSelectionHalo methodsFor: 'initialize' stamp: 'ar 3/23/2004 18:09'!initialize	super initialize.	self borderWidth: 1.	self borderStyle: #simple.	self borderColor: CWidgetLibrary default frameColor.	self color: CWidgetLibrary default paneColor.	self fillAlpha: 0.5.! !!CPlayerCollection methodsFor: 'accessing' stamp: 'ar 3/29/2004 22:37'!at: aKey	^(costume at: aKey) asPlayer! !!CPlayerCollection methodsFor: 'accessing' stamp: 'ar 3/29/2004 22:37'!at: aKey ifAbsent: aBlock	^(costume at: aKey ifAbsent:[^aBlock value]) asPlayer! !!CPlayerCollection methodsFor: 'accessing' stamp: 'tk 7/14/2004 11:26'!at: index put: anObject	^costume replaceFrom: index to: index with: {anObject asPrimCostume}! !!CPlayerCollection methodsFor: 'accessing' stamp: 'ar 3/16/2004 11:46'!contentType	^CPlayer! !!CPlayerCollection methodsFor: 'accessing' stamp: 'ar 3/16/2004 12:36'!costume	^costume! !!CPlayerCollection methodsFor: 'accessing' stamp: 'ar 3/16/2004 12:36'!costume: aCostume	costume := aCostume.! !!CPlayerCollection methodsFor: 'accessing' stamp: 'ar 3/16/2004 17:06'!cursor	^self propertyValueAt: #cursor ifAbsent:[0]! !!CPlayerCollection methodsFor: 'accessing' stamp: 'ar 3/16/2004 17:42'!cursor: aNumber	^self propertyValueAt: #cursor put: (aNumber min: self size max: 0) with: #cursorChanged! !!CPlayerCollection methodsFor: 'accessing' stamp: 'ar 3/16/2004 12:16'!size	^costume size! !!CPlayerCollection methodsFor: 'adding' stamp: 'tk 7/14/2004 11:25'!add: anObject at: index	^costume add: anObject asPrimCostume at: index! !!CPlayerCollection methodsFor: 'adding' stamp: 'tk 7/14/2004 11:25'!addAll: aCollection at: index	^costume addAll: (aCollection collect:[:each| each asPrimCostume]) at: index! !!CPlayerCollection methodsFor: 'removing' stamp: 'ar 3/16/2004 12:17'!removeAll	^costume removeAll! !!CPlayerCollection methodsFor: 'removing' stamp: 'ar 3/16/2004 12:17'!removeFrom: firstIndex to: lastIndex	^costume removeFrom: firstIndex to: lastIndex! !!CPlayerCollection methodsFor: 'copying' stamp: 'ar 3/16/2004 12:17'!copyFrom: firstIndex to: lastIndex	^(costume copyFrom: firstIndex to: lastIndex) collect:[:each| each player]! !!CPlayerCollection methodsFor: 'copying' stamp: 'tk 7/14/2004 11:26'!replaceFrom: firstIndex to: lastIndex with: aCollection startingAt: replStart	^costume 		replaceFrom: firstIndex 		to: lastIndex 		with: (aCollection collect:[:each| each asPrimCostume])		startingAt: replStart! !!CPlayerCollection methodsFor: 'searching' stamp: 'tk 7/14/2004 11:26'!indexOf: anElement startingAt: start ifAbsent: exceptionBlock	"Answer the index of the first occurence of anElement after start	within the receiver. If the receiver does not contain anElement, 	answer the 	result of evaluating the argument, exceptionBlock.	Note: There is no point in searching for anything but players	since all others would have their costumes created on the fly."	anElement isPlayer ifFalse:[^exceptionBlock value].			^costume indexOf: anElement asPrimCostume startingAt: start ifAbsent: exceptionBlock! !!CPlayerCollection methodsFor: 'enumerating' stamp: 'ar 3/29/2004 22:37'!do: aBlock	^costume do:[:each| aBlock value: each asPlayer]! !!CPlayerCollection methodsFor: 'enumerating' stamp: 'ar 3/29/2004 22:37'!keysAndValuesDo: aBlock	^costume keysAndValuesDo:[:aKey :aValue| aBlock value: aKey value: aValue asPlayer]! !!CPlayerCollection methodsFor: 'enumerating' stamp: 'ar 3/29/2004 22:37'!reverseDo: aBlock	^costume reverseDo:[:each| aBlock value: each asPlayer]! !!CPreDebugger methodsFor: 'initializing' stamp: 'md 4/29/2004 14:26'!initialize	"Initialize the receiver"	super initialize.	self define: #notifyPane as: CList new.	"messageList menu: self messageListMenu."	self define: #proceedButton as: CButton new.	self define: #abortButton as: CButton new.	self define: #debugButton as: CButton new.	! !!CPreDebugger methodsFor: 'initializing' stamp: 'ar 7/29/2004 21:31'!setupCostume	"Create the default costume"	window player: self.	window extent:  450 @ 200.	window layout: CProportionalLayout new.	proceedButton label: 'Proceed'.	proceedButton layoutFrame: (0@0 extent: 0.33@0.2).	proceedButton hResizing: #shrinkWrap; vResizing: #shrinkWrap.	proceedButton roundCorners: true.	window add: proceedButton.	abortButton label: 'Abort'.	abortButton layoutFrame: (0.33@0 extent: 0.33@0.2).	abortButton hResizing: #shrinkWrap; vResizing: #shrinkWrap.	abortButton roundCorners: true.	window add: abortButton.	debugButton label: 'Debug'.	debugButton layoutFrame: (0.66@0 extent: 0.34@0.2).	debugButton hResizing: #shrinkWrap; vResizing: #shrinkWrap.	debugButton roundCorners: true.	window add: debugButton.	notifyPane costume: CStringListCostume new.	notifyPane color: Color transparent.	notifyPane layoutFrame: (0@0.2 corner: 1@1).	window add: notifyPane.	window elements do:[:each|		each borderWidth: 2.		each borderStyle: #complexAltInset.		each borderColor: (Color r: 0.995 g: 0.788 b: 0.353).		each windowColor: (Color r: 0.652 g: 0.8 b: 0.504).	].	window color:  (Color r: 0.652 g: 0.8 b: 0.504).! !!CPreDebugger methodsFor: 'events' stamp: 'ar 7/19/2004 18:58'!abort	<on: fire in: abortButton>	player abort.	window close.! !!CPreDebugger methodsFor: 'events' stamp: 'md 5/3/2004 13:59'!debug	<on: fire in: debugButton>	player debug.	window close.! !!CPreDebugger methodsFor: 'events' stamp: 'md 4/28/2004 15:40'!debugAt	<on: cursorChanged in: notifyPane> 	player debugAt: notifyPane selectionIndex.	self close.! !!CPreDebugger methodsFor: 'events' stamp: 'ar 7/19/2004 18:58'!onCloseRequest	<on: closeRequest in: window>	self abort.! !!CPreDebugger methodsFor: 'events' stamp: 'md 5/3/2004 14:46'!proceed	<on: fire in: proceedButton>	player proceed.	window close.! !!CPreDebugger methodsFor: 'accessing' stamp: 'md 4/28/2004 12:47'!abortButton	"Answer the abortButton of the receiver"	<bewareOf: #abortButtonChanged>	^self propertyValueAt: #abortButton! !!CPreDebugger methodsFor: 'accessing' stamp: 'md 4/28/2004 12:47'!abortButton: aValue	"Modify the receiver's abortButton"	^self propertyValueAt: #abortButton put: aValue with: #abortButtonChanged! !!CPreDebugger methodsFor: 'accessing' stamp: 'md 4/28/2004 12:47'!debugButton	"Answer the debugButton of the receiver"	<bewareOf: #debugButtonChanged>	^self propertyValueAt: #debugButton! !!CPreDebugger methodsFor: 'accessing' stamp: 'md 4/28/2004 12:47'!debugButton: aValue	"Modify the receiver's debugButton"	^self propertyValueAt: #debugButton put: aValue with: #debugButtonChanged! !!CPreDebugger methodsFor: 'accessing' stamp: 'md 4/28/2004 12:46'!notifyPane	"Answer the notifyPane of the receiver"	<bewareOf: #notifyPaneChanged>	^self propertyValueAt: #notifyPane! !!CPreDebugger methodsFor: 'accessing' stamp: 'md 4/28/2004 12:46'!notifyPane: aValue	"Modify the receiver's notifyPane"	^self propertyValueAt: #notifyPane put: aValue with: #notifyPaneChanged! !!CPreDebugger methodsFor: 'accessing' stamp: 'md 4/28/2004 12:46'!proceedButton	"Answer the proceedButton of the receiver"	<bewareOf: #proceedButtonChanged>	^self propertyValueAt: #proceedButton! !!CPreDebugger methodsFor: 'accessing' stamp: 'md 4/28/2004 12:46'!proceedButton: aValue	"Modify the receiver's proceedButton"	^self propertyValueAt: #proceedButton put: aValue with: #proceedButtonChanged! !!CPrimitiveCostume methodsFor: 'accessing' stamp: 'ar 3/24/2004 03:13'!balloonHelp	^self propertyValueAt: #balloonHelp! !!CPrimitiveCostume methodsFor: 'accessing' stamp: 'ar 3/24/2004 03:13'!balloonHelp: aText	self propertyValueAt: #balloonHelp put: aText.	self signal: #balloonHelpChanged.	^aText! !!CPrimitiveCostume methodsFor: 'accessing' stamp: 'ar 3/24/2004 03:14'!border	^border! !!CPrimitiveCostume methodsFor: 'accessing' stamp: 'ar 3/24/2004 03:14'!border: aBorder	"Give the receiver a new border"	aBorder == border ifTrue:[^aBorder].	aBorder ifNil:[		border isNoBorder ifTrue:[^nil].		border costume: nil.		border := CNoBorder forCostume: self.		^nil].	border isNoBorder ifTrue:[		border := CCostumeBorder new.		border costume: self.	].	border loadFrom: aBorder.	^aBorder! !!CPrimitiveCostume methodsFor: 'accessing' stamp: 'ar 3/24/2004 03:12'!cacheEnabled	^(flags bitAnd: FlagCached) == FlagCached! !!CPrimitiveCostume methodsFor: 'accessing' stamp: 'ar 3/24/2004 03:12'!cacheEnabled: aBool	aBool = self localCache notNil ifFalse:[		^self localCache: (aBool ifTrue:[self newFormCache] ifFalse:[nil]).	].	flags := aBool ifTrue:[flags bitOr: FlagCached] ifFalse:[flags bitClear: FlagCached].! !!CPrimitiveCostume methodsFor: 'accessing' stamp: 'ar 1/8/2003 16:57'!container	"Answer the container of this costume"	^ container! !!CPrimitiveCostume methodsFor: 'accessing' stamp: 'ar 12/8/2003 19:36'!costume	^self! !!CPrimitiveCostume methodsFor: 'accessing' stamp: 'ar 3/24/2004 03:14'!dropShadow	^self highlightNamed: #dropShadow! !!CPrimitiveCostume methodsFor: 'accessing' stamp: 'ar 3/24/2004 03:14'!dropShadow: aDropShadow	aDropShadow ifNil:[^self removeHighlight: #dropShadow].	aDropShadow name: #dropShadow.	self addHighlight: aDropShadow.! !!CPrimitiveCostume methodsFor: 'accessing' stamp: 'ar 3/16/2004 13:42'!elements	"Answer the players represented by this costume"	^self propertyValueAt: #elements ifAbsentPut:[CPlayerCollection costume: self].! !!CPrimitiveCostume methodsFor: 'accessing' stamp: 'ar 3/16/2004 13:42'!elements: aCollection	"Give this costume a set of new elements"	self elements contents: aCollection! !!CPrimitiveCostume methodsFor: 'accessing' stamp: 'ar 3/24/2004 03:15'!fill	^fill! !!CPrimitiveCostume methodsFor: 'accessing' stamp: 'ar 3/24/2004 03:15'!fill: aFill	aFill == fill ifTrue:[^aFill].	aFill ifNil:[		fill isNoFill ifTrue:[^nil].		fill costume: nil.		fill := CNoFill forCostume: self.		^nil].	fill isNoFill 		ifTrue:[fill := CCostumeFill forCostume: self].	fill loadFrom: aFill.	^aFill! !!CPrimitiveCostume methodsFor: 'accessing' stamp: 'ar 9/18/2003 22:50'!fullBounds	| fullBounds |	(flags bitAnd: FlagIntrinsicFullBounds) == 0 ifTrue:[^bounds]."true ifTrue:[^self localFullBounds transformedBy: self transform]."	(flags bitAnd: FlagHasFullBounds) == 0 		ifFalse:[^properties at: #fullBounds].	fullBounds := self localFullBounds transformedBy: self transform.	self propertyValueAt: #fullBounds put: fullBounds.	flags := flags bitOr: FlagHasFullBounds.	^fullBounds! !!CPrimitiveCostume methodsFor: 'accessing' stamp: 'ar 3/23/2004 22:08'!geometry	^self! !!CPrimitiveCostume methodsFor: 'accessing' stamp: 'ar 3/24/2004 03:10'!grid	^self propertyValueAt: #grid! !!CPrimitiveCostume methodsFor: 'accessing' stamp: 'ar 3/26/2004 21:08'!grid: newGrid	| oldGrid |	oldGrid := self grid.	oldGrid ifNotNil:[oldGrid costume: nil].	newGrid ifNotNil:[newGrid costume: self].	self setFlag: FlagHasGrid value: newGrid notNil.	self signal: #gridChanged.	^self propertyValueAt: #grid put: newGrid.! !!CPrimitiveCostume methodsFor: 'accessing' stamp: 'ar 3/29/2003 17:16'!hand	^Processor activeProcess hand! !!CPrimitiveCostume methodsFor: 'accessing'!hidden	^(flags bitAnd: FlagHidden) == FlagHidden! !!CPrimitiveCostume methodsFor: 'accessing' stamp: 'ar 8/10/2004 11:33'!hidden: aBool	self hidden = aBool ifTrue:[^self].	self invalidate.	flags := aBool ifTrue:[flags bitOr: FlagHidden] ifFalse:[flags bitClear: FlagHidden].	self invalidate.	self signal: #flagsChanged.	container ifNotNil:[container invalidateLayout].! !!CPrimitiveCostume methodsFor: 'accessing' stamp: 'ar 3/24/2004 03:12'!localCache	^self propertyValueAt: #localCache! !!CPrimitiveCostume methodsFor: 'accessing' stamp: 'ar 3/24/2004 03:12'!localCache: aCache	self propertyValueAt: #localCache put: aCache.	self cacheEnabled: aCache notNil.! !!CPrimitiveCostume methodsFor: 'accessing' stamp: 'ar 3/23/2004 23:06'!localClipBounds	"TODO: Remove this method"	self clipping ifFalse:[^self localFullBounds].	^self propertyValueAt: #localClipBounds ifAbsent:[self innerBounds]! !!CPrimitiveCostume methodsFor: 'accessing' stamp: 'ar 3/24/2004 03:13'!mouseCursor	"Answer the associated mouse cursor for this costume"	^self propertyValueAt: #mouseCursor! !!CPrimitiveCostume methodsFor: 'accessing' stamp: 'bf 3/30/2004 10:36'!mouseCursor: newCursor	"Answer the associated mouse cursor for this costume"	self propertyValueAt: #mouseCursor put: newCursor.	self signal: #mouseCursorChanged.	^ newCursor! !!CPrimitiveCostume methodsFor: 'accessing' stamp: 'ar 2/5/2003 15:16'!name	^self player ifNil:[super name] ifNotNil:[self player name]! !!CPrimitiveCostume methodsFor: 'accessing' stamp: 'ar 3/24/2004 03:11'!overlay	^self propertyValueAt: #overlay! !!CPrimitiveCostume methodsFor: 'accessing' stamp: 'ar 3/24/2004 03:11'!overlay: aPlayer	aPlayer ifNil:[		self removeProperty: #overlay.		flags := flags bitClear: FlagHasOverlay.	] ifNotNil:[		self propertyValueAt: #overlay put: aPlayer.		flags := flags bitOr: FlagHasOverlay.	].	self invalidate.	self signal: #overlayChanged.	^aPlayer! !!CPrimitiveCostume methodsFor: 'accessing' stamp: 'ar 3/24/2004 03:10'!player	^self propertyValueAt: #player! !!CPrimitiveCostume methodsFor: 'accessing' stamp: 'bf 3/30/2004 10:35'!player: aPlayer	^ self propertyValueAt: #player put: aPlayer! !!CPrimitiveCostume methodsFor: 'accessing' stamp: 'ar 12/8/2003 19:41'!root	container ifNotNil:[^container root].	^nil! !!CPrimitiveCostume methodsFor: 'accessing' stamp: 'ar 3/23/2004 23:37'!sticky	^self propertyValueAt: #sticky ifAbsent:[false]! !!CPrimitiveCostume methodsFor: 'accessing' stamp: 'ar 3/23/2004 23:37'!sticky: aBool	self propertyValueAt: #sticky put: aBool.	self signal: #flagsChanged.! !!CPrimitiveCostume methodsFor: 'accessing' stamp: 'ar 3/24/2004 03:18'!textHolder	^self propertyValueAt: #textHolder! !!CPrimitiveCostume methodsFor: 'accessing' stamp: 'ar 3/25/2004 17:25'!textHolder: aTextHolder	| myText |	myText := self textHolder.	myText == aTextHolder ifTrue:[^self].	aTextHolder ifNil:[		"Remove existing text"		self removeProperty: #textHolder.		flags := flags bitClear: FlagHasText.		^self signal: #textChanged].	myText ifNil:[		"Create new text"		myText := CCostumeTextHolder forCostume: self.		flags := flags bitOr: FlagHasText.		self propertyValueAt: #textHolder put: myText	].	myText loadFrom: aTextHolder.	^aTextHolder! !!CPrimitiveCostume methodsFor: 'accessing'!transformTo: aCostume	"Compute a transform that allows relocating costumes from myself to aCostume"	^self localToGlobal transformedBy: aCostume globalToLocal! !!CPrimitiveCostume methodsFor: 'accessing' stamp: 'ar 3/16/2004 19:17'!value	^self player value! !!CPrimitiveCostume methodsFor: 'accessing' stamp: 'ar 3/16/2004 19:17'!value: ignored	^self player value! !!CPrimitiveCostume methodsFor: 'accessing'!visible	^(flags bitAnd: FlagHidden) == 0! !!CPrimitiveCostume methodsFor: 'accessing'!visible: aBool	^self hidden: aBool not! !!CPrimitiveCostume methodsFor: 'accessing' stamp: 'ar 7/15/2003 16:35'!world	self isWorld ifTrue:[^self player].	container ifNotNil:[^container world].	^nil! !!CPrimitiveCostume methodsFor: 'structure' stamp: 'ar 12/8/2003 21:08'!allContainersDo: aBlock	"Evaluate aBlock with all containers of the receiver"	| parent |	parent := container.	[parent == nil] whileFalse:[		aBlock value: parent.		parent := parent container].! !!CPrimitiveCostume methodsFor: 'structure' stamp: 'ar 3/24/2004 03:18'!at: index	^contents at: index! !!CPrimitiveCostume methodsFor: 'structure' stamp: 'ar 2/13/2003 11:37'!contents	^contents collect:[:each| each]! !!CPrimitiveCostume methodsFor: 'structure' stamp: 'tk 7/14/2004 11:26'!contents: aCollection	self removeAll.	self addAll: (aCollection collect:[:each| each asPrimCostume]).! !!CPrimitiveCostume methodsFor: 'structure' stamp: 'ar 4/2/2004 14:16'!contentsAt: aPoint behind: aCostume unlocked: aBool	"Return all costumes at aPoint that are behind aCostume; if aBool is true return only unlocked, visible costumes."	| isBack found all |	(aCostume == nil or:[container == nil]) ifTrue:["Traverse down"		(self localFullBounds containsPoint: aPoint) ifFalse:[^#()].		(aBool and:[self locked or:[self visible not]]) ifTrue:[^#()].		all := nil.	] ifFalse:[ "Traverse up"		all := container contentsAt: (self childToParent: aPoint) behind: self unlocked: aBool.		all := WriteStream with: all.	].	isBack := aCostume == nil.	contents reverseDo:[:m|		isBack ifTrue:[			found := m contentsAt: (m parentToChild: aPoint) behind: nil unlocked: aBool.			found size > 0 ifTrue:[				all ifNil:[all := WriteStream on: #()].				all nextPutAll: found]].		m == aCostume ifTrue:[isBack := true]].	(isBack and:[self containsPoint: aPoint]) ifTrue:[		all ifNil:[^Array with: self].		all nextPut: self].	^all ifNil:[#()] ifNotNil:[all contents].! !!CPrimitiveCostume methodsFor: 'structure' stamp: 'ar 3/24/2004 03:19'!do: aBlock	1 to: contents size do:[:i| aBlock value: (contents at: i)].! !!CPrimitiveCostume methodsFor: 'structure' stamp: 'ar 3/24/2004 03:20'!first	^contents at: 1! !!CPrimitiveCostume methodsFor: 'structure' stamp: 'ar 3/21/2004 05:22'!frameChanged	"Either my or one of my owner's frames have changed. Notify my children.	TODO: At some point we may want to introduce a flag that tells us if	someone is really interested in handling this. If not, there is no point in	traversing all the children 'cause there can be very many."	self signal: #frameChanged.	contents do:[:p| p frameChanged].! !!CPrimitiveCostume methodsFor: 'structure' stamp: 'ar 1/8/2003 17:15'!isEmpty	^contents size = 0! !!CPrimitiveCostume methodsFor: 'structure' stamp: 'tk 6/17/2004 15:28'!keysAndValuesDo: aBlock	"index numbers are the keys"	1 to: contents size do:[:ii | aBlock value: ii value: (contents at: ii)].! !!CPrimitiveCostume methodsFor: 'structure' stamp: 'ar 3/23/2004 23:16'!layoutTargets	^contents select:[:cc| cc visible].! !!CPrimitiveCostume methodsFor: 'structure' stamp: 'ar 3/23/2004 23:15'!lockContents: aBool	contents do:[:each| each locked: aBool].! !!CPrimitiveCostume methodsFor: 'structure' stamp: 'ar 3/24/2004 03:23'!size	^contents size! !!CPrimitiveCostume methodsFor: 'structure' stamp: 'ar 3/9/2003 22:11'!swap: costumeA with: costumeB	"Exchange costumeA and costumeB"	| posA posB containerA containerB indexA indexB |	posA := costumeA position.	posB := costumeB position.	containerA := costumeA container.	containerB := costumeB container.	containerA ifNotNil:[indexA := containerA indexOf: costumeA].	containerB ifNotNil:[indexB := containerB indexOf: costumeB].	containerA ifNotNil:[		containerA remove: costumeA.		containerA add: costumeB atIndex: indexA.		costumeB position: posA.	].	containerB ifNotNil:[		containerB remove: costumeB.		containerB add: costumeA atIndex: indexB.		costumeA position: posB.	].! !!CPrimitiveCostume methodsFor: 'structure' stamp: 'ar 12/8/2003 19:41'!withAllContainersDo: aBlock	"Evaluate aBlock with the receiver and all of its containers"	aBlock value: self.	container ifNotNil:[^container withAllContainersDo: aBlock].! !!CPrimitiveCostume methodsFor: 'drawing' stamp: 'ar 3/29/2004 14:53'!areasRemainingToFill: aRectangle	"Answer the damage regions needed to be restored after the receiver has been drawn in aRectangle."	| outer box rects cRect |	self userDraw 		ifTrue: [^ Array with: aRectangle].	"translucent fills need to restore background first"	self hasTranslucentFill		ifTrue: [^ Array with: aRectangle].	"transformed objects need to restore background first"	(flags bitAnd: FlagHasMatrix) = 0		ifFalse:[^ Array with: aRectangle].	outer := box := self bounds.	"inset by border if translucent border is present"	"bw := self borderWidth.	(bw > 0 and:[self borderColor isTranslucent]) 		ifTrue:[box := box insetBy: bw]."	border isTranslucent ifTrue:[box := border insetBounds: box].	"if no rounded corners take what's left"	self wantsRoundedCorners 		ifFalse: [^aRectangle areasOutside: box].	outer == box ifFalse:[		"don't spend more work on translucent borders"		box := box intersect: (CCornerRounder rectWithinCornersOf: outer).		^aRectangle areasOutside: box].	"Eliminate most of the damage for the common case	when just the receiver is being redrawn."	aRectangle = box		ifTrue:[^box cornerRectsOfSize: CCornerRounder cornerSize].	"Otherwise take the area outside of the receiver"	rects := WriteStream on: (Array new: 8).	"aRectangle areasOutside: box into: rects."	rects nextPutAll: (aRectangle areasOutside: box).	"And the corner rectangles (if any)"	(box cornerRectsOfSize: CCornerRounder cornerSize) do:[:r|		cRect := r intersect: aRectangle.		cRect area > 0 ifTrue:[rects nextPut: cRect].	].	^rects contents! !!CPrimitiveCostume methodsFor: 'drawing' stamp: 'ar 3/24/2004 03:12'!asClipMask	"Answer the receiver as a clip mask"	| mask maskCanvas |	mask := Form extent: self localBounds extent depth: 1.	maskCanvas := CTransformCanvas on: mask.	maskCanvas shadowColor: Color black.	self drawOn: maskCanvas.	^mask! !!CPrimitiveCostume methodsFor: 'drawing' stamp: 'ar 3/23/2004 23:08'!clipping	"Drawing specific. If this property is set, clip the receiver's children to the receiver's clipping bounds."	^(flags bitAnd: FlagClipEnabled) == FlagClipEnabled! !!CPrimitiveCostume methodsFor: 'drawing' stamp: 'ar 3/23/2004 23:09'!clipping: aBool	"Drawing specific. If this property is set, clip the receiver's children to the receiver's clipping bounds."	aBool = self clipping ifTrue:[^self].	self invalidate.	flags := aBool ifTrue:[flags bitOr: FlagClipEnabled] ifFalse:[flags bitClear: FlagClipEnabled].	self invalidate.	self signal: #flagsChanged.! !!CPrimitiveCostume methodsFor: 'drawing' stamp: 'ar 3/23/2004 23:06'!clippingBounds	"Return the bounds to which any parts should be clipped if the property is set"	^self clipping ifTrue:[self innerBounds] ifFalse:[self localFullBounds]! !!CPrimitiveCostume methodsFor: 'drawing' stamp: 'ar 7/25/2003 11:52'!debugDraw	^self fullDrawOn: (CTransformCanvas on: Display).! !!CPrimitiveCostume methodsFor: 'drawing' stamp: 'ar 4/14/2004 20:54'!displayOn: gDev	"Draw the receiver in the presence of a full transform"	| highlights index hl transformedCanvas |	transformedCanvas := gDev asCanvas.	highlights := self highlights.	"Step 1: Draw highlights below the receiver"	index := 1.	[index <= highlights size and:[(hl := highlights at: index) priority < 0]]		whileTrue:[	hl drawHighlightOn: transformedCanvas.					index := index + 1].	"Skip zero-priority highlights"	[index <= highlights size and:[(highlights at: index) priority = 0]]		whileTrue:[index := index + 1].	transformedCanvas roundCornersOf: self in: self localBounds during:[		"Step 2: Draw receiver itself"		self drawOn: transformedCanvas.	].	"Step 3: Draw pen trails"	self drawPenTrailsOn: transformedCanvas.	"Step 4: Draw all the parts"	"transformedCanvas clipBy: self clippingBounds during:[:clip|		self drawContentsOn: clip.	]."	(flags bitAnd: FlagHasOverlay) = 0 		ifFalse:[self drawOverlayOn: transformedCanvas].	"Step 5: Draw highlights on top of the receiver"	index to: highlights size do:[:i|		(highlights at: i) drawHighlightOn: transformedCanvas.	].! !!CPrimitiveCostume methodsFor: 'drawing' stamp: 'ar 3/24/2004 03:12'!drawClipMaskOn: aCanvas in: clippingBounds	"Draw a clipping mask (form of depth 1) on aCanvas"	| mask maskCanvas |	mask := Form extent: clippingBounds extent depth: 1.	maskCanvas := CTransformCanvas on: mask.	maskCanvas transformBy: self localToGlobal.	maskCanvas shadowColor: Color white.	self localFullDrawOn: maskCanvas.	^mask! !!CPrimitiveCostume methodsFor: 'drawing' stamp: 'ar 4/2/2004 14:15'!drawContentsOn: aCanvas	"Display children back to front"	contents size = 0 ifTrue:[^self].	1 to: contents size do:[:i| (contents at: i) fullDrawOn: aCanvas].! !!CPrimitiveCostume methodsFor: 'drawing' stamp: 'ar 3/24/2004 03:10'!drawGrid: aGrid on: aCanvas in: drawingBounds	aGrid ifNil:[^self].	aGrid drawOn: aCanvas in: drawingBounds.! !!CPrimitiveCostume methodsFor: 'drawing' stamp: 'bf 4/29/2004 02:16'!drawOn: aCanvas	| box |	box := self scrollBox.	(aCanvas isVisible: box) ifFalse:[^self].	fill isOrientedFill ifTrue:[fill updateFrame: box].	border trackColorFrom: self.	aCanvas pushState.	(flags bitAnd: FlagCustomDraw) == 0 ifTrue:[		self drawOn: aCanvas in: box.	] ifFalse:[		flags := flags bitClear: FlagCustomDraw.		[aCanvas clipBy: box.		self asPlayer drawOn: aCanvas in: box]			ensure:[flags := flags bitOr: FlagCustomDraw].	].	aCanvas popState.! !!CPrimitiveCostume methodsFor: 'drawing' stamp: 'ar 3/23/2004 20:16'!drawOn: aCanvas in: drawingBounds	"Draw only the receiver on the canvas using the given drawing bounds"	"TODO: Optimize fill for the case of opaque textures (no or only partial background fill needs to be drawn in this case)"	"draw fill (color/gradient) and border if present"	(fill isTransparent and:[border width = 0]) ifFalse:[		aCanvas fillRectangle: drawingBounds fill: fill border: self border.	].	"draw vector shape if present"	(flags bitAnd: FlagHasShape) = 0 ifFalse:[		self drawShape: self shape on: aCanvas in: (drawingBounds insetBy: border width).	].	"draw texture if present"	(flags bitAnd: FlagHasGraphic) = 0 ifFalse:[		self drawGraphic: self graphic on: aCanvas in: (drawingBounds insetBy: border width).	].	"draw text if present"	(flags bitAnd: FlagHasText) = 0 ifFalse:[		self drawText: self textHolder on: aCanvas in: (drawingBounds insetBy: border width).	].	"draw grid if present"	(flags bitAnd: FlagHasGrid) = 0 ifFalse:[		self drawGrid: self grid on: aCanvas in: (drawingBounds insetBy: border width).	].! !!CPrimitiveCostume methodsFor: 'drawing' stamp: 'ar 3/24/2004 03:11'!drawOverlay: aPlayer on: aCanvas in: drawingBounds	"Draw the receiver's texture"	aPlayer ifNil:[^self].	aCanvas clipBy: drawingBounds during:[:cc|		aPlayer drawOverlayOn: aCanvas in: drawingBounds.	].! !!CPrimitiveCostume methodsFor: 'drawing' stamp: 'ar 6/9/2003 04:10'!drawOverlayOn: aCanvas	| box |	box := self scrollBox.	(aCanvas isVisible: box) ifFalse:[^self].	aCanvas pushState.	aCanvas clipBy: box.	self drawOverlay: self overlay on: aCanvas in: box.	aCanvas popState.! !!CPrimitiveCostume methodsFor: 'drawing' stamp: 'ar 1/8/2003 17:14'!drawPenTrailsOn: aCanvas	"I need to draw my pen trails on the given canvas"	| any |	self indicatePenTrails ifFalse:[^self].	any := false.	contents do:[:cc| cc hasPen ifTrue:[		any := true.		cc pen drawOn: aCanvas.	]].	any ifFalse:["don't need it any longer"		self indicatePenTrails: false.	].! !!CPrimitiveCostume methodsFor: 'drawing' stamp: 'ar 3/24/2004 03:15'!drawShape: aShape on: aCanvas in: drawingBounds	"Draw the receiver's texture"	aShape ifNil:[^self].	aCanvas clipBy: drawingBounds during:[:cc|		aShape drawOn: aCanvas in: drawingBounds.	].! !!CPrimitiveCostume methodsFor: 'drawing' stamp: 'ar 3/24/2004 03:17'!drawText: textContainer on: aCanvas in: drawingBounds	textContainer ifNil:[^self].	aCanvas clipBy: drawingBounds during:[:cc|		textContainer drawOn: aCanvas in: drawingBounds.	].! !!CPrimitiveCostume methodsFor: 'drawing' stamp: 'ar 5/3/2004 14:57'!drawTextOn: aCanvas in: drawingBounds	^self drawText: self textHolder on: aCanvas in: drawingBounds! !!CPrimitiveCostume methodsFor: 'drawing' stamp: 'ar 12/9/2003 00:41'!drawingBounds	^self localFullBounds! !!CPrimitiveCostume methodsFor: 'drawing' stamp: 'ar 3/25/2004 20:01'!flash	"Flash the receiver"	| prevFill |	prevFill := fill copy.	fill color: Color black.	self wait: 0.1.	self fill: prevFill.! !!CPrimitiveCostume methodsFor: 'drawing' stamp: 'ar 4/14/2004 20:54'!fullDrawOn: aCanvas	"Draw the full structure of the receiver on the given Canvas.	There are many properties that come into play here some of which	are pretty heavily used and some of which aren't.	The more heavily used properties are:		* clipping		* rounded corners		* cache enabled	The more rarely used properties are		* a full transformation		* highlights	And therefore the following optimizes for the first three and falls	through into a generic version in the presence of the latter two."	| box |	self visible ifFalse: [^ self]. "(a)"	(aCanvas isVisible: self fullBounds) ifFalse:[^self].	"Bail out to the generic version if needed"	(flags bitAnd: (FlagHasMatrix bitOr: FlagHasHighlights)) == 0 ifFalse:[		box := self localFullBounds.		^aCanvas 			transformBy: self transform clippingTo: box during:[:cc|				cc cache: box using: self localCache during:[:cc2| self localFullDrawOn: cc2]].	].	"Otherwise go straight for it"	box := self localBounds.	aCanvas pushState.	aCanvas translateBy: bounds origin.	aCanvas cache: self localFullBounds using: self localCache during:[:cache|		cache roundCornersOf: self in: box during:[			self drawOn: cache.		].		contents size = 0 ifFalse:[			self clipping 				ifTrue:[cache clipBy: self clippingBounds during:[:cc| self drawContentsOn: cc]]				ifFalse:[self drawContentsOn: cache].		].		(flags bitAnd: FlagHasOverlay) = 0 			ifFalse:[self drawOverlayOn: aCanvas].	].	aCanvas popState.! !!CPrimitiveCostume methodsFor: 'drawing'!hasTranslucentFill	"Answer whether the receiver has any parts where the background must be restored"	^fill isTranslucent! !!CPrimitiveCostume methodsFor: 'drawing' stamp: 'ar 12/8/2003 19:42'!insetColor	"Return the color to be used for shading inset borders.  The default is my own color, but it might want to be, eg, my container's color.  Whoever's color ends up prevailing, the color itself gets the last chance to determine, so that when, for example, an InfiniteForm serves as the color, callers won't choke on some non-Color object being returned"	(fill isTransparent and:[container notNil]) ifTrue:[^container insetColor].	^fill asColor! !!CPrimitiveCostume methodsFor: 'drawing' stamp: 'ar 3/21/2004 03:43'!invalidate	"Invalidate the receiver so that it will be redrawn"	(flags bitAnd: FlagHidden) == 0 ifFalse:[^self].	self invalidate: self invalidationBounds.! !!CPrimitiveCostume methodsFor: 'drawing' stamp: 'ar 3/23/2004 21:27'!invalidate: aRectangle	"Invalidate the rectangle so that it will be redrawn within the receiver"	^self invalidate: aRectangle from: self! !!CPrimitiveCostume methodsFor: 'drawing' stamp: 'ar 3/23/2004 23:06'!invalidate: aRectangle from: aCostume	| damageRect |	(flags bitAnd: FlagInvalidationSuppressed) == 0 ifFalse:[^self].	(flags bitAnd: FlagHidden) == 0 ifFalse:[^self].	damageRect := aRectangle.	(aCostume ~~ self and:[self clipping]) ifTrue:[		"Clip to receiver's clipping bounds if the damage came from a part"		damageRect := damageRect intersect: self clippingBounds.	].	"Notify our cache if any"	(flags bitAnd: FlagCached) == 0 		ifFalse:[self localCache invalidate: damageRect].	"Notify our highlights if any"	(flags bitAnd: FlagHasHighlights) = 0 		ifFalse:[self highlights do:[:hl| hl noteInvalidationOf: aRectangle]].	"Pass invalidation area to parent"	container ifNotNil: [		damageRect := self transform transformRect: damageRect.		container invalidate: damageRect from: self.	].! !!CPrimitiveCostume methodsFor: 'drawing'!invalidationSuppressed	^(flags bitAnd: FlagInvalidationSuppressed) = FlagInvalidationSuppressed! !!CPrimitiveCostume methodsFor: 'drawing'!invalidationSuppressed: aBool	"Temporarily suppress invalidation requests"	flags := aBool 		ifTrue:[flags bitOr: FlagInvalidationSuppressed]		ifFalse:[flags bitClear: FlagInvalidationSuppressed].! !!CPrimitiveCostume methodsFor: 'drawing' stamp: 'ar 3/29/2004 14:54'!localAreasRemainingToFill: aRectangle	"Answer the damage regions needed to be restored after the receiver has been drawn in aRectangle."	| outer box |	self userDraw 		ifTrue: [^ Array with: aRectangle].	"translucent fills need to restore background first"	self hasTranslucentFill		ifTrue: [^ Array with: aRectangle].	outer := box := self localBounds.	"inset by border if translucent border is present"	"bw := self borderWidth.	(bw > 0 and:[self borderColor isTranslucent]) 		ifTrue:[box := box insetBy: bw]."	border isTranslucent ifTrue:[box := border insetBounds: box].	"if no rounded corners take what's left"	self wantsRoundedCorners 		ifFalse: [^aRectangle areasOutside: box].	"Eliminate most of the damage for the common case when just the receiver is being redrawn."	aRectangle = box ifTrue:[		^aRectangle cornerRectsOfSize: CCornerRounder cornerSize	].	"Otherwise take the interior"	box := box intersect: (CCornerRounder rectWithinCornersOf: outer).	^aRectangle areasOutside: box.! !!CPrimitiveCostume methodsFor: 'drawing' stamp: 'ar 4/14/2004 20:57'!localFullDrawOn: transformedCanvas	"Draw the receiver in the presence of a full transform"	| highlights index hl |	highlights := self highlights.	"Step 1: Draw highlights below the receiver"	index := 1.	[index <= highlights size and:[(hl := highlights at: index) priority < 0]]		whileTrue:[	hl drawHighlightOn: transformedCanvas.					index := index + 1].	"Skip zero-priority highlights"	[index <= highlights size and:[(highlights at: index) priority = 0]]		whileTrue:[index := index + 1].	transformedCanvas roundCornersOf: self in: self localBounds during:[		"Step 2: Draw receiver itself"		self drawOn: transformedCanvas.	].	"Step 3: Draw pen trails"	self drawPenTrailsOn: transformedCanvas.	"Step 4: Draw all the parts"	transformedCanvas clipBy: self clippingBounds during:[:clip|		self drawContentsOn: clip.	].	(flags bitAnd: FlagHasOverlay) = 0 		ifFalse:[self drawOverlayOn: transformedCanvas].	"Step 5: Draw highlights on top of the receiver"	index to: highlights size do:[:i|		(highlights at: i) drawHighlightOn: transformedCanvas.	].! !!CPrimitiveCostume methodsFor: 'drawing' stamp: 'ar 2/16/2003 14:56'!makeThumbnail: extent	"Create a thumbnail of the receiver with the given extent"	^self makeThumbnail: extent depth: Display depth! !!CPrimitiveCostume methodsFor: 'drawing' stamp: 'ar 2/16/2003 20:26'!makeThumbnail: extent depth: depth	"Create a thumbnail of the receiver with the given extent"	| myPicture form scale thumb |	myPicture := self asFormOfDepth: depth.	form := Form extent: extent depth: depth.	scale := 1.	(myPicture width > 0 and:[myPicture height > 0])		ifTrue:[scale _ (extent x / myPicture width) min: (extent y / myPicture height)].	scale < 1.0 ifTrue:[		thumb _ Form extent: (myPicture extent * scale) asIntegerPoint depth: myPicture depth.		myPicture displayScaledOn: thumb.		thumb displayOn: form at: (form extent - thumb extent // 2) rule: Form paint.	] ifFalse:[		myPicture displayOn: form at: (form extent - myPicture extent // 2) rule: Form paint.	].	^form! !!CPrimitiveCostume methodsFor: 'drawing' stamp: 'ar 12/8/2003 19:42'!raisedColor	"Return the color to be used for shading raised borders.  The default is my own color, but it might want to be, eg, my container's color.  Whoever's color ends up prevailing, the color itself gets the last chance to determine, so that when, for example, an InfiniteForm serves as the color, callers won't choke on some non-Color object being returned"	(fill isTransparent and:[container notNil]) ifTrue:[^container raisedColor].	^fill asColor! !!CPrimitiveCostume methodsFor: 'drawing' stamp: 'ar 12/8/2002 00:13'!shadowForm	"Return a form representing the 'shadow' of the receiver - e.g., all pixels that are occupied by the receiver are one, all others are zero."	| canvas |	canvas _ (CTransformCanvas extent: self extent depth: 1)				asShadowDrawingCanvas: Color black. "Color black represents one for 1bpp"	canvas translateBy: self topLeft negated		during:[:tempCanvas| tempCanvas fullDraw: self].	^ canvas form offset: self topLeft! !!CPrimitiveCostume methodsFor: 'drawing' stamp: 'ar 4/2/2004 14:17'!topDownFullDrawOn: aCanvas damageList: damageList	"Draw the receiver and all its parts on the given canvas. This method uses a top-down strategy for redrawing which will eliminate much of the actual work if many parts overlap and are (at least partly) transparent. This strategy is useful, for instance, in worlds (using overlapping windows) but others may use it as well. Note that for optimal performance, aCanvas' clip rect should be set to encapsulate the minimum bounding area of all the rectangles in damage list."	^self topDownFullDrawOn: aCanvas damageList: damageList dirtyRect: aCanvas clipRect startingAt: contents size! !!CPrimitiveCostume methodsFor: 'drawing' stamp: 'ar 4/2/2004 14:18'!topDownFullDrawOn: aCanvas damageList: damageList dirtyRect: damageBounds startingAt: idx	"Draw the receiver and all its contents on the given canvas. This method uses a top-down strategy for redrawing which will eliminate much of the actual work if many costumes overlap and are (at least partly) transparent. This strategy is useful, for instance, in worlds (using overlapping windows) but others may use it as well. Note that for optimal performance, aCanvas' clip rect should be set to encapsulate the minimum bounding area of all the rectangles in damage list."	| child stillDirty index |	damageList size = 0 ifTrue:[^self]. "no damage no work"	"Find the next visible child intersecting the damage area"	index := idx. child := nil.	[index > 0 and:[child == nil]] whileTrue:[		child := contents at: index.		(child visible and:[child fullBounds intersects: damageBounds])			ifFalse:[child := nil].		index := index-1].	"If we have no more children draw the receiver"	child ifNil:[^aCanvas draw: self damageList: damageList].	"Collect left-over damage for this child"	stillDirty := OrderedCollection new: damageList size.	damageList do:[:rect|		(child areasRemainingToFill: rect) do:[:dirty| 			stillDirty add: (dirty origin truncated corner: dirty corner ceiling)].	].	"Now recursively update everything behind the child"	self topDownFullDrawOn: aCanvas damageList: stillDirty dirtyRect: damageBounds startingAt: index.	"Everything below the child has been restored, now restore the child itself"	^aCanvas fullDraw: child damageList: damageList.! !!CPrimitiveCostume methodsFor: 'drawing' stamp: 'ar 3/29/2004 14:55'!userDraw	"Return true if the receiver should act as a custom drawing area"	^(flags bitAnd: FlagCustomDraw) == FlagCustomDraw! !!CPrimitiveCostume methodsFor: 'drawing' stamp: 'ar 3/29/2004 14:55'!userDraw: aBool	"Determine whether the receiver should act as a custom drawing area"	flags := aBool ifTrue:[flags bitOr: FlagCustomDraw] ifFalse:[flags bitClear: FlagCustomDraw].	self signal: #flagsChanged.	self invalidate.! !!CPrimitiveCostume methodsFor: 'scrolling' stamp: 'ar 3/24/2004 12:50'!privateScrollBy: delta	"Scroll by the specified amount. Note: At some point this should be optimized to use a direct blt for the non-overlapping regions if the receiver is cached."	self invalidate.	bounds := bounds translateBy: delta negated.	contents do:[:m| m scrollingDisabled ifTrue:[m moveBy: delta]].	(flags bitAnd: FlagHasText) = 0 ifFalse:[		self textHolder offset: self textHolder offset - delta.	].	self invalidate.! !!CPrimitiveCostume methodsFor: 'scrolling' stamp: 'ar 3/26/2004 01:09'!scrollArea	"Answer the area that should be scrolled in the receiver"	^self contentsBounds encompass: 0@0! !!CPrimitiveCostume methodsFor: 'scrolling' stamp: 'ar 3/20/2003 02:51'!scrollBox	^self scrollOffset extent: bounds extent.! !!CPrimitiveCostume methodsFor: 'scrolling' stamp: 'ar 3/20/2003 02:53'!scrollOffset	"Return the current scroll offset if any"	(flags bitAnd: FlagHasScroller) == 0 ifTrue:[^0@0].	^self propertyValueAt: #scrollOffset ifAbsent:[0@0]! !!CPrimitiveCostume methodsFor: 'scrolling' stamp: 'ar 9/8/2004 16:24'!scrollOffset: aPoint	"Change the current scroll offset"	| newOffset delta oldOffset |	oldOffset := self scrollOffset.	newOffset := aPoint asPoint truncated.	delta _ newOffset - oldOffset.	delta isZero ifTrue:[^self].	self privateScrollBy: delta.	self signalChanged: #scrollOffsetChanged from: oldOffset to: newOffset.	newOffset isZero ifTrue:[		flags := flags bitClear: FlagHasScroller.		self removeProperty: #scrollOffset.	] ifFalse:[		flags := flags bitOr: FlagHasScroller.		self propertyValueAt: #scrollOffset put: newOffset.	].	self frameChanged.! !!CPrimitiveCostume methodsFor: 'scrolling' stamp: 'ar 3/15/2003 01:32'!scrollableExtent	"Return the area that should be scrolled"	^(self contentsBounds encompass: 0@0) extent! !!CPrimitiveCostume methodsFor: 'scrolling' stamp: 'ar 9/4/2003 23:51'!scrollingDisabled	^self propertyValueAt: #scrollingDisabled ifAbsent:[false]! !!CPrimitiveCostume methodsFor: 'scrolling' stamp: 'ar 9/8/2004 16:25'!scrollingDisabled: aBool	self signalChanged: #scrollingDisabledChanged from: self scrollingDisabled to: aBool.	self propertyValueAt: #scrollingDisabled put: aBool.! !!CPrimitiveCostume methodsFor: 'scrolling' stamp: 'ar 8/18/2003 00:07'!visibleBounds	"Answer the (scrolled) bounds encompassing the currently visible portion of this object"	^self innerBounds! !!CPrimitiveCostume methodsFor: 'scrolling' stamp: 'ar 3/24/2004 01:53'!visibleScrollArea	"Answer the visible portion of the scroll area"	^self innerBounds! !!CPrimitiveCostume methodsFor: 'drag and drop' stamp: 'ar 4/2/2004 14:16'!dragChildAt: aPoint	"Answer a child of me which can be dragged when the mouse is clicked"	^contents reversed detect:[:any| 		any locked not			and:[any visible 			and:[any sticky not			and:[any fullContainsPoint: aPoint]]]	] ifNone:[nil].! !!CPrimitiveCostume methodsFor: 'drag and drop' stamp: 'ar 3/23/2004 23:11'!floating	"Answer whether the receiver is a 'floating' object, e.g., one which will never generate a drop event when dragged around."	^self propertyValueAt: #floating ifAbsent:[false]! !!CPrimitiveCostume methodsFor: 'drag and drop' stamp: 'ar 3/23/2004 23:11'!floating: aBool	"Answer whether the receiver is a 'floating' object, e.g., one which will never generate a drop event when dragged around."	self propertyValueAt: #floating put: (aBool ifTrue:[true] ifFalse:[nil]).	self signal: #flagsChanged! !!CPrimitiveCostume methodsFor: 'drag and drop' stamp: 'ar 3/23/2004 23:11'!onDrag	"Drag the receiver"	| myContainer myTransform myIndex myPosition evt |	container ifNil:[^self].	self floating ifTrue:[^self onDragMove].	"Remember my container and my transform for drop rejection"	myContainer := container.	myIndex := container indexOf: self.	myTransform := self transform.	myPosition := container localToGlobal: self position.	self hand dragContents: self player.	self onDragMove.	"Catch any attempts to reject the drop operation"	evt := self player catchAnyOf:{self player. #dropReject} during:[		self hand dragContents: nil.		self hand drop: self.		"Wait for a single tick after the drop to see if it should be rejected"		self waitTick.	].	evt ifNotNil:["Yup, it got rejected"		self moveBy: (myPosition - self position) duration: 0.2 style: #gently.		myContainer add: self at: myIndex.		self transform: myTransform.	].! !!CPrimitiveCostume methodsFor: 'drag and drop' stamp: 'ar 5/5/2004 12:44'!onDragMove	"Drag the receiver but do not drop it when the move completes"	| lastPos nextPos moved cursor delta wasLocked shadow |	container ifNil:[^self].	wasLocked := self locked.	self transformBy: container localToWorld.	self world costume add: self.	self locked: true.	cursor := self mouseCursor.	self mouseCursor: (cursor ifNil:[Cursor normal]) asForm.	self hand cursorFocus: self player.	self waitTick.	shadow := CDropShadowHighlight new.	shadow name: #dragMoveShadow.	shadow offset: 6@8.	moved := false.	lastPos := container cursorPoint.	self hand forEach: #mouseMove do:[		nextPos := container cursorPoint.		delta := nextPos - lastPos.		lastPos := nextPos.		moved ifFalse:[			self addHighlight: shadow.			moved := true.		].		self moveBy: delta.	] until: #mouseUp.	self mouseCursor: cursor.	self hand releaseMouseFocus: self.	self removeHighlight: #dragMoveShadow.	self locked: wasLocked.	self hand releaseCursorFocus: self player.! !!CPrimitiveCostume methodsFor: 'drag and drop' stamp: 'ar 3/29/2003 17:18'!onMove	"Move the receiver"	| lastPos nextPos cursor delta |	container ifNil:[^self].	cursor := self hand mouseCursor.	self hand mouseCursor: cursor asForm.	lastPos := container cursorPoint.	self hand forEach: #mouseMove do:[		nextPos := container cursorPoint.		delta := nextPos - lastPos.		lastPos := nextPos.		self moveBy: delta.	] until: #mouseUp.	self hand mouseCursor: cursor.! !!CPrimitiveCostume methodsFor: 'layout' stamp: 'ar 3/23/2004 23:06'!adjustLayoutBounds					 	"Adjust the receivers bounds depending on the resizing strategy imposed"	| hFit vFit clip box myExtent extent partsBox |	self ignoreShrinkWrapConstraints ifTrue:[^self].	partsBox := self contentsBounds.	clip := self clipping.	hFit := self hResizing.	vFit := self vResizing.	(self localBounds containsRect: partsBox)		ifFalse:[flags := flags bitOr: FlagExcessBounds].	((hFit == #rigid or:[hFit == #spaceFill and:[clip]]) and:[		(vFit == #rigid or:[vFit == #spaceFill and:[clip]])])			ifTrue:[^self].	box := self layoutBounds.	myExtent := box extent.	"Something is definitely screwed up here... but what???"	extent := partsBox extent.	"extent := partsBox corner - box origin."	hFit == #shrinkWrap ifTrue:[myExtent := extent x @ myExtent y].	vFit == #shrinkWrap ifTrue:[myExtent := myExtent x @ extent y].	clip ifFalse:[		hFit == #spaceFill ifTrue:[myExtent := (extent x max: myExtent x) @ myExtent y].		vFit == #spaceFill ifTrue:[myExtent := myExtent x @ (extent y max: myExtent y)].	].	"Make sure we don't get smaller than minWidth/minHeight"	myExtent x < self minWidth ifTrue:[		myExtent := (myExtent x max: 			(self minWidth - self localBounds width + self layoutBounds width)) @ myExtent y].	myExtent y < self minHeight ifTrue:[		myExtent := myExtent x @ (myExtent y max:			(self minHeight - self localBounds height + self layoutBounds height))].	self layoutBounds: (box origin extent: myExtent).	(self localBounds containsRect: partsBox)		ifTrue:[flags := flags bitClear: FlagExcessBounds]		ifFalse:[flags := flags bitOr: FlagExcessBounds].! !!CPrimitiveCostume methodsFor: 'layout' stamp: 'ar 12/7/2002 22:27'!assureLayoutProperties	| props |	props _ self layoutProperties.	props == self ifTrue:[props _ nil].	props ifNil:[		props _ CLayoutProperties new initializeFrom: self.		self layoutProperties: props].	^props! !!CPrimitiveCostume methodsFor: 'layout' stamp: 'ar 3/24/2004 03:32'!cellPositioning	^(self layout ifNil:[^#center]) cellPositioning! !!CPrimitiveCostume methodsFor: 'layout' stamp: 'ar 3/23/2004 23:16'!contentsBounds	"Answer the bounds of my contents"	| box subBox |	box := nil.	(flags bitAnd: FlagHasText) = 0 ifFalse:[		box := self textBounds origin extent: self textHolder bounds extent.	].	(flags bitAnd: FlagHasGraphic) = 0 ifFalse:[		| tex |		tex := self graphic.		tex fit = #rigid ifTrue:[			box ifNil:[box := tex bounds]				ifNotNil:[box := box quickMerge: tex bounds].		].	].	contents do:[:p |		p visible ifTrue:[			subBox := p fullBounds.			box 				ifNil:[box := subBox copy]				ifNotNil:[box := box quickMerge: subBox].		].	].	box ifNil:[^0@0 corner: 0@0]. "e.g., having children but not visible"	^ box origin asIntegerPoint corner: box corner asIntegerPoint! !!CPrimitiveCostume methodsFor: 'layout' stamp: 'ar 3/24/2004 02:50'!doLayoutIn: layoutBounds	"Compute a new layout based on the given (local) layout bounds."	| layout box priorBounds |	self layoutNeeded: true. "don't bother broadcasting changes from here"	"A costume with #spaceFill constraints needs to update its own bounds	before the layout can be computed since it will grow anyways to match	the layout bounds."	(self hResizing == #spaceFill or:[self vResizing == #spaceFill]) ifTrue:[		box := self layoutBounds.		self hResizing == #spaceFill 			ifTrue:[box := box withWidth: layoutBounds width].		self vResizing == #spaceFill 			ifTrue:[box := box withHeight: layoutBounds height].		self layoutBounds: box.	].	"Note: Testing for #bounds or #layoutBounds would be sufficient to	figure out if we need an invalidation afterwards but #outerBounds	is what we need for all leaf nodes so we use that."	flags := flags bitClear: FlagExcessBounds.	contents size = 0 ifTrue:[		self adjustLayoutBounds.	] ifFalse:[		"Send #containerChanged to our children"		contents do:[:m| m signal: #containerLayoutChanged with: m with: self].		priorBounds := self outerBounds.		layout := self layout.		layout ifNotNil:[layout layout: self in: layoutBounds].		self adjustLayoutBounds.		box := self outerBounds.		box = priorBounds ifFalse:[self invalidate: (priorBounds quickMerge: box)].	].	self layoutNeeded: false.	self signal: #layoutChanged.! !!CPrimitiveCostume methodsFor: 'layout' stamp: 'ar 3/21/2004 04:44'!hResizing	"Layout specific. This property describes how the receiver should be resized with respect to its owner and its children. Possible values are:		#rigid			-	do not resize the receiver		#spaceFill		-	resize to fill owner's available space		#shrinkWrap	- resize to fit children	"	| props |	props _ self layoutProperties.	^props ifNil:[#rigid] ifNotNil:[props hResizing].! !!CPrimitiveCostume methodsFor: 'layout' stamp: 'ar 2/17/2004 18:53'!hResizing: aSymbol	"Layout specific. This property describes how the receiver should be resized with respect to its owner and its children. Possible values are:		#rigid			-	do not resize the receiver		#spaceFill		-	resize to fill owner's available space		#shrinkWrap	- resize to fit children	"	self hResizing == aSymbol ifTrue:[^self].	self assureLayoutProperties hResizing: aSymbol.	self signal: #hResizingChanged.	self invalidateLayout.! !!CPrimitiveCostume methodsFor: 'layout' stamp: 'ar 3/23/2004 20:29'!ignoreShrinkWrapConstraints	"Answer whether shrink wrap constraints should be ignored for the receiver. This method has been factored out since Text costumes need to handle this slightly differently."	^contents size = 0 "e.g., ignore shrinkWrap if there are no children"		and:[(flags bitAnd: FlagHasText) = 0 or:[self textHolder text size = 0]]! !!CPrimitiveCostume methodsFor: 'layout' stamp: 'ar 3/24/2004 03:20'!innerBounds	"Return the inner rectangle enclosed by the bounds of this costume excluding the space taken by its borders."	"^self localBounds insetBy: self borderWidth"	^border insetBounds: self localBounds! !!CPrimitiveCostume methodsFor: 'layout' stamp: 'ar 3/24/2004 02:50'!invalidateLayout	| layout |	self layoutNeeded ifTrue:[^self]. "layout will be recomputed so don't bother"	(flags bitAnd: FlagHasFullBounds) == 0 ifFalse:[		"Cached fullBounds get invalidated when the layout goes away"		properties removeKey: #fullBounds.		flags := flags bitClear: FlagHasFullBounds.	].	self layoutNeeded: true.	layout := self layout.	layout ifNotNil:[layout flushLayoutCache].	container ifNotNil: [container invalidateLayout].! !!CPrimitiveCostume methodsFor: 'layout' stamp: 'ar 3/24/2004 02:48'!layout	"Return the layout policy describing how children of the receiver should appear."	^self propertyValueAt: #layout! !!CPrimitiveCostume methodsFor: 'layout' stamp: 'bf 3/30/2004 11:35'!layout: aLayout	"Set the layout policy describing how children of the receiver should appear."	| myLayout |	(myLayout := self layout) == aLayout ifTrue:[^aLayout].	myLayout ifNotNil:[myLayout costume: nil].	self propertyValueAt: #layout put: aLayout.	aLayout ifNotNil:[aLayout costume: self].	self signal: #layoutChanged.	self invalidateLayout.	^aLayout! !!CPrimitiveCostume methodsFor: 'layout' stamp: 'ar 3/24/2004 03:20'!layoutBounds	"Return the bounds for laying out children of the receiver.	Note: The layout bounds always start relative to the scroll origin."	| box |	box := self innerBounds.	box := box insetBy: self layoutInset.	^box translateBy: self scrollOffset negated! !!CPrimitiveCostume methodsFor: 'layout' stamp: 'ar 3/21/2004 05:27'!layoutBounds: newBounds	"Set the bounds for laying out children of the receiver"	| box |	box := newBounds.	box := box expandBy: self layoutInset.	box := border expandBounds: box.	box = self localBounds ifTrue:[^self].	self invalidate.	self privateBounds:(bounds origin + box origin extent: box extent).	self invalidate.	self invalidateLayout.	self signal: #geometryChanged.	self frameChanged.! !!CPrimitiveCostume methodsFor: 'layout' stamp: 'ar 9/4/2003 23:43'!layoutFrame	"Layout specific. Return the layout frame describing where the receiver should appear in a proportional layout"	^self propertyValueAt: #layoutFrame! !!CPrimitiveCostume methodsFor: 'layout' stamp: 'bf 4/27/2004 01:14'!layoutFrame: aFrame	"Layout specific. Return the layout frame describing where the receiver should appear in a proportional layout"	| layoutFrame |	layoutFrame := aFrame asLayoutFrame.	self propertyValueAt: #layoutFrame put: layoutFrame.	self invalidateLayout.	^ layoutFrame! !!CPrimitiveCostume methodsFor: 'layout' stamp: 'ar 1/8/2003 16:56'!layoutInBounds: cellBounds	"Layout specific. Apply the given global bounds to the receiver after being layed out in its container."	| box aSymbol |	self layoutNeeded ifTrue:[		"We need to get our own layout right first"		box := cellBounds origin extent: "adjust for #rigid receiver"			(self hResizing == #rigid ifTrue:[self bounds extent x] ifFalse:[cellBounds extent x]) @			(self vResizing == #rigid ifTrue:[self bounds extent y] ifFalse:[cellBounds extent y]).		self bounds: box.		self doLayoutIn: self layoutBounds].	cellBounds = self fullBounds ifTrue:[^self]. "already up to date"	cellBounds extent = self fullBounds extent "nice fit"		ifTrue:[^self origin: cellBounds origin].	box := self bounds.	"match #spaceFill constraints"	self hResizing == #spaceFill 		ifTrue:[box := box withWidth: cellBounds width].	self vResizing == #spaceFill		ifTrue:[box := box withHeight: cellBounds height].	"align accordingly"	aSymbol := (container ifNil:[self]) cellPositioning.	box := box align: (box perform: aSymbol) with: (cellBounds perform: aSymbol).	"install new bounds"	box extent = self bounds extent 		ifTrue:[^self origin: box origin].	"Since the extent is subject to change. layout right away"	self layoutNeeded: true. "don't bother broadcasting"	self bounds: box.	"and do the layout"	self doLayoutIn: self layoutBounds.! !!CPrimitiveCostume methodsFor: 'layout' stamp: 'ar 3/24/2004 03:35'!layoutInset	| props |	props _ self layoutProperties.	^props ifNil:[0@0] ifNotNil:[props layoutInset].! !!CPrimitiveCostume methodsFor: 'layout' stamp: 'ar 3/24/2004 03:36'!layoutInset: newInset	self layoutInset = newInset ifTrue:[^self].	self assureLayoutProperties layoutInset: newInset.	self invalidateLayout.! !!CPrimitiveCostume methodsFor: 'layout'!layoutNeeded				 	^(flags bitAnd: FlagLayoutNeeded) == FlagLayoutNeeded! !!CPrimitiveCostume methodsFor: 'layout'!layoutNeeded: aBool				 	flags := aBool ifTrue:[flags bitOr: FlagLayoutNeeded] ifFalse:[flags bitClear: FlagLayoutNeeded].! !!CPrimitiveCostume methodsFor: 'layout' stamp: 'ar 9/4/2003 23:43'!layoutProperties	"Return the current layout properties associated with the receiver"	^self propertyValueAt: #layoutProperties! !!CPrimitiveCostume methodsFor: 'layout' stamp: 'ar 9/4/2003 23:39'!layoutProperties: newProperties	"Return the current layout properties associated with the receiver"	self propertyValueAt: #layoutProperties put: newProperties.! !!CPrimitiveCostume methodsFor: 'layout'!layoutProportionallyIn: newBounds	"Layout specific. Apply the given bounds to the receiver."	| box frame |	frame _ self layoutFrame ifNil:[^self].	"before applying the proportional values make sure the receiver's layout is computed"	self fullBounds. "sigh..."	"compute the cell size the receiver has given its layout frame"	box _ frame layout: self bounds in: newBounds.	(box = self bounds) ifTrue:[^self]. "no change"	^self layoutInBounds: box.! !!CPrimitiveCostume methodsFor: 'layout' stamp: 'ar 3/15/2003 17:08'!layoutSimplyIn: newBounds	"Layout specific. Apply the given bounds to the receiver."	| box hFit vFit myBounds |	hFit := self hResizing.	vFit := self vResizing.	(hFit == #spaceFill or:[vFit == #spaceFill]) ifFalse:[^self].	myBounds := self bounds.	box := myBounds.	hFit == #spaceFill ifTrue:[box := box withWidth: newBounds width].	vFit == #spaceFill ifTrue:[box := box withHeight: newBounds height].	box = myBounds ifTrue:[^self].	^self layoutInBounds: box.! !!CPrimitiveCostume methodsFor: 'layout' stamp: 'ar 3/23/2004 23:07'!minExtent	"Layout specific. Return the minimum size the receiver can be represented in."	| minExtent extra hFit vFit |	hFit := self hResizing.	vFit := self vResizing.	"If both are rigid then just take my full bounds"	(hFit == #rigid and:[vFit == #rigid]) 		ifTrue:[^self fullBounds extent].	"Compute the minimal extent of my children"	minExtent := self minimalPartsExtent.	"receiver with #shrinkWrap constraints but no children is being treated #rigid"	self ignoreShrinkWrapConstraints ifTrue:[		hFit == #shrinkWrap ifTrue:[hFit := #rigid].		vFit == #shrinkWrap ifTrue:[vFit := #rigid]].	"Ignore the minExtent for clipping #spaceFill costumes. 	This allows #spaceFill costumes to shrink below their parts size,	but ONLY if clipping."	self clipping ifTrue:[		hFit == #spaceFill ifTrue:[minExtent := 0 @ minExtent y].		vFit == #spaceFill ifTrue:[minExtent := minExtent x @ 0].	].	"Fix up #rigid costumes which will not resize at all. 	For all others outset the minExtent by the costume's layout inset."	hFit == #rigid		ifTrue:[	minExtent := self fullBounds extent x @ minExtent y]		ifFalse:[extra := self bounds width - self layoutBounds width.				minExtent := (minExtent x + extra) @ minExtent y].	vFit == #rigid		ifTrue:[minExtent := minExtent x @ self fullBounds extent y]		ifFalse:[extra := self bounds height - self layoutBounds height.				minExtent := minExtent x @ (minExtent y + extra)].	"Constrain minExtent by user-supplied minimal width / height"	minExtent := minExtent max: (self minWidth@self minHeight).	^minExtent! !!CPrimitiveCostume methodsFor: 'layout' stamp: 'ar 3/23/2004 20:17'!minHeight	| minH |	minH := self propertyValueAt: #minHeight ifAbsent:[1].	(flags bitAnd: FlagHasText) = 0 ifFalse:[		minH := minH max: self textHolder minHeight.	].	(flags bitAnd: FlagHasGraphic) = 0 ifFalse:[		minH := minH max: self graphic minHeight.	].	^minH! !!CPrimitiveCostume methodsFor: 'layout' stamp: 'ar 9/4/2003 23:39'!minHeight: aNumber	aNumber == nil		ifTrue:[self removeProperty: #minHeight]		ifFalse:[self propertyValueAt: #minHeight put: aNumber].	self invalidateLayout.! !!CPrimitiveCostume methodsFor: 'layout' stamp: 'ar 3/23/2004 20:17'!minWidth	| minW |	minW := self propertyValueAt: #minWidth ifAbsent:[1].	(flags bitAnd: FlagHasText) = 0 ifFalse:[		minW := minW max: self textHolder minWidth.	].	(flags bitAnd: FlagHasText) = 0 ifFalse:[		minW := minW max: self textHolder minWidth.	].	^minW! !!CPrimitiveCostume methodsFor: 'layout' stamp: 'ar 9/4/2003 23:39'!minWidth: aNumber	aNumber == nil		ifTrue:[self removeProperty: #minWidth]		ifFalse:[self propertyValueAt: #minWidth put: aNumber].	self invalidateLayout.! !!CPrimitiveCostume methodsFor: 'layout' stamp: 'ar 3/24/2004 02:50'!minimalPartsExtent	"Compute the minimal extent of my children. This method has been factored out since Text costumes need to handle this slightly differently."	| layout minExtent |	layout := self layout.	layout 		ifNil:[minExtent := self contentsBounds corner - self innerBounds origin]		ifNotNil:[minExtent := layout minExtentOf: self in: self layoutBounds].	(flags bitAnd: FlagHasText) = 0 ifFalse:[		"Include the text itself. Note: For both, wrapped and non-wrapped text		we take the current editor extent. Obviously, this is correct for wrapped		text but also for non-wrapped since the editor has layed out the text		in its current extent which means that it is possible to represent the		text in these minimal bounds."		minExtent := minExtent max: self textHolder minimalTextExtent.	].	^minExtent! !!CPrimitiveCostume methodsFor: 'layout' stamp: 'ar 3/26/2004 01:12'!textBounds	"Answer the bounds for drawing text"	^border insetBounds: (0@0 extent: bounds extent)! !!CPrimitiveCostume methodsFor: 'layout' stamp: 'ar 3/21/2004 04:44'!vResizing	"Layout specific. This property describes how the receiver should be resized with respect to its owner and its children. Possible values are:		#rigid			-	do not resize the receiver		#spaceFill		-	resize to fill owner's available space		#shrinkWrap	- resize to fit children	"	| props |	props _ self layoutProperties.	^props ifNil:[#rigid] ifNotNil:[props vResizing].! !!CPrimitiveCostume methodsFor: 'layout' stamp: 'ar 2/17/2004 18:55'!vResizing: aSymbol	"Layout specific. This property describes how the receiver should be resized with respect to its owner and its children. Possible values are:		#rigid			-	do not resize the receiver		#spaceFill		-	resize to fill owner's available space		#shrinkWrap	- resize to fit children	"	self vResizing == aSymbol ifTrue:[^self].	self assureLayoutProperties vResizing: aSymbol.	self signal: #vResizingChanged.	self invalidateLayout.! !!CPrimitiveCostume methodsFor: 'corners' stamp: 'ar 4/20/2004 21:47'!roundCornerFlags	self roundCorners ifFalse:[^0].	^self propertyValueAt: #roundCornerFlags ifAbsent:[15]! !!CPrimitiveCostume methodsFor: 'corners' stamp: 'ar 4/20/2004 21:48'!roundCornerFlags: cornerFlags	cornerFlags = 0 ifTrue:[		self removeProperty: #roundCornerFlags.		^self roundCorners: false].	cornerFlags = 15 ifTrue:[		self removeProperty: #roundCornerFlags.		^self roundCorners: true].	self propertyValueAt: #roundCornerFlags put: cornerFlags.	self roundCorners: true.	self invalidate.	self signal: #roundCornersChanged.! !!CPrimitiveCostume methodsFor: 'corners' stamp: 'ar 4/20/2004 21:54'!roundCornerSpec	^(1 to: 4) select:[:i| self roundCornerFlags anyMask: (1 bitShift: i-1)]! !!CPrimitiveCostume methodsFor: 'corners' stamp: 'ar 4/20/2004 21:53'!roundCornerSpec: anArray	^self roundCornerFlags: (anArray inject: 0 into:[:sum :next| sum bitOr: (1 bitShift: next-1)])! !!CPrimitiveCostume methodsFor: 'corners' stamp: 'ar 3/24/2004 14:14'!roundCorners	"Return true if the receiver wants its corners rounded"	^(flags bitAnd: FlagRoundedCorners) = FlagRoundedCorners! !!CPrimitiveCostume methodsFor: 'corners' stamp: 'ar 3/24/2004 14:26'!roundCorners: aBool	"Indicate whether the receiver wants its corners rounded"	self roundCorners = aBool ifTrue:[^self].	flags := aBool 		ifTrue:[flags bitOr: FlagRoundedCorners] 		ifFalse:[flags bitClear: FlagRoundedCorners].	self invalidate.	self signal: #roundCornersChanged.! !!CPrimitiveCostume methodsFor: 'corners' stamp: 'ar 3/24/2004 14:26'!roundedCorners	"Compatibility"	^self roundCornerSpec! !!CPrimitiveCostume methodsFor: 'corners' stamp: 'ar 3/24/2004 14:26'!wantsRoundedCorners	"Compatibility"	^self roundCorners! !!CPrimitiveCostume methodsFor: 'geometry' stamp: 'ar 3/28/2004 16:21'!angle	"Warning: angle is numerically unstable so round it to .01"	(flags bitAnd: FlagHasMatrix) = 0 ifTrue:[^0].	^self heading degrees roundTo: 0.01.! !!CPrimitiveCostume methodsFor: 'geometry' stamp: 'bf 3/30/2004 10:47'!angle: aNumber	self rotateBy: aNumber - self angle.	^aNumber! !!CPrimitiveCostume methodsFor: 'geometry' stamp: 'ar 3/24/2004 03:17'!bottom	^ self bounds bottom! !!CPrimitiveCostume methodsFor: 'geometry' stamp: 'bf 3/30/2004 11:18'!bottom: aNumber	self moveBy: 0@(aNumber - self bottom).	^aNumber! !!CPrimitiveCostume methodsFor: 'geometry' stamp: 'ar 3/24/2004 03:18'!bottomLeft	^ self bounds bottomLeft! !!CPrimitiveCostume methodsFor: 'geometry' stamp: 'ar 3/24/2004 03:18'!bottomLeft: aPoint	self bottom: aPoint y.	self left: aPoint x.! !!CPrimitiveCostume methodsFor: 'geometry' stamp: 'ar 3/24/2004 03:19'!bottomRight	^ self bounds bottomRight! !!CPrimitiveCostume methodsFor: 'geometry' stamp: 'ar 3/24/2004 03:19'!bottomRight: aPoint	self bottom: aPoint y.	self right: aPoint x! !!CPrimitiveCostume methodsFor: 'geometry'!bounds	(flags bitAnd: FlagIntrinsicFullBounds) == 0 ifTrue:[^bounds].	^self localBounds transformedBy: self transform! !!CPrimitiveCostume methodsFor: 'geometry'!bounds: newBounds	self topLeft: newBounds origin; extent: newBounds extent.! !!CPrimitiveCostume methodsFor: 'geometry' stamp: 'ar 3/24/2004 03:19'!center	^ self bounds center! !!CPrimitiveCostume methodsFor: 'geometry' stamp: 'ar 3/24/2004 03:19'!center: aPoint	self moveBy: aPoint - self center.! !!CPrimitiveCostume methodsFor: 'geometry' stamp: 'ar 12/8/2002 14:27'!childToParent	"Answer a transformation mapping from my coordinate frame 	into my parent's coordinate frame."	^self transform! !!CPrimitiveCostume methodsFor: 'geometry'!childToParent: anObject	^anObject transformedBy: self childToParent! !!CPrimitiveCostume methodsFor: 'geometry' stamp: 'ar 3/24/2004 03:19'!corner	^self bounds corner! !!CPrimitiveCostume methodsFor: 'geometry' stamp: 'ar 3/24/2004 03:19'!corner: aPoint	^self moveBy: aPoint - self corner! !!CPrimitiveCostume methodsFor: 'geometry'!costumeMoved: aCostume	self invalidateLayout.	self isTextCostume ifTrue:[self adjustTextAnchor: self].! !!CPrimitiveCostume methodsFor: 'geometry' stamp: 'ar 5/5/2004 12:43'!extent	^bounds extent! !!CPrimitiveCostume methodsFor: 'geometry' stamp: 'bf 3/30/2004 10:46'!extent: aPoint	self resizable 		ifTrue:[self resizeTo: aPoint]		ifFalse:[self scaleTo: aPoint].	^aPoint! !!CPrimitiveCostume methodsFor: 'geometry'!globalBounds	^self localToGlobal: self localBounds! !!CPrimitiveCostume methodsFor: 'geometry' stamp: 'ar 9/8/2004 14:00'!globalPosition	^self localToGlobal: 0@0! !!CPrimitiveCostume methodsFor: 'geometry' stamp: 'ar 9/8/2004 14:01'!globalPosition: aPoint	self moveBy: (self globalToLocal: aPoint)! !!CPrimitiveCostume methodsFor: 'geometry'!globalToLocal	"Answer a transformation from the global into the local frame"	^self localToGlobal inverseTransformation! !!CPrimitiveCostume methodsFor: 'geometry'!globalToLocal: anObject	"Transform anObject from global (world) coordinates into local coordinates"	^anObject transformedBy: self globalToLocal.! !!CPrimitiveCostume methodsFor: 'geometry' stamp: 'ar 3/23/2003 19:51'!heading	^(self transform transformDirection: 1@0) normalized! !!CPrimitiveCostume methodsFor: 'geometry' stamp: 'bf 3/30/2004 10:48'!heading: aDirection	"Indicate the new heading for the receiver"	| oldHeading newHeading sin cos angle |	oldHeading := self heading.	"Compute the delta angle between current and new heading"	newHeading := [aDirection normalized] on: ZeroDivide do:[:ex| ex return: nil].	newHeading ifNil:[^oldHeading].	sin := oldHeading crossProduct: newHeading.	cos := oldHeading dotProduct: newHeading.	angle := cos arcCos radiansToDegrees.	sin < 0.0 ifTrue:[angle := angle negated].	self rotateBy: angle.	^aDirection! !!CPrimitiveCostume methodsFor: 'geometry' stamp: 'ar 3/24/2004 03:20'!height	^ self bounds height! !!CPrimitiveCostume methodsFor: 'geometry' stamp: 'bf 3/30/2004 10:46'!height: aNumber	self extent: self width@aNumber asInteger.	^aNumber! !!CPrimitiveCostume methodsFor: 'geometry' stamp: 'ar 3/23/2004 23:12'!infinite	"Answer whether the receiver should be treated as an infinite plane"	^self propertyValueAt: #infinite ifAbsent:[false]! !!CPrimitiveCostume methodsFor: 'geometry' stamp: 'ar 3/23/2004 23:12'!infinite: aBool	"Indicate whether the receiver should be treated as an infinite plane"	self propertyValueAt: #infinite put: (aBool ifTrue:[true] ifFalse:[nil]).	self signal: #flagsChanged! !!CPrimitiveCostume methodsFor: 'geometry' stamp: 'ar 3/24/2004 03:21'!left	^self bounds left! !!CPrimitiveCostume methodsFor: 'geometry' stamp: 'bf 3/30/2004 11:18'!left: aNumber	self moveBy: (aNumber - self left) @ 0.	^aNumber! !!CPrimitiveCostume methodsFor: 'geometry' stamp: 'ar 3/24/2004 03:21'!localBounds	"Answer the receiver's local bounds starting at 0@0."	^self scrollOffset extent: bounds extent! !!CPrimitiveCostume methodsFor: 'geometry'!localExtent	^bounds extent! !!CPrimitiveCostume methodsFor: 'geometry' stamp: 'ar 3/23/2004 20:17'!localExtent: aPoint	| newExtent aspect oldExtent |	newExtent := aPoint.	(aspect := self aspectRatio) ifNotNil:[		(newExtent y * aspect) > newExtent x			ifFalse:[newExtent := newExtent x @ (newExtent x / aspect)]			ifTrue:[newExtent := (newExtent y * aspect) @ newExtent y]].	newExtent := newExtent asIntegerPoint max: self minWidth @ self minHeight.	oldExtent := bounds extent.	oldExtent = newExtent ifTrue:[^self].	oldExtent <= newExtent ifFalse:[self invalidate: self outerBounds].	bounds := bounds origin extent: newExtent.	newExtent <= oldExtent ifFalse:[self invalidate: self outerBounds].	self signal: #extentChanged.	self signal: #geometryChanged.	self frameChanged.	self invalidateLayout.	(flags bitAnd: FlagHasText) = 0 ifFalse:[		self textHolder updateParagraphExtent	].! !!CPrimitiveCostume methodsFor: 'geometry' stamp: 'ar 1/8/2003 16:57'!localToGlobal	"Answer a transformation from the local into the global frame"	^container 		ifNil:[self childToParent]		ifNotNil:[self childToParent transformedBy: container localToGlobal]! !!CPrimitiveCostume methodsFor: 'geometry'!localToGlobal: anObject	"Transform anObject from global (world) coordinates into local coordinates"	^anObject transformedBy: self localToGlobal.! !!CPrimitiveCostume methodsFor: 'geometry' stamp: 'ar 12/8/2003 19:42'!localToWorld	"Answer a transformation from the local into the global frame"	self isWorld ifTrue:[^CIdentityTransform new].	^container 		ifNil:[self childToParent]		ifNotNil:[self childToParent transformedBy: container localToWorld]! !!CPrimitiveCostume methodsFor: 'geometry' stamp: 'ar 7/15/2003 16:39'!localToWorld: anObject	"Transform anObject from global (world) coordinates into local coordinates"	^anObject transformedBy: self localToWorld.! !!CPrimitiveCostume methodsFor: 'geometry' stamp: 'ar 3/24/2004 03:21'!origin	^self bounds origin! !!CPrimitiveCostume methodsFor: 'geometry' stamp: 'ar 3/24/2004 03:21'!origin: aPoint	^self moveBy: aPoint - self origin! !!CPrimitiveCostume methodsFor: 'geometry'!parentToChild	^self childToParent inverseTransformation! !!CPrimitiveCostume methodsFor: 'geometry'!parentToChild: anObject	^anObject transformedBy: self parentToChild! !!CPrimitiveCostume methodsFor: 'geometry' stamp: 'ar 3/10/2003 11:45'!position	^self childToParent: 0@0! !!CPrimitiveCostume methodsFor: 'geometry' stamp: 'bf 3/30/2004 10:43'!position: aPoint	self moveTo: aPoint.	^aPoint! !!CPrimitiveCostume methodsFor: 'geometry'!referencePosition	^self rotationCenter transformedBy: self transform! !!CPrimitiveCostume methodsFor: 'geometry'!referencePosition: aPoint	^self rotationCenter: (self transform invertPoint: aPoint)! !!CPrimitiveCostume methodsFor: 'geometry' stamp: 'ar 9/4/2003 23:50'!resizable	"Return true if the receiver is resizable. Returning false will result in scaling."	^self propertyValueAt: #resizable ifAbsent:[true]! !!CPrimitiveCostume methodsFor: 'geometry' stamp: 'ar 9/4/2003 23:40'!resizable: aBool	"Return true if the receiver is resizable. Returning false will result in scaling."	aBool		ifTrue:[self removeProperty: #resizable]		ifFalse:[self propertyValueAt: #resizable put: false].! !!CPrimitiveCostume methodsFor: 'geometry' stamp: 'ar 3/24/2004 03:22'!right	^self bounds right! !!CPrimitiveCostume methodsFor: 'geometry' stamp: 'bf 3/30/2004 11:18'!right: aNumber	self moveBy: (aNumber - self right) @ 0.	^aNumber! !!CPrimitiveCostume methodsFor: 'geometry' stamp: 'ar 9/4/2003 23:50'!rotationCenter	"Return the rotation center of the receiver. The rotation center defines the relative offset inside the receiver's bounds for locating the reference position."	^self propertyValueAt: #rotationCenter ifAbsent:[self localBounds center]! !!CPrimitiveCostume methodsFor: 'geometry' stamp: 'ar 9/4/2003 23:40'!rotationCenter: aPointOrNil	"Set the new rotation center of the receiver. The rotation center defines the relative offset inside the receiver's bounds for locating the reference position."	aPointOrNil isNil		ifTrue:[self removeProperty: #rotationCenter]		ifFalse:[self propertyValueAt: #rotationCenter put: aPointOrNil].	self invalidateLayout.! !!CPrimitiveCostume methodsFor: 'geometry'!rotationDegrees	^(self transform asMatrixTransform2x3 a11 @ self transform asMatrixTransform2x3 a21) degrees! !!CPrimitiveCostume methodsFor: 'geometry' stamp: 'bf 5/7/2004 21:30'!rotationDegrees: degrees	"Set the receiver's rotation degrees. If the degrees are close to 90, renormalize the transform to prevent nunerical inaccuracies"	degrees = self rotationDegrees ifTrue:[^self].	self rotateBy: degrees - self rotationDegrees.	((degrees - degrees rounded) abs < 0.001 and:[(degrees rounded \\ 90) = 0]) 		ifTrue:[^self normalizeWithRotationDegrees: degrees rounded].! !!CPrimitiveCostume methodsFor: 'geometry' stamp: 'ar 3/28/2004 16:30'!scale	"Warning: scale is numerically unstable so round it to .01"	| scale |	(flags bitAnd: FlagHasMatrix) = 0 ifTrue:[^1].	scale := self transform scale roundTo: 0.01.	scale x = scale y ifTrue:[^scale x].	^scale! !!CPrimitiveCostume methodsFor: 'geometry' stamp: 'bf 3/30/2004 10:48'!scale: aNumber	self scaleBy: aNumber / self scale.	^aNumber! !!CPrimitiveCostume methodsFor: 'geometry' stamp: 'ar 3/24/2004 03:23'!top	^ self bounds top! !!CPrimitiveCostume methodsFor: 'geometry' stamp: 'bf 3/30/2004 11:18'!top: aNumber	self moveBy: 0 @ (aNumber - self top).	^aNumber! !!CPrimitiveCostume methodsFor: 'geometry' stamp: 'ar 3/24/2004 03:23'!topLeft	^ self bounds topLeft! !!CPrimitiveCostume methodsFor: 'geometry' stamp: 'ar 3/24/2004 03:23'!topLeft: aPoint	self moveBy: aPoint - self topLeft.! !!CPrimitiveCostume methodsFor: 'geometry' stamp: 'ar 3/24/2004 03:23'!topRight	^ self bounds topRight! !!CPrimitiveCostume methodsFor: 'geometry' stamp: 'ar 3/24/2004 03:23'!topRight: aPoint	self top: aPoint y.	self right: aPoint x! !!CPrimitiveCostume methodsFor: 'geometry'!transform	^self privateTransform! !!CPrimitiveCostume methodsFor: 'geometry' stamp: 'ar 3/21/2004 03:43'!transform: newTransform	"Change the current transform. This is the core of all transformations."	| penPos |	self isPenDown ifTrue:[penPos := self penPosition].	self invalidate.	self privateTransform: newTransform.	container ifNotNil:[container costumeMoved: self].	self invalidate.	penPos ifNotNil:[self pen moveFrom: penPos to: self penPosition].! !!CPrimitiveCostume methodsFor: 'geometry' stamp: 'ar 3/24/2004 03:24'!width	^self bounds width! !!CPrimitiveCostume methodsFor: 'geometry' stamp: 'bf 3/30/2004 10:46'!width: aNumber	self extent: aNumber asInteger@self height.	^aNumber! !!CPrimitiveCostume methodsFor: 'geometry' stamp: 'ar 7/15/2003 16:33'!worldToLocal	"Answer a transformation from the local into the global frame"	^self localToWorld inverseTransformation! !!CPrimitiveCostume methodsFor: 'geometry' stamp: 'ar 7/15/2003 16:39'!worldToLocal: anObject	"Transform anObject from global (world) coordinates into local coordinates"	^anObject transformedBy: self worldToLocal.! !!CPrimitiveCostume methodsFor: 'geometry' stamp: 'ar 3/10/2003 11:45'!x	^self position x! !!CPrimitiveCostume methodsFor: 'geometry' stamp: 'bf 3/30/2004 10:42'!x: aNumber	self position: aNumber @ self y.	^aNumber! !!CPrimitiveCostume methodsFor: 'geometry' stamp: 'ar 3/10/2003 11:46'!y	^self position y! !!CPrimitiveCostume methodsFor: 'geometry' stamp: 'bf 3/30/2004 10:43'!y: aNumber	self position: self x @ aNumber.	^aNumber! !!CPrimitiveCostume methodsFor: 'adding' stamp: 'ar 4/2/2004 14:27'!add: aCostume	self addLast: aCostume.! !!CPrimitiveCostume methodsFor: 'adding' stamp: 'ar 3/16/2004 14:35'!add: newObject after: oldObject				 	"Add the argument, newObject, as an element of the receiver. Put it in 	the sequence just succeeding oldObject."	self add: newObject at: (self indexOf: oldObject)+1! !!CPrimitiveCostume methodsFor: 'adding' stamp: 'ar 3/16/2004 12:36'!add: aCostume at: index		^self privateAdd: aCostume beforeIndex: index! !!CPrimitiveCostume methodsFor: 'adding' stamp: 'ar 12/18/2002 14:15'!add: aCostume atIndex: index				 	 	^self privateAdd: aCostume atIndex: index! !!CPrimitiveCostume methodsFor: 'adding' stamp: 'ar 3/16/2004 14:35'!add: newObject before: oldObject				 	 	"Add the argument, newObject, as an element of the receiver. Put it in 	the sequence just preceding oldObject. Answer newObject."	self add: newObject at: (self indexOf: oldObject ifAbsent:[1])! !!CPrimitiveCostume methodsFor: 'adding' stamp: 'ar 12/7/2002 22:26'!add: aCostume frame: relFrame	| frame |	frame _ CLayoutFrame new.	frame 		leftFraction: relFrame left; 		rightFraction: relFrame right; 		topFraction: relFrame top; 		bottomFraction: relFrame bottom.	self add: aCostume fullFrame: frame.! !!CPrimitiveCostume methodsFor: 'adding' stamp: 'ar 12/7/2002 22:26'!add: aCostume frame: relFrame offsets: offsets	| frame |	frame := CLayoutFrame new.	frame 		leftFraction: relFrame left offset: offsets left;		rightFraction: relFrame right offset: offsets right;		topFraction: relFrame top offset: offsets top;		bottomFraction: relFrame bottom offset: offsets bottom.	self add: aCostume fullFrame: frame.! !!CPrimitiveCostume methodsFor: 'adding' stamp: 'ar 3/21/2004 13:39'!add: aCostume fullFrame: aLayoutFrame	aCostume layoutFrame: aLayoutFrame.	aCostume hResizing: #spaceFill; vResizing: #spaceFill.	self add: aCostume.! !!CPrimitiveCostume methodsFor: 'adding' stamp: 'tk 7/14/2004 11:26'!addAll: aCollection					 	 	"Add all the costumes in aCollection after the prior costume"	self privateReplaceFrom: contents size+1 to: contents size 		with: (aCollection collect:[:each| each asPrimCostume]).! !!CPrimitiveCostume methodsFor: 'adding' stamp: 'ar 3/16/2004 14:39'!addAll: aCollection after: prevCostume					 	 	 	"Add all the costumes in aCollection after the prior costume"	^self addAll: aCollection 		at: (contents indexOf: prevCostume ifAbsent:[contents size])+1.! !!CPrimitiveCostume methodsFor: 'adding' stamp: 'tk 7/14/2004 11:26'!addAll: aCollection at: index					 	 	"Add all the costumes in aCollection after the prior costume"	self privateReplaceFrom: index to: index-1 		with: (aCollection collect:[:each| each asPrimCostume]).! !!CPrimitiveCostume methodsFor: 'adding' stamp: 'ar 3/16/2004 14:36'!addFirst: aCostume	"Add newObject to the beginning of the receiver"	self add: aCostume at: 1! !!CPrimitiveCostume methodsFor: 'adding' stamp: 'ar 3/16/2004 14:36'!addLast: aCostume	"Add newObject to the end of the receiver"	self add: aCostume at: contents size+1! !!CPrimitiveCostume methodsFor: 'adding'!indexOf: anElement	"Answer the index of the first occurence of anElement within the  	receiver. If the receiver does not contain anElement, answer 0."	^ self indexOf: anElement ifAbsent: [0]! !!CPrimitiveCostume methodsFor: 'adding'!indexOf: anElement ifAbsent: exceptionBlock	"Answer the index of the first occurence of anElement within the  	receiver. If the receiver does not contain anElement, answer the 	result of evaluating the argument, exceptionBlock."	^ self indexOf: anElement startingAt: 1 ifAbsent: exceptionBlock! !!CPrimitiveCostume methodsFor: 'adding' stamp: 'ar 1/8/2003 17:12'!indexOf: anElement startingAt: start ifAbsent: exceptionBlock	"Answer the index of the first occurence of anElement after start	within the receiver. If the receiver does not contain anElement, 	answer the 	result of evaluating the argument, exceptionBlock."	start to: contents size do:[:index |		(contents at: index) = anElement ifTrue: [^ index]].	^ exceptionBlock value! !!CPrimitiveCostume methodsFor: 'adding' stamp: 'tk 7/14/2004 11:27'!replace: cc1 with: cc2	| index costume1 costume2 |	costume1 := cc1 asPrimCostume.	costume2 := cc2 asPrimCostume.	costume1 == costume2 ifTrue:[^self].	costume2 ifNil:[^self remove: costume1].	costume1 ifNil:[^self addLast: costume2].	index := self indexOf: costume1 ifAbsent:[^nil].	self replaceFrom: index to: index with: (Array with: costume2).! !!CPrimitiveCostume methodsFor: 'adding' stamp: 'ar 2/16/2003 19:20'!replaceFrom: firstIndex to: lastIndex with: aCollection	^self privateReplaceFrom: firstIndex to: lastIndex with: aCollection! !!CPrimitiveCostume methodsFor: 'adding' stamp: 'ar 3/16/2004 13:40'!replaceFrom: firstIndex to: lastIndex with: aCollection startingAt: replStart	replStart = 1 		ifTrue:[^self privateReplaceFrom: firstIndex to: lastIndex with: aCollection]		ifFalse:[^self privateReplaceFrom: firstIndex to: lastIndex with: (aCollection copyFrom: replStart to: aCollection size)].! !!CPrimitiveCostume methodsFor: 'text anchoring' stamp: 'ar 12/8/2003 19:37'!inlineTextAnchorPosition: aPoint	"Set the new inline text anchor position for the receiver. This method is currently a hack since not all of the transformation model has been figured out with respect to text handling. Currently, the point describes the left and the baseline position of the receiver with respect to a text origin of 0@0. This text origin is relative to the containers text bounds so we need to do a bit of conversion here."	| distance pos |true ifTrue:[^self].	container isTextCostume ifFalse:[^self]. "should never happen"	distance := (self referencePosition y - self top) asInteger.	pos := container textBounds topLeft + (aPoint x @ (aPoint y - distance)).	self position: pos! !!CPrimitiveCostume methodsFor: 'text anchoring' stamp: 'ar 9/4/2003 23:48'!relativeTextAnchorPosition	^self propertyValueAt: #relativeTextAnchorPosition! !!CPrimitiveCostume methodsFor: 'text anchoring' stamp: 'ar 9/4/2003 23:40'!relativeTextAnchorPosition: aPoint	^self propertyValueAt: #relativeTextAnchorPosition put: aPoint! !!CPrimitiveCostume methodsFor: 'text anchoring' stamp: 'ar 9/24/2003 13:54'!textAnchorType	^(self propertyValueAt: #textAnchorType) ifNil:[#document]! !!CPrimitiveCostume methodsFor: 'text anchoring' stamp: 'ar 9/4/2003 23:41'!textAnchorType: aSymbol	aSymbol == #document		ifTrue:[^self removeProperty: #textAnchorType]		ifFalse:[^self propertyValueAt: #textAnchorType put: aSymbol].! !!CPrimitiveCostume methodsFor: 'testing' stamp: 'ar 4/2/2004 14:15'!fullContainsPoint: globalPt	"NOTE: Contrary to #containsPoint: this method assumes the target point to be in the parents reference frame."	| localPt |	localPt := self parentToChild: globalPt.	(self localFullBounds containsPoint: localPt) 		ifFalse: [^ false].  "try quick elimination"	(self containsPoint: localPt)		ifTrue:[^true]. "try quick acceptance"	contents reverseDo: [:m | (m fullContainsPoint: localPt) ifTrue: [^true]].	^ false! !!CPrimitiveCostume methodsFor: 'testing' stamp: 'ar 2/17/2004 19:02'!hasKeyboardFocus	| myHand myRoot |	myHand := self hand.	myHand isPlayer ifTrue:[^myHand keyboardFocus == self].	"@@@: Workaround - this doesn't work correctly if we're somewhere in Morphic :@@@"	myRoot := self root ifNil:[^false].	^myRoot primaryHand keyboardFocus == self! !!CPrimitiveCostume methodsFor: 'testing' stamp: 'ar 2/17/2004 19:03'!hasMouseFocus	^self hand mouseFocus == self! !!CPrimitiveCostume methodsFor: 'testing' stamp: 'ar 9/10/2003 18:15'!isIn: aContainer	"Return true if the receiver is contained in aContainer."	| cc |	aContainer ifNil:[^true].	"Open-coded for speed."	cc := container.	[cc == nil] whileFalse:[		aContainer == cc ifTrue:[^true].		cc := cc container].	^false! !!CPrimitiveCostume methodsFor: 'testing' stamp: 'ar 7/15/2003 16:18'!isInWorld	"Remove this at some point"	self isWorld ifFalse:[^self world notNil].	container ifNil:[^false].	^container world notNil! !!CPrimitiveCostume methodsFor: 'testing' stamp: 'ar 2/17/2004 19:05'!isOrIn: aCostume	"Return true if the receiver is contained in aContainer"	aCostume == nil ifTrue:[^true].	self == aCostume ifTrue:[^true].	self allContainersDo:[:aContainer| aContainer == aCostume ifTrue:[^true]].	^false! !!CPrimitiveCostume methodsFor: 'testing' stamp: 'tk 6/22/2004 17:46'!isPrimitiveCostume	"well, of course"	^true! !!CPrimitiveCostume methodsFor: 'testing'!isTextCostume	^false! !!CPrimitiveCostume methodsFor: 'testing' stamp: 'ar 9/4/2003 23:50'!isWorld	^self propertyValueAt: #isWorld ifAbsent:[false]! !!CPrimitiveCostume methodsFor: 'testing' stamp: 'ar 9/4/2003 23:38'!isWorld: aBool	^self propertyValueAt: #isWorld put: aBool! !!CPrimitiveCostume methodsFor: 'testing' stamp: 'ar 3/23/2004 23:39'!locked				 	^(flags bitAnd: FlagLocked) == FlagLocked! !!CPrimitiveCostume methodsFor: 'testing' stamp: 'ar 3/23/2004 23:39'!locked: aBool	flags := aBool ifTrue:[flags bitOr: FlagLocked] ifFalse:[flags bitClear: FlagLocked].	self signal: #flagsChanged.! !!CPrimitiveCostume methodsFor: 'event handling' stamp: 'ar 3/23/2004 23:13'!containsEvent: localPt	"Return true if aPoint is considered to be inside the receiver for event handling. The default implementation treats locked contents as integral part of their owners."	self obsolete.	self infinite ifTrue:[^true].	(self localFullBounds containsPoint: localPt)		ifFalse:[^false]. "try quick elimination"	(self containsPoint: localPt) 		ifTrue:[^true]. "try quick acceptance"	contents do:[:m|		(m locked and:[m fullContainsPoint: localPt])			ifTrue:[^true]].	^false! !!CPrimitiveCostume methodsFor: 'event handling' stamp: 'bf 4/29/2004 02:15'!containsPoint: localPoint	"Answer whether aPoint is in the receiver. Query player for custom drawing components"	| box |	box := self localBounds.	(box containsPoint: localPoint) ifFalse:[^false].	(flags bitAnd: FlagCustomDraw) == 0 ifTrue:[		fill isTransparent ifFalse:[^true].		self preciseCollisions ifFalse:[^true].		(flags bitAnd: FlagHasShape) = 0 ifTrue:[			"Check to see if it's on the border"			border isTransparent ifFalse:[				((border insetBounds: box) containsPoint: localPoint) ifFalse:[^true].			].		] ifFalse:[			(self shape containsPoint: localPoint) ifTrue:[^true].		].		(flags bitAnd: FlagHasGraphic) = 0 ifFalse:[			(self graphic containsPoint: localPoint) ifTrue:[^true].		].		(flags bitAnd: FlagHasText) = 0 ifFalse:[			(self textHolder containsPoint: localPoint) ifTrue:[^true].		].		^false	].	"Disable custom draw while querying player"	flags := flags bitClear: FlagCustomDraw.	^[self asPlayer containsPoint: localPoint]		ensure:[flags := flags bitOr: FlagCustomDraw]! !!CPrimitiveCostume methodsFor: 'event handling' stamp: 'ar 4/2/2004 14:19'!dispatchEvent: anEvent	"Dispatch the given event. The event will be passed to the front-most visible part that contains the event."	| localEvent index inside child shield |	(self rejectsEvent: anEvent) ifTrue:[^#rejected].	localEvent := anEvent transformedBy: self parentToChild. "into local frame"	self infinite ifFalse:[		(self localFullBounds containsPoint: localEvent position) 			ifFalse:[^#rejected]. "outside"	].	"Check for event shield"	(shield := self eventShield) ifNotNil:[		(self containsEvent: localEvent position) 			ifTrue:[^shield handleEvent: localEvent]			ifFalse:[^#rejected].	].	"Traverse children"	index := contents size + 1. inside := false.	[(index := index-1) > 0] whileTrue:[		child := contents at: index.		(child dispatchEvent: localEvent) == #rejected ifFalse:[			"Inside child of receiver"			inside := true.			localEvent wasHandled ifTrue:[				"Copy handler state for return"				anEvent copyHandlerState: localEvent			].			index := 0. "e.g., break"		].	].	"Check for inside of the receiver itself if necessary"	inside := inside or:[self infinite or:[self containsPoint: localEvent position]].	inside ifTrue:[		self handleEvent: localEvent.		localEvent wasHandled ifTrue:[			anEvent copyHandlerState: localEvent		].		^self].	^#rejected! !!CPrimitiveCostume methodsFor: 'event handling' stamp: 'ar 7/19/2003 20:54'!eventShield	"Answer the event shield for the receiver (if any)"	^self propertyValueAt: #eventShield.! !!CPrimitiveCostume methodsFor: 'event handling' stamp: 'ar 7/19/2003 20:55'!eventShield: anObject	"Set the event shield for the receiver (if any)"	^self propertyValueAt: #eventShield put: anObject! !!CPrimitiveCostume methodsFor: 'event handling' stamp: 'ar 2/17/2004 18:57'!handleChildEnter: anEvent with: aChild	"System level event handling."	(anEvent hand hasDragContents) 		ifTrue:[self signal: #dragEnterChild with: anEvent with: aChild with: self].	self signal: #mouseEnterChild with: anEvent with: aChild with: self.! !!CPrimitiveCostume methodsFor: 'event handling' stamp: 'ar 2/17/2004 18:57'!handleChildLeave: anEvent with: aChild	"System level event handling."	(anEvent hand hasDragContents) 		ifTrue:[self signal: #dragLeaveChild with: anEvent with: aChild with: self].	self signal: #mouseLeaveChild with: anEvent with: aChild with: self.! !!CPrimitiveCostume methodsFor: 'event handling' stamp: 'ar 2/17/2004 18:56'!handleDrop: anEvent	"Handle a drop event."	anEvent wasHandled ifTrue:[^self].	(self handlesDrop: anEvent) ifFalse:[^self].	anEvent wasHandled: true.	self signal: #dragDrop with: anEvent contents asPlayer with: anEvent! !!CPrimitiveCostume methodsFor: 'event handling' stamp: 'ar 2/17/2004 18:55'!handleDropFiles: anEvent	"Handle a drop event."	anEvent wasHandled ifTrue:[^self].	(self handlesDropFiles: anEvent) ifFalse:[^self].	anEvent wasHandled: true.	self signal: #dropFiles with: anEvent.! !!CPrimitiveCostume methodsFor: 'event handling'!handleEvent: anEvent	"Handle the given event"	^anEvent sentTo: self.! !!CPrimitiveCostume methodsFor: 'event handling' stamp: 'ar 4/2/2004 14:19'!handleFocusEvent: localEvent	"Dispatch the given event. The event will be passed to the front-most visible part that contains the event."	| index |	(self rejectsEvent: localEvent) ifTrue:[^self].	"Traverse children"	index := contents size + 1.	[(index := index-1) > 0] whileTrue:[		(( contents at: index) player dispatchEvent: localEvent) == #rejected 			ifFalse:[index := 0]. "e.g., break"	].	self handleEvent: localEvent.! !!CPrimitiveCostume methodsFor: 'event handling' stamp: 'ar 3/24/2004 12:36'!handleMouseDown: anEvent	"System level event handling."	self signal: #mouseDownListen with: anEvent.	anEvent wasHandled ifTrue:[^self]. "not interested"	(self handlesEvent: #rawMouseDown) ifTrue:[		"if you handle raw events everything is up to you - we don't care"		anEvent wasHandled: true.		^self signal: #rawMouseDown with: anEvent with: self.	].	(self handlesMouseDown: anEvent) ifFalse:[^self].	anEvent wasHandled: true.	self signal: #anyButtonDown with: anEvent with: self.	anEvent redButtonChanged ifTrue:[		(self handlesAnyOf:#(click dragStart doubleClick)) 			ifTrue:[self startScript: #waitForClicksOrDrag:event:						withArguments: {anEvent hand. anEvent clone}].		self signal: #mouseDown with: anEvent with: self.		self signal: #redButtonDown with: anEvent with: self.	].	anEvent yellowButtonChanged 		ifTrue:[self signal: #yellowButtonDown with: anEvent with: self].	anEvent blueButtonChanged 		ifTrue:[self signal: #blueButtonDown with: anEvent with: self].	"Make me modal during mouse transitions"	anEvent hand mouseFocus: self.! !!CPrimitiveCostume methodsFor: 'event handling' stamp: 'ar 3/26/2004 17:37'!handleMouseEnter: anEvent	"System level event handling."	(self handlesEvent: #rawMouseEnter) ifTrue:[		"if you handle raw events everything is up to you - we don't care"		^self signal: #rawMouseEnter with: anEvent with: self.	].	"The default semantics will ignores any enter/leave events 	if the mouse focus is not in my container chain"	(self isOrIn: anEvent hand mouseFocus) ifFalse:[^self].	"Otherwise dispatch it accordingly"	(anEvent hand hasDragContents) 		ifTrue:[^self signal: #dragEnter with: anEvent with: self].	self signal: #mouseEnter with: anEvent with: self.	anEvent hand balloonTarget: self.! !!CPrimitiveCostume methodsFor: 'event handling' stamp: 'ar 3/26/2004 17:36'!handleMouseLeave: anEvent	"System level event handling."	(self handlesEvent: #rawMouseLeave) ifTrue:[		"if you handle raw events everything is up to you - we don't care"		^self signal: #rawMouseLeave with: anEvent with: self.	].	"The default semantics will ignores any enter/leave events 	if the mouse focus is not in my container chain"	(self isOrIn: anEvent hand mouseFocus) ifFalse:[^self].	(anEvent hand hasDragContents) 		ifTrue:[^self signal: #dragLeave with: anEvent with: self].	^self signal: #mouseLeave with: anEvent with: self! !!CPrimitiveCostume methodsFor: 'event handling' stamp: 'ar 2/17/2004 18:56'!handleMouseMove: anEvent	"System level event handling."	anEvent wasHandled: true.	(self handlesEvent: #rawMouseMove) ifTrue:[		"if you handle raw events everything is up to you - we don't care"		^self signal: #rawMouseMove with: anEvent with: self.	].	(anEvent hand hasDragContents) 		ifTrue:[^self signal: #dragMove with: anEvent with: self].	self signal: #mouseMove with: anEvent with: self.	anEvent redButtonPressed 		ifTrue:[self signal: #redButtonMove with: anEvent with: self].	anEvent yellowButtonPressed 		ifTrue:[self signal: #yellowButtonMove with: anEvent with: self].	anEvent blueButtonPressed 		ifTrue:[self signal: #blueButtonMove with: anEvent with: self].! !!CPrimitiveCostume methodsFor: 'event handling' stamp: 'ar 2/17/2004 19:02'!handleMouseOver: anEvent	"@@@@: Check this - should we generate any #mouseOver events here?!! @@@@"	"System level event handling."false ifTrue:[	anEvent hand mouseFocus == self ifTrue:[		"Got this directly through #handleFocusEvent: so check explicitly"		(self containsEvent: anEvent position) ifFalse:[^self]].].	anEvent hand noticeMouseOver: self event: anEvent! !!CPrimitiveCostume methodsFor: 'event handling' stamp: 'ar 3/26/2004 17:35'!handleMouseUp: anEvent	"System level event handling."	anEvent wasHandled ifTrue:[^self]. "not interested"	(self handlesEvent: #rawMouseUp) ifTrue:[		"if you handle raw events everything is up to you - we don't care"		^self signal: #rawMouseUp with: anEvent with: self.	].	anEvent hand mouseFocus == self ifFalse:[		container ifNotNil:[^self]. "Not interested in other parties"	].	anEvent hand releaseMouseFocus: self.	anEvent wasHandled: true.	self signal: #anyButtonUp with: anEvent with: self.	anEvent redButtonChanged ifTrue:[		self signal: #redButtonUp with: anEvent with: self.		self signal: #mouseUp with: anEvent with: self].	anEvent yellowButtonChanged 		ifTrue:[self signal: #yellowButtonUp with: anEvent with: self].	anEvent blueButtonChanged 		ifTrue:[self signal: #blueButtonUp with: anEvent with: self].! !!CPrimitiveCostume methodsFor: 'event handling' stamp: 'ar 3/24/2004 03:09'!handlesAnyOf: eventNames	| myPlayer |	(super handlesAnyOf: eventNames) ifTrue:[^true].	myPlayer := self player ifNil:[^false].	^myPlayer handlesAnyOf: eventNames! !!CPrimitiveCostume methodsFor: 'event handling' stamp: 'ar 2/17/2004 18:52'!handlesDrop: anEvent	^self handlesEvent: #dragDrop! !!CPrimitiveCostume methodsFor: 'event handling' stamp: 'ar 2/17/2004 18:52'!handlesDropFiles: anEvent	^self handlesEvent: #dropFiles! !!CPrimitiveCostume methodsFor: 'event handling' stamp: 'ar 3/24/2004 03:09'!handlesEvent: eventName	| myPlayer |	(super handlesEvent: eventName) ifTrue:[^true].	myPlayer := self player ifNil:[^false].	^myPlayer handlesEvent: eventName! !!CPrimitiveCostume methodsFor: 'event handling' stamp: 'ar 2/17/2004 18:51'!handlesKeyboard: evt	^self isWorld or:[self handlesAnyOf: #(keyDown keyUp keyStroke)]! !!CPrimitiveCostume methodsFor: 'event handling' stamp: 'ar 2/17/2004 18:51'!handlesMouseDown: evt	"This really means: Am I interested in any kinds of events starting with a mouseDown"	(self handlesAnyOf: #(anyButtonDown anyButtonUp)) 		ifTrue:[^true].	evt ifNil:[		^self handlesAnyOf: #(			mouseDown mouseUp			redButtonDown redButtonUp 			yellowButtonDown yellowButtonUp 			blueButtonDown blueButtonUp 			click doubleClick dragStart		).	].	evt redButtonChanged ifTrue:[		^self handlesAnyOf: #(			mouseDown mouseUp			redButtonDown redButtonUp			click doubleClick dragStart		).	].	evt yellowButtonChanged ifTrue:[		^self handlesAnyOf: #(			yellowButtonDown yellowButtonUp			yellowButtonClick yellowButtonDrag		).	].	evt blueButtonChanged ifTrue:[		^self handlesAnyOf: #(			blueButtonDown blueButtonUp			blueButtonClick blueButtonDrag		).	].! !!CPrimitiveCostume methodsFor: 'event handling' stamp: 'ar 3/23/2004 20:16'!keyboardFocusEnter	"The receiver has become the new keyboard focus"	(flags bitAnd: FlagHasText) = 0 ifFalse:[		self textHolder keyboardFocusEnter.	].	self signal: #keyboardFocusEnter.! !!CPrimitiveCostume methodsFor: 'event handling' stamp: 'ar 3/23/2004 20:17'!keyboardFocusLeave	"The receiver has become the new keyboard focus"	(flags bitAnd: FlagHasText) = 0 ifFalse:[		self textHolder keyboardFocusLeave.	].	self signal: #keyboardFocusLeave.! !!CPrimitiveCostume methodsFor: 'event handling' stamp: 'ar 8/3/2004 17:22'!pressedKeys	self isWorld ifFalse:[^nil].	^self propertyValueAt: #pressedKeys ifAbsentPut:[Set new].! !!CPrimitiveCostume methodsFor: 'event handling' stamp: 'ar 3/23/2004 23:13'!rejectsEvent: anEvent	"Return true to reject the given event. Rejecting an event means neither the receiver nor any of it's parts will be given any chance to handle it."	^self locked or:[self visible not]! !!CPrimitiveCostume methodsFor: 'event handling' stamp: 'ar 3/24/2004 03:10'!signalEvent: anEvent	| myPlayer |	super signalEvent: anEvent.	myPlayer := self player ifNil:[^self].	anEvent setSender: myPlayer.	myPlayer signalEvent: anEvent.! !!CPrimitiveCostume methodsFor: 'event handling' stamp: 'ar 2/17/2004 18:57'!waitForClicksOrDrag: aHand event: firstEvent	"Synthesize #click, #doubleClick or #dragStart events"	| pos dragThreshold timeOut startTime nowTime evt timer |	dragThreshold := 10. "pixels before drag"	timeOut := 350. "double click time out"	startTime := Time millisecondClockValue.	(self handlesEvent: #dragStart) ifTrue:[		pos := aHand position.		evt := aHand forEach: #mouseMove do:[:event|			(aHand position dist: pos) > dragThreshold ifTrue:[				^self signal: #dragStart 					with: firstEvent with: self.			].		] until: #mouseUp.	] ifFalse:[evt := aHand waitUntil: #mouseUp].	(self containsPoint: self cursorPoint) ifFalse:[^self].	(self handlesEvent: #doubleClick) ifFalse:[		"If the player doesn't handle #doubleClick don't wait for #click to time out"		^self signal: #click				with: evt arguments first with: self.	].	nowTime := Time millisecondClockValue.	(nowTime - startTime) > timeOut ifTrue:[		"timeout after mouseUp -> click"		^self signal: #click				with: evt arguments first with: self.	].	"this is ugly... we should be able to wait on a delay but we aren't"	timer := self startScript:[		(Delay forMilliseconds: timeOut - (nowTime - startTime)) wait.		self signal: #doubleClickTimeout 			with: aHand lastEvent with: self.	].	evt := self waitUntilAnyOf: {		self. #mouseDown.		self. #doubleClickTimeout.	}.	self stopScript: timer.	evt selector == #mouseDown ifTrue:[		^self signal: #doubleClick			with: evt arguments first with: self.	] ifFalse:[		^self signal: #click			with: aHand lastEvent with: self.	].! !!CPrimitiveCostume methodsFor: 'keyboard events' stamp: 'ar 8/3/2004 17:21'!handleKeyDown: anEvent	"System level event handling."	| map event |	self isWorld ifTrue:[self pressedKeys add: anEvent keyValue].	anEvent wasHandled ifTrue:[^self].	(map := self keyDownMap) ifNotNil:[		event := map lookupEvent: anEvent.		event ifNotNil:[			anEvent wasHandled: true.			^self signal: event with: anEvent with: self.		].	].	(self handlesEvent: #keyDown) ifTrue:[		anEvent wasHandled: true.		self signal: #keyDown with: anEvent with: self	].! !!CPrimitiveCostume methodsFor: 'keyboard events' stamp: 'ar 8/3/2004 17:21'!handleKeyUp: anEvent	"System level event handling."	| map event |	self isWorld ifTrue:[self pressedKeys remove: anEvent keyValue ifAbsent:[]].	anEvent wasHandled ifTrue:[^self].	(map := self keyUpMap) ifNotNil:[		event := map lookupEvent: anEvent.		event ifNotNil:[			anEvent wasHandled: true.			^self signal: event with: anEvent with: self.		].	].	(self handlesEvent: #keyUp) ifTrue:[		anEvent wasHandled: true.		self signal: #keyUp with: anEvent with: self	].! !!CPrimitiveCostume methodsFor: 'keyboard events' stamp: 'ar 3/25/2004 20:08'!handleKeystroke: anEvent	"System level event handling."	| map event |	anEvent wasHandled ifTrue:[^self].	(map := self keyStrokeMap) ifNotNil:[		event := map lookupEvent: anEvent.		event ifNotNil:[			anEvent wasHandled: true.			^self signal: event with: anEvent with: self.		].	].	(self handlesEvent: #keyStroke) ifTrue:[		anEvent wasHandled: true.		self signal: #keyStroke with: anEvent with: self	].! !!CPrimitiveCostume methodsFor: 'keyboard events' stamp: 'ar 3/24/2004 01:23'!keyDownMap	^self propertyValueAt: #keyDownMap! !!CPrimitiveCostume methodsFor: 'keyboard events' stamp: 'ar 3/24/2004 01:23'!keyDownMap: aMap	^self propertyValueAt: #keyDownMap put: aMap! !!CPrimitiveCostume methodsFor: 'keyboard events' stamp: 'ar 3/24/2004 01:24'!keyStrokeMap	^self propertyValueAt: #keyStrokeMap! !!CPrimitiveCostume methodsFor: 'keyboard events' stamp: 'ar 3/24/2004 01:24'!keyStrokeMap: aMap	^self propertyValueAt: #keyStrokeMap put: aMap! !!CPrimitiveCostume methodsFor: 'keyboard events' stamp: 'ar 3/24/2004 01:23'!keyUpMap	^self propertyValueAt: #keyUpMap! !!CPrimitiveCostume methodsFor: 'keyboard events' stamp: 'ar 3/24/2004 01:24'!keyUpMap: aMap	^self propertyValueAt: #keyUpMap put: aMap! !!CPrimitiveCostume methodsFor: 'keyboard events' stamp: 'ar 3/24/2004 03:33'!onKeyDown: keySpec signal: eventName	"Signal the given event when the key specified by keySpec is pressed"	| map |	(map := self keyDownMap) ifNil:[		map := CKeyboardDispatchTable new.		self keyDownMap: map.	].	eventName ifNil:[		map remove: keySpec.		map isEmpty ifTrue:[self keyDownMap: nil].	] ifNotNil:[		map add: keySpec action: eventName.	].! !!CPrimitiveCostume methodsFor: 'keyboard events' stamp: 'ar 3/24/2004 03:33'!onKeyStroke: keySpec signal: eventName	"Signal the given event when the key specified by keySpec is pressed"	| map |	(map := self keyStrokeMap) ifNil:[		map := CKeyboardDispatchTable new.		self keyStrokeMap: map.	].	eventName ifNil:[		map remove: keySpec.		map isEmpty ifTrue:[self keyStrokeMap: nil].	] ifNotNil:[		map add: keySpec action: eventName.	].! !!CPrimitiveCostume methodsFor: 'keyboard events' stamp: 'ar 3/24/2004 03:33'!onKeyUp: keySpec signal: eventName	"Signal the given event when the key specified by keySpec is pressed"	| map |	(map := self keyUpMap) ifNil:[		map := CKeyboardDispatchTable new.		self keyUpMap: map.	].	eventName ifNil:[		map remove: keySpec.		map isEmpty ifTrue:[self keyUpMap: nil].	] ifNotNil:[		map add: keySpec action: eventName.	].! !!CPrimitiveCostume methodsFor: 'graphic' stamp: 'ar 9/4/2003 23:50'!aspectRatio	^self propertyValueAt: #aspectRatio ifAbsent:[nil].! !!CPrimitiveCostume methodsFor: 'graphic' stamp: 'ar 9/4/2003 23:36'!aspectRatio: newRatio	newRatio == nil		ifTrue:[self removeProperty: #aspectRatio]		ifFalse:[self propertyValueAt: #aspectRatio put: newRatio].	self localExtent: self localExtent. "so we keep the constraints accordingly"! !!CPrimitiveCostume methodsFor: 'graphic' stamp: 'ar 1/10/2003 20:55'!drawGraphic: aGraphic on: aCanvas in: drawingBounds	"Draw the receiver's texture"	aGraphic ifNil:[^self].	aCanvas clipBy: drawingBounds during:[:cc|		aGraphic drawOn: aCanvas in: drawingBounds.	].! !!CPrimitiveCostume methodsFor: 'graphic' stamp: 'ar 3/18/2003 22:45'!drawGraphicOn: aCanvas in: drawingBounds	"Draw the receiver's texture"	| aGraphic |	aGraphic := self graphic ifNil:[^self].	aCanvas clipBy: drawingBounds during:[:cc|		aGraphic drawOn: aCanvas in: drawingBounds.	].! !!CPrimitiveCostume methodsFor: 'graphic' stamp: 'ar 9/4/2003 23:43'!graphic	^self propertyValueAt: #graphic! !!CPrimitiveCostume methodsFor: 'graphic' stamp: 'ar 7/31/2004 18:32'!graphic: aGraphic	| myGraphic |	myGraphic := self graphic.	myGraphic == aGraphic ifTrue:[^self].	aGraphic ifNil:[		"Remove existing graphic"		self invalidate.		self removeProperty: #graphic.		flags := flags bitClear: FlagHasGraphic.		^self signal: #graphicChanged].	myGraphic ifNil:[		"Create new graphic"		myGraphic := CCostumeGraphic forCostume: self.		flags := flags bitOr: FlagHasGraphic.		self propertyValueAt: #graphic put: myGraphic	].	myGraphic loadFrom: aGraphic.	^aGraphic! !!CPrimitiveCostume methodsFor: 'highlights' stamp: 'ar 3/24/2004 02:00'!addHighlight: aHighlight	"Add the given highlight to the receiver's list of highlights.	propertyName describes the particular name of this highlight such as		* mouseDown, mouseOver, drop, grab (UI highlights)		* selection (widget highlights)		* dropShadow (static highlights)	"	| list priority index highlight aCostume |	(highlight := aHighlight) ifNil:[^self].	aCostume := highlight costume.	aCostume ifNotNil:[		aCostume == self ifFalse:[highlight := highlight copy].	].	self removeHighlight: highlight name.	highlight costume: self.	priority := highlight priority.	index := 1. "default insertion index"	list := self highlights.	"this should use binary search but I'm too lazy to do it now"	(list size = 0 or:[list first priority >= priority]) ifFalse:[		list last priority <= priority ifTrue:[index _ list size + 1].		index = 1 ifTrue:[ "e.g., above didn't work"			1 to: list size do:[:i|				(list at: i) priority < priority ifTrue:[index _ i+1]]]].	list := list copyWith: highlight before: index.	self highlights: list.	"Activate highlight if it is active"	highlight changed.	highlight isActive ifTrue:[highlight highlight].! !!CPrimitiveCostume methodsFor: 'highlights' stamp: 'ar 3/23/2004 21:16'!hasHighlight: propertyName	self highlights do:[:highlight|		highlight name = propertyName ifTrue:[^true]].	^false! !!CPrimitiveCostume methodsFor: 'highlights' stamp: 'ar 9/4/2003 23:50'!highlightBounds	"Return the bounds used for highlighting the receiver"	^self propertyValueAt: #highlightBounds ifAbsent:[self localBounds]! !!CPrimitiveCostume methodsFor: 'highlights' stamp: 'ar 9/4/2003 23:37'!highlightBounds: newBounds	"Set the bounds used for highlighting the receiver"	newBounds == nil		ifTrue:[self removeProperty: #highlightBounds]		ifFalse:[self propertyValueAt: #highlightBounds put: newBounds].! !!CPrimitiveCostume methodsFor: 'highlights' stamp: 'ar 3/23/2004 21:17'!highlightNamed: propertyName	self highlights do:[:highlight|		highlight name = propertyName ifTrue:[^highlight]].	^nil! !!CPrimitiveCostume methodsFor: 'highlights' stamp: 'ar 9/24/2003 16:46'!highlights	"Return all the highlights of the receiver"	^self propertyValueAt: #highlights ifAbsent:[#()]! !!CPrimitiveCostume methodsFor: 'highlights' stamp: 'ar 9/4/2003 23:37'!highlights: anArray	"Install all the highlights of the receiver"	self invalidate.	(anArray == nil or:[anArray isEmpty]) 		ifTrue:[self removeProperty: #highlights.				flags := flags bitClear: FlagHasHighlights]		ifFalse:[self propertyValueAt: #highlights put: anArray.				flags := flags bitOr: FlagHasHighlights].	self invalidateLayout.	self invalidate.! !!CPrimitiveCostume methodsFor: 'highlights' stamp: 'ar 3/24/2004 02:03'!removeHighlight: name	"Remove the given highlight from the list of highlights.	Either aHighlight or propertyName may be nil."	| list drop anyDropped |	anyDropped := false.	list := self highlights reject:[:highlight|		drop := false.		drop := highlight name = name.		(drop and:[highlight isActive]) ifTrue:[			highlight unhighlight.			highlight costume: nil.		].		drop ifTrue:[anyDropped := true].		drop].	anyDropped ifTrue:[self highlights: list].! !!CPrimitiveCostume methodsFor: 'collision detection' stamp: 'ar 3/23/2003 22:56'!boxCollisionPairs	^Array streamContents:[:s|		self boxCollisionPairsDo:[:a1 :a2|			s nextPut: (Array with: a1 value player with: a2 value player).		].	].! !!CPrimitiveCostume methodsFor: 'collision detection' stamp: 'ar 3/23/2004 23:49'!boxCollisionPairsDo: aBlock	| count sorted box objectA boxA j continue objectB boxB |	sorted := Array new: contents size.	count := 0.	contents do:[:aCostume|		aCostume collisionsEnabled ifTrue:[			box := aCostume fullBounds.			sorted at: (count := count + 1) put: (Association key: box value: aCostume).		].	].	count = 0 ifTrue:[^#()].	sorted mergeSortFrom: 1 		to: count 		src: (sorted copyFrom: 1 to: count)		dst: sorted		by:[:a1 :a2| a1 key left <= a2 key left].	1 to: count-1 do:[:i|		objectA := sorted at: i.		boxA := objectA key.		j := i.		continue := true.		[continue and:[(j := j+1) <= count]] whileTrue:[			objectB := sorted at: j.			boxB := objectB key.			continue := boxB left < boxA right.			continue ifTrue:[				(boxA bottom <= boxB top or:[boxB bottom <= boxA top]) ifFalse:[					aBlock value: objectA value: objectB.				].			].		].	].! !!CPrimitiveCostume methodsFor: 'collision detection' stamp: 'ar 3/23/2003 23:24'!collisionPairs	^Array streamContents:[:s|		self collisionPairsDo:[:a1 :a2|			s nextPut: (Array with: a1 value player with: a2 value player).		].	].! !!CPrimitiveCostume methodsFor: 'collision detection' stamp: 'ar 3/23/2003 23:57'!collisionPairsDo: aBlock	"this method makes a fine-grained distinction between the colliding objects actually checking the outlines"	| collide formA formB rect costumeA preciseA costumeB preciseB pixels |	formA := formB := nil.	self boxCollisionPairsDo:[:a1 :a2|		rect := a1 key intersect: a2 key.		costumeA := a1 value.		preciseA := costumeA preciseCollisions.		costumeB := a2 value.		preciseB := costumeB preciseCollisions.		preciseA ifTrue:[			(formA notNil and:[formA extent >= rect extent]) 				ifFalse:[formA := Form extent: rect extent depth: 1].			(CTransformCanvas on: formA) translateBy: rect origin negated during:[:cc|				cc clipBy: rect during:[:clipped|					clipped shadowColor: Color black.					a1 value fullDrawOn: clipped.				].			].		].		preciseB ifTrue:[			(formB notNil and:[formB extent >= rect extent]) 				ifFalse:[formB := Form extent: rect extent depth: 1].			(CTransformCanvas on: formB) translateBy: rect origin negated during:[:cc|				cc clipBy: rect during:[:clipped|					clipped shadowColor: Color black.					a2 value fullDrawOn: clipped.				].			].		].		preciseA ifTrue:[			preciseB ifTrue:[				(BitBlt toForm: formA)					sourceForm: formB;					width: rect width; height: rect height;					combinationRule: Form and;					copyBits.			].			pixels := formA tallyPixelValuesInRect: (0@0 extent: rect extent) 							into: (Bitmap new: 2).			collide := (pixels at: 2) > 0.		] ifFalse:[			preciseB ifTrue:[				pixels := formB tallyPixelValuesInRect: (0@0 extent: rect extent) 								into: (Bitmap new: 2).				collide := (pixels at: 2) > 0.			] ifFalse:[collide := true].		].		collide ifTrue:[aBlock value: a1 value player value: a2 value player].	].! !!CPrimitiveCostume methodsFor: 'collision detection' stamp: 'ar 3/23/2004 23:49'!collisionsEnabled	^self propertyValueAt: #collisionsEnabled ifAbsent:[false]! !!CPrimitiveCostume methodsFor: 'collision detection' stamp: 'ar 3/23/2004 23:49'!collisionsEnabled: aBool	^self propertyValueAt: #collisionsEnabled put: aBool! !!CPrimitiveCostume methodsFor: 'collision detection' stamp: 'ar 3/23/2003 23:33'!preciseCollisions	^self propertyValueAt: #preciseCollisions ifAbsent:[false]! !!CPrimitiveCostume methodsFor: 'collision detection' stamp: 'ar 3/23/2003 23:33'!preciseCollisions: aBool	^self propertyValueAt: #preciseCollisions put: aBool! !!CPrimitiveCostume methodsFor: 'serialization' stamp: 'tk 7/14/2004 11:27'!postBuildWith: aMaker	contents := contents collect:[:x| x asPrimCostume].	contents do:[:cc|		cc ifNil:[contents := contents reject:[:any| any == nil]]		ifNotNil:[cc setContainer: self]].	fill = DefaultFill ifTrue:[fill := CNoFill forCostume: self].	border = DefaultBorder ifTrue:[border := CNoBorder forCostume: self].	fill costume: self.	border costume: self.	self graphic ifNotNil:[		self graphic costume: self.		flags := flags bitOr: FlagHasGraphic.	].	self textHolder ifNotNil:[		self textHolder costume: self.		flags := flags bitOr: FlagHasText.	].	self highlights size = 0 ifFalse:[		flags := flags bitOr: FlagHasHighlights.	].! !!CPrimitiveCostume methodsFor: 'serialization' stamp: 'ar 3/29/2004 14:54'!readFieldsFrom: deserializer	| v origin extent |	self initialize.	"basic"	origin := deserializer readField: #origin ifAbsent:[bounds origin].	extent := deserializer readField: #extent ifAbsent:[bounds extent].	bounds := origin extent: extent.	fill := deserializer readField: #fill ifAbsent:[fill].	border := deserializer readField: #border ifAbsent:[border].	contents := deserializer readField: #contents.	self player: (deserializer readField: #player).	"flags"	v := deserializer readField: #hidden ifAbsent:[self hidden].	v ifNotNil:[self hidden: v].	v := deserializer readField: #userDraw ifAbsent:[self userDraw].	v ifNotNil:[self userDraw: v].	v := deserializer readField: #locked ifAbsent:[self locked].	v ifNotNil:[self locked: v].	v := deserializer readField: #cacheEnabled ifAbsent:[self cacheEnabled].	v ifNotNil:[self cacheEnabled: v].	v := deserializer readField: #clipEnabled ifAbsent:[self clipping].	v ifNotNil:[self clipping: v].	v := deserializer readField: #roundCorners ifAbsent:[self roundCorners].	v ifNotNil:[self roundCorners: v].	v := deserializer readField: #hasScroller ifAbsent:[false].	self setFlag: FlagHasScroller value: v.	"flags := 0.	1 to: FlagRegistry size do:[:bit|		flagBit := 1 bitShift: bit-1.		flagName := FlagRegistry at: bit.		flagName ifNotNil:[			v := deserializer readField: flagName ifAbsent:[flags anyMask: flagBit].			v ifNotNil:[				v == true 					ifTrue:[flags := flags bitOr: flagBit]					ifFalse:[flags := flags bitClear: flagBit].			].		].	]."	self serializableFields do:[:fieldName|		v := deserializer readField: fieldName ifAbsent:[nil].		v ifNotNil:[self propertyValueAt: fieldName put: v].	].! !!CPrimitiveCostume methodsFor: 'serialization' stamp: 'ar 3/24/2004 14:21'!serializableFields	^#(		transform 		shape 		roundedCorners 		aspectRatio 		graphic		highlights		overlay 		mouseCursor		textHolder		textAnchorType		scrollOffset		scrollingDisabled		layoutProperties		layout		layoutFrame		minWidth		minHeight		floating		infinite		collisionsEnabled		sticky		isWorld		resizable		preciseCollisions		balloonHelp	).! !!CPrimitiveCostume methodsFor: 'serialization' stamp: 'ar 2/25/2004 16:18'!serializeOn: aSerializer	^aSerializer writeCostume: self! !!CPrimitiveCostume methodsFor: 'serialization' stamp: 'ar 3/14/2004 15:55'!setFlag: flagBit value: aBool	aBool ifNil:[^self].	flags := aBool ifTrue:[flags bitOr: flagBit] ifFalse:[flags bitClear: flagBit].! !!CPrimitiveCostume methodsFor: 'serialization' stamp: 'ar 3/22/2004 02:34'!writeContentsOn: aSerializer	| aPlayer |	^aSerializer writeField: #contents value: (contents collect:[:each| 		aPlayer := each player.		[aPlayer player notNil and:[aPlayer player getCostume == aPlayer]]			whileTrue:[aPlayer := aPlayer player].		aPlayer]).! !!CPrimitiveCostume methodsFor: 'serialization' stamp: 'ar 3/29/2004 14:54'!writeFieldsOn: aSerializer	"basic"	aSerializer writeField: #origin value: bounds origin.	aSerializer writeField: #extent value: bounds extent.	aSerializer writeField: #fill value: fill.	aSerializer writeField: #border value: border.	aSerializer writeField: #player value: self player.	self writeContentsOn: aSerializer.	"aSerializer writeField: #contents value: contents."	"flags"	aSerializer writeField: #hidden value: (flags anyMask: FlagHidden).	aSerializer writeField: #userDraw value: (flags anyMask: FlagCustomDraw).	aSerializer writeField: #locked value: (flags anyMask: FlagLocked).	aSerializer writeField: #cacheEnabled value: (flags anyMask: FlagCached).	aSerializer writeField: #clipEnabled value: (flags anyMask: FlagClipEnabled).	aSerializer writeField: #roundCorners value: (flags anyMask: FlagRoundedCorners).	aSerializer writeField: #hasScroller value: (flags anyMask: FlagHasScroller).	"1 to: FlagRegistry size do:[:bit|		flagBit := 1 bitShift: bit-1.		flagName := FlagRegistry at: bit.		flagName ifNotNil:[			(flags bitAnd: flagBit) = 0 ifFalse:[				aSerializer writeField: flagName value: true.			].		].	]."	self serializableFields do:[:fieldName|		aSerializer writeField: fieldName value: (self propertyValueAt: fieldName).	].! !!CPrimitiveCostume methodsFor: 'converting' stamp: 'tk 7/14/2004 11:31'!asCostume	"*** Later remove all implementor of asCostume ***"	self inform: 'Please call asPrimCostume instead of asCostume'.	^self! !!CPrimitiveCostume methodsFor: 'converting' stamp: 'ar 12/16/2002 17:22'!asForm	"Convert me into a form"	^self asFormOfDepth: Display depth! !!CPrimitiveCostume methodsFor: 'converting' stamp: 'ar 12/16/2002 17:34'!asFormExtent: maxExtent	"Convert me into a form of at most maxExtent size.	Scale the receiver to fit that extent if needed."	^self asFormOfDepth: Display depth extent: maxExtent! !!CPrimitiveCostume methodsFor: 'converting' stamp: 'ar 12/16/2002 17:27'!asFormOfDepth: depth	"Convert me into a form"	| box form canvas |	box := self localFullBounds.	form := Form extent: box extent depth: depth.	canvas := CTransformCanvas on: form.	canvas translateBy: box origin negated during:[:cc|		self localFullDrawOn: cc.	].	^form! !!CPrimitiveCostume methodsFor: 'converting' stamp: 'ar 12/16/2002 17:33'!asFormOfDepth: depth extent: maxExtent	"Convert me into a form of at most maxExtent size.	Scale the receiver to fit that extent if needed."	| form size thumb |	form := self asFormOfDepth: depth.	form extent <= maxExtent ifTrue:[^form].	size := form extent.	size y > maxExtent y 		ifTrue:[size := (size x * maxExtent y // size y) @ maxExtent y].	size x > maxExtent x 		ifTrue:[size := maxExtent x @ (size y * maxExtent x // size x)].	thumb := Form extent: size depth: depth.	form displayScaledOn: thumb.	^thumb! !!CPrimitiveCostume methodsFor: 'converting' stamp: 'ar 3/24/2004 03:16'!asPlayer	^(self player ifNil:[CPlayer new costume: self]) asPlayer.! !!CPrimitiveCostume methodsFor: 'converting' stamp: 'tk 7/14/2004 11:20'!asPrimCostume	^self! !!CPrimitiveCostume methodsFor: 'properties'!hasProperty: propName	"Answer whether the receiver has the given property.  Deemed to have it only if I have a property dictionary entry for it and that entry is neither nil nor false"	^properties ifNil:[false] ifNotNil:[properties includesKey: propName]! !!CPrimitiveCostume methodsFor: 'properties' stamp: 'ar 9/4/2003 23:50'!propertyValueAt: propName	^self propertyValueAt: propName ifAbsent:[nil]! !!CPrimitiveCostume methodsFor: 'properties' stamp: 'ar 9/4/2003 23:51'!propertyValueAt: propName ifAbsent: aBlock	^properties ifNil:[aBlock value] ifNotNil:[properties at: propName ifAbsent: aBlock].! !!CPrimitiveCostume methodsFor: 'properties' stamp: 'ar 9/9/2003 15:35'!propertyValueAt: propName ifAbsentPut: aBlock	properties ifNil:[^self propertyValueAt: propName put: aBlock value].	^properties at: propName ifAbsentPut: aBlock! !!CPrimitiveCostume methodsFor: 'properties' stamp: 'ar 9/4/2003 23:42'!propertyValueAt: propName put: aValue	aValue ifNil: [^self removeProperty: propName].	properties ifNil:[properties := IdentityDictionary new].	properties at: propName put: aValue.	^aValue! !!CPrimitiveCostume methodsFor: 'properties' stamp: 'ar 3/10/2003 07:47'!removeProperty: propName	| old |	properties ifNotNil:[		old := properties removeKey: propName ifAbsent:[].		properties isEmpty ifTrue:[properties := nil].	].	^old! !!CPrimitiveCostume methodsFor: 'initialize' stamp: 'ar 1/19/2003 02:41'!close	"Close this costume"	container ifNotNil:[container remove: self].! !!CPrimitiveCostume methodsFor: 'initialize' stamp: 'ar 2/24/2004 00:43'!destroy	"Dump the receiver"	| cc |	self close.	(cc := self player) ifNotNil:[		self player: nil.		cc destroy].! !!CPrimitiveCostume methodsFor: 'initialize' stamp: 'ar 3/23/2004 17:17'!initialize	bounds ifNil:[bounds _ 0@0 corner: 50@40].	contents ifNil:[contents _ #()].	fill ifNil:[fill := CNoFill forCostume: self].	border ifNil:[border := CNoBorder forCostume: self].	flags ifNil:[flags := 0].! !!CPrimitiveCostume methodsFor: 'initialize' stamp: 'ar 7/28/2004 21:49'!intoWorld: aWorld	"This costume has just appeared in a new world. Note:		* aWorld can be nil (due to optimizations in other places)		* owner is already set		* owner's children may not include receiver yet.	Important: Keep this method fast - it is run whenever objects are added."	aWorld ifNil:[^self].	self resumeTickingScripts.	self signal: #opened with: aWorld.	self signal: #open with: aWorld.	contents do:[:m| m intoWorld: aWorld].! !!CPrimitiveCostume methodsFor: 'initialize' stamp: 'ar 7/28/2004 21:48'!outOfWorld: aWorld	"The receiver has just appeared in a new world. Notes:		* aWorld can be nil (due to optimizations in other places)		* owner is still valid	Important: Keep this method fast - it is run whenever objects are removed."	aWorld ifNil:[^self].	contents do:[:m| m outOfWorld: aWorld].	self signal: #closed with: aWorld.	self signal: #close with: aWorld.	self cacheEnabled ifTrue:[self localCache release].	self suspendTickingScripts.! !!CPrimitiveCostume methodsFor: 'initialize' stamp: 'ar 7/28/2004 22:52'!resumeTickingScripts	"Resume all ticking scripts for the receiver and its costume."	| aPlayer |	aPlayer := self asPlayer.	[aPlayer == nil] whileFalse:[		aPlayer myScripts do:[:each| each isTickingScript ifTrue:[each resumeScript]].		aPlayer := aPlayer getCostume.	].! !!CPrimitiveCostume methodsFor: 'initialize' stamp: 'ar 7/28/2004 22:52'!suspendTickingScripts	"Suspend all ticking scripts for the receiver and its costume."	| aPlayer |	aPlayer := self asPlayer.	[aPlayer == nil] whileFalse:[		aPlayer myScripts do:[:each| each isTickingScript ifTrue:[each pauseScript]].		aPlayer := aPlayer getCostume.	].! !!CPrimitiveCostume methodsFor: 'removing' stamp: 'ar 2/12/2003 22:24'!remove: aCostume	"Remove oldObject from the receiver's elements."	^self remove: aCostume ifAbsent:[]! !!CPrimitiveCostume methodsFor: 'removing' stamp: 'ar 2/12/2003 22:24'!remove: aCostume ifAbsent: aBlock	"Remove oldObject from the receiver's elements."	aCostume container == self ifFalse:[^aBlock value].	aCostume outOfWorld: self world.	self privateRemove: aCostume.	aCostume setContainer: nil.! !!CPrimitiveCostume methodsFor: 'removing' stamp: 'ar 2/25/2004 20:06'!removeAll	"Remove all the contents of the receiver"	| world |	self invalidate.	world := self world.	contents do:[:aCostume|		aCostume outOfWorld: world.		aCostume setContainer: nil.	].	contents := #().	self invalidateLayout.	self structureChanged.! !!CPrimitiveCostume methodsFor: 'removing' stamp: 'ar 2/12/2003 22:24'!removeAll: aCollection	"Remove all the elements found in aCollection"	aCollection do:[:each| self remove: each].! !!CPrimitiveCostume methodsFor: 'removing' stamp: 'ar 6/28/2003 21:52'!removeAt: index	"Remove oldObject from the receiver's elements."	^self remove: (self at: index) ifAbsent:[]! !!CPrimitiveCostume methodsFor: 'removing' stamp: 'ar 7/3/2003 15:32'!removeFrom: firstIndex to: lastIndex	"Remove oldObject from the receiver's elements."	firstIndex to: lastIndex do:[:i| self removeAt: firstIndex].! !!CPrimitiveCostume methodsFor: 'removing' stamp: 'ar 4/3/2003 17:43'!removeLast	self remove: contents last! !!CPrimitiveCostume methodsFor: 'pen support' stamp: 'ar 12/7/2002 19:52'!assurePen	self pen: CCostumePen new.! !!CPrimitiveCostume methodsFor: 'pen support'!hasPen	^self hasProperty: #pen! !!CPrimitiveCostume methodsFor: 'pen support' stamp: 'ar 9/4/2003 23:50'!indicatePenTrails	^self propertyValueAt: #indicatePenTrails ifAbsent:[false]! !!CPrimitiveCostume methodsFor: 'pen support' stamp: 'ar 9/4/2003 23:37'!indicatePenTrails: aBool	self propertyValueAt: #indicatePenTrails put: aBool.! !!CPrimitiveCostume methodsFor: 'pen support'!isPenDown	self hasPen ifFalse:[^false].	^self pen isDown! !!CPrimitiveCostume methodsFor: 'pen support' stamp: 'ar 12/8/2003 19:42'!isPenDown: aBool	aBool ifTrue:[		self assurePen.		container ifNotNil:[container indicatePenTrails: true]].	self hasPen ifFalse:[^self].	self pen isDown: aBool.! !!CPrimitiveCostume methodsFor: 'pen support' stamp: 'ar 9/4/2003 23:43'!pen	^self propertyValueAt: #pen! !!CPrimitiveCostume methodsFor: 'pen support' stamp: 'ar 9/4/2003 23:40'!pen: aPen	self propertyValueAt: #pen put: aPen.! !!CPrimitiveCostume methodsFor: 'pen support' stamp: 'ar 12/7/2002 19:52'!penColor	^self hasPen ifTrue:[self pen color] ifFalse:[CCostumePen defaultColor].! !!CPrimitiveCostume methodsFor: 'pen support' stamp: 'ar 12/7/2002 19:52'!penColor: aColor	aColor = CCostumePen defaultColor ifFalse:[self assurePen].	self hasPen ifFalse:[^self].	self pen color: aColor! !!CPrimitiveCostume methodsFor: 'pen support'!penPosition	^self transform transformPoint: self rotationCenter! !!CPrimitiveCostume methodsFor: 'pen support' stamp: 'ar 12/7/2002 19:52'!penWidth	^self hasPen ifTrue:[self pen width] ifFalse:[CCostumePen defaultWidth].! !!CPrimitiveCostume methodsFor: 'pen support' stamp: 'ar 12/7/2002 19:52'!penWidth: aNumber	aNumber = CCostumePen defaultWidth ifFalse:[self assurePen].	self hasPen ifFalse:[^self].	self pen width: aNumber! !!CPrimitiveCostume methodsFor: 'tweaking' stamp: 'ar 2/27/2004 19:35'!readTweakedFieldsFrom: deSerializer	"FIXME!!!!!!"	| oldValue newValue |	deSerializer fieldsDo:[:fieldName|		oldValue := self perform: fieldName.		newValue := deSerializer tweakField: fieldName value: oldValue.		(newValue equals: oldValue) ifFalse:[			self perform: (fieldName,':') asSymbol with: newValue.			self tweaked: fieldName from: oldValue to: newValue.		].	].! !!CPrimitiveCostume methodsFor: 'tweaking' stamp: 'ar 2/27/2004 20:02'!tweaked: propName from: oldValue to: newValue	"Remember the change of the given property from its previous to its new value.	Answer true if the receiver is newly changed or reverted back to unchanged."	(super tweaked: propName from: oldValue to: newValue) ifFalse:[^false].	self player tweakedCostume: self.	^true! !!CPrimitiveCostume methodsFor: 'tweaking' stamp: 'ar 2/27/2004 18:35'!tweaks	"Answer the changes associated with the receiver"	^self propertyValueAt: #myTweaks! !!CPrimitiveCostume methodsFor: 'tweaking' stamp: 'ar 2/27/2004 18:36'!tweaks: aDictionary	"Set the changes associated with the receiver"	^self propertyValueAt: #myTweaks put: aDictionary! !!CPrimitiveCostume methodsFor: 'tweaking' stamp: 'ar 2/27/2004 18:40'!writeTweakedFieldsOn: aSerializer	"FIXME!!!!!!"	| changeList newValue |	changeList := self tweaks ifNil:[#()].	changeList keysAndValuesDo:[:fieldName :chgRec|		fieldName == #contents ifTrue:[			self writeContentsOn: aSerializer.		] ifFalse:[			newValue := self perform: fieldName.			aSerializer writeField: fieldName value: newValue.		].	].! !!CPrimitiveCostume methodsFor: 'other' stamp: 'ar 3/24/2004 03:17'!align: aPoint1 with: aPoint2	"Translate by aPoint2 - aPoint1."	^self moveBy: (aPoint2 - aPoint1)! !!CPrimitiveCostume methodsFor: 'other' stamp: 'ar 4/2/2004 14:17'!colorAt: aPoint behind: aPlayer	"Answer the color of the receiver at the given point"	| aForm aCanvas rect pv index |	aPlayer		ifNil:[index := contents size] "don't bother searching"		ifNotNil:[index := (self indexOf: aPlayer costume) - 1].	rect := aPoint-1 extent: 3@3.	aForm := Form extent: 3@3 depth: 32. "always pick in 32bpp"	aCanvas := CTransformCanvas on: aForm.	aCanvas translateBy: rect origin negated.	aCanvas clipBy: rect.	self topDownFullDrawOn: aCanvas 		damageList: (Array with: rect) 		dirtyRect: aCanvas clipRect 		startingAt: index.	aCanvas finish.	pv := aForm bits at: 5.	pv = 0 ifTrue:[^Color transparent].	^Color colorFromPixelValue: (pv bitOr: 16rFF000000) depth: 32! !!CPrimitiveCostume methodsFor: 'other' stamp: 'ar 4/2/2004 15:00'!comeToFront	container ifNotNil:[container add: self].! !!CPrimitiveCostume methodsFor: 'other' stamp: 'ar 3/24/2004 03:19'!cursorPoint	"Answer the active's hand position in local coordinates"	^self globalToLocal: self hand position! !!CPrimitiveCostume methodsFor: 'other' stamp: 'ar 3/24/2004 03:19'!deselect	"Deselect the receiver"! !!CPrimitiveCostume methodsFor: 'other' stamp: 'ar 3/24/2004 03:14'!disable	| highlight |	highlight := CFillingHighlight new.	highlight name: #disableHighlight.	highlight fill: (Color black alpha: 0.3).	self addHighlight: highlight.	self locked: true.! !!CPrimitiveCostume methodsFor: 'other' stamp: 'ar 3/24/2004 03:14'!enable	self removeHighlight: #disableHighlight.	self locked: false.! !!CPrimitiveCostume methodsFor: 'other' stamp: 'ar 4/2/2004 14:18'!findPlayerAt: aPoint	"Search the receiver to find the first player located at the given position."	| aCostume |	contents size to: 1 by: -1 do:[:i|		aCostume := contents at: i.		(aCostume fullContainsPoint: aPoint) ifTrue:[^aCostume player].	].	^nil! !!CPrimitiveCostume methodsFor: 'other' stamp: 'ar 4/2/2004 15:01'!goBehind	container addFirst: self.! !!CPrimitiveCostume methodsFor: 'other' stamp: 'ar 3/24/2004 03:16'!grabMe	self hand attach: self.! !!CPrimitiveCostume methodsFor: 'other' stamp: 'ar 3/24/2004 03:13'!moveDownLayer	container add: self at: (container indexOf: self) + 1! !!CPrimitiveCostume methodsFor: 'other' stamp: 'ar 3/24/2004 03:13'!moveUpLayer	container add: self at: (container indexOf: self) - 1! !!CPrimitiveCostume methodsFor: 'other' stamp: 'ar 3/24/2004 03:23'!select	"Select the receiver"! !!CPrimitiveCostume methodsFor: 'other' stamp: 'ar 3/24/2004 03:24'!windowColor: aColor	(border width > 0 and:[border color isTransparent not])		ifTrue:[border color: aColor].! !!CPrimitiveCostume methodsFor: 'move/resize/scale'!forwardBy: distance	^self forwardBy: 5 duration: 0 style: #gently! !!CPrimitiveCostume methodsFor: 'move/resize/scale'!localTransformBy: aTransform	self transform: (aTransform transformedBy: self transform)! !!CPrimitiveCostume methodsFor: 'move/resize/scale'!move: direction duration: aDuration	^self move: direction distance: 1 duration: aDuration style: #gently! !!CPrimitiveCostume methodsFor: 'move/resize/scale' stamp: 'ar 12/8/2003 19:42'!moveBy: delta	| box oldRect newRect suppressed |	delta isZero ifTrue:[^self].	box := self invalidationBounds.	oldRect := self childToParent transformRect: box.	suppressed := self invalidationSuppressed.	self invalidationSuppressed: true.	self transform: ((COffsetTransform withOffset: delta) composedWithLocal: self transform).	self invalidationSuppressed: suppressed.	container ifNil:[^self].	newRect := self childToParent transformRect: box.	suppressed ifFalse:[container privateBltMove: self from: oldRect to: newRect].! !!CPrimitiveCostume methodsFor: 'move/resize/scale' stamp: 'ar 3/9/2004 12:06'!moveBy: delta duration: duration	"Move the receiver by delta over the given duration"	^self moveTo: self referencePosition + delta duration: duration! !!CPrimitiveCostume methodsFor: 'move/resize/scale'!moveTo: aPoint	self moveBy: aPoint - self position.! !!CPrimitiveCostume methodsFor: 'move/resize/scale'!moveTo: target duration: duration	"Move the receiver to match its reference position with the given reference position"	| lastTime nowTime myPos itsPos delta startTime myStart itsStart |	duration <= 0 ifTrue:[		^self moveBy: target referencePosition - self referencePosition].	startTime _ lastTime _ Time millisecondClockValue.	myStart _ self referencePosition.	itsStart _ target referencePosition.	self clock forEach: #tick do:[		nowTime _ Time millisecondClockValue.		(nowTime - startTime * 0.001) >= duration ifTrue:[			^self moveTo: target referencePosition duration: 0.		].		itsPos _ target referencePosition.		(itsPos = itsStart) ifTrue:[			"Simple case since 'it' has not moved"			delta _ nowTime - startTime * 0.001 / duration.			self moveTo: myStart + (itsStart - myStart * delta) duration: 0.		] ifFalse:[			"Tricky case - 'it' has moved so adjust our strategy."			myPos _ self referencePosition.			delta _ nowTime - lastTime * 0.001 / (duration - (lastTime - startTime * 0.001)).			self moveTo: myPos + (itsPos - myPos * delta) duration: 0.		].		lastTime _ nowTime.	].! !!CPrimitiveCostume methodsFor: 'move/resize/scale'!moveTo: aReferenceObject speed: speed	"Move the receiver to match its reference position with the given reference position"	| mySpeed lastTime nowTime distance myPos itsPos direction delta |	lastTime _ Time millisecondClockValue.	self clock forEach: #tick do:[		nowTime _ Time millisecondClockValue.		mySpeed _ speed ifNil:[self speed].		distance _ (nowTime - lastTime) * mySpeed * 0.001. "dealing with msecs here"		myPos _ self referencePosition.		itsPos _ aReferenceObject referencePosition.		(myPos dist: itsPos) <= distance ifTrue:[ "done"			self referencePosition: itsPos.			^self].		direction _ (itsPos - myPos) normalized.		delta _ direction * distance.		self moveBy: delta.		lastTime _ nowTime.	].! !!CPrimitiveCostume methodsFor: 'move/resize/scale' stamp: 'ar 3/29/2003 18:27'!resizeTo: extentPoint	"Resize the receiver to match the given (global) extent"	| tfm oldBox origin corner relOrigin relCorner |	tfm := self childToParent.	tfm isPureTranslation 		ifTrue:[^self localExtent: extentPoint].	"TODO: This doesn't work"	"If our transform is not a pure translation we must inscribe a local rectangle into the global one defined by our (global) origin and the given extent point."	oldBox := self bounds.	origin := tfm transformPoint: self localBounds origin.	corner := tfm transformPoint: self localBounds corner.	"origin and corner are on some border of oldBox; compute its relative position"	[		relOrigin := (origin - oldBox origin) / oldBox extent.		relCorner := (corner - oldBox corner) / oldBox extent.	] on: ZeroDivide do:[:ex| ex resume: ex dividend].	"map origin and corner into the new extent"	origin := oldBox origin + (relOrigin * extentPoint).	corner := oldBox origin + (relCorner * extentPoint).	"transform them back into local frame"	origin := tfm invertPoint: origin.	corner := tfm invertPoint: corner.	"set our new local bounds"	"self localBounds: (origin corner: corner)."	self localExtent: corner - origin.! !!CPrimitiveCostume methodsFor: 'move/resize/scale' stamp: 'ar 12/7/2002 22:15'!rotateBy: degrees	| tfm refPos |	refPos _ self rotationCenter.	tfm _ COffsetTransform withOffset: refPos.	tfm _ tfm composedWithLocal: (CMatrixTransform withAngle: degrees).	tfm _ tfm composedWithLocal: (COffsetTransform withOffset: refPos negated).	self localTransformBy: tfm! !!CPrimitiveCostume methodsFor: 'move/resize/scale' stamp: 'ar 4/6/2003 00:35'!scaleBy: scale	"Scale the receiver"	| tfm refPos scaleX scaleY |	scaleX := scale asPoint x.	scaleY := scale asPoint y.	(scaleX = 1 and:[scaleY = 1]) ifTrue:[^self].	(scaleX > -1.0e-3 and:[scaleX < 1.0e-3]) 		ifTrue:[scaleX := 1].	(scaleY > -1.0e-3 and:[scaleY < 1.0e-3]) 		ifTrue:[scaleY := 1].	refPos _ self rotationCenter.	tfm _ COffsetTransform withOffset: refPos.	tfm _ tfm composedWithLocal: (CMatrixTransform withScale: scaleX@scaleY).	tfm _ tfm composedWithLocal: (COffsetTransform withOffset: refPos negated).	self localTransformBy: tfm! !!CPrimitiveCostume methodsFor: 'move/resize/scale' stamp: 'ar 12/7/2002 22:14'!scaleTo: aPoint	"Scale the receiver to match the given extent"	| x y |	x _ self width.	(x > -1 and:[x < 1]) ifTrue:[x _ 1].	y _ self height.	(y > -1 and:[x < 1]) ifTrue:[y _ 1].	self localTransformBy: (CMatrixTransform withScale: aPoint / (x@y))! !!CPrimitiveCostume methodsFor: 'move/resize/scale'!transformBy: aTransform	self transform: (self transform transformedBy: aTransform)! !!CPrimitiveCostume methodsFor: 'move/resize/scale' stamp: 'ar 3/28/2004 16:10'!turnBy: angle	self rotateBy: angle asNumber.! !!CPrimitiveCostume methodsFor: 'move/resize/scale'!turnBy: turns speed: speed! !!CPrimitiveCostume methodsFor: 'primitive behaviors' stamp: 'ar 3/24/2004 03:11'!abruptly: x	x > 1.0 ifTrue:[^1.0] ifFalse:[^x]! !!CPrimitiveCostume methodsFor: 'primitive behaviors'!forwardBy: distance duration: duration style: style	^self move: #forward distance: distance duration: duration style: style! !!CPrimitiveCostume methodsFor: 'primitive behaviors' stamp: 'ar 3/24/2004 03:11'!gently: x lowerBound: lower upperBound: upper	"This method converts a linear proportion done to a slow in - slow out proportion. If x is less than A then the animation is in the slow in part, while if x is greater than B then the animation is in the slow out part."	| a3 b3 c3 m b2 |	x > 1.0 ifTrue:[^1.0].  	(x < lower) ifTrue: [ 		^((upper - 1)/(lower *  ((upper * upper) - (lower * upper) + lower - 1))) * x * x	].	(x > upper) ifTrue: [		a3 _ 1 / ((upper * upper) - (lower * upper) + lower - 1).		b3 _ -2 * a3.		c3 _ 1 + a3.  		^(a3 * x * x) + (b3 * x) + c3.	].	m _ 2 * (upper - 1) / ((upper * upper) - (lower * upper) + lower - 1).	b2 _ (0 - m) * lower / 2.	^m * x + b2.! !!CPrimitiveCostume methodsFor: 'primitive behaviors'!headingFor: aDirection	| fwd |	fwd := (self transform transformDirection: 0@-1) normalized.	aDirection == #forward ifTrue:[^0@-1].	aDirection == #back ifTrue:[^fwd negated].	fwd := fwd y @ fwd x negated.	aDirection == #left ifTrue:[^fwd].	aDirection == #right ifTrue:[^fwd negated].	self error:'No such direction: ', aDirection.! !!CPrimitiveCostume methodsFor: 'primitive behaviors' stamp: 'ar 3/24/2004 03:11'!interpolationForStyle: aStyle	aStyle == #gently ifTrue:[		^[:x| self gently: x lowerBound: 0.3 upperBound: 0.8].	].	^[:x| self abruptly: x]! !!CPrimitiveCostume methodsFor: 'primitive behaviors'!move	^self move: #forward distance: 10 duration: 1 style: #gently! !!CPrimitiveCostume methodsFor: 'primitive behaviors'!move: direction	^self move: direction distance: 10 duration: 1 style: #gently! !!CPrimitiveCostume methodsFor: 'primitive behaviors'!move: direction distance: dist	^self move: direction distance: dist duration: 1 style: #gently! !!CPrimitiveCostume methodsFor: 'primitive behaviors'!move: direction distance: dist duration: dur	^self move: direction distance: dist duration: dur style: #gently! !!CPrimitiveCostume methodsFor: 'primitive behaviors' stamp: 'ar 12/7/2002 22:15'!move: 		directiondistance: 	distanceduration: 	durationstyle: 		style	"Move me according the given attributes."	| msecDuration nowTime startTime styleFunc lastState startState endState deltaTime proportion newState |	"Get the ultimate state we're interested in"	endState := (self headingFor: direction) * distance.	duration <= 0		ifTrue:[^self localTransformBy: (COffsetTransform withOffset: endState)].	"Compute msecs since that's what we'll be working on here"	msecDuration := duration * 1000.	"Get our starting time to compute incremental changes accordingly"	nowTime := startTime := Time millisecondClockValue.	"Get the interpolation function (evaluating from 0-1 and returning values from 0-1)"	styleFunc := self interpolationForStyle: style.	"Reset the interpolation state"	lastState := startState := 0@0.	"And go moving until we're out of time"	self clock 		forEach: #tick 		until:[nowTime >= (startTime + msecDuration)]		do:[			"Compute the time at the tick and the delta to when we started"			nowTime := Time millisecondClockValue.			deltaTime := (nowTime - startTime) min: msecDuration.			"Compute the proportion of time that's over"			proportion := deltaTime asFloat / msecDuration asFloat.			"Map it through the interpolation style"			proportion := styleFunc value: proportion.			"Compute the state (e.g., offset) at our new proportion"			newState := startState interpolateTo: endState at: proportion.			"Transform incrementally - this is so that we can superimpose animations."			self localTransformBy: (COffsetTransform withOffset: newState - lastState).			"Remember last state for the next round"			lastState := newState.	].	"Apply the remaining part of the transform (if any)"	self localTransformBy: (COffsetTransform withOffset: endState - lastState).! !!CPrimitiveCostume methodsFor: 'primitive behaviors' stamp: 'ar 12/7/2002 22:15'!moveBy: 		distanceduration: 	durationstyle: 		style	"Move me according the given attributes."	| msecDuration nowTime startTime styleFunc lastState startState endState deltaTime proportion newState |	"Compute msecs since that's what we'll be working on here"	msecDuration := duration * 1000.	"Get our starting time to compute incremental changes accordingly"	nowTime := startTime := Time millisecondClockValue.	"Get the interpolation function (evaluating from 0-1 and returning values from 0-1)"	styleFunc := self interpolationForStyle: style.	"Reset the interpolation state"	lastState := startState := 0@0.	"Get the ultimate state we're interested in"	endState := distance.	"And go moving until we're out of time"	self clock 		forEach: #tick 		until:[nowTime >= (startTime + msecDuration)]		do:[			"Compute the time at the tick and the delta to when we started"			nowTime := Time millisecondClockValue.			deltaTime := (nowTime - startTime) min: msecDuration.			"Compute the proportion of time that's over"			proportion := deltaTime asFloat / msecDuration asFloat.			"Map it through the interpolation style"			proportion := styleFunc value: proportion.			"Compute the state (e.g., offset) at our new proportion"			newState := startState interpolateTo: endState at: proportion.			"Transform incrementally - this is so that we can superimpose animations."			self localTransformBy: (COffsetTransform withOffset: newState - lastState).			"Remember last state for the next round"			lastState := newState.	].	"Apply the remaining part of the transform (if any)"	self localTransformBy: (COffsetTransform withOffset: endState - lastState).	"Renormalize transform after completing the move"	self normalizeWithRotationDegrees.! !!CPrimitiveCostume methodsFor: 'primitive behaviors'!turn	^self turn: #left turns: 1 duration: 1 style: #gently.! !!CPrimitiveCostume methodsFor: 'primitive behaviors'!turn: dir	^self turn: dir turns: 1 duration: 1 style: #gently.! !!CPrimitiveCostume methodsFor: 'primitive behaviors'!turn: dir turns: turns	^self turn: dir turns: turns duration: 1 style: #gently.! !!CPrimitiveCostume methodsFor: 'primitive behaviors'!turn: dir turns: turns duration: dur	^self turn: dir turns: turns duration: dur style: #gently.! !!CPrimitiveCostume methodsFor: 'primitive behaviors'!turn: direction turns: turns duration: duration style: style	"Move me according the given attributes."	| msecDuration nowTime startTime styleFunc lastState startState endState deltaTime proportion newState |	"Get the ultimate state we're interested in"	direction == #left 		ifTrue:[endState := -360 * turns]		ifFalse:[endState := 360 * turns].		duration <= 0 ifTrue:[^self rotationDegrees: endState].	"Compute msecs since that's what we'll be working on here"	msecDuration := duration * 1000.	"Get our starting time to compute incremental changes accordingly"	nowTime := startTime := Time millisecondClockValue.	"Get the interpolation function (evaluating from 0-1 and returning values from 0-1)"	styleFunc := self interpolationForStyle: style.	"Reset the interpolation state"	lastState := startState := 0.	"And go moving until we're out of time"	self clock 		forEach: #tick 		until:[nowTime >= (startTime + msecDuration)]		do:[			"Compute the time at the tick and the delta to when we started"			nowTime := Time millisecondClockValue.			"Truncate deltaTime to fit into the given proportion"			deltaTime := (nowTime - startTime) min: msecDuration.			"Compute the proportion of time that's over"			proportion := deltaTime asFloat / msecDuration asFloat.			"Map it through the interpolation style"			proportion := styleFunc value: proportion.			"Compute the state (e.g., offset) at our new proportion"			newState := startState interpolateTo: endState at: proportion.			"Apply transform incrementally - this is so that we can superimpose animations."			self rotateBy: (newState - lastState).			"Remember last state for the next round"			lastState := newState.	].	"Apply the remaining part of the transform (if any)"	self rotateBy: (endState - lastState).! !!CPrimitiveCostume methodsFor: 'primitive behaviors'!turnBy: angle duration: duration style: style	"Move me according the given attributes."	duration <= 0 ifTrue:[^self rotationDegrees: self rotationDegrees + angle].	^self turn: #right turns: (angle / 360.0) duration: duration style: style! !!CPrimitiveCostume methodsFor: 'primitive behaviors'!turnTo: target duration: duration style: style	"Move me according the given attributes."self error:'not implemented'! !!CPrimitiveCostume methodsFor: 'private' stamp: 'ar 3/24/2004 03:14'!allocateBorder	border isNoBorder ifTrue:[border := CCostumeBorder forCostume: self].	^border! !!CPrimitiveCostume methodsFor: 'private' stamp: 'ar 3/24/2004 03:15'!allocateFill	fill isNoFill ifTrue:[fill := CCostumeFill forCostume: self].	^fill! !!CPrimitiveCostume methodsFor: 'private' stamp: 'ar 3/24/2004 03:14'!borderWidthForRounding	^border width! !!CPrimitiveCostume methodsFor: 'private' stamp: 'ar 3/23/2004 23:16'!canBltMove: aCostume from: oldRect to: newRect	"Private. Answer whether it is possible to relocate the given costume	from oldRect to newRect using a direct screen blt. If possible, prepare	everything that's needed for the blt (which may include transferring	some damage etc.)"	"Note: This version is currently _very_ conservative in its assumptions."	| cache dirty dirtyArea index frontCostume debug |true ifTrue:[^false].	debug := false.	debug ifTrue:[Transcript cr; show: '<bltMove: ',aCostume,'>'].	"Make sure this *is* a blt"	oldRect extent = newRect extent ifFalse:[		debug ifTrue:[Transcript cr; show: '<no blit>'].		^false].	(cache := self localCache) ifNotNil:[		"See if there is any damage in the old rectangle. 		If so, don't blt since the costume itself may not be up to date.		Note: For further optimization we could take the dirty region		into account and translate it into the new region (for non-front		costumes this would probably have to introduce addl. damage)."		(cache damageRecorder hasDamageInRect: oldRect) ifTrue:[			debug ifTrue:[Transcript cr; show: '<oldRect damage>'].			^false].		"See if there is any damage in the new rectangle.		If so, don't blt since we'd be drawing this area more than once.		Note: For further optimization we should take the size of the 		dirty area into account since it can be small."		(cache damageRecorder hasDamageInRect: newRect) ifTrue:[			debug ifTrue:[Transcript cr; show: '<newRect damage>'].			^false].	].	"See how much we'd have to redraw after the blt.	Note: for non-front costumes this must take the overlap into account	since we _do_ have to restore everything before aCostume."	dirty := aCostume areasRemainingToFill: newRect.	dirtyArea := dirty inject: 0 into:[:sum :rect| sum + rect area].	"If we have to restore more than half of aCostume after the blt it's pointless"	newRect area > (dirtyArea * 2) ifFalse:[		debug ifTrue:[Transcript cr; show: '<tiny area>'].		^false].	"Only the front-most costume is allowed to blt.	Note: For further optimization this could be relaxed but requires	more effort in some other parts."	index := 1.	[index <= contents size and:[(contents at: index) ~~ aCostume]] whileTrue:[		frontCostume := contents at: index.		frontCostume visible ifTrue:[			"see if front costume overlaps either old or new rect"			frontCostume layoutNeeded ifTrue:[				"Uh, ah ... this guy needs a layout which may change its size.				I can't say for sure what this means at this point; probably some				other than the 'fullBounds' measure is needed."				debug ifTrue:[Transcript cr; show: '<layout needed>'].				^false].			"Check if its fullBounds overlap either the the new area"			(frontCostume fullBounds intersects: newRect) ifTrue:[				debug ifTrue:[Transcript cr; show: '<costume overlap>'].				^false]].		index := index + 1].	"Okay, so this looks good. Let's go for it"	debug ifTrue:[Transcript cr; show: '<OKAY>'].	^true! !!CPrimitiveCostume methodsFor: 'private' stamp: 'ar 3/15/2004 20:32'!componentBinding	"Answer the receiver's part binding"	^self propertyValueAt: #componentBinding! !!CPrimitiveCostume methodsFor: 'private' stamp: 'ar 3/15/2004 20:32'!componentBinding: aBinding	"Change the component binding associated with the receiver."	| myBinding |	"Carefully release the previous binding first"	(myBinding := self componentBinding) ifNotNil:[myBinding value: nil].	^self propertyValueAt: #componentBinding put: aBinding.! !!CPrimitiveCostume methodsFor: 'private' stamp: 'ar 7/14/2003 19:08'!confirm: queryString	ActiveHand isPlayer ifTrue:[^CDialog confirm: queryString].	^super confirm: queryString! !!CPrimitiveCostume methodsFor: 'private' stamp: 'ar 7/28/2004 22:01'!getCostume	^nil! !!CPrimitiveCostume methodsFor: 'private' stamp: 'ar 7/14/2003 19:08'!inform: queryString	ActiveHand isPlayer ifTrue:[^CDialog inform: queryString].	^super inform: queryString! !!CPrimitiveCostume methodsFor: 'private' stamp: 'ar 1/8/2003 17:15'!invalidationBounds	"Return the bounds for invalidating the receiver"	| box  |	box := self outerBounds.	contents size = 0 ifTrue: [^box].	(flags bitAnd: FlagExcessBounds) == 0 ifTrue:[^box].	(flags bitAnd: FlagClipEnabled) == 0 ifFalse:[^box].	box := box copy.	"@@@@: Fix this. It sucks. We shouldn't have to use child's childToParent transform here... :@@@@"	contents do: [:m |		(m visible) ifTrue: [box := box quickMerge: (m childToParent transformRect: m invalidationBounds)]].	^ box! !!CPrimitiveCostume methodsFor: 'private'!localFullBounds	"Return the bounding box of the receiver and all its parts. Recompute the layout if necessary."	self layoutNeeded ifTrue:[		"Errors at this point can be critical so make sure we catch 'em all right"		[self doLayoutIn: self layoutBounds] on: Error do:[:ex| ex pass].	].	^self privateFullBounds! !!CPrimitiveCostume methodsFor: 'private' stamp: 'ar 9/4/2003 23:43'!myEventMap	^self propertyValueAt: #myEventMap! !!CPrimitiveCostume methodsFor: 'private' stamp: 'ar 9/4/2003 23:39'!myEventMap: eventMap	self propertyValueAt: #myEventMap put: eventMap! !!CPrimitiveCostume methodsFor: 'private' stamp: 'ar 9/4/2003 23:43'!myScripts	^(self propertyValueAt: #myScripts) ifNil:[#()]! !!CPrimitiveCostume methodsFor: 'private' stamp: 'ar 9/4/2003 23:39'!myScripts: scriptList	scriptList isEmptyOrNil		ifTrue:[self removeProperty: #myScripts]		ifFalse:[self propertyValueAt: #myScripts put: scriptList].! !!CPrimitiveCostume methodsFor: 'private' stamp: 'ar 3/24/2004 03:12'!newFormCache	^CFormCache new! !!CPrimitiveCostume methodsFor: 'private'!normalizeWithRotationDegrees	"Set the receiver's rotation degrees and renormalize the transformation."	| degrees |	degrees := self rotationDegrees.	(degrees - degrees rounded abs < 0.001 and:[(degrees rounded \\ 90) = 0]) 		ifTrue:[^self normalizeWithRotationDegrees: degrees rounded].! !!CPrimitiveCostume methodsFor: 'private' stamp: 'ar 12/7/2002 22:14'!normalizeWithRotationDegrees: degrees	"Set the receiver's rotation degrees and renormalize the transformation.	WARNING: Only call this method with multiple of 90 degrees!!"	| tfm tfmOffset tfmDegrees tfmScale s c a11 a12 a21 a22 quadrant |	tfm := self transform.	tfmOffset := tfm offset rounded.	tfmDegrees := degrees truncated.	tfmScale := tfm scale.	(tfmScale x  < 0.0 and:[tfmScale x * tfmScale y > 0.0]) ifTrue:[		"if both scales are < 0.0 then we have a rotation and reverse the scale"		tfmScale := tfmScale negated].	tfmScale := [tfmScale roundTo: (1.0 asPoint / self localFullBounds extent)]		on: ZeroDivide do:[:ex| ex return: ex dividend].	"Compute new transform but manually to have full 64 bit precision"	quadrant := tfmDegrees \\ 360 // 90 + 1.	s := #(0.0 1.0 0.0 -1.0) at: quadrant.	c := #(1.0 0.0 -1.0 0.0) at: quadrant.	a11 := c * tfmScale x.	a12 := (0.0 - s) * tfmScale y. 	a21 := s * tfmScale x.	a22 := c * tfmScale y.	"done here; install new transform and be happy"	tfm := CMatrixTransform new.	tfm 	a11: a11; a12: a12; a13: tfmOffset x;			a21: a21; a22: a22; a23: tfmOffset y.	self transform: tfm.! !!CPrimitiveCostume methodsFor: 'private' stamp: 'ar 3/24/2004 15:05'!onPlayerChanged! !!CPrimitiveCostume methodsFor: 'private' stamp: 'ar 3/23/2004 21:22'!outerBounds	"Return the 'outer' bounds of the receiver, e.g., the bounds that need to be invalidated when the receiver changes."	| box highlights |	(flags bitAnd: FlagHasHighlights) = 0 ifTrue:[^self localBounds].	box := self localBounds.	highlights := self highlights.	highlights do:[:highlight| box := highlight expandBounds: box].	^box! !!CPrimitiveCostume methodsFor: 'private' stamp: 'ar 3/24/2004 03:10'!printOn: aStream	super printOn: aStream.	aStream nextPut:$[; print: self player; nextPut: $].! !!CPrimitiveCostume methodsFor: 'private' stamp: 'ar 2/17/2004 18:55'!privateAdd: aCostume atIndex: index	"@@@@: Fix this. When adding a costume we should check if it obtrudes the receiver and update its obtrusion flag (****check wording ****) appropriately before any invalidations are triggered. Might need to update the 'i am fully invalidated' flag too. :@@@@"	"@@@@: Check this. See how to avoid invalidations when we (for example) pick up costumes or drop them again. Should check the bounds before and after the add operation if aCostume is in the world."	"@@@@: Check this. Should we add costumes based on their world position??? Makes sense in many cases but can be a pain in others... :@@@@"	| oldIndex newIndex myWorld itsWorld |	newIndex _ index.	newIndex < 1 ifTrue:[newIndex _ 1].	newIndex > (contents size + 1) ifTrue:[newIndex _ contents size + 1].	aCostume == self ifTrue:[^self]. "@@@@: Should this raise an error or not??? :@@@@"	aCostume container == self ifTrue:[		"costume's position changes within in the contents"		newIndex > contents size ifTrue:[newIndex := contents size].		oldIndex _ self indexOf: aCostume.		oldIndex = newIndex ifTrue:[^self].		oldIndex < newIndex ifTrue:["moving aCostume to the back"			oldIndex+1 to: newIndex do:[:i| contents at: i-1 put: (contents at: i)].			contents at: newIndex put: aCostume.		] ifFalse:["moving aCostume to front"			oldIndex-1 to: newIndex by: -1 do:[:i| contents at: i+1 put: (contents at: i)].			contents at: newIndex put: aCostume.		]	] ifFalse:["a new costume"		myWorld _ self world.		aCostume container ifNotNil:[			itsWorld _ aCostume world.			itsWorld == myWorld ifFalse: [aCostume outOfWorld: itsWorld].			aCostume container privateRemove: aCostume.		].		aCostume setContainer: self.		contents _ contents copyReplaceFrom: newIndex to: newIndex-1 with: (Array with: aCostume).		itsWorld == myWorld ifFalse:[aCostume intoWorld: myWorld].	].	aCostume invalidate.	self invalidateLayout.	self signal: #added with: aCostume.	self structureChanged.! !!CPrimitiveCostume methodsFor: 'private' stamp: 'ar 3/16/2004 13:51'!privateAdd: aCostume beforeIndex: index	| newIndex oldIndex |	aCostume == self ifTrue:[^self]. "@@@@: Should this raise an error or not??? :@@@@"	(self isIn: aCostume) ifTrue:[		"Need to change my container to aCostume's container"		aCostume container 			ifNil:[self container remove: self]			ifNotNil:[aCostume container elements replace: aCostume with: self].	].	newIndex _ index.	newIndex < 1 ifTrue:[newIndex _ 1].	newIndex > (contents size + 1) ifTrue:[newIndex _ contents size + 1].	aCostume container == self 		ifFalse:[^self privateReplaceFrom: newIndex 					to: newIndex-1 					with: (Array with: aCostume)].	"move that guy to the appropriate position"	"costume's position changes within in the contents"	newIndex > contents size ifTrue:[newIndex := contents size].	oldIndex _ self indexOf: aCostume.	oldIndex = newIndex ifTrue:[^self].	oldIndex < newIndex ifTrue:["moving aCostume to the back"		oldIndex+1 to: newIndex do:[:i| contents at: i-1 put: (contents at: i)].		contents at: newIndex put: aCostume.	] ifFalse:["moving aCostume to front"		oldIndex-1 to: newIndex by: -1 do:[:i| contents at: i+1 put: (contents at: i)].		contents at: newIndex put: aCostume.	].	aCostume invalidate.	self invalidateLayout.	self structureChanged.! !!CPrimitiveCostume methodsFor: 'private' stamp: 'ar 3/7/2004 02:34'!privateBltMove: aCostume from: oldRect to: newRect	"Private. Try to relocate the given costume by delta using a direct screen blt.	By default, just invalidate the portion for later updates."	| aCanvas cache form tfm |	(self canBltMove: aCostume from: oldRect to: newRect) ifFalse:[		^self invalidate: (oldRect merge: newRect) from: aCostume.	].	cache := self localCache ifNil:[		container ifNil:[^self].		tfm := self transform.		^container privateBltMove: self 			from: (tfm transformRect: oldRect) 			to: (tfm transformRect: newRect)].	form := cache form.	form deferUpdates: true. "must defer from here"	aCanvas := CTransformCanvas on: form.	aCanvas clipBy: (oldRect merge: newRect).	(BitBlt toForm: form)		sourceForm: form;		combinationRule: 3;		sourceRect: oldRect;		destOrigin: newRect origin;		copyBits.	"Now that the blt is complete, record the remaining dirty areas.	Note: For non-front costumes this needs to take overlapping	areas into account."	(aCostume areasRemainingToFill: newRect)		do:[:rect| self invalidate: rect].	"And of course, the old rectangle"	(oldRect areasOutside: newRect) do:[:rect| self invalidate: rect].	"Notify parent about the change in newRect"	container ifNotNil:[container invalidate: newRect from: self].! !!CPrimitiveCostume methodsFor: 'private' stamp: 'ar 3/16/2003 00:06'!privateBounds	^bounds! !!CPrimitiveCostume methodsFor: 'private' stamp: 'ar 3/16/2003 00:06'!privateBounds: newBounds	bounds := newBounds.! !!CPrimitiveCostume methodsFor: 'private' stamp: 'ar 1/8/2003 17:11'!privateFullBounds	"Private. Compute the intermediate full bounds of the receiver"	| box |	box := self outerBounds.	contents size = 0 ifTrue: [^box].	(flags bitAnd: FlagExcessBounds) == 0 ifTrue:[^box].	(flags bitAnd: FlagClipEnabled) == 0 ifFalse:[^box].	box := box merge: self contentsBounds.	^box origin asIntegerPoint corner: box corner asIntegerPoint! !!CPrimitiveCostume methodsFor: 'private' stamp: 'ar 2/17/2004 18:55'!privateRemove: aCostume	"Private!! Should only be used by methods which:		* maintain the ower/part invariant		* notify costumes about leaving worlds	"	self assert:[aCostume container == self].	aCostume invalidate.	contents := contents copyWithout: aCostume.	self invalidateLayout.	self signal: #removed with: aCostume.	self structureChanged.! !!CPrimitiveCostume methodsFor: 'private' stamp: 'ar 2/17/2004 18:56'!privateReplaceFrom: firstIndex to: lastIndex with: aCollection	"The core of modifying costume contents"	| myWorld itsWorld startIndex stopIndex |	myWorld := self world.	startIndex := firstIndex.	stopIndex := lastIndex.	aCollection do:[:aCostume|		aCostume == self ifTrue:[^self error: 'Cannot add myself to my children'].		itsWorld := nil.		aCostume container ifNil:[			"the simple case - merely transfer it"			aCostume setContainer: self.			aCostume intoWorld: myWorld.			aCostume invalidate.		] ifNotNil:[			"more complex - must distinguish between containers"			aCostume container == self ifTrue:[				"this guy is being moved around - fix up my start/stop if needed"				| oldIndex |				oldIndex := self indexOf: aCostume.				oldIndex < startIndex ifTrue:[startIndex := startIndex-1].				oldIndex <= stopIndex ifTrue:[stopIndex := stopIndex-1].				itsWorld := myWorld.				"simply remove it from my contents without any further invalidation"				contents := contents copyReplaceFrom: oldIndex to: oldIndex with: #().			] ifFalse:[				"the guy comes from somewhere else"				itsWorld := aCostume world.				itsWorld == myWorld ifFalse:[aCostume outOfWorld: itsWorld].				aCostume container privateRemove: aCostume.				"transfer aCostume to me"				aCostume setContainer: self.				itsWorld == myWorld ifFalse:[aCostume intoWorld: myWorld].				aCostume invalidate.			].		].	].	"Now bump everything from start to stop"	contents from: startIndex to: stopIndex do:[:aCostume|		aCostume outOfWorld: myWorld.		aCostume invalidate.		self signal: #removed with: aCostume.		aCostume setContainer: nil.	].	contents := contents copyReplaceFrom: startIndex to: stopIndex with: aCollection.	self invalidateLayout.	self structureChanged.! !!CPrimitiveCostume methodsFor: 'private' stamp: 'ar 3/24/2004 03:22'!privateTransform	(flags bitAnd: FlagHasMatrix) = 0		ifTrue:[^COffsetTransform withOffset: bounds origin]		ifFalse:[^self propertyValueAt: #transform].! !!CPrimitiveCostume methodsFor: 'private' stamp: 'ar 3/28/2004 16:32'!privateTransform: aTransform	(flags bitAnd: FlagHasFullBounds) == 0 ifFalse:[		"Cached fullBounds get invalidated when the transform changes"		properties removeKey: #fullBounds.		flags := flags bitClear: FlagHasFullBounds.	].	aTransform isPureTranslation ifTrue:[		bounds := aTransform offset extent: bounds extent.		flags := flags bitClear: FlagHasMatrix.	] ifFalse:[		self propertyValueAt: #transform put: aTransform.		flags := flags bitOr: FlagHasMatrix.	].	self signal: #geometryChanged.	self frameChanged.! !!CPrimitiveCostume methodsFor: 'private' stamp: 'ar 9/8/2004 16:25'!setContainer: aCostume	"Private!! Should only be used by methods that maintain the ower/part invariant."	| oldOwner |	oldOwner _ container.	container _ aCostume.	self signalChanged: #containerChanged from: oldOwner to: container.! !!CPrimitiveCostume methodsFor: 'private' stamp: 'ar 2/17/2004 18:56'!structureChanged	"My structure has changed (by adding or removing some entitiy)."	self signal: #structureChanged with: self.! !!CPrimitiveCostume methodsFor: 'Morphic compatibility' stamp: 'ar 3/27/2004 19:58'!handleDropMorph: anEvent	^self handleDrop: anEvent! !!CPrimitiveCostume methodsFor: 'tk script' stamp: 'tk 7/8/2004 11:22'!asCodeOn: converter using: myTempName	"With a temp var name already assigned for me, write Squeak code to make the changes from my default state.     Cases:  Set value or add TweakscurValue has tweaks  -> Put in a temp var. tell him to write his tweaks.						Runtime test if his class is the same as now.curValue has no tweaks itself, but it is the new value of a tweak  ->   parent setter: curValue  "	| myTweaks fldDesc hisTempName fldValue |	(myTweaks _ self tweaks) ifNil: [^ self].	myTweaks associationsDo: [:asc | 		fldDesc _ self fieldNamed: asc key.		fldDesc 			ifNil: [Transcript show: asc printString; cr]	"PrimCostume contents"			ifNotNil: [				(fldValue _ fldDesc value "the current value") tweaks ~~ nil  					ifTrue: [						hisTempName _ converter tempNameFor: fldValue.						"Another level down"						converter assign: hisTempName gets: myTempName 							field: fldDesc fieldDefinition toGet value: fldValue.						"debug"						converter testClassOf: fldValue tempName: hisTempName.												fldValue asCodeOn: converter using: hisTempName]					ifFalse: ["Direct setter"						converter store: fldValue withSetter: fldDesc fieldDefinition toSet in: self]]].! !!CHandCostume methodsFor: 'mouse cursor' stamp: 'ar 3/19/2003 20:49'!mouseCursor	^mouseCursor! !!CHandCostume methodsFor: 'mouse cursor' stamp: 'bf 10/1/2004 16:23'!mouseCursor: newCursor	| oldCursor |	oldCursor := mouseCursor.	mouseCursor := newCursor ifNil:[Cursor normal].	mouseCursor isForm 		ifFalse:[mouseCursor := mouseCursor asForm].	self signalChanged: #mouseCursorChanged from: oldCursor to: newCursor.	self extent: mouseCursor extent.	self scrollOffset: mouseCursor offset.	self showHardwareCursor ifTrue:[		self invalidationSuppressed: true.		self graphic: nil.		mouseCursor show.	] ifFalse:[		self graphic: mouseCursor asForm.		self invalidationSuppressed: false.		self invalidate.		"grrr ... this leads to a slight flash as the hardware cursor 		goes away immediately but is redrawn only later..."		Cursor blank show.	].	^newCursor! !!CHandCostume methodsFor: 'mouse cursor' stamp: 'ar 3/19/2003 20:47'!showHardwareCursor	"Answer whether receiver should show the hardware cursor or not"	contents size = 0 ifFalse:[^false]. "carrying stuff"	container ifNil:[^false]. "how should we?"	self world primaryHand == self player ifFalse:[^false]. "not primary hand"	self mouseCursor isCursor ifFalse:[^false]. "not a cursor"	^true! !!CHandCostume methodsFor: 'initialize' stamp: 'ar 3/19/2003 22:27'!initialize	super initialize.	mouseCursor := Cursor blank.! !!CProject methodsFor: 'initialize' stamp: 'ar 3/5/2004 14:45'!destroy	"Destroy this project"	self name: '<destroyed project>'.	self thumbnail: nil.	super destroy.! !!CProject methodsFor: 'initialize' stamp: 'ar 3/25/2004 19:23'!initialize	super initialize.	self name: nil.	self define: #library as: CProjectLibrary new.	self clipping: true.! !!CProject methodsFor: 'field access' stamp: 'ar 3/17/2004 15:12'!library	"This method was automatically generated"	<bewareOf: #libraryChanged>	^self propertyValueAt: #library! !!CProject methodsFor: 'field access' stamp: 'ar 3/11/2004 14:24'!library: aValue	"This method was automatically generated"	^self propertyValueAt: #library put: aValue with: #libraryChanged! !!CProject methodsFor: 'field access' stamp: 'ar 3/17/2004 15:13'!thumbnail	"This method was automatically generated"	<bewareOf: #thumbnailChanged>	^self propertyValueAt: #thumbnail! !!CProject methodsFor: 'field access' stamp: 'ar 3/11/2004 14:24'!thumbnail: aValue	"This method was automatically generated"	^self propertyValueAt: #thumbnail put: aValue with: #thumbnailChanged! !!CProject methodsFor: 'actions' stamp: 'tk 7/14/2004 11:27'!makeThumbnail	"Create a new thumbnail"	self thumbnail: (self asPrimCostume asFormExtent: 128@128).! !!CProject methodsFor: 'accessing' stamp: 'ar 3/5/2004 14:50'!root	^self! !!CProject methodsFor: 'layout' stamp: 'tk 6/25/2004 22:43'!okToPlace: aPlayer at: pt	"Return true if no obvious intersection of aPlayer with other existing players is placed at the point"	| rr |	rr _ aPlayer bounds.		"Transcript show: rr extent; cr."	rr _ pt extent: rr extent.	elements do: [:obj |		(obj globalBounds intersects: rr) ifTrue: [^ false]].	^ true! !!CProject methodsFor: 'layout' stamp: 'tk 6/25/2004 22:38'!positionToOpen: aPlayer	"Look for a place to open this player.  If a TileViewer, really want to know its target.  Maybe find out how has a halo."	| rect pt2 |	rect _ self globalBounds.	rect _ rect origin copy extent: (rect extent - aPlayer extent max: (0@0)).	"places to put upper left corner"	{0.2@0.2. 0.98@0.98. 0.4@0. 0@0.4. 0.5@0.5. 1.0@0.5. 0.5@1.0. 0.75@0.75. 1.0@0. 0@1.0} do: [:pt |		pt2 _ (rect origin + (pt * rect extent)) truncated.		(self okToPlace: aPlayer at: pt2) ifTrue: [^ pt2]].	^ self hand position - 100! !!CProjectBuilder methodsFor: 'initialize' stamp: 'ar 10/4/2004 21:48'!initialize	super initialize.	self allProjects: CCollection new.	self installWorldMenu.	project := self newProject.	projectList := self newProjectList.! !!CProjectBuilder methodsFor: 'initialize' stamp: 'ar 10/20/2003 19:37'!installWorldMenu	self worldMenu ifNotNil:[self worldMenu close].	self worldMenu: self newWorldMenu.! !!CProjectBuilder methodsFor: 'initialize' stamp: 'ar 10/20/2003 19:50'!quit	self closeProject.	self window ifNotNil:[self window close].! !!CProjectBuilder methodsFor: 'initialize' stamp: 'bf 7/23/2004 12:39'!setupCostume	super setupCostume.	self clipping: true.	self add: worldMenu.	projectList color: CWidgetLibrary default paneColor.	projectList width: 110.	self add: projectList.	self add: project.! !!CProjectBuilder methodsFor: 'accessing' stamp: 'ar 3/17/2004 15:13'!allProjects	"This method was automatically generated"	<bewareOf: #allProjectsChanged>	^self propertyValueAt: #allProjects! !!CProjectBuilder methodsFor: 'accessing' stamp: 'ar 3/11/2004 14:24'!allProjects: aValue	"This method was automatically generated"	^self propertyValueAt: #allProjects put: aValue with: #allProjectsChanged! !!CProjectBuilder methodsFor: 'accessing' stamp: 'ar 3/14/2004 13:52'!display	^(self window ifNil:[^nil]) display! !!CProjectBuilder methodsFor: 'accessing' stamp: 'ar 4/3/2004 13:55'!lastImportDirectory	"Answer the lastImportDirectory of the receiver"	<bewareOf: #lastImportDirectoryChanged>	^self propertyValueAt: #lastImportDirectory! !!CProjectBuilder methodsFor: 'accessing' stamp: 'ar 4/3/2004 13:55'!lastImportDirectory: aValue	"Modify the receiver's lastImportDirectory"	^self propertyValueAt: #lastImportDirectory put: aValue with: #lastImportDirectoryChanged! !!CProjectBuilder methodsFor: 'accessing' stamp: 'ar 3/17/2004 15:13'!project	"This method was automatically generated"	<bewareOf: #projectChanged>	^self propertyValueAt: #project! !!CProjectBuilder methodsFor: 'accessing' stamp: 'ar 3/11/2004 14:24'!project: aValue	"This method was automatically generated"	^self propertyValueAt: #project put: aValue with: #projectChanged! !!CProjectBuilder methodsFor: 'accessing' stamp: 'ar 3/14/2004 13:13'!projectList	"Answer the projectList of the receiver"	<bewareOf: #projectListChanged>	^self propertyValueAt: #projectList! !!CProjectBuilder methodsFor: 'accessing' stamp: 'ar 3/14/2004 13:13'!projectList: aValue	"Modify the receiver's projectList"	^self propertyValueAt: #projectList put: aValue with: #projectListChanged! !!CProjectBuilder methodsFor: 'accessing' stamp: 'ar 10/20/2003 19:52'!standardBounds	"Answer the standard bounds for this world - inset by the menu if present"	self worldMenu ifNil:[^self costume localBounds].	^self costume localBounds insetBy: (0@self worldMenu costume fullBounds height corner: 0@0).! !!CProjectBuilder methodsFor: 'accessing' stamp: 'ar 3/29/2004 16:50'!toolMenuItems	^self class toolMenuItems! !!CProjectBuilder methodsFor: 'accessing' stamp: 'ar 3/17/2004 15:13'!window	"This method was automatically generated"	<bewareOf: #windowChanged>	^self propertyValueAt: #window! !!CProjectBuilder methodsFor: 'accessing' stamp: 'ar 3/11/2004 14:24'!window: aValue	"This method was automatically generated"	^self propertyValueAt: #window put: aValue with: #windowChanged! !!CProjectBuilder methodsFor: 'accessing' stamp: 'ar 3/17/2004 15:13'!worldMenu	"This method was automatically generated"	<bewareOf: #worldMenuChanged>	^self propertyValueAt: #worldMenu! !!CProjectBuilder methodsFor: 'accessing' stamp: 'ar 3/11/2004 14:24'!worldMenu: aValue	"This method was automatically generated"	^self propertyValueAt: #worldMenu put: aValue with: #worldMenuChanged! !!CProjectBuilder methodsFor: 'project' stamp: 'ar 3/14/2004 18:44'!closeProject	"Close the current project"	| oldProject result |	(oldProject := self project) ifNil:[^self].	result := CDialog confirm: 'Save ''', oldProject name,''' before closing?'.	result ifNil:[^nil].	result ifTrue:[self saveProject ifFalse:[^nil]].	self halo target: nil.	self project: nil.	oldProject destroy.	self allProjects remove: oldProject.	self allProjects cursor: 0.	self window label: 'Project Builder'.! !!CProjectBuilder methodsFor: 'project' stamp: 'ar 3/25/2004 19:23'!newProject	"Create a new project"	| newProject |	newProject := CProject new.	self allProjects add: newProject.	self allProjects selection: newProject.	^newProject! !!CProjectBuilder methodsFor: 'project' stamp: 'ar 3/25/2004 19:09'!openFile	"Open a file"	| fileName file object |	fileName := CFileOpenDialog openFile: #(		('Graphic files' ('*.gif' '*.jpg' '*.bmp' '*.png' '*.jpeg'))	).	fileName ifNil:[^self].	file := FileStream readOnlyFileNamed: fileName.	[object := self importImageFrom: file] ensure:[file close].	object openInHand! !!CProjectBuilder methodsFor: 'project' stamp: 'ar 10/20/2003 19:48'!openImageFile	"An example for using file specs"	"ActiveHand world openImageFile"	^self openFile: #(		('Image Files' ('*.jpg' '*.gif' '*.png' '*.bmp'))		('JPEG Files' ('*.jpg' '*.jpeg'))		('GIF Files' ('*.gif'))		('PNG Files' ('*.png'))		('BMP Files' ('*.bmp'))		('All Files' ('*'))	)! !!CProjectBuilder methodsFor: 'project' stamp: 'ar 4/2/2004 14:52'!openProject	"Open a new project"	| fileName file object newProject |	fileName := CFileOpenDialog openFile: #(		('Projects'	('*.zip'))	) label: 'Open Project'.	fileName ifNil:[^self].	(fileName endsWith: '.zip') ifTrue:[		MessageTally spyOnScript:[newProject := self openProjectNamed: fileName].	] ifFalse:[		newProject := CProject new.		file := FileStream readOnlyFileNamed: fileName.		[object := self importImageFrom: file] ensure:[file close].		newProject add: object.	].	newProject name: fileName.	self allProjects add: newProject.	self allProjects selection: newProject.! !!CProjectBuilder methodsFor: 'project' stamp: 'ar 3/5/2004 15:48'!openProjectNamed: aFilename	| file |	file := FileStream readOnlyFileNamed: aFilename.	Utilities informUserDuring:[:bar|		^[CProjectLoader new readFrom: file notifying: bar] ensure:[file close].	].! !!CProjectBuilder methodsFor: 'project' stamp: 'ar 2/23/2004 14:41'!projectExtent: newExtent	newExtent == #auto 		ifTrue:[^self project root hResizing: #spaceFill; vResizing: #spaceFill].	self project root hResizing: #rigid; vResizing: #rigid.	self project root extent: newExtent.	self project root origin: self extent - self project extent // 2.! !!CProjectBuilder methodsFor: 'project' stamp: 'ar 3/25/2004 18:54'!saveObject	| obj fileName |	obj := self hand halo target.	obj ifNil:[^Smalltalk beep].	fileName := CFileSaveDialog openFile: #(			('Player files'	('*.sqp'))		) label: 'Save Player'.	fileName ifNil:[^self].	Smalltalk beep.! !!CProjectBuilder methodsFor: 'project' stamp: 'ar 3/5/2004 18:06'!saveProject	"Save the current project"	| maker |	self project name ifNil:[^self saveProjectAs].	Cursor wait showWhile:[maker := CObjectMaker newFrom: self project].	maker saveTo: self project name.	^true! !!CProjectBuilder methodsFor: 'project' stamp: 'ar 3/13/2004 15:53'!saveProjectAs	"Save the current project"	| fileName |	fileName := CFileSaveDialog openFile: #(			('Project files'	('*.zip'))		) label: 'Save Player'.	fileName ifNil:[^false].	self project name: fileName.	self window label: fileName.	^self saveProject.! !!CProjectBuilder methodsFor: 'halo' stamp: 'ar 1/7/2004 23:09'!halo	"This is still with the hand where it is PRECISELY wrong"	^self hand halo! !!CProjectBuilder methodsFor: 'halo' stamp: 'ar 3/26/2004 21:17'!move: aPlayer by: delta	| oldValue newValue parent |	oldValue := aPlayer position.	parent := aPlayer container.	parent gridEnabled ifTrue:[		newValue := oldValue + (delta * parent grid extent).	] ifFalse:[		newValue := oldValue + delta.	].	aPlayer position: newValue.	aPlayer tweaked: #position from: oldValue to: newValue.! !!CProjectBuilder methodsFor: 'halo' stamp: 'tk 7/14/2004 11:27'!moveDownLayer: aTarget	| aCostume |	self flag: #partsHack.	"FIXME: This is an incredibly ugly hack to get the change notification right. I haven't quite thought about how to handle parts-change notification. So we will simply inform the costume about its contents change and this requires the following ugly hack. I NEED TO FIX THIS!!!!!!"	aCostume := aTarget asPrimCostume.	aCostume container tweaked: #contents		after:[aCostume moveDownLayer].! !!CProjectBuilder methodsFor: 'halo' stamp: 'tk 7/14/2004 11:28'!moveUpLayer: aTarget	| aCostume |	self flag: #partsHack.	"FIXME: This is an incredibly ugly hack to get the change notification right. I haven't quite thought about how to handle parts-change notification. So we will simply inform the costume about its contents change and this requires the following ugly hack. I NEED TO FIX THIS!!!!!!"	aCostume := aTarget asPrimCostume.	aCostume container tweaked: #contents		after:[aCostume moveUpLayer].! !!CProjectBuilder methodsFor: 'halo' stamp: 'ar 2/23/2004 01:41'!onHaloCopy	self halo target ifNil:[^self].	Cursor wait showWhile:[		self waitTick.		CClipboard clipboardClear.		CClipboard clipboardAt: 'Squeak Player' put: self halo target.		self waitTick.	].! !!CProjectBuilder methodsFor: 'halo' stamp: 'ar 1/20/2004 18:45'!onHaloDebug: aHandle	<on: haloDebug>	self halo target inspect.! !!CProjectBuilder methodsFor: 'halo' stamp: 'tk 7/14/2004 11:28'!onHaloDismiss: aHandle	| haloTarget |	<on: haloDismiss>	(self waitHaloAction: aHandle) ifFalse:[^self].	haloTarget := self halo target.	self halo target: nil.	haloTarget container asPrimCostume tweaked: #contents after:[haloTarget close].! !!CProjectBuilder methodsFor: 'halo' stamp: 'ar 2/27/2004 18:38'!onHaloDrag: aHandle	| lastPt nextPt delta haloTarget oldPos |	<on: haloDrag>	"note: does not recompute transform every frame"	lastPt := self hand position. "global!!"	haloTarget := self halo target.	oldPos := haloTarget position.	self trackHaloHandle: aHandle in:[		nextPt := self hand position. "global!!"		haloTarget container 			ifNil:[delta := nextPt - lastPt]			ifNotNil:[delta := (haloTarget container globalToLocal: nextPt) - 					(haloTarget container globalToLocal: lastPt)].		haloTarget costume moveBy: delta.		lastPt := nextPt.	].	haloTarget tweaked: #position from: oldPos to: haloTarget position.! !!CProjectBuilder methodsFor: 'halo' stamp: 'ar 3/24/2004 02:12'!onHaloDup: aHandle	| dup tfm haloTarget |	<on: haloDup>	haloTarget := self halo target.	tfm := self project root globalToLocal composedWithLocal:			haloTarget localToGlobal.	dup := haloTarget copy.	dup openIn: self project root.	dup costume transform: tfm.	self halo target: dup.	self onHaloGrab: aHandle.! !!CProjectBuilder methodsFor: 'halo' stamp: 'ar 1/7/2004 23:06'!onHaloEvent: aHandle	| eventName |	<on: haloEvent>	eventName := aHandle value.	self halo target ifNil:[^self].	eventName ifNil:[^self].	self signal: eventName with: aHandle! !!CProjectBuilder methodsFor: 'halo' stamp: 'tk 7/14/2004 11:29'!onHaloGrab: aHandle	| tfm haloTarget parent haloCostume |	<on: haloGrab>	haloTarget := self halo target.	haloCostume := haloTarget asPrimCostume.	parent := haloTarget container.	tfm := self project root globalToLocal composedWithLocal:			haloCostume localToGlobal.	haloCostume transform: tfm.	self flag: #partsHack.	"FIXME: This is an incredibly ugly hack to get the change notification right. I haven't quite thought about how to handle parts-change notification. So we will simply inform the costume about its contents change and this requires the following ugly hack. I NEED TO FIX THIS!!!!!!"	parent asPrimCostume tweaked: #contents after:[		self project root add: haloTarget.	].	self onHaloDrag: aHandle.	self hand drop: haloTarget.! !!CProjectBuilder methodsFor: 'halo' stamp: 'ar 3/27/2004 21:07'!onHaloKeyDown: evt	| keyValue |	<on: haloKeyDown> "later: <on: keyDown in: halo>"	keyValue := evt keyValue.	evt controlKeyPressed ifTrue:[		keyValue = $C asciiValue ifTrue:[self onHaloCopy].		keyValue = $V asciiValue ifTrue:[self onHaloPaste].		keyValue = $S asciiValue ifTrue:[self onHaloSave].		keyValue = 28 ifTrue:[^self turn: self halo target by: -1].		keyValue = 29 ifTrue:[^self turn: self halo target by: 1].		keyValue = 30 ifTrue:[^self moveUpLayer: self halo target].		keyValue = 31 ifTrue:[^self moveDownLayer: self halo target].		^self].	evt shiftPressed ifTrue:[		keyValue = 28 ifTrue:[^self resize: self halo target by: -1@0].		keyValue = 29 ifTrue:[^self resize: self halo target by:  1@0].		keyValue = 30 ifTrue:[^self resize: self halo target by: 0@-1].		keyValue = 31 ifTrue:[^self resize: self halo target by: 0@ 1].		^self].	keyValue = 28 ifTrue:[^self move: self halo target by: -1@0].	keyValue = 29 ifTrue:[^self move: self halo target by:  1@0].	keyValue = 30 ifTrue:[^self move: self halo target by: 0@-1].	keyValue = 31 ifTrue:[^self move: self halo target by: 0@1].! !!CProjectBuilder methodsFor: 'halo' stamp: 'ar 2/23/2004 01:24'!onHaloPaste	| pastee |	self halo target ifNil:[^self].	pastee := CClipboard clipboardAt: 'Squeak Player'.	pastee ifNil:[^self].	self onPastePlayer: pastee.! !!CProjectBuilder methodsFor: 'halo' stamp: 'ar 3/23/2004 20:47'!onHaloRecolor: aHandle	| tool |	<on: haloRecolor>	tool := CColorTool new.	tool target: self halo target.	tool openAt: hand position.! !!CProjectBuilder methodsFor: 'halo' stamp: 'ar 2/29/2004 01:25'!onHaloRename: aString	| haloTarget |	<on: haloRename>	haloTarget := self halo target.	haloTarget name: aString.! !!CProjectBuilder methodsFor: 'halo' stamp: 'tk 7/14/2004 11:28'!onHaloRotate: aHandle	| lastPt nextPt rotCenter haloTarget oldAngle |	<on: haloRotate>	haloTarget := self halo target.	oldAngle := haloTarget angle.	rotCenter := haloTarget localToGlobal: haloTarget asPrimCostume rotationCenter.	lastPt := self hand position. "global!!"	self trackHaloHandle: aHandle in:[		nextPt := self hand position.		self rotateHaloTarget: haloTarget from: lastPt to: nextPt center: rotCenter.		lastPt := nextPt.	].	oldAngle = haloTarget angle ifFalse:[		haloTarget tweaked: #angle from: oldAngle to: haloTarget angle.	].! !!CProjectBuilder methodsFor: 'halo' stamp: 'ar 2/24/2004 23:17'!onHaloSave	| aLibrary haloTarget |	(haloTarget := self halo target) ifNil:[^self].	aLibrary := self project library.	aLibrary ifNil:[^self inform: 'This project has no library'].	Cursor write showWhile:[aLibrary save: haloTarget].! !!CProjectBuilder methodsFor: 'halo' stamp: 'ar 3/27/2004 21:03'!onHaloSize: aHandle	|  aPoint offset haloTarget oldExtent |	<on: haloSize>	haloTarget := self halo target.	offset := (haloTarget costume globalToLocal: self hand position) - 		haloTarget costume localBounds corner.	oldExtent := haloTarget extent.	self trackHaloHandle: aHandle in:[		aPoint := haloTarget globalToLocal: self hand position.		haloTarget costume localExtent: aPoint - offset - haloTarget costume localBounds origin.	].	oldExtent = haloTarget extent ifFalse:[		haloTarget tweaked: #extent from: oldExtent to: haloTarget extent.	].! !!CProjectBuilder methodsFor: 'halo' stamp: 'ar 3/26/2004 19:42'!onHaloViewer: aHandle	| haloTarget viewer |	<on: haloViewer>	haloTarget := self halo target.	hand shiftPressed ifTrue:[			viewer := CTileInspector open.		viewer target: (haloTarget player ifNil:[haloTarget]).	] ifFalse:[		CTileDefinition openDefaultViewerOn: (haloTarget player ifNil:[haloTarget]).	].! !!CProjectBuilder methodsFor: 'halo' stamp: 'ar 2/27/2004 18:37'!onPasteBorder: aPlayer	"Paste aPlayer (or one of its aspects) into the currently selected player"	self halo target ifNil:[^self].	#(borderStyle borderWidth borderColor) do:[:field|		self halo target tweak: field to: (aPlayer get: field).	].! !!CProjectBuilder methodsFor: 'halo' stamp: 'ar 4/2/2004 15:00'!onPasteEmbed: aPlayer	"Paste aPlayer (or one of its aspects) into the currently selected player"	| copy |	self halo target ifNil:[^self].	copy := aPlayer copy.	copy origin: 0@0.	self halo target add: copy.	self halo target: copy.! !!CProjectBuilder methodsFor: 'halo' stamp: 'ar 2/27/2004 18:37'!onPasteFill: aPlayer	"Paste aPlayer (or one of its aspects) into the currently selected player"	self halo target ifNil:[^self].	#(fillStyle fillColors fillAlpha fillAngle fillOffset) do:[:each|		self halo target tweak: each to: (aPlayer get: each).	].! !!CProjectBuilder methodsFor: 'halo' stamp: 'ar 3/27/2004 21:05'!onPasteGeometry: aPlayer	"Paste aPlayer (or one of its aspects) into the currently selected player"	| pos haloTarget |	(haloTarget := self halo target) ifNil:[^self].	pos := haloTarget position.	haloTarget tweak: #transform to: aPlayer transform.	haloTarget tweak: #localExtent to: aPlayer localExtent.	haloTarget tweak: #position to: pos.! !!CProjectBuilder methodsFor: 'halo' stamp: 'ar 3/24/2004 02:55'!onPasteLayout: aPlayer	"Paste aPlayer (or one of its aspects) into the currently selected player"	| haloTarget |	(haloTarget := self halo target) ifNil:[^self].	haloTarget tweak: #layout to: aPlayer layout copy.	haloTarget tweak: #hResizing to: aPlayer hResizing.	haloTarget tweak: #vResizing to: aPlayer vResizing.	haloTarget tweak: #layoutFrame to: aPlayer layoutFrame copy.! !!CProjectBuilder methodsFor: 'halo' stamp: 'ar 3/17/2004 11:44'!onPastePlayer: aPlayer	"Paste aPlayer (or one of its aspects) into the currently selected player"	| menu |	menu := CMenu new.	menu add: 'embed into' target: self action: #onPasteEmbed: argument: aPlayer.	menu addSeparator.	menu add: 'paste fill' target: self action: #onPasteFill: argument: aPlayer.	menu add: 'paste border' target: self action: #onPasteBorder: argument: aPlayer.	menu add: 'paste geometry' target: self action: #onPasteGeometry: argument: aPlayer.	menu addSeparator.	menu add: 'paste layout' target: self action: #onPasteLayout: argument: aPlayer.	menu label: aPlayer name.	menu openAt: self hand position.	menu run.! !!CProjectBuilder methodsFor: 'halo' stamp: 'ar 3/26/2004 21:19'!resize: aPlayer by: delta	| oldValue newValue parent |	oldValue := aPlayer extent.	parent := aPlayer container.	parent gridEnabled 		ifTrue:[newValue := oldValue + (delta * parent grid extent)]		ifFalse:[newValue := oldValue + delta].	aPlayer extent: newValue.	aPlayer tweaked: #extent from: oldValue to: newValue.! !!CProjectBuilder methodsFor: 'halo' stamp: 'tk 7/14/2004 11:28'!rotateHaloTarget: aTarget from: lastPt to: nextPt center: centerPt 	| dir1 dir2 deg sign |	lastPt = nextPt ifTrue:[^self].	dir1 := lastPt - centerPt.	dir2 := nextPt - centerPt.	dir1 isZero ifTrue:[^self].	dir2 isZero ifTrue:[^self].	dir1 := dir1 normalized.	dir2 := dir2 normalized.	sign := (dir1 crossProduct: dir2) sign.	deg := (dir1 dotProduct: dir2) arcCos radiansToDegrees.	aTarget asPrimCostume rotateBy: deg*sign.! !!CProjectBuilder methodsFor: 'halo' stamp: 'ar 4/2/2004 15:00'!trackHaloHandle: aHandle in: aBlock	"Track the given handle so that we can drag it"	| cursor lastPos nextPos |	lastPos := aHandle container localToGlobal: aHandle origin.	self world add: aHandle.	aHandle origin: lastPos.	self halo visible: false.	cursor := self hand mouseCursor.	self hand mouseCursor: cursor asForm.	lastPos := self hand position.	aHandle forEach: #mouseMove do:[		nextPos := self hand position.		aHandle costume moveBy: nextPos - lastPos.		lastPos := nextPos.		aBlock value.	] until: #mouseUp.	"Restore halo after interaction completed"	self halo add: aHandle.	self halo visible: true.	self hand mouseCursor: cursor.	self halo onGeometryChanged.! !!CProjectBuilder methodsFor: 'halo' stamp: 'ar 2/27/2004 18:39'!turn: anObject by: delta	| oldValue newValue |	oldValue := anObject angle.	newValue := oldValue + delta.	anObject angle: newValue.	anObject tweaked: #angle from: oldValue to: newValue.! !!CProjectBuilder methodsFor: 'halo' stamp: 'ar 1/7/2004 23:04'!waitHaloAction: aHandle	"Wait for a halo 'button action' to fire or abort"	| evt |	evt := self waitUntilAnyOf: {		aHandle. #fire.		aHandle. #abortFire.	}.	^evt selector == #fire! !!CProjectBuilder methodsFor: 'halo-menu' stamp: 'ar 3/24/2004 02:58'!addCellLayoutMenuItems: haloTarget to: aMenu	"Cell (e.g., child) related items"	| menu sub item |	menu := CMenu new.	sub := CMenu new.	#(rigid shrinkWrap spaceFill) do:[:sym|		item := sub add: sym target: haloTarget action: #tweak:to: arguments: {#hResizing. sym}.		item checked: (haloTarget hResizing == sym).	].	sub label: 'Resizing'.	menu add:'horizontal resizing' subMenu: sub.	sub := CMenu new.	#(rigid shrinkWrap spaceFill) do:[:sym|		item := sub add: sym target: haloTarget action: #tweak:to: arguments: {#vResizing. sym}.		item checked: (haloTarget vResizing == sym).	].	sub label: 'Resizing'.	menu add:'vertical resizing' subMenu: sub.	aMenu ifNotNil:[aMenu add: 'child options' subMenu: menu].	^menu! !!CProjectBuilder methodsFor: 'halo-menu' stamp: 'tk 7/14/2004 11:29'!addEmbeddingItems: target to: aMenu	| menu parent newParent newName |	parent := target container ifNil:[^self].	menu := CMenu new.	menu label: 'Embedding'.	(parent asPrimCostume 		contentsAt: target position 		behind: target asPrimCostume 		unlocked: true) reverseDo:[:m|			newParent := m asPlayer.			newName := (newParent componentBinding ifNil:[newParent]) name.			menu add: newName target: self 				action: #embed:into: arguments: {target. newParent}.	].	menu menuItems size = 0 ifTrue:[^self].	aMenu ifNotNil:[aMenu add: 'embed into' subMenu: menu].	^menu! !!CProjectBuilder methodsFor: 'halo-menu' stamp: 'ar 3/27/2004 21:00'!addLayoutMenuItems: haloTarget to: aMenu	| menu haloLayout item |	menu _ CMenu new.	menu label: 'Layout Options'.	haloLayout := haloTarget layout.	item := menu add: 'no layout' target: haloTarget action: #tweak:to: arguments:{#layout. nil}.	item checked: haloLayout isNil.	item := menu add: 'simple layout' target: haloTarget action: #tweak:to: arguments:{#layout. CSimpleLayout new}.	item checked: (haloLayout notNil and:[haloLayout isSimpleLayout]).	item := menu add: 'proportional layout' target: haloTarget action: #tweak:to: arguments:{#layout. CProportionalLayout new}.	item checked: (haloLayout notNil and:[haloLayout isProportionalLayout]).	item := menu add: 'table layout' target: haloTarget action: #tweak:to: arguments:{#layout. CTableLayout new}.	item checked: (haloLayout notNil and:[haloLayout isTableLayout]).	menu addSeparator.	self addCellLayoutMenuItems: haloTarget to: menu.	self addTableLayoutMenuItems: haloTarget to: menu.	menu label:'Layout'.	aMenu ifNotNil:[aMenu add: 'layout' subMenu: menu].	^menu! !!CProjectBuilder methodsFor: 'halo-menu' stamp: 'ar 3/27/2004 21:05'!addTableLayoutMenuItems: haloTarget to: aMenu	| menu sub item optName optValue targetLayout |	targetLayout := haloTarget layout ifNil:[^nil].	targetLayout isTableLayout ifFalse:[^nil].	menu := CMenu new.	menu add: 'change layout inset...' target: self		action: #onChangeLayoutInset: argument: haloTarget.	menu add: 'change cell inset...' target: self		action: #onChangeCellInset: argument: haloTarget.	menu  addSeparator.	#(		('reverse table cells' reverseTableCells)		('rubber band cells' rubberBandCells)	) do:[:opt|		optName := opt second.		optValue := targetLayout perform: optName.		item := menu add: opt first target: targetLayout action: #tweak:to: arguments:{optName. optValue not}.		item checked: optValue.	].	sub _ CMenu new.	#(leftToRight rightToLeft topToBottom bottomToTop) do:[:sym|		item := sub add: sym target: targetLayout action: #newListDirection: argument: sym.		item checked: (targetLayout listDirection == sym).	].	sub label: 'Direction'.	menu add: 'list direction' subMenu: sub.	sub _ CMenu new.	#(none leftToRight rightToLeft topToBottom bottomToTop) do:[:sym|		item := sub add: sym target: targetLayout action: #tweak:to: arguments:{#wrapDirection. sym}.		item checked: (targetLayout wrapDirection == sym).	].	sub label: 'Direction'.	menu add: 'wrap direction' subMenu: sub.	sub _ CMenu new.	#(center topLeft topRight bottomLeft bottomRight topCenter leftCenter rightCenter bottomCenter) do:[:sym|		item := sub add: sym target: targetLayout action: #tweak:to: arguments:{#cellPositioning. sym}.		item checked: (targetLayout cellPositioning == sym).	].	sub label: 'Position'.	menu add: 'cell positioning' subMenu: sub.	sub _ CMenu new.	#(topLeft bottomRight center justified) do:[:sym|		item := sub add: sym target: targetLayout action: #tweak:to: arguments:{#listCentering. sym}.		item checked: (targetLayout listCentering == sym).	].	sub label: 'Center'.	menu add: 'list centering' subMenu: sub.	sub _ CMenu new.	#(topLeft bottomRight center justified) do:[:sym|		item := sub add: sym target: targetLayout action: #tweak:to: arguments:{#wrapCentering. sym}.		item checked: (targetLayout wrapCentering == sym).	].	sub label: 'Center'.	menu add: 'wrap centering' subMenu: sub.	menu label: 'Table Layout'.	aMenu ifNotNil:[aMenu add: 'table options' subMenu: menu].	^menu! !!CProjectBuilder methodsFor: 'halo-menu' stamp: 'tk 7/14/2004 11:27'!embed: child into: newParent	| tfm |	tfm := child localToGlobal transformedBy: newParent globalToLocal.	child transform: tfm.	self flag: #partsHack.	"FIXME: This is an incredibly ugly hack to get the change notification right. I haven't quite thought about how to handle parts-change notification. So we will simply inform the costume about its contents change and this requires the following ugly hack. I NEED TO FIX THIS!!!!!!"	child container asPrimCostume tweaked: #contents after:[		newParent asPrimCostume tweaked: #contents after:[			newParent add: child.		].	].! !!CProjectBuilder methodsFor: 'halo-menu' stamp: 'ar 3/24/2004 03:04'!getHaloMenu: haloTarget	| menu aMenu |	menu := CMenu new.	menu label: (haloTarget name truncateTo: 30).	menu add: 'inspect' target: haloTarget action: #inspect.	aMenu := self getSaveCostumeMenu: haloTarget.	aMenu ifNotNil:[menu add: 'save costume for' subMenu: aMenu].	"aMenu := haloTarget getMessageMenu.	aMenu label: nil.	menu add: 'messages' subMenu: aMenu.	menu addSeparator."	menu add: 'tile for player' target: self		action: #getTileForPlayer: argument: haloTarget.	menu add: 'tile for value' target: self		action: #getTileForValue: argument: haloTarget.	menu add: 'grab me' target: self 		action: #grabObject: argument: haloTarget.	menu addSeparator.	menu add: 'send to back' target: self 		action: #sendToBack: argument: haloTarget.	menu add: 'come to front' target: self 		action: #sendToFront: argument: haloTarget.	self addEmbeddingItems: haloTarget to: menu.	menu addSeparator.	"self addFactoryItemsTo: menu."	self addLayoutMenuItems: haloTarget to: menu.	menu addSeparator.	^menu! !!CProjectBuilder methodsFor: 'halo-menu' stamp: 'ar 3/17/2004 11:44'!getSaveCostumeMenu: aPlayer	| target menu |	target := aPlayer player ifNil:[^nil].	menu := CMenu new.	menu label: 'Save Costume'.	[target == nil] whileFalse:[		menu add: target class name allButFirst target: self action: #saveCostume:for: arguments:{aPlayer. target}.		target := target player.	].	^menu! !!CProjectBuilder methodsFor: 'halo-menu' stamp: 'ar 3/25/2004 19:04'!getTileForPlayer: target! !!CProjectBuilder methodsFor: 'halo-menu' stamp: 'ar 3/25/2004 19:04'!getTileForValue: target! !!CProjectBuilder methodsFor: 'halo-menu' stamp: 'ar 3/25/2004 22:24'!onChangeCellInset: haloTarget	| inset |	inset := CDialog request: 'Cell Inset:' initialAnswer: haloTarget layout cellInset printString.	inset ifNil:[^self].	haloTarget layout tweak: #cellInset to: (Object readFrom: inset).! !!CProjectBuilder methodsFor: 'halo-menu' stamp: 'ar 3/25/2004 22:24'!onChangeLayoutInset: haloTarget	| inset |	inset := CDialog request: 'Layout Inset:' initialAnswer: haloTarget layoutInset printString.	inset ifNil:[^self].	haloTarget tweak: #layoutInset to: (Object readFrom: inset).! !!CProjectBuilder methodsFor: 'halo-menu' stamp: 'ar 2/23/2004 22:31'!onHaloMenu: aHandle	<on: haloMenu>	(self getHaloMenu: self halo target) openAt: self hand position.! !!CProjectBuilder methodsFor: 'halo-menu' stamp: 'ar 2/27/2004 18:46'!saveCostume: aCostume for: aPlayer	| maker |	"This doesn't work properly yet"	aPlayer player ifNotNil:[self halt: 'Check this'].	maker := CTweakMaker newFrom: aCostume.	maker allImportsDo:[:each|		each isBehavior ifFalse:[self error:'Cannot deal with this yet'].		each isUniClass ifTrue:[self error: 'Cannot deal with this yet'].	].	self halt.! !!CProjectBuilder methodsFor: 'halo-menu' stamp: 'ar 4/2/2004 15:01'!sendToBack: target	target container addFirst: target! !!CProjectBuilder methodsFor: 'halo-menu' stamp: 'ar 4/2/2004 15:00'!sendToFront: target	target container add: target! !!CProjectBuilder methodsFor: 'menu' stamp: 'ar 3/13/2004 17:06'!about	| info |	info := String streamContents:[:s|		s nextPutAll: 'Base version: ', Smalltalk version.		s cr; nextPutAll: 'Platform: ', Smalltalk platformName.		s cr; nextPutAll: 'Update level: ', SystemVersion current highestUpdate.		s cr.		s cr; nextPutAll: 'Memory used: ', (Smalltalk vmParameterAt: 3) asStringWithCommas.		s cr; nextPutAll: 'Memory free: ', (Smalltalk bytesLeft: false) asStringWithCommas.	].	CDialog inform: info label:'About Tweak!!'.! !!CProjectBuilder methodsFor: 'menu' stamp: 'ar 10/20/2003 19:33'!adjustWorldMenu	"Adjust the world menu after a geometry change in the receiver"	self worldMenu ifNil:[^self stopScript: #adjustWorldMenu]. "why bother"	self worldMenu left: 0.	self worldMenu width: self bounds width.! !!CProjectBuilder methodsFor: 'menu' stamp: 'ar 8/10/2004 15:57'!chooseUpdates: trackingVersion tag: menuTag	| item menu |	TweakUpdateStreamManager trackingVersion: trackingVersion.	item := worldMenu itemNamed: '?'.	item := item subMenu itemNamed: 'Choose updates...'.	menu := item subMenu.	menu menuItems do:[:mItem|		mItem checked: mItem label = menuTag.	].! !!CProjectBuilder methodsFor: 'menu' stamp: 'ar 3/25/2004 21:43'!debugMenu	| menu |	menu := CMenu new.	menu add: 'Refresh Display' target: self action: #refreshDisplay.	menu add: 'Restore Cursor' target: self action: #restoreCursor.	menu add: 'Restore World Menu' target: self action: #installWorldMenu.	menu addSeparator.	menu add: 'Collect Garbage' target: self action: #garbageCollect.	menu add: 'VM statistics' target: self action: #vmStatistics.	menu add: 'Start MessageTally' target: self action: #startMessageTally.	"more to come..."	^menu! !!CProjectBuilder methodsFor: 'menu' stamp: 'ar 2/7/2004 21:59'!displayDepth: bpp	self window displayDepth: bpp.	self onUpdateDisplayDepthMenu.! !!CProjectBuilder methodsFor: 'menu' stamp: 'ar 3/13/2004 15:52'!exportImage	| obj fileName file writer |	obj := self hand halo target.	obj ifNil:[^Smalltalk beep].	fileName := CFileSaveDialog openFile: #(		('PNG' ('*.png'))		('JPG' ('*.jpg' '*.jpeg'))		('GIF' ('*.gif'))		('BMP' ('*.bmp'))	) label: 'Export image'.	fileName ifNil:[^nil].	file := FileStream newFileNamed: fileName.	[file binary.		(file name endsWith: '.png') ifTrue:[writer := PNGReadWriter].		(file name endsWith: '.bmp') ifTrue:[writer := BMPReadWriter].		(file name endsWith: '.gif') ifTrue:[writer := GIFReadWriter].		(file name endsWith: '.jpg') ifTrue:[writer := JPEGReadWriter2].	writer := writer on: file.	writer nextPutImage: obj asForm] 		ensure:[file close].! !!CProjectBuilder methodsFor: 'menu' stamp: 'ar 3/25/2004 18:54'!exportObject	| obj fileName maker |	obj := self hand halo target.	obj ifNil:[^Smalltalk beep].	fileName := CFileSaveDialog openFile: #(			('Objects'	('*.sqp'))		) label: 'Export Object'.	fileName ifNil:[^self].	(fileName endsWith: '.zip') ifTrue:[		Cursor wait showWhile:[maker := CObjectMaker newFrom: obj].		maker name: 'project'.		maker saveTo: fileName.		^self].	Smalltalk beep.! !!CProjectBuilder methodsFor: 'menu' stamp: 'ar 3/17/2004 11:44'!fileMenu	| menu |	menu := CMenu new.	menu add: 'New Project...' target: self action: #newProject.	menu add: 'Open Project...' target: self action: #openProject.	menu add: 'Close Project' target: self action: #closeProject.	menu addSeparator.	menu add: 'Save Project' target: self action: #saveProject.	menu add: 'Save Project As...' target: self action: #saveProjectAs.	menu addSeparator.	menu add: 'Import Object...' target: self action: #importObject.	menu add: 'Export Object...' target: self action: #exportObject.	menu add: 'Export Image...' target: self action: #exportImage.	menu addSeparator.	menu add: 'Print' target: self action: #notYet disabled: true.	menu add: 'Page setup' target: self action: #notYet disabled: true.	menu addSeparator.	menu add: 'Quit' target: self action: #quit.	^menu! !!CProjectBuilder methodsFor: 'menu' stamp: 'ar 3/13/2004 17:13'!garbageCollect	"Collect garbage and report memory statistics"	| spaceUsed spaceLeft reserve info |	Smalltalk garbageCollect.	spaceLeft _ Smalltalk bytesLeft: false.	reserve _ Smalltalk bytesLeft: true.	spaceUsed _ Smalltalk vmParameterAt: 3.	info := String streamContents:[:s|		s nextPutAll: 'Used:	', spaceUsed asStringWithCommas, ' bytes'.		s cr; nextPutAll: 'Free:	', spaceLeft asStringWithCommas, ' bytes'.		s cr; nextPutAll: 'Swap: ', reserve asStringWithCommas, ' bytes'.	].	CDialog inform: info label: 'Memory statistics'.! !!CProjectBuilder methodsFor: 'menu' stamp: 'ar 8/10/2004 15:45'!helpMenu	| menu |	menu := CMenu new.	menu add: 'Load updates...' target: self action: #loadUpdates.	menu add: 'Choose updates...' subMenu: self updatesMenu.	menu addSeparator.	menu add: 'Release notes...' target: self action: #showReleaseNotes.	menu add: 'About...' target: self action: #about.	^menu! !!CProjectBuilder methodsFor: 'menu' stamp: 'ar 3/27/2004 22:32'!loadUpdates	TweakUpdateStreamManager loadUpdates.! !!CProjectBuilder methodsFor: 'menu' stamp: 'ar 10/20/2003 19:37'!memoryInfo	"Collect garbage and report memory statistics"	| spaceUsed spaceLeft reserve |	spaceLeft _ Smalltalk bytesLeft: false.	reserve _ Smalltalk bytesLeft: true.	spaceUsed _ Smalltalk vmParameterAt: 3.	^String streamContents:[:s|		s nextPutAll: 'Memory statistics:'; cr; cr.		s nextPutAll: 'Used:	', spaceUsed asStringWithCommas, ' bytes'; cr.		s nextPutAll: 'Free:	', spaceLeft asStringWithCommas, ' bytes'; cr; cr.		s nextPutAll: 'Reserve: ', reserve asStringWithCommas, ' bytes'; cr.	].! !!CProjectBuilder methodsFor: 'menu' stamp: 'ar 3/26/2004 04:07'!newWorldMenu	| menu |	menu := CMenuBar new.	menu add: 'File' subMenu: self fileMenu.	menu add: 'Tools' subMenu: self toolsMenu.	menu add: 'Widgets' subMenu: self widgetsMenu.	"menu add: 'Library' subMenu: self libraryMenu."	menu add: 'Options' subMenu: self optionMenu.	menu add: 'Debug' subMenu: self debugMenu.	menu add: '?' subMenu: self helpMenu.	^menu! !!CProjectBuilder methodsFor: 'menu' stamp: 'ar 3/29/2004 16:50'!onToolMenuItemsChanged	<on: changed in: toolMenuItems>	self installWorldMenu. "a cheap way out ;-)"! !!CProjectBuilder methodsFor: 'menu' stamp: 'tk 7/6/2004 17:10'!openColoredPlayer	"When the user asks for a Player, give it color so he can see it."		CPlayer new openColored.! !!CProjectBuilder methodsFor: 'menu' stamp: 'ar 3/25/2004 16:23'!openTool: aTool	aTool open.! !!CProjectBuilder methodsFor: 'menu' stamp: 'ar 3/26/2004 04:08'!openWidget: aClass	aClass openInHand.! !!CProjectBuilder methodsFor: 'menu' stamp: 'ar 3/17/2004 11:44'!optionMenu	| menu subMenu |	menu := CMenu new.	menu add: 'Project size' subMenu: (subMenu := CMenu new).	subMenu add: 'automatic' target: self action: #projectExtent: argument: #auto.	subMenu addSeparator.	{	1024@768.	800@600.	640@480	} do:[:pt|		subMenu 			add: pt x printString,'x', pt y printString			target: self action: #projectExtent: argument: pt.	].	subMenu addSeparator.	subMenu add: 'Other' target: self action: #chooseDisplayExtent.	self onUpdateProjectSizeMenu: subMenu.	menu add: 'Display depth' subMenu: (subMenu := CMenu new).	#(1 2 4 8 16 32) do:[:bpp|		subMenu 			add: bpp printString,' bpp' 			target: self 			action: #displayDepth: 			argument: bpp.	].	self onUpdateDisplayDepthMenu: subMenu.	^menu! !!CProjectBuilder methodsFor: 'menu' stamp: 'ar 3/25/2004 18:54'!saveToFile: aPlayer	| fileName |	fileName := CFileSaveDialog openFile: #(			('Player files'	('*.sqp'))		) label: 'Save Player'.	fileName ifNil:[^self].	Smalltalk beep.! !!CProjectBuilder methodsFor: 'menu' stamp: 'ar 3/28/2004 01:54'!showReleaseNotes	| ws |	ws := CWorkspace new.	ws contents: self class tcarReleaseNotes.	ws label: 'Release Notes'.	ws extent: 500@400.	ws openIn: self project.	ws position: 60@60.! !!CProjectBuilder methodsFor: 'menu' stamp: 'ar 3/25/2004 21:44'!startMessageTally	(self confirm: 'MessageTally will start now,and stop when the cursor goesto the top of the screen') ifFalse:[^nil].	MessageTally spyOnScript:[		[hand position y > 0] whileTrue:[self wait: 0.1]	].! !!CProjectBuilder methodsFor: 'menu' stamp: 'ar 3/29/2004 16:54'!toolsMenu	| menu |	menu := CMenu new.	menu menuItems contents: toolMenuItems.	^menu! !!CProjectBuilder methodsFor: 'menu' stamp: 'ar 8/10/2004 15:53'!updatesMenu	| menu itemName itemValue item |	menu := CMenu new.	{		{'Tweak-1.0 (fixes only)'. 'Tweak-1.0'}.		{'Tweak-1.1 (alpha)'. 'Tweak-1.1-alpha'}.	} do:[:spec|		itemName := spec first.		itemValue := spec last.		item := menu add: itemName target: self 				action: #chooseUpdates:tag: arguments: {itemValue. itemName}.		item checked: itemValue = TweakUpdateStreamManager trackingVersion.	].	^menu! !!CProjectBuilder methodsFor: 'menu' stamp: 'ar 3/13/2004 17:11'!vmStatistics	| ws |	ws := CWorkspace open.	ws codePane contents: Utilities vmStatisticsReportString.! !!CProjectBuilder methodsFor: 'menu' stamp: 'tk 7/6/2004 17:23'!widgetsMenu	| menu |	menu := CMenu new.	menu 		add: 'Player'		target: self 		action: #openColoredPlayer.	menu addSeparator.	{		{			CPushButton.			CRadioButton.			CImageButton.			CCheckBox.			CTabButton.		}.		{			CLabel.			CTextEditor.			CInputField.		}.		{			CList.			CDropDownList.			CSpinnerList.			CStringList.		}.		{			CSlider.			CScrollBar.			CScrollPane.			CSpinnerButtons.			CSpinner.			CWheelWidget.		}.		{			CWindow.			CUserDialog.			CFileOpenDialog.			CFileSaveDialog.		}.	} do:[:group|		group do:[:each| 			menu 				add: each name allButFirst 				target: self 				action: #openWidget: 				argument: each].	] separatedBy:[menu addSeparator].	^menu! !!CProjectBuilder methodsFor: 'display' stamp: 'ar 10/20/2003 19:42'!onUpdateDisplayDepthMenu	| item |	self worldMenu ifNil:[^self].	item := (self worldMenu itemNamed: 'Options') ifNil:[^self].	item := (item subMenu itemNamed: 'Display depth') ifNil:[^self].	self onUpdateDisplayDepthMenu: item subMenu.! !!CProjectBuilder methodsFor: 'display' stamp: 'ar 3/14/2004 13:51'!onUpdateDisplayDepthMenu: aMenu	| label item display |	display := self display.	#(1 2 4 8 16 32) do:[:bpp|		label := bpp printString,' bpp'.		item := aMenu itemNamed: label.		display ifNotNil:[			item enabled: (display supportsDisplayDepth: bpp).			item checked: (display depth = bpp).		].	].! !!CProjectBuilder methodsFor: 'display' stamp: 'ar 10/20/2003 19:43'!onUpdateDisplaySizeMenu	| item |	self worldMenu ifNil:[^self].	item := (self worldMenu itemNamed: 'Options') ifNil:[^self].	item := (item subMenu itemNamed: 'Display size') ifNil:[^self].	self onUpdateDisplaySizeMenu: item subMenu.! !!CProjectBuilder methodsFor: 'display' stamp: 'ar 10/20/2003 19:43'!onUpdateDisplaySizeMenu: aMenu	| item other label |	other := true.	{1024@768.	800@600.	640@480} do:[:pt|		label := pt x printString, 'x', pt y printString.		item := aMenu itemNamed: label.		item checked: self display extent = pt.		self display extent = pt ifTrue:[other := false].	].	aMenu menuItems last checked: other.	other ifTrue:[		label := self display width printString, 'x', self display height printString.		aMenu menuItems last label: 'Other (', label,')'.	] ifFalse:[		aMenu menuItems last label: 'Other ...'.	].! !!CProjectBuilder methodsFor: 'display' stamp: 'ar 10/20/2003 19:44'!onUpdateProjectSizeMenu	| item |	self worldMenu ifNil:[^self].	item := (self worldMenu itemNamed: 'Options') ifNil:[^self].	item := (item subMenu itemNamed: 'Project size') ifNil:[^self].	self onUpdateProjectSizeMenu: item subMenu.! !!CProjectBuilder methodsFor: 'display' stamp: 'ar 2/23/2004 14:39'!onUpdateProjectSizeMenu: aMenu	| item label done match |	done := false.	self project ifNil:[^self].	match := self project root hResizing == #spaceFill and:[self project root vResizing == #spaceFill].	item := aMenu itemNamed: 'automatic'.	item checked: match.	done := done or:[match].	{1024@768.	800@600.	640@480} do:[:pt|		match := false.		match := done not and:[self project root extent = pt].		done := done or:[match].		label := pt x printString, 'x', pt y printString.		item := aMenu itemNamed: label.		item checked: match.	].	aMenu menuItems last checked: done not.	done ifTrue:[		aMenu menuItems last label: 'Other ...'.	] ifFalse:[		label := self project root width printString, 'x', self project root height printString.		aMenu menuItems last label: 'Other (', label,')'.	].! !!CProjectBuilder methodsFor: 'display' stamp: 'ar 10/20/2003 19:50'!refreshDisplay	self invalidate.! !!CProjectBuilder methodsFor: 'display' stamp: 'ar 10/20/2003 19:50'!restoreCursor	self hand mouseCursor: Cursor normal.! !!CProjectBuilder methodsFor: 'events' stamp: 'ar 3/6/2004 16:55'!dropFile: fileStream	"The given file was just dropped onto me"	| types |	types _ fileStream mimeTypes.	(types anySatisfy:[:mimeType| mimeType beginsWith: 'image/']) ifTrue:[		(self importImageFrom: fileStream) asPlayer openIn: self project at: self project cursorPoint.	].! !!CProjectBuilder methodsFor: 'events' stamp: 'bf 7/23/2004 16:37'!onBlueButtonDown	| dragThreshold pos plr |	<on: #blueButtonDown>	self root ownerMorph ifNotNil:[		((plr _ self findPlayerAt: self cursorPoint) isNil			or: [plr == project and: [(project findPlayerAt: project cursorPoint) isNil]]) ifTrue: [			dragThreshold := 10. "pixels before drag"			pos := self hand position.			self hand halo rootContext: self project root asPrimCostume.			self hand forEach: #mouseMove do:[:event|				(self hand position dist: pos) > dragThreshold 					ifTrue:[^self hand halo onDragSelect: pos].			] until: #mouseUp.			^self root ownerMorph addHalo: World firstHand lastEvent		]	].	self hand halo rootContext: self project root asPrimCostume.	self hand halo onBlueButtonDown.! !!CProjectBuilder methodsFor: 'events' stamp: 'tk 7/14/2004 11:28'!onDrop: aPlayer	"If the project doesn't handle drops, handle them for it"	| tfm aCostume |	<on: dragDrop>	self project ifNil:[^aPlayer signal: #dropReject]. "no way, Jose"	aCostume := aPlayer asPrimCostume.	"Get player in child frame"	tfm := self project root globalToLocal composedWithLocal: aCostume localToGlobal.	aCostume transform: tfm.	self project root add: aPlayer.	"And inform it about the drop"	aPlayer signal: #dropped with: self project root.! !!CProjectBuilder methodsFor: 'events' stamp: 'ar 3/5/2004 17:33'!onDropFiles: anEvent	"Handle a number of dropped files from the OS."	| numFiles stream |	<on: dropFiles>	numFiles := anEvent contents.	1 to: numFiles do: [:i |		stream _ FileStream requestDropStream: i.		[self dropFile: stream] ensure:[stream close].	].! !!CProjectBuilder methodsFor: 'events' stamp: 'ar 3/24/2004 02:12'!onLayoutChanged	| box |	<on: layoutChanged>	box := self localBounds.	worldMenu topLeft: box topLeft.	worldMenu width: box width.	projectList topLeft: worldMenu fullBounds bottomLeft.	projectList height: box height - projectList top.	project ifNotNil:[		project topLeft: projectList topRight.		project extent: box extent - project topLeft.	].! !!CProjectBuilder methodsFor: 'events' stamp: 'bf 9/14/2004 11:52'!onMouseDown	| draggee |	<on: #mouseDown>	draggee := self costume dragChildAt: self cursorPoint.	(draggee notNil and:[draggee player == self project root]) ifTrue:[		draggee := self project root costume dragChildAt: self project root cursorPoint.	].	draggee ifNotNil:[^draggee onDrag].	"clicks on desktop remove halo and keyboard focus"	(hand keyboardFocus isNil and: [hand halo target isNil])		ifFalse: [			hand keyboardFocus: nil.			hand halo target: nil]		ifTrue: [			"pass event up"			self allContainersDo: [:parent |				(parent handlesEvent: #mouseDown) ifTrue:[					parent signal: #mouseDown.					(parent handlesEvent: #mouseUp) ifTrue: [						self forEach: #mouseMove							do: [parent signal: #mouseMove]							until: #mouseUp.						parent signal: #mouseUp]]]]! !!CProjectBuilder methodsFor: 'events' stamp: 'ar 4/2/2004 15:04'!onProjectChanged	| oldProject newProject |	<on: cursorChanged in: allProjects>	newProject := self allProjects selection.	oldProject := self project.	newProject == oldProject ifTrue:[^self].	self halo target: nil.	oldProject ifNotNil:[		oldProject makeThumbnail.		oldProject root ifNotNil:[oldProject root close].	].	self project: newProject.	newProject ifNotNil:[		"Put project at the bottom"		self addFirst: newProject root.	].! !!CProjectBuilder methodsFor: 'events' stamp: 'ar 10/20/2003 19:44'!onViewerClosed! !!CProjectBuilder methodsFor: 'events' stamp: 'ar 10/20/2003 19:45'!onViewerOpened! !!CProjectBuilder methodsFor: 'events' stamp: 'ar 10/20/2003 19:45'!onWindowChanged	<on: #windowChanged>	self stopScript: #onWindowResize.	self window ifNotNil:[		self startScript: #onWindowResize when:{self window. #geometryChanged}.	].! !!CProjectBuilder methodsFor: 'events' stamp: 'ar 3/14/2004 19:00'!onWindowResize	"My window has been resized"	self window ifNil:[^self].	self extent = self window extent ifFalse:[		self position: 0@0.		self extent: self window extent].! !!CProjectBuilder methodsFor: 'events' stamp: 'ar 3/14/2004 18:56'!onWindowUpdate"	<on: #geometryChanged>	self window ifNil:[^self].	self origin = (0@0) ifFalse:[		self window origin: self window origin + self origin.		self origin: 0@0.	].	self extent = self window extent ifFalse:[		self window extent: self extent.	]."! !!CProjectBuilder methodsFor: 'events' stamp: 'ar 4/2/2004 15:00'!onWorldMenuChanged	"Set aMenu as the world's menu bar"	<on: #worldMenuChanged>	self stopScript: #adjustWorldMenu.	self worldMenu ifNil:[^self].	self worldMenu hResizing: #rigid.	self worldMenu topLeft: 0@0.	"self worldMenu color: (Color gray: 0.9)."	self worldMenu border: ((CBorder complexFramed) width: 1; yourself).	self adjustWorldMenu.	self add: self worldMenu.	self startScript: #adjustWorldMenu when: {self. #geometryChanged}.! !!CProjectBuilder methodsFor: 'events' stamp: 'ar 3/23/2004 23:52'!onYellowButtonDown	"| target aPoint |	<on: #yellowButtonDown>	aPoint := self cursorPoint.	target := self costume contents detect:[:any| 		any locked not			and:[any visible 			and:[any sticky not			and:[any fullContainsPoint: aPoint]]]	] ifNone:[^self].	target onContextMenu"! !!CProjectBuilder methodsFor: 'tools' stamp: 'ar 4/3/2004 20:10'!newLibraryList	"Create a new list of items from my library"	| list |	list := CList new.	list itemMaker: CLibraryEntryCostume.	list items: self project library contents.	^list! !!CProjectBuilder methodsFor: 'tools' stamp: 'ar 4/3/2004 20:10'!newProjectList	| list |	list := CList new.	list allowDeselect: false.	list itemMaker: CProjectCostume.	list items: self allProjects.	^list! !!CProjectBuilder methodsFor: 'tools' stamp: 'ar 2/24/2004 23:11'!openLibraryList	self newLibraryList open! !!CProjectBuilder methodsFor: 'tools' stamp: 'ar 2/24/2004 23:11'!openProjectList	self newProjectList open.! !!CProjectBuilder methodsFor: 'media' stamp: 'ar 3/23/2004 19:17'!importImageFrom: aFile	| object aGraphic |	aFile binary.	Cursor read showWhile:[aGraphic := CImageResource readFrom: aFile].	object := CImagePlayer new.	object value: aGraphic.	object graphicForm: aGraphic.	object graphicFit: #stretch.	object extent: aGraphic extent.	object fill: nil.	object name: (aFile localName readStream upTo: $. ).	self project library save: object thumbnail: aGraphic.	^object! !!CProjectBuilder methodsFor: 'media' stamp: 'ar 3/14/2004 17:49'!importMovieFrom: file	| aSound object |	file binary.	Cursor read showWhile:[aSound := CMovieResource readFrom: file].	object := CSoundPlayer new.	object value: aSound.	object name: (file localName readStream upTo: $. ).	self project library save: object.	^object! !!CProjectBuilder methodsFor: 'media' stamp: 'ar 4/3/2004 13:56'!importObject	"Open a file"	| fileName file object objectTypes pictureTypes musicTypes movieTypes allTypes dialog |	objectTypes := #('*.zip' '*.sqp').	pictureTypes := #('*.gif' '*.jpg' '*.bmp' '*.png' '*.jpeg').	musicTypes := #('*.wav' '*.mp3' '*.au' '*.mid').	movieTypes := #('*.mpg' '*.jmv').	allTypes := objectTypes, pictureTypes, musicTypes, movieTypes.	dialog := CFileOpenDialog new.	dialog directory: (lastImportDirectory ifNil:[FileDirectory default]).	fileName := dialog openFile: {		{'All Media'. allTypes}.		{'Objects'. objectTypes}.		{'Pictures'. pictureTypes}.		{'Music'. musicTypes}.		{'Movies'. movieTypes}.	} label: 'Import Object'.	fileName ifNil:[^self].	lastImportDirectory := dialog directory.	file := FileStream readOnlyFileNamed: fileName.	[		(objectTypes any match: fileName) 			ifTrue:[object := self importObjectFrom: file].		(pictureTypes any match: fileName)			ifTrue:[object := self importImageFrom: file].		(musicTypes any match: fileName)			ifTrue:[object := self importSoundFrom: file].		(movieTypes any match: fileName)			ifTrue:[object := self importMovieFrom: file].	] ensure:[file close].	object ifNotNil:[object openInHand].! !!CProjectBuilder methodsFor: 'media' stamp: 'ar 3/14/2004 17:28'!importSoundFrom: file	| aSound object |	file binary.	Cursor read showWhile:[aSound := CSoundResource readFrom: file].	object := CSoundPlayer new.	object value: aSound.	object name: (file localName readStream upTo: $. ).	self project library save: object.	^object! !!CProjectCostume methodsFor: 'events' stamp: 'ar 3/25/2004 21:51'!onNameChanged	<on: nameChanged in: player>	label value: player name! !!CProjectCostume methodsFor: 'events' stamp: 'ar 3/17/2004 17:34'!onPlayerChanged	<on: playerChanged>	player ifNil:[^self].	self onNameChanged.	self onThumbnailChanged.! !!CProjectCostume methodsFor: 'events' stamp: 'ar 3/25/2004 21:52'!onThumbnailChanged	<on: thumbnailChanged in: player>	image graphic: player thumbnail.! !!CProjectCostume methodsFor: 'initialize' stamp: 'ar 3/23/2004 21:54'!deselect	dropShadow active: true.! !!CProjectCostume methodsFor: 'initialize' stamp: 'ar 3/22/2004 14:41'!initialize	super initialize.	self define: #image as: CPlayer new.	self define: #label as: CLabel new.! !!CProjectCostume methodsFor: 'initialize' stamp: 'ar 3/23/2004 21:54'!select	dropShadow active: false.! !!CProjectCostume methodsFor: 'initialize' stamp: 'ar 4/30/2004 15:58'!setupCostume	self add: image.	self add: label.	self dropShadowEnabled: true.	image graphicEnabled: true.	image graphicFit: #scale.	image clipping: true.	self layout: CTableLayout new.	self color: (Color gray: 0.9).	self borderStyle: #simple.	self borderWidth: 1.	self borderColor: Color black.	self roundCorners: true.	self extent: 80@60.! !!CProjectCostume methodsFor: 'accessing' stamp: 'ar 3/12/2004 16:26'!image	"Answer the image of the receiver"	<bewareOf: #imageChanged>	^self propertyValueAt: #image! !!CProjectCostume methodsFor: 'accessing' stamp: 'ar 3/12/2004 16:26'!image: aValue	"Modify the receiver's image"	^self propertyValueAt: #image put: aValue with: #imageChanged! !!CProjectCostume methodsFor: 'accessing' stamp: 'ar 3/12/2004 16:25'!label	"Answer the label of the receiver"	<bewareOf: #labelChanged>	^self propertyValueAt: #label! !!CProjectCostume methodsFor: 'accessing' stamp: 'ar 3/12/2004 16:25'!label: aValue	"Modify the receiver's label"	^self propertyValueAt: #label put: aValue with: #labelChanged! !!CProjectCostume methodsFor: 'accessing' stamp: 'ar 3/24/2004 23:35'!listItemValue: aValue	"See comment in listItemValue:"	^self player: aValue! !!CProjectLibrary methodsFor: 'saving' stamp: 'ar 3/15/2004 03:05'!save: aPlayer	^ self save: aPlayer thumbnail: nil! !!CProjectLibrary methodsFor: 'saving' stamp: 'ar 3/25/2004 19:23'!save: anObject as: makerName thumbnail: thumb	"Save the object under the given name, overwriting any present entry."	| newEntry binding oldEntry newMaker oldMaker newObject |	newMaker := CObjectMaker newFrom: anObject.	newMaker name: makerName.	"For now, try to capture any problems early on..."	newObject := newMaker next.	newObject isPlayer ifTrue:[		[newObject layoutNeeded] whileTrue:[			newObject fullBounds.			self waitTick]].	binding := self bindingOf: makerName.	binding ifNil:[		self define: makerName as: newMaker.		newMaker saveTemp.	] ifNotNil:[		oldMaker := binding value.		oldMaker saveTemp.		newMaker saveTemp.		[binding value: newMaker] 			on: AttemptToWriteReadOnlyGlobal 			do:[:ex| ex resume: true].		oldEntry := self contents detect:[:any| any itemFactory == oldMaker] ifNone:[nil].	].	newEntry := CLibraryEntry new.	newEntry value: newMaker.	newEntry image: (thumb ifNil:[newObject asForm]).	newEntry label: makerName.	newEntry library: self.	self contents replace: oldEntry with: newEntry.! !!CProjectLibrary methodsFor: 'saving' stamp: 'ar 3/15/2004 03:04'!save: aPlayer thumbnail: thumb	"Save aPlayer, overwriting any existing factory if it already exists"	| baseName existing makerName |	baseName := aPlayer name stemAndNumericSuffix first.	makerName := baseName,'Maker'.	"Look if the binding for the player already exists"	existing := self bindingOf: makerName.	existing ifNotNil:[		"We allow silently overwriting an existing entry if the new player came from the same maker (e.g., we just modified it). If it was created by a different maker, ask the user first, so not to accidentally overwrite some older entry."		aPlayer maker = existing value ifFalse:[			(CDialog confirm: 'Overwrite ''', baseName,'''?')				ifFalse:[^self].		].	].	^self save: aPlayer as: makerName thumbnail: thumb! !!CProjectLibrary methodsFor: 'lookup' stamp: 'ar 3/15/2004 20:52'!bindingOf: varName	^self componentNamed: varName! !!CProjectLibrary methodsFor: 'accessing' stamp: 'ar 3/17/2004 15:09'!contents	"This method was automatically generated"	<bewareOf: #contentsChanged>	^self propertyValueAt: #contents! !!CProjectLibrary methodsFor: 'accessing' stamp: 'ar 3/11/2004 14:22'!contents: aValue	"This method was automatically generated"	^self propertyValueAt: #contents put: aValue with: #contentsChanged! !!CProjectLibrary methodsFor: 'initialize' stamp: 'ar 3/17/2004 03:12'!initialize	super initialize.	self define: #contents as: CCollection new.! !!CProjectLoader methodsFor: 'import' stamp: 'ar 12/2/2003 21:47'!importClass: xmlNode	| id |	id := xmlNode attributeAt: 'id'.	^Smalltalk at: id asSymbol! !!CProjectLoader methodsFor: 'import' stamp: 'ar 12/2/2003 21:49'!importFont: xmlNode	| fontName fontSize fontEmphasis font |	fontName := xmlNode attributeAt: 'name'.	fontSize := xmlNode literalAt: 'size'.	fontEmphasis := xmlNode literalAt: 'emphasis'.	font := StrikeFont familyName: fontName size: fontSize emphasized: fontEmphasis.	font resourceID = (xmlNode attributeAt: 'id') ifFalse:[self error: 'oops?'].	^font! !!CProjectLoader methodsFor: 'import' stamp: 'ar 3/14/2004 17:27'!importForm: xmlNode	| uid aForm formClass w h d |	uid := UUID fromString: (xmlNode attributeAt: 'id').	aForm := CResourceManager default lookup: uid ifAbsent:[nil].	aForm ifNotNil:[^aForm].	formClass := Smalltalk at: (xmlNode attributeAt: 'class') asSymbol.	w := xmlNode literalAt: 'width'.	h := xmlNode literalAt: 'height'.	d := xmlNode literalAt: 'depth'.	aForm := CImageResource with: (formClass extent: w@h depth: d).	aForm name: (xmlNode attributeAt: 'name').	aForm type: (xmlNode attributeAt: 'type').	aForm url: (xmlNode attributeAt: 'url').	CResourceManager default at: uid put: aForm.	aForm extractResourceFrom: archive in: self.	^aForm! !!CProjectLoader methodsFor: 'import' stamp: 'ar 3/25/2004 19:22'!importLibrary: xmlNode	| id maker fileName mbr lib resID |	id := UUID fromString: (resID := xmlNode attributeAt: 'id').	resources at: resID put: (lib := CProjectLibrary new).	fileName := 'resources/library/', id asString,'/library.maker'.	mbr := archive members detect:[:any| any fileName = fileName].	maker := CObjectMaker new.	maker readFrom: mbr contentStream in: self.	lib updateFrom: maker next.	^lib! !!CProjectLoader methodsFor: 'import' stamp: 'ar 12/3/2003 00:45'!importObjectMaker: xmlNode	| id maker |	id := UUID fromString: (xmlNode attributeAt: 'id').	maker := CMaker withID: id.	maker ifNotNil:[^maker].	maker := CObjectMaker new.	maker uuid: id.	^maker extractResourceFrom: archive in: self.! !!CProjectLoader methodsFor: 'import' stamp: 'ar 12/2/2003 21:49'!importScripted: xmlNode	| id baseClass uniClass |	id := UUID fromString: (xmlNode attributeAt: 'id').	baseClass := Smalltalk at: (xmlNode attributeAt: 'extends') asSymbol.	uniClass := baseClass findUniClass: id.	uniClass ifNotNil:[^uniClass].	uniClass := baseClass newUniClass.	uniClass uuid: id.	^uniClass extractResourceFrom: archive in: self! !!CProjectLoader methodsFor: 'import' stamp: 'ar 12/3/2003 00:27'!loadResource: resID type: resType xmlNode: node	| provider resource |	resource := resources at: resID ifAbsent:[nil].	resource ifNotNil:[^resource].	notifier value: 'Loading ', ((node attributeAt: 'name') ifNil:['a ', resType, '(', resID,')']).	provider := CResource resourceProviderFor: resType.	resource := provider importXmlResource: node in: self.	resources at: resID put: resource.	^resource! !!CProjectLoader methodsFor: 'import' stamp: 'ar 12/2/2003 20:45'!registerResource: aResource id: resID	resources at: resID put: aResource! !!CProjectLoader methodsFor: 'interface' stamp: 'ar 12/7/2003 17:44'!readFrom: aStream notifying: bar	| member version projMaker |	"Check the version"	version := aStream next: 9.	version = 'Tweak-1.0' ifFalse:[^self error: 'Wrong version: ', version].	notifier := bar.	resources := Dictionary new.	archive := ZipArchive new.	archive readFrom: aStream.	"Load the contents of the project"	bar value: 'Loading project...'.	member := archive memberNamed: 'contents.maker'.	projMaker := CObjectMaker new readFrom: member contentStream in: self.	^projMaker next! !!CPropertyChange methodsFor: 'accessing' stamp: 'ar 2/10/2004 13:57'!value	^value! !!CPropertyChange methodsFor: 'accessing' stamp: 'ar 2/10/2004 13:57'!value: aValue	value := aValue! !!CPropertyChange methodsFor: 'as yet unclassified' stamp: 'tk 6/23/2004 10:39'!printOn: strm	super printOn: strm.  strm nextPut: $(.	value printOn: strm.  strm nextPut: $); space.! !!CProportionalLayout methodsFor: 'testing'!isProportionalLayout	^true! !!CProportionalLayout methodsFor: 'layout'!flushLayoutCache	"Flush any cached information associated with the receiver"	minExtentCache := nil.! !!CProportionalLayout methodsFor: 'layout'!layout: aMorph in: newBounds	"Compute the layout for the given morph based on the new bounds"	aMorph layoutTargets do:[:m| m layoutProportionallyIn: newBounds].! !!CProportionalLayout methodsFor: 'layout'!minExtentOf: aMorph in: newBounds	"Return the minimal size aMorph's children would require given the new bounds"	| min extent frame |	minExtentCache == nil ifFalse:[^minExtentCache].	min _ 0@0.	aMorph layoutTargets do:[:m|		"Map the minimal size of the child through the layout frame.		Note: This is done here and not in the child because its specific		for proportional layouts. Perhaps we'll generalize this for table		layouts but I'm not sure how and when."		extent _ m minExtent.		frame _ m layoutFrame.		frame ifNotNil:[extent _ frame minExtentFrom: extent].		min _ min max: extent].	^minExtentCache := min! !!CResource methodsFor: 'serialization' stamp: 'ar 2/24/2004 15:25'!allImportsDo: aBlock	^nil! !!CResource methodsFor: 'serialization' stamp: 'ar 2/24/2004 15:25'!allImportsDo: aBlock excluding: aSet	^nil! !!CResource methodsFor: 'serialization' stamp: 'ar 12/2/2003 14:51'!embedResourceIn: zipArchive	"Embed this resource in the given zip archive. 	Notes: 		1) All resources must be stored in a way that allows the reader to resolve the resource by uid if it has already been loaded before.		2) All resources must be stored under resources/<resource type>/.	It is recommended to implement this method by creating a separate directory for each resource with the uid as name and store the resource inside that directory. For example, images may be stored under 		resources/images/a1bd6f78-229e-6f48-84e1-90c7b25caccf/image.jpg	"	^self subclassResponsibility! !!CResource methodsFor: 'serialization' stamp: 'ar 12/2/2003 15:53'!embedResourceIn: zipArchive notifying: bar	bar ifNotNil:[bar value: 'Exporting ', self name,'...'].	^self embedResourceIn: zipArchive! !!CResource methodsFor: 'serialization' stamp: 'ar 12/2/2003 18:51'!exportXmlOn: xmlWriter	"When exporting an object that uses a shared resource, this method needs to write out an appropriate description of the receiver. This method should provide enough information for the loader to construct the resource even if it hasn't been loaded yet."	xmlWriter startTag: self resourceType.	xmlWriter attribute: 'id' value: self resourceID asString.	xmlWriter endEmptyTag: self resourceType.! !!CResource methodsFor: 'serialization' stamp: 'ar 12/2/2003 23:20'!resourceDirectory	"Helper to get a consistent location"	^'resources/', self resourceType,'/', self resourceID asString,'/'! !!CResource methodsFor: 'serialization' stamp: 'ar 12/2/2003 14:41'!serializeOn: aSerializer	^aSerializer writeResource: self! !!CResource methodsFor: 'accessing' stamp: 'ar 12/2/2003 14:31'!name	"Answer the name of this resource"	^self subclassResponsibility! !!CResource methodsFor: 'accessing' stamp: 'ar 12/7/2003 19:41'!resourceID	"Answer a unique ID for this resource"	| uid |	uid := CResourceManager default uidFor: self.	uid ifNil:[CResourceManager default at: (uid := UUID new) put: self].	^uid! !!CResource methodsFor: 'accessing' stamp: 'ar 12/2/2003 15:09'!resourceType	"Answer the type of this resource. Types must be unique across all resource types."	^self subclassResponsibility! !!CResource methodsFor: 'accessing' stamp: 'ar 12/2/2003 14:32'!resourceUrl	"Answer the URL for this resource"	^self subclassResponsibility! !!CMaker methodsFor: 'interface' stamp: 'ar 2/24/2004 14:57'!allImportsDo: aBlock	^self allImportsDo: aBlock excluding: IdentitySet new! !!CMaker methodsFor: 'interface' stamp: 'ar 2/24/2004 14:58'!allImportsDo: aBlock excluding: aSet	self importsDo:[:each|		(aSet includes: each) ifFalse:[			aSet add: each.			aBlock value: each.			each allImportsDo: aBlock excluding: aSet.		].	].! !!CMaker methodsFor: 'interface' stamp: 'ar 12/1/2003 21:50'!importsDo: aBlock	"Enumerate all the imports of the receiver"	^self subclassResponsibility! !!CMaker methodsFor: 'interface' stamp: 'ar 10/18/2003 21:36'!new	^self next! !!CMaker methodsFor: 'interface' stamp: 'ar 10/18/2003 21:36'!next	"Make a new object"	^self subclassResponsibility! !!CMaker methodsFor: 'interface' stamp: 'ar 11/18/2003 14:52'!nextVersionID	^nil! !!CMaker methodsFor: 'interface' stamp: 'ar 11/18/2003 14:52'!nextVersionID: aUUID! !!CMaker methodsFor: 'interface' stamp: 'ar 11/18/2003 14:52'!prevVersionID	^nil! !!CMaker methodsFor: 'interface' stamp: 'ar 11/18/2003 14:52'!prevVersionID: aUUID! !!CMaker methodsFor: 'interface' stamp: 'ar 11/18/2003 14:51'!saveTemp	"Save me to a temporary file"! !!CMaker methodsFor: 'exporting' stamp: 'ar 11/20/2003 14:04'!writeZipOn: archive	^self writeZipOn: archive as: self name,'.maker'! !!CMaker methodsFor: 'exporting' stamp: 'ar 12/2/2003 15:56'!writeZipOn: archive as: memberName	^self writeZipOn: archive as: memberName notifying: nil! !!CMaker methodsFor: 'exporting' stamp: 'ar 12/2/2003 15:55'!writeZipOn: archive as: memberName notifying: bar	| writer |	writer := XMLWriter on: (String new: 1000) writeStream.	bar ifNotNil:[bar value: 'Exporting ', self name,' ...'].	self exportXmlOn: writer.	archive 		addDeflateString: writer stream contents 		as: (memberName ifNil:[self name,'.maker']).	self embedResourceIn: archive notifying: bar.! !!CMaker methodsFor: 'converting' stamp: 'ar 11/17/2003 23:33'!asMaker	^self! !!CMaker methodsFor: 'importing' stamp: 'ar 11/21/2003 19:03'!importXMLContentsFrom: xmlNode including: makers	^self subclassResponsibility! !!CMaker methodsFor: 'importing' stamp: 'ar 12/8/2003 15:09'!importXMLFrom: xmlNode in: loader	| prior type uuid |	uuid := UUID fromString: (xmlNode attributeAt: 'id').	prior := CResourceManager default lookup: uuid.	prior ifNotNil:[^prior].	type := Smalltalk at: (xmlNode attributeAt: 'type') asSymbol.	type == self class ifFalse:[^type new importXMLFrom: xmlNode in: loader].	"Need to pre-register for cyclic references"	self name: (xmlNode attributeAt: 'name').	self uuid: uuid.	CResourceManager default at: uuid put: self.	[self importXMLContentsFrom: xmlNode in: loader] 		ifCurtailed:[			(CResourceManager default at: uuid) == self ifTrue:[				CResourceManager default at: uuid put: nil.			].		].! !!CMaker methodsFor: 'accessing' stamp: 'ar 12/2/2003 15:28'!resourceUrl	"Answer the URL for this resource"	^nil! !!CMaker methodsFor: 'private-factory' stamp: 'ar 11/18/2003 18:44'!basicNew	^self rootClass basicNew! !!CMaker methodsFor: 'private-factory' stamp: 'ar 11/18/2003 18:45'!basicNew: n	^self rootClass basicNew: n! !!CMaker methodsFor: 'private-factory' stamp: 'ar 10/18/2003 21:36'!rootClass	"Answer the class of the root object."	^self subclassResponsibility! !!CMaker methodsFor: 'printing' stamp: 'ar 11/18/2003 21:35'!printOn: aStream	aStream nextPutAll: self name asString.! !!CMaker methodsFor: 'testing' stamp: 'ar 11/18/2003 16:54'!isClassMaker	^false! !!CMaker methodsFor: 'serializing' stamp: 'ar 12/10/2003 00:16'!serializeOn: aSerializer	^super serializeOn: aSerializer! !!CMediaResource methodsFor: 'accessing' stamp: 'ar 3/14/2004 17:05'!name	^name! !!CMediaResource methodsFor: 'accessing' stamp: 'ar 3/14/2004 17:05'!name: aString	name := aString! !!CMediaResource methodsFor: 'accessing' stamp: 'ar 3/14/2004 17:06'!resourceUrl	"Answer the URL for this resource"	^url! !!CMediaResource methodsFor: 'accessing' stamp: 'ar 3/14/2004 17:05'!type	^type! !!CMediaResource methodsFor: 'accessing' stamp: 'ar 3/14/2004 17:05'!type: mediaType	type := mediaType! !!CMediaResource methodsFor: 'accessing' stamp: 'ar 3/14/2004 17:06'!url	^url! !!CMediaResource methodsFor: 'accessing' stamp: 'ar 3/14/2004 17:06'!url: aUrl	url := aUrl! !!CMediaResource methodsFor: 'printing' stamp: 'ar 3/14/2004 17:07'!printOn: aStream	aStream nextPutAll: self class name; nextPut:$(; print: self name; nextPut: $).! !!CMediaResource methodsFor: 'serialization' stamp: 'ar 3/14/2004 17:51'!embedResourceIn: zipArchive	"Yeah, okay it sucks. I'm gonna fix that at some point but right now I need something that works. We want to embed the file contents if it's a local file, we want to provide a url if it's a remote one and we want to write the raw contents if it's neither one."	| file aStream |	(zipArchive hasMemberSuchThat:[:mbr| mbr fileName beginsWith: self resourceDirectory])		ifTrue:[^self].	"Try to get the original contents and store that."	(file := self resourceFileStream) ifNotNil:[		[zipArchive addString: file contents as: self resourceDirectory, self name] 			ensure:[file close].	] ifNil:[		"Simply store the form data in raw form"		aStream := (ByteArray new: 1000) writeStream.		self storeRawMediaContentsOn: aStream.		zipArchive 			addDeflateString: aStream contents 			as: self resourceDirectory, self name, self rawMediaExtension.	].! !!CMediaResource methodsFor: 'serialization' stamp: 'ar 3/14/2004 17:11'!exportXmlOn: xmlWriter	"When exporting an object that uses a shared resource, this method needs to write out an appropriate description of the receiver. This method should provide enough information for the loader to construct the resource even if it hasn't been loaded yet."	xmlWriter startTag: self resourceType.	xmlWriter attribute: 'id' value: self resourceID asString.	"ResourceForm attributes"	name ifNotNil:[xmlWriter attribute: 'name' value: name].	type ifNotNil:[xmlWriter attribute: 'type' value: type].	url ifNotNil:[xmlWriter attribute: 'url' value: url].	self storeXmlMediaAttributesOn: xmlWriter.	xmlWriter endEmptyTag: self resourceType.! !!CMediaResource methodsFor: 'serialization' stamp: 'ar 3/14/2004 17:13'!extractResourceFrom: zipArchive in: loader	| mbr |	mbr := zipArchive members detect:[:any| any fileName beginsWith: self resourceDirectory].	self extractMediaFrom: mbr.! !!CMediaResource methodsFor: 'serialization' stamp: 'ar 3/14/2004 17:13'!resourceFileStream	"Answer the file stream for a file url.	@@@@ TODO: We really should be checking the modification date of the file and possibly a check sum. If the file changes we're going to embed the wrong one ho, hum. @@@@"	| fileUrl |	fileUrl := url asUrl.	(fileUrl isKindOf: FileUrl) ifFalse:[^nil].	^[FileStream readOnlyFileNamed: fileUrl pathForFile] 		on: FileDoesNotExistException do:[:ex| ex return: nil].! !!CMediaResource methodsFor: 'private' stamp: 'ar 3/14/2004 17:13'!extractMediaFrom: mbr	"Extract media from the given archive member"	^self subclassResponsibility! !!CMediaResource methodsFor: 'private' stamp: 'ar 3/14/2004 17:12'!rawMediaExtension	"Answer the (extra!!) extension to use if we store raw media resources"	^self subclassResponsibility! !!CMediaResource methodsFor: 'private' stamp: 'ar 3/14/2004 17:23'!setMedia: media	^self subclassResponsibility! !!CMediaResource methodsFor: 'private' stamp: 'ar 3/14/2004 17:12'!storeRawMediaContentsOn: aStream	"Store raw media contents on aStream if the original media is inaccessible"	^self subclassResponsibility! !!CMediaResource methodsFor: 'private' stamp: 'ar 3/14/2004 17:12'!storeXmlMediaAttributesOn: xmlWriter	^self subclassResponsibility! !!CImageResource methodsFor: 'accessing' stamp: 'ar 12/2/2003 15:47'!resourceType	"Answer the type of this resource. Types must be unique across all resource types."	^#image! !!CImageResource methodsFor: 'Form-support' stamp: 'ar 3/23/2004 19:34'!asPlayer	^(CPlayer new) 		graphicForm: self;		extent: self extent;		value: self; 		name: (self name readStream upTo: $.);		yourself! !!CImageResource methodsFor: 'Form-support' stamp: 'ar 12/2/2003 15:05'!boundingBox	^form boundingBox! !!CImageResource methodsFor: 'Form-support' stamp: 'ar 12/2/2003 15:07'!colormapIfNeededFor: destForm	^form colormapIfNeededFor: destForm! !!CImageResource methodsFor: 'Form-support' stamp: 'ar 12/2/2003 15:06'!depth	^form depth! !!CImageResource methodsFor: 'Form-support' stamp: 'ar 12/2/2003 15:07'!drawOn: aCanvas in: box	^form drawOn: aCanvas in: box! !!CImageResource methodsFor: 'Form-support' stamp: 'bf 4/3/2004 00:19'!drawOn: aCanvas in: box sourceRect: src	^form drawOn: aCanvas in: box sourceRect: src! !!CImageResource methodsFor: 'Form-support' stamp: 'ar 12/2/2003 15:06'!extent	^form extent! !!CImageResource methodsFor: 'Form-support' stamp: 'ar 12/2/2003 15:06'!height	^form height! !!CImageResource methodsFor: 'Form-support' stamp: 'ar 12/2/2003 16:19'!isForm	^true! !!CImageResource methodsFor: 'Form-support' stamp: 'ar 12/2/2003 15:06'!isOpaque	^form isOpaque! !!CImageResource methodsFor: 'Form-support' stamp: 'ar 12/2/2003 15:06'!offset	^form offset! !!CImageResource methodsFor: 'Form-support' stamp: 'ar 12/2/2003 15:07'!width	^form width! !!CImageResource methodsFor: 'private' stamp: 'ar 12/2/2003 15:05'!asSourceForm	^form! !!CImageResource methodsFor: 'private' stamp: 'ar 3/14/2004 17:17'!extractMediaFrom: mbr	"Extract media from the given archive member"	| stream newForm |	stream := mbr contentStream.	stream binary.	(mbr fileName endsWith: '.form') 		ifTrue:[^form readResourceContentsFrom: stream].	newForm := ImageReadWriter formFromStream: stream.	(newForm extent = self extent and:[newForm depth = self depth]) 		ifFalse:[self error: 'wrong form'].	form := newForm.! !!CImageResource methodsFor: 'private' stamp: 'ar 3/14/2004 17:17'!rawMediaExtension	"Answer the (extra!!) extension to use if we store raw media resources"	^'.form'! !!CImageResource methodsFor: 'private' stamp: 'ar 3/14/2004 17:23'!setMedia: media	form := media! !!CImageResource methodsFor: 'private' stamp: 'ar 3/14/2004 17:17'!storeRawMediaContentsOn: aStream	"Store raw media contents on aStream if the original media is inaccessible"	form storeResourceContentsOn: aStream.! !!CImageResource methodsFor: 'private' stamp: 'ar 3/14/2004 17:18'!storeXmlMediaAttributesOn: xmlWriter	"Basic form attributes"	xmlWriter attribute: 'width' value: self width asString.	xmlWriter attribute: 'height' value: self height asString.	xmlWriter attribute: 'depth' value: self depth asString.	xmlWriter attribute: 'class' value: form class name.! !!CMovieResource methodsFor: 'accessing' stamp: 'ar 3/14/2004 17:28'!resourceType	"Answer the type of this resource. Types must be unique across all resource types."	^#movie! !!CMovieResource methodsFor: 'private' stamp: 'ar 3/14/2004 17:30'!extractMediaFrom: mbr	"Extract media from the given archive member"	| stream file |	stream := mbr contentStream.	stream binary.	"We need to extract movies first since we can only play straight from file"	file := self extractToCache: stream.	[movie := self class readFrom: file type: type] ensure:[file close].! !!CMovieResource methodsFor: 'private' stamp: 'ar 3/14/2004 17:30'!rawMediaExtension	"Currently unsupported"	^''! !!CMovieResource methodsFor: 'private' stamp: 'ar 3/14/2004 17:31'!setMedia: media	movie := media! !!CMovieResource methodsFor: 'private' stamp: 'ar 3/14/2004 17:31'!storeRawMediaContentsOn: aStream	"Currently unsupported"	^self error:'Not implemented'! !!CMovieResource methodsFor: 'private' stamp: 'ar 3/14/2004 17:31'!storeXmlMediaAttributesOn: xmlWriter	"Basic movie attributes"! !!CObjectMaker methodsFor: 'interface' stamp: 'ar 12/1/2003 21:50'!importsDo: aBlock	"Enumerate all the imports of the receiver"	^imports do: aBlock! !!CObjectMaker methodsFor: 'interface' stamp: 'ar 2/14/2004 22:05'!newFrom: anObject	"Create a new factory based on the given object"	| serializer |	name ifNil:[name := (anObject name truncateTo: 100), 'Maker'].	serializer := self newSerializer.	parts := serializer serialize: anObject.	imports := serializer imports asArray.	parts first partID ifNil:[parts first partID: UUID new]! !!CObjectMaker methodsFor: 'interface' stamp: 'ar 3/24/2004 00:51'!next	"Answer the next object from this factory"	| result |false ifTrue:[	"Create the individual objects"	parts do:[:aPart| aPart createPartIn: self].	"Construct the parts, reading in the appropriate fields."	parts do:[:aPart| aPart constructPartIn: self].].	result := parts first valueInMaker: self.	"Finally, finish creation."	parts do:[:aPart| 		aPart postBuildIn: self.	].	^result! !!CObjectMaker methodsFor: 'interface' stamp: 'ar 12/3/2003 14:10'!saveOn: aFile	| archive writer |	archive := ZipArchive new.	archive addString: 'Tweak-1.0' as: 'version'.	Utilities informUserDuring:[:bar|		Cursor read showWhile:[			bar value: 'Exporting project...'.			writer := XMLWriter on: (String new: 1000) writeStream.			bar value: 'Exporting project...'.			self exportXmlContentsOn: writer.			archive 				addDeflateString: writer stream contents 				as: 'contents.maker'.			self imports do:[:each| each embedResourceIn: archive notifying: bar].		].		bar value: 'Saving project file...'.		Cursor write showWhile:[			archive writeTo: aFile		].	].! !!CObjectMaker methodsFor: 'interface' stamp: 'ar 12/7/2003 15:07'!saveTo: fileName	| archive writer |	archive := ZipArchive new.	Utilities informUserDuring:[:bar|		Cursor read showWhile:[			bar value: 'Exporting project...'.			writer := XMLWriter on: (String new: 1000) writeStream.			bar value: 'Exporting project...'.			self exportXmlContentsOn: writer.			archive 				addDeflateString: writer stream contents 				as: 'contents.maker'.			self imports do:[:each| each embedResourceIn: archive notifying: bar].		].		bar value: 'Saving project file...'.		Cursor write showWhile:[			archive writeToFileNamed: fileName prepending: 'Tweak-1.0'.		].	].! !!CObjectMaker methodsFor: 'importing' stamp: 'ar 12/3/2003 00:37'!extractResourceFrom: archive in: loader	"Create a new factory from the given stream"	| mbr |	mbr := archive members detect:[:any| any fileName beginsWith: self resourceDirectory].	^self readFrom: mbr contentStream in: loader! !!CObjectMaker methodsFor: 'importing' stamp: 'ar 12/2/2003 21:44'!readFrom: aStream in: loader	"Create a new factory from the given stream"	| xmlDoc root |	aStream ascii.	xmlDoc := XMLDOMParser parseDocumentFrom: aStream.	root := xmlDoc elements first.	root name = 'maker' ifFalse:[^self error: 'wrong type'].	^self importXMLFrom: root in: loader! !!CObjectMaker methodsFor: 'private-factory' stamp: 'ar 2/14/2004 22:26'!constructObjectFrom: aPart	| reader |	reader := self newDeserializer.	reader objectMaker: self.	reader readObjectFrom: aPart.! !!CObjectMaker methodsFor: 'private-factory' stamp: 'ar 10/18/2003 21:39'!createPart: aPart	| result |	aPart createPartIn: self.	aPart constructPartIn: self.	result := aPart fieldValueIn: self.	aPart postBuildIn: self.	^result! !!CObjectMaker methodsFor: 'private-factory' stamp: 'ar 2/14/2004 21:55'!makeNewPart: partMaker	^partMaker basicNew! !!CObjectMaker methodsFor: 'private-factory' stamp: 'ar 2/14/2004 21:56'!makeNewPart: partMaker size: sz	^partMaker basicNew: sz! !!CObjectMaker methodsFor: 'private-factory' stamp: 'ar 10/18/2003 21:39'!partWithID: pid	^parts detect:[:any| any partID = pid] ifNone:[nil]! !!CObjectMaker methodsFor: 'private-factory' stamp: 'ar 11/18/2003 18:46'!rootClass	^parts first partMaker! !!CObjectMaker methodsFor: 'private-factory' stamp: 'ar 10/18/2003 21:39'!rootField	^parts first! !!CObjectMaker methodsFor: 'accessing' stamp: 'ar 2/14/2004 22:06'!importXMLContentsFrom: xmlNode in: loader	| result |	result := self newImporter importFrom: xmlNode in: loader.	imports := result imports.	parts := result parts.! !!CObjectMaker methodsFor: 'accessing' stamp: 'ar 11/21/2003 16:13'!imports	^imports! !!CObjectMaker methodsFor: 'accessing' stamp: 'ar 11/21/2003 16:13'!imports: aSet	imports := aSet! !!CObjectMaker methodsFor: 'accessing' stamp: 'ar 10/18/2003 21:37'!name	^name! !!CObjectMaker methodsFor: 'accessing' stamp: 'ar 10/18/2003 21:37'!name: aString	name := aString! !!CObjectMaker methodsFor: 'accessing' stamp: 'ar 10/18/2003 21:37'!nextVersion	^nextVersion! !!CObjectMaker methodsFor: 'accessing' stamp: 'ar 10/18/2003 21:38'!nextVersion: aMaker	nextVersion := aMaker.! !!CObjectMaker methodsFor: 'accessing' stamp: 'ar 10/18/2003 21:38'!prevVersion	^prevVersion! !!CObjectMaker methodsFor: 'accessing' stamp: 'ar 10/18/2003 21:38'!prevVersion: aMaker	prevVersion := aMaker.! !!CObjectMaker methodsFor: 'accessing' stamp: 'ar 12/2/2003 15:46'!resourceType	^#maker! !!CObjectMaker methodsFor: 'accessing' stamp: 'ar 12/1/2003 20:52'!saveFullOn: aStream	"Save the updates on the given stream"	| writer |	writer := XMLWriter on: aStream.	self exportXmlOn: writer.! !!CObjectMaker methodsFor: 'accessing' stamp: 'ar 11/14/2003 21:04'!saveFullTo: fileName	"Save the updates on the given stream"	| file |	file := FileStream newFileNamed: fileName.	[self saveFullOn: file] ensure:[file close].! !!CObjectMaker methodsFor: 'accessing' stamp: 'ar 11/19/2003 19:06'!saveZipTo: fileName	"Save the updates on the given stream"	| file zip |	file := FileStream newFileNamed: fileName.	zip := GZipWriteStream on: file.	self saveFullOn: zip.	zip close.! !!CObjectMaker methodsFor: 'accessing' stamp: 'ar 11/18/2003 16:01'!uuid	^uuid ifNil:[uuid := UUID new]! !!CObjectMaker methodsFor: 'accessing' stamp: 'ar 12/3/2003 00:42'!uuid: newID	uuid = newID ifTrue:[^self].	uuid ifNotNil:[self error:'Cannot change uuid'].	uuid := newID.! !!CObjectMaker methodsFor: 'exporting' stamp: 'ar 12/2/2003 15:55'!embedResourceIn: zipArchive	^self embedResourceIn: zipArchive notifying: nil! !!CObjectMaker methodsFor: 'exporting' stamp: 'ar 12/2/2003 23:21'!embedResourceIn: zipArchive notifying: bar	| writer |	(zipArchive hasMemberSuchThat:[:mbr| mbr fileName beginsWith: self resourceDirectory])		ifTrue:[^self].	bar ifNotNil:[bar value: 'Exporting ', self name,'...'].	writer := XMLWriter on: (String new: 1000) writeStream.	self exportXmlContentsOn: writer.	zipArchive addDeflateString: writer stream contents as: self resourceDirectory, self name, '.maker'.	imports do:[:each| each embedResourceIn: zipArchive notifying: bar].! !!CObjectMaker methodsFor: 'exporting' stamp: 'ar 2/14/2004 22:13'!exportXmlContentsOn: writer	"Save the updates on the given stream"	writer startTag: self makerType.	writer attribute: 'type' value: self class name.	writer attribute: 'id' value: self uuid asString.	writer attribute: 'name' value: (self name ifNil:['']).	writer attribute: 'endianness' value: Smalltalk endianness.	writer endTag.	writer startTag: 'resources'; endTag.		imports do:[:each| each exportXmlOn: writer].	writer endTag: 'resources'.	writer startTag: 'parts'; endTag.		parts do:[:each| each exportXmlOn: writer].	writer endTag: 'parts'.	writer endTag: self makerType.! !!CObjectMaker methodsFor: 'exporting' stamp: 'ar 12/2/2003 14:13'!resourceID	^self uuid! !!CObjectMaker methodsFor: 'private-defaults' stamp: 'ar 2/14/2004 22:13'!makerType	^'maker'! !!CObjectMaker methodsFor: 'private-defaults' stamp: 'ar 2/14/2004 21:53'!newDeserializer	^CObjectMakerDeserializer new! !!CObjectMaker methodsFor: 'private-defaults' stamp: 'ar 2/14/2004 22:06'!newImporter	^CObjectMakerImporter new! !!CObjectMaker methodsFor: 'private-defaults' stamp: 'ar 2/14/2004 22:05'!newSerializer	^CObjectMakerSerializer new! !!CResourceManager methodsFor: 'accessing' stamp: 'ar 12/7/2003 19:39'!at: uid	^resources at: uid ifAbsent:[nil].! !!CResourceManager methodsFor: 'accessing' stamp: 'ar 12/7/2003 19:39'!at: uid put: anObject	resources at: uid put: anObject.	^uid! !!CResourceManager methodsFor: 'accessing' stamp: 'ar 12/2/2003 20:56'!lookup: uid	^self lookup: uid ifAbsent:[nil].! !!CResourceManager methodsFor: 'accessing' stamp: 'ar 12/3/2003 18:46'!lookup: uid ifAbsent: aBlock	^(resources at: uid ifAbsent:[nil]) ifNil: aBlock! !!CResourceManager methodsFor: 'accessing' stamp: 'ar 12/7/2003 19:38'!lookup: uid ifAbsentPut: aBlock	self lookup: uid ifAbsent:[resources at: uid put: aBlock value].! !!CResourceManager methodsFor: 'accessing' stamp: 'ar 12/7/2003 19:38'!uidFor: anObject	^self uidFor: anObject ifAbsent:[nil]! !!CResourceManager methodsFor: 'accessing' stamp: 'ar 12/7/2003 19:38'!uidFor: anObject ifAbsent: aBlock	resources keysAndValuesDo:[:uid :value|		value == anObject ifTrue:[^uid].	].	^aBlock value! !!CResourceManager methodsFor: 'initialize' stamp: 'ar 12/3/2003 18:45'!initialize	resources := WeakValueDictionary new.! !!CRootMorph methodsFor: 'event handling' stamp: 'bf 10/1/2004 17:14'!handleEvent: anEvent	| evt |	(#(mouseDown mouseUp mouseMove mouseEnter mouseLeave	keyDown keyUp keystroke	dropFilesEvent) includes: anEvent type) ifTrue:[		(anEvent isMouse) ifTrue:[			anEvent hand keyboardFocus: self.			anEvent isMouseDown ifTrue:[				anEvent hand mouseFocus: self.				self comeToFront].			anEvent isMouseUp ifTrue:[				anEvent hand releaseMouseFocus: self.			].		].		"pass it into myWorld"		evt := anEvent translatedBy: self innerBounds origin negated.		evt type == #mouseMove ifTrue:[				evt setTrail: (evt trail collect:[:pt| pt - bounds origin]).		].		"evt printString displayAt: 0@0."		myWorld eventQueue nextPut: evt.		anEvent wasHandled: true.		^true].	^super handleEvent: anEvent! !!CRootMorph methodsFor: 'event handling' stamp: 'ar 12/8/2002 01:51'!handlerForMouseDown: anEvent	^self! !!CRootMorph methodsFor: 'event handling' stamp: 'ar 12/8/2002 02:57'!handlesMouseOver: evt	^true! !!CRootMorph methodsFor: 'event handling' stamp: 'ar 12/8/2002 02:57'!mouseEnter: evt	evt hand newKeyboardFocus: self.! !!CRootMorph methodsFor: 'geometry' stamp: 'ar 7/15/2003 20:44'!extent: newExtent	super extent: newExtent.	myWorld ifNotNil:[myWorld startScript: #displayExtent: withArguments:{self innerBounds extent}].! !!CRootMorph methodsFor: 'drawing' stamp: 'ar 12/19/2002 05:46'!areasRemainingToFill: aRectangle	(color isColor and: [color isTranslucent]) ifTrue: [^ Array with: aRectangle].	self wantsRoundedCorners		ifTrue: [^ aRectangle areasOutside: self boundsWithinCorners]		ifFalse: [^ aRectangle areasOutside: self bounds]! !!CRootMorph methodsFor: 'drawing' stamp: 'ar 7/15/2003 20:45'!drawOn: aCanvas	aCanvas fillRectangle: self bounds fillStyle: Color transparent borderStyle: self borderStyle.	aCanvas clipBy: self innerBounds during:[:cc|		cc drawImage: myWorld display at: (self innerBounds origin).	].! !!CRootMorph methodsFor: 'stepping' stamp: 'ar 7/15/2003 20:41'!step	| rectList priorHand offset |	priorHand := ActiveHand.	rectList := myWorld runMorphicCycle.	ActiveHand := priorHand.	offset := self innerBounds origin.	rectList do:[:dmgRect|		self invalidRect: (dmgRect translateBy: offset).	].! !!CRootMorph methodsFor: 'stepping' stamp: 'ar 8/17/2003 16:04'!stepAt: millisecondClockValue in: aWindow	"do nothing"! !!CRootMorph methodsFor: 'stepping' stamp: 'ar 9/8/2003 21:10'!stepTime	^20! !!CRootMorph methodsFor: 'stepping' stamp: 'ar 12/8/2002 00:59'!wantsSteps	^true! !!CRootMorph methodsFor: 'accessing' stamp: 'ar 12/7/2003 18:15'!label	window ifNil:[^''].	^window label! !!CRootMorph methodsFor: 'accessing' stamp: 'ar 12/7/2003 18:18'!label: aString	window ifNil:[^nil].	window setLabel: aString! !!CRootMorph methodsFor: 'accessing' stamp: 'ar 1/9/2003 16:12'!myWorld	^myWorld! !!CRootMorph methodsFor: 'accessing' stamp: 'ar 12/7/2003 18:13'!window	^window! !!CRootMorph methodsFor: 'accessing' stamp: 'ar 12/7/2003 18:13'!window: aWindow	window := aWindow! !!CRootMorph methodsFor: 'initialize' stamp: 'bf 5/7/2004 13:47'!defaultBackgroundColor	^CWidgetLibrary default baseColor! !!CRootMorph methodsFor: 'initialize' stamp: 'ar 3/28/2004 01:56'!initialExtent	^800@600! !!CRootMorph methodsFor: 'initialize' stamp: 'ar 3/25/2004 19:15'!initialize	super initialize.	color := Color transparent.	self extent: 800@600.	self center: World center.	"self cornerStyle: #rounded.	self addDropShadow."	myWorld := CWorldPlayer new.	myWorld display: (Form extent: self extent depth: Display depth).	myWorld ownerMorph: self.	myWorld eventQueue: SharedQueue new.! !!CScriptChange methodsFor: 'accessing' stamp: 'ar 2/14/2004 22:53'!value	^value! !!CScriptChange methodsFor: 'accessing' stamp: 'ar 2/14/2004 22:54'!value: aString	value := aString! !!CScriptForObject methodsFor: 'accessing' stamp: 'tk 6/15/2004 19:50'!initialize	suffixCnt _ 0.	objToName _ IdentityDictionary new.! !!CScriptForObject methodsFor: 'accessing' stamp: 'tk 6/15/2004 14:46'!objToName	"Answer the value of objToName"	^ objToName! !!CScriptForObject methodsFor: 'accessing' stamp: 'tk 6/15/2004 14:46'!objToName: anObject	"Set the value of objToName"	objToName _ anObject! !!CScriptForObject methodsFor: 'accessing' stamp: 'tk 6/15/2004 14:46'!sqkCodeStrm	"Answer the value of sqkCodeStrm"	^ sqkCodeStrm! !!CScriptForObject methodsFor: 'accessing' stamp: 'tk 6/15/2004 14:46'!sqkCodeStrm: anObject	"Set the value of sqkCodeStrm"	sqkCodeStrm _ anObject! !!CScriptForObject methodsFor: 'accessing' stamp: 'tk 6/15/2004 17:35'!strm	^ sqkCodeStrm! !!CScriptForObject methodsFor: 'accessing' stamp: 'tk 6/15/2004 14:46'!suffixCnt	"Answer the value of suffixCnt"	^ suffixCnt! !!CScriptForObject methodsFor: 'accessing' stamp: 'tk 6/15/2004 14:46'!suffixCnt: anObject	"Set the value of suffixCnt"	suffixCnt _ anObject! !!CScriptForObject methodsFor: 'work' stamp: 'tk 6/17/2004 14:35'!createTime: object near: element	"Return true if self and element were created in the same second.  Accepts integers also in order to share."	| myTime otherTime |	myTime _ object isInteger 		ifTrue: [object]	"he passed in his time in seconds"		ifFalse: [(object propertyValueAt: #creationTime ifAbsent: [^ false]) asSeconds].	otherTime _ (element propertyValueAt: #creationTime ifAbsent: [^ false]) asSeconds.	^ (myTime - otherTime) abs <= 1! !!CScriptForObject methodsFor: 'work' stamp: 'tk 6/17/2004 14:04'!tempNameAndStore: aCObject	"See if we have already stored a definition for this object.  If so, return its temp var name.  If not, generate a new temp var name for it and store it.  Not to be confused with the object's real name."	|  known hisTempName |	known _ objToName includesKey: aCObject.	hisTempName _ self tempNameFor: aCObject.	known ifFalse: [aCObject entireObjectOn: self using: hisTempName].	"write out object"	^ hisTempName! !!CScriptForObject methodsFor: 'work' stamp: 'tk 6/15/2004 19:56'!tempNameFor: aCObject	"See if we know this object.  If not, generate a new temp var name for it.  Not to be confused with the object's real name."	| nn |	^ objToName at: aCObject ifAbsent: [		nn _ aCObject class name allButFirst withFirstCharacterDownshifted, 					(suffixCnt _ suffixCnt + 1) printString.		objToName at: aCObject  put: nn]! !!CScriptForObject methodsFor: 'generate' stamp: 'tk 7/6/2004 10:41'!assign: hisTempName gets: myTempName field: fieldGetter value: aPlayer	"Create a names temp for a field within the object called myTempName"	sqkCodeStrm nextPutAll: hisTempName, ' _ ', myTempName, ' ', fieldGetter.	sqkCodeStrm nextPutAll: '.'; cr.! !!CScriptForObject methodsFor: 'generate' stamp: 'tk 6/28/2004 15:26'!assign: myTempName new: aClass	"Emit code to create a new object and assign it to the temp name"	sqkCodeStrm nextPutAll: myTempName, ' _ ', aClass name, ' new.'; cr.! !!CScriptForObject methodsFor: 'generate' stamp: 'tk 6/28/2004 15:21'!elementPresent: index	"Emit a comment that this element is already accounted for"	sqkCodeStrm nextPutAll: '"element ', index printString, ' is already there"'; cr! !!CScriptForObject methodsFor: 'generate' stamp: 'tk 6/28/2004 15:23'!elementsOf: myTempName add: hisTempName at: index	"Emit code to add an object at a given place in elements"	sqkCodeStrm nextPutAll: myTempName, ' add: ', hisTempName, ' at: '; 							 nextPutAll: index printString, '.'; cr.! !!CScriptForObject methodsFor: 'generate' stamp: 'tk 6/28/2004 15:16'!methodHeader: methName for: cPlayer on: aStream	"Write the method header for the method to generate this object on an external stream"	aStream nextPutAll: methName; cr; tab; nextPutAll: '"This code regenerates the CPlayer: '.	cPlayer printOn: aStream.  aStream nextPut: $"; cr.	"install temps"	aStream nextPutAll: '| '. 	objToName values do: [:tempName | 		aStream nextPutAll: tempName; space].	aStream nextPut: $|; cr.	^ aStream! !!CScriptForObject methodsFor: 'generate' stamp: 'tk 6/28/2004 15:11'!returnTempVar: varName	"Emit a return of the value of this temp var"	sqkCodeStrm nextPutAll: '^ ', varName; cr.! !!CScriptForObject methodsFor: 'generate' stamp: 'tk 6/28/2004 15:32'!store: anObject withSetter: aSelector in: aPlayer	"Emit code to do a direct store on self using a setter.  anObject can be a CObject"	| hisTempName |	anObject isCObject 		ifTrue: [			hisTempName _ self tempNameAndStore: anObject.			sqkCodeStrm nextPutAll: (self tempNameFor: aPlayer), ' ', aSelector, ' '.			sqkCodeStrm nextPutAll: hisTempName; nextPutAll: '.'; cr]		ifFalse: [			sqkCodeStrm nextPutAll: (self tempNameFor: aPlayer), ' ', aSelector, ' '.			anObject storeOn: sqkCodeStrm.			sqkCodeStrm nextPutAll: '.'; cr].! !!CScriptForObject methodsFor: 'generate' stamp: 'tk 6/28/2004 15:04'!testClassOf: aPlayer tempName: myName	"Emit code for a test of aPlayer having the correct class"	sqkCodeStrm nextPutAll: myName, ' class name = #', aPlayer class name;				nextPutAll: ' ifFalse: [self error: ''wrong class''].'; cr.! !!CEnglishForObject methodsFor: 'generate' stamp: 'tk 7/6/2004 10:44'!assign: hisTempName gets: myTempName field: fieldGetter value: aPlayer	"Create a names temp for a field within the object called myTempName"	sqkCodeStrm nextPutAll: 'Let ', hisTempName, ' stand for ', myTempName, '''s ', fieldGetter.	sqkCodeStrm nextPutAll: ', which is a ', aPlayer class name.	sqkCodeStrm nextPutAll: '.  '.! !!CEnglishForObject methodsFor: 'generate' stamp: 'tk 7/1/2004 15:29'!assign: myTempName new: aClass	"Emit code to create a new object and assign it to the temp name"	sqkCodeStrm nextPutAll: 'Make a new ', aClass name, ' and call it ', myTempName, '.  '.! !!CEnglishForObject methodsFor: 'generate' stamp: 'tk 7/1/2004 15:31'!elementPresent: index	"Emit a comment that this element is already accounted for"	sqkCodeStrm nextPutAll: 'Element number ', index printString, ' was created when this object was initialized.  '! !!CEnglishForObject methodsFor: 'generate' stamp: 'tk 7/13/2004 14:08'!elementsOf: myTempName add: hisTempName at: index	"Emit code to add an object at a given place in elements"	sqkCodeStrm nextPutAll: 'Set the ', index printString, index ordinalSuffix, ' element of ', 			myTempName, ' to ', hisTempName, '.  '.! !!CEnglishForObject methodsFor: 'generate' stamp: 'tk 7/1/2004 16:20'!methodHeader: methName for: cPlayer on: aStream	"Write the method header for the method to generate this object on an external stream"	aStream nextPutAll: 'Here is how to make a new object just like '.	cPlayer componentBinding 		ifNil: [cPlayer printOn: aStream]		ifNotNil: [aStream nextPutAll: cPlayer componentBinding name].	aStream nextPutAll: '.  '.! !!CEnglishForObject methodsFor: 'generate' stamp: 'tk 7/6/2004 10:38'!returnTempVar: varName	"Emit a return of the value of this temp var"	sqkCodeStrm nextPutAll: 'The object ', varName, ' is ready to use.  '! !!CEnglishForObject methodsFor: 'generate' stamp: 'tk 7/13/2004 13:54'!store: anObject withSetter: aSelector in: aPlayer	"Emit code to do a direct store on self using a setter.  anObject can be a CObject"	| hisTempName |	anObject isCObject 		ifTrue: [			hisTempName _ self tempNameAndStore: anObject.			sqkCodeStrm nextPutAll: 'Put ', hisTempName, ' into ', (self tempNameFor: aPlayer),				'''s ', aSelector allButLast, '.  ']		ifFalse: [			sqkCodeStrm nextPutAll: 'Put ', anObject printString, ' into ', (self tempNameFor: aPlayer),				'''s ', aSelector allButLast, '.  ']! !!CEnglishForObject methodsFor: 'generate' stamp: 'tk 7/6/2004 10:45'!testClassOf: aPlayer tempName: myName	"Emit code for a test of aPlayer having the correct class"	"do nothing, this info is in assign:gets:field:value:"! !!CEnglishObjOutline methodsFor: 'generate' stamp: 'tk 7/13/2004 13:59'!assign: hisTempName gets: myTempName field: fieldGetter value: aPlayer	"Create a names temp for a field within the object called myTempName"	self bullet.	sqkCodeStrm nextPutAll: 'Let ', hisTempName, ' stand for ', myTempName, '''s ', fieldGetter.	sqkCodeStrm nextPutAll: ' (which is a ', aPlayer class name.	sqkCodeStrm nextPutAll: ')'; cr.! !!CEnglishObjOutline methodsFor: 'generate' stamp: 'tk 7/13/2004 14:06'!assign: myTempName new: aClass	"Emit code to create a new object and assign it to the temp name"	self bullet.	sqkCodeStrm nextPutAll: 'Make a new ', aClass name, ' and call it ', myTempName; cr.! !!CEnglishObjOutline methodsFor: 'generate' stamp: 'tk 7/13/2004 13:59'!bullet	sqkCodeStrm nextPutAll: ' - '.! !!CEnglishObjOutline methodsFor: 'generate' stamp: 'tk 7/13/2004 14:07'!elementPresent: index	"Emit a comment that this element is already accounted for"	self bullet.	sqkCodeStrm nextPutAll: 'Element number ', index printString, ' was created when this object was initialized'; cr.! !!CEnglishObjOutline methodsFor: 'generate' stamp: 'tk 7/13/2004 14:08'!elementsOf: myTempName add: hisTempName at: index	"Emit code to add an object at a given place in elements"	self bullet.	sqkCodeStrm nextPutAll: 'Set the ', index printString, index ordinalSuffix, ' element of ', 			myTempName, ' to ', hisTempName; cr.! !!CEnglishObjOutline methodsFor: 'generate' stamp: 'tk 7/13/2004 14:09'!methodHeader: methName for: cPlayer on: aStream	"Write the method header for the method to generate this object on an external stream"	aStream nextPutAll: 'Here is how to make a new object just like '.	cPlayer componentBinding 		ifNil: [cPlayer printOn: aStream]		ifNotNil: [aStream nextPutAll: cPlayer componentBinding name].	aStream nextPutAll: '.'; cr.! !!CEnglishObjOutline methodsFor: 'generate' stamp: 'tk 7/13/2004 14:09'!returnTempVar: varName	"Emit a return of the value of this temp var"	sqkCodeStrm nextPutAll: 'The object ', varName, ' is ready to use.'; cr! !!CEnglishObjOutline methodsFor: 'generate' stamp: 'tk 7/13/2004 14:40'!store: anObject withSetter: aSelector in: aPlayer	"Emit code to do a direct store on self using a setter.  anObject can be a CObject"	| hisTempName |	anObject isCObject 		ifTrue: [			hisTempName _ self tempNameAndStore: anObject.			self bullet.	"after the store in the line above"			sqkCodeStrm nextPutAll: 'Put ', hisTempName, ' into ', (self tempNameFor: aPlayer), '''s ';				 nextPutAll: aSelector allButLast asText allItalic]		ifFalse: [			self bullet.			sqkCodeStrm nextPutAll: 'Put ', anObject printString, ' into ';				nextPutAll: (self tempNameFor: aPlayer), '''s ';				nextPutAll: aSelector allButLast asText allItalic].	sqkCodeStrm cr.! !!CEnglishObjOutline methodsFor: 'generate' stamp: 'tk 7/13/2004 14:10'!testClassOf: aPlayer tempName: myName	"Emit code for a test of aPlayer having the correct class"	"do nothing, this info is in assign:gets:field:value:"! !!CKeywordsForObject methodsFor: 'generate' stamp: 'tk 7/6/2004 11:23'!assign: hisTempName gets: myTempName field: fieldGetter value: aPlayer	"Create a names temp for a field within the object called myTempName"	sqkCodeStrm add: fieldGetter asString.	sqkCodeStrm add: aPlayer class name asString.! !!CKeywordsForObject methodsFor: 'generate' stamp: 'tk 7/6/2004 11:22'!assign: myTempName new: aClass	"Emit code to create a new object and assign it to the temp name"	sqkCodeStrm add: aClass name asString.! !!CKeywordsForObject methodsFor: 'generate' stamp: 'tk 7/6/2004 11:01'!elementPresent: index	"no special info in a numbered element"! !!CKeywordsForObject methodsFor: 'generate' stamp: 'tk 7/6/2004 11:03'!elementsOf: myTempName add: hisTempName at: index	"no special info for storing into a numbered element"! !!CKeywordsForObject methodsFor: 'generate' stamp: 'tk 7/6/2004 11:22'!methodHeader: methName for: cPlayer on: aStream	"Record some info from building this object."	sqkCodeStrm add: (cPlayer componentBinding 		ifNil: [cPlayer class name]		ifNotNil: [cPlayer componentBinding name]) asString.! !!CKeywordsForObject methodsFor: 'generate' stamp: 'tk 7/6/2004 11:07'!returnTempVar: varName	"no new info"! !!CKeywordsForObject methodsFor: 'generate' stamp: 'tk 7/6/2004 11:09'!store: anObject withSetter: aSelector in: aPlayer	"Emit code to do a direct store on self using a setter.  anObject can be a CObject"	sqkCodeStrm add: aSelector allButLast.	anObject isCObject		ifFalse: [sqkCodeStrm add: anObject printString].! !!CKeywordsForObject methodsFor: 'generate' stamp: 'tk 7/6/2004 11:09'!testClassOf: aPlayer tempName: myName	"do nothing, this info is in assign:gets:field:value:"! !!CKeywordsForObject methodsFor: 'accessing' stamp: 'tk 7/6/2004 11:00'!keywords	"Set has a list of keywords"	^ sqkCodeStrm asArray! !!CScriptorHeader methodsFor: 'initialize' stamp: 'ar 3/22/2004 14:41'!initialize	super initialize.	self define: #fireButton as: CPushButton new.	self define: #collapseButton as: CPushButton new.	self define: #rcvrLabel as: CLabel new.	self define: #scriptName as: CLabel new.	self define: #ticker as: CPlayer new.	self define: #trigger as: CLabel new.	self define: #closeButton as: CButton new.! !!CScriptorHeader methodsFor: 'initialize' stamp: 'ar 4/30/2004 15:53'!setupCostume	super setupCostume.	self extent: 2@2.	self layout: CTableLayout new.	self hResizing: #spaceFill; vResizing: #shrinkWrap.	self layout listDirection: #leftToRight.	self layout cellInset: 2@2.	self fillStyle: #verticalGradient.	self fillColors: {Color white. Color r: 1.0 g: 0.677 b: 0.032}.	self layout layoutInset: 3.	"fireButton color: Color yellow."	fireButton font: CTileLibrary default tileFont.	fireButton label: '!!'.	"fireButton isRounded: true."	fireButton hResizing: #shrinkWrap; vResizing: #spaceFill.	self add: fireButton.	"collapseButton color: (Color r: 0.8 g: 0.8 b: 0.501)."	collapseButton font: CTileLibrary default tileFont.	collapseButton label: 'O'.	"collapseButton isRounded: true."	collapseButton hResizing: #shrinkWrap; vResizing: #spaceFill.	self add: collapseButton.	"rcvrLabel color: (Color r: 0.807 g: 1.0 b: 0.807)."	"rcvrLabel borderWidth: 1.	rcvrLabel borderColor: Color blue.	rcvrLabel borderStyle: #simple."	rcvrLabel font: CTileLibrary default tileFont.	rcvrLabel hResizing: #shrinkWrap.	self add: rcvrLabel.	scriptName font: CTileLibrary default tileFont.	scriptName hResizing: #shrinkWrap.	self add: scriptName.	ticker extent: 20@20.	self add: ticker.	trigger value: 'normal'.	trigger font: CTileLibrary default tileFont.	"trigger color: (Color r: 0.768 g: 1.0 b: 0.768).	trigger borderWidth: 1.	trigger borderColor: (Color r: 0.361 g: 0.721 b: 0.541).	trigger borderStyle: #simple.	trigger roundedCorners: #(1 2 3 4)."	trigger hResizing: #shrinkWrap.	self add: trigger.	"closeButton color: Color lightRed."	closeButton font: CTileLibrary default tileFont.	closeButton label: 'X'.	closeButton hResizing: #shrinkWrap; vResizing: #spaceFill.	"closeButton isRounded: true."	self add: closeButton.! !!CScriptorHeader methodsFor: 'accessing' stamp: 'ar 3/12/2004 16:25'!closeButton	"Answer the closeButton of the receiver"	<bewareOf: #closeButtonChanged>	^self propertyValueAt: #closeButton! !!CScriptorHeader methodsFor: 'accessing' stamp: 'ar 3/12/2004 16:25'!closeButton: aValue	"Modify the receiver's closeButton"	^self propertyValueAt: #closeButton put: aValue with: #closeButtonChanged! !!CScriptorHeader methodsFor: 'accessing' stamp: 'ar 3/12/2004 16:24'!collapseButton	"Answer the collapseButton of the receiver"	<bewareOf: #collapseButtonChanged>	^self propertyValueAt: #collapseButton! !!CScriptorHeader methodsFor: 'accessing' stamp: 'ar 3/12/2004 16:24'!collapseButton: aValue	"Modify the receiver's collapseButton"	^self propertyValueAt: #collapseButton put: aValue with: #collapseButtonChanged! !!CScriptorHeader methodsFor: 'accessing' stamp: 'ar 3/12/2004 16:24'!fireButton	"Answer the fireButton of the receiver"	<bewareOf: #fireButtonChanged>	^self propertyValueAt: #fireButton! !!CScriptorHeader methodsFor: 'accessing' stamp: 'ar 3/12/2004 16:24'!fireButton: aValue	"Modify the receiver's fireButton"	^self propertyValueAt: #fireButton put: aValue with: #fireButtonChanged! !!CScriptorHeader methodsFor: 'accessing' stamp: 'ar 3/12/2004 16:24'!rcvrLabel	"Answer the rcvrLabel of the receiver"	<bewareOf: #rcvrLabelChanged>	^self propertyValueAt: #rcvrLabel! !!CScriptorHeader methodsFor: 'accessing' stamp: 'ar 3/12/2004 16:24'!rcvrLabel: aValue	"Modify the receiver's rcvrLabel"	^self propertyValueAt: #rcvrLabel put: aValue with: #rcvrLabelChanged! !!CScriptorHeader methodsFor: 'accessing' stamp: 'ar 3/12/2004 16:24'!scriptName	"Answer the scriptName of the receiver"	<bewareOf: #scriptNameChanged>	^self propertyValueAt: #scriptName! !!CScriptorHeader methodsFor: 'accessing' stamp: 'ar 3/12/2004 16:24'!scriptName: aValue	"Modify the receiver's scriptName"	^self propertyValueAt: #scriptName put: aValue with: #scriptNameChanged! !!CScriptorHeader methodsFor: 'accessing' stamp: 'ar 3/12/2004 16:24'!ticker	"Answer the ticker of the receiver"	<bewareOf: #tickerChanged>	^self propertyValueAt: #ticker! !!CScriptorHeader methodsFor: 'accessing' stamp: 'ar 3/12/2004 16:24'!ticker: aValue	"Modify the receiver's ticker"	^self propertyValueAt: #ticker put: aValue with: #tickerChanged! !!CScriptorHeader methodsFor: 'accessing' stamp: 'ar 3/12/2004 16:24'!trigger	"Answer the trigger of the receiver"	<bewareOf: #triggerChanged>	^self propertyValueAt: #trigger! !!CScriptorHeader methodsFor: 'accessing' stamp: 'ar 3/12/2004 16:24'!trigger: aValue	"Modify the receiver's trigger"	^self propertyValueAt: #trigger put: aValue with: #triggerChanged! !!CSerializer methodsFor: 'types-prohibited' stamp: 'ar 9/25/2003 21:26'!writeCompiledMethod: aMethod	"Writes a compiled method"	^self writeProhibited: aMethod! !!CSerializer methodsFor: 'types-prohibited' stamp: 'ar 9/25/2003 21:26'!writeContext: aContext	"Writes out a context"	^self writeProhibited: aContext! !!CSerializer methodsFor: 'types-prohibited' stamp: 'ar 9/25/2003 21:26'!writeProcess: aProcess	"Writes out a process"	^self writeProhibited: aProcess! !!CSerializer methodsFor: 'types-optional' stamp: 'ar 9/25/2003 21:23'!writeBitsArray: anArray	"Writes an object containing bits (instead of pointers)"	^self writeObject: anArray! !!CSerializer methodsFor: 'types-optional' stamp: 'ar 12/2/2003 18:37'!writeClass: aClass	"Writes out a class"	^self writeResource: aClass! !!CSerializer methodsFor: 'types-optional' stamp: 'ar 9/25/2003 21:23'!writeCollection: aCollection	"Writes a generic collection of objects."	^self writeObject: aCollection! !!CSerializer methodsFor: 'types-optional' stamp: 'ar 9/25/2003 21:23'!writeColor: aColor	"Writes out a color"	^self writeObject: aColor! !!CSerializer methodsFor: 'types-optional' stamp: 'ar 2/25/2004 16:19'!writeCostume: aCostume	^self writeObject: aCostume! !!CSerializer methodsFor: 'types-optional' stamp: 'ar 10/9/2003 16:06'!writeDictionary: aDictionary	"Writes a generic collection of objects."	^self writeCollection: aDictionary! !!CSerializer methodsFor: 'types-optional' stamp: 'ar 12/2/2003 18:38'!writeFont: aFont	"Writes a font"	^self writeResource: aFont! !!CSerializer methodsFor: 'types-optional' stamp: 'ar 9/25/2003 21:24'!writeForm: aForm	"Writes a form"	^self writeObject: aForm! !!CSerializer methodsFor: 'types-optional' stamp: 'ar 2/27/2004 18:24'!writeOwnedPlayer: aPlayer	^self writeScripted: aPlayer! !!CSerializer methodsFor: 'types-optional' stamp: 'ar 2/25/2004 16:19'!writePlayerCostume: aPlayer	^self writeScripted: aPlayer! !!CSerializer methodsFor: 'types-optional' stamp: 'ar 9/25/2003 21:24'!writePoint: aPoint	"Writes a point"	^self writeObject: aPoint! !!CSerializer methodsFor: 'types-optional' stamp: 'ar 9/25/2003 21:24'!writeRectangle: aRectangle	"Writes a rectangle"	^self writeObject: aRectangle! !!CSerializer methodsFor: 'types-optional' stamp: 'ar 9/25/2003 21:24'!writeScripted: aScriptedObject	"Writes out a scripted (Tweak) object"	^self writeObject: aScriptedObject! !!CSerializer methodsFor: 'types-optional' stamp: 'ar 9/25/2003 21:24'!writeSequence: aSequence	"Writes a sequencable collection"	^self writeCollection: aSequence! !!CSerializer methodsFor: 'types-optional' stamp: 'ar 9/25/2003 21:24'!writeString: aString	"Writes a string"	^self writeBitsArray: aString! !!CSerializer methodsFor: 'types-optional' stamp: 'ar 9/25/2003 21:24'!writeText: aText	"Writes a text object"	^self writeObject: aText! !!CSerializer methodsFor: 'types-required' stamp: 'ar 10/2/2003 00:55'!writeGlobal: globalName	"Write an object which is accessible under the given global name.	Arguments:		globalName:	Symbol	"	^self writeGlobal: globalName constructor: nil arguments: nil! !!CSerializer methodsFor: 'types-required' stamp: 'ar 10/2/2003 00:55'!writeGlobal: globalName constructor: constructor	"Write an object which is retrieved by sending the constructor to the given global.	Arguments:		globalName:	Symbol		constructor: Symbol	"	^self writeGlobal: globalName constructor: constructor arguments: #()! !!CSerializer methodsFor: 'types-required' stamp: 'ar 9/25/2003 21:08'!writeGlobal: globalName constructor: constructor arguments: arguments	"Write an object which is retrieved by sending the constructor with a set of arguments to the given global.		globalName:		Symbol		constructor:		Symbol | nil		arguments:		Array of: Object | nil	Remarks: 		The arguments are NOT limited to literals but can be arbitrarily complex. 		Serializers need to ensure that the arguments are properly serialized.	"	^self subclassResponsibility! !!CSerializer methodsFor: 'types-required' stamp: 'ar 9/25/2003 21:09'!writeLiteral: aLiteral	"Writes a literal object. 	Arguments:		aLiteral: Object	Remarks:		A 'literal' object in the context of a serializer is ANY object which is assumed to be immutable (e.g., not being modified in-place and comparing by content-equality, e.g., #=). Serializers have to be aware that composite objects may be treated immutable too. Clients have to be aware that references to literals may no longer be identical after literals are being deserialized.	"	^self subclassResponsibility! !!CSerializer methodsFor: 'types-required' stamp: 'ar 9/25/2003 21:11'!writeObject: anObject	"Write a generic object.	Arguments:		anObject:	Object	"	| ref |	ref := self lookupReference: anObject.	ref ifNotNil:[^self writeReference: ref]. "write a reference"	ref := self newReference: anObject.	self registerReference: ref for: anObject.	self writeContentsOf: anObject.	^ref! !!CSerializer methodsFor: 'types-required' stamp: 'ar 9/25/2003 21:22'!writeProhibited: anObject	"Writes an object which must not be written out.	Arguments:		anObject:	Object	Remarks:		This method provides a way for the serializer to determine that an object which should not be written in fact is being written. The method allows the serializers to handle this situation in a more graceful way than just raising an error. For example, a serializer can simply substitute another object (such as nil) or record the object for later notification to the user.		Senders of this method are STRONGLY encouraged to pass a proxy instead of themselves to this method to prevent the chance that a serializer can be used to spy on the internals of the prohibited object."	self error: 'Cannot serialize: ', anObject name.! !!CSerializer methodsFor: 'types-required' stamp: 'ar 9/25/2003 21:12'!writeReference: reference	"Writes a reference to an object previously encountered.	Arguments:		reference:	Object	Remarks:		This method is private to the serializer. 		Only the serializer can determine when to write a reference and when not.	"	^self subclassResponsibility! !!CSerializer methodsFor: 'types-required' stamp: 'ar 12/2/2003 18:39'!writeResource: anObject	"Write a resource object"	^self subclassResponsibility! !!CSerializer methodsFor: 'types-literal' stamp: 'ar 9/25/2003 21:26'!writeBoolean: aBoolean	"Write a Boolean"	^self writeLiteral: aBoolean! !!CSerializer methodsFor: 'types-literal' stamp: 'ar 9/25/2003 21:26'!writeCharacter: aCharacter	"Writes a character"	^self writeLiteral: aCharacter! !!CSerializer methodsFor: 'types-literal' stamp: 'ar 9/25/2003 21:26'!writeNil: nilObject	"Writes nil"	^self writeLiteral: nilObject! !!CSerializer methodsFor: 'types-literal' stamp: 'ar 9/25/2003 21:26'!writeNumber: aNumber	"Writes a number"	^self writeLiteral: aNumber! !!CSerializer methodsFor: 'types-literal' stamp: 'ar 9/25/2003 21:25'!writeUUID: uuid	"Writes a UUID"	^self writeLiteral: uuid! !!CSerializer methodsFor: 'private-writing' stamp: 'ar 9/17/2003 17:02'!write: anObject	^anObject serializeOn: self! !!CSerializer methodsFor: 'private-writing' stamp: 'ar 11/18/2003 12:45'!writeContentsOf: anObject	"Write the contents of the given object"	anObject writeFieldsOn: self! !!CSerializer methodsFor: 'private-references' stamp: 'ar 9/17/2003 17:51'!lookupReference: anObject	"Check if a reference to the given object already exists, e.g., whether the object has been written out before. If it does, return the reference, otherwise answer nil"	^self subclassResponsibility! !!CSerializer methodsFor: 'private-references' stamp: 'ar 9/17/2003 17:51'!newReference: anObject	"Answer a new object reference which can be used to identify the object uniquely"	^self subclassResponsibility! !!CSerializer methodsFor: 'private-references' stamp: 'ar 9/17/2003 17:51'!registerReference: aReference for: anObject	"Register the given reference for anObject so it can be retrieved afterwards using #lookupReference:"	^self subclassResponsibility! !!CSerializer methodsFor: 'initialize' stamp: 'ar 9/17/2003 17:47'!initialize	"Initialize the receiver"! !!CSerializer methodsFor: 'initialize' stamp: 'ar 11/18/2003 12:31'!serialize: rootObject	"Serialize the given root object"	^self writeField: #root value: rootObject! !!CSerializer methodsFor: 'interface' stamp: 'ar 11/18/2003 12:26'!writeField: fieldName value: fieldValue	"Write the given value under the name of the field which will be used to retrieve it during deserialization.		fieldName: 	Symbol		fieldValue:	Object	Remarks: 		The fieldName has to be unique in the context of the object being written. The serializer is NOT required to ensure uniqueness of the key; the whole responsibility lies with the object being serialized.	"	^self subclassResponsibility! !!CObjectMakerSerializer methodsFor: 'types-optional' stamp: 'ar 11/18/2003 20:51'!writeBitsArray: bitsArray	"Write an object containing bits (instead of pointers)"	| part |	(part := self lookupReference: bitsArray) 		ifNotNil:[^self writeReference: part].	part := CBitsArrayPart new.	partList nextPut: part.	part partMaker: bitsArray maker.	imports add: part partMaker.	part contents: bitsArray.	self registerReference: part for: bitsArray.	^part! !!CObjectMakerSerializer methodsFor: 'types-optional' stamp: 'ar 10/18/2003 21:42'!writeColor: aColor	^self writeLiteral: aColor! !!CObjectMakerSerializer methodsFor: 'types-optional' stamp: 'ar 12/2/2003 16:55'!writeFont: aFont	"Write a font - not shared"	"^self writeGlobal: #StrikeFont 		constructor: #familyName:size:emphasized:		arguments: (Array with: aFont familyName with: aFont height with: aFont emphasis)"	^self writeResource: aFont! !!CObjectMakerSerializer methodsFor: 'types-optional' stamp: 'ar 10/18/2003 21:42'!writePoint: aPoint	aPoint class == Point ifTrue:[^self writeLiteral: aPoint].	^self writeObject: aPoint! !!CObjectMakerSerializer methodsFor: 'types-optional' stamp: 'ar 11/18/2003 20:51'!writeSequence: aSequence	"Write an object containing bits (instead of pointers)"	| sz part |	(part := self lookupReference: aSequence) 		ifNotNil:[^self writeReference: part].	part := CSequencePart new.	partList nextPut: part.	part partMaker: aSequence maker.	imports add: part partMaker.	part partSize: (sz := aSequence basicSize).	self registerReference: part for: aSequence.	self storeContents: part using:[		contents := (Array new: sz) writeStream.		1 to: sz do:[:i| contents nextPut: (self write: (aSequence basicAt: i))].	].	^part! !!CObjectMakerSerializer methodsFor: 'types-optional' stamp: 'ar 10/18/2003 21:42'!writeString: aString	^self writeLiteral: aString! !!CObjectMakerSerializer methodsFor: 'interface' stamp: 'ar 11/18/2003 20:52'!imports	^imports! !!CObjectMakerSerializer methodsFor: 'interface' stamp: 'ar 2/25/2004 22:10'!parentField	^parentField! !!CObjectMakerSerializer methodsFor: 'interface' stamp: 'ar 2/25/2004 22:10'!parentValue	^parentValue! !!CObjectMakerSerializer methodsFor: 'interface' stamp: 'ar 11/20/2003 13:20'!replace: obj1 by: obj2	"WARNING: Unfinished - move this up to the serializer."	"If obj1 is being serialized (or has been) replace it transparently by obj2."	| ref2 ref1 map pp |	ref2 := self write: obj2.	ref1 := self lookupReference: obj1.	ref1 ifNotNil:[		"Remap any existing references to obj1 ... slow but no other way."		map := IdentityDictionary new.		map at: ref1 put: ref2.		partList position: 0.		[(pp := partList next) == nil] whileFalse:[pp remapIn: map].	].	self registerReference: ref2 for: obj1.! !!CObjectMakerSerializer methodsFor: 'interface' stamp: 'ar 11/18/2003 20:50'!serialize: rootObject	| ref index |	root := rootObject.	imports := Set new.	data := CObjectPart new. "top-level stub"	contents := Array new writeStream.	super serialize: rootObject.	ref := self lookupReference: rootObject.	ref ifNil:[self error: 'Where''s the object???'].	data := ref.	partList := partList contents.	(partList at: 1) == data ifFalse:[		index := partList indexOf: data.		partList swap: 1 with: index.	].	^partList! !!CObjectMakerSerializer methodsFor: 'interface' stamp: 'ar 10/18/2003 21:42'!serialize: anObject on: aStream	self serialize: anObject.	self writeContentsOn: aStream.! !!CObjectMakerSerializer methodsFor: 'interface' stamp: 'ar 12/1/2003 20:55'!writeContentsOn: aStream	| writer |	writer := XMLWriter on: aStream.	writer startTag: 'root'; endTag.	partList do:[:each|		each exportXmlOn: writer key: 'object'.	].	writer endTag: 'root'.! !!CObjectMakerSerializer methodsFor: 'interface' stamp: 'ar 2/25/2004 22:12'!writeField: fieldName value: aValue	"Write the given value under the name of the field which will 	be used to retrieve it afterwards."	| prevField prevValue |	prevField := parentField.	prevValue := parentValue.	parentValue := currentValue.	parentField := fieldName asSymbol.	currentValue := aValue.	contents nextPut: (Association key: parentField value: (self write: aValue)).	parentField := prevField.	currentValue := parentValue.	parentValue := prevValue.! !!CObjectMakerSerializer methodsFor: 'private' stamp: 'ar 10/18/2003 22:56'!storeContents: ref using: aBlock	| oldContents oldData |	oldContents := contents.	oldData := data.	data := ref.	aBlock value.	data contents: contents contents.	data := oldData.	contents := oldContents.! !!CObjectMakerSerializer methodsFor: 'types-special' stamp: 'ar 12/8/2003 14:42'!writeResource: anObject	| part |	anObject == root ifTrue:[^self writeObject: anObject].	(part := self lookupReference: anObject) ifNil:[		imports add: anObject.		part := CResourcePart new.		part value: anObject.		part partID: anObject resourceID.		self registerReference: part for: anObject.	].	^self writeReference: part! !!CObjectMakerSerializer methodsFor: 'types-special' stamp: 'ar 2/24/2004 16:42'!writeUUID: uuid	"Writes a UUID"	^self writeBitsArray: uuid! !!CObjectMakerSerializer methodsFor: 'references' stamp: 'ar 10/18/2003 21:42'!lookupReference: anObject	"Check if a reference to the given object already exists, e.g., whether the object has been written out before. If it does, return the reference, otherwise answer nil"	^objMap at: anObject ifAbsent:[nil]! !!CObjectMakerSerializer methodsFor: 'references' stamp: 'ar 10/18/2003 21:42'!registerReference: aReference for: anObject	"Register the given reference for anObject so it can be retrieved afterwards using #lookupReference:"	objMap at: anObject put: aReference.! !!CObjectMakerSerializer methodsFor: 'initialize' stamp: 'ar 11/20/2003 12:47'!initialize	"Initialize the receiver"	super initialize.	objMap := IdentityDictionary new: 4096.	partList := ReadWriteStream on: (Array new: 100).! !!CObjectMakerSerializer methodsFor: 'types-required' stamp: 'ar 10/18/2003 22:59'!writeGlobal: globalName constructor: aSelector arguments: args	| part |	part := CGlobalPart new.	partList nextPut: part.	part globalName: globalName.	part globalSelector: aSelector.	part globalArgs: args.	^part! !!CObjectMakerSerializer methodsFor: 'types-required' stamp: 'ar 10/18/2003 22:38'!writeLiteral: aLiteral	"Serialize the given literal"	^aLiteral! !!CObjectMakerSerializer methodsFor: 'types-required' stamp: 'ar 11/18/2003 20:51'!writeObject: anObject	"Serialize the given object"	| part |	(part := self lookupReference: anObject) 		ifNotNil:[^self writeReference: part].	part := CObjectPart new.	partList nextPut: part.	part partMaker: anObject maker.	imports add: part partMaker.	self registerReference: part for: anObject.	self storeContents: part using:[		contents := (Array new: 10) writeStream.		self writeContentsOf: anObject.	].	^part! !!CObjectMakerSerializer methodsFor: 'types-required' stamp: 'ar 10/18/2003 22:35'!writeReference: ref	"Write a reference to the object having the associated objId"	ref partID ifNil:[ref partID: UUID new].	^ref! !!CSharedPart methodsFor: 'exporting' stamp: 'ar 11/14/2003 20:30'!exportPartOn: xmlWriter key: aKey	^self subclassResponsibility! !!CSharedPart methodsFor: 'exporting' stamp: 'ar 12/1/2003 20:50'!exportXmlOn: xmlWriter	partID ifNil:[^self].	^self exportPartOn: xmlWriter key: self xmlTagName! !!CSharedPart methodsFor: 'exporting' stamp: 'ar 12/5/2003 17:33'!exportXmlOn: xmlWriter key: aKey	| |	partID ifNil:[^self exportPartOn: xmlWriter key: aKey].	xmlWriter startTag: aKey.	xmlWriter attribute: 'ref' value: partID asString.	xmlWriter endEmptyTag: aKey.! !!CSharedPart methodsFor: '*Tweak-Tweaks' stamp: 'ar 2/27/2004 19:44'!tdlPrintPartIdOn: aStream	aStream nextPutAll:'"'; nextPutAll: partID asString; nextPutAll:'"'! !!CSharedPart methodsFor: 'accessing' stamp: 'ar 10/18/2003 22:56'!partID	^partID! !!CSharedPart methodsFor: 'accessing' stamp: 'ar 10/18/2003 22:56'!partID: newPartID	partID := newPartID! !!CObjectPart methodsFor: 'creating' stamp: 'ar 2/14/2004 22:02'!constructPartIn: aMaker	"Construct this part"	^aMaker constructObjectFrom: self! !!CObjectPart methodsFor: 'creating' stamp: 'ar 2/14/2004 21:55'!createPartIn: aMaker	value := aMaker makeNewPart: partMaker.! !!CObjectPart methodsFor: 'creating' stamp: 'ar 10/19/2003 13:27'!postBuildIn: aMaker	value postBuildWith: aMaker.	value := nil.! !!CObjectPart methodsFor: 'accessing' stamp: 'ar 10/18/2003 22:55'!contents	^contents! !!CObjectPart methodsFor: 'accessing' stamp: 'ar 10/18/2003 22:56'!contents: newContents	contents := newContents! !!CObjectPart methodsFor: 'accessing' stamp: 'ar 2/24/2004 16:04'!keysAndValuesDo: aBlock	contents do:[:each| aBlock value: each key value: each value].! !!CObjectPart methodsFor: 'accessing' stamp: 'ar 10/18/2003 22:39'!partMaker	^partMaker! !!CObjectPart methodsFor: 'accessing' stamp: 'ar 10/18/2003 22:40'!partMaker: aMaker	partMaker := aMaker! !!CObjectPart methodsFor: 'printing' stamp: 'ar 11/14/2003 20:45'!printOn: aStream	super printOn: aStream.	aStream nextPutAll: '('; nextPutAll: partMaker name; nextPutAll:')'.! !!CObjectPart methodsFor: '*Tweak-Tweaks' stamp: 'ar 2/27/2004 19:42'!tdlPrintContentsOn: aStream indent: level	self keysAndValuesDo:[:key :aValue|		aStream crtab: level+1.		aStream nextPutAll: key asString; nextPutAll: ': '.		aValue isMakerPart ifTrue:[			aValue partID 				ifNil:[aValue tdlPrintOn: aStream indent: level+1]				ifNotNil:[aValue tdlPrintPartIdOn: aStream].		] ifFalse:[aValue storeOn: aStream].		aStream nextPut: $.	].	aStream crtab: level.! !!CObjectPart methodsFor: '*Tweak-Tweaks' stamp: 'ar 2/27/2004 19:42'!tdlPrintOn: aStream indent: level	aStream nextPutAll:'def '; nextPutAll: partMaker name.	partID ifNotNil:[aStream space. self tdlPrintPartIdOn: aStream].	aStream nextPutAll: ' ['.	contents size > 0 ifTrue:[self tdlPrintContentsOn: aStream indent: level].	aStream nextPutAll:']'.! !!CObjectPart methodsFor: '*Tweak-Tweaks' stamp: 'ar 2/27/2004 19:43'!tdlPrintPartIdOn: aStream	aStream nextPutAll:'"'; nextPutAll: partMaker name; nextPutAll:'['; nextPutAll: partID asString; nextPutAll:']"'! !!CObjectPart methodsFor: '*Tweak-Tweaks' stamp: 'ar 2/28/2004 23:06'!tweak: oldValue in: aMaker	value ifNotNil:[^value].	oldValue maker == partMaker ifFalse:[		"Maker changed - create entirely new object"		^self valueInMaker: aMaker.	].	"Otherwise, update the oldValue"	value := oldValue.	aMaker tweakObjectPart: self.	^value! !!CObjectPart methodsFor: 'importing' stamp: 'ar 11/20/2003 12:46'!remapIn: aMap	"Replace all references to some object using the given map."	| old new binding |	1 to: contents size do:[:i|		(binding := contents at: i) ifNotNil:[			old := binding value.			new := aMap at: old ifAbsent:[new].			new == old ifFalse:[binding value: new].		].	].! !!CObjectPart methodsFor: 'importing' stamp: 'ar 12/2/2003 14:09'!resolveIn: importer	"Replace all shared references by references to their contents"	| assoc vv |	1 to: contents size do:[:i|		vv := (assoc := contents at: i) value.		"Okay, this sucks but I need something efficient RIGHT NOW"		vv class == CReferencePart			ifTrue:[assoc value: (importer resolve: vv partID)].	].! !!CObjectPart methodsFor: 'exporting' stamp: 'ar 12/1/2003 20:55'!exportPartOn: xmlWriter key: aKey	xmlWriter startTag: aKey.	partID ifNotNil:[xmlWriter attribute: 'id' value: partID asString].	self exportMaker: partMaker on: xmlWriter.	xmlWriter endTag.	contents do:[:item| item value exportXmlOn: xmlWriter key: item key].	xmlWriter endTag: aKey.! !!CObjectPart methodsFor: 'exporting' stamp: 'ar 11/14/2003 20:55'!xmlTagName	^'object'! !!CBitsArrayPart methodsFor: 'creating' stamp: 'ar 2/14/2004 22:02'!constructPartIn: aMaker	"Construct this part"! !!CBitsArrayPart methodsFor: 'creating' stamp: 'ar 2/14/2004 21:54'!createPartIn: aMaker	"Create this part"	value := contents clone.! !!CBitsArrayPart methodsFor: 'exporting' stamp: 'ar 11/21/2003 17:37'!exportBitsOf: anObject	"Take a (non-pointer) object and convert it into bytes suitable for external representation"	| bytes src dst |	anObject class isWords ifTrue:[		bytes := String new: anObject basicSize * 4.		"convert (any-endian) words to (big-endian) bytes"		src := Form new hackBits: anObject.		dst := Form new hackBits: bytes.		(BitBlt toForm: dst) sourceForm: src; combinationRule: 3; copyBits.	] ifFalse:[		bytes := String new: anObject basicSize.		bytes replaceFrom: 1 to: anObject basicSize with: anObject startingAt: 1.	].	^bytes zipped base64Encoded! !!CBitsArrayPart methodsFor: 'exporting' stamp: 'ar 11/17/2003 23:40'!exportPartOn: xmlWriter key: aKey	xmlWriter startTag: aKey.	partID ifNotNil:[xmlWriter attribute: 'id' value: partID asString].	self exportMaker: partMaker on: xmlWriter.	xmlWriter attribute: 'size' value: contents basicSize printString.	xmlWriter attribute: 'bits' value: (self exportBitsOf: contents).	xmlWriter endEmptyTag: aKey.! !!CBitsArrayPart methodsFor: 'exporting' stamp: 'ar 11/14/2003 20:55'!xmlTagName	^'bits'! !!CBitsArrayPart methodsFor: 'importing' stamp: 'ar 11/20/2003 12:43'!remapIn: aMap	"do nothing"! !!CBitsArrayPart methodsFor: 'importing' stamp: 'ar 12/2/2003 14:08'!resolveIn: importer	"do nothing"! !!CBitsArrayPart methodsFor: '*Tweak-Tweaks' stamp: 'ar 2/27/2004 19:41'!tdlPrintContentsOn: aStream indent: level	1 to: contents basicSize do:[:i|		aStream print: (contents basicAt: i); space.	].! !!CBitsArrayPart methodsFor: '*Tweak-Tweaks' stamp: 'ar 2/27/2004 19:37'!tweak: oldValue in: aMaker	^self valueInMaker: aMaker! !!CBitsArrayPart methodsFor: 'accessing' stamp: 'ar 2/27/2004 19:41'!keysAndValuesDo: aBlock	contents keysAndValuesDo: aBlock! !!CResourcePart methodsFor: '*Tweak-Tweaks' stamp: 'ar 2/27/2004 19:43'!tdlPrintPartIdOn: aStream	"^value printResourcePartIdOn: aStream"	aStream nextPutAll:'"'; nextPutAll: partID asString; nextPutAll:'"'! !!CResourcePart methodsFor: '*Tweak-Tweaks' stamp: 'ar 3/3/2004 16:45'!tweak: oldValue in: aMaker	^self valueInMaker: aMaker! !!CResourcePart methodsFor: 'as yet unclassified' stamp: 'ar 12/2/2003 18:37'!exportXmlOn: writer	"do nothing. resources are stored outside of the object tree"! !!CSequencePart methodsFor: 'accessing' stamp: 'ar 2/24/2004 16:04'!keysAndValuesDo: aBlock	contents keysAndValuesDo: aBlock! !!CSequencePart methodsFor: 'accessing' stamp: 'ar 10/18/2003 22:55'!partSize	^partSize! !!CSequencePart methodsFor: 'accessing' stamp: 'ar 10/18/2003 22:55'!partSize: sz	partSize := sz! !!CSequencePart methodsFor: 'exporting' stamp: 'ar 12/1/2003 20:55'!exportPartOn: xmlWriter key: aKey	xmlWriter startTag: aKey.	partID ifNotNil:[xmlWriter attribute: 'id' value: partID asString].	self exportMaker: partMaker on: xmlWriter.	xmlWriter attribute: 'size' value: contents size printString.	xmlWriter endTag.	contents do:[:item|		item exportXmlOn: xmlWriter key: 'item'.	].	xmlWriter endTag: aKey.! !!CSequencePart methodsFor: 'exporting' stamp: 'ar 11/14/2003 20:55'!xmlTagName	^'sequence'! !!CSequencePart methodsFor: 'creating' stamp: 'ar 2/14/2004 22:25'!constructPartIn: aMaker	"Construct this part"	1 to: contents size do:[:index|		value basicAt: index put: ((contents at: index) valueInMaker: aMaker).	].! !!CSequencePart methodsFor: 'creating' stamp: 'ar 2/14/2004 21:56'!createPartIn: aMaker	value := aMaker makeNewPart: partMaker size: partSize.! !!CSequencePart methodsFor: 'importing' stamp: 'ar 11/20/2003 12:43'!remapIn: aMap	"Replace all references to some object using the given map."	| old new |	1 to: contents size do:[:i|		old := contents at: i.		new := aMap at: old ifAbsent:[new].		new == old ifFalse:[contents at: i put: new].	].! !!CSequencePart methodsFor: 'importing' stamp: 'ar 12/2/2003 14:09'!resolveIn: importer	"Replace all shared references by references to their contents"	| vv |	1 to: contents size do:[:i|		vv := contents at: i.		"Okay, this sucks but I need something efficient RIGHT NOW"		vv class == CReferencePart			ifTrue:[contents at: i put: (importer resolve: vv partID)].	].! !!CSequencePart methodsFor: '*Tweak-Tweaks' stamp: 'ar 2/27/2004 19:38'!tweak: oldValue in: aMaker	"Don't tweak"	^self valueInMaker: aMaker! !!CSimpleBorder methodsFor: 'drawing'!drawLineFrom: startPoint to: stopPoint on: aCanvas	| lineColor |	(stopPoint truncated quadrantOf: startPoint truncated) > 2		ifTrue: [lineColor _ self topLeftColor]		ifFalse: [lineColor _ self bottomRightColor].	aCanvas line: startPoint to: stopPoint width: self width color: lineColor.! !!CSimpleBorder methodsFor: 'drawing'!frameRectangle: aRectangle on: aCanvas	aCanvas frameAndFillRectangle: aRectangle		fillColor: Color transparent		borderWidth: self width		topLeftColor: self topLeftColor		bottomRightColor: self bottomRightColor.! !!CSimpleBorder methodsFor: 'accessing'!baseColor	^baseColor ifNil:[Color transparent]! !!CSimpleBorder methodsFor: 'accessing' stamp: 'ar 1/8/2003 18:24'!baseColor: aColor	| cc |	cc _ aColor isTransparent ifTrue:[nil] ifFalse:[aColor].	baseColor = cc ifTrue:[^self].	baseColor _ cc.	self releaseCachedState.	self color: cc.	owner ifNotNil:[owner invalidate].! !!CSimpleBorder methodsFor: 'accessing'!bottomRightColor	^self color! !!CSimpleBorder methodsFor: 'accessing'!color	^color ifNil:[Color transparent]! !!CSimpleBorder methodsFor: 'accessing' stamp: 'ar 1/8/2003 18:22'!color: aColor	color = aColor ifTrue:[^self].	color _ aColor.	self releaseCachedState.	owner ifNotNil:[owner invalidate].! !!CSimpleBorder methodsFor: 'accessing' stamp: 'ar 1/8/2003 18:22'!owner	^owner! !!CSimpleBorder methodsFor: 'accessing' stamp: 'ar 1/8/2003 18:22'!owner: newOwner	"associate a new owner with this texture"	owner == newOwner ifTrue:[^self].	owner ifNotNil:[owner border: nil].	owner := newOwner.	owner ifNotNil:[owner border: self].! !!CSimpleBorder methodsFor: 'accessing'!style	^#simple! !!CSimpleBorder methodsFor: 'accessing'!topLeftColor	^self color! !!CSimpleBorder methodsFor: 'accessing'!width	^width! !!CSimpleBorder methodsFor: 'accessing' stamp: 'bf 3/30/2004 10:46'!width: aNumber	width = aNumber ifTrue:[^self].	owner ifNotNil:[owner invalidate].	width _ aNumber truncated max: (width isPoint ifTrue:[0@0] ifFalse:[0]).	self releaseCachedState.	owner ifNotNil:[owner invalidate; invalidateLayout].	^aNumber! !!CComplexBorder methodsFor: 'private'!colorsForDirection: direction	"Return an array of colors describing the receiver in the given direction"	| colorArray dT cc |	cc _ self colors.	(direction x * direction y) <= 0 ifTrue:[		"within up->right or down->left transition; no color blend needed"		(direction x > 0 or:[direction y < 0]) ifTrue:["up->right"			colorArray _ cc copyFrom: 1 to: width.		] ifFalse:["down->left"			"colors are stored in reverse direction when following a line"			colorArray _ (cc copyFrom: width+1 to: cc size) reversed.		].	] ifFalse:[		"right->down or left->up transition; need color blend"		colorArray _ Array new: width.		dT _ direction x asFloat / (direction x + direction y).		(direction x > 0 or:[direction y >= 0]) ifTrue:["top-right"			1 to: width do:[:i|				colorArray at: i put: 					((cc at: i) mixed: dT with: (cc at: cc size - i + 1))]		] ifFalse:["bottom-left"			1 to: width do:[:i|				colorArray at: i put: 					((cc at: cc size - i + 1) mixed: dT with: (cc at: i))]		].	].	^colorArray! !!CComplexBorder methodsFor: 'private'!computeAltFramedColors	| base light dark w hw colorArray param |	base _ self color asColor.	light _ Color white.	dark _ Color black.	w _ self width isPoint ifTrue:[self width x max: self width y] ifFalse:[self width].	w _ w asInteger.	w = 1 ifTrue:[^{base mixed: 0.5 with: light. base mixed: 0.5 with: dark}].	colorArray _ Array new: w.	hw _ w // 2.	"brighten"	0 to: hw-1 do:[:i|		param _ 0.5 + (i asFloat / hw * 0.5).		colorArray at: i+1 put: (base mixed: param with: dark). "brighten"		colorArray at: w-i put: (base mixed: param with: light). "darken"	].	w odd ifTrue:[colorArray at: hw+1 put: base].	^colorArray, colorArray! !!CComplexBorder methodsFor: 'private'!computeAltInsetColors	| base light dark w colorArray param hw |	base _ self color asColor.	light _ Color white.	dark _ Color black.	w _ self width isPoint ifTrue:[self width x max: self width y] ifFalse:[self width].	w _ w asInteger.	colorArray _ Array new: w*2.	hw _ 0.5 / w.	0 to: w-1 do:[:i|		false			ifTrue:[param _ 0.5 + (hw * i)]			ifFalse:[param _ 0.5 + (hw * (w-i))].		colorArray at: i+1 put: (base mixed: param with: dark). "darken"		colorArray at: colorArray size - i put: (base mixed: param with: light). "brighten"	].	^colorArray! !!CComplexBorder methodsFor: 'private'!computeAltRaisedColors	| base light dark w colorArray param hw |	base _ self color asColor.	light _ Color white.	dark _ Color black.	w _ self width isPoint ifTrue:[self width x max: self width y] ifFalse:[self width].	w _ w asInteger.	colorArray _ Array new: w*2.	hw _ 0.5 / w.	0 to: w-1 do:[:i|		false 			ifTrue:[param _ 0.5 + (hw * i)]			ifFalse:[param _ 0.5 + (hw * (w-i))].		colorArray at: i+1 put: (base mixed: param with: light). "brighten"		colorArray at: colorArray size - i put: (base mixed: param with: dark). "darken"	].	^colorArray! !!CComplexBorder methodsFor: 'private'!computeColors	width = 0 ifTrue:[^colors _ #()].	style == #complexFramed ifTrue:[^self computeFramedColors].	style == #complexAltFramed ifTrue:[^self computeAltFramedColors].	style == #complexRaised ifTrue:[^self computeRaisedColors].	style == #complexAltRaised ifTrue:[^self computeAltRaisedColors].	style == #complexInset ifTrue:[^self computeInsetColors].	style == #complexAltInset ifTrue:[^self computeAltInsetColors].	self error:'Unknown border style: ', style printString.! !!CComplexBorder methodsFor: 'private'!computeFramedColors	| base light dark w hw colorArray param |	base _ self color asColor.	light _ Color white.	dark _ Color black.	w _ self width isPoint ifTrue:[self width x max: self width y] ifFalse:[self width].	w _ w asInteger.	w = 1 ifTrue:[^{base mixed: 0.5 with: light. base mixed: 0.5 with: dark}].	colorArray _ Array new: w.	hw _ w // 2.	"brighten"	0 to: hw-1 do:[:i|		param _ 0.5 + (i asFloat / hw * 0.5).		colorArray at: i+1 put: (base mixed: param with: light). "brighten"		colorArray at: w-i put: (base mixed: param with: dark). "darken"	].	w odd ifTrue:[colorArray at: hw+1 put: base].	^colorArray, colorArray! !!CComplexBorder methodsFor: 'private'!computeInsetColors	| base light dark w colorArray param hw |	base _ self color asColor.	light _ Color white.	dark _ Color black.	w _ self width isPoint ifTrue:[self width x max: self width y] ifFalse:[self width].	w _ w asInteger.	colorArray _ Array new: w*2.	hw _ 0.5 / w.	0 to: w-1 do:[:i|		true			ifTrue:[param _ 0.5 + (hw * i)]			ifFalse:[param _ 0.5 + (hw * (w-i))].		colorArray at: i+1 put: (base mixed: param with: dark). "darken"		colorArray at: colorArray size - i put: (base mixed: param with: light). "brighten"	].	^colorArray! !!CComplexBorder methodsFor: 'private'!computeRaisedColors	| base light dark w colorArray param hw |	base _ self color asColor.	light _ Color white.	dark _ Color black.	w _ self width isPoint ifTrue:[self width x max: self width y] ifFalse:[self width].	w _ w asInteger.	colorArray _ Array new: w*2.	hw _ 0.5 / w.	0 to: w-1 do:[:i|		true 			ifTrue:[param _ 0.5 + (hw * i)]			ifFalse:[param _ 0.5 + (hw * (w-i))].		colorArray at: i+1 put: (base mixed: param with: light). "brighten"		colorArray at: colorArray size - i put: (base mixed: param with: dark). "darken"	].	^colorArray! !!CComplexBorder methodsFor: 'private' stamp: 'ar 12/7/2002 22:20'!fillStyleForDirection: direction	"Fill the given form describing the receiver's look at a particular direction"	| index fill dir |	index _ direction degrees truncated // 10 + 1.	lineStyles ifNotNil:[		fill _ lineStyles at: index.		fill ifNotNil:[^fill].	].	dir _ Point r: 1.0 degrees: index - 1 * 10 + 5.	fill _ CGradientFill colors: (self colorsForDirection: dir).	fill direction: 0 @ width asPoint y; radial: false.	fill origin: ((width asPoint x // 2) @ (width asPoint y // 2)) negated.	fill pixelRamp: (fill computePixelRampOfSize: 16).	fill isTranslucent. "precompute"	lineStyles ifNil:[lineStyles _ Array new: 37].	lineStyles at: index put: fill.	^fill! !!CComplexBorder methodsFor: 'private'!intersectFrom: startPt with: startDir to: endPt with: endDir	"Compute the intersection of two lines. Return nil if either		* the intersection does not exist, or		* the intersection is 'before' startPt, or		* the intersection is 'after' endPt	"	| det deltaPt alpha beta |	det _ (startDir x * endDir y) - (startDir y * endDir x).	det = 0.0 ifTrue:[^nil]. "There's no solution for it"	deltaPt _ endPt - startPt.	alpha _ (deltaPt x * endDir y) - (deltaPt y * endDir x).	beta _ (deltaPt x * startDir y) - (deltaPt y * startDir x).	alpha _ alpha / det.	beta _ beta / det.	alpha < 0 ifTrue:[^nil].	beta > 1.0 ifTrue:[^nil].	"And compute intersection"	^(startPt x + (alpha * startDir x)) @ (startPt y + (alpha * startDir y))! !!CComplexBorder methodsFor: 'drawing' stamp: 'ar 12/7/2002 22:13'!drawLineFrom: startPoint to: stopPoint on: aCanvas	"Here we're using the balloon engine since this is much faster than BitBlt w/ brushes."	| delta length dir cos sin tfm w h w1 w2 h1 h2 fill |	width isPoint ifTrue:[w _ width x. h _ width y] ifFalse:[w _ h _ width].	w1 _ w // 2.	w2 _ w - w1.	h1 _ h // 2. 	h2 _ h - h1.	"Compute the rotational transform from (0@0) -> (1@0) to startPoint -> stopPoint"	delta _ stopPoint - startPoint.	length _ delta r.	length > 1.0e-10 ifTrue:[dir _ delta / length] ifFalse:[dir _ 1@0].	cos _ dir dotProduct: (1@0).		sin _ dir crossProduct: (1@0).	tfm _ (CMatrixTransform new) a11: cos; a12: sin; a21: sin negated; a22: cos.	"Install the start point offset"	tfm offset: startPoint.	"Now get the fill style appropriate for the given direction"	fill _ self fillStyleForDirection: dir.	"And draw..."	aCanvas asBalloonCanvas transformBy: tfm during:[:cc|		cc drawPolygon: { 			(0-w1) @ (0-h1). "top left"			(length + w2) @ (0-h1). "top right"			(length + w2) @ (h2). "bottom right"			(0-w1) @ (h2). "bottom left"		} fillStyle: fill.	].! !!CComplexBorder methodsFor: 'drawing' stamp: 'ar 12/7/2002 22:14'!drawPolyPatchFrom: startPoint to: stopPoint on: aCanvas usingEnds: endsArray	| cos sin tfm fill dir fsOrigin fsDirection points x y |	dir _ (stopPoint - startPoint) normalized.	"Compute the rotational transform from (0@0) -> (1@0) to startPoint -> stopPoint"	cos _ dir dotProduct: (1@0).	sin _ dir crossProduct: (1@0).	"Now get the fill style appropriate for the given direction"	fill _ self fillStyleForDirection: dir.false ifTrue:[	"Transform the fill appropriately"	fill _ fill clone.	"Note: Code below is inlined from tfm transformPoint:/transformDirection:"	x _ fill origin x. y _ fill origin y.	fsOrigin _ ((x * cos) + (y * sin) + startPoint x) @					((y * cos) - (x * sin) + startPoint y).	x _ fill direction x. y _ fill direction y.	fsDirection _ ((x * cos) + (y * sin)) @ ((y * cos) - (x * sin)).	fill origin: fsOrigin; 		direction: fsDirection rounded; "NOTE: This is a bug in the balloon engine!!!!!!"		normal: nil.	aCanvas asBalloonCanvas drawPolygon: endsArray fillStyle: fill.] ifFalse:[	"Transform the points rather than the fills"	tfm _ (CMatrixTransform new) a11: cos; a12: sin; a21: sin negated; a22: cos.	"Install the start point offset"	tfm offset: startPoint.	points _ endsArray collect:[:pt| tfm invertPoint: pt].	aCanvas asBalloonCanvas transformBy: tfm during:[:cc|		cc drawPolygon: points fillStyle: fill.	].].! !!CComplexBorder methodsFor: 'drawing'!framePolygon2: vertices on: aCanvas	| dir1 dir2 dir3 nrm1 nrm2 nrm3 point1 point2 point3 	 cross1 cross2 pointA pointB pointC pointD w p1 p2 p3 p4 balloon ends |	balloon _ aCanvas asBalloonCanvas.	balloon == aCanvas ifFalse:[balloon deferred: true].	ends _ Array new: 4.	w _ width * 0.5.	pointA _ nil.	1 to: vertices size do:[:i|		p1 _ vertices atWrap: i.		p2 _ vertices atWrap: i+1.		p3 _ vertices atWrap: i+2.		p4 _ vertices atWrap: i+3.		dir1 _ p2 - p1.		dir2 _ p3 - p2.		dir3 _ p4 - p3.		i = 1 ifTrue:[			"Compute the merge points of p1->p2 with p2->p3"			cross1 _ dir2 crossProduct: dir1.			nrm1 _ dir1 normalized. nrm1 _ (nrm1 y * w) @ (0 - nrm1 x * w).			nrm2 _ dir2 normalized. nrm2 _ (nrm2 y * w) @ (0 - nrm2 x * w).			cross1 < 0 ifTrue:[nrm1 _ nrm1 negated. nrm2 _ nrm2 negated].			point1 _ (p1 x + nrm1 x) @ (p1 y + nrm1 y).			point2 _ (p2 x + nrm2 x) @ (p2 y + nrm2 y).			pointA _ self intersectFrom: point1 with: dir1 to: point2 with: dir2.			point1 _ (p1 x - nrm1 x) @ (p1 y - nrm1 y).			point2 _ (p2 x - nrm2 x) @ (p2 y - nrm2 y).			pointB _ self intersectFrom: point1 with: dir1 to: point2 with: dir2.			pointB ifNotNil:[				(pointB x - p2 x) abs + (pointB y - p2 y) abs > (4*w) ifTrue:[pointA _ pointB _ nil].			].		].		"Compute the merge points of p2->p3 with p3->p4"		cross2 _ dir3 crossProduct: dir2.		nrm2 _ dir2 normalized. nrm2 _ (nrm2 y * w) @ (0 - nrm2 x * w).		nrm3 _ dir3 normalized. nrm3 _ (nrm3 y * w) @ (0 - nrm3 x * w).		cross2 < 0 ifTrue:[nrm2 _ nrm2 negated. nrm3 _ nrm3 negated].		point2 _ (p2 x + nrm2 x) @ (p2 y + nrm2 y).		point3 _ (p3 x + nrm3 x) @ (p3 y + nrm3 y).		pointC _ self intersectFrom: point2 with: dir2 to: point3 with: dir3.		point2 _ (p2 x - nrm2 x) @ (p2 y - nrm2 y).		point3 _ (p3 x - nrm3 x) @ (p3 y - nrm3 y).		pointD _ self intersectFrom: point2 with: dir2 to: point3 with: dir3.		pointD ifNotNil:[			(pointD x - p3 x) abs + (pointD y - p3 y) abs > (4*w) ifTrue:[pointC _ pointD _ nil].		].		cross1 * cross2 < 0.0 ifTrue:[			point1 _ pointA.			pointA _ pointB.			pointB _ point1.			cross1 _ 0.0 - cross1].		ends at: 1 put: pointA; at: 2 put: pointB; at: 3 put: pointD; at: 4 put: pointC.		pointA ifNil:["degenerate and slow"			nrm2 _ dir2 normalized. nrm2 _ (nrm2 y * w) @ (0 - nrm2 x * w).			cross1 < 0 ifTrue:[nrm2 _ nrm2 negated].			point2 _ (p2 x + nrm2 x) @ (p2 y + nrm2 y).			ends at: 1 put: point2].		pointB ifNil:["degenerate and slow"			nrm2 _ dir2 normalized. nrm2 _ (nrm2 y * w) @ (0 - nrm2 x * w).			cross1 < 0 ifTrue:[nrm2 _ nrm2 negated].			point2 _ (p2 x - nrm2 x) @ (p2 y - nrm2 y).			ends at: 2 put: point2].		pointC ifNil:["degenerate and slow"			nrm2 _ dir2 normalized. nrm2 _ (nrm2 y * w) @ (0 - nrm2 x * w).			cross2 < 0 ifTrue:[nrm2 _ nrm2 negated].			point2 _ (p3 x + nrm2 x) @ (p3 y + nrm2 y).			ends at: 4 put: point2].		pointD ifNil:["degenerate and slow"			nrm2 _ dir2 normalized. nrm2 _ (nrm2 y * w) @ (0 - nrm2 x * w).			cross2 < 0 ifTrue:[nrm2 _ nrm2 negated].			point2 _ (p3 x - nrm2 x) @ (p3 y - nrm2 y).			ends at: 3 put: point2].		self drawPolyPatchFrom: p2 to: p3 on: balloon usingEnds: ends.		pointA _ pointC.		pointB _ pointD.		cross1 _ cross2.	].	balloon == aCanvas ifFalse:[balloon flush].! !!CComplexBorder methodsFor: 'drawing'!framePolygon: vertices on: aCanvas	| dir1 dir2 dir3 nrm1 nrm2 nrm3 point1 point2 point3 	 cross1 cross2 pointA pointB pointC pointD w p1 p2 p3 p4 balloon ends pointE pointF |	balloon _ aCanvas asBalloonCanvas.	balloon == aCanvas ifFalse:[balloon deferred: true].	ends _ Array new: 6.	w _ width * 0.5.	pointA _ nil.	1 to: vertices size do:[:i|		p1 _ vertices atWrap: i.		p2 _ vertices atWrap: i+1.		p3 _ vertices atWrap: i+2.		p4 _ vertices atWrap: i+3.		dir1 _ p2 - p1.		dir2 _ p3 - p2.		dir3 _ p4 - p3.		(i = 1 | true) ifTrue:[			"Compute the merge points of p1->p2 with p2->p3"			cross1 _ dir2 crossProduct: dir1.			nrm1 _ dir1 normalized. nrm1 _ (nrm1 y * w) @ (0 - nrm1 x * w).			nrm2 _ dir2 normalized. nrm2 _ (nrm2 y * w) @ (0 - nrm2 x * w).			cross1 < 0 ifTrue:[nrm1 _ nrm1 negated. nrm2 _ nrm2 negated].			point1 _ (p1 x + nrm1 x) @ (p1 y + nrm1 y).			point2 _ (p2 x + nrm2 x) @ (p2 y + nrm2 y).			pointA _ self intersectFrom: point1 with: dir1 to: point2 with: dir2.			point1 _ (p1 x - nrm1 x) @ (p1 y - nrm1 y).			point2 _ (p2 x - nrm2 x) @ (p2 y - nrm2 y).			pointB _ point1 + dir1 + point2 * 0.5.			pointB _ p2 + ((pointB - p2) normalized * w).			pointC _ point2.		].		"Compute the merge points of p2->p3 with p3->p4"		cross2 _ dir3 crossProduct: dir2.		nrm2 _ dir2 normalized. nrm2 _ (nrm2 y * w) @ (0 - nrm2 x * w).		nrm3 _ dir3 normalized. nrm3 _ (nrm3 y * w) @ (0 - nrm3 x * w).		cross2 < 0 ifTrue:[nrm2 _ nrm2 negated. nrm3 _ nrm3 negated].		point2 _ (p2 x + nrm2 x) @ (p2 y + nrm2 y).		point3 _ (p3 x + nrm3 x) @ (p3 y + nrm3 y).		pointD _ self intersectFrom: point2 with: dir2 to: point3 with: dir3.		point2 _ (p2 x - nrm2 x) @ (p2 y - nrm2 y).		point3 _ (p3 x - nrm3 x) @ (p3 y - nrm3 y).		pointF _ point2 + dir2.		pointE _ pointF + point3 * 0.5.		pointE _ p3 + ((pointE - p3) normalized * w).		cross1 * cross2 < 0.0 ifTrue:[			ends				at: 1 put: pointA;				at: 2 put: pointB;				at: 3 put: pointC;				at: 4 put: pointD;				at: 5 put: pointE;				at: 6 put: pointF.		] ifFalse:[			ends 				at: 1 put: pointA; 				at: 2 put: pointB;				at: 3 put: pointC; 				at: 4 put: pointF; 				at: 5 put: pointE;				at: 6 put: pointD.		].		self drawPolyPatchFrom: p2 to: p3 on: balloon usingEnds: ends.		pointA _ pointD.		pointB _ pointE.		pointC _ pointF.		cross1 _ cross2.	].	balloon == aCanvas ifFalse:[balloon flush].! !!CComplexBorder methodsFor: 'drawing'!frameRectangle: aRectangle on: aCanvas	"Note: This uses BitBlt since it's roughly a factor of two faster for rectangles"	| w h r topLeft topRight bottomLeft rectWidth rectHeight |	self colors ifNil:[^super frameRectangle: aRectangle on: aCanvas].	topLeft := aRectangle topLeft.	bottomLeft := aRectangle bottomLeft.	topRight := aRectangle topRight.	rectWidth := topRight x - topLeft x.	rectHeight := bottomLeft y - topLeft y.	w := self width.	w isPoint ifTrue:[h := w y. w := w x] ifFalse:[h := w].	1 to: h do:[:i| "top/bottom"		r := (topLeft + (i-1)) extent: (rectWidth - (i-1*2))@1. "top"		aCanvas fillRectangle: r color: (colors at: i).		r := (bottomLeft + (i @ (0-i))) extent: (rectWidth - (i-1*2) - 1)@1. "bottom"		aCanvas fillRectangle: r color: (colors at: colors size - i + 1).	].	1 to: w do:[:i| "left/right"		r := (topLeft + (i-1)) extent: 1@(rectHeight - (i-1*2)). "left"		aCanvas fillRectangle: r color: (colors at: i).		r := topRight + ((0-i)@i) extent: 1@(rectHeight - (i-1*2) - 1). "right"		aCanvas fillRectangle: r color: (colors at: colors size - i + 1).	].! !!CComplexBorder methodsFor: 'accessing'!colors	^colors ifNil:[colors _ self computeColors].! !!CComplexBorder methodsFor: 'accessing'!colorsAtCorners	| c c14 c23 |	c _ self color.	(style == #complexRaised) ifTrue:[		c14 _ c lighter. c23 _ c darker.		^Array with: c14 with: c with: c23 with: c].	(style == #complexInset) ifTrue:[		c14 _ c lighter. c23 _ c darker.		^Array with: c23 with: c with: c14 with: c].	style == #complexAltRaised ifTrue:[		c14 _ c lighter. c23 _ c darker.		^Array with: c14 with: c with: c23 with: c].	style == #complexAltInset ifTrue:[		c14 _ c darker. c23 _ c lighter.		^Array with: c14 with: c with: c23 with: c].	^super colorsAtCorners! !!CComplexBorder methodsFor: 'accessing'!style	^style! !!CComplexBorder methodsFor: 'accessing' stamp: 'bf 3/30/2004 10:39'!style: newStyle	style == newStyle ifTrue:[^self].	style _ newStyle.	self releaseCachedState.	^ newStyle! !!CComplexBorder methodsFor: 'accessing'!widthForRounding	^0! !!CComplexBorder methodsFor: 'color tracking'!trackColorFrom: aCostume	baseColor ifNil:[self color: aCostume raisedColor].! !!CComplexBorder methodsFor: 'initialize'!releaseCachedState	colors := nil.	lineStyles := nil.! !!CComplexBorder methodsFor: 'testing'!isComplex	^true! !!CInsetBorder methodsFor: 'accessing'!bottomRightColor	^width = 1 		ifTrue: [color alphaMixed: 0.5 with: Color white]		ifFalse: [color alphaMixed: 0.83333 with: Color white]! !!CInsetBorder methodsFor: 'accessing'!colorsAtCorners	| c c14 c23 |	c _ self color.	c14 _ c lighter. c23 _ c darker.	^Array with: c23 with: c14 with: c14 with: c23.! !!CInsetBorder methodsFor: 'accessing'!style	^#inset! !!CInsetBorder methodsFor: 'accessing'!topLeftColor	^width = 1 		ifTrue: [color alphaMixed: 0.5 with: Color black]		ifFalse: [color alphaMixed: 0.83333 with: Color black]! !!CInsetBorder methodsFor: 'color tracking'!trackColorFrom: aCostume	baseColor ifNil:[self color: aCostume insetColor].! !!CRaisedBorder methodsFor: 'accessing'!bottomRightColor	^width = 1 		ifTrue: [color alphaMixed: 0.5 with: Color black]		ifFalse: [color alphaMixed: 0.83333 with: Color black]! !!CRaisedBorder methodsFor: 'accessing'!colorsAtCorners	| c c14 c23 |	c _ self color.	c14 _ c lighter. c23 _ c darker.	^Array with: c14 with: c23 with: c23 with: c14! !!CRaisedBorder methodsFor: 'accessing'!style	^#raised! !!CRaisedBorder methodsFor: 'accessing'!topLeftColor	^width = 1 		ifTrue: [color alphaMixed: 0.5 with: Color white]		ifFalse: [color alphaMixed: 0.83333 with: Color white]! !!CRaisedBorder methodsFor: 'color tracking'!trackColorFrom: aCostume	baseColor ifNil:[self color: aCostume raisedColor].! !!CSimpleLayout methodsFor: 'layout' stamp: 'ar 3/15/2003 17:01'!flushLayoutCache	"Flush any cached information associated with the receiver"	minExtentCache := nil.! !!CSimpleLayout methodsFor: 'layout' stamp: 'ar 3/15/2003 17:01'!layout: aMorph in: newBounds	"Compute the layout for the given morph based on the new bounds"	aMorph layoutTargets do:[:m| m layoutSimplyIn: newBounds].! !!CSimpleLayout methodsFor: 'layout' stamp: 'ar 3/15/2003 17:02'!minExtentOf: aMorph in: newBounds	"Return the minimal size aMorph's children would require given the new bounds"	| min extent |	minExtentCache == nil ifFalse:[^minExtentCache].	min _ 0@0.	aMorph layoutTargets do:[:m|		extent _ m minExtent.		min _ min max: extent].	^minExtentCache := min! !!CSimpleLayout methodsFor: 'testing' stamp: 'ar 3/15/2003 17:01'!isSimpleLayout	^true! !!CSimpleTextEditor methodsFor: 'initialize' stamp: 'ar 4/5/2004 02:11'!initialize	super initialize.	"Define our components"	self define: #window as: CWindow new.	self define: #editor as: CTextEditor new.! !!CSimpleTextEditor methodsFor: 'initialize' stamp: 'ar 4/30/2004 15:53'!setupCostume	"Create the default costume"	super setupCostume.	self costume: window.	self extent: 400@265.	self layout: CProportionalLayout new.	editor color: Color white.	editor layoutFrame: (0@0 corner: 1@1).	editor hResizing: #spaceFill; vResizing: #spaceFill.	editor textWrap: true.	editor hScrollable: false; vScrollable: true.	window add: editor.	"Give all of my contents the default look"	window elements do:[:each|		each borderWidth: 2.		each borderStyle: #complexAltInset.		each borderColor: (Color r: 0.995 g: 0.788 b: 0.353)	].	window label: 'SimpleText'.	"window color: (Color r: 0.67 g: 0.67 b: 0.67)."! !!CSimpleTextEditor methodsFor: 'accessing' stamp: 'ar 4/5/2004 02:11'!editor	"Answer the editor of the receiver"	<bewareOf: #editorChanged>	^self propertyValueAt: #editor! !!CSimpleTextEditor methodsFor: 'accessing' stamp: 'ar 4/5/2004 02:11'!editor: aValue	"Modify the receiver's editor"	^self propertyValueAt: #editor put: aValue with: #editorChanged! !!CSimpleTextEditor methodsFor: 'accessing' stamp: 'tk 6/29/2004 14:16'!geometry	"My window has my bounds"	^window geometry! !!CSimpleTextEditor methodsFor: 'accessing' stamp: 'ar 4/5/2004 02:11'!window	"Answer the window of the receiver"	<bewareOf: #windowChanged>	^self propertyValueAt: #window! !!CSimpleTextEditor methodsFor: 'accessing' stamp: 'ar 4/5/2004 02:11'!window: aValue	"Modify the receiver's window"	^self propertyValueAt: #window put: aValue with: #windowChanged! !!CSolidFill methodsFor: 'testing'!isSolidFill	^true! !!CSolidFill methodsFor: 'testing'!isTranslucent	^color isTranslucent! !!CSolidFill methodsFor: 'testing'!isTransparent	^color isTransparent! !!CSolidFill methodsFor: 'printing'!printOn: aStream	super printOn: aStream.	aStream nextPut:$(; print: color; nextPut:$).! !!CSolidFill methodsFor: 'accessing'!color: aColor	color _ aColor.	pixelValue32 _ aColor scaledPixelValue32! !!CSolidFill methodsFor: 'accessing'!display	^color display! !!CSolidFill methodsFor: 'accessing'!scaledPixelValue32	"Return the alpha scaled pixel value for depth 32"	^pixelValue32! !!CSolidFill methodsFor: 'accessing'!style	^#solid! !!CSolidFill methodsFor: 'converting'!asColor	^color! !!CSoundPlayer methodsFor: 'initialize' stamp: 'ar 3/14/2004 17:47'!initialize	super initialize.	self color: Color white.! !!CSoundResource methodsFor: 'accessing' stamp: 'ar 3/14/2004 16:55'!resourceType	"Answer the type of this resource. Types must be unique across all resource types."	^#sound! !!CSoundResource methodsFor: 'Sound-support' stamp: 'ar 3/14/2004 17:46'!play	sound play! !!CSoundResource methodsFor: 'private' stamp: 'ar 3/14/2004 17:30'!extractMediaFrom: mbr	"Extract media from the given archive member"	| stream file |	stream := mbr contentStream.	stream binary.	type == #mp3 ifFalse:[		sound := self class readFrom: stream type: type.		^self	].	"We need to extract MP3 first since we can only play straight from file"	file := self extractToCache: stream.	[sound := self class readFrom: file type: type] ensure:[file close].! !!CSoundResource methodsFor: 'private' stamp: 'ar 3/14/2004 17:20'!rawMediaExtension	"Currently unsupported"	^''! !!CSoundResource methodsFor: 'private' stamp: 'ar 3/14/2004 17:23'!setMedia: media	sound := media! !!CSoundResource methodsFor: 'private' stamp: 'ar 3/14/2004 17:21'!storeRawMediaContentsOn: aStream	"Currently unsupported"	^self error:'Not implemented'! !!CSoundResource methodsFor: 'private' stamp: 'ar 3/14/2004 17:31'!storeXmlMediaAttributesOn: xmlWriter	"Basic sound attributes"! !!CSpinnerList methodsFor: 'initialize' stamp: 'ar 3/7/2004 20:08'!defaultCostume	^CWidgetLibrary default spinnerListCostume! !!CStringList methodsFor: 'initialize' stamp: 'ar 3/14/2004 15:50'!defaultCostume	^CStringListCostume! !!CStyleReadoutList methodsFor: 'initialize' stamp: 'ar 4/30/2004 15:54'!setupCostume	super setupCostume.	self layout: CTableLayout new.	self hResizing: #spaceFill; vResizing: #shrinkWrap.	self layout listDirection: #leftToRight; wrapDirection: #topToBottom.	self layout layoutInset: 4; cellInset: 2.! !!CStyleReadoutList methodsFor: 'accessing' stamp: 'ar 3/16/2004 17:34'!selection	"Answer the selection of the receiver"	<bewareOf: #selectionChanged>	^self propertyValueAt: #selection! !!CStyleReadoutList methodsFor: 'accessing' stamp: 'ar 3/16/2004 17:34'!selection: aValue	"Modify the receiver's selection"	^self propertyValueAt: #selection put: aValue with: #selectionChanged! !!CStyleReadoutList methodsFor: 'events' stamp: 'ar 3/17/2004 03:34'!onCursorChanged	<on: cursorChanged in: elements>	elements cursor = 0 ifTrue:[^self].	selection ifNotNil:[selection deselect].	selection := elements selection.	selection ifNotNil:[selection select].	value := selection value.! !!CStyleReadoutList methodsFor: 'events' stamp: 'ar 3/16/2004 17:42'!onMouseDown	| item |	<on: mouseDown>	item := self findPlayerAt: self cursorPoint.	item ifNotNil:[elements selection: item].! !!CStyleReadoutList methodsFor: 'events' stamp: 'ar 3/16/2004 17:27'!onValueChanged	<on: valueChanged>	elements selection: (elements findFirstElement:[:item| item value == value]).! !!CTabButtonList methodsFor: 'initialize' stamp: 'ar 3/13/2004 22:35'!defaultCostume	^CTabButtonListCostume! !!CTabButtonList methodsFor: 'initialize' stamp: 'ar 3/24/2004 23:53'!initialize	"Initialize me to use a CTabButton as the default item maker"	super initialize.	allowDeselect := false.	itemMaker := CTabButton.! !!CTableLayout methodsFor: 'initialize' stamp: 'ar 3/24/2004 03:29'!initialize	super initialize.	properties := CTableLayoutProperties new initialize.! !!CTableLayout methodsFor: 'initialize' stamp: 'ar 3/25/2004 18:04'!loadFrom: aLayout	properties := aLayout properties copy.! !!CTableLayout methodsFor: 'initialize' stamp: 'ar 3/24/2004 03:01'!newListDirection: aSymbol	| oldWrap wrapDir |	oldWrap := self wrapDirection.	wrapDir := self updateWrapDirection: aSymbol.	self tweak: #listDirection to: aSymbol.	wrapDir ifNotNil:[self tweaked: #wrapDirection from: oldWrap to: wrapDir].! !!CTableLayout methodsFor: 'accessing' stamp: 'ar 3/24/2004 02:25'!cellInset	"Layout specific. This property specifies an extra inset for each cell in the layout."	^properties cellInset! !!CTableLayout methodsFor: 'accessing' stamp: 'ar 3/24/2004 02:22'!cellInset: aNumber	"Layout specific. This property specifies an extra inset for each cell in the layout."	properties cellInset: aNumber.	self invalidateLayout.! !!CTableLayout methodsFor: 'accessing' stamp: 'ar 3/24/2004 02:25'!cellPositioning	"Layout specific. This property describes how the receiver should be layed out in its owner when the bounds of the cell assigned to the receiver do not exactly match its bounds. Possible values are:		#topLeft, #topRight, #bottomLeft, #bottomRight, #topCenter, #leftCenter, #rightCenter, #bottomCenter, #center 	which align the receiver's bounds with the cell at the given point."	^properties cellPositioning! !!CTableLayout methodsFor: 'accessing' stamp: 'ar 3/24/2004 02:22'!cellPositioning: aSymbol	"Layout specific. This property describes how the receiver should be layed out in its owner when the bounds of the cell assigned to the receiver do not exactly match its bounds. Possible values are:		#topLeft, #topRight, #bottomLeft, #bottomRight, #topCenter, #leftCenter, #rightCenter, #bottomCenter, #center 	which align the receiver's bounds with the cell at the given point."	properties cellPositioning: aSymbol.	self invalidateLayout.! !!CTableLayout methodsFor: 'accessing' stamp: 'ar 3/24/2004 02:25'!cellSpacing	"Layout specific. This property describes how the cell size for each element in a list should be computed.		#globalRect - globally equal rectangular cells		#globalSquare - globally equal square cells		#localRect - locally (e.g., per row/column) equal rectangular cells		#localSquare - locally (e.g., per row/column) equal square cells		#none - cells are sized based on available row/column constraints	"	^properties cellSpacing! !!CTableLayout methodsFor: 'accessing' stamp: 'ar 3/24/2004 02:22'!cellSpacing: aSymbol	"Layout specific. This property describes how the cell size for each element in a list should be computed.		#globalRect - globally equal rectangular cells		#globalSquare - globally equal square cells		#localRect - locally (e.g., per row/column) equal rectangular cells		#localSquare - locally (e.g., per row/column) equal square cells		#none - cells are sized based on available row/column constraints	"	properties cellSpacing: aSymbol.	self invalidateLayout.! !!CTableLayout methodsFor: 'accessing' stamp: 'ar 3/24/2004 02:26'!inset	"Return the extra inset for layouts"	^properties inset! !!CTableLayout methodsFor: 'accessing' stamp: 'ar 3/24/2004 02:26'!listCentering	"Layout specific. This property describes how the rows/columns in a list-like layout should be centered.		#topLeft - center at start of primary direction		#bottomRight - center at end of primary direction		#center - center in the middle of primary direction		#justified - insert extra space inbetween rows/columns	"	^properties listCentering! !!CTableLayout methodsFor: 'accessing' stamp: 'ar 3/24/2004 02:22'!listCentering: aSymbol	"Layout specific. This property describes how the rows/columns in a list-like layout should be centered.		#topLeft - center at start of primary direction		#bottomRight - center at end of primary direction		#center - center in the middle of primary direction		#justified - insert extra space inbetween rows/columns	"	properties listCentering: aSymbol.	self invalidateLayout.! !!CTableLayout methodsFor: 'accessing' stamp: 'ar 3/24/2004 02:27'!listDirection	"Layout specific. This property describes the direction in which a list-like layout should be applied. Possible values are:		#leftToRight		#rightToLeft		#topToBottom		#bottomToTop	indicating the direction in which any layout should take place"	^properties listDirection! !!CTableLayout methodsFor: 'accessing' stamp: 'ar 3/24/2004 02:23'!listDirection: aSymbol	"Layout specific. This property describes the direction in which a list-like layout should be applied. Possible values are:		#leftToRight		#rightToLeft		#topToBottom		#bottomToTop	indicating the direction in which any layout should take place"	properties listDirection: aSymbol.	self updateWrapDirection.	self invalidateLayout.! !!CTableLayout methodsFor: 'accessing' stamp: 'ar 3/24/2004 02:27'!listSpacing	"Layout specific. This property describes how the heights for different rows in a table layout should be handled.		#equal - all rows have the same height		#none - all rows may have different heights	"	^properties listSpacing! !!CTableLayout methodsFor: 'accessing' stamp: 'ar 3/24/2004 02:23'!listSpacing: aSymbol	"Layout specific. This property describes how the heights for different rows in a table layout should be handled.		#equal - all rows have the same height		#none - all rows may have different heights	"	properties listSpacing: aSymbol.	self invalidateLayout.! !!CTableLayout methodsFor: 'accessing' stamp: 'ar 3/24/2004 02:27'!maxCellSize	"Layout specific. This property specifies the maximum size of a table cell."	^properties maxCellSize! !!CTableLayout methodsFor: 'accessing' stamp: 'ar 3/24/2004 02:23'!maxCellSize: aPoint	"Layout specific. This property specifies the maximum size of a table cell."	properties maxCellSize: aPoint.	self invalidateLayout.! !!CTableLayout methodsFor: 'accessing' stamp: 'ar 3/24/2004 02:27'!minCellSize	"Layout specific. This property specifies the minimal size of a table cell."	^properties minCellSize! !!CTableLayout methodsFor: 'accessing' stamp: 'ar 3/24/2004 02:24'!minCellSize: aPoint	"Layout specific. This property specifies the minimal size of a table cell."	properties minCellSize: aPoint.	self invalidateLayout.! !!CTableLayout methodsFor: 'accessing' stamp: 'ar 3/24/2004 02:28'!reverseTableCells	"Layout specific. This property describes if the cells should be treated in reverse order of children."	^properties reverseTableCells! !!CTableLayout methodsFor: 'accessing' stamp: 'ar 3/24/2004 02:24'!reverseTableCells: aBool	"Layout specific. This property describes if the cells should be treated in reverse order of children."	properties reverseTableCells: aBool.	self invalidateLayout.! !!CTableLayout methodsFor: 'accessing' stamp: 'ar 3/24/2004 02:28'!rubberBandCells	"Layout specific. This property describes if a parent that is #shrinkWrapped around its children should ignore any #spaceFill children. E.g., when #rubberBandCells is true, the compound layout will always stay at the smallest available size, even though some child may be able to grow."	^properties rubberBandCells! !!CTableLayout methodsFor: 'accessing' stamp: 'ar 3/24/2004 02:24'!rubberBandCells: aBool	"Layout specific. This property describes if a parent that is #shrinkWrapped around its children should ignore any #spaceFill children. E.g., when #rubberBandCells is true, the compound layout will always stay at the smallest available size, even though some child may be able to grow."	properties rubberBandCells: aBool.	self invalidateLayout.! !!CTableLayout methodsFor: 'accessing' stamp: 'ar 3/24/2004 02:28'!wrapCentering	"Layout specific. This property describes how the rows/columns in a list-like layout should be centered.		#topLeft - center at start of secondary direction		#bottomRight - center at end of secondary direction		#center - center in the middle of secondary direction		#justified - insert extra space inbetween rows/columns	"	^properties wrapCentering! !!CTableLayout methodsFor: 'accessing' stamp: 'ar 3/24/2004 02:24'!wrapCentering: aSymbol	"Layout specific. This property describes how the rows/columns in a list-like layout should be centered.		#topLeft - center at start of secondary direction		#bottomRight - center at end of secondary direction		#center - center in the middle of secondary direction		#justified - insert extra space inbetween rows/columns	"	properties wrapCentering: aSymbol.	self invalidateLayout.! !!CTableLayout methodsFor: 'accessing' stamp: 'ar 3/24/2004 02:29'!wrapDirection	"Layout specific. This property describes the direction along which a list-like layout should be wrapped. Possible values are:		#leftToRight		#rightToLeft		#topToBottom		#bottomToTop		#none	indicating in which direction wrapping should occur. This direction must be orthogonal to the list direction, that is if listDirection is #leftToRight or #rightToLeft then wrapDirection must be #topToBottom or #bottomToTop and vice versa."	^properties wrapDirection! !!CTableLayout methodsFor: 'accessing' stamp: 'ar 3/24/2004 02:24'!wrapDirection: aSymbol	"Layout specific. This property describes the direction along which a list-like layout should be wrapped. Possible values are:		#leftToRight		#rightToLeft		#topToBottom		#bottomToTop		#none	indicating in which direction wrapping should occur. This direction must be orthogonal to the list direction, that is if listDirection is #leftToRight or #rightToLeft then wrapDirection must be #topToBottom or #bottomToTop and vice versa."	properties wrapDirection: aSymbol.	self invalidateLayout.! !!CTableLayout methodsFor: 'layout'!computeCellArrangement: cellHolder in: newBounds horizontal: aBool target: aMorph	"Compute number of cells we can put in each row/column. The returned array contains a list of all the cells we can put into the row/column at each level.	Note: The arrangement is so that the 'x' value of each cell advances along the list direction and the 'y' value along the wrap direction. The returned arrangement has an extra cell at the start describing the width and height of the row."	| cells wrap spacing output maxExtent n sum index max cell first last w cellMax maxCell hFill vFill inset |	maxCell _ cellHolder key.	cells _ cellHolder value.	properties wrapDirection == #none 		ifTrue:[wrap _ SmallInteger maxVal]		ifFalse:[wrap _ aBool ifTrue:[newBounds width] ifFalse:[newBounds height].				wrap < maxCell x ifTrue:[wrap _ maxCell x]].	spacing _ properties cellSpacing.	(spacing == #globalRect or:[spacing = #globalSquare]) ifTrue:[		"Globally equal spacing is a very special case here, so get out fast and easy"		^self computeGlobalCellArrangement: cells 			in: newBounds horizontal: aBool 			wrap: wrap spacing: spacing].	output _ (WriteStream on: Array new).	inset _ properties cellInset asPoint.	aBool ifFalse:[inset _ inset transposed].	first _ last _ nil.	maxExtent _ 0@0.	sum _ 0.	index _ 1.	n _ 0.	hFill _ vFill _ false.	[index <= cells size] whileTrue:[		w _ sum.		cell _ cells at: index.		cellMax _ maxExtent max: cell cellSize. "e.g., minSize"		(spacing == #localRect or:[spacing == #localSquare]) ifTrue:[			"Recompute entire size of current row"			spacing == #localSquare 				ifTrue:[max _ cellMax x max: cellMax y]				ifFalse:[max _ cellMax x].			sum _ (n + 1) * max.		] ifFalse:[			sum _ sum + (cell cellSize x).		].		((sum + (n * inset x)) > wrap and:[first notNil]) ifTrue:[			"It doesn't fit and we're not starting a new line"			(spacing == #localSquare or:[spacing == #localRect]) ifTrue:[				spacing == #localSquare 					ifTrue:[maxExtent _ (maxExtent x max: maxExtent y) asPoint].				first do:[:c| c cellSize: maxExtent]].			w _ w + ((n - 1) * inset x).			"redistribute extra space"			first nextCell ifNotNil:[first nextCell do:[:c| c addExtraSpace: inset x@0]].			last _ CLayoutCell new.			last cellSize: w @ (maxExtent y).			last hSpaceFill: hFill.			last vSpaceFill: vFill.			last nextCell: first.			output position = 0 ifFalse:[last addExtraSpace: 0@inset y].			output nextPut: last.			first _ nil.			maxExtent _ 0@0.			sum _ 0.			n _ 0.			hFill _ vFill _ false.		] ifFalse:[			"It did fit; use next item from input"			first ifNil:[first _ last _ cell] ifNotNil:[last nextCell: cell. last _ cell].			index _ index+1.			n _ n + 1.			maxExtent _ cellMax.			hFill _ hFill or:[cell hSpaceFill].			vFill _ vFill or:[cell vSpaceFill].		].	].	first ifNotNil:[		last _ CLayoutCell new.		sum _ sum + ((n - 1) * inset x).		first nextCell ifNotNil:[first nextCell do:[:c| c addExtraSpace: inset x@0]].		last cellSize: sum @ maxExtent y.		last hSpaceFill: hFill.		last vSpaceFill: vFill.		last nextCell: first.		output position = 0 ifFalse:[last addExtraSpace: 0@inset y].		output nextPut: last].	output _ output contents.	properties listSpacing == #equal ifTrue:[		"Make all the heights equal"		max _ output inject: 0 into:[:size :c| size max: c cellSize y].		output do:[:c| c cellSize: c cellSize x @ max].	].	^output! !!CTableLayout methodsFor: 'layout' stamp: 'ar 3/24/2004 02:31'!computeCellSizes: aMorph in: newBounds horizontal: aBool	"Step 1: Compute the minimum extent for all the children of aMorph"	| cells cell size block maxCell minSize maxSize |	cells _ WriteStream on: (Array new: aMorph layoutTargets size).	minSize _ properties minCellSize asPoint.	maxSize _ properties maxCellSize asPoint.	aBool ifTrue:[		minSize _ minSize transposed.		maxSize _ maxSize transposed].	maxCell _ 0@0.	block _ [:m|			size _ m minExtent asIntegerPoint.			cell _ CLayoutCell new target: m.			aBool ifTrue:[				cell hSpaceFill: m hResizing == #spaceFill.				cell vSpaceFill: m vResizing == #spaceFill.			] ifFalse:[				cell hSpaceFill: m vResizing == #spaceFill.				cell vSpaceFill: m hResizing == #spaceFill.				size _ size transposed.			].			size _ (size min: maxSize) max: minSize.			cell cellSize: size.			maxCell _ maxCell max: size.			cells nextPut: cell].	properties reverseTableCells		ifTrue:[aMorph layoutTargets reverseDo: block]		ifFalse:[aMorph layoutTargets do: block].	^maxCell -> cells contents! !!CTableLayout methodsFor: 'layout' stamp: 'ar 3/24/2004 03:30'!computeExtraSpacing: arrangement in: newBounds horizontal: aBool target: aMorph	"Compute the required extra spacing for laying out the cells"	| extent extra centering n extraPerCell cell last hFill vFill max amount allow |	"match newBounds extent with arrangement's orientation"	extent _ newBounds extent.	aBool ifFalse:[extent _ extent transposed].	"figure out if we have any horizontal or vertical space fillers"	hFill _ vFill _ false.	max _ 0@0.	arrangement do:[:c|		max _ (max x max: c cellSize x) @ (max y + c cellSize y).		max _ max max: c cellSize.		hFill _ hFill or:[c hSpaceFill].		vFill _ vFill or:[c vSpaceFill]].	"Take client's shrink wrap constraints into account.	Note: these are only honored when there are no #spaceFill children,	or when #rubberBandCells is set."	allow _ properties rubberBandCells not.	aMorph hResizing == #shrinkWrap ifTrue:[		aBool 			ifTrue:[allow & hFill ifFalse:[extent _ max x @ (max y max: extent y)]]			ifFalse:[allow & vFill ifFalse:[extent _ (max x max: extent x) @ max y]]].	aMorph vResizing == #shrinkWrap ifTrue:[		aBool 			ifFalse:[allow & hFill ifFalse:[extent _ max x @ (max y max: extent y)]]			ifTrue:[allow & vFill ifFalse:[extent _ (max x max: extent x) @ max y]]].	"Now compute the extra v space"	extra _ extent y - (arrangement inject: 0 into:[:sum :c| sum + c cellSize y]).	extra > 0 ifTrue:[		"Check if we have any #spaceFillers"		vFill ifTrue:[ "use only #spaceFillers"			n _ arrangement inject: 0 into:[:sum :c| 				c vSpaceFill ifTrue:[sum + 1] ifFalse:[sum]].			n isZero ifFalse:[extraPerCell _ extra asFloat / n asFloat].			extra _ last _ 0.			arrangement do:[:c|				c vSpaceFill ifTrue:[					extra _ (last _ extra) + extraPerCell.					amount _ 0 @ (extra truncated - last truncated).					c do:[:cc| cc cellSize: cc cellSize + amount]]].		] ifFalse:[ "no #spaceFillers; distribute regularly"			centering _ properties wrapCentering.			"centering == #topLeft ifTrue:[]." "add all extra space to the last cell; e.g., do nothing"			centering == #bottomRight "add all extra space to the first cell"				ifTrue:[arrangement first addExtraSpace: 0@extra].			centering == #center "add 1/2 extra space to the first and last cell"				ifTrue:[arrangement first addExtraSpace: 0@ (extra // 2)].			centering == #justified "add extra space equally distributed to each cell"				ifTrue:[	n _ (arrangement size - 1) max: 1.						extraPerCell _ extra asFloat / n asFloat.						extra _ last _ 0.						arrangement do:[:c|							c addExtraSpace: 0@(extra truncated - last truncated).							extra _ (last _ extra) + extraPerCell]].		].	].	"Now compute the extra space for the primary direction"	centering _ properties listCentering.	1 to: arrangement size do:[:i|		cell _ (arrangement at: i).		extra _ extent x - cell cellSize x.		extra > 0 ifTrue:[			"Check if we have any #spaceFillers"			cell hSpaceFill ifTrue:[ "use only #spaceFillers"				cell _ cell nextCell.				n _ cell inject: 0 into:[:sum :c| 					c hSpaceFill ifTrue:[sum + 1] ifFalse:[sum]].				n isZero ifFalse:[extraPerCell _ extra asFloat / n asFloat].				extra _ last _ 0.				cell do:[:c|					c hSpaceFill ifTrue:[						extra _ (last _ extra) + (extraPerCell * 1).						amount _ extra truncated - last truncated.						c cellSize: c cellSize + (amount@0)]].			] ifFalse:[ "no #spaceFiller; distribute regularly"				cell _ cell nextCell.				"centering == #topLeft ifTrue:[]" "add all extra space to the last cell; e.g., do nothing"				centering == #bottomRight "add all extra space to the first cell"					ifTrue:[cell addExtraSpace: extra @ 0].				centering == #center "add 1/2 extra space to the first and last cell"					ifTrue:[cell addExtraSpace: (extra // 2) @ 0].				centering == #justified "add extra space equally distributed to each cell"					ifTrue:[	n _ (cell size - 1) max: 1.							extraPerCell _ extra asFloat / n asFloat.							extra _ last _ 0.							cell do:[:c|								c addExtraSpace: (extra truncated - last truncated) @ 0.								extra _ (last _ extra) + extraPerCell]].			].		].	].! !!CTableLayout methodsFor: 'layout'!computeGlobalCellArrangement: cells in: newBounds horizontal: aBool wrap: wrap spacing: spacing	"Compute number of cells we can put in each row/column. The returned array contains a list of all the cells we can put into the row/column at each level.	Note: The arrangement is so that the 'x' value of each cell advances along the list direction and the 'y' value along the wrap direction. The returned arrangement has an extra cell at the start describing the width and height of the row."	| output maxExtent n cell first last hFill vFill |	output _ (WriteStream on: Array new).	first _ last _ nil.	maxExtent _ cells inject: 0@0 into:[:size :c| size max: c cellSize "e.g., minSize"].	spacing == #globalSquare ifTrue:[maxExtent _ (maxExtent x max: maxExtent y) asPoint].	n _ (wrap // maxExtent x) max: 1.	hFill _ vFill _ false.	1 to: cells size do:[:i|		cell _ cells at: i.		hFill _ hFill or:[cell hSpaceFill].		vFill _ vFill or:[cell vSpaceFill].		cell cellSize: maxExtent.		first ifNil:[first _ last _ cell] ifNotNil:[last nextCell: cell. last _ cell].		(i \\ n) = 0 ifTrue:[			last _ CLayoutCell new.			last cellSize: (maxExtent x * n) @ (maxExtent y).			last hSpaceFill: hFill.			last vSpaceFill: vFill.			hFill _ vFill _ false.			last nextCell: first.			output nextPut: last.			first _ nil]].	first ifNotNil:[		last _ CLayoutCell new.		last cellSize: (maxExtent x * n) @ (maxExtent y). self flag: #arNote."@@@: n is not correct!!"		last nextCell: first.		output nextPut: last].	^output contents! !!CTableLayout methodsFor: 'layout'!flushLayoutCache	"Flush any cached information associated with the receiver"	minExtentCache _ nil.! !!CTableLayout methodsFor: 'layout' stamp: 'ar 3/24/2004 02:37'!layout: aMorph in: box	"Compute the layout for the given morph based on the new bounds"	| cells arrangement horizontal newBounds |	aMorph layoutTargets size = 0 ifTrue:[^self].	newBounds _ box origin asIntegerPoint corner: (box corner asIntegerPoint).	(properties wrapDirection == #none and:[properties cellSpacing == #none]) ifTrue:[		"get into the fast lane"		properties listCentering == #justified ifFalse:["can't deal with that"			properties listDirection == #leftToRight 				ifTrue:[^self layoutLeftToRight: aMorph in: newBounds].			properties listDirection == #topToBottom				ifTrue:[^self layoutTopToBottom: aMorph in: newBounds].		].	].	(properties listDirection == #topToBottom or:[properties listDirection == #bottomToTop])		ifTrue:[	horizontal _ false]		ifFalse:[	horizontal _ true].	"Step 1: Compute the minimum extent for all the children of aMorph"	cells _ self computeCellSizes: aMorph 				in: (0@0 corner: newBounds extent) 				horizontal: horizontal.	"Step 2: Compute the arrangement of the cells for each row and column"	arrangement _ self computeCellArrangement: cells 						in: newBounds 						horizontal: horizontal 						target: aMorph.	"Step 3: Compute the extra spacing for each cell"	self computeExtraSpacing: arrangement 		in: newBounds 		horizontal: horizontal 		target: aMorph.	"Step 4: Place the children within the cells accordingly"	self placeCells: arrangement 		in: newBounds 		horizontal: horizontal 		target: aMorph.! !!CTableLayout methodsFor: 'layout' stamp: 'ar 3/24/2004 02:37'!minExtentOf: aMorph in: box	"Return the minimal size aMorph's children would require given the new bounds"	| cells arrangement horizontal newBounds minX minY dir |	minExtentCache == nil ifFalse:[^minExtentCache].	aMorph layoutTargets size = 0 ifTrue:[^0@0].	(properties wrapDirection == #none and:[properties cellSpacing == #none]) ifTrue:[		"Get into the fast lane"		dir _ properties listDirection.		(dir == #leftToRight or:[dir == #rightToLeft])			ifTrue:[^self minExtentHorizontal: aMorph].		(dir == #topToBottom or:[dir == #bottomToTop])			ifTrue:[^self minExtentVertical: aMorph].	].	newBounds _ box origin asIntegerPoint corner: (box corner asIntegerPoint).	(properties listDirection == #topToBottom or:[properties listDirection == #bottomToTop])		ifTrue:[	horizontal _ false]		ifFalse:[	horizontal _ true].	"Step 1: Compute the minimum extent for all the children of aMorph"	cells _ self computeCellSizes: aMorph 				in: (0@0 corner: newBounds extent) 				horizontal: horizontal.	"Step 2: Compute the arrangement of the cells for each row and column"	arrangement _ self computeCellArrangement: cells 						in: newBounds 						horizontal: horizontal						target: aMorph.	"Step 3: Extract the minimum size out of the arrangement"	minX _ minY _ 0.	arrangement do:[:cell|		minX _ minX max: cell cellSize x + cell extraSpace x.		minY _ minY + cell cellSize y + cell extraSpace y].	horizontal 		ifTrue:[minExtentCache _ minX@minY]		ifFalse:[minExtentCache _ minY@minX].	^minExtentCache! !!CTableLayout methodsFor: 'layout'!placeCells: arrangement in: newBounds horizontal: aBool target: aMorph		 	"Place the morphs within the cells accordingly"	| xDir yDir anchor yDist place cell xDist cellRect corner inset |	inset _ properties cellInset.	(inset isNumber and:[inset isZero]) ifTrue:[inset _ nil].	aBool ifTrue:["horizontal layout"		properties listDirection == #rightToLeft ifTrue:[			xDir _ -1@0.			properties wrapDirection == #bottomToTop 				ifTrue:[yDir _ 0@-1. anchor _ newBounds bottomRight]				ifFalse:[yDir _ 0@1. anchor _ newBounds topRight].		] ifFalse:[			xDir _ 1@0.			properties wrapDirection == #bottomToTop				ifTrue:[yDir _ 0@-1. anchor _ newBounds bottomLeft]				ifFalse:[yDir _ 0@1. anchor _ newBounds topLeft]].	] ifFalse:["vertical layout"		properties listDirection == #bottomToTop ifTrue:[			xDir _ 0@-1.			properties wrapDirection == #rightToLeft				ifTrue:[yDir _ -1@0. anchor _ newBounds bottomRight]				ifFalse:[yDir _ 1@0. anchor _ newBounds bottomLeft]		] ifFalse:[			xDir _ 0@1.			properties wrapDirection == #rightToLeft				ifTrue:[yDir _ -1@0. anchor _ newBounds topRight]				ifFalse:[yDir _ 1@0. anchor _ newBounds topLeft]].	].	1 to: arrangement size do:[:i|		cell _ arrangement at: i.		cell extraSpace ifNotNil:[anchor _ anchor + (cell extraSpace y * yDir)].		yDist _ cell cellSize y * yDir. "secondary advance direction"		place _ anchor.		cell _ cell nextCell.		[cell == nil] whileFalse:[			cell extraSpace ifNotNil:[place _ place + (cell extraSpace x * xDir)].			xDist _ cell cellSize x * xDir. "primary advance direction"			corner _ place + xDist + yDist.			cellRect _ Rectangle origin: (place min: corner) corner: (place max: corner).			"@@@: Fix this. It's broken. :@@@"			"inset ifNotNil:[cellRect _ cellRect insetBy: inset]."			cell target layoutInBounds: cellRect.			place _ place + xDist.			cell _ cell nextCell].		anchor _ anchor + yDist.	].! !!CTableLayout methodsFor: 'copying' stamp: 'ar 3/24/2004 02:57'!postCopy	super postCopy.	properties := properties copy.! !!CTableLayout methodsFor: 'optimized' stamp: 'ar 3/24/2004 03:30'!layoutLeftToRight: aMorph in: newBounds	"An optimized left-to-right list layout"	| inset n size extent width height block sum vFill posX posY extra centering extraPerCell last amount minX minY maxX maxY sizeX sizeY first cell |	size _ properties minCellSize asPoint. minX _ size x. minY _ size y.	size _ properties maxCellSize asPoint. maxX _ size x. maxY _ size y.	inset _ properties cellInset asPoint x.	extent _ newBounds extent.	n _ 0. vFill _ false. sum _ 0.	width _ height _ 0.	first _ last _ nil.	block _ [:m|			n _ n + 1.			cell _ CLayoutCell new target: m.			(m hResizing == #spaceFill) ifTrue:[				cell hSpaceFill: true.				extra _ 1.				cell extraSpace: extra.				sum _ sum + extra.			] ifFalse:[cell hSpaceFill: false].			(m vResizing == #spaceFill) ifTrue:[vFill _ true].			size _ m minExtent. sizeX _ size x. sizeY _ size y.			sizeX < minX				ifTrue:[sizeX _ minX]				ifFalse:[sizeX > maxX ifTrue:[sizeX _ maxX]].			sizeY < minY				ifTrue:[sizeY _ minY]				ifFalse:[sizeY > maxY ifTrue:[sizeY _ maxY]].			cell cellSize: sizeX.			last ifNil:[first _ cell] ifNotNil:[last nextCell: cell].			last _ cell.			width _ width + sizeX.			sizeY > height ifTrue:[height _ sizeY].	].	properties reverseTableCells		ifTrue:[aMorph layoutTargets reverseDo: block]		ifFalse:[aMorph layoutTargets do: block].	n > 1 ifTrue:[width _ width + (n-1 * inset)].	(aMorph hResizing == #shrinkWrap and:[properties rubberBandCells or:[sum isZero]])		ifTrue:[extent _ width @ (extent y max: height)].	(aMorph vResizing == #shrinkWrap and:[properties rubberBandCells or:[vFill not]])		ifTrue:[extent _ (extent x max: width) @ height].	posX _ newBounds left.	posY _ newBounds top.	"Compute extra vertical space"	extra _ extent y - height.	extra < 0 ifTrue:[extra _ 0].	extra > 0 ifTrue:[		vFill ifTrue:[			height _ extent y.		] ifFalse:[			centering _ properties wrapCentering.			centering == #bottomRight ifTrue:[posY _ posY + extra].			centering == #center ifTrue:[posY _ posY + (extra // 2)]		].	].	"Compute extra horizontal space"	extra _ extent x - width.	extra < 0 ifTrue:[extra _ 0].	extraPerCell _ 0.	extra > 0 ifTrue:[		sum isZero ifTrue:["extra space but no #spaceFillers"			centering _ properties listCentering.			centering == #bottomRight ifTrue:[posX _ posX + extra].			centering == #center ifTrue:[posX _ posX + (extra // 2)].		] ifFalse:[extraPerCell _ extra asFloat / sum asFloat].	].	n _ 0.	extra _ last _ 0.	cell _ first.	[cell == nil] whileFalse:[		n _ n + 1.		width _ cell cellSize.		(extraPerCell > 0 and:[cell hSpaceFill]) ifTrue:[			extra _ (last _ extra) + (extraPerCell * cell extraSpace).			amount _ extra truncated - last truncated.			width _ width + amount.		].		cell target layoutInBounds: (posX @ posY extent: width @ height).		posX _ posX + width + inset.		cell _ cell nextCell.	].! !!CTableLayout methodsFor: 'optimized' stamp: 'ar 3/24/2004 03:30'!layoutTopToBottom: aMorph in: newBounds	"An optimized top-to-bottom list layout"	| inset n size extent width height block sum vFill posX posY extra centering extraPerCell last amount minX minY maxX maxY sizeX sizeY first cell |	size _ properties minCellSize asPoint. minX _ size x. minY _ size y.	size _ properties maxCellSize asPoint. maxX _ size x. maxY _ size y.	inset _ properties cellInset asPoint y.	extent _ newBounds extent.	n _ 0. vFill _ false. sum _ 0.	width _ height _ 0.	first _ last _ nil.	block _ [:m|			n _ n + 1.			cell _ CLayoutCell new target: m.			(m vResizing == #spaceFill) ifTrue:[				cell vSpaceFill: true.				extra _ 1.				cell extraSpace: extra.				sum _ sum + extra.			] ifFalse:[cell vSpaceFill: false].			(m hResizing == #spaceFill) ifTrue:[vFill _ true].			size _ m minExtent. sizeX _ size x. sizeY _ size y.			sizeX < minX				ifTrue:[sizeX _ minX]				ifFalse:[sizeX > maxX ifTrue:[sizeX _ maxX]].			sizeY < minY				ifTrue:[sizeY _ minY]				ifFalse:[sizeY > maxY ifTrue:[sizeY _ maxY]].			cell cellSize: sizeY.			first ifNil:[first _ cell] ifNotNil:[last nextCell: cell].			last _ cell.			height _ height + sizeY.			sizeX > width ifTrue:[width _ sizeX].	].	properties reverseTableCells		ifTrue:[aMorph layoutTargets reverseDo: block]		ifFalse:[aMorph layoutTargets do: block].	n > 1 ifTrue:[height _ height + (n-1 * inset)].	(aMorph vResizing == #shrinkWrap and:[properties rubberBandCells or:[sum isZero]])		ifTrue:[extent _ (extent x max: width) @ height].	(aMorph hResizing == #shrinkWrap and:[properties rubberBandCells or:[vFill not]])		ifTrue:[extent _ width @ (extent y max: height)].	posX _ newBounds left.	posY _ newBounds top.	"Compute extra horizontal space"	extra _ extent x - width.	extra < 0 ifTrue:[extra _ 0].	extra > 0 ifTrue:[		vFill ifTrue:[			width _ extent x.		] ifFalse:[			centering _ properties wrapCentering.			centering == #bottomRight ifTrue:[posX _ posX + extra].			centering == #center ifTrue:[posX _ posX + (extra // 2)]		].	].	"Compute extra vertical space"	extra _ extent y - height.	extra < 0 ifTrue:[extra _ 0].	extraPerCell _ 0.	extra > 0 ifTrue:[		sum isZero ifTrue:["extra space but no #spaceFillers"			centering _ properties listCentering.			centering == #bottomRight ifTrue:[posY _ posY + extra].			centering == #center ifTrue:[posY _ posY + (extra // 2)].		] ifFalse:[extraPerCell _ extra asFloat / sum asFloat].	].	n _ 0.	extra _ last _ 0.	cell _ first.	[cell == nil] whileFalse:[		n _ n + 1.		height _ cell cellSize.		(extraPerCell > 0 and:[cell vSpaceFill]) ifTrue:[			extra _ (last _ extra) + (extraPerCell * cell extraSpace).			amount _ extra truncated - last truncated.			height _ height + amount.		].		cell target layoutInBounds: (posX @ posY extent: width @ height).		posY _ posY + height + inset.		cell _ cell nextCell.	].! !!CTableLayout methodsFor: 'optimized' stamp: 'ar 3/24/2004 02:31'!minExtentHorizontal: aMorph	"Return the minimal size aMorph's children would require given the new bounds"	| inset n size width height minX minY maxX maxY sizeX sizeY |	size _ properties minCellSize asPoint. minX _ size x. minY _ size y.	size _ properties maxCellSize asPoint. maxX _ size x. maxY _ size y.	inset _ properties cellInset asPoint.	n _ 0.	width _ height _ 0.	aMorph layoutTargets do:[:m|			n _ n + 1.			size _ m minExtent. sizeX _ size x. sizeY _ size y.			sizeX < minX				ifTrue:[sizeX _ minX]				ifFalse:[sizeX > maxX ifTrue:[sizeX _ maxX]].			sizeY < minY				ifTrue:[sizeY _ minY]				ifFalse:[sizeY > maxY ifTrue:[sizeY _ maxY]].			width _ width + sizeX.			sizeY > height ifTrue:[height _ sizeY].	].	n > 1 ifTrue:[width _ width + (n-1 * inset x)].	^minExtentCache _ width @ height! !!CTableLayout methodsFor: 'optimized' stamp: 'ar 3/24/2004 02:31'!minExtentVertical: aMorph	"Return the minimal size aMorph's children would require given the new bounds"	| inset n size width height minX minY maxX maxY sizeX sizeY |	size _ properties minCellSize asPoint. minX _ size x. minY _ size y.	size _ properties maxCellSize asPoint. maxX _ size x. maxY _ size y.	inset _ properties cellInset asPoint.	n _ 0.	width _ height _ 0.	aMorph layoutTargets do:[:m|			n _ n + 1.			size _ m minExtent. sizeX _ size x. sizeY _ size y.			sizeX < minX				ifTrue:[sizeX _ minX]				ifFalse:[sizeX > maxX ifTrue:[sizeX _ maxX]].			sizeY < minY				ifTrue:[sizeY _ minY]				ifFalse:[sizeY > maxY ifTrue:[sizeY _ maxY]].			height _ height + sizeY.			sizeX > width ifTrue:[width _ sizeX].	].	n > 1 ifTrue:[height _ height + (n-1 * inset y)].	^minExtentCache _ width @ height! !!CTableLayout methodsFor: 'testing'!isTableLayout	^true! !!CTableLayout methodsFor: 'private' stamp: 'ar 3/24/2004 02:23'!updateWrapDirection	| wrapDir |	wrapDir := self updateWrapDirection: self listDirection.	wrapDir ifNotNil:[self wrapDirection: wrapDir].! !!CTableLayout methodsFor: 'private' stamp: 'ar 3/24/2004 02:23'!updateWrapDirection: listDir	"Answer the new wrap direction to use for the receiver if it would assume the given list direction"	| wrapDir |	wrapDir _ self wrapDirection.	(wrapDir == #none) ifTrue:[^nil].	"otherwise automatically keep a valid table layout"	(listDir == #leftToRight or:[listDir == #rightToLeft]) ifTrue:[		wrapDir == #leftToRight ifTrue:[^#topToBottom].		wrapDir == #rightToLeft ifTrue:[^#bottomToTop].	] ifFalse:[		wrapDir == #topToBottom ifTrue:[^#leftToRight].		wrapDir == #bottomToTop ifTrue:[^#rightToLeft].	].	^nil! !!CTableLayoutProperties methodsFor: 'initialize' stamp: 'ar 3/24/2004 03:41'!initialize	cellSpacing _ listSpacing _ wrapDirection _ #none.	cellPositioning _ #center.	listCentering _ wrapCentering _ #topLeft.	listDirection _ #topToBottom.	reverseTableCells _ rubberBandCells _ false.	cellInset _ minCellSize _ 0.	maxCellSize _ 1073741823. "SmallInteger maxVal"! !!CTableLayoutProperties methodsFor: 'accessing'!cellInset	^cellInset! !!CTableLayoutProperties methodsFor: 'accessing'!cellInset: aNumber	cellInset _ aNumber! !!CTableLayoutProperties methodsFor: 'accessing'!cellPositioning	^cellPositioning! !!CTableLayoutProperties methodsFor: 'accessing'!cellPositioning: aSymbol	cellPositioning _ aSymbol! !!CTableLayoutProperties methodsFor: 'accessing'!cellSpacing	^cellSpacing! !!CTableLayoutProperties methodsFor: 'accessing'!cellSpacing: aSymbol	cellSpacing _ aSymbol.! !!CTableLayoutProperties methodsFor: 'accessing'!listCentering	^listCentering! !!CTableLayoutProperties methodsFor: 'accessing'!listCentering: aSymbol	listCentering _ aSymbol! !!CTableLayoutProperties methodsFor: 'accessing'!listDirection	^listDirection! !!CTableLayoutProperties methodsFor: 'accessing'!listDirection: aSymbol	listDirection _ aSymbol.! !!CTableLayoutProperties methodsFor: 'accessing'!listSpacing	^listSpacing! !!CTableLayoutProperties methodsFor: 'accessing'!listSpacing: aSymbol	listSpacing _ aSymbol! !!CTableLayoutProperties methodsFor: 'accessing'!maxCellSize	^maxCellSize! !!CTableLayoutProperties methodsFor: 'accessing'!maxCellSize: aNumber	maxCellSize _ aNumber.! !!CTableLayoutProperties methodsFor: 'accessing'!minCellSize	^minCellSize! !!CTableLayoutProperties methodsFor: 'accessing'!minCellSize: aNumber	minCellSize _ aNumber.! !!CTableLayoutProperties methodsFor: 'accessing'!reverseTableCells	^reverseTableCells! !!CTableLayoutProperties methodsFor: 'accessing'!reverseTableCells: aBool	reverseTableCells _ aBool! !!CTableLayoutProperties methodsFor: 'accessing'!rubberBandCells	^rubberBandCells! !!CTableLayoutProperties methodsFor: 'accessing'!rubberBandCells: aBool	rubberBandCells _ aBool.! !!CTableLayoutProperties methodsFor: 'accessing'!wrapCentering	^wrapCentering! !!CTableLayoutProperties methodsFor: 'accessing'!wrapCentering: aSymbol	wrapCentering _ aSymbol! !!CTableLayoutProperties methodsFor: 'accessing'!wrapDirection	^wrapDirection! !!CTableLayoutProperties methodsFor: 'accessing'!wrapDirection: aSymbol	wrapDirection _ aSymbol! !!CTableLayoutProperties methodsFor: 'testing'!includesTableProperties	^true! !!CTextComposer methodsFor: 'as yet unclassified' stamp: 'ar 1/9/2003 16:25'!addNullLineForIndex: index"This awful bit is to ensure that if we have scanned all the text and the last character is a CR that there is a null line at the end of lines. Sometimes this was not happening which caused anomalous selections when selecting all the text. This is implemented as a post-composition fixup because I couldn't figure out where to put it in the main logic."	| oldLastLine r |	oldLastLine _ lines last.	oldLastLine last - oldLastLine first >= 0 ifFalse: [^self].	oldLastLine last = (index - 1) ifFalse: [^self].	r _ oldLastLine left @ oldLastLine bottom 				extent: 0@(oldLastLine bottom - oldLastLine top).	"Even though we may be below the bottom of the container,	it is still necessary to compose the last line for consistency..."	self addNullLineWithIndex: index andRectangle: r.! !!CTextComposer methodsFor: 'as yet unclassified' stamp: 'ar 1/9/2003 16:25'!addNullLineWithIndex: index andRectangle: r	lines addLast: (		(			TextLine 				start: index 				stop: index - 1				internalSpaces: 0 				paddingWidth: 0		)			rectangle: r;			lineHeight: defaultLineHeight baseline: theTextStyle baseline	)! !!CTextComposer methodsFor: 'as yet unclassified' stamp: 'ar 1/9/2003 16:25'!checkIfReadyToSlide	"Check whether we are now in sync with previously composed lines"	(possibleSlide and: [currCharIndex > stopCharIndex]) ifFalse: [^self].	[prevIndex < prevLines size		and: [(prevLines at: prevIndex) first < (currCharIndex - deltaCharIndex)]]			whileTrue: [prevIndex _ prevIndex + 1].	(prevLines at: prevIndex) first = (currCharIndex - deltaCharIndex) ifTrue: [		"Yes -- next line will have same start as prior line."		prevIndex _ prevIndex - 1.		possibleSlide _ false.		nowSliding _ true	] ifFalse: [		prevIndex = prevLines size ifTrue: [			"Weve reached the end of prevLines, so no use to keep looking for lines to slide."			possibleSlide _ false		]	]! !!CTextComposer methodsFor: 'as yet unclassified' stamp: 'ar 1/9/2003 16:25'!composeAllLines	[currCharIndex <= theText size and: 			[(currentY + defaultLineHeight) <= theContainer bottom]] whileTrue: [		nowSliding ifTrue: [			self slideOneLineDown ifNil: [^nil].		] ifFalse: [			self composeOneLine ifNil: [^nil].		]	].! !!CTextComposer methodsFor: 'as yet unclassified' stamp: 'ar 1/9/2003 16:25'!composeAllRectangles: rectangles	| charIndexBeforeLine numberOfLinesBefore reasonForStopping |	actualHeight _ defaultLineHeight.	charIndexBeforeLine _ currCharIndex.	numberOfLinesBefore _ lines size.	reasonForStopping _ self composeEachRectangleIn: rectangles.	currentY _ currentY + actualHeight.	currentY > theContainer bottom ifTrue: [		"Oops -- the line is really too high to fit -- back out"		currCharIndex _ charIndexBeforeLine.		lines size - numberOfLinesBefore timesRepeat: [lines removeLast].		^self	].		"It's OK -- the line still fits."	maxRightX _ maxRightX max: scanner rightX.	1 to: rectangles size - 1 do: [ :i |		"Adjust heights across rectangles if necessary"		(lines at: lines size - rectangles size + i)			lineHeight: lines last lineHeight			baseline: lines last baseline	].	isFirstLine _ false.	reasonForStopping == #columnBreak ifTrue: [^nil].	currCharIndex > theText size ifTrue: [		^nil		"we are finished composing"	].	! !!CTextComposer methodsFor: 'as yet unclassified' stamp: 'ar 1/9/2003 16:27'!composeEachRectangleIn: rectangles	| myLine lastChar |	1 to: rectangles size do: [:i | 		currCharIndex <= theText size ifFalse: [^false].		myLine _ scanner 			composeFrom: currCharIndex 			inRectangle: (rectangles at: i)							firstLine: isFirstLine 			leftSide: i=1 			rightSide: i=rectangles size.		lines addLast: myLine.		actualHeight _ actualHeight max: myLine lineHeight.  "includes font changes"		currCharIndex _ myLine last + 1.		lastChar _ theText at: myLine last.		lastChar = Character cr ifTrue: [^#cr].		wantsColumnBreaks ifTrue: [			lastChar = CTextComposer characterForColumnBreak ifTrue: [^#columnBreak].		].	].	^false! !!CTextComposer methodsFor: 'as yet unclassified' stamp: 'ar 1/9/2003 16:25'!composeLinesFrom: argStart to: argStop delta: argDelta into: argLinesCollection priorLines: argPriorLines atY: argStartY textStyle: argTextStyle text: argText container: argContainer wantsColumnBreaks: argWantsColumnBreaks	wantsColumnBreaks _ argWantsColumnBreaks.	lines _ argLinesCollection.	theTextStyle _ argTextStyle.	theText _ argText.	theContainer _ argContainer.	deltaCharIndex _ argDelta.	currCharIndex _ startCharIndex _ argStart.	stopCharIndex _ argStop.	prevLines _ argPriorLines.	currentY _ argStartY.	defaultLineHeight _ theTextStyle lineGrid.	maxRightX _ theContainer left.	possibleSlide _ stopCharIndex < theText size and: [theContainer isMemberOf: Rectangle].	nowSliding _ false.	prevIndex _ 1.	scanner _ CompositionScanner new text: theText textStyle: theTextStyle.	scanner wantsColumnBreaks: wantsColumnBreaks.	isFirstLine _ true.	self composeAllLines.	isFirstLine ifTrue: ["No space in container or empty text"		self 			addNullLineWithIndex: startCharIndex			andRectangle: (theContainer topLeft extent: 0@defaultLineHeight)	] ifFalse: [		self fixupLastLineIfCR	].	^{lines asArray. maxRightX}! !!CTextComposer methodsFor: 'as yet unclassified' stamp: 'ar 1/9/2003 16:25'!composeOneLine	| rectangles |	rectangles _ theContainer rectanglesAt: currentY height: defaultLineHeight.	rectangles size >= 1 ifTrue: [		(self composeAllRectangles: rectangles) ifNil: [^nil].	] ifFalse: [		currentY _ currentY + defaultLineHeight	].	self checkIfReadyToSlide.! !!CTextComposer methodsFor: 'as yet unclassified' stamp: 'ar 1/9/2003 16:25'!fixupLastLineIfCR"This awful bit is to ensure that if we have scanned all the text and the last character is a CR that there is a null line at the end of lines. Sometimes this was not happening which caused anomalous selections when selecting all the text. This is implemented as a post-composition fixup because I couldn't figure out where to put it in the main logic."	(theText size > 1 and: [theText last = Character cr]) ifFalse: [^self].	self addNullLineForIndex: theText size + 1.! !!CTextComposer methodsFor: 'as yet unclassified' stamp: 'ar 1/9/2003 16:27'!slideOneLineDown	| priorLine |	"Having detected the end of rippling recoposition, we are only sliding old lines"	prevIndex < prevLines size ifFalse: [		"There are no more prevLines to slide."		^nowSliding _ possibleSlide _ false	].	"Adjust and re-use previously composed line"	prevIndex _ prevIndex + 1.	priorLine _ (prevLines at: prevIndex)				slideIndexBy: deltaCharIndex andMoveTopTo: currentY.	lines addLast: priorLine.	maxRightX := maxRightX max: (priorLine right - priorLine left - priorLine paddingWidth).	currentY _ priorLine bottom.	currCharIndex _ priorLine last + 1.	wantsColumnBreaks ifTrue: [		priorLine first to: priorLine last do: [ :i |			(theText at: i) = CTextComposer characterForColumnBreak ifTrue: [				nowSliding _ possibleSlide _ false.				^nil			].		].	].! !!CTextConverter methodsFor: 'converting' stamp: 'ar 3/19/2004 17:24'!printValue: aValue	"Answer the text representation of aValue"	^aValue displayText! !!CTextConverter methodsFor: 'converting' stamp: 'ar 3/19/2004 17:25'!readValue: aText	"Answer the object representation of aText"	^aText! !!CDateConverter methodsFor: 'accessing' stamp: 'ar 3/19/2004 17:45'!format	"Answer the format of the receiver"	<bewareOf: #formatChanged>	^self propertyValueAt: #format! !!CDateConverter methodsFor: 'accessing' stamp: 'ar 3/19/2004 17:45'!format: aValue	"Modify the receiver's format"	^self propertyValueAt: #format put: aValue with: #formatChanged! !!CDateConverter methodsFor: 'converting' stamp: 'ar 3/19/2004 17:46'!printValue: aValue	"Answer the text representation of aValue"	format ifNil:[^aValue displayText].	^aValue printFormat: format! !!CDateConverter methodsFor: 'converting' stamp: 'ar 3/19/2004 17:47'!readValue: aText	"Answer the object representation of aText"	"Hm... where the hell is #readFrom:format: when you need it???"	^Date readFrom: aText asString! !!CNumberConverter methodsFor: 'converting' stamp: 'ar 3/19/2004 17:44'!readValue: aText	"Answer the object representation of aText"	^Number readFrom: aText asString! !!CStringConverter methodsFor: 'converting' stamp: 'ar 3/19/2004 17:43'!printValue: aValue	"Answer the text representation of aValue"	^aValue displayText asString! !!CStringConverter methodsFor: 'converting' stamp: 'ar 3/19/2004 17:43'!readValue: aText	"Answer the object representation of aText"	^aText asString! !!CTextEditorPane methodsFor: 'accessing' stamp: 'ar 6/2/2004 14:57'!editor	"Answer the editor of the receiver"	<bewareOf: #editorChanged>	^self propertyValueAt: #editor! !!CTextEditorPane methodsFor: 'accessing' stamp: 'ar 6/2/2004 14:57'!editor: aValue	"Modify the receiver's editor"	^self propertyValueAt: #editor put: aValue with: #editorChanged! !!CTextEditorPane methodsFor: 'accessing' stamp: 'ar 6/2/2004 13:09'!oldBorder	"Answer the oldBorder of the receiver"	<bewareOf: #oldBorderChanged>	^self propertyValueAt: #oldBorder! !!CTextEditorPane methodsFor: 'accessing' stamp: 'ar 6/2/2004 13:09'!oldBorder: aValue	"Modify the receiver's oldBorder"	^self propertyValueAt: #oldBorder put: aValue with: #oldBorderChanged! !!CTextEditorPane methodsFor: 'events' stamp: 'ar 6/2/2004 14:58'!onKeyboardFocusEnter	"only accept input while having the keyboard focus"	<on: keyboardFocusEnter in: editor>	oldBorder := border copy.	oldBorder width > 0 ifTrue:[		borderStyle := #inset.		borderWidth := 1 max: oldBorder width.		borderColor isTransparent 			ifTrue:[borderColor := Color gray: 0.5].	].! !!CTextEditorPane methodsFor: 'events' stamp: 'ar 6/2/2004 14:58'!onKeyboardFocusLeave	"only accept input while having the keyboard focus"	<on: keyboardFocusLeave in: editor>	border := oldBorder.! !!CTextEditorPane methodsFor: 'initialize' stamp: 'ar 5/19/2004 15:16'!setupCostume	super setupCostume.	self text: ''.	self mouseCursor: Cursor text.	self borderWidth: 1.	self borderColor: CWidgetLibrary default frameColor.	self borderStyle: #simple.	self textAnchorPoint: #topLeft.	self textWrap: true.! !!CTextParagraph methodsFor: 'display'!caretWidth	^ 2! !!CTextParagraph methodsFor: 'display' stamp: 'ar 3/16/2003 20:57'!displayOn: aCanvas using: displayScanner at: offset	"Send all visible lines to the displayScanner for display"	| visibleRectangle leftInRun line startBlock stopBlock showCaret mark point |	showCaret := false.	editor ifNotNil:[showCaret := editor showCaret].	showCaret ifTrue:[		mark := editor markBlock.		point := editor pointBlock.		mark stringIndex < point stringIndex 			ifTrue:[startBlock := mark. 	stopBlock := point]			ifFalse:[startBlock := point.	stopBlock := mark].	].	visibleRectangle _ aCanvas clipRect.	leftInRun _ 0.	(self lineIndexForPoint: visibleRectangle topLeft)		to: (self lineIndexForPoint: visibleRectangle bottomRight)		do: [:i | line _ lines at: i.			showCaret ifTrue:[self displaySelectionInLine: line from: startBlock to: stopBlock on: aCanvas].			line first <= line last ifTrue:				[leftInRun _ displayScanner displayLine: line								offset: offset leftInRun: leftInRun]].! !!CTextParagraph methodsFor: 'display'!displaySelectionInLine: line from: startBlock to: stopBlock on: aCanvas	| leftX rightX w caretColor |	startBlock = stopBlock		ifTrue: ["Only show caret on line where clicked"					(startBlock textLine = line) ifFalse: [^ self]]		ifFalse: ["Test entire selection before or after here"				(stopBlock stringIndex < line first					or: [startBlock stringIndex > (line last+1)])					ifTrue: [^ self].  "No selection on this line"				(stopBlock stringIndex = line first					and: [stopBlock textLine ~= line])					ifTrue: [^ self].  "Selection ends on line above"				(startBlock stringIndex = (line last+1)					and: [stopBlock textLine ~= line])					ifTrue: [^ self]].  "Selection begins on line below"	startBlock stringIndex < line first		ifTrue: [leftX _ line left]		ifFalse: [leftX _ startBlock left].	(stopBlock stringIndex > (line last+1)			or: [stopBlock stringIndex = (line last+1)					and: [stopBlock textLine ~= line]])		ifTrue: [rightX _ line right]		ifFalse: [rightX _ stopBlock left].	startBlock = stopBlock		ifTrue:		[rightX _ rightX + 1.		w _ self caretWidth.		caretColor _ self insertionPointColor.		1 to: w do:			[:i |  "Draw caret triangles at top and bottom"			aCanvas fillRectangle: ((leftX-w+i-1)@(line top+i-1) extent: (w-i*2+3)@1)				color: caretColor.			aCanvas fillRectangle: ((leftX-w+i-1)@(line bottom-i) extent: (w-i*2+3)@1)				color: caretColor].		aCanvas fillRectangle: (leftX@line top corner: rightX@line bottom)				color: caretColor]	ifFalse:		[aCanvas fillRectangle: (leftX@line top corner: rightX@line bottom)				color: self selectionColor]! !!CTextParagraph methodsFor: 'display'!insertionPointColor	^ Display depth <= 2		ifTrue: [Color black]		ifFalse: [Color r: 0.4 g: 1.0 b: 0.0"(Color r: 1 g: 0.8 b: 0.45)"]! !!CTextParagraph methodsFor: 'display' stamp: 'ar 4/4/2004 21:09'!selectionColor	| color |	Display depth = 1 ifTrue: [^ Color veryLightGray].	Display depth = 2 ifTrue: [^ Color gray].	"true ifTrue:[^(Color r: 1 g: 0.8 b: 0.45)]."	color := Color r: 0.4 g: 1.0 b: 0.0.	editor ifNil:[^color].	editor hasKeyboardFocus 		ifTrue:[^color]		ifFalse:[^color twiceLighter]! !!CTextParagraph methodsFor: 'private'!fastFindFirstLineSuchThat: lineBlock	"Perform a binary search of the lines array and return the index	of the first element for which lineBlock evaluates as true.	This assumes the condition is one that goes from false to true for	increasing line numbers (as, eg, yval > somey or start char > somex).	If lineBlock is not true for any element, return size+1."	| index low high |	low _ 1.	high _ lines size.	[index _ high + low // 2.	low > high]		whileFalse: 			[(lineBlock value: (lines at: index))				ifTrue: [high _ index - 1]				ifFalse: [low _ index + 1]].	^ low! !!CTextParagraph methodsFor: 'private'!lineIndexForCharacter: index	"Answer the index of the line in which to select the character at index."	^ (self fastFindFirstLineSuchThat: [:line | line first > index]) - 1 max: 1! !!CTextParagraph methodsFor: 'private'!lineIndexForPoint: aPoint	"Answer the index of the line in which to select the character nearest to aPoint."	| i py |	py _ aPoint y truncated.	"Find the first line at this y-value"	i _ (self fastFindFirstLineSuchThat: [:line | line bottom > py]) min: lines size.	"Now find the first line at this x-value"	[i < lines size and: [(lines at: i+1) top = (lines at: i) top				and: [aPoint x >= (lines at: i+1) left]]]		whileTrue: [i _ i + 1].	^ i! !!CTextParagraph methodsFor: 'private'!lineIndexOfCharacterIndex: characterIndex					 	"Answer the line index for a given characterIndex."	"apparently the selector changed with NewParagraph"	^self lineIndexForCharacter: characterIndex! !!CTextParagraph methodsFor: 'private'!lines	^ lines! !!CTextParagraph methodsFor: 'accessing' stamp: 'ar 7/8/2003 15:46'!adjustRightXBy: value	| w |	lines do:[:tl|		"I think the following are only for stupid empty text lines that don't span the container rectangle ... check this!!!!!!"		tl right > value ifTrue:[tl setRight: tl right - value].		w := tl paddingWidth.		w >= 0 ifTrue:[tl paddingWidth: ((w - value) max: 0)].	].! !!CTextParagraph methodsFor: 'accessing' stamp: 'ar 5/5/2004 23:40'!attributesAt: aPoint	"Answer the attributes at the given point"	^text attributesAt: (self characterBlockAtPoint: aPoint) stringIndex forStyle: textStyle! !!CTextParagraph methodsFor: 'accessing'!bounds	^container! !!CTextParagraph methodsFor: 'accessing'!characterBlockAtIndex: index	"Answer a CharacterBlock for character in the text at targetIndex. The 	coordinates in the CharacterBlock will be appropriate to the intersection 	of the destinationForm rectangle and the compositionRectangle."	^self characterBlockForIndex: index! !!CTextParagraph methodsFor: 'accessing' stamp: 'ar 7/25/2003 11:58'!editor	^editor! !!CTextParagraph methodsFor: 'accessing'!editor: aTextEditor	editor _ aTextEditor! !!CTextParagraph methodsFor: 'accessing'!extent	^maxRightX @ (lines last bottom - lines first top)! !!CTextParagraph methodsFor: 'accessing'!height	^(lines last bottom - lines first top)! !!CTextParagraph methodsFor: 'accessing'!indexOfCharacterAbove: index	| block |	block _ self characterBlockAtIndex: index.	^(self characterBlockAtPoint: block topLeft - (0@1)) stringIndex! !!CTextParagraph methodsFor: 'accessing'!indexOfCharacterBelow: index	| block |	block _ self characterBlockAtIndex: index.	^(self characterBlockAtPoint: block bottomLeft + (0@1)) stringIndex! !!CTextParagraph methodsFor: 'accessing'!indexOfNextWord: index	^text string indexOfNextWord: index! !!CTextParagraph methodsFor: 'accessing'!indexOfPreviousWord: index	^text string indexOfPreviousWord: index! !!CTextParagraph methodsFor: 'accessing'!lineSelectionIntervalAt: index	^text string lineSelectionIntervalAt: index! !!CTextParagraph methodsFor: 'accessing' stamp: 'ar 3/16/2003 21:11'!minimalTextExtent	^self minimalTextWidth @ self height! !!CTextParagraph methodsFor: 'accessing'!minimalTextWidth	| min w |	text isEmpty ifTrue:[^0].	min := 0.	lines do:[:tl|		w :=  tl right - tl left - tl paddingWidth.		w > min ifTrue:[min := w].	].	^min! !!CTextParagraph methodsFor: 'accessing'!numberOfLines	^lines size! !!CTextParagraph methodsFor: 'accessing'!replaceFrom: start to: stop with: aText	"Edit the text, and then recompose the lines." 	text replaceFrom: start to: stop with: aText.	^self recomposeFrom: start to: start + aText size - 1 delta: aText size - (stop-start+1)! !!CTextParagraph methodsFor: 'accessing'!setExtent: anExtent	container := container topLeft extent: anExtent! !!CTextParagraph methodsFor: 'accessing'!size	^text size! !!CTextParagraph methodsFor: 'accessing'!string	^ text string! !!CTextParagraph methodsFor: 'accessing'!text	^ text! !!CTextParagraph methodsFor: 'accessing' stamp: 'ar 3/16/2003 21:54'!textStyle	^ textStyle ifNil:[TextStyle default]! !!CTextParagraph methodsFor: 'accessing' stamp: 'ar 12/8/2003 22:29'!textStyle: aTextStyle	"Set the style by which the receiver should display its text."	textStyle _ aTextStyle! !!CTextParagraph methodsFor: 'accessing' stamp: 'ar 1/8/2003 22:33'!width	^maxRightX! !!CTextParagraph methodsFor: 'accessing'!wordSelectionIntervalAt: index	^text string wordSelectionIntervalAt: index! !!CTextParagraph methodsFor: 'selection'!characterBlockAtPoint: aPoint					 	"Answer a CharacterBlock for the character in the text at aPoint."	| line |	line _ lines at: (self lineIndexForPoint: aPoint).	^ (CharacterBlockScanner new text: text textStyle: textStyle)		characterBlockAtPoint: aPoint index: nil		in: line! !!CTextParagraph methodsFor: 'selection'!characterBlockForIndex: index					 	"Answer a CharacterBlock for the character in text at index."	| line |	line _ lines at: (self lineIndexForCharacter: index).	^ (CharacterBlockScanner new text: text textStyle: textStyle)		characterBlockAtPoint: nil index: ((index max: line first) min: text size+1)		in: line! !!CTextParagraph methodsFor: 'selection'!containsPoint: aPoint	^ (lines at: (self lineIndexForPoint: aPoint)) rectangle		containsPoint: aPoint! !!CTextParagraph methodsFor: 'selection'!selectionRectsFrom: characterBlock1 to: characterBlock2					 	"Return an array of rectangles representing the area between the two character blocks given as arguments."	| line1 line2 rects cb1 cb2 w |	characterBlock1 <= characterBlock2		ifTrue: [cb1 _ characterBlock1.  cb2 _ characterBlock2]		ifFalse: [cb2 _ characterBlock1.  cb1 _ characterBlock2].	cb1 = cb2 ifTrue:		[w _ self caretWidth.		^ Array with: (cb1 topLeft - (w@0) corner: cb1 bottomLeft + ((w+1)@0))].	line1 _ self lineIndexForCharacter: cb1 stringIndex.	line2 _ self lineIndexForCharacter: cb2 stringIndex.	line1 = line2 ifTrue:		[^ Array with: (cb1 topLeft corner: cb2 bottomRight)].	rects _ OrderedCollection new.	rects addLast: (cb1 topLeft corner: (lines at: line1) bottomRight).	line1+1 to: line2-1 do: [ :i |		| line |		line := lines at: i.		(line left = rects last left and: [ line right = rects last right ])			ifTrue: [ "new line has same margins as old one -- merge them, so that the caller gets as few rectangles as possible"					| lastRect |					lastRect := rects removeLast.					rects add: (lastRect bottom: line bottom) ]			ifFalse: [ "differing margins; cannot merge"					rects add: line rectangle ] ].	rects addLast: ((lines at: line2) topLeft corner: cb2 bottomLeft).	^ rects! !!CTextParagraph methodsFor: 'composition'!compose: t style: ts from: startingIndex in: textContainer	text _ t.	textStyle _ ts.	container _ textContainer.	self composeAll! !!CTextParagraph methodsFor: 'composition'!composeAll	self composeLinesFrom: 1 to: text size delta: 0		into: OrderedCollection new priorLines: Array new atY: container top! !!CTextParagraph methodsFor: 'composition' stamp: 'ar 7/24/2003 20:44'!composeLinesFrom: start to: stop delta: delta into: lineColl priorLines: priorLines atY: startingY	"While the section from start to stop has changed, composition may ripple all the way to the end of the text.  However in a rectangular container, if we ever find a line beginning with the same character as before (ie corresponding to delta in the old lines), then we can just copy the old lines from there to the end of the container, with adjusted indices and y-values"	| newResult |	newResult _ CTextComposer new		composeLinesFrom: start 		to: stop 		delta: delta 		into: lineColl 		priorLines: priorLines		atY: startingY		textStyle: textStyle 		text: text 		container: container		wantsColumnBreaks: false.	lines _ newResult first asArray.	lines last last = text size ifFalse:[self error: 'Text composition error'].	maxRightX _ newResult second.	^maxRightX! !!CTextParagraph methodsFor: 'composition'!compositionRectangle	^ container! !!CTextParagraph methodsFor: 'composition' stamp: 'ar 1/9/2003 16:32'!recomposeFrom: start to: stop delta: delta	"Recompose this paragraph.  The altered portion is between start and stop.	Recomposition may continue to the end of the text, due to a ripple effect.	Delta is the amount by which the current text is longer than it was	when its current lines were composed."	| startLine newLines rightX myLine |	"Have to recompose line above in case a word-break was affected."	startLine _ (self lineIndexForCharacter: start) - 1 max: 1.	[startLine > 1 and: [(lines at: startLine-1) top = (lines at: startLine) top]]		whileTrue: [startLine _ startLine - 1].  "Find leftmost of line pieces"	newLines _ OrderedCollection new: lines size + 1.	rightX := 0.	1 to: startLine-1 do: [:i | 		myLine := lines at: i.		rightX := rightX max: (myLine right - myLine left - myLine paddingWidth).		newLines addLast: myLine].	self composeLinesFrom: (lines at: startLine) first to: stop delta: delta			into: newLines priorLines: lines			atY: (lines at: startLine) top.	maxRightX := maxRightX max: rightX.! !!CTextParagraphEditor methodsFor: 'editor commands'!addAttribute: textAttr	"Add the given attribute to the current selection"	self replaceSelectionWith: (self selection asText addAttribute: textAttr).! !!CTextParagraphEditor methodsFor: 'editor commands'!align: aSymbol	"Change the alignment of the selected region to be #leftFlush, #centered, #rightFlush, or, #justified."	| attr string left right start stop|	attr := TextAlignment perform: aSymbol.	start := markBlock stringIndex.	stop := pointBlock stringIndex.	string := paragraph text string.	left := string lastIndexOf: Character cr startingAt: (start min: stop)-1 ifAbsent:[1].	right := string indexOf: Character cr startingAt: (start max: stop) ifAbsent:[string size].	self selectFrom: left to: right.	self addAttribute: attr.	self selectFrom: start to: stop.! !!CTextParagraphEditor methodsFor: 'editor commands' stamp: 'ar 4/4/2004 21:35'!changeEmpasisHere: emph	| attr |	emphasisHere := self emphasisHere reject:[:any| any class == TextEmphasis].	emph = 0 ifFalse:[		attr := TextEmphasis new emphasisCode: emph.		emphasisHere := Text addAttribute: attr toArray: self emphasisHere.	].	self textSelectionChanged.! !!CTextParagraphEditor methodsFor: 'editor commands' stamp: 'ar 4/4/2004 21:35'!changeFontHere: attr	emphasisHere := Text addAttribute: attr toArray: self emphasisHere.	self textSelectionChanged.! !!CTextParagraphEditor methodsFor: 'editor commands'!redo	"Redo the last undone command"	| stack |	redoStack isEmptyOrNil ifTrue:[^self].	stack := redoStack.	redoStack := nil.	self undoCommand: stack removeLast.	stack isEmpty ifFalse:[redoStack := stack].! !!CTextParagraphEditor methodsFor: 'editor commands'!selectFontNamed: fontName pointSize: ptSize	"Set the current selection to the given font name in the appropriate point size"	| style font |	style := TextStyle named: fontName.	style ifNil:[^self].	font := style fonts detect:[:any| any pointSize = ptSize] ifNone:[nil].	font ifNil:[^self].	self addAttribute: (TextFontReference toFont: font).! !!CTextParagraphEditor methodsFor: 'editor commands'!undo	"Undo the last command"	| stack |	undoStack isEmptyOrNil ifTrue:[^self].	stack := undoStack.	undoStack := redoStack ifNil:[OrderedCollection new].	self undoCommand: stack removeLast.	redoStack := undoStack.	undoStack := stack.! !!CTextParagraphEditor methodsFor: 'cursor keys'!moveCursorLeft	"Select one character left"	^self moveCaretTo: self selectionStart - 1 selecting: false! !!CTextParagraphEditor methodsFor: 'cursor keys'!moveCursorRight	"Move one character to the right"	^self moveCaretTo: self selectionStop + 1 selecting: false! !!CTextParagraphEditor methodsFor: 'cursor keys'!moveLineDown	"Move cursor from position in current line to same position in	next line. If next line too short, put at end."	^self moveCaretTo: (paragraph indexOfCharacterBelow: self selectionStop) selecting: false! !!CTextParagraphEditor methodsFor: 'cursor keys'!moveLineEnd	"Move cursor end of current line. If cursor already at end of 	line, put cursor at end of text"	^self moveCaretTo: (paragraph lineSelectionIntervalAt: pointBlock stringIndex) last + 1 selecting: false! !!CTextParagraphEditor methodsFor: 'cursor keys'!moveLineStart	"Move cursor from position in current line to beginning of	current line. If cursor already at beginning of line, put cursor at	beginning of text"	^self moveCaretTo: (paragraph lineSelectionIntervalAt: pointBlock stringIndex) first selecting: false! !!CTextParagraphEditor methodsFor: 'cursor keys'!moveLineUp	"Move one line up"	^self moveCaretTo: (paragraph indexOfCharacterAbove: pointBlock stringIndex) selecting: false! !!CTextParagraphEditor methodsFor: 'cursor keys'!moveTextEnd	"Move the cursor to the end of the text"	^self moveCaretTo: paragraph size+1 selecting: false! !!CTextParagraphEditor methodsFor: 'cursor keys'!moveTextStart	"Move the cursor to the beginning of the text"	^self moveCaretTo: 1 selecting: false! !!CTextParagraphEditor methodsFor: 'cursor keys'!moveWordLeft	"Move cursor left one word left"	^self  moveCaretTo: (paragraph indexOfPreviousWord: pointBlock stringIndex-1) selecting: false.! !!CTextParagraphEditor methodsFor: 'cursor keys'!moveWordRight	"Move cursor right one word"	^self moveCaretTo: (paragraph indexOfNextWord: self selectionStop) selecting: false! !!CTextParagraphEditor methodsFor: 'cursor keys'!selectCursorLeft	"Select one character left"	^self moveCaretTo: pointBlock stringIndex - 1 selecting: true.! !!CTextParagraphEditor methodsFor: 'cursor keys'!selectCursorRight	"Select one character to the right"	^self moveCaretTo: pointBlock stringIndex + 1 selecting: true! !!CTextParagraphEditor methodsFor: 'cursor keys'!selectLineDown	"Select one line down"	^self moveCaretTo: (paragraph indexOfCharacterBelow: pointBlock stringIndex) selecting: true! !!CTextParagraphEditor methodsFor: 'cursor keys'!selectLineEnd	"Select up to the end of current line. If cursor already at end of 	line, put cursor at end of text"	^self moveCaretTo: (paragraph lineSelectionIntervalAt: pointBlock stringIndex) last + 1 selecting: true! !!CTextParagraphEditor methodsFor: 'cursor keys'!selectLineStart	"Select from position in current line to beginning of	current line. If cursor already at beginning of line, put cursor at	beginning of text"	^self moveCaretTo: (paragraph lineSelectionIntervalAt: self selectionStart) first selecting: true! !!CTextParagraphEditor methodsFor: 'cursor keys'!selectLineUp	"Select one line up"	^self moveCaretTo: (paragraph indexOfCharacterAbove: pointBlock stringIndex) selecting: true! !!CTextParagraphEditor methodsFor: 'cursor keys'!selectTextEnd	"Move the cursor to the end of the text"	^self moveCaretTo: paragraph size+1 selecting: true! !!CTextParagraphEditor methodsFor: 'cursor keys'!selectTextStart	"Select to the beginning of the text"	^self moveCaretTo: 1 selecting: true! !!CTextParagraphEditor methodsFor: 'cursor keys'!selectWordLeft	"Select left one word left"	self  moveCaretTo: (paragraph indexOfPreviousWord: pointBlock stringIndex-1) selecting: true.! !!CTextParagraphEditor methodsFor: 'cursor keys'!selectWordRight	"Select one word to the right"	^self moveCaretTo: (paragraph indexOfNextWord: pointBlock stringIndex) selecting: true! !!CTextParagraphEditor methodsFor: 'private' stamp: 'ar 4/4/2004 21:34'!adjustRightXBy: aValue	^paragraph adjustRightXBy: aValue! !!CTextParagraphEditor methodsFor: 'private' stamp: 'ar 3/13/2003 02:48'!emphasisHere	^emphasisHere ifNil:[#()]! !!CTextParagraphEditor methodsFor: 'private'!markBlock	^markBlock! !!CTextParagraphEditor methodsFor: 'private'!moveCaretTo: pos selecting: aBool	"Move the caret to the given position, extending the selection if indicated"	| newPos |	newPos := pos min: paragraph size + 1 max: 1.	aBool		ifTrue:[self selectFrom: markBlock stringIndex to: newPos]		ifFalse:[self selectFrom: newPos to: newPos].! !!CTextParagraphEditor methodsFor: 'private'!pointBlock	^pointBlock! !!CTextParagraphEditor methodsFor: 'private'!prepareUndo: aText type: editingType	| cutInterval pasteText highlightInterval lastUndo |	"determine what to cut upon undo"	cutInterval := Array with: self selectionStart with: self selectionStart + aText size.	"get the text to put back in"	pasteText := self selection.	"determine what to select after undo"	highlightInterval := Array with: markBlock stringIndex with: pointBlock stringIndex.	"If keyStroke replaces selected text don't merge it"	(editingType == #keyStroke and:[pasteText isEmpty not]) ifTrue:[lastUndoType := nil].	(lastUndoType notNil and:[lastUndoType == editingType]) ifTrue:[		"Try to merge current undo into last undo"		lastUndo := undoStack last.		editingType == #keyStroke ifTrue:[			self assert:[pasteText isEmpty]. "after first keystroke selection must be empty"			lastUndo at: 1 put: (Array with: lastUndo first first with: cutInterval last). "extend cut interval by one"			^self].		(editingType == #backspace) ifTrue:[			lastUndo at: 1 put: cutInterval. "always empty"			lastUndo at: 2 put: (pasteText, lastUndo second). "extend text to restore"			lastUndo at: 3 put: (Array 				with: lastUndo first first 				with: cutInterval min + lastUndo second size). "and highlight"			^self].		(editingType == #delete) ifTrue:[			lastUndo at: 1 put: cutInterval. "always empty"			lastUndo at: 2 put: (lastUndo second, pasteText). "extend text to restore"			lastUndo at: 3 put: (Array				with: lastUndo first first				with: cutInterval min + lastUndo second size). "and highlight"			^self].	].	"Cannot merge with last undo"	lastUndoType := editingType.	lastUndo := {cutInterval. pasteText. highlightInterval}.	undoStack addLast: lastUndo.	redoStack := nil.! !!CTextParagraphEditor methodsFor: 'private' stamp: 'ar 4/2/2004 15:00'!privateAnchor: aCostume at: aPoint type: anchorType	"Anchor the given costume at the provided location using the given type of anchoring"	| index newText block relPt |	aCostume container == costume ifTrue:[self removeAnchor: aCostume].	aCostume textAnchorType: nil.	aCostume relativeTextAnchorPosition: nil.	costume add: aCostume.	aCostume textAnchorType: anchorType.	aCostume relativeTextAnchorPosition: nil.	relPt _ aPoint - costume textBounds origin.	"@@@@: Fix this. Embedding costumes in scrolled texts probable doesn't work without including scroll offset. :@@@@"	index _ (self paragraph characterBlockAtPoint: relPt) stringIndex.	newText _ Text 		string: (Character value: 1) asString 		attribute: (TextAnchor new anchoredObject: aCostume).	anchorType == #inline ifTrue:[		^paragraph text replaceFrom: index to: index-1 with: newText].	anchorType == #paragraph ifTrue:[		index _ index min: paragraph size.		index _ paragraph text string lastIndexOf: Character cr startingAt: index ifAbsent:[0].		"If there ain't no preceeding CR fall through and use #document anchoring"		index > 0 ifTrue:[			block _ paragraph characterBlockAtIndex: index.			aCostume relativeTextAnchorPosition: relPt x @ (relPt y - block top).			^paragraph text replaceFrom: index+1 to: index with: newText].	].	"do nothing -- #document anchoring has no reference in text"! !!CTextParagraphEditor methodsFor: 'private' stamp: 'ar 4/2/2004 15:00'!replaceFrom: start to: stop with: aText	| embedded m |	"Remember embedded costumess"	embedded := paragraph text  embeddedCostumesFrom: start to: stop.	"Convert those in the selection"	aText removeAttributesThat:[:attr|		(m := attr anchoredObject) ifNil:[false] ifNotNil:[m textAnchorType == #document]	] replaceAttributesThat:[:attr|		(m := attr anchoredObject) ifNil:[false] ifNotNil:[m textAnchorType ~~ #document]	] by:[:attr| 		m := attr anchoredObject copy.		costume add: m.		TextAnchor new anchoredObject: m.	].	paragraph replaceFrom: start to: stop with: aText.	"Zap old costumes"	embedded do:[:aCostume| aCostume delete].! !!CTextParagraphEditor methodsFor: 'private' stamp: 'ar 3/13/2003 02:53'!replaceSelectionWith: aText type: editingType	undoStack ifNotNil:[self prepareUndo: aText type: editingType].	^self zapSelectionWith: aText! !!CTextParagraphEditor methodsFor: 'private'!selectionRect	"Compute selection rect"	| rect |	rect := markBlock merge: pointBlock.	markBlock textLine = pointBlock textLine		ifFalse:[rect := (rect withLeft: costume textBounds left) withWidth: costume textBounds width].	"Something is definitely weird here with the caret handling but the following does at least work"	^rect expandBy: 8@8! !!CTextParagraphEditor methodsFor: 'private' stamp: 'ar 4/4/2004 21:35'!textSelectionChanged	self signal: #textSelectionChanged.	costume textSelectionChanged.! !!CTextParagraphEditor methodsFor: 'private'!undoCommand: cmd	| cutInterval pasteText highlight |	cutInterval := cmd first.	pasteText := cmd second.	highlight := cmd third.	self selectFrom: cutInterval first to: cutInterval last.	self replaceSelectionWith: pasteText.	self selectFrom: highlight first to: highlight last.! !!CTextParagraphEditor methodsFor: 'private' stamp: 'ar 3/13/2003 03:11'!updateEmphasisHere	paragraph size = 0 ifTrue:[^self].	emphasisHere _ (paragraph text 		attributesAt: (pointBlock stringIndex-1 max: 1) 		forStyle: paragraph textStyle	) select: [:att | att mayBeExtended].! !!CTextParagraphEditor methodsFor: 'private' stamp: 'ar 3/13/2003 15:02'!zapSelectionWith: aText	| start stop |	(aText isEmpty and:[markBlock = pointBlock]) ifTrue:[^self].	start := self selectionStart.	stop := self selectionStop-1.	aText isString ifTrue:[		self replaceFrom: start to: stop with: (Text string: aText emphasis: self emphasisHere).	] ifFalse:[		self replaceFrom: start to: stop with: aText.	].	"Need to recompute entirely since paragraph changes"	markBlock := paragraph characterBlockAtIndex: start + aText size.	pointBlock := markBlock copy.	costume invalidate.	costume scrollToSelection.	self modified: true.! !!CTextParagraphEditor methodsFor: 'selecting'!replaceSelectionWith: aText	^self replaceSelectionWith: aText allowUndo: true! !!CTextParagraphEditor methodsFor: 'selecting' stamp: 'ar 3/13/2003 02:58'!replaceSelectionWith: aText allowUndo: allowUndo	(allowUndo and:[undoStack notNil]) 		ifTrue:[self prepareUndo: aText type: nil].	^self zapSelectionWith: aText! !!CTextParagraphEditor methodsFor: 'selecting' stamp: 'ar 1/8/2003 22:36'!selectAll	self selectFrom: 1 to: paragraph text size+1! !!CTextParagraphEditor methodsFor: 'selecting'!selectAt: selectionIndex	"Public. Used by clients"	^self selectFrom: selectionIndex to: selectionIndex.! !!CTextParagraphEditor methodsFor: 'selecting' stamp: 'ar 4/4/2004 21:36'!selectFrom: markIndex to: pointIndex	"Select the text from markIndex to pointIndex."	| oldRect newRect start stop |	lastUndoType := nil. "so we need to reset"	oldRect := self selectionRect.	start := markIndex min: self text size + 1 max: 1.	stop := pointIndex min: self text size + 1 max: 1.	"Optimize search for character blocks by reusing the old mark block and testing for start=stop"	(start = markBlock stringIndex and:[stop = pointBlock stringIndex])		ifTrue:[^self].	start = markBlock stringIndex 		ifFalse:[markBlock := paragraph characterBlockAtIndex: start].	start = stop		ifTrue:[pointBlock := markBlock copy]		ifFalse:[pointBlock := paragraph characterBlockAtIndex: stop].	"Invalidate the regions that have changed"	newRect := self selectionRect.	costume invalidate: (oldRect merge: newRect).	costume scrollToSelection.	self updateEmphasisHere.	self textSelectionChanged.! !!CTextParagraphEditor methodsFor: 'selecting'!selectLine	| interval |	interval _ paragraph lineSelectionIntervalAt: self selectionStart.	self selectFrom: interval first to: interval last + 1.! !!CTextParagraphEditor methodsFor: 'selecting'!selectLineIfEmpty	"If current selection is empty, select entire line"	markBlock stringIndex = pointBlock stringIndex ifTrue:[self selectLine].! !!CTextParagraphEditor methodsFor: 'selecting'!selectWordAt: characterIndex	"Select the word at the given character index"	| interval |	interval _ paragraph wordSelectionIntervalAt: characterIndex.	self selectFrom: interval first to: interval last+1.! !!CTextParagraphEditor methodsFor: 'selecting' stamp: 'ar 3/13/2003 03:06'!selection	markBlock = pointBlock ifTrue:[^Text new].	^paragraph text copyFrom: self selectionStart to: self selectionStop-1! !!CTextParagraphEditor methodsFor: 'selecting'!selectionStart	^markBlock stringIndex min: pointBlock stringIndex! !!CTextParagraphEditor methodsFor: 'selecting'!selectionStop	^pointBlock stringIndex max: markBlock stringIndex! !!CTextParagraphEditor methodsFor: 'initialize'!closeUndoStack	undoStack := OrderedCollection new.! !!CTextParagraphEditor methodsFor: 'initialize' stamp: 'bf 3/30/2004 10:47'!extent: anExtent	paragraph		compose: paragraph text		style: paragraph textStyle		from: 1		in: (0@0 extent: anExtent).	^anExtent! !!CTextParagraphEditor methodsFor: 'initialize' stamp: 'ar 3/18/2003 12:14'!paragraph: aTextParagraph	paragraph := aTextParagraph.	modified := false.	undoStack := OrderedCollection new.	redoStack := nil.	markBlock := paragraph characterBlockAtIndex: 1.	pointBlock := markBlock copy.	self updateEmphasisHere.	"Needed for now"	paragraph editor: self.! !!CTextParagraphEditor methodsFor: 'accessing' stamp: 'ar 5/5/2004 23:41'!attributesAt: aPoint	"Answer the attributes at the given point"	^paragraph attributesAt: (aPoint - costume editorOffset)! !!CTextParagraphEditor methodsFor: 'accessing'!costume	^costume! !!CTextParagraphEditor methodsFor: 'accessing'!costume: aCostume	costume := aCostume! !!CTextParagraphEditor methodsFor: 'accessing' stamp: 'ar 3/13/2003 04:26'!emphasis	| code |	code := 0.	self emphasisHere do:[:attr|		code := code bitOr: attr emphasisCode.	].	^code! !!CTextParagraphEditor methodsFor: 'accessing'!extent	^paragraph extent! !!CTextParagraphEditor methodsFor: 'accessing' stamp: 'ar 3/13/2003 03:54'!font	self emphasisHere do:[:attr|		attr class == TextFontReference ifTrue:[^attr font].	].	^TextStyle defaultFont! !!CTextParagraphEditor methodsFor: 'accessing' stamp: 'ar 3/16/2003 21:23'!hasKeyboardFocus	"Return true if the receiver has the input focus"	^costume hasKeyboardFocus! !!CTextParagraphEditor methodsFor: 'accessing'!minimalTextExtent	"Return the minimal width of the text (excluding alignment!!)"	^paragraph minimalTextWidth @ paragraph height! !!CTextParagraphEditor methodsFor: 'accessing'!minimalTextWidth	"Return the minimal width of the text (excluding alignment!!)"	^paragraph minimalTextWidth! !!CTextParagraphEditor methodsFor: 'accessing'!modified	"Answer whether the receiver is modified"	^modified! !!CTextParagraphEditor methodsFor: 'accessing' stamp: 'ar 3/13/2003 15:02'!modified: aBool	"Indicate whether the receiver is modified"	costume modified: aBool.	modified := aBool.! !!CTextParagraphEditor methodsFor: 'accessing'!paragraph	^paragraph! !!CTextParagraphEditor methodsFor: 'accessing'!showCaret	"Return true if the receiver should display the caret while drawing"	markBlock ifNil:[^false].	pointBlock ifNil:[^false].	^costume wantsCaretShowingIn: self! !!CTextParagraphEditor methodsFor: 'accessing' stamp: 'ar 3/12/2004 15:55'!showCaret: aBool	^costume showCaret: aBool! !!CTextParagraphEditor methodsFor: 'accessing'!text	^paragraph text! !!CTextParagraphEditor methodsFor: 'accessing' stamp: 'bf 3/30/2004 11:33'!text: newText	"need to go through the costume here..."	^costume text: newText.! !!CTextParagraphEditor methodsFor: 'accessing'!textLines	^paragraph lines! !!CTextParagraphEditor methodsFor: 'accessing'!visibleLines	^self visibleLinesIn: (costume textBounds)! !!CTextParagraphEditor methodsFor: 'accessing'!visibleLinesIn: box	^paragraph lines select:[:line| 		(line top between: box top and: box bottom) 			and:[line bottom between: box top and: box bottom]].! !!CTextParagraphEditor methodsFor: 'anchoring'!adjustTextAnchor: aCostume	"The given costume has been moved by delta; adjust its reference if necessary. The following could be optimized but using #anchor: has some advantages since it'll restore any anchor that got lost due to deleting the referencing character."	self anchor: aCostume at: aCostume position type: aCostume textAnchorType! !!CTextParagraphEditor methodsFor: 'anchoring'!anchor: aCostume	^self anchor: aCostume at: aCostume position! !!CTextParagraphEditor methodsFor: 'anchoring' stamp: 'ar 3/26/2004 22:14'!anchor: aCostume at: aPoint	"Used to anchor a costume without knowing how exactly it should happen. We make an educated guess here based on the size and the relative position of the costume."	"TODO: Make better guesses:		a) When over text and having small objects use line anchoring (for bullets)		b) If not over text or object is too large use paragraph anchoring"	self anchor: aCostume at: aPoint type: #paragraph.	self flag: #todo. ! !!CTextParagraphEditor methodsFor: 'anchoring'!anchor: aCostume at: aPoint type: anchorType	"Anchor the given costume at the provided location using the given type of anchoring"	| start stop |	aCostume fullBounds. "it needs to finish layout"	lastUndoType := nil.	start := markBlock stringIndex.	stop := pointBlock stringIndex.	self privateAnchor: aCostume at: aPoint type: anchorType.	paragraph composeAll.	costume invalidate.	self selectFrom: start to: stop.! !!CTextParagraphEditor methodsFor: 'anchoring'!removeAnchor: aCostume	| range anchor |	anchor _ TextAnchor new anchoredObject: aCostume.	range _ paragraph text find: anchor.	range ifNotNil:[		self replaceFrom: range first to: range last with: Text new.	].	aCostume textAnchorType: nil.	aCostume relativeTextAnchorPosition: nil.! !!CTextParagraphEditor methodsFor: 'mouse input' stamp: 'ar 5/6/2004 16:54'!mouseDown: evt	"Put the cursor at the location prompted by the user, if requested extending the selection."	| pos textPos |	textPos := evt position - costume editorOffset.	lastUndoType := nil.	pos := (paragraph characterBlockAtPoint: textPos) stringIndex.	(markBlock = pointBlock and:[pos = markBlock stringIndex])		ifTrue:[^self selectWordAt: markBlock stringIndex].	evt shiftPressed 		ifTrue:[self selectFrom: markBlock stringIndex to: pos]		ifFalse:[self selectFrom: pos to: pos].! !!CTextParagraphEditor methodsFor: 'mouse input' stamp: 'ar 3/18/2003 15:21'!mouseMove: evt	"If the mouse is down select text"	| pos textPos |	textPos := evt position - costume editorOffset.	lastUndoType := nil.	pos := (paragraph characterBlockAtPoint: textPos) stringIndex.	self selectFrom: markBlock stringIndex to: pos.! !!CTextParagraphEditor methodsFor: 'mouse input'!mouseUp: evt	lastUndoType := nil.	"Ignored for now"! !!CTextParagraphEditor methodsFor: 'editing keys'!backspace	| type |	type := #backspace.	pointBlock = markBlock		ifTrue:[self selectFrom: markBlock stringIndex to: markBlock stringIndex-1]		ifFalse:[type := nil].	self replaceSelectionWith: '' type: type! !!CTextParagraphEditor methodsFor: 'editing keys'!forwardDelete	"Delete forward over the next character."	| type |	type := #delete.	markBlock = pointBlock		ifTrue:[self selectFrom: markBlock stringIndex to: markBlock stringIndex + 1]		ifFalse:[type := nil].	self replaceSelectionWith: '' type: type! !!CTextParagraphEditor methodsFor: 'editing keys' stamp: 'ar 3/18/2003 23:59'!keyStroke: evt	evt keyValue = 8 ifTrue:[^self backspace].	evt keyValue = 127 ifTrue:[^self forwardDelete].	self replaceSelectionWith: evt keyCharacter asString type: #keyStroke.! !!CTextTool methodsFor: 'intialize' stamp: 'ar 4/4/2004 20:31'!initialize	super initialize.	self define: #window as: CWindow new.	self define: #fontNames as: CDropDownList new.	self define: #fontSizes as: CDropDownList new.	self define: #boldButton as: CToolBarButton new.	self define: #italicButton as: CToolBarButton new.	self define: #underlineButton as: CToolBarButton new.	self define: #struckoutButton as: CToolBarButton new.	self define: #leftAlign as: CToolBarButton new.	self define: #centerAlign as: CToolBarButton new.	self define: #rightAlign as: CToolBarButton new.	self define: #blockAlign as: CToolBarButton new.! !!CTextTool methodsFor: 'intialize' stamp: 'ar 4/30/2004 15:54'!setupCostume	super setupCostume.	window extent: 187@76.	window minimizeBox: false; maximizeBox: false.	self costume: window.	window label: 'TextTool'.	layout := CTableLayout new.	layout listDirection: #leftToRight.	layout wrapDirection: #topToBottom.	layout hResizing: #shrinkWrap; vResizing: #shrinkWrap.	layout layoutInset: 4.	layout cellInset: 2.	fontNames addAll: StrikeFont actualFamilyNames.	fontNames width: 108.	fontNames costume hResizing: #rigid.	self add: fontNames.	fontSizes addAll: #(9 10 12 14 18 24 36 48).	fontSizes width: 64.	fontSizes costume hResizing: #rigid.	self add: fontSizes.	boldButton label: ('B' asText allBold addAttribute: TextEmphasis bold).	boldButton extent: 20@20.	self add: boldButton.	italicButton label: (' I ' asText allBold addAttribute: TextEmphasis italic).	italicButton extent: 20@20.	self add: italicButton.	underlineButton label: ('U' asText allBold addAttribute: TextEmphasis underlined).	underlineButton extent: 20@20.	self add: underlineButton.	struckoutButton label: ('S' asText allBold addAttribute: TextEmphasis struckOut).	struckoutButton extent: 20@20.	self add: struckoutButton.	leftAlign extent: 20@20.	self add: leftAlign.	centerAlign extent: 20@20.	self add: centerAlign.	rightAlign extent: 20@20.	self add: rightAlign.	blockAlign extent: 20@20.	self add: blockAlign.	self selectFont: TextStyle defaultFont.! !!CTextTool methodsFor: 'accessing' stamp: 'ar 4/4/2004 17:36'!blockAlign	"Answer the blockAlign of the receiver"	<bewareOf: #blockAlignChanged>	^self propertyValueAt: #blockAlign! !!CTextTool methodsFor: 'accessing' stamp: 'ar 4/4/2004 17:36'!blockAlign: aValue	"Modify the receiver's blockAlign"	^self propertyValueAt: #blockAlign put: aValue with: #blockAlignChanged! !!CTextTool methodsFor: 'accessing' stamp: 'ar 4/4/2004 17:36'!boldButton	"Answer the boldButton of the receiver"	<bewareOf: #boldButtonChanged>	^self propertyValueAt: #boldButton! !!CTextTool methodsFor: 'accessing' stamp: 'ar 4/4/2004 17:36'!boldButton: aValue	"Modify the receiver's boldButton"	^self propertyValueAt: #boldButton put: aValue with: #boldButtonChanged! !!CTextTool methodsFor: 'accessing' stamp: 'ar 4/4/2004 17:36'!centerAlign	"Answer the centerAlign of the receiver"	<bewareOf: #centerAlignChanged>	^self propertyValueAt: #centerAlign! !!CTextTool methodsFor: 'accessing' stamp: 'ar 4/4/2004 17:36'!centerAlign: aValue	"Modify the receiver's centerAlign"	^self propertyValueAt: #centerAlign put: aValue with: #centerAlignChanged! !!CTextTool methodsFor: 'accessing' stamp: 'ar 4/4/2004 19:06'!editor	"Answer the editor of the receiver"	<bewareOf: #editorChanged>	^self propertyValueAt: #editor! !!CTextTool methodsFor: 'accessing' stamp: 'ar 4/4/2004 19:06'!editor: aValue	"Modify the receiver's editor"	^self propertyValueAt: #editor put: aValue with: #editorChanged! !!CTextTool methodsFor: 'accessing' stamp: 'ar 4/4/2004 17:34'!fontNames	"Answer the fontNames of the receiver"	<bewareOf: #fontNamesChanged>	^self propertyValueAt: #fontNames! !!CTextTool methodsFor: 'accessing' stamp: 'ar 4/4/2004 17:34'!fontNames: aValue	"Modify the receiver's fontNames"	^self propertyValueAt: #fontNames put: aValue with: #fontNamesChanged! !!CTextTool methodsFor: 'accessing' stamp: 'ar 4/4/2004 17:34'!fontSizes	"Answer the fontSizes of the receiver"	<bewareOf: #fontSizesChanged>	^self propertyValueAt: #fontSizes! !!CTextTool methodsFor: 'accessing' stamp: 'ar 4/4/2004 17:34'!fontSizes: aValue	"Modify the receiver's fontSizes"	^self propertyValueAt: #fontSizes put: aValue with: #fontSizesChanged! !!CTextTool methodsFor: 'accessing' stamp: 'tk 6/29/2004 14:15'!geometry	"My window has my bounds"	^window geometry! !!CTextTool methodsFor: 'accessing' stamp: 'ar 4/4/2004 17:36'!italicButton	"Answer the italicButton of the receiver"	<bewareOf: #italicButtonChanged>	^self propertyValueAt: #italicButton! !!CTextTool methodsFor: 'accessing' stamp: 'ar 4/4/2004 17:36'!italicButton: aValue	"Modify the receiver's italicButton"	^self propertyValueAt: #italicButton put: aValue with: #italicButtonChanged! !!CTextTool methodsFor: 'accessing' stamp: 'ar 4/4/2004 17:36'!leftAlign	"Answer the leftAlign of the receiver"	<bewareOf: #leftAlignChanged>	^self propertyValueAt: #leftAlign! !!CTextTool methodsFor: 'accessing' stamp: 'ar 4/4/2004 17:36'!leftAlign: aValue	"Modify the receiver's leftAlign"	^self propertyValueAt: #leftAlign put: aValue with: #leftAlignChanged! !!CTextTool methodsFor: 'accessing' stamp: 'ar 4/4/2004 17:36'!rightAlign	"Answer the rightAlign of the receiver"	<bewareOf: #rightAlignChanged>	^self propertyValueAt: #rightAlign! !!CTextTool methodsFor: 'accessing' stamp: 'ar 4/4/2004 17:36'!rightAlign: aValue	"Modify the receiver's rightAlign"	^self propertyValueAt: #rightAlign put: aValue with: #rightAlignChanged! !!CTextTool methodsFor: 'accessing' stamp: 'ar 4/4/2004 17:36'!struckoutButton	"Answer the struckoutButton of the receiver"	<bewareOf: #struckoutButtonChanged>	^self propertyValueAt: #struckoutButton! !!CTextTool methodsFor: 'accessing' stamp: 'ar 4/4/2004 17:36'!struckoutButton: aValue	"Modify the receiver's struckoutButton"	^self propertyValueAt: #struckoutButton put: aValue with: #struckoutButtonChanged! !!CTextTool methodsFor: 'accessing' stamp: 'ar 4/4/2004 17:36'!underlineButton	"Answer the underlineButton of the receiver"	<bewareOf: #underlineButtonChanged>	^self propertyValueAt: #underlineButton! !!CTextTool methodsFor: 'accessing' stamp: 'ar 4/4/2004 17:36'!underlineButton: aValue	"Modify the receiver's underlineButton"	^self propertyValueAt: #underlineButton put: aValue with: #underlineButtonChanged! !!CTextTool methodsFor: 'accessing' stamp: 'ar 4/4/2004 20:31'!window	"Answer the window of the receiver"	<bewareOf: #windowChanged>	^self propertyValueAt: #window! !!CTextTool methodsFor: 'accessing' stamp: 'ar 4/4/2004 20:31'!window: aValue	"Modify the receiver's window"	^self propertyValueAt: #window put: aValue with: #windowChanged! !!CTextTool methodsFor: 'color and fill' stamp: 'ar 4/4/2004 18:34'!windowColor: aColor	super windowColor: aColor.	self elements do:[:each| each windowColor: aColor].! !!CTextTool methodsFor: 'events' stamp: 'ar 4/4/2004 21:20'!onEditorChanged	<on: editorChanged>	editor ifNotNil:[^self onTextSelectionChanged].! !!CTextTool methodsFor: 'events' stamp: 'ar 4/4/2004 19:20'!onFontNameChanged	| style selection |	<on: valueChanged in: fontNames>	style := self selectedFontStyle ifNil:[TextStyle default].	selection := fontSizes value ifNil:[style defaultFont height].	fontSizes contents: style pointSizes.	fontSizes value: (style fontOfPointSize: selection) pointSize.	self onUpdateFont.! !!CTextTool methodsFor: 'events' stamp: 'ar 4/4/2004 19:08'!onFontSizeChanged	<on: valueChanged in: fontSizes>	self onUpdateFont.! !!CTextTool methodsFor: 'events' stamp: 'ar 4/4/2004 21:13'!onKeyboardFocusChanged	| newFocus |	<on: keyboardFocusChanged in: hand>	newFocus := hand keyboardFocus.	newFocus ifNil:[^editor := nil].	newFocus := newFocus asPlayer.	newFocus textHolder ifNil:[^editor := nil].	editor := newFocus textHolder getEditor.! !!CTextTool methodsFor: 'events' stamp: 'ar 4/4/2004 21:13'!onTextSelectionChanged	| code |	<on: textSelectionChanged in: editor>	self selectFont: editor font.	code := editor emphasis.	boldButton selected: (code anyMask: 1).	italicButton selected: (code anyMask: 2).	underlineButton selected: (code anyMask: 4).	struckoutButton selected: (code anyMask: 16).! !!CTextTool methodsFor: 'events' stamp: 'ar 4/4/2004 21:16'!onUpdateFont	| attr selection |	editor ifNil:[^self].	attr := TextFontReference toFont: self selectedFont.	selection := editor selection.	selection isEmpty 		ifTrue:[editor changeFontHere: attr].	selection := selection addAttribute: attr.	editor replaceSelectionWith: selection.	editor selectFrom: editor selectionStop - selection size to: editor selectionStop.! !!CTextTool methodsFor: 'events' stamp: 'ar 4/4/2004 20:41'!selectFont: aFont	fontNames value: aFont familyName asSymbol.	fontSizes contents: (self selectedFontStyle pointSizes).	fontSizes value: aFont pointSize.! !!CTextTool methodsFor: 'events' stamp: 'ar 4/4/2004 19:18'!selectedFont	| fontSize |	fontSize := self selectedFontSize.	fontSize ifNotNil:[^self selectedFontStyle fontOfPointSize: fontSize].	^self selectedFontStyle defaultFont! !!CTextTool methodsFor: 'events' stamp: 'ar 4/4/2004 19:16'!selectedFontSize	^fontSizes value! !!CTextTool methodsFor: 'events' stamp: 'ar 4/4/2004 19:07'!selectedFontStyle	^TextStyle named: fontNames value! !!CTextTool methodsFor: 'emphasis' stamp: 'ar 4/4/2004 21:04'!changeEmphasis: emph	"If the emphasis is present in the current selection, then add it. Otherwise remove it."	| attr selection |	selection := editor selection.	selection isEmpty 		ifTrue:[^editor changeEmpasisHere: emph].	selection removeAttributesSuchThat:[:a| a class == TextEmphasis].	emph = 0 ifFalse:[		attr := TextEmphasis new emphasisCode: emph.		emph = 0 ifFalse:[selection addAttribute: attr].	].	editor paste: selection select: true.! !!CTextTool methodsFor: 'emphasis' stamp: 'ar 4/4/2004 19:46'!onBoldChanged	<on: fire in: boldButton>	boldButton selected: boldButton selected not.	self onUpdateEmphasis.! !!CTextTool methodsFor: 'emphasis' stamp: 'ar 4/4/2004 19:47'!onItalicChanged	<on: fire in: italicButton>	italicButton selected: italicButton selected not.	self onUpdateEmphasis.! !!CTextTool methodsFor: 'emphasis' stamp: 'ar 4/4/2004 19:47'!onStruckoutChanged	<on: fire in: struckoutButton>	struckoutButton selected: struckoutButton selected not.	self onUpdateEmphasis.! !!CTextTool methodsFor: 'emphasis' stamp: 'ar 4/4/2004 19:47'!onUnderlinedChanged	<on: fire in: underlineButton>	underlineButton selected: underlineButton selected not.	self onUpdateEmphasis.! !!CTextTool methodsFor: 'emphasis' stamp: 'ar 4/4/2004 20:52'!onUpdateEmphasis	| code |	code := 0.	boldButton selected ifTrue:[code := code bitOr: 1].	italicButton selected ifTrue:[code := code bitOr: 2].	underlineButton selected ifTrue:[code := code bitOr: 4].	struckoutButton selected ifTrue:[code := code bitOr: 16].	"editor changeEmphasis: code."! !!CTileCostume methodsFor: 'initialize' stamp: 'ar 4/30/2004 15:54'!setupCostume	super setupCostume.	self color: Color transparent.	self clipping: false.! !!CTileCostume methodsFor: 'events' stamp: 'ar 3/30/2004 17:08'!onTilePadDragged: aTilePad	"The receiver -a tile being dragged around- is notified that it just successfully dropped on aTilePad."	<on: tilePadDragged in: player>! !!CTileCostume methodsFor: 'events' stamp: 'ar 3/30/2004 17:00'!onTilePadDropped: aTilePad	"The receiver -a tile being dragged around- is notified that it just successfully dropped on aTilePad."	<on: tilePadDropped in: player>	self color: Color transparent.! !!CTileCostume methodsFor: 'events' stamp: 'ar 3/30/2004 16:32'!tileSignal: eventName	"Find a guy in our container list who handles the event and let him know about it"	self allContainersDo:[:parent|		(parent handlesEvent: eventName) ifTrue:[^parent signal: eventName with: self].	].! !!CColorTileCostume methodsFor: 'initialize' stamp: 'ar 3/21/2004 19:26'!initialize	super initialize.	swatch := CPlayer new.! !!CColorTileCostume methodsFor: 'initialize' stamp: 'ar 4/30/2004 15:48'!setupCostume	super setupCostume.	self borderWidth: 1.	self borderStyle: #simple.	self borderColor: CWidgetLibrary default frameColor.	self extent: 50@22.	self hResizing: #rigid; vResizing: #spaceFill.	swatch extent: 14@14.	swatch borderWidth: 1; borderStyle: #inset.	self add: swatch.! !!CColorTileCostume methodsFor: 'accessing' stamp: 'ar 3/21/2004 19:26'!swatch	"Answer the swatch of the receiver"	<bewareOf: #swatchChanged>	^self propertyValueAt: #swatch! !!CColorTileCostume methodsFor: 'accessing' stamp: 'ar 3/21/2004 19:26'!swatch: aValue	"Modify the receiver's swatch"	^self propertyValueAt: #swatch put: aValue with: #swatchChanged! !!CColorTileCostume methodsFor: 'events' stamp: 'ar 3/21/2004 19:28'!onExtentChanged	<on: extentChanged>	swatch center: extent // 2.! !!CColorTileCostume methodsFor: 'events' stamp: 'ar 3/21/2004 19:42'!onMouseDown	| picker |	<on: mouseDown in: swatch>	picker := CColorPicker new.	picker player: self.	picker openAt: hand position.	picker pickColor.! !!CColorTileCostume methodsFor: 'events' stamp: 'ar 3/21/2004 19:28'!onPlayerChanged	super onPlayerChanged.	self onValueChanged.! !!CColorTileCostume methodsFor: 'events' stamp: 'ar 3/23/2004 18:18'!onValueChanged	<on: valueChanged>	value ifNotNil:[swatch color: value].! !!CEnumListCostume methodsFor: 'initialize' stamp: 'ar 3/30/2004 03:03'!initialize	super initialize.	self define: #list as: CDropDownList new.! !!CEnumListCostume methodsFor: 'initialize' stamp: 'ar 4/30/2004 15:49'!setupCostume	super setupCostume.	self borderWidth: 1.	self borderStyle: #simple.	self borderColor: CWidgetLibrary default frameColor.	self layout: CTableLayout new.	self layout listDirection: #leftToRight.	self hResizing: #shrinkWrap; vResizing: #spaceFill.	self height: 22.	list hResizing: #shrinkWrap; vResizing: #spaceFill.	list font: CTileLibrary default tileFont.	list clipping: false.	self add: list.! !!CEnumListCostume methodsFor: 'accessing' stamp: 'ar 3/30/2004 03:03'!list	"Answer the list of the receiver"	<bewareOf: #listChanged>	^self propertyValueAt: #list! !!CEnumListCostume methodsFor: 'accessing' stamp: 'ar 3/30/2004 03:03'!list: aValue	"Modify the receiver's list"	^self propertyValueAt: #list put: aValue with: #listChanged! !!CEnumListCostume methodsFor: 'events' stamp: 'ar 3/30/2004 03:05'!onCursorChanged	<on: cursorChanged in: list>	player value: list selection.! !!CEnumListCostume methodsFor: 'events' stamp: 'ar 3/30/2004 03:04'!onPlayerChanged	super onPlayerChanged.	list contents: player valueType enumValues.	self onValueChanged.! !!CEnumListCostume methodsFor: 'events' stamp: 'ar 3/30/2004 03:04'!onValueChanged	<on: valueChanged>	list selection: value.! !!CEnumTileCostume methodsFor: 'initialize' stamp: 'ar 3/21/2004 20:34'!initialize	super initialize.	self define: #spinner as: CSpinnerButtons new.	self define: #label as: CLabel new.	self define: #valueList as: CCollection new.	valueList wrapCursor: true.! !!CEnumTileCostume methodsFor: 'initialize' stamp: 'ar 4/30/2004 15:49'!setupCostume	super setupCostume.	self borderWidth: 1.	self borderStyle: #simple.	self borderColor: CWidgetLibrary default frameColor.	self layout: CTableLayout new.	self layout listDirection: #leftToRight.	self hResizing: #shrinkWrap; vResizing: #spaceFill.	self height: 22.	self add: spinner.	label hResizing: #shrinkWrap; vResizing: #spaceFill.	label font: CTileLibrary default tileFont.	label clipping: false.	self add: label.! !!CEnumTileCostume methodsFor: 'accessing' stamp: 'ar 3/21/2004 20:31'!label	"Answer the label of the receiver"	<bewareOf: #labelChanged>	^self propertyValueAt: #label! !!CEnumTileCostume methodsFor: 'accessing' stamp: 'ar 3/21/2004 20:31'!label: aValue	"Modify the receiver's label"	^self propertyValueAt: #label put: aValue with: #labelChanged! !!CEnumTileCostume methodsFor: 'accessing' stamp: 'ar 3/21/2004 20:31'!spinner	"Answer the spinner of the receiver"	<bewareOf: #spinnerChanged>	^self propertyValueAt: #spinner! !!CEnumTileCostume methodsFor: 'accessing' stamp: 'ar 3/21/2004 20:31'!spinner: aValue	"Modify the receiver's spinner"	^self propertyValueAt: #spinner put: aValue with: #spinnerChanged! !!CEnumTileCostume methodsFor: 'accessing' stamp: 'ar 3/21/2004 20:33'!valueList	"Answer the valueList of the receiver"	<bewareOf: #valueListChanged>	^self propertyValueAt: #valueList! !!CEnumTileCostume methodsFor: 'accessing' stamp: 'ar 3/21/2004 20:33'!valueList: aValue	"Modify the receiver's valueList"	^self propertyValueAt: #valueList put: aValue with: #valueListChanged! !!CEnumTileCostume methodsFor: 'events' stamp: 'ar 3/21/2004 20:34'!onContextMenu	| newValue |	<on: yellowButtonDown>	newValue := CMenu new chooseFromValues: valueList.	newValue ifNotNil:[value := newValue].! !!CEnumTileCostume methodsFor: 'events' stamp: 'ar 3/21/2004 20:34'!onPlayerChanged	super onPlayerChanged.	valueList contents: player valueType enumValues.	self onValueChanged.! !!CEnumTileCostume methodsFor: 'events' stamp: 'ar 3/21/2004 20:39'!onSpinDown	<on: spinDown in: spinner>	value := valueList next.! !!CEnumTileCostume methodsFor: 'events' stamp: 'ar 3/21/2004 20:39'!onSpinUp	<on: spinUp in: spinner>	value := valueList prev.! !!CEnumTileCostume methodsFor: 'events' stamp: 'ar 3/21/2004 20:35'!onValueChanged	<on: valueChanged>	valueList selection: value.	label value: value.! !!CImageResourceTileCostume methodsFor: 'initialize' stamp: 'ar 4/3/2004 14:09'!initialize	super initialize.	self define: #editor as: CInputField new.	self define: #button as: CPushButton new.! !!CImageResourceTileCostume methodsFor: 'initialize' stamp: 'ar 4/30/2004 15:51'!setupCostume	super setupCostume.	self borderWidth: 1.	self borderStyle: #simple.	self borderColor: CWidgetLibrary default frameColor.	self layout: CTableLayout new.	self layout listDirection: #leftToRight.	self hResizing: #shrinkWrap; vResizing: #spaceFill.	self height: 1.	editor onKeyDown: #(13) signal: #accept.	editor hResizing: #rigid; vResizing: #rigid.	editor extent: 80@20.	editor borderWidth: 1.	editor borderColor: CWidgetLibrary default frameColor.	editor color: Color transparent.	self add: editor.	button font: (TextStyle named: 'WindowFont') defaultFont.	button label: 'r'.	button extent: 20@20.	self add: button.! !!CImageResourceTileCostume methodsFor: 'accessing' stamp: 'ar 4/3/2004 14:12'!button	"Answer the button of the receiver"	<bewareOf: #buttonChanged>	^self propertyValueAt: #button! !!CImageResourceTileCostume methodsFor: 'accessing' stamp: 'ar 4/3/2004 14:12'!button: aValue	"Modify the receiver's button"	^self propertyValueAt: #button put: aValue with: #buttonChanged! !!CImageResourceTileCostume methodsFor: 'accessing' stamp: 'ar 4/3/2004 14:12'!editor	"Answer the editor of the receiver"	<bewareOf: #editorChanged>	^self propertyValueAt: #editor! !!CImageResourceTileCostume methodsFor: 'accessing' stamp: 'ar 4/3/2004 14:12'!editor: aValue	"Modify the receiver's editor"	^self propertyValueAt: #editor put: aValue with: #editorChanged! !!CImageResourceTileCostume methodsFor: 'events' stamp: 'ar 4/3/2004 14:19'!onButtonPressed	| fileName file aGraphic |	<on: fire in: button>	fileName := CFileOpenDialog openFile: {		{'Pictures'. #('*.gif' '*.jpg' '*.bmp' '*.png' '*.jpeg')}.	} label: 'Choose picture'.	fileName ifNil:[^self].	file := FileStream readOnlyFileNamed: fileName.	[aGraphic := CImageResource readFrom: file] ensure:[file close].	aGraphic ifNotNil:[value := aGraphic].! !!CImageResourceTileCostume methodsFor: 'events' stamp: 'ar 4/3/2004 14:25'!onEditorAccept	| url aStream aGraphic |	<on: accept in: editor>	editor contents isEmpty ifTrue:[		value := nil.	] ifFalse:[		url := editor contents asUrl.		aStream := url contentStream.		aGraphic := [CImageResource readFrom: aStream] ensure:[aStream close].		value := aGraphic.	].! !!CImageResourceTileCostume methodsFor: 'events' stamp: 'ar 4/3/2004 14:12'!onPlayerChanged	super onPlayerChanged.	self onValueChanged.! !!CImageResourceTileCostume methodsFor: 'events' stamp: 'ar 4/3/2004 14:16'!onValueChanged	<on: valueChanged>	editor value: (value ifNil:[''] ifNotNil:[value resourceUrl]).! !!CMessageAndArgsCostume methodsFor: 'initialize' stamp: 'ar 3/7/2004 22:02'!defaultPlayer	^CMessageTile! !!CMessageAndArgsCostume methodsFor: 'initialize' stamp: 'ar 4/30/2004 15:52'!setupCostume	super setupCostume.	self layout: CTableLayout new.	self layout listDirection: #leftToRight.	self hResizing: #spaceFill; vResizing: #shrinkWrap.! !!CMessageAndArgsCostume methodsFor: 'events' stamp: 'ar 3/7/2004 18:48'!onArgumentsChanged	"Update everything when the player's argument list changes"	<on: argumentsChanged in: player>	self onUpdateEverything.! !!CMessageAndArgsCostume methodsFor: 'events' stamp: 'ar 3/7/2004 18:47'!onPlayerChanged	super onPlayerChanged.	self onUpdateEverything.! !!CMessageAndArgsCostume methodsFor: 'events' stamp: 'ar 3/7/2004 18:48'!onSelectorChanged	"Update everything when the player's selector changes"	<on: selectorChanged in: player>	self onUpdateEverything.! !!CMessageAndArgsCostume methodsFor: 'events' stamp: 'ar 4/2/2004 14:51'!onUpdateEverything	| selector nArgs selectorParts |	self removeAll.	selector := player selector ifNil:[^self].	nArgs := selector numArgs.	nArgs = 0 ifTrue:[^self add: (self tileForMessagePart: selector)].	selectorParts := selector findTokens: $:.	selectorParts with: player arguments do:[:msgPart :msgArg|		self add: (self tileForMessagePart: msgPart).		self add: (self tileForArgument: msgArg).	].! !!CMessageAndArgsCostume methodsFor: 'private' stamp: 'ar 3/7/2004 21:09'!tileForArgument: arg	"Answer an appropriate costume for the given argument"	^arg costume! !!CMessageAndArgsCostume methodsFor: 'private' stamp: 'ar 3/7/2004 18:55'!tileForMessagePart: msgPart	"Answer an appropriate costume for the given message part"	^CMessagePartCostume on: msgPart! !!CMessagePartCostume methodsFor: 'initialize' stamp: 'ar 3/7/2004 22:03'!defaultPlayer	^nil! !!CMessagePartCostume methodsFor: 'initialize' stamp: 'ar 4/30/2004 15:52'!setupCostume	super setupCostume.	text := ''.	self textFont: CTileLibrary default tileFont.	self hResizing: #shrinkWrap.	self vResizing: #shrinkWrap.	"self textInset: 3@3."	self borderWidth: 1.	self borderColor: CWidgetLibrary default frameColor.	self borderStyle: #simple.! !!CMessagePartCostume methodsFor: 'events' stamp: 'ar 3/7/2004 18:56'!onValueChanged	<on: valueChanged>	self text: self value asText.! !!CMessageTileCostume methodsFor: 'initialize' stamp: 'ar 3/7/2004 22:03'!defaultPlayer	^CMessageTile! !!CMessageTileCostume methodsFor: 'initialize' stamp: 'ar 3/17/2004 03:14'!initialize	super initialize.	self define: #fireButton as: CTileButton new.	self define: #receiverTile as: CReceiverTileCostume new.	self define: #argumentsTile as: CMessageAndArgsCostume new.	self define: #expandArrow as: CTileButton new.! !!CMessageTileCostume methodsFor: 'initialize' stamp: 'ar 4/30/2004 15:52'!setupCostume	super setupCostume.	self color: CWidgetLibrary default paneColor.	self borderStyle: #raised.	self borderWidth: 1.	"self color: (Color r: 0.8 g: 1.0 b: 0.8)."	self layout: CTableLayout new.	self layout listDirection: #leftToRight.	self layout rubberBandCells: true.	self hResizing: #shrinkWrap.	self vResizing: #shrinkWrap.	fireButton hResizing: #shrinkWrap.	fireButton visible: false.	expandArrow label: '...'.	expandArrow hResizing: #shrinkWrap; vResizing: #spaceFill.	expandArrow visible: false.	self add: fireButton.	self add: receiverTile.	self add: argumentsTile.	self add: expandArrow.! !!CMessageTileCostume methodsFor: 'accessing' stamp: 'ar 3/12/2004 16:17'!argumentsTile	"Answer the argumentsTile of the receiver"	<bewareOf: #argumentsTileChanged>	^self propertyValueAt: #argumentsTile! !!CMessageTileCostume methodsFor: 'accessing' stamp: 'ar 3/12/2004 16:17'!argumentsTile: aValue	"Modify the receiver's argumentsTile"	^self propertyValueAt: #argumentsTile put: aValue with: #argumentsTileChanged! !!CMessageTileCostume methodsFor: 'accessing' stamp: 'ar 3/12/2004 16:17'!expandArrow	"Answer the expandArrow of the receiver"	<bewareOf: #expandArrowChanged>	^self propertyValueAt: #expandArrow! !!CMessageTileCostume methodsFor: 'accessing' stamp: 'ar 3/12/2004 16:17'!expandArrow: aValue	"Modify the receiver's expandArrow"	^self propertyValueAt: #expandArrow put: aValue with: #expandArrowChanged! !!CMessageTileCostume methodsFor: 'accessing' stamp: 'ar 3/12/2004 16:16'!fireButton	"Answer the fireButton of the receiver"	<bewareOf: #fireButtonChanged>	^self propertyValueAt: #fireButton! !!CMessageTileCostume methodsFor: 'accessing' stamp: 'ar 3/12/2004 16:16'!fireButton: aValue	"Modify the receiver's fireButton"	^self propertyValueAt: #fireButton put: aValue with: #fireButtonChanged! !!CMessageTileCostume methodsFor: 'accessing' stamp: 'ar 3/12/2004 16:17'!receiverTile	"Answer the receiverTile of the receiver"	<bewareOf: #receiverTileChanged>	^self propertyValueAt: #receiverTile! !!CMessageTileCostume methodsFor: 'accessing' stamp: 'ar 3/12/2004 16:17'!receiverTile: aValue	"Modify the receiver's receiverTile"	^self propertyValueAt: #receiverTile put: aValue with: #receiverTileChanged! !!CMessageTileCostume methodsFor: 'events' stamp: 'ar 3/7/2004 21:14'!onFireButtonPressed	| result |	<on: fire in: fireButton>	result := player eval.	player valueType ifNotNil:[		(CValueTile on: result) openInHand.	].! !!CMessageTileCostume methodsFor: 'events' stamp: 'ar 3/7/2004 21:13'!onPlayerChanged	self onReceiverChanged.	self onValueTypeChanged.	argumentsTile player: self player.! !!CMessageTileCostume methodsFor: 'events' stamp: 'ar 3/22/2004 18:40'!onReceiverChanged	<on: receiverChanged in: player>	receiverTile reflexive: player valueType notNil.	receiverTile value: player receiver.! !!CMessageTileCostume methodsFor: 'events' stamp: 'ar 3/30/2004 17:08'!onTilePadDragged: aTilePad	self color: CWidgetLibrary default paneColor.	self borderWidth: 1.! !!CMessageTileCostume methodsFor: 'events' stamp: 'ar 3/30/2004 17:02'!onTilePadDropped: aTilePad	"The receiver -a tile being dragged around- is notified that it just successfully dropped on aTilePad."	self color: Color transparent.	self borderWidth: 0.! !!CMessageTileCostume methodsFor: 'events' stamp: 'ar 3/7/2004 21:12'!onValueTypeChanged	<on: valueTypeChanged in: player>	player valueType 		ifNil:[fireButton label: '!!']		ifNotNil:[fireButton label: '?'].! !!CNumberTileCostume methodsFor: 'initialize' stamp: 'ar 3/17/2004 03:14'!initialize	super initialize.	self define: #editor as: CInputField new.	self define: #spinner as: CSpinnerButtons new.! !!CNumberTileCostume methodsFor: 'initialize' stamp: 'ar 4/30/2004 15:52'!setupCostume	super setupCostume.	self borderWidth: 1.	self borderStyle: #simple.	self borderColor: CWidgetLibrary default frameColor.	self layout: CTableLayout new.	self layout listDirection: #leftToRight.	self hResizing: #shrinkWrap; vResizing: #spaceFill.	self height: 1.	self add: spinner.	editor onKeyDown: #(13) signal: #accept.	editor hResizing: #rigid; vResizing: #rigid.	editor extent: 40@20.	editor borderWidth: 1.	editor borderColor: CWidgetLibrary default frameColor.	editor color: Color transparent.	self add: editor.! !!CNumberTileCostume methodsFor: 'accessing' stamp: 'ar 3/12/2004 16:15'!editor	"Answer the editor of the receiver"	<bewareOf: #editorChanged>	^self propertyValueAt: #editor! !!CNumberTileCostume methodsFor: 'accessing' stamp: 'ar 3/12/2004 16:15'!editor: aValue	"Modify the receiver's editor"	^self propertyValueAt: #editor put: aValue with: #editorChanged! !!CNumberTileCostume methodsFor: 'accessing' stamp: 'ar 3/12/2004 16:15'!spinner	"Answer the spinner of the receiver"	<bewareOf: #spinnerChanged>	^self propertyValueAt: #spinner! !!CNumberTileCostume methodsFor: 'accessing' stamp: 'ar 3/12/2004 16:15'!spinner: aValue	"Modify the receiver's spinner"	^self propertyValueAt: #spinner put: aValue with: #spinnerChanged! !!CNumberTileCostume methodsFor: 'events' stamp: 'ar 3/7/2004 21:57'!onEditorChanged	| newValue |	<on: accept in: editor>	newValue := [editor contents asString asNumber] 		on: Error do:[:ex| ex return: player value].	player value: newValue.	editor modified: false.	editor value: newValue.! !!CNumberTileCostume methodsFor: 'events' stamp: 'ar 5/3/2004 14:53'!onEditorFocusLost	<on: keyboardFocusLeave in: editor>	self onEditorChanged.! !!CNumberTileCostume methodsFor: 'events' stamp: 'ar 3/7/2004 22:23'!onPlayerChanged	super onPlayerChanged.	self onValueChanged.! !!CNumberTileCostume methodsFor: 'events' stamp: 'ar 3/28/2004 16:08'!onSpinDown	<on: spinDown in: spinner>	value := value - 1.! !!CNumberTileCostume methodsFor: 'events' stamp: 'ar 3/28/2004 16:08'!onSpinUp	<on: spinUp in: spinner>	value := value + 1.! !!CNumberTileCostume methodsFor: 'events' stamp: 'ar 3/28/2004 16:15'!onValueChanged	<on: valueChanged>	editor value: player value.! !!COperatorTileCostume methodsFor: 'initialize' stamp: 'ar 4/30/2004 15:52'!setupCostume	super setupCostume.	self color: CWidgetLibrary default paneColor.	self borderStyle: #raised.	self borderWidth: 1.	self layout: CTableLayout new.	self layout listDirection: #leftToRight.	self layout rubberBandCells: true.	self hResizing: #shrinkWrap.	self vResizing: #shrinkWrap.! !!COperatorTileCostume methodsFor: 'accessing' stamp: 'ar 3/22/2004 16:18'!leftHandTile	"Answer the leftHandTile of the receiver"	<bewareOf: #leftHandTileChanged>	^self propertyValueAt: #leftHandTile! !!COperatorTileCostume methodsFor: 'accessing' stamp: 'ar 3/22/2004 16:18'!leftHandTile: aValue	"Modify the receiver's leftHandTile"	^self propertyValueAt: #leftHandTile put: aValue with: #leftHandTileChanged! !!COperatorTileCostume methodsFor: 'accessing' stamp: 'ar 3/22/2004 16:18'!operatorTile	"Answer the operatorTile of the receiver"	<bewareOf: #operatorTileChanged>	^self propertyValueAt: #operatorTile! !!COperatorTileCostume methodsFor: 'accessing' stamp: 'ar 3/22/2004 16:18'!operatorTile: aValue	"Modify the receiver's operatorTile"	^self propertyValueAt: #operatorTile put: aValue with: #operatorTileChanged! !!COperatorTileCostume methodsFor: 'accessing' stamp: 'ar 3/22/2004 16:18'!rightHandTile	"Answer the rightHandTile of the receiver"	<bewareOf: #rightHandTileChanged>	^self propertyValueAt: #rightHandTile! !!COperatorTileCostume methodsFor: 'accessing' stamp: 'ar 3/22/2004 16:18'!rightHandTile: aValue	"Modify the receiver's rightHandTile"	^self propertyValueAt: #rightHandTile put: aValue with: #rightHandTileChanged! !!COperatorTileCostume methodsFor: 'events' stamp: 'ar 3/22/2004 16:19'!onPlayerChanged	super onPlayerChanged.	self onUpdateEverything.! !!COperatorTileCostume methodsFor: 'events' stamp: 'ar 3/30/2004 17:08'!onTilePadDragged: aTilePad	self color: CWidgetLibrary default paneColor.	self borderWidth: 1.! !!COperatorTileCostume methodsFor: 'events' stamp: 'ar 3/30/2004 17:02'!onTilePadDropped: aTilePad	"The receiver -a tile being dragged around- is notified that it just successfully dropped on aTilePad."	self color: Color transparent.	self borderWidth: 0.! !!COperatorTileCostume methodsFor: 'events' stamp: 'ar 4/2/2004 14:52'!onUpdateEverything	self removeAll.	self add: player arguments first costume.	self add: (CMessagePartCostume on: player name).	self add: player arguments last costume.! !!CPropertyTileCostume methodsFor: 'initialize' stamp: 'ar 3/21/2004 18:15'!defaultPlayer	^CPropertyTile! !!CPropertyTileCostume methodsFor: 'initialize' stamp: 'ar 3/22/2004 17:45'!initialize	super initialize.	self define: #fireButton as: CTileButton new.	self define: #receiverTile as: CReceiverTileCostume new.	self define: #propertyName as: CLabel new.	receiverTile reflexive: true.! !!CPropertyTileCostume methodsFor: 'initialize' stamp: 'ar 4/30/2004 15:53'!setupCostume	super setupCostume.	self color: CWidgetLibrary default paneColor.	self borderStyle: #raised.	self borderWidth: 1.	self layout: CTableLayout new.	self layout listDirection: #leftToRight.	self layout rubberBandCells: true.	self hResizing: #shrinkWrap.	self vResizing: #shrinkWrap.	self add: receiverTile.	propertyName font: CTileLibrary default tileFont.	propertyName clipping: false.	propertyName borderWidth: 1.	propertyName borderColor: CWidgetLibrary default frameColor.	propertyName borderStyle: #simple.	self add: propertyName.! !!CPropertyTileCostume methodsFor: 'accessing' stamp: 'ar 3/21/2004 18:17'!propertyName	"Answer the propertyName of the receiver"	<bewareOf: #propertyNameChanged>	^self propertyValueAt: #propertyName! !!CPropertyTileCostume methodsFor: 'accessing' stamp: 'ar 3/21/2004 18:17'!propertyName: aValue	"Modify the receiver's propertyName"	^self propertyValueAt: #propertyName put: aValue with: #propertyNameChanged! !!CPropertyTileCostume methodsFor: 'accessing' stamp: 'ar 3/21/2004 18:16'!receiverTile	"Answer the receiverTile of the receiver"	<bewareOf: #receiverTileChanged>	^self propertyValueAt: #receiverTile! !!CPropertyTileCostume methodsFor: 'accessing' stamp: 'ar 3/21/2004 18:16'!receiverTile: aValue	"Modify the receiver's receiverTile"	^self propertyValueAt: #receiverTile put: aValue with: #receiverTileChanged! !!CPropertyTileCostume methodsFor: 'events' stamp: 'ar 3/21/2004 18:21'!onPlayerChanged	super onPlayerChanged.	self onReceiverChanged.	self onPropertyChanged.! !!CPropertyTileCostume methodsFor: 'events' stamp: 'ar 3/21/2004 18:19'!onPropertyChanged	<on: propertyChanged in: player>	propertyName value: player property.! !!CPropertyTileCostume methodsFor: 'events' stamp: 'ar 3/21/2004 21:15'!onReceiverChanged	<on: receiverChanged in: player>	receiverTile value: player receiver.! !!CPropertyTileCostume methodsFor: 'events' stamp: 'ar 3/30/2004 17:08'!onTilePadDragged: aTilePad	self color: CWidgetLibrary default paneColor.	self borderWidth: 1.! !!CPropertyTileCostume methodsFor: 'events' stamp: 'ar 3/30/2004 17:02'!onTilePadDropped: aTilePad	"The receiver -a tile being dragged around- is notified that it just successfully dropped on aTilePad."	self color: Color transparent.	self borderWidth: 0.! !!CReceiverTileCostume methodsFor: 'initialize' stamp: 'ar 3/21/2004 21:15'!defaultPlayer	^nil! !!CReceiverTileCostume methodsFor: 'initialize' stamp: 'ar 3/22/2004 17:44'!initialize	super initialize.	reflexive := false.! !!CReceiverTileCostume methodsFor: 'initialize' stamp: 'ar 4/30/2004 15:53'!setupCostume	super setupCostume.	text := ''.	self textFont: CTileLibrary default tileFont.	self hResizing: #shrinkWrap; vResizing: #shrinkWrap.	"self textInset: 3@3."	self borderWidth: 1.	self borderColor: CWidgetLibrary default frameColor.	self borderStyle: #simple.! !!CReceiverTileCostume methodsFor: 'accessing' stamp: 'ar 3/22/2004 17:44'!reflexive	"Answer the reflexive of the receiver"	<bewareOf: #reflexiveChanged>	^self propertyValueAt: #reflexive! !!CReceiverTileCostume methodsFor: 'accessing' stamp: 'ar 3/22/2004 17:44'!reflexive: aValue	"Modify the receiver's reflexive"	^self propertyValueAt: #reflexive put: aValue with: #reflexiveChanged! !!CReceiverTileCostume methodsFor: 'events' stamp: 'ar 3/22/2004 17:45'!onNameChanged	<on: nameChanged in: value>	reflexive 		ifTrue:[self text: value name,'''s']		ifFalse:[self text: value name].! !!CReceiverTileCostume methodsFor: 'events' stamp: 'ar 3/21/2004 21:21'!onValueChanged	<on: valueChanged>	self onNameChanged.! !!CSequenceTileCostume methodsFor: 'initialize' stamp: 'ar 3/8/2004 21:05'!defaultPlayer	^CSequenceTile! !!CSequenceTileCostume methodsFor: 'initialize' stamp: 'ar 3/17/2004 03:15'!initialize	super initialize.	self define: #spacer as: CPlayer new.	self define: #target as: CPlayer new.! !!CSequenceTileCostume methodsFor: 'initialize' stamp: 'ar 4/30/2004 15:53'!setupCostume	super setupCostume.	self color: Color white.	self layout: CTableLayout new.	self hResizing: #spaceFill; vResizing: #shrinkWrap.	target layout: CTableLayout new.	target hResizing: #spaceFill; vResizing: #shrinkWrap.	target layout cellPositioning: #topLeft.	self add: target.	spacer hResizing: #spaceFill; vResizing: #shrinkWrap.	spacer fillStyle: #radialGradient.	spacer fillColors: {Color white. Color r: 1.0 g: 0.677 b: 0.032}.	spacer borderWidth: 1.	spacer borderStyle: #simple.	spacer borderColor: CWidgetLibrary default frameColor.	spacer textFont: CTileLibrary default tileFont.	spacer text: '<-- drop here -->'.	spacer textAnchorPoint: #center.! !!CSequenceTileCostume methodsFor: 'accessing' stamp: 'ar 3/12/2004 16:18'!spacer	"Answer the spacer of the receiver"	<bewareOf: #spacerChanged>	^self propertyValueAt: #spacer! !!CSequenceTileCostume methodsFor: 'accessing' stamp: 'ar 3/12/2004 16:18'!spacer: aValue	"Modify the receiver's spacer"	^self propertyValueAt: #spacer put: aValue with: #spacerChanged! !!CSequenceTileCostume methodsFor: 'accessing' stamp: 'ar 3/12/2004 16:18'!target	"Answer the target of the receiver"	<bewareOf: #targetChanged>	^self propertyValueAt: #target! !!CSequenceTileCostume methodsFor: 'accessing' stamp: 'ar 3/12/2004 16:18'!target: aValue	"Modify the receiver's target"	^self propertyValueAt: #target put: aValue with: #targetChanged! !!CSequenceTileCostume methodsFor: 'events' stamp: 'ar 3/16/2004 16:46'!onDragStart: evt	"Handle a drag start"	| dragTile |	<on: dragStart in: target>	dragTile := target findPlayerAt: evt position.	dragTile ifNil:[^self].	[dragTile player == nil] whileFalse:[dragTile := dragTile player].	self player statements remove: dragTile.	self player statements isEmpty 		ifTrue:[target height: spacer height].	self hand attach: dragTile.	dragTile origin: self hand position + 4.! !!CSequenceTileCostume methodsFor: 'events' stamp: 'ar 3/8/2004 21:00'!onPlayerChanged	super onPlayerChanged.	self onStatementsChanged.! !!CSequenceTileCostume methodsFor: 'events' stamp: 'ar 3/8/2004 23:25'!onStatementsChanged	<on: statementsChanged in: player>	target removeAll.	target addAll: player statements.! !!CSequenceTileCostume methodsFor: 'drag and drop' stamp: 'ar 3/14/2004 21:54'!onDragEnter	<on: dragEnter in: target>	self tileSignal: #tileSequenceEnter.	self onTileEnter.! !!CSequenceTileCostume methodsFor: 'drag and drop' stamp: 'ar 3/24/2004 02:13'!onTileEnter	| newTile evt |	newTile := self hand dropContents ifNil:[^self].	[newTile player == nil] whileFalse:[newTile := newTile player].	newTile == self player ifTrue:[^self]. "spurious enter"	newTile isTilePlayer ifFalse:[^self].	newTile isStatementLike ifFalse:[^self].	self startTicking: #trackDropZones at: 100.	evt := self waitUntilAnyOf: {		target. #tileSequenceEnter.		target. #dragLeave.		target. #dragDrop.	}.	self stopScript: #trackDropZones.	evt selector == #dragDrop ifTrue:[		player statements add: newTile 			at: (target elements indexOf: spacer).		newTile signal: #tileSequenceDrop.		self onStatementsChanged.	].	evt selector == #dragLeave ifTrue:[		self tileSignal: #tileSequenceLeave.	].	spacer close.! !!CSequenceTileCostume methodsFor: 'drag and drop' stamp: 'ar 3/25/2004 14:41'!onTileSequenceLeave	<on: tileSequenceLeave>	(target containsPoint: target cursorPoint) 		ifTrue:[self startScript: #onTileEnter]		ifFalse:[self tileSignal: #tileSequenceLeave].! !!CSequenceTileCostume methodsFor: 'drag and drop' stamp: 'ar 4/2/2004 14:53'!trackDropZones	| refPt above |	spacer close.	refPt := target cursorPoint.	"figure out the guy above the cursor point so we know 	what the reference y for resizing the spacers is"	above := target elements detect:[:any| 		any ~~ spacer and:[any center y > refPt y]	] ifNone:[nil].	above 		ifNil:[target addLast: spacer]		ifNotNil:[target add: spacer before: above].! !!CScriptorTileCostume methodsFor: 'initialize' stamp: 'ar 3/17/2004 03:14'!initialize	super initialize.	self define: #header as: CScriptorHeader new.! !!CScriptorTileCostume methodsFor: 'initialize' stamp: 'ar 4/30/2004 15:53'!setupCostume	super setupCostume.	self borderStyle: #complexRaised.	self borderWidth: 2.	self borderColor: (Color r: 0.995 g: 0.804 b: 0.404).	self roundCornerSpec: #(1 4).	target borderWidth: 2.	target borderStyle: #complexAltInset.	target borderColor: (Color r: 0.995 g: 0.804 b: 0.404).	target layout layoutInset: 2; cellInset: 1.	target color: Color white.	self layout: CTableLayout new.	self hResizing: #shrinkWrap.	self vResizing: #shrinkWrap.	self layout rubberBandCells: true.	self add: header.! !!CScriptorTileCostume methodsFor: 'accessing' stamp: 'ar 3/12/2004 16:17'!header	"Answer the header of the receiver"	<bewareOf: #headerChanged>	^self propertyValueAt: #header! !!CScriptorTileCostume methodsFor: 'accessing' stamp: 'ar 3/12/2004 16:17'!header: aValue	"Modify the receiver's header"	^self propertyValueAt: #header put: aValue with: #headerChanged! !!CScriptorTileCostume methodsFor: 'events' stamp: 'ar 3/8/2004 23:34'!onPlayerChanged	super onPlayerChanged.	self onSelectorChanged.	self onReceiverChanged.! !!CScriptorTileCostume methodsFor: 'events' stamp: 'ar 3/8/2004 23:35'!onReceiverChanged	<on: receiverChanged in: player>	header rcvrLabel value: player receiver name.! !!CScriptorTileCostume methodsFor: 'events' stamp: 'ar 3/8/2004 23:35'!onSelectorChanged	<on: selectorChanged in: player>	header scriptName value: player selector! !!CSoundTileCostume methodsFor: 'accessing' stamp: 'ar 3/21/2004 18:46'!label	"Answer the label of the receiver"	<bewareOf: #labelChanged>	^self propertyValueAt: #label! !!CSoundTileCostume methodsFor: 'accessing' stamp: 'ar 3/21/2004 18:46'!label: aValue	"Modify the receiver's label"	^self propertyValueAt: #label put: aValue with: #labelChanged! !!CSoundTileCostume methodsFor: 'accessing' stamp: 'ar 3/21/2004 18:46'!spinner	"Answer the spinner of the receiver"	<bewareOf: #spinnerChanged>	^self propertyValueAt: #spinner! !!CSoundTileCostume methodsFor: 'accessing' stamp: 'ar 3/21/2004 18:46'!spinner: aValue	"Modify the receiver's spinner"	^self propertyValueAt: #spinner put: aValue with: #spinnerChanged! !!CStringTileCostume methodsFor: 'initialize' stamp: 'ar 3/28/2004 22:43'!initialize	super initialize.	self define: #editor as: CInputField new.! !!CStringTileCostume methodsFor: 'initialize' stamp: 'ar 4/30/2004 15:54'!setupCostume	super setupCostume.	self layout: CTableLayout new.	self layout listDirection: #leftToRight.	self hResizing: #shrinkWrap; vResizing: #spaceFill.	self height: 22.	editor width: 60.	editor color: Color transparent.	editor hResizing: #rigid; vResizing: #spaceFill.	editor font: CTileLibrary default tileFont.	self add: editor.! !!CStringTileCostume methodsFor: 'accessing' stamp: 'ar 3/28/2004 22:42'!editor	"Answer the editor of the receiver"	<bewareOf: #editorChanged>	^self propertyValueAt: #editor! !!CStringTileCostume methodsFor: 'accessing' stamp: 'ar 3/28/2004 22:42'!editor: aValue	"Modify the receiver's editor"	^self propertyValueAt: #editor put: aValue with: #editorChanged! !!CStringTileCostume methodsFor: 'events' stamp: 'ar 3/28/2004 22:45'!onAcceptValue	<on: accept in: editor>	value := editor value.! !!CStringTileCostume methodsFor: 'events' stamp: 'ar 3/28/2004 22:44'!onPlayerChanged	super onPlayerChanged.	self onValueChanged.! !!CStringTileCostume methodsFor: 'events' stamp: 'ar 3/28/2004 22:44'!onValueChanged	<on: valueChanged>	editor value: value.! !!CTileDefinition methodsFor: 'accessing' stamp: 'ar 3/21/2004 16:37'!externalName	"Answer the externalName of the receiver"	<bewareOf: #externalNameChanged>	^self propertyValueAt: #externalName! !!CTileDefinition methodsFor: 'accessing' stamp: 'ar 3/21/2004 16:37'!externalName: aValue	"Modify the receiver's externalName"	^self propertyValueAt: #externalName put: aValue with: #externalNameChanged! !!CTileDefinition methodsFor: 'accessing' stamp: 'ar 3/21/2004 16:37'!helpText	"Answer the helpText of the receiver"	<bewareOf: #helpTextChanged>	^self propertyValueAt: #helpText! !!CTileDefinition methodsFor: 'accessing' stamp: 'ar 3/21/2004 16:37'!helpText: aValue	"Modify the receiver's helpText"	^self propertyValueAt: #helpText put: aValue with: #helpTextChanged! !!CTileDefinition methodsFor: 'accessing' stamp: 'ar 3/21/2004 16:38'!selector	"Answer the selector of the receiver"	<bewareOf: #selectorChanged>	^self propertyValueAt: #selector! !!CTileDefinition methodsFor: 'accessing' stamp: 'ar 3/21/2004 16:38'!selector: aValue	"Modify the receiver's selector"	^self propertyValueAt: #selector put: aValue with: #selectorChanged! !!CTileDefinition methodsFor: 'accessing' stamp: 'ar 3/21/2004 16:37'!type	"Answer the type of the receiver"	<bewareOf: #typeChanged>	^self propertyValueAt: #type! !!CTileDefinition methodsFor: 'accessing' stamp: 'ar 3/21/2004 16:37'!type: aValue	"Modify the receiver's type"	^self propertyValueAt: #type put: aValue with: #typeChanged! !!CTileDefinition methodsFor: 'creating' stamp: 'ar 3/21/2004 17:36'!new	"Create a new tile for this definition"	^self subclassResponsibility! !!CTileDefinition methodsFor: 'creating' stamp: 'ar 3/21/2004 17:34'!newFor: anObject	"Create a new tile for the given object"	^self subclassResponsibility! !!CTileDefinition methodsFor: 'printing' stamp: 'ar 3/21/2004 16:25'!xmlString	| stream writer |	stream := WriteStream on: String new.	writer := XMLWriterIndenting on: stream.	self printXmlOn: writer.	^stream contents! !!CTileDefinition methodsFor: 'private' stamp: 'ar 3/21/2004 16:41'!typeNamed: aString	^Smalltalk at: aString asSymbol! !!CArgumentDefinition methodsFor: 'accessing' stamp: 'ar 3/21/2004 16:21'!defaultValue	"Answer the defaultValue of the receiver"	<bewareOf: #defaultValueChanged>	^self propertyValueAt: #defaultValue! !!CArgumentDefinition methodsFor: 'accessing' stamp: 'ar 3/21/2004 16:21'!defaultValue: aValue	"Modify the receiver's defaultValue"	^self propertyValueAt: #defaultValue put: aValue with: #defaultValueChanged! !!CArgumentDefinition methodsFor: 'creating' stamp: 'ar 3/21/2004 17:50'!new	| tile expr |	expr := CValueTile new.	expr valueType: type.	expr value: defaultValue.	tile := CVariableTile new.	tile valueType: type.	tile name: (externalName ifNil:['']).	tile expression: expr.	^tile! !!CArgumentDefinition methodsFor: 'creating' stamp: 'ar 3/21/2004 17:43'!newFor: anObject	^self new! !!CArgumentDefinition methodsFor: 'printing' stamp: 'ar 3/21/2004 17:26'!printXmlOn: xmlWriter	xmlWriter startTag: 'argument'.	externalName ifNotNil:[xmlWriter attribute: 'name' value: externalName].	type ifNotNil:[xmlWriter attribute: 'type' value: type name].	defaultValue ifNotNil:[xmlWriter attribute: 'defaultValue' value: (type print: defaultValue)].	helpText ifNotNil:[xmlWriter attribute: 'help' value: helpText].	xmlWriter endEmptyTag: 'argument'.! !!CArgumentDefinition methodsFor: 'printing' stamp: 'ar 3/21/2004 16:57'!readXmlFrom: xmlNode	| attr |	xmlNode name == #argument ifFalse:[^self error: 'Not an argument'].	attr := xmlNode attributeAt: 'name'.	attr ifNotNil:[externalName := attr].	attr := xmlNode attributeAt: 'type'.	attr ifNotNil:[type := self typeNamed: attr].	attr := xmlNode attributeAt: 'default'.	attr ifNotNil:[defaultValue := type read: attr].	attr := xmlNode attributeAt: 'help'.	attr ifNotNil:[helpText := attr].	^self! !!CCategoryDefinition methodsFor: 'initialize' stamp: 'ar 3/21/2004 17:05'!initialize	super initialize.	self define: #items as: CCollection new.! !!CCategoryDefinition methodsFor: 'accessing' stamp: 'ar 3/21/2004 17:01'!items	"Answer the items of the receiver"	<bewareOf: #itemsChanged>	^self propertyValueAt: #items! !!CCategoryDefinition methodsFor: 'accessing' stamp: 'ar 3/21/2004 17:01'!items: aValue	"Modify the receiver's items"	^self propertyValueAt: #items put: aValue with: #itemsChanged! !!CCategoryDefinition methodsFor: 'creating' stamp: 'ar 3/22/2004 15:11'!new	| tile |	tile := CTileViewerPage new.	tile name: externalName.	tile contents: (items collect:[:each| each new]).	^tile! !!CCategoryDefinition methodsFor: 'creating' stamp: 'ar 3/22/2004 15:11'!newFor: anObject	| tile |	tile := CTileViewerPage new.	tile name: externalName.	tile contents: (items collect:[:each| each newFor: anObject]).	^tile! !!CCategoryDefinition methodsFor: 'printing' stamp: 'ar 3/21/2004 17:25'!printXmlOn: xmlWriter	xmlWriter startTag: 'category'.	selector ifNotNil:[xmlWriter attribute: 'selector' value: selector].	externalName ifNotNil:[xmlWriter attribute: 'name' value: externalName].	type ifNotNil:[xmlWriter attribute: 'type' value: type name].	helpText ifNotNil:[xmlWriter attribute: 'help' value: helpText].	xmlWriter endTag.	items do:[:each| each printXmlOn: xmlWriter].	xmlWriter endTag: 'category'.! !!CCategoryDefinition methodsFor: 'printing' stamp: 'ar 3/21/2004 17:03'!readXmlFrom: xmlNode	| attr |	xmlNode name == #category ifFalse:[^self error: 'Not a category'].	attr := xmlNode attributeAt: 'selector'.	attr ifNotNil:[selector := attr asSymbol].	attr := xmlNode attributeAt: 'name'.	attr ifNotNil:[externalName := attr].	attr := xmlNode attributeAt: 'type'.	attr ifNotNil:[type := self typeNamed: attr].	attr := xmlNode attributeAt: 'help'.	attr ifNotNil:[helpText := attr].	xmlNode elements do:[:each|		items add: (CTileDefinition xmlFrom: each).	].	^self! !!CMessageDefinition methodsFor: 'initialize' stamp: 'ar 3/21/2004 16:45'!initialize	super initialize.	self define: #arguments as: CCollection new.! !!CMessageDefinition methodsFor: 'accessing' stamp: 'ar 3/21/2004 16:17'!arguments	"Answer the arguments of the receiver"	<bewareOf: #argumentsChanged>	^self propertyValueAt: #arguments! !!CMessageDefinition methodsFor: 'accessing' stamp: 'ar 3/21/2004 16:17'!arguments: aValue	"Modify the receiver's arguments"	^self propertyValueAt: #arguments put: aValue with: #argumentsChanged! !!CMessageDefinition methodsFor: 'creating' stamp: 'ar 3/22/2004 15:26'!new	"Create a new tile for the given object"	| tile |	tile := CMessageTile new.	tile valueType: type.	tile selector: selector.	tile name: (externalName ifNil:[selector]).	tile arguments: (arguments collect:[:each| each new]).	tile definition: self.	^tile! !!CMessageDefinition methodsFor: 'creating' stamp: 'ar 3/22/2004 15:26'!newFor: anObject	"Create a new tile for the given object"	| tile |	tile := CMessageTile new.	tile receiver: anObject.	tile valueType: type.	tile selector: selector.	tile name: (externalName ifNil:[selector]).	tile arguments: (arguments collect:[:each| each new]).	tile definition: self.	^tile! !!CMessageDefinition methodsFor: 'printing' stamp: 'ar 3/21/2004 17:25'!printXmlOn: xmlWriter	xmlWriter startTag: 'message'.	selector ifNotNil:[xmlWriter attribute: 'selector' value: selector].	externalName ifNotNil:[xmlWriter attribute: 'name' value: externalName].	type ifNotNil:[xmlWriter attribute: 'type' value: type name].	helpText ifNotNil:[xmlWriter attribute: 'help' value: helpText].	arguments size = 0 ifTrue:[^xmlWriter endEmptyTag: 'message'].	xmlWriter endTag.	arguments do:[:each| each printXmlOn: xmlWriter].	xmlWriter endTag: 'message'.! !!CMessageDefinition methodsFor: 'printing' stamp: 'ar 3/21/2004 16:40'!readXmlFrom: xmlNode	| attr |	xmlNode name == #message ifFalse:[^self error: 'Not an argument'].	attr := xmlNode attributeAt: 'selector'.	attr ifNotNil:[selector := attr asSymbol].	attr := xmlNode attributeAt: 'name'.	attr ifNotNil:[externalName := attr].	attr := xmlNode attributeAt: 'type'.	attr ifNotNil:[type := self typeNamed: attr].	attr := xmlNode attributeAt: 'help'.	attr ifNotNil:[helpText := attr].	xmlNode elements do:[:each|		arguments add: (CArgumentDefinition new readXmlFrom: each).	].	^self! !!COperatorDefinition methodsFor: 'initialize' stamp: 'ar 3/22/2004 16:07'!initialize	super initialize.	self define: #arguments as: CCollection new.! !!COperatorDefinition methodsFor: 'accessing' stamp: 'ar 3/22/2004 16:07'!arguments	"Answer the arguments of the receiver"	<bewareOf: #argumentsChanged>	^self propertyValueAt: #arguments! !!COperatorDefinition methodsFor: 'accessing' stamp: 'ar 3/22/2004 16:07'!arguments: aValue	"Modify the receiver's arguments"	^self propertyValueAt: #arguments put: aValue with: #argumentsChanged! !!COperatorDefinition methodsFor: 'creating' stamp: 'ar 3/22/2004 16:17'!new	"Create a new tile for the given object"	| tile |	tile := COperatorTile new.	tile valueType: type.	tile selector: selector.	tile name: (externalName ifNil:[selector]).	tile arguments: (arguments collect:[:each| each new]).	tile definition: self.	^tile! !!COperatorDefinition methodsFor: 'creating' stamp: 'ar 3/22/2004 16:17'!newFor: anObject	"Create a new tile for the given object"	| tile |	tile := COperatorTile new.	tile receiver: anObject.	tile valueType: type.	tile selector: selector.	tile name: (externalName ifNil:[selector]).	tile arguments: (arguments collect:[:each| each new]).	tile definition: self.	^tile! !!COperatorDefinition methodsFor: 'printing' stamp: 'ar 3/23/2004 20:02'!printXmlOn: xmlWriter	xmlWriter startTag: 'operator'.	selector ifNotNil:[xmlWriter attribute: 'selector' value: selector].	externalName ifNotNil:[xmlWriter attribute: 'name' value: externalName].	type ifNotNil:[xmlWriter attribute: 'type' value: type name].	helpText ifNotNil:[xmlWriter attribute: 'help' value: helpText].	xmlWriter endTag.	arguments do:[:each| each printXmlOn: xmlWriter].	xmlWriter endTag: 'operator'.! !!COperatorDefinition methodsFor: 'printing' stamp: 'ar 3/22/2004 16:07'!readXmlFrom: xmlNode	| attr |	xmlNode name == #operator ifFalse:[^self error: 'Not an operator'].	attr := xmlNode attributeAt: 'selector'.	attr ifNotNil:[selector := attr asSymbol].	attr := xmlNode attributeAt: 'name'.	attr ifNotNil:[externalName := attr].	attr := xmlNode attributeAt: 'type'.	attr ifNotNil:[type := self typeNamed: attr].	attr := xmlNode attributeAt: 'help'.	attr ifNotNil:[helpText := attr].	xmlNode elements do:[:each|		arguments add: (CArgumentDefinition new readXmlFrom: each).	].	^self! !!CSlotDefinition methodsFor: 'creating' stamp: 'ar 3/22/2004 15:26'!new	| tile |	tile := CPropertyTile new.	tile valueType: type.	tile property: selector.	tile name: (externalName ifNil:[selector]).	tile definition: self.	^tile! !!CSlotDefinition methodsFor: 'creating' stamp: 'ar 3/22/2004 15:26'!newFor: anObject	| tile |	tile := CPropertyTile new.	tile receiver: anObject.	tile valueType: type.	tile property: selector.	tile name: externalName.	tile definition: self.	^tile! !!CSlotDefinition methodsFor: 'printing' stamp: 'ar 3/21/2004 16:41'!printXmlOn: xmlWriter	xmlWriter startTag: 'slot'.	selector ifNotNil:[xmlWriter attribute: 'selector' value: selector].	externalName ifNotNil:[xmlWriter attribute: 'name' value: externalName].	type ifNotNil:[xmlWriter attribute: 'type' value: type name].	helpText ifNotNil:[xmlWriter attribute: 'help' value: helpText].	xmlWriter endEmptyTag: 'slot'.! !!CSlotDefinition methodsFor: 'printing' stamp: 'ar 3/21/2004 16:41'!readXmlFrom: xmlNode	| attr |	xmlNode name == #slot ifFalse:[^self error: 'Not an argument'].	attr := xmlNode attributeAt: 'selector'.	attr ifNotNil:[selector := attr asSymbol].	attr := xmlNode attributeAt: 'name'.	attr ifNotNil:[externalName := attr].	attr := xmlNode attributeAt: 'type'.	attr ifNotNil:[type := self typeNamed: attr].	attr := xmlNode attributeAt: 'help'.	attr ifNotNil:[helpText := attr].	^self! !!CTileInspector methodsFor: 'initialize' stamp: 'ar 4/3/2004 20:10'!initialize	super initialize.	self define: #fieldList as: CList new.	fieldList itemMaker: CTileReadout.! !!CTileInspector methodsFor: 'initialize' stamp: 'ar 4/30/2004 15:55'!setupCostume	super setupCostume.	self layout: CTableLayout new.	self add: fieldList.! !!CTileInspector methodsFor: 'accessing' stamp: 'ar 3/19/2004 15:24'!category	"Answer the category of the receiver"	<bewareOf: #categoryChanged>	^self propertyValueAt: #category! !!CTileInspector methodsFor: 'accessing' stamp: 'ar 3/19/2004 15:24'!category: aValue	"Modify the receiver's category"	^self propertyValueAt: #category put: aValue with: #categoryChanged! !!CTileInspector methodsFor: 'accessing' stamp: 'ar 3/19/2004 15:18'!fieldList	"Answer the fieldList of the receiver"	<bewareOf: #fieldListChanged>	^self propertyValueAt: #fieldList! !!CTileInspector methodsFor: 'accessing' stamp: 'ar 3/19/2004 15:18'!fieldList: aValue	"Modify the receiver's fieldList"	^self propertyValueAt: #fieldList put: aValue with: #fieldListChanged! !!CTileInspector methodsFor: 'accessing' stamp: 'ar 3/19/2004 15:17'!target	"Answer the target of the receiver"	<bewareOf: #targetChanged>	^self propertyValueAt: #target! !!CTileInspector methodsFor: 'accessing' stamp: 'ar 3/19/2004 15:17'!target: aValue	"Modify the receiver's target"	^self propertyValueAt: #target put: aValue with: #targetChanged! !!CTileInspector methodsFor: 'events' stamp: 'ar 3/19/2004 19:53'!onCategoryChanged	<on: categoryChanged>	self updateFieldList.! !!CTileInspector methodsFor: 'events' stamp: 'ar 3/19/2004 19:51'!onTargetChanged	<on: targetChanged>	self updateFieldList.! !!CTileInspector methodsFor: 'updating' stamp: 'ar 3/19/2004 19:55'!updateFieldList	"Update my field list"	| newFields |	target ifNil:[^fieldList removeAll].	newFields := target definedFields 		select:[:aField| self shouldShowField: aField].	fieldList elements contents: (newFields collect:[:aField| target fieldNamed: aField name]).! !!CTileInspector methodsFor: 'private' stamp: 'ar 3/19/2004 18:16'!messageTileFor: aSelector in: aClass	"Answer a message tile for the given selector in our target"	| source argNames msgTile varTile |	source := aClass sourceCodeAt: aSelector.	argNames := aClass parserClass new parseArgs: source notifying: nil.	msgTile := CMessageTile new.	msgTile receiver: (CValueTile on: target).	msgTile selector: aSelector.	msgTile arguments: CCollection new.	argNames do:[:each|		varTile := CVariableTile new.		varTile name: each.		msgTile arguments add: varTile.	].	^msgTile! !!CTileInspector methodsFor: 'private' stamp: 'ar 3/21/2004 02:16'!shouldShowField: aField	"Answer whether we want to show the given field"	aField isPrivateField ifTrue:[^false].	category ifNil:[^true].	^(aField category ifNil:[#'user fields']) = category! !!CTileLibrary methodsFor: 'defaults' stamp: 'ar 3/7/2004 23:26'!argumentTileCostume	^CVariableTileCostume! !!CTileLibrary methodsFor: 'defaults' stamp: 'ar 3/22/2004 16:21'!messageTileCostume	^CMessageTileCostume! !!CTileLibrary methodsFor: 'defaults' stamp: 'ar 3/22/2004 16:21'!operatorTileCostume	^COperatorTileCostume! !!CTileLibrary methodsFor: 'defaults' stamp: 'ar 3/8/2004 21:47'!scriptorTileCostume	^CScriptorTileCostume! !!CTileLibrary methodsFor: 'defaults' stamp: 'ar 3/8/2004 21:07'!sequenceTileCostume	^CSequenceTileCostume! !!CTileLibrary methodsFor: 'defaults' stamp: 'ar 3/22/2004 23:43'!tileFont	^TextStyle defaultFont	"^(TextStyle named: 'ComicBold') fontOfSize: 16."! !!CTileLibrary methodsFor: 'value tiles' stamp: 'ar 4/3/2004 14:16'!valueTileForType: aType	(aType includesBehavior: CStringType) ifTrue:[^CStringTileCostume].	(aType includesBehavior: CNumberType) ifTrue:[^CNumberTileCostume].	(aType includesBehavior: CEnumType) ifTrue:[^CEnumListCostume].	(aType includesBehavior: CColorType) ifTrue:[^CColorTileCostume].	(aType includesBehavior: CImageResourceType) ifTrue:[^CImageResourceTileCostume].	^CValueTileCostume! !!CTilePlayer methodsFor: 'accessing' stamp: 'ar 3/22/2004 15:25'!definition	"Answer the definition of the receiver"	<bewareOf: #definitionChanged>	^self propertyValueAt: #definition! !!CTilePlayer methodsFor: 'accessing' stamp: 'ar 3/22/2004 15:25'!definition: aValue	"Modify the receiver's definition"	^self propertyValueAt: #definition put: aValue with: #definitionChanged! !!CTilePlayer methodsFor: 'accessing' stamp: 'ar 3/28/2004 16:04'!fieldName	"If the receiver represents an updating field, answer its name"	^nil! !!CTilePlayer methodsFor: 'accessing' stamp: 'ar 3/17/2004 15:15'!valueType	"This method was automatically generated"	<bewareOf: #valueTypeChanged>	^self propertyValueAt: #valueType! !!CTilePlayer methodsFor: 'accessing' stamp: 'ar 3/11/2004 14:27'!valueType: aValue	"This method was automatically generated"	^self propertyValueAt: #valueType put: aValue with: #valueTypeChanged! !!CTilePlayer methodsFor: 'testing' stamp: 'ar 3/7/2004 21:05'!isArgumentTile	^false! !!CTilePlayer methodsFor: 'testing' stamp: 'ar 3/22/2004 18:11'!isComplex	"Am I a complex expression which needs parenthesis?"	^false! !!CTilePlayer methodsFor: 'testing' stamp: 'ar 3/7/2004 18:52'!isMessageTile	^false! !!CTilePlayer methodsFor: 'testing' stamp: 'ar 3/7/2004 18:52'!isPropertyTile	^false! !!CTilePlayer methodsFor: 'testing' stamp: 'ar 3/22/2004 17:48'!isStatementLike	^false! !!CTilePlayer methodsFor: 'testing' stamp: 'ar 3/8/2004 00:02'!isTilePlayer	^true! !!CTilePlayer methodsFor: 'testing' stamp: 'ar 3/7/2004 18:52'!isValueTile	^false! !!CTilePlayer methodsFor: 'converting' stamp: 'ar 3/19/2004 18:02'!asArgument	^(CVariableTile new) expression: self; yourself! !!CTilePlayer methodsFor: 'evaluating' stamp: 'ar 3/7/2004 19:53'!eval	"Evaluate the receiver"	^self value! !!CMessageTile methodsFor: 'initialize' stamp: 'ar 3/7/2004 21:39'!defaultCostume	^CTileLibrary default messageTileCostume! !!CMessageTile methodsFor: 'initialize' stamp: 'ar 3/21/2004 18:22'!initialize	super initialize.	"self makeForwardBy."! !!CMessageTile methodsFor: 'initialize' stamp: 'ar 3/8/2004 00:15'!make3plus4	| arg1 |	self receiver: (CValueTile on: 3).	self selector: #+.	self arguments: CCollection new.	self arguments add: (arg1 := (CValueTile on: 4) asArgument).	arg1 valueType: Number.	self valueType: Number.! !!CMessageTile methodsFor: 'initialize' stamp: 'ar 3/8/2004 00:14'!makeAddTo	| arg1 arg2 |	self receiver: (CValueTile on: self).	self selector: #add:to:.	self arguments: CCollection new.	self arguments add: (arg1 := (CValueTile on: 3) asArgument).	arg1 valueType: Number.	self arguments add: (arg2 := (CValueTile on: 4) asArgument).	arg2 valueType: Number.	self valueType: Number.! !!CMessageTile methodsFor: 'initialize' stamp: 'ar 3/21/2004 16:07'!makeForwardBy	| arg1 |	self receiver: (CValueTile on: nil).	self selector: #forwardBy:.	self arguments: CCollection new.	self arguments add: (arg1 := (CValueTile on: 3) asArgument).	arg1 valueType: Number.! !!CMessageTile methodsFor: 'accessing' stamp: 'ar 3/17/2004 15:11'!arguments	"This method was automatically generated"	<bewareOf: #argumentsChanged>	^self propertyValueAt: #arguments! !!CMessageTile methodsFor: 'accessing' stamp: 'ar 3/11/2004 14:23'!arguments: aValue	"This method was automatically generated"	^self propertyValueAt: #arguments put: aValue with: #argumentsChanged! !!CMessageTile methodsFor: 'accessing' stamp: 'ar 3/17/2004 15:11'!receiver	"This method was automatically generated"	<bewareOf: #receiverChanged>	^self propertyValueAt: #receiver! !!CMessageTile methodsFor: 'accessing' stamp: 'ar 3/11/2004 14:23'!receiver: aValue	"This method was automatically generated"	^self propertyValueAt: #receiver put: aValue with: #receiverChanged! !!CMessageTile methodsFor: 'accessing' stamp: 'ar 3/17/2004 15:11'!selector	"This method was automatically generated"	<bewareOf: #selectorChanged>	^self propertyValueAt: #selector! !!CMessageTile methodsFor: 'accessing' stamp: 'ar 3/11/2004 14:23'!selector: aValue	"This method was automatically generated"	^self propertyValueAt: #selector put: aValue with: #selectorChanged! !!CMessageTile methodsFor: 'testing' stamp: 'ar 3/22/2004 18:15'!isComplex	"Am I a complex expression which needs parenthesis?"	^arguments size > 0! !!CMessageTile methodsFor: 'testing' stamp: 'ar 3/7/2004 18:53'!isMessageTile	^true! !!CMessageTile methodsFor: 'testing' stamp: 'ar 3/22/2004 17:48'!isStatementLike	^self valueType == nil! !!CMessageTile methodsFor: 'evaluating' stamp: 'ar 3/22/2004 21:14'!eval	"Evaluate the receiver"	^(self receiver)		perform: self selector		withArguments: (self arguments asArray collect:[:each| each eval])! !!CMessageTile methodsFor: 'private' stamp: 'ar 3/7/2004 19:55'!add: arg1 to: arg2	^arg1 + arg2! !!COperatorTile methodsFor: 'initialize' stamp: 'ar 3/22/2004 16:04'!defaultCostume	^CTileLibrary default operatorTileCostume! !!COperatorTile methodsFor: 'testing' stamp: 'ar 3/22/2004 18:12'!isComplex	"Am I a complex expression which needs parenthesis?"	^true! !!COperatorTile methodsFor: 'evaluating' stamp: 'ar 3/22/2004 21:16'!eval	^self arguments first eval perform: selector with: self arguments last eval! !!CPropertyTile methodsFor: 'initialize' stamp: 'ar 3/21/2004 18:17'!defaultCostume	^CPropertyTileCostume! !!CPropertyTile methodsFor: 'accessing' stamp: 'ar 3/28/2004 16:04'!fieldName	"If the receiver represents an updating field, answer its name"	^property! !!CPropertyTile methodsFor: 'accessing' stamp: 'ar 3/17/2004 15:13'!property	"This method was automatically generated"	<bewareOf: #propertyChanged>	^self propertyValueAt: #property! !!CPropertyTile methodsFor: 'accessing' stamp: 'ar 3/11/2004 14:24'!property: aValue	"This method was automatically generated"	^self propertyValueAt: #property put: aValue with: #propertyChanged! !!CPropertyTile methodsFor: 'accessing' stamp: 'ar 3/17/2004 15:13'!receiver	"This method was automatically generated"	<bewareOf: #receiverChanged>	^self propertyValueAt: #receiver! !!CPropertyTile methodsFor: 'accessing' stamp: 'ar 3/11/2004 14:24'!receiver: aValue	"This method was automatically generated"	^self propertyValueAt: #receiver put: aValue with: #receiverChanged! !!CPropertyTile methodsFor: 'testing' stamp: 'ar 3/7/2004 18:53'!isPropertyTile	^true! !!CPropertyTile methodsFor: 'evaluating' stamp: 'ar 3/22/2004 21:18'!eval	^self receiver get: property! !!CSequenceTile methodsFor: 'initialize' stamp: 'ar 3/8/2004 21:07'!defaultCostume	^CTileLibrary default sequenceTileCostume! !!CSequenceTile methodsFor: 'initialize' stamp: 'ar 3/8/2004 20:51'!initialize	super initialize.	self statements: CCollection new.! !!CSequenceTile methodsFor: 'accessing' stamp: 'ar 3/17/2004 15:14'!statements	"This method was automatically generated"	<bewareOf: #statementsChanged>	^self propertyValueAt: #statements! !!CSequenceTile methodsFor: 'accessing' stamp: 'ar 3/11/2004 14:25'!statements: aValue	"This method was automatically generated"	^self propertyValueAt: #statements put: aValue with: #statementsChanged! !!CSequenceTile methodsFor: 'evaluating' stamp: 'ar 3/8/2004 21:45'!eval	"Evaluate the receiver"	| result |	result := nil.	self statements do:[:each| result := each eval].	^result! !!CScriptorTile methodsFor: 'initialize' stamp: 'ar 3/8/2004 21:46'!defaultCostume	^CTileLibrary default scriptorTileCostume! !!CScriptorTile methodsFor: 'initialize' stamp: 'ar 3/8/2004 23:36'!initialize	super initialize.	self receiver: self. "for testing..."	self selector: #foo.	self statements add: (CMessageTile new makeForwardBy).	self statements add: (CMessageTile new make3plus4).	self statements add: (CMessageTile new makeAddTo).! !!CScriptorTile methodsFor: 'accessing' stamp: 'ar 3/17/2004 15:13'!receiver	"This method was automatically generated"	<bewareOf: #receiverChanged>	^self propertyValueAt: #receiver! !!CScriptorTile methodsFor: 'accessing' stamp: 'ar 3/11/2004 14:25'!receiver: aValue	"This method was automatically generated"	^self propertyValueAt: #receiver put: aValue with: #receiverChanged! !!CScriptorTile methodsFor: 'accessing' stamp: 'ar 3/17/2004 15:13'!selector	"This method was automatically generated"	<bewareOf: #selectorChanged>	^self propertyValueAt: #selector! !!CScriptorTile methodsFor: 'accessing' stamp: 'ar 3/11/2004 14:25'!selector: aValue	"This method was automatically generated"	^self propertyValueAt: #selector put: aValue with: #selectorChanged! !!CScriptorTile methodsFor: 'accessing' stamp: 'ar 3/17/2004 15:13'!trigger	"This method was automatically generated"	<bewareOf: #triggerChanged>	^self propertyValueAt: #trigger! !!CScriptorTile methodsFor: 'accessing' stamp: 'ar 3/11/2004 14:25'!trigger: aValue	"This method was automatically generated"	^self propertyValueAt: #trigger put: aValue with: #triggerChanged! !!CTileReadout methodsFor: 'initialize' stamp: 'ar 3/22/2004 14:41'!initialize	super initialize.	self define: #label as: CLabel new.	self define: #editor as: nil.! !!CTileReadout methodsFor: 'initialize' stamp: 'ar 4/30/2004 15:55'!setupCostume	super setupCostume.	self color: CWidgetLibrary default paneColor.	self borderStyle: #raised.	self borderWidth: 1.	self layout: CTableLayout new.	self layout listDirection: #leftToRight.	self hResizing: #spaceFill.	self vResizing: #rigid.	self height: 22.	label hResizing: #spaceFill.	label vResizing: #spaceFill.	label clipping: true.	label borderStyle: #simple.	label borderWidth: 1.	label borderColor: CWidgetLibrary default frameColor.	label textInset: 2; textEmphasis: 1.	self add: label.! !!CTileReadout methodsFor: 'accessing' stamp: 'ar 3/18/2004 13:47'!editor	"Answer the editor of the receiver"	<bewareOf: #editorChanged>	^self propertyValueAt: #editor! !!CTileReadout methodsFor: 'accessing' stamp: 'ar 3/18/2004 13:47'!editor: aValue	"Modify the receiver's editor"	^self propertyValueAt: #editor put: aValue with: #editorChanged! !!CTileReadout methodsFor: 'accessing' stamp: 'ar 3/18/2004 14:11'!field	"Answer the field of the receiver"	<bewareOf: #fieldChanged>	^self propertyValueAt: #field! !!CTileReadout methodsFor: 'accessing' stamp: 'ar 3/18/2004 14:11'!field: aValue	"Modify the receiver's field"	^self propertyValueAt: #field put: aValue with: #fieldChanged! !!CTileReadout methodsFor: 'accessing' stamp: 'ar 3/19/2004 15:59'!fieldType	"Answer the fieldType of the receiver"	<bewareOf: #fieldTypeChanged>	^self propertyValueAt: #fieldType! !!CTileReadout methodsFor: 'accessing' stamp: 'ar 3/19/2004 15:59'!fieldType: aValue	"Modify the receiver's fieldType"	^self propertyValueAt: #fieldType put: aValue with: #fieldTypeChanged! !!CTileReadout methodsFor: 'accessing' stamp: 'ar 3/18/2004 13:46'!label	"Answer the label of the receiver"	<bewareOf: #labelChanged>	^self propertyValueAt: #label! !!CTileReadout methodsFor: 'accessing' stamp: 'ar 3/18/2004 13:46'!label: aValue	"Modify the receiver's label"	^self propertyValueAt: #label put: aValue with: #labelChanged! !!CTileReadout methodsFor: 'events' stamp: 'ar 3/19/2004 16:02'!onValueChanged		| newType |	<on: valueChanged>	value ifNotNil:[label value: value fieldName].	newType := value valueType.	newType == fieldType ifFalse:[self installFieldType: newType].	editor player: value.! !!CTileReadout methodsFor: 'events' stamp: 'ar 3/18/2004 15:03'!printValue: aValue	^aValue displayText! !!CTileReadout methodsFor: 'events' stamp: 'ar 3/26/2004 15:51'!readValue: aString	^CCompiler evaluate: aString asString! !!CTileReadout methodsFor: 'private' stamp: 'ar 3/23/2004 12:54'!defaultEditor	| newEditor |	newEditor := CInputField new.	newEditor converter: self.	newEditor textInset: 2.	^newEditor! !!CTileReadout methodsFor: 'private' stamp: 'ar 3/25/2004 21:24'!editorForType: aType	| newEditor |	aType ifNil:[^self defaultEditor].	(aType includesBehavior: Boolean) ifTrue:[		newEditor := CDropDownList new.		newEditor add: true.		newEditor add: false.		^newEditor	].	(aType includesBehavior: Integer) ifTrue:[		newEditor := CSpinner new.		newEditor min: nil; max: nil.		newEditor label: nil.		^newEditor	].	(aType includesBehavior: String) ifTrue:[		newEditor := self defaultEditor.		newEditor converter: CStringConverter new.		^newEditor	].	(aType includesBehavior: Text) ifTrue:[		newEditor := self defaultEditor.		newEditor converter: nil.		^newEditor	].	(aType includesBehavior: Date) ifTrue:[		newEditor := self defaultEditor.		newEditor converter: CDateConverter new.		^newEditor	].	(aType includesBehavior: Number) ifTrue:[		newEditor := self defaultEditor.		newEditor converter: CNumberConverter new.		^newEditor	].	^self defaultEditor! !!CTileReadout methodsFor: 'private' stamp: 'ar 3/27/2004 21:15'!installFieldType: newType	| oldEditor newEditor |	self fieldType: newType.	oldEditor := editor.	newEditor := self editorForType: newType.	newEditor hResizing: #rigid; vResizing: #shrinkWrap.	newEditor width: 80.	oldEditor 		ifNil:[elements addLast: newEditor]		ifNotNil:[elements replace: oldEditor with: newEditor].	editor := newEditor.	oldEditor ifNotNil:[oldEditor destroy].! !!CTileViewer methodsFor: 'initialize' stamp: 'ar 3/22/2004 14:42'!initialize	super initialize.	self define: #header as: CViewerCategoryHeader new.	self define: #pages as: CCollection new.	pages wrapCursor: true.	self define: #holder as: CHolder new.! !!CTileViewer methodsFor: 'initialize' stamp: 'ar 4/30/2004 15:55'!setupCostume	super setupCostume.	color := CWidgetLibrary default paneColor.	self borderStyle: #simple.	self borderColor: CWidgetLibrary default frameColor.	self borderWidth: 1.	self roundCorners: true.	self layout: CTableLayout new.	self hResizing: #spaceFill; vResizing: #spaceFill.	self layout cellPositioning: #topLeft.	self layout layoutInset: 4; cellInset: 2.	self add: header.	holder layout: CTableLayout new.	holder hResizing: #spaceFill; vResizing: #spaceFill.	holder layout layoutInset: 4.	holder roundCorners: true.	holder borderWidth: 1; borderStyle: #simple.	holder borderColor: CWidgetLibrary default frameColor.	holder color: Color white.	self add: holder! !!CTileViewer methodsFor: 'accessing' stamp: 'ar 3/21/2004 17:59'!categories	"Answer the categories of the receiver"	^categoryList contents! !!CTileViewer methodsFor: 'accessing' stamp: 'ar 3/21/2004 17:59'!categories: aList	"Modify the receiver's categories"	categoryList contents: aList! !!CTileViewer methodsFor: 'accessing' stamp: 'ar 3/21/2004 17:59'!categoryList	"Answer the categoryList of the receiver"	<bewareOf: #categoryListChanged>	^self propertyValueAt: #categoryList! !!CTileViewer methodsFor: 'accessing' stamp: 'ar 3/21/2004 17:59'!categoryList: aValue	"Modify the receiver's categoryList"	^self propertyValueAt: #categoryList put: aValue with: #categoryListChanged! !!CTileViewer methodsFor: 'accessing' stamp: 'ar 3/21/2004 23:27'!header	"Answer the header of the receiver"	<bewareOf: #headerChanged>	^self propertyValueAt: #header! !!CTileViewer methodsFor: 'accessing' stamp: 'ar 3/21/2004 23:27'!header: aValue	"Modify the receiver's header"	^self propertyValueAt: #header put: aValue with: #headerChanged! !!CTileViewer methodsFor: 'accessing' stamp: 'ar 3/21/2004 23:28'!holder	"Answer the holder of the receiver"	<bewareOf: #holderChanged>	^self propertyValueAt: #holder! !!CTileViewer methodsFor: 'accessing' stamp: 'ar 3/21/2004 23:28'!holder: aValue	"Modify the receiver's holder"	^self propertyValueAt: #holder put: aValue with: #holderChanged! !!CTileViewer methodsFor: 'accessing' stamp: 'ar 3/21/2004 23:26'!pages	"Answer the pages of the receiver"	<bewareOf: #pagesChanged>	^self propertyValueAt: #pages! !!CTileViewer methodsFor: 'accessing' stamp: 'ar 3/21/2004 23:26'!pages: aValue	"Modify the receiver's pages"	^self propertyValueAt: #pages put: aValue with: #pagesChanged! !!CTileViewer methodsFor: 'adding' stamp: 'ar 3/21/2004 23:28'!addPage: aPage	pages add: aPage.! !!CTileViewer methodsFor: 'events' stamp: 'ar 4/2/2004 14:54'!onCursorChanged	| selected |	<on: cursorChanged in: pages>	holder removeAll.	selected := pages selection.	selected ifNil:[^self].	holder add: pages selection.	header label: selected name.! !!CTileViewer methodsFor: 'events' stamp: 'ar 3/21/2004 23:34'!onGotoNext	<on: gotoNext in: header>	pages next.! !!CTileViewer methodsFor: 'events' stamp: 'ar 3/21/2004 23:34'!onGotoPrev	<on: gotoPrev in: header>	pages prev.! !!CTileViewer methodsFor: 'events' stamp: 'ar 3/21/2004 23:42'!onLabelHit	| result menu |	<on: mouseDown in: header>	menu := CMenu new.	menu chooseFrom: (pages collect:[:each| {each name. each}]) in: menu.	menu width: header width.	menu openAt: (header localToGlobal: 0@header height).	result := menu run.	result ifNotNil:[pages selection: result].! !!CTileViewerPage methodsFor: 'initialize' stamp: 'ar 4/30/2004 15:55'!setupCostume	super setupCostume.	self layout: CTableLayout new.	self hResizing: #spaceFill; vResizing: #spaceFill.	self layout cellPositioning: #topLeft.! !!CTileViewerPage methodsFor: 'adding' stamp: 'ar 3/22/2004 15:22'!contents: items	self removeAll.	self addAll: (items collect:[:each| (CViewerRow new) messageTile: each; yourself]).! !!CTreeItem methodsFor: 'initialize' stamp: 'ar 3/12/2004 19:18'!defaultCostume	^CTreeItemCostume! !!CTreeItem methodsFor: 'initialize' stamp: 'ar 3/12/2004 17:38'!initialize	super initialize.	expanded := false.	children := #().	indentation := 0.! !!CTreeItem methodsFor: 'templates' stamp: 'ar 3/13/2004 01:00'!getChildren	"Answer the (computed) children of this tree node"	^#()! !!CTreeItem methodsFor: 'templates' stamp: 'ar 3/14/2004 02:19'!getIcon	"Retrieve the icon for this item"	^nil! !!CTreeItem methodsFor: 'templates' stamp: 'ar 3/13/2004 00:57'!getLabel	"Answer the label to be used for this tree item"	^value displayText! !!CTreeItem methodsFor: 'templates' stamp: 'ar 3/13/2004 01:00'!hasChildren	"Answer true if this tree item has any children"	^self getChildren isEmpty not! !!CTreeItem methodsFor: 'accessing' stamp: 'ar 3/17/2004 15:15'!children	"This method was automatically generated"	<bewareOf: #childrenChanged>	^self propertyValueAt: #children! !!CTreeItem methodsFor: 'accessing' stamp: 'ar 3/12/2004 18:01'!children: aCollection	"This method was automatically generated"	self installChildren: aCollection.	^self propertyValueAt: #children put: aCollection with: #childrenChanged! !!CTreeItem methodsFor: 'accessing' stamp: 'ar 3/17/2004 15:15'!expanded	"This method was automatically generated"	<bewareOf: #expandedChanged>	^self propertyValueAt: #expanded! !!CTreeItem methodsFor: 'accessing' stamp: 'ar 3/11/2004 14:27'!expanded: aValue	"This method was automatically generated"	^self propertyValueAt: #expanded put: aValue with: #expandedChanged! !!CTreeItem methodsFor: 'accessing' stamp: 'ar 3/14/2004 02:19'!icon	"Answer the icon of the receiver"	<bewareOf: #iconChanged>	^self propertyValueAt: #icon! !!CTreeItem methodsFor: 'accessing' stamp: 'ar 3/14/2004 02:19'!icon: aValue	"Modify the receiver's icon"	^self propertyValueAt: #icon put: aValue with: #iconChanged! !!CTreeItem methodsFor: 'accessing' stamp: 'ar 3/12/2004 17:36'!indentation	"Answer the indentation of the receiver"	<bewareOf: #indentationChanged>	^self propertyValueAt: #indentation! !!CTreeItem methodsFor: 'accessing' stamp: 'ar 3/12/2004 17:36'!indentation: aValue	"Modify the receiver's indentation"	^self propertyValueAt: #indentation put: aValue with: #indentationChanged! !!CTreeItem methodsFor: 'accessing' stamp: 'ar 3/17/2004 15:15'!label	"This method was automatically generated"	<bewareOf: #labelChanged>	^self propertyValueAt: #label! !!CTreeItem methodsFor: 'accessing' stamp: 'ar 3/11/2004 14:27'!label: aValue	"This method was automatically generated"	^self propertyValueAt: #label put: aValue with: #labelChanged! !!CTreeItem methodsFor: 'accessing' stamp: 'ar 3/12/2004 17:35'!parent	"Answer the parent of the receiver"	<bewareOf: #parentChanged>	^self propertyValueAt: #parent! !!CTreeItem methodsFor: 'accessing' stamp: 'ar 3/12/2004 17:35'!parent: aValue	"Modify the receiver's parent"	^self propertyValueAt: #parent put: aValue with: #parentChanged! !!CTreeItem methodsFor: 'accessing' stamp: 'ar 3/17/2004 15:15'!tree	"This method was automatically generated"	<bewareOf: #treeChanged>	^self propertyValueAt: #tree! !!CTreeItem methodsFor: 'accessing' stamp: 'ar 3/11/2004 14:27'!tree: aValue	"This method was automatically generated"	^self propertyValueAt: #tree put: aValue with: #treeChanged! !!CTreeItem methodsFor: 'accessing' stamp: 'ar 3/9/2004 02:08'!value: newValue	"This is left as a reminder that *probably* we will want to have an update operation if a tree item's value changes. If so, this would be a good (and efficient) way to notify our tree to replace any old against new children."	self value == newValue ifTrue:[^newValue].	^super value: newValue.! !!CTreeItem methodsFor: 'expanding' stamp: 'ar 3/12/2004 18:11'!collapse	"collapse me"	expanded ifFalse:[^self].	expanded := false.	children := #().! !!CTreeItem methodsFor: 'expanding' stamp: 'ar 3/13/2004 03:00'!expand	"expand me"	expanded ifTrue:[^self].	expanded := true.	children := self getChildren.! !!CTreeItem methodsFor: 'events' stamp: 'ar 3/13/2004 03:29'!onValueChanged	| newLabel |	<on: valueChanged>	newLabel := self getLabel.	newLabel ifNotNil:[label := newLabel].! !!CTreeItem methodsFor: 'private' stamp: 'ar 3/12/2004 17:49'!anyChangedFrom: oldChildren to: newChildren	"Answer whether there may be any change from oldChildren to newChildren"	oldChildren size = newChildren size ifFalse:[^true]. "size differs"	1 to: oldChildren size do:[:i|		(oldChildren at: i) value == (newChildren at: i) ifFalse:[^true]. "child changed"	].	^false "no change"! !!CTreeItem methodsFor: 'private' stamp: 'ar 3/13/2004 00:39'!indexOfFirstOpenNode	^(tree indexOfTreeNode: self) + 1! !!CTreeItem methodsFor: 'private' stamp: 'ar 3/13/2004 00:39'!indexOfLastOpenNode	| lastNode |	lastNode := self.	[lastNode children size > 0] whileTrue:[		lastNode := lastNode children last.	].	^tree indexOfTreeNode: lastNode! !!CTreeItem methodsFor: 'private' stamp: 'ar 3/16/2004 14:40'!installChildren: newChildren	"Update my children after they have changed"	| firstIndex lastIndex |	"Avoid infinite recursion"	value == tree ifTrue:[^self].	tree ifNil:[^self].	"figure out the range of nodes affected"	(firstIndex := self indexOfFirstOpenNode) = 1 ifTrue:[		"either this is a root node or the node was removed"		(tree isRootNode: self) ifFalse:[^self]. "removed"	].	lastIndex := self indexOfLastOpenNode.	newChildren do:[:each|		each parent: self.		each tree: tree.		each indentation: indentation + 1.	].	(lastIndex - firstIndex + 1) = newChildren size		ifTrue:[tree replaceTreeNodesFrom: firstIndex to: lastIndex with: newChildren].	(lastIndex >= firstIndex)		ifTrue:[tree removeTreeNodesFrom: firstIndex to: lastIndex].	newChildren size = 0 		ifFalse:[tree addTreeNodes: newChildren at: firstIndex].! !!CTreeItem methodsFor: 'private' stamp: 'ar 3/15/2004 12:34'!printOn: aStream	super printOn: aStream.	aStream nextPut: $(; print: self label; nextPut:$).! !!CFileDirectoryTreeItem methodsFor: 'templates' stamp: 'ar 3/13/2004 03:03'!getChildren	^[value directories collect:[:each| each asTreeItem]] 		on: Error do:[:ex| CDialog abortRetryDebug: ex].! !!CFileDirectoryTreeItem methodsFor: 'templates' stamp: 'ar 3/15/2004 12:23'!getIcon	"Retrieve the icon for this entry"	^nil! !!CFileDirectoryTreeItem methodsFor: 'templates' stamp: 'ar 3/13/2004 00:59'!getLabel	^value localName! !!CFileDirectoryTreeItem methodsFor: 'templates' stamp: 'ar 3/13/2004 00:59'!hasChildren	^value hasSubDirectories! !!CServerDirectoryTreeItem methodsFor: 'templates' stamp: 'ar 3/13/2004 03:01'!getChildren	| list |	^[Cursor wait showWhile:[		list := value directoryNames.		list collect:[:each| self class on: (value directoryNamed: each)]	]] on: Error do:[:ex| CDialog abortRetryDebug: ex].! !!CServerDirectoryTreeItem methodsFor: 'templates' stamp: 'ar 3/13/2004 01:30'!getLabel	^ServerDirectory servers keyAtIdentityValue: value ifAbsent:[value localName]! !!CServerDirectoryTreeItem methodsFor: 'templates' stamp: 'ar 3/13/2004 01:14'!hasChildren	"We don't really want to query the server unless we have to"	^true! !!CTreeItemCostume methodsFor: 'initialize' stamp: 'ar 3/13/2004 01:40'!defaultColor	^Color transparent! !!CTreeItemCostume methodsFor: 'initialize' stamp: 'ar 3/12/2004 19:14'!defaultPlayer	^CTreeItem! !!CTreeItemCostume methodsFor: 'initialize' stamp: 'ar 3/17/2004 03:15'!initialize	super initialize.	self define: #label as: CLabel new.	self define: #marker as: CPlayer new.! !!CTreeItemCostume methodsFor: 'initialize' stamp: 'ar 4/30/2004 15:56'!setupCostume	super setupCostume.	self layout: CTableLayout new.	self layout listDirection: #leftToRight.	self hResizing: #spaceFill; vResizing: #shrinkWrap.	self clipping: true.	marker extent: self markerExtent.	marker textFont: (TextStyle named: 'WindowFont') defaultFont.	self add: marker.	label hResizing: #spaceFill.	label clipping: true.	self add: label.! !!CTreeItemCostume methodsFor: 'accessing' stamp: 'ar 3/12/2004 14:11'!label	"Answer the label of the receiver"	<bewareOf: #labelChanged>	^self propertyValueAt: #label! !!CTreeItemCostume methodsFor: 'accessing' stamp: 'ar 3/11/2004 20:33'!label: aValue	"Modify the receiver's label"	^self propertyValueAt: #label put: aValue with: #labelChanged! !!CTreeItemCostume methodsFor: 'accessing' stamp: 'ar 3/12/2004 14:11'!marker	"Answer the marker of the receiver"	<bewareOf: #markerChanged>	^self propertyValueAt: #marker! !!CTreeItemCostume methodsFor: 'accessing' stamp: 'ar 3/11/2004 20:33'!marker: aValue	"Modify the receiver's marker"	^self propertyValueAt: #marker put: aValue with: #markerChanged! !!CTreeItemCostume methodsFor: 'accessing' stamp: 'ar 3/12/2004 19:24'!markerExtent	^12@16! !!CTreeItemCostume methodsFor: 'selecting' stamp: 'ar 3/9/2004 01:25'!deselect	color := Color transparent.	label textColor: Color black! !!CTreeItemCostume methodsFor: 'selecting' stamp: 'ar 3/12/2004 19:24'!onExpand	<on: mouseDown in: marker>	player expanded ifTrue:[player collapse] ifFalse:[player expand].! !!CTreeItemCostume methodsFor: 'selecting' stamp: 'ar 3/12/2004 19:18'!onExpandedChanged	<on: expandedChanged in: player>	player hasChildren ifFalse:[^marker text:''].	player expanded 		ifTrue:[marker text: 'd']		ifFalse:[marker text: 'r'].! !!CTreeItemCostume methodsFor: 'selecting' stamp: 'ar 3/24/2004 02:14'!onIndentationChanged	<on: indentationChanged in: player>	self layout layoutInset: (player indentation @ 0 * self markerExtent corner: 0@0).! !!CTreeItemCostume methodsFor: 'selecting' stamp: 'ar 3/12/2004 19:18'!onLabelChanged	<on: labelChanged in: player>	label value: player label.! !!CTreeItemCostume methodsFor: 'selecting' stamp: 'ar 3/12/2004 19:15'!onPlayerChanged	super onPlayerChanged.	self onLabelChanged.	self onExpandedChanged.	self onIndentationChanged.! !!CTreeItemCostume methodsFor: 'selecting' stamp: 'ar 3/15/2004 00:15'!select	color := CWidgetLibrary default baseColor.	label textColor: Color white.! !!CTreeWidget methodsFor: 'initialize' stamp: 'ar 3/9/2004 02:31'!defaultCostume	^CWidgetLibrary default treeCostume! !!CTreeWidget methodsFor: 'initialize' stamp: 'ar 3/19/2004 13:25'!initialize	super initialize.	treeNodes := CCollection new.	allowDeselect := true.	hScrollable := false.! !!CTreeWidget methodsFor: 'accessing' stamp: 'ar 3/17/2004 15:16'!allowDeselect	"This method was automatically generated"	<bewareOf: #allowDeselectChanged>	^self propertyValueAt: #allowDeselect! !!CTreeWidget methodsFor: 'accessing' stamp: 'ar 3/11/2004 14:27'!allowDeselect: aValue	"This method was automatically generated"	^self propertyValueAt: #allowDeselect put: aValue with: #allowDeselectChanged! !!CTreeWidget methodsFor: 'accessing' stamp: 'ar 3/13/2004 01:11'!root	^self rootNode value! !!CTreeWidget methodsFor: 'accessing' stamp: 'ar 3/13/2004 01:11'!root: anObject	^self rootNode: anObject asTreeItem! !!CTreeWidget methodsFor: 'accessing' stamp: 'ar 3/13/2004 01:02'!rootNode	^self rootNodes anyOne! !!CTreeWidget methodsFor: 'accessing' stamp: 'ar 3/13/2004 01:02'!rootNode: aNode	self rootNodes: (Array with: aNode)! !!CTreeWidget methodsFor: 'accessing' stamp: 'ar 3/13/2004 00:51'!rootNodes	"Answer the rootNodes of the receiver"	<bewareOf: #rootNodesChanged>	^self propertyValueAt: #rootNodes! !!CTreeWidget methodsFor: 'accessing' stamp: 'bf 3/30/2004 14:02'!rootNodes: aValue	"Modify the receiver's rootNodes"	self propertyValueAt: #rootNodes put: aValue with: #rootNodesChanged.	self onRootNodesChanged.	^aValue! !!CTreeWidget methodsFor: 'accessing' stamp: 'ar 3/13/2004 01:10'!roots	^self rootNodes collect:[:each| each value]! !!CTreeWidget methodsFor: 'accessing' stamp: 'ar 3/13/2004 01:10'!roots: aCollection	self rootNodes: (aCollection collect:[:each| each asTreeItem]).! !!CTreeWidget methodsFor: 'events' stamp: 'ar 3/16/2004 14:40'!onRootNodesChanged	| selected |	selected := self selection.	treeNodes removeAll.	elements removeAll.	rootNodes do:[:each| each tree: self].	self addTreeNodes: rootNodes at: 1.	self selection: selected.! !!CTreeWidget methodsFor: 'operations' stamp: 'ar 3/27/2004 19:32'!expandPath: aCollection	"aCollection describes a 'path' to one of the receiver's nodes. 	Expand the receiver along this path."	| node item pathIndex rootIndex |	pathIndex := aCollection findFirstIndex:[:any| 		rootIndex := self roots indexOf: any.		rootIndex > 0].	pathIndex = 0 ifTrue:[^self]. "not in our list"	node := self rootNodes at: rootIndex.	pathIndex+1 to: aCollection size do:[:i|		node expanded ifFalse:[node expand].		item := aCollection at: i.		node := node children detect:[:any| any value = item] ifNone:[nil].		node ifNil:[^self].	].! !!CTreeWidget methodsFor: 'private-tree' stamp: 'ar 3/16/2004 14:40'!addTreeNodes: newChildren at: firstIndex	treeNodes addAll: newChildren at: firstIndex.	elements addAll: (newChildren collect:[:each| each value]) at: firstIndex.! !!CTreeWidget methodsFor: 'private-tree' stamp: 'ar 3/13/2004 00:44'!indexOfTreeNode: aNode	^treeNodes indexOf: aNode! !!CTreeWidget methodsFor: 'private-tree' stamp: 'ar 3/13/2004 00:54'!isRootNode: aNode	"Is aNode one of our roots?"	^false! !!CTreeWidget methodsFor: 'private-tree' stamp: 'ar 3/13/2004 13:09'!removeTreeNodesFrom: firstIndex to: lastIndex	treeNodes removeFrom: firstIndex to: lastIndex.	elements removeFrom: firstIndex to: lastIndex.! !!CTreeWidget methodsFor: 'private-tree' stamp: 'ar 3/13/2004 13:09'!replaceTreeNodesFrom: firstIndex to: lastIndex with: nodeList	treeNodes replaceFrom: firstIndex to: lastIndex with: nodeList.	elements replaceFrom: firstIndex to: lastIndex with: (nodeList collect:[:each| each value]).! !!CTreeWidget methodsFor: 'private-tree' stamp: 'ar 3/13/2004 00:42'!treeNodes	"Answer the treeNodes of the receiver"	<bewareOf: #treeNodesChanged>	^self propertyValueAt: #treeNodes! !!CTreeWidget methodsFor: 'private-tree' stamp: 'ar 3/13/2004 00:42'!treeNodes: aValue	"Modify the receiver's treeNodes"	^self propertyValueAt: #treeNodes put: aValue with: #treeNodesChanged! !!CTweakDeserializer methodsFor: 'reading' stamp: 'ar 2/27/2004 18:28'!readContentsOf: anObject	^anObject readTweakedFieldsFrom: self! !!CTweakDeserializer methodsFor: 'reading' stamp: 'ar 2/27/2004 19:36'!tweakField: fieldName value: oldValue	| field pos fieldSymbol |	fieldSymbol := fieldName isString ifTrue:[fieldName asSymbol] ifFalse:[fieldName].	(field := contents next) ifNil:[^oldValue].	field key == fieldSymbol ifTrue:[^self tweakValue: oldValue from: field value].	pos := contents position.	[(field := contents next) == nil] whileFalse:[		field key == fieldSymbol ifTrue:[			contents originalContents swap: pos with: contents position.			contents position: pos.			^self tweakValue: oldValue from: field value		].	].	contents position: pos-1.	^oldValue! !!CTweakDeserializer methodsFor: 'reading' stamp: 'ar 2/27/2004 19:39'!tweakValue: oldValue from: partData	"Read (and update) oldValue based on partData"	partData isMakerPart ifFalse:[^partData].	^partData tweak: oldValue in: objectMaker! !!CTweakMaker methodsFor: 'private-defaults' stamp: 'ar 2/27/2004 18:45'!makeNewPart: partMaker	^partMaker new! !!CTweakMaker methodsFor: 'private-defaults' stamp: 'ar 2/27/2004 18:45'!makerType	^'tweak'! !!CTweakMaker methodsFor: 'private-defaults' stamp: 'ar 2/27/2004 18:45'!newDeserializer	^CTweakDeserializer new! !!CTweakMaker methodsFor: 'private-defaults' stamp: 'ar 2/27/2004 18:45'!newSerializer	^CTweakSerializer new! !!CTweakMaker methodsFor: 'private-defaults' stamp: 'ar 2/27/2004 19:39'!tweakObjectPart: aPart	| reader |	reader := self newDeserializer.	reader objectMaker: self.	reader readObjectFrom: aPart.! !!CTweakMaker methodsFor: 'exporting' stamp: 'ar 2/27/2004 19:45'!tdlPrintString	^String streamContents:[:s|		parts do:[:pp| pp partID ifNotNil:[			pp tdlPrintOn: s indent: 0.			s nextPut:$.; cr; cr]]]! !!CTweakMaker methodsFor: 'exporting' stamp: 'ar 2/28/2004 20:38'!xmlPrintString	| writer |	writer := XMLWriterIndenting on: (String new writeStream).	parts do:[:pp| pp partID ifNotNil:[		pp exportXmlOn: writer.	]].	^writer stream contents! !!CTweakSerializer methodsFor: 'writing' stamp: 'ar 2/27/2004 18:25'!writeContentsOf: anObject	"Write the contents of the given object"	anObject writeTweakedFieldsOn: self! !!CTweakSerializer methodsFor: 'writing' stamp: 'ar 2/29/2004 19:43'!writeCostume: aCostume	^self writeOwned: aCostume home: aCostume player role: #costume! !!CTweakSerializer methodsFor: 'writing' stamp: 'ar 2/29/2004 01:11'!writeOwned: anObject home: aHome role: roleName	| part homePart binding |	(part := self lookupReference: anObject) 		ifNotNil:[^self writeReference: part].	homePart := self write: aHome.	"Note: we must check again for anObject as it most likely has been written via its model"	(part := self lookupReference: anObject) 		ifNotNil:[^self writeReference: part].	part := CTweakedPart new.	binding := CPartBinding new.	binding home: homePart.	binding key: roleName.	binding value: part.	partList nextPut: part.	part partMaker: anObject maker.	imports add: part partMaker.	self registerReference: part for: anObject.	self storeContents: part using:[		contents := (Array new: 10) writeStream.		self writeContentsOf: anObject.	].	^part! !!CTweakSerializer methodsFor: 'writing' stamp: 'ar 3/15/2004 20:44'!writeScripted: aPlayer	| owner binding baseName index newName part |	(part := self lookupReference: aPlayer) 		ifNotNil:[^self writeReference: part].	root == aPlayer ifTrue:[^self writeObject: aPlayer].	(binding := aPlayer componentBinding) ifNotNil:[		^self writeOwned: aPlayer home: binding home role: binding key.	].	(owner := aPlayer player) 		ifNotNil:[^self writeOwned: aPlayer home: owner role: #costume].	"If the player wasn't owned make it an implicit part of the root guy"	extraPartNames ifNil:[		extraPartNames := Set new.		extraPartNames addAll: root components keys	].	baseName := aPlayer name asString withFirstCharacterDownshifted.	index := 1.	[newName := baseName, index.	extraPartNames includes: newName] whileTrue:[index := index + 1].	extraPartNames add: newName.	Transcript cr; show: 'Warning: Creating implicit part ', newName,' (', aPlayer printString,')'.	^self writeOwned: aPlayer home: root role: newName asSymbol.! !!CTweakedPart methodsFor: 'exporting' stamp: 'ar 2/29/2004 01:15'!exportPartOn: xmlWriter key: aKey	xmlWriter startTag: aKey.	partID ifNotNil:[xmlWriter attribute: 'id' value: partID asString].	self exportMaker: partMaker on: xmlWriter.	xmlWriter attribute: 'home' value: partBinding home partID asString.	xmlWriter attribute: 'key' value: partBinding key asString.	xmlWriter endTag.	contents do:[:item| item value exportXmlOn: xmlWriter key: item key].	xmlWriter endTag: aKey.! !!CTweakedPart methodsFor: 'accessing' stamp: 'ar 2/29/2004 01:15'!partBinding	^partBinding! !!CTweakedPart methodsFor: 'accessing' stamp: 'ar 2/29/2004 01:15'!partBinding: aSite	partBinding := aSite! !!CTweakedPart methodsFor: '*Tweak-Tweaks' stamp: 'ar 3/15/2004 20:54'!tweak: oldValue in: aMaker	| owner |	value ifNotNil:[^value].partBinding home value ifNil:[self halt].	"@@@@@@@ Uuuuuuuhhhhhh - is this even remotely correct????? @@@@@@@@"	owner := partBinding home value.	value := owner componentNamed: partBinding key.	value ifNil:[^self valueInMaker: aMaker].	aMaker tweakObjectPart: self.	^value! !!CTweakedPart methodsFor: 'creating' stamp: 'ar 3/15/2004 20:53'!createPartIn: aMaker	| owner |	partBinding ifNil:[^super createPartIn: aMaker].	owner := partBinding home valueInMaker: aMaker.	value := owner componentNamed: partBinding key.	value maker == partMaker ifFalse:[		"we have changed this part"		value := aMaker makeNewPart: partMaker.		owner define: partBinding key as: value.		partBinding key == #costume ifTrue:[value player: owner].	].! !!CUserDialog methodsFor: 'initialize' stamp: 'ar 3/25/2004 20:04'!initialize	super initialize.	self define: #dialogLabel as: CLabel new.	self define: #messageText as: CInputField new.	self define: #buttonRow as: CPlayer new.! !!CUserDialog methodsFor: 'initialize' stamp: 'tk 7/14/2004 11:28'!setupCostume	| col |	super setupCostume.	self floating: true.	self color: Color white.	self dropShadowEnabled: true.	self borderWidth: 1.	self borderColor: CWidgetLibrary default frameColor.	self borderStyle: #simple.	self roundCorners: true.	self layout: CTableLayout new.	self hResizing: #shrinkWrap; vResizing: #shrinkWrap.	dialogLabel textEmphasis: 1.	dialogLabel fillStyle: #verticalGradient.	dialogLabel fillAlpha: 1.0.	dialogLabel fillColors: CWidgetLibrary default gradientColors.	dialogLabel layoutInset: 3.	dialogLabel roundCornerSpec: #(1 4).	self add: dialogLabel.	col := CPlayer new.	col layout: CTableLayout new.	col hResizing: #spaceFill; vResizing: #spaceFill.	col layout layoutInset: 13@5; cellInset: 0@7; cellPositioning: #topLeft.	messageText borderWidth: 1.	messageText borderColor: Color transparent.	messageText borderStyle: #simple.	messageText asPrimCostume minHeight: 21.	messageText textWrap: false.	col add: messageText.	buttonRow layout: CTableLayout new.	buttonRow hResizing: #spaceFill; vResizing: #shrinkWrap.	buttonRow layout listDirection: #leftToRight.	buttonRow layout cellInset: 4@0; listCentering: #center.	col add: buttonRow.	self add: col.! !!CUserDialog methodsFor: 'events' stamp: 'ar 3/13/2004 15:05'!onAccept	<on: accept in: messageText>	self value: true.	self close.! !!CUserDialog methodsFor: 'events' stamp: 'ar 3/13/2004 15:05'!onCancel	<on: cancel in: messageText>	self value: false.	self close.! !!CUserDialog methodsFor: 'events' stamp: 'ar 4/4/2004 16:59'!onOpen	<on: opened>	messageText allowEditing 		ifTrue:[hand keyboardFocus: messageText]		ifFalse:[hand keyboardFocus: self].! !!CUserDialog methodsFor: 'requests' stamp: 'ar 3/26/2004 01:31'!abortRetryDebug: anException label: labelString centerAt: aPoint	| result |	self costume. "XXX fixMe"	dialogLabel value: labelString.	messageText contents: anException description asText allBold.	messageText allowEditing: false.	messageText hResizing: #shrinkWrap; vResizing: #shrinkWrap.	"Error messages can be long so make button row stick to left edge"	buttonRow layout listCentering: #topLeft.	buttonRow removeAll.	self addButton: 'Abort' value: #abort.	self addButton: 'Retry' value: #retry.	self addButton: 'Debug' value: #debug.	result := self run: nil centerAt: aPoint.	result == #retry ifTrue:[^anException retry].	result == #debug ifTrue:[^anException debug].	^anException return	! !!CUserDialog methodsFor: 'requests' stamp: 'ar 3/21/2004 04:29'!confirm: aString label: labelString centerAt: aPoint	dialogLabel value: labelString.	buttonRow removeAll.	messageText contents: aString asText allBold.	messageText allowEditing: false.	messageText hResizing: #shrinkWrap; vResizing: #shrinkWrap.	self addButton: 'Yes' value: true.	self addButton: 'No' value: false.	self addButton: 'Cancel' value: nil.	^self run: nil centerAt: aPoint! !!CUserDialog methodsFor: 'requests' stamp: 'ar 3/21/2004 04:29'!inform: aString label: labelString centerAt: aPoint	dialogLabel value: labelString.	messageText contents: aString asText allBold.	messageText allowEditing: false.	messageText hResizing: #shrinkWrap; vResizing: #shrinkWrap.	buttonRow removeAll.	self addButton: 'OK' value: nil.	^self run: nil centerAt: aPoint! !!CUserDialog methodsFor: 'requests' stamp: 'ar 3/24/2004 01:08'!request: queryString initialAnswer: defaultAnswer centerAt: aPoint	"self request: 'Enter your name' initialAnswer: 'Joe Doe'"	dialogLabel value: queryString.	messageText onKeyDown: #(13) signal: #accept.	messageText onKeyDown: #(27) signal: #cancel.	messageText contents: (defaultAnswer ifNil:['']).	messageText hResizing: #spaceFill; vResizing: #spaceFill.	messageText borderColor: CWidgetLibrary default frameColor.	messageText selectAll.	buttonRow removeAll.	self addButton: 'OK' value: true.	self addButton: 'Cancel' value: false.	(self run: false centerAt: aPoint) ifFalse:[^nil].	^messageText contents asString! !!CUserDialog methodsFor: 'requests' stamp: 'ar 3/13/2004 15:15'!requestPassword: queryString centerAt: aPoint	"self requestPassword: 'Enter your name'"	messageText font: (StrikeFont passwordFontSize: 16).	^self request: queryString initialAnswer: '' centerAt: aPoint! !!CUserDialog methodsFor: 'construction' stamp: 'ar 4/2/2004 14:54'!addButton: labelString	| button |	button := CPushButton new.	button label: labelString.	button hResizing: #rigid; vResizing: #rigid.	button extent: 80@20.	button roundCorners: true.	button borderStyle: #simple.	button borderColor: CWidgetLibrary default frameColor.	buttonRow add: button.	^button! !!CUserDialog methodsFor: 'construction' stamp: 'ar 3/10/2004 00:50'!addButton: labelString value: aValue	| button |	button := self addButton: labelString.	self startScript: #endDialog: withArguments:{aValue} 		when:{button. #fire}.	^button! !!CUserDialog methodsFor: 'running' stamp: 'ar 3/10/2004 00:50'!endDialog: aValue	self value: aValue.	self close.! !!CUserDialog methodsFor: 'running' stamp: 'ar 3/10/2004 00:49'!run	^self run: nil.! !!CUserDialog methodsFor: 'running' stamp: 'ar 3/13/2004 15:16'!run: defaultValue	^self run: defaultValue centerAt: self hand position.! !!CUserDialog methodsFor: 'running' stamp: 'ar 4/4/2004 16:58'!run: defaultValue centerAt: aPoint	"Wait until this dialog is completed (ultimately by deleting my costume from the world)"	| oldFocus |	self value: defaultValue.	self openCenteredAt: (aPoint ifNil:[hand position]).	oldFocus := hand keyboardFocus.	self waitUntil: #closed.	hand keyboardFocus: oldFocus.	^self value "whatever it is"! !!CUserDialog methodsFor: 'accessing' stamp: 'ar 3/12/2004 14:12'!buttonRow	"Answer the buttonRow of the receiver"	<bewareOf: #buttonRowChanged>	^self propertyValueAt: #buttonRow! !!CUserDialog methodsFor: 'accessing' stamp: 'ar 3/11/2004 20:36'!buttonRow: aValue	"Modify the receiver's buttonRow"	^self propertyValueAt: #buttonRow put: aValue with: #buttonRowChanged! !!CUserDialog methodsFor: 'accessing' stamp: 'ar 3/12/2004 14:12'!dialogLabel	"Answer the dialogLabel of the receiver"	<bewareOf: #dialogLabelChanged>	^self propertyValueAt: #dialogLabel! !!CUserDialog methodsFor: 'accessing' stamp: 'ar 3/11/2004 20:35'!dialogLabel: aValue	"Modify the receiver's dialogLabel"	^self propertyValueAt: #dialogLabel put: aValue with: #dialogLabelChanged! !!CUserDialog methodsFor: 'accessing' stamp: 'ar 3/13/2004 02:49'!label	^dialogLabel value! !!CUserDialog methodsFor: 'accessing' stamp: 'ar 3/13/2004 02:49'!label: aString	dialogLabel value: aString! !!CUserDialog methodsFor: 'accessing' stamp: 'ar 3/13/2004 13:58'!message	^messageText value! !!CUserDialog methodsFor: 'accessing' stamp: 'ar 3/13/2004 13:58'!message: aString	messageText value: aString! !!CUserDialog methodsFor: 'accessing' stamp: 'ar 3/13/2004 13:54'!messageText	"Answer the messageText of the receiver"	<bewareOf: #messageTextChanged>	^self propertyValueAt: #messageText! !!CUserDialog methodsFor: 'accessing' stamp: 'ar 3/13/2004 13:54'!messageText: aValue	"Modify the receiver's messageText"	^self propertyValueAt: #messageText put: aValue with: #messageTextChanged! !!CListItem methodsFor: 'initialize' stamp: 'ar 4/30/2004 15:51'!setupCostume	super setupCostume.	self color: Color transparent.	self hResizing: #spaceFill.	self vResizing: #shrinkWrap.	self textEnabled: true.	self textAnchorPoint: #leftCenter.! !!CListItem methodsFor: 'selecting' stamp: 'ar 3/1/2004 17:18'!deselect	color := Color transparent.	self textColor: Color black! !!CListItem methodsFor: 'selecting' stamp: 'ar 3/15/2004 00:14'!select	color := CWidgetLibrary default baseColor.	self textColor: Color white.! !!CListItem methodsFor: 'events' stamp: 'ar 3/25/2004 12:07'!onValueChanged	<on: valueChanged>	self text: value displayText.! !!CMenuItemCostume methodsFor: 'initialize' stamp: 'ar 2/29/2004 22:26'!defaultPlayer	^nil! !!CMenuItemCostume methodsFor: 'initialize' stamp: 'ar 3/17/2004 03:13'!initialize	super initialize.	self define: #checkMarker as: CPlayer new.	self define: #itemLabel as: CLabel new.	self define: #subMenuMarker as: CPlayer new.! !!CMenuItemCostume methodsFor: 'initialize' stamp: 'ar 4/30/2004 15:58'!setupCostume	self clipping: false.	self add: checkMarker.	checkMarker extent: 11@15.	checkMarker hResizing: #rigid.	checkMarker text: ''.	checkMarker textFont: (TextStyle named: 'WindowFont') defaultFont.	self add: itemLabel.	itemLabel textInset: 3@0.	itemLabel clipping: false.	self add: subMenuMarker.	subMenuMarker extent: 11@13.	subMenuMarker hResizing: #rigid.	subMenuMarker text: ''.	subMenuMarker textFont: (TextStyle named: 'WindowFont') defaultFont.	self layout: CTableLayout new.	self layout listDirection: #leftToRight; layoutInset: 0@2.	self hResizing: #spaceFill; vResizing: #shrinkWrap.	self color: Color transparent.! !!CMenuItemCostume methodsFor: 'accessing' stamp: 'ar 2/29/2004 22:28'!action	^self value action! !!CMenuItemCostume methodsFor: 'accessing' stamp: 'ar 2/29/2004 22:28'!action: aMessage	self value action: aMessage! !!CMenuItemCostume methodsFor: 'accessing' stamp: 'ar 3/12/2004 16:27'!checkMarker	"Answer the checkMarker of the receiver"	<bewareOf: #checkMarkerChanged>	^self propertyValueAt: #checkMarker! !!CMenuItemCostume methodsFor: 'accessing' stamp: 'ar 3/12/2004 16:27'!checkMarker: aValue	"Modify the receiver's checkMarker"	^self propertyValueAt: #checkMarker put: aValue with: #checkMarkerChanged! !!CMenuItemCostume methodsFor: 'accessing' stamp: 'ar 2/29/2004 22:28'!checked	^self value checked! !!CMenuItemCostume methodsFor: 'accessing' stamp: 'ar 2/29/2004 22:28'!checked: aBool	self value checked: aBool! !!CMenuItemCostume methodsFor: 'accessing' stamp: 'ar 3/24/2004 15:38'!enabled	^value enabled! !!CMenuItemCostume methodsFor: 'accessing' stamp: 'bf 3/30/2004 11:26'!enabled: aBool	^self value enabled: aBool! !!CMenuItemCostume methodsFor: 'accessing' stamp: 'ar 3/13/2004 18:53'!isSeparator	^false! !!CMenuItemCostume methodsFor: 'accessing' stamp: 'ar 3/12/2004 16:28'!itemLabel	"Answer the itemLabel of the receiver"	<bewareOf: #itemLabelChanged>	^self propertyValueAt: #itemLabel! !!CMenuItemCostume methodsFor: 'accessing' stamp: 'ar 3/12/2004 16:28'!itemLabel: aValue	"Modify the receiver's itemLabel"	^self propertyValueAt: #itemLabel put: aValue with: #itemLabelChanged! !!CMenuItemCostume methodsFor: 'accessing' stamp: 'ar 2/29/2004 22:43'!label	^self value label! !!CMenuItemCostume methodsFor: 'accessing' stamp: 'ar 2/29/2004 22:43'!label: aString	self value label: aString! !!CMenuItemCostume methodsFor: 'accessing' stamp: 'ar 2/29/2004 22:28'!subMenu	^self value subMenu! !!CMenuItemCostume methodsFor: 'accessing' stamp: 'ar 2/29/2004 22:28'!subMenu: aMenu	self value subMenu: aMenu! !!CMenuItemCostume methodsFor: 'accessing' stamp: 'ar 3/12/2004 16:27'!subMenuMarker	"Answer the subMenuMarker of the receiver"	<bewareOf: #subMenuMarkerChanged>	^self propertyValueAt: #subMenuMarker! !!CMenuItemCostume methodsFor: 'accessing' stamp: 'ar 3/12/2004 16:27'!subMenuMarker: aValue	"Modify the receiver's subMenuMarker"	^self propertyValueAt: #subMenuMarker put: aValue with: #subMenuMarkerChanged! !!CMenuItemCostume methodsFor: 'events' stamp: 'ar 2/24/2004 01:48'!deselect	color := Color transparent.	self enabled ifTrue:[itemLabel textColor: Color black].! !!CMenuItemCostume methodsFor: 'events' stamp: 'ar 2/29/2004 22:27'!onCheckedChanged	<on: checkedChanged in: value>	checkMarker text: (self checked ifTrue:['V'] ifFalse:['']).! !!CMenuItemCostume methodsFor: 'events' stamp: 'ar 3/13/2004 21:07'!onEnabledChanged	<on: enabledChanged in: value>	self enabled		ifTrue:[itemLabel textColor: Color black]		ifFalse:[itemLabel textColor: Color lightGray].! !!CMenuItemCostume methodsFor: 'events' stamp: 'ar 3/13/2004 21:04'!onFire	<on: fire>	self action ifNil:[^self].	self action receiver 		startScript: self action selector 		withArguments: self action arguments.! !!CMenuItemCostume methodsFor: 'events' stamp: 'ar 3/17/2004 19:07'!onLabelChanged	<on: labelChanged in: value>	itemLabel value: value label.! !!CMenuItemCostume methodsFor: 'events' stamp: 'ar 2/29/2004 22:27'!onSubMenuChanged	<on: subMenuChanged in: value>	subMenuMarker text: (value subMenu ifNil:[''] ifNotNil:['s']).! !!CMenuItemCostume methodsFor: 'events' stamp: 'ar 3/17/2004 19:05'!onValueChanged	<on: valueChanged>	self onCheckedChanged.	self onEnabledChanged.	self onSubMenuChanged.	self onLabelChanged.! !!CMenuItemCostume methodsFor: 'events' stamp: 'ar 3/15/2004 00:05'!select	color := CWidgetLibrary default baseColor.	self enabled ifTrue:[itemLabel textColor: Color white].! !!CValueTile methodsFor: 'initialize' stamp: 'ar 3/7/2004 21:38'!defaultCostume	^CTileLibrary default valueTileForType: self valueType! !!CValueTile methodsFor: 'accessing' stamp: 'ar 3/7/2004 21:21'!valueType	^super valueType ifNil:["use the concrete type" self value class].! !!CValueTile methodsFor: 'testing' stamp: 'ar 3/7/2004 18:52'!isValueTile	^true! !!CValueTileCostume methodsFor: 'initialize' stamp: 'ar 3/7/2004 22:04'!defaultPlayer	^CValueTile! !!CValueTileCostume methodsFor: 'initialize' stamp: 'ar 4/30/2004 15:57'!setupCostume	super setupCostume.	self hResizing: #shrinkWrap.	self vResizing: #shrinkWrap.	self borderStyle: #simple.	self borderColor: CWidgetLibrary default frameColor.	self borderWidth: 1.	self roundCorners: true.	self color: Color white.	self layoutInset: 5@3.! !!CValueTileCostume methodsFor: 'events' stamp: 'ar 3/7/2004 19:06'!onPlayerChanged	super onPlayerChanged.	self onValueChanged.! !!CValueTileCostume methodsFor: 'events' stamp: 'ar 3/17/2004 17:34'!onValueChanged	<on: valueChanged>	self text: player value asText.! !!CVariableTile methodsFor: 'initialize' stamp: 'ar 3/7/2004 21:38'!defaultCostume	^CTileLibrary default argumentTileCostume! !!CVariableTile methodsFor: 'initialize' stamp: 'ar 3/19/2004 18:30'!initialize	super initialize.! !!CVariableTile methodsFor: 'accessing' stamp: 'ar 3/17/2004 15:02'!expression	"This method was automatically generated"	<bewareOf: #expressionChanged>	^self propertyValueAt: #expression! !!CVariableTile methodsFor: 'accessing' stamp: 'ar 3/11/2004 14:18'!expression: aValue	"This method was automatically generated"	^self propertyValueAt: #expression put: aValue with: #expressionChanged! !!CVariableTile methodsFor: 'testing' stamp: 'ar 3/7/2004 21:05'!isArgumentTile	^true! !!CVariableTile methodsFor: 'evaluating' stamp: 'ar 3/7/2004 21:07'!eval	^self expression eval! !!CVariableTileCostume methodsFor: 'initialize' stamp: 'ar 3/19/2004 18:02'!defaultPlayer	^CVariableTile! !!CVariableTileCostume methodsFor: 'initialize' stamp: 'ar 3/7/2004 23:11'!initialize	super initialize.	self dropEnabled: true.! !!CVariableTileCostume methodsFor: 'initialize' stamp: 'ar 4/30/2004 15:57'!setupCostume	super setupCostume.	self layout: CTableLayout new.	self layout listDirection: #leftToRight.	self hResizing: #spaceFill; vResizing: #shrinkWrap.! !!CVariableTileCostume methodsFor: 'accessing' stamp: 'ar 3/17/2004 15:16'!dropEnabled	"This method was automatically generated"	<bewareOf: #dropEnabledChanged>	^self propertyValueAt: #dropEnabled! !!CVariableTileCostume methodsFor: 'accessing' stamp: 'ar 3/11/2004 14:28'!dropEnabled: aValue	"This method was automatically generated"	^self propertyValueAt: #dropEnabled put: aValue with: #dropEnabledChanged! !!CVariableTileCostume methodsFor: 'events' stamp: 'ar 4/2/2004 14:54'!onExpressionChanged	| expr paren |	<on: expressionChanged in: player>	self removeAll.	expr := player expression.	expr ifNil:[		text := player name.	] ifNotNil:[		text := ''.		expr isComplex ifTrue:[			paren := CLabel new.			paren value: '('.			paren font: CTileLibrary default tileFont.			paren textEmphasis: 1.			self add: paren.		].		expr position: 0@0.		self add: expr.		expr isComplex ifTrue:[			paren := CLabel new.			paren value: ')'.			paren font: CTileLibrary default tileFont.			paren textEmphasis: 1.			self add: paren.		].	].! !!CVariableTileCostume methodsFor: 'events' stamp: 'ar 3/7/2004 21:11'!onPlayerChanged	super onPlayerChanged.	self onExpressionChanged.! !!CVariableTileCostume methodsFor: 'drag and drop' stamp: 'ar 3/19/2004 18:32'!onDragEnter	| newTile argType newType |	<on: dragEnter>	dropEnabled ifFalse:[^self].	newTile := self hand dropContents.	[newTile player == nil] whileFalse:[newTile := newTile player].	newTile isTilePlayer ifFalse:[^self].	"See if the types match"	newType := newTile valueType ifNil:[^nil]. "no type, no drop"	argType := player valueType.	argType ifNotNil:[		(argType canCoerceType: newType) ifFalse:[^nil].	].	(self runDropLoop: newTile) ifFalse:[^nil].	player expression: newTile.! !!CVariableTileCostume methodsFor: 'drag and drop' stamp: 'ar 3/30/2004 17:09'!onDragStart	"Handle a drag start - e.g., the user trying to drag something from this slot"	| expr dragTile |	<on: dragStart>	expr := player expression ifNil:[^self].	expr isValueTile ifTrue:[		"If it's just a simple value tile, hand the user its value"		dragTile := CValueTile on: expr eval.		dragTile valueType: expr valueType.	] ifFalse:[		"It's more complex than that. Hand the user the full expression and 		substitute the default value for the given type as the new expression."		dragTile := expr.		player valueType ifNil:[			player expression: nil.		] ifNotNil:[			expr := CValueTile on: player valueType defaultValue.			expr valueType: dragTile valueType.			player expression: expr.		].		dragTile signal: #tilePadDragged with: self.	].	hand attach: dragTile.	dragTile origin: self hand position + 4.! !!CVariableTileCostume methodsFor: 'drag and drop' stamp: 'ar 3/7/2004 23:15'!onDropEnabledChanged	<on: dropEnabledChanged>	dropEnabled 		ifTrue:[self resumeScript: #onDragEnter]		ifFalse:[self pauseScript: #onDragEnter]! !!CVariableTileCostume methodsFor: 'drag and drop' stamp: 'ar 3/30/2004 17:24'!runDropLoop: dragTile	"Run the feedback loop. This is somewhat complicated since we have to deal with pads which might be nested."	| oldFill evt |	[self containsPoint: self cursorPoint] whileTrue:[		"notify all interested parties"		"tilePadEntering: Allow a container to stop tracking the dragTile"		self tileSignal: #tilePadChildEnter.		"tilePadEnter: Allow the dragTile wants to make itself transparent"		dragTile signal: #tilePadEnter with: self.		"tilePadHighlight: Allow the expression tile to become transparent if needed"		(player expression ifNil:[player]) signal: #tilePadHighlight with: self.		"give drop feedback and wait for user to drop or to leave or to enter another tile pad"		oldFill := fill copy.		fill := Color green.		evt := self waitUntilAnyOf: {			self. #dragLeave.			self. #dragDrop.			player. #tilePadChildEnter.		}.		fill := oldFill.		"Notify the expression tile that the transaction is over"		(player expression ifNil:[player]) signal: #tilePadUnhighlight with: self.		evt selector == #dragDrop ifTrue:[			"Notify the dragTile that it is being dropped"			dragTile signal: #tilePadDropped with: self.			"Notify containers that I got a drop"			self tileSignal: #tilePadChildDrop.			^true "accept it"		].		evt selector == #tilePadChildEnter ifTrue:[			"we are entering a child tile pad"			evt := self waitUntilAnyOf: {				player. #tilePadChildLeave.				player. #tilePadChildDrop.			}.			(evt selector == #tilePadChildDrop) ifTrue:[^false]. "dropped on child"		].		(self containsPoint: self cursorPoint) ifFalse:[			"Notify dragTile about leaving me"			dragTile signal: #tilePadLeave with: self.			"Notify containers about dragTile leaving me"			self tileSignal: #tilePadChildLeave.			^false		].	].	^false! !!CVectorShape methodsFor: 'accessing' stamp: 'ar 6/9/2003 03:42'!bounds	^bounds! !!CVectorShape methodsFor: 'accessing' stamp: 'ar 6/9/2003 03:42'!bounds: newBounds	bounds := newBounds! !!CVectorShape methodsFor: 'accessing' stamp: 'ar 6/9/2003 03:34'!compressedShape	^compressedShape! !!CVectorShape methodsFor: 'accessing' stamp: 'ar 6/9/2003 03:34'!compressedShape: aShape	compressedShape := aShape.	bounds := aShape bounds.! !!CVectorShape methodsFor: 'drawing' stamp: 'ar 6/9/2003 03:55'!drawOn: aCanvas in: drawingBounds	aCanvas pushState.	aCanvas transformBy: (CMatrixTransform transformFromLocal: bounds toGlobal: drawingBounds).	aCanvas drawCompressedShape: compressedShape.	aCanvas popState.! !!CViewerCategoryHeader methodsFor: 'intialize' stamp: 'ar 3/22/2004 14:42'!initialize	super initialize.	self define: #prevArrow as: CPushButton new.	self define: #nextArrow as: CPushButton new.	self define: #categoryLabel as: CLabel new.! !!CViewerCategoryHeader methodsFor: 'intialize' stamp: 'ar 4/30/2004 15:57'!setupCostume	super setupCostume.	self layout: CTableLayout new.	self layout listDirection: #leftToRight.	self hResizing: #spaceFill; vResizing: #shrinkWrap.	self color: Color white.	self borderStyle: #simple.	self borderColor: CWidgetLibrary default frameColor.	self borderWidth: 1.	self extent: 1@1.	categoryLabel font: CTileLibrary default tileFont.	categoryLabel textAnchorPoint: #center.	{prevArrow. nextArrow} do:[:button|		button height: 5.		button textFont: (TextStyle named:'WindowFont') defaultFont.		button hResizing: #rigid; vResizing: #spaceFill; width: 16.	].	prevArrow text: 'l'.	nextArrow text: 'r'.	self add: prevArrow.	self add: categoryLabel.	self add: nextArrow.! !!CViewerCategoryHeader methodsFor: 'accessing' stamp: 'ar 3/21/2004 23:09'!categoryLabel	"Answer the categoryLabel of the receiver"	<bewareOf: #categoryLabelChanged>	^self propertyValueAt: #categoryLabel! !!CViewerCategoryHeader methodsFor: 'accessing' stamp: 'ar 3/21/2004 23:09'!categoryLabel: aValue	"Modify the receiver's categoryLabel"	^self propertyValueAt: #categoryLabel put: aValue with: #categoryLabelChanged! !!CViewerCategoryHeader methodsFor: 'accessing' stamp: 'ar 3/21/2004 23:38'!label	^categoryLabel value! !!CViewerCategoryHeader methodsFor: 'accessing' stamp: 'ar 3/21/2004 23:39'!label: aString	categoryLabel value: aString! !!CViewerCategoryHeader methodsFor: 'accessing' stamp: 'ar 3/21/2004 23:08'!nextArrow	"Answer the nextArrow of the receiver"	<bewareOf: #nextArrowChanged>	^self propertyValueAt: #nextArrow! !!CViewerCategoryHeader methodsFor: 'accessing' stamp: 'ar 3/21/2004 23:08'!nextArrow: aValue	"Modify the receiver's nextArrow"	^self propertyValueAt: #nextArrow put: aValue with: #nextArrowChanged! !!CViewerCategoryHeader methodsFor: 'accessing' stamp: 'ar 3/21/2004 23:08'!prevArrow	"Answer the prevArrow of the receiver"	<bewareOf: #prevArrowChanged>	^self propertyValueAt: #prevArrow! !!CViewerCategoryHeader methodsFor: 'accessing' stamp: 'ar 3/21/2004 23:08'!prevArrow: aValue	"Modify the receiver's prevArrow"	^self propertyValueAt: #prevArrow put: aValue with: #prevArrowChanged! !!CViewerCategoryHeader methodsFor: 'events' stamp: 'ar 3/21/2004 23:55'!onNextArrow	<on: fire in: nextArrow>	self signal: #gotoNext.! !!CViewerCategoryHeader methodsFor: 'events' stamp: 'ar 3/21/2004 23:55'!onPrevArrow	<on: fire in: prevArrow>	self signal: #gotoPrev.! !!CViewerDefinition methodsFor: 'initialize' stamp: 'ar 3/21/2004 17:05'!initialize	super initialize.	self define: #categories as: CCollection new.! !!CViewerDefinition methodsFor: 'accessing' stamp: 'ar 3/21/2004 17:03'!categories	"Answer the categories of the receiver"	<bewareOf: #categoriesChanged>	^self propertyValueAt: #categories! !!CViewerDefinition methodsFor: 'accessing' stamp: 'ar 3/21/2004 17:03'!categories: aValue	"Modify the receiver's categories"	^self propertyValueAt: #categories put: aValue with: #categoriesChanged! !!CViewerDefinition methodsFor: 'creating' stamp: 'ar 3/21/2004 23:38'!new	| tile |	tile := CTileViewer new.	tile name: externalName.	categories do:[:each| tile addPage: each new].	tile pages cursor: 1.	^tile! !!CViewerDefinition methodsFor: 'creating' stamp: 'ar 3/28/2004 22:33'!newFor: anObject	| tile |	tile := CTileViewer new.	tile name: externalName.	(categories 		select:[:page| page type == nil or:[anObject isKindOf: page type]])			do:[:each| tile addPage: (each newFor: anObject)].	tile pages cursor: 1.	^tile! !!CViewerDefinition methodsFor: 'printing' stamp: 'ar 3/21/2004 17:25'!printXmlOn: xmlWriter	xmlWriter startTag: 'viewer'.	selector ifNotNil:[xmlWriter attribute: 'selector' value: selector].	externalName ifNotNil:[xmlWriter attribute: 'name' value: externalName].	type ifNotNil:[xmlWriter attribute: 'type' value: type name].	helpText ifNotNil:[xmlWriter attribute: 'help' value: helpText].	xmlWriter endTag.	categories do:[:each| each printXmlOn: xmlWriter].	xmlWriter endTag: 'viewer'.! !!CViewerDefinition methodsFor: 'printing' stamp: 'ar 3/21/2004 17:04'!readXmlFrom: xmlNode	| attr |	xmlNode name == #viewer ifFalse:[^self error: 'Not a viewer'].	attr := xmlNode attributeAt: 'selector'.	attr ifNotNil:[selector := attr asSymbol].	attr := xmlNode attributeAt: 'name'.	attr ifNotNil:[externalName := attr].	attr := xmlNode attributeAt: 'type'.	attr ifNotNil:[type := self typeNamed: attr].	attr := xmlNode attributeAt: 'help'.	attr ifNotNil:[helpText := attr].	xmlNode elements do:[:each|		categories add: (CCategoryDefinition new readXmlFrom: each).	].	^self! !!CViewerRow methodsFor: 'initialize' stamp: 'ar 3/22/2004 21:20'!initialize	super initialize.	self define: #fireButton as: CLabel new.	self define: #spacer as: CPlayer new.! !!CViewerRow methodsFor: 'initialize' stamp: 'ar 4/30/2004 15:57'!setupCostume	super setupCostume.	self layout: CTableLayout new.	self layout listDirection: #leftToRight.	self hResizing: #spaceFill; vResizing: #shrinkWrap.	self layout cellInset: 2@0.	fireButton width: 16.	fireButton hResizing: #rigid; vResizing: #spaceFill.	fireButton font: CTileLibrary default tileFont.	fireButton textAnchorPoint: #center.	fireButton textInset: 0@0.	fireButton fillColors: {Color white. CWidgetLibrary default baseColor}.	fireButton fillAlpha: 1.0.	fireButton fillStyle: #solid.	fireButton 		borderWidth: 1; 		borderStyle: #simple; 		borderColor: CWidgetLibrary default frameColor.	fireButton roundCorners: true.	spacer hResizing: #spaceFill; vResizing: #rigid.	spacer height: 10.! !!CViewerRow methodsFor: 'events' stamp: 'ar 3/22/2004 15:29'!onClick	<on: click in: messageTile>	self onDragStart.! !!CViewerRow methodsFor: 'events' stamp: 'ar 3/22/2004 15:28'!onDragStart	| dragTile |	<on: dragStart in: messageTile>	self onMouseLeave.	dragTile := messageTile definition newFor: messageTile receiver.	hand attach: dragTile.	dragTile origin: hand position + 4.! !!CViewerRow methodsFor: 'events' stamp: 'ar 4/2/2004 14:55'!onMessageTileChanged	| fieldRef fieldName |	<on: messageTileChanged>	self removeAll.	messageTile valueType 		ifNil:[fireButton label: '!!']		ifNotNil:[fireButton label: '?'].	self add: fireButton.	self add: messageTile.	messageTile borderStyle: #simple.	messageTile isPropertyTile ifFalse:[^self].	self add: spacer.	readout := CValueTile on: messageTile eval.	fieldName := messageTile fieldName.	fieldName ifNotNil:[		fieldRef := messageTile receiver fieldNamed: fieldName.		readout player: fieldRef.	].	readout valueType: messageTile valueType.	readout color: CWidgetLibrary default paneColor.	self add: readout.! !!CViewerRow methodsFor: 'events' stamp: 'ar 3/22/2004 15:23'!onMouseDown	<on: mouseDown in: messageTile>	messageTile borderStyle: #inset.! !!CViewerRow methodsFor: 'events' stamp: 'ar 3/23/2004 13:13'!onMouseEnter	<on: mouseEnter in: messageTile>	messageTile borderStyle: #raised.! !!CViewerRow methodsFor: 'events' stamp: 'ar 3/22/2004 15:22'!onMouseLeave	<on: mouseLeave in: messageTile>	messageTile borderStyle: #simple.! !!CViewerRow methodsFor: 'events' stamp: 'ar 3/22/2004 15:23'!onMouseUp	<on: mouseUp in: messageTile>	messageTile borderStyle: #raised.! !!CViewerRow methodsFor: 'firing' stamp: 'ar 3/22/2004 21:17'!fireMessage	| result tile |	result := messageTile eval.	messageTile valueType ifNil:[^nil].	tile := CValueTile on: result.	tile valueType: messageTile valueType.	tile openInHand! !!CViewerRow methodsFor: 'firing' stamp: 'ar 3/23/2004 13:15'!onFireButtonDown	<on: mouseDown in: fireButton>	"fireButton borderStyle: #inset."	fireButton fillAngle: -90.! !!CViewerRow methodsFor: 'firing' stamp: 'ar 3/23/2004 13:15'!onFireButtonEnter	<on: mouseEnter in: fireButton>	"fireButton borderStyle: #raised."	fireButton fillStyle: #verticalGradient.	fireButton fillColors: {Color white. CWidgetLibrary default baseColor}.! !!CViewerRow methodsFor: 'firing' stamp: 'ar 3/23/2004 13:14'!onFireButtonLeave	<on: mouseLeave in: fireButton>	"fireButton borderStyle: #simple."	fireButton fillStyle: #solid.! !!CViewerRow methodsFor: 'firing' stamp: 'ar 3/23/2004 13:15'!onFireButtonUp	<on: mouseUp in: fireButton>	"fireButton borderStyle: #raised."	fireButton fillAngle: 90.	(fireButton containsPoint: fireButton cursorPoint)		ifTrue:[self fireMessage].! !!CViewerRow methodsFor: 'accessing' stamp: 'ar 3/22/2004 20:46'!fireButton	"Answer the fireButton of the receiver"	<bewareOf: #fireButtonChanged>	^self propertyValueAt: #fireButton! !!CViewerRow methodsFor: 'accessing' stamp: 'ar 3/22/2004 20:46'!fireButton: aValue	"Modify the receiver's fireButton"	^self propertyValueAt: #fireButton put: aValue with: #fireButtonChanged! !!CViewerRow methodsFor: 'accessing' stamp: 'ar 3/22/2004 15:21'!messageTile	"Answer the messageTile of the receiver"	<bewareOf: #messageTileChanged>	^self propertyValueAt: #messageTile! !!CViewerRow methodsFor: 'accessing' stamp: 'ar 3/22/2004 15:21'!messageTile: aValue	"Modify the receiver's messageTile"	^self propertyValueAt: #messageTile put: aValue with: #messageTileChanged! !!CViewerRow methodsFor: 'accessing' stamp: 'ar 3/22/2004 21:20'!readout	"Answer the readout of the receiver"	<bewareOf: #readoutChanged>	^self propertyValueAt: #readout! !!CViewerRow methodsFor: 'accessing' stamp: 'ar 3/22/2004 21:20'!readout: aValue	"Modify the receiver's readout"	^self propertyValueAt: #readout put: aValue with: #readoutChanged! !!CViewerRow methodsFor: 'accessing' stamp: 'ar 3/22/2004 21:20'!spacer	"Answer the spacer of the receiver"	<bewareOf: #spacerChanged>	^self propertyValueAt: #spacer! !!CViewerRow methodsFor: 'accessing' stamp: 'ar 3/22/2004 21:20'!spacer: aValue	"Modify the receiver's spacer"	^self propertyValueAt: #spacer put: aValue with: #spacerChanged! !!CWidget methodsFor: 'accessing' stamp: 'ar 3/17/2004 15:16'!font	"This method was automatically generated"	<bewareOf: #fontChanged>	^self propertyValueAt: #font! !!CWidget methodsFor: 'accessing' stamp: 'ar 3/11/2004 14:28'!font: aValue	"This method was automatically generated"	^self propertyValueAt: #font put: aValue with: #fontChanged! !!CButton methodsFor: 'initialize' stamp: 'ar 3/1/2004 14:45'!defaultCostume	^CWidgetLibrary default buttonCostume! !!CButton methodsFor: 'initialize' stamp: 'ar 3/30/2004 02:53'!defaultGroup	"Answer the default group this button should use if none was explicitly assigned"	^nil! !!CButton methodsFor: 'initialize' stamp: 'ar 3/29/2004 21:58'!initialize	super initialize.	state := #normal.! !!CButton methodsFor: 'accessing' stamp: 'ar 3/30/2004 02:52'!group	"Answer the group of the receiver"	<bewareOf: #groupChanged>	^self propertyValueAt: #group ifAbsent:[self defaultGroup].! !!CButton methodsFor: 'accessing' stamp: 'ar 3/13/2004 04:54'!group: aValue	"Modify the receiver's group"	^self propertyValueAt: #group put: aValue with: #groupChanged! !!CButton methodsFor: 'accessing' stamp: 'ar 3/17/2004 15:02'!image	"This button's image"	<bewareOf: #imageChanged>	^self propertyValueAt: #image! !!CButton methodsFor: 'accessing' stamp: 'ar 3/11/2004 14:18'!image: aValue	^self propertyValueAt: #image put: aValue with: #imageChanged! !!CButton methodsFor: 'accessing' stamp: 'ar 3/24/2004 16:37'!label	"Answer the label of the receiver"	<bewareOf: #labelChanged>	^self propertyValueAt: #label! !!CButton methodsFor: 'accessing' stamp: 'ar 3/24/2004 16:37'!label: aValue	"Modify the receiver's label"	^self propertyValueAt: #label put: aValue with: #labelChanged! !!CButton methodsFor: 'accessing' stamp: 'ar 3/29/2004 22:57'!selected	"Answer the selected of the receiver"	<bewareOf: #selectedChanged>	^self propertyValueAt: #selected ifAbsent:[false]! !!CButton methodsFor: 'accessing' stamp: 'ar 3/29/2004 21:48'!selected: aValue	"Modify the receiver's selected"	^self propertyValueAt: #selected put: aValue with: #selectedChanged! !!CButton methodsFor: 'accessing' stamp: 'ar 3/26/2004 17:39'!state	"Answer the state of the receiver"	<bewareOf: #stateChanged>	^self propertyValueAt: #state! !!CButton methodsFor: 'accessing' stamp: 'ar 3/26/2004 19:38'!state: aValue	"Modify the receiver's state"	^self propertyValueAt: #state put: aValue with: #stateChanged! !!CButton methodsFor: 'selecting' stamp: 'ar 3/29/2004 21:49'!deselect	"Deselect the receiver"	selected := false.! !!CButton methodsFor: 'selecting' stamp: 'ar 3/26/2004 19:39'!disable	state := #disabled.! !!CButton methodsFor: 'selecting' stamp: 'ar 3/28/2004 22:38'!disabled	"Answer whether this button is disabled"	<bewareOf: #stateChanged>	^state == #disabled! !!CButton methodsFor: 'selecting' stamp: 'ar 3/26/2004 19:39'!enable	self disabled ifFalse:[^self].	state := #normal.! !!CButton methodsFor: 'selecting' stamp: 'ar 3/30/2004 02:51'!select	"Select the receiver"	| myGroup |	myGroup := group.	myGroup ifNotNil:[		myGroup selection deselect.		myGroup selection: self.	].	selected := true.! !!CCheckBox methodsFor: 'initialize' stamp: 'ar 3/1/2004 14:45'!defaultCostume	^CWidgetLibrary default checkBoxCostume! !!CCheckBox methodsFor: 'initialize' stamp: 'ar 3/26/2004 20:49'!initialize	super initialize.	value := false.! !!CCheckBox methodsFor: 'events' stamp: 'ar 3/27/2004 18:56'!onFire	"Fire this button"	| oldValue |	<on: fire>	oldValue := value.	oldValue == true 		ifTrue:[value := false]		ifFalse:[value := true].! !!CConstraintValueWidget methodsFor: 'accessing' stamp: 'ar 9/8/2004 16:21'!value: unconstraintValue	"Modify the receiver's value"	| newValue |	"First check if the value is the same as the current one"	value = unconstraintValue ifTrue:[^unconstraintValue].	"Now compute the constraint value"	newValue := self adoptValue: unconstraintValue.	"Even if the constraint value is the same as the current value 	we MUST signal valueChanged here to inform any costume that 	it should update its value, so that the costume sees the constraint value.	Signaling valueChanged below basically says that we did something like:		value := unconstraintValue.		value := newValue.	but this way it's a lot more efficient."	newValue = value 		ifTrue:[self signalChanged: #valueChanged from: unconstraintValue to: newValue]		ifFalse:[super value: newValue].	"field setters must return their argument unmodified"	^unconstraintValue! !!CConstraintValueWidget methodsFor: 'private' stamp: 'ar 3/28/2004 19:57'!adoptValue: aValue	"Constrain the given value to whatever is required by the receiver"	^aValue! !!CImageButton methodsFor: 'accessing' stamp: 'ar 3/17/2004 15:09'!disabledImage	"This method was automatically generated"	<bewareOf: #disabledImageChanged>	^self propertyValueAt: #disabledImage! !!CImageButton methodsFor: 'accessing' stamp: 'ar 3/11/2004 14:22'!disabledImage: aValue	"This method was automatically generated"	^self propertyValueAt: #disabledImage put: aValue with: #disabledImageChanged! !!CImageButton methodsFor: 'accessing' stamp: 'ar 3/17/2004 15:09'!normalImage	"This method was automatically generated"	<bewareOf: #normalImageChanged>	^self propertyValueAt: #normalImage! !!CImageButton methodsFor: 'accessing' stamp: 'ar 3/11/2004 14:22'!normalImage: aValue	"This method was automatically generated"	^self propertyValueAt: #normalImage put: aValue with: #normalImageChanged! !!CImageButton methodsFor: 'accessing' stamp: 'ar 3/17/2004 15:09'!overImage	"This method was automatically generated"	<bewareOf: #overImageChanged>	^self propertyValueAt: #overImage! !!CImageButton methodsFor: 'accessing' stamp: 'ar 3/11/2004 14:22'!overImage: aValue	"This method was automatically generated"	^self propertyValueAt: #overImage put: aValue with: #overImageChanged! !!CImageButton methodsFor: 'accessing' stamp: 'ar 3/17/2004 15:09'!pressedImage	"This method was automatically generated"	<bewareOf: #pressedImageChanged>	^self propertyValueAt: #pressedImage! !!CImageButton methodsFor: 'accessing' stamp: 'ar 3/11/2004 14:22'!pressedImage: aValue	"This method was automatically generated"	^self propertyValueAt: #pressedImage put: aValue with: #pressedImageChanged! !!CImageButton methodsFor: 'accessing' stamp: 'ar 4/4/2004 16:18'!selectedImage	"Answer the selectedImage of the receiver"	<bewareOf: #selectedImageChanged>	^self propertyValueAt: #selectedImage! !!CImageButton methodsFor: 'accessing' stamp: 'ar 4/4/2004 16:18'!selectedImage: aValue	"Modify the receiver's selectedImage"	^self propertyValueAt: #selectedImage put: aValue with: #selectedImageChanged! !!CImageButton methodsFor: 'events' stamp: 'bf 4/27/2004 12:34'!onButtonStateChanged	| baseImage |	<on: stateChanged>	selected ifTrue:[		baseImage := selectedImage ifNil:[pressedImage].	] ifFalse:[		baseImage := normalImage.	].	state == #normal ifTrue:[image := baseImage].	(state == #over and: [selected not]) ifTrue:[image := overImage ifNil:[baseImage]].	state == #pressed ifTrue:[image := pressedImage].	state == #disabled ifTrue:[image := disabledImage ifNil:[baseImage]].! !!CImageButton methodsFor: 'events' stamp: 'ar 7/30/2004 08:35'!onNormalImageChanged	"Make sure we display the right stuff"	<on: normalImageChanged>	self onButtonStateChanged.! !!CImageButton methodsFor: 'events' stamp: 'ar 4/4/2004 16:19'!onSelectedChanged	<on: selectedChanged>	selected ifTrue:[		image := selectedImage ifNil:[pressedImage].	] ifFalse:[		self onButtonStateChanged.	].! !!CImageButton methodsFor: 'initialize' stamp: 'ar 4/3/2004 14:06'!defaultCostume	^CButtonCostume! !!CLabel methodsFor: 'initialize' stamp: 'ar 3/1/2004 14:47'!defaultCostume	^CWidgetLibrary default labelCostume! !!CLabel methodsFor: 'initialize' stamp: 'ar 2/25/2004 00:19'!initialize	super initialize.	self value: 'Label'.! !!CLabel methodsFor: 'accessing' stamp: 'ar 3/25/2004 21:31'!label	^self value displayText! !!CLabel methodsFor: 'accessing' stamp: 'ar 3/25/2004 21:31'!label: aString	^self value: aString! !!CMenu methodsFor: 'initialize' stamp: 'ar 3/1/2004 14:48'!defaultCostume	^CWidgetLibrary default menuCostume! !!CMenu methodsFor: 'initialize' stamp: 'ar 3/24/2004 18:12'!initialize	super initialize.	self define: #menuItems as: CCollection new.	label := nil.! !!CMenu methodsFor: 'accessing' stamp: 'ar 3/13/2004 20:33'!itemNamed: aString	self menuItems do:[:item|		aString = item label ifTrue:[^item].	].	^nil! !!CMenu methodsFor: 'accessing' stamp: 'ar 3/24/2004 16:37'!label	"Answer the label of the receiver"	<bewareOf: #labelChanged>	^self propertyValueAt: #label! !!CMenu methodsFor: 'accessing' stamp: 'ar 3/24/2004 16:37'!label: aValue	"Modify the receiver's label"	^self propertyValueAt: #label put: aValue with: #labelChanged! !!CMenu methodsFor: 'accessing' stamp: 'ar 3/24/2004 15:11'!menuItems	"Answer the menuItems of the receiver"	<bewareOf: #menuItemsChanged>	^self propertyValueAt: #menuItems! !!CMenu methodsFor: 'accessing' stamp: 'ar 3/24/2004 15:11'!menuItems: aValue	"Modify the receiver's menuItems"	^self propertyValueAt: #menuItems put: aValue with: #menuItemsChanged! !!CMenu methodsFor: 'construction' stamp: 'ar 2/23/2004 19:12'!add: aString action: anAction	^self add: aString target: anAction action: #value! !!CMenu methodsFor: 'construction' stamp: 'ar 2/23/2004 19:12'!add: aString subMenu: aMenu	| item |	item := self addItem: aString.	item subMenu: aMenu.	^item! !!CMenu methodsFor: 'construction' stamp: 'ar 2/23/2004 19:12'!add: aString target: anObject action: aSelector	^self add: aString target: anObject action: aSelector arguments: #()! !!CMenu methodsFor: 'construction' stamp: 'ar 2/23/2004 19:12'!add: aString target: anObject action: aSelector argument: arg	^self add: aString target: anObject action: aSelector arguments: {arg}! !!CMenu methodsFor: 'construction' stamp: 'ar 2/23/2004 19:12'!add: aString target: anObject action: aSelector arguments: args	| item |	item := self addItem: aString.	item action: (MessageSend receiver: anObject selector: aSelector arguments: args).	^item! !!CMenu methodsFor: 'construction' stamp: 'ar 2/23/2004 19:13'!add: aString target: anObject action: aSelector checked: aBool	| item |	item := self add: aString target: anObject action: aSelector.	item checked: aBool.	^item! !!CMenu methodsFor: 'construction' stamp: 'ar 2/23/2004 19:13'!add: aString target: anObject action: aSelector disabled: aBool	| item |	item := self add: aString target: anObject action: aSelector.	item disabled: aBool.	^item! !!CMenu methodsFor: 'construction' stamp: 'ar 3/24/2004 18:13'!addItem: aString	| item |	item := CMenuItem new.	item label: aString.	menuItems add: item.	self signal: #menuItemsChanged.	^item! !!CMenu methodsFor: 'construction' stamp: 'ar 3/17/2004 11:44'!addItemSpec: itemSpec target: aTarget	| itemName itemValue item |	itemSpec == #- ifTrue:[^self addSeparator].	itemName := itemSpec first.	itemValue := itemSpec last.	item := self addItem: itemName.	(itemValue isMemberOf: Array) ifTrue:[		item subMenu: (CMenu new addList: itemValue target: aTarget).	] ifFalse:[		item action: (MessageSend receiver: aTarget selector: itemValue).	].	^item! !!CMenu methodsFor: 'construction' stamp: 'ar 3/6/2004 22:27'!addList: itemSpecList target: aTarget	itemSpecList do:[:itemSpec|		self addItemSpec: itemSpec target: aTarget.	].! !!CMenu methodsFor: 'construction' stamp: 'ar 3/6/2004 22:34'!addSeparator	| item |	item := self addItem: ''.	item separator: true.	^item! !!CMenu methodsFor: 'utilities' stamp: 'ar 3/6/2004 22:52'!choose: labelString	labelString ifNotNil:[self label: labelString].	^self run: nil! !!CMenu methodsFor: 'utilities' stamp: 'ar 3/6/2004 22:52'!choose: labelString from: labels values: values default: defaultAnswer	labelString ifNotNil:[self label: labelString].	labels with: values do:[:lbl :val| 		self add: lbl target: self action: #value: argument: val].	^self run: defaultAnswer! !!CMenu methodsFor: 'utilities' stamp: 'ar 3/6/2004 22:52'!chooseFrom: aCollection	self chooseFrom: aCollection in: self.	^self run: nil! !!CMenu methodsFor: 'utilities' stamp: 'ar 3/27/2004 21:07'!chooseFrom: aCollection in: aMenu	| subLabel item entry |	aCollection do:[:spec|		spec = #- ifTrue:[			self addSeparator.		] ifFalse:[			subLabel := spec first.			item := spec last.			item class == Array ifTrue:[				| subMenu |				subMenu := CMenu new.				subMenu chooseFrom: item in: aMenu.				self add: subLabel subMenu: subMenu.			] ifFalse:[				entry := self add: subLabel target: aMenu action: #value: argument: item.				entry checked: aMenu value == item.			].		].	].! !!CMenu methodsFor: 'utilities' stamp: 'ar 3/7/2004 01:04'!chooseFromValues: aCollection	^self chooseFrom: (aCollection collect:[:each| Array with: each with: each]).! !!CMenu methodsFor: 'utilities' stamp: 'ar 3/7/2004 01:05'!chooseFromValues: aCollection default: defaultValue	defaultValue ifNotNil:[		self add: defaultValue target: self action: #value: argument: defaultValue.		self addSeparator.	].	^self chooseFromValues: aCollection! !!CMenu methodsFor: 'utilities' stamp: 'ar 3/6/2004 22:53'!run	^self run: self value! !!CMenu methodsFor: 'utilities' stamp: 'ar 3/6/2004 22:53'!run: defaultValue	self value: defaultValue.	self isOpen ifFalse:[self openAt: self hand position].	self waitUntil: #closed.	self syncScript. "to get answer for real"	^self value! !!CMenuBar methodsFor: 'initialize' stamp: 'ar 3/13/2004 17:35'!defaultCostume	^CMenuBarCostume! !!CMenuBar methodsFor: 'initialize' stamp: 'ar 3/13/2004 17:35'!initialize	super initialize.	self label: nil.! !!CPushButton methodsFor: 'initialize' stamp: 'ar 3/1/2004 14:48'!defaultCostume	^CWidgetLibrary default pushButtonCostume! !!CRadioButton methodsFor: 'initialize' stamp: 'ar 3/1/2004 14:48'!defaultCostume	^CWidgetLibrary default radioButtonCostume! !!CRadioButton methodsFor: 'initialize' stamp: 'ar 3/30/2004 02:53'!defaultGroup	"Answer the default group this button should use if none was explicitly assigned"	^container elements! !!CRadioButton methodsFor: 'events' stamp: 'ar 3/30/2004 18:17'!onFire	<on: fire>	self select.! !!CScrollPane methodsFor: 'initialize' stamp: 'ar 3/1/2004 14:48'!defaultCostume	^CWidgetLibrary default scrollPaneCostume! !!CScrollPane methodsFor: 'initialize' stamp: 'ar 3/24/2004 18:02'!initialize	super initialize.	self define: #holder as: CHolder new.	hScrollable := true.	vScrollable := true.! !!CScrollPane methodsFor: 'accessing' stamp: 'ar 3/24/2004 17:55'!elements	^holder elements! !!CScrollPane methodsFor: 'accessing' stamp: 'ar 3/24/2004 17:53'!holder	"Answer the holder of the receiver"	<bewareOf: #holderChanged>	^self propertyValueAt: #holder! !!CScrollPane methodsFor: 'accessing' stamp: 'ar 3/24/2004 17:53'!holder: aValue	"Modify the receiver's holder"	^self propertyValueAt: #holder put: aValue with: #holderChanged! !!CSlider methodsFor: 'initialize' stamp: 'ar 3/1/2004 14:49'!defaultCostume	^CWidgetLibrary default sliderCostume! !!CSlider methodsFor: 'initialize' stamp: 'ar 2/8/2004 22:21'!initialize	super initialize.	self value: 0.	self min: 0.	self max: 100.	self step: 1.! !!CSlider methodsFor: 'accessing' stamp: 'ar 2/8/2004 20:20'!fraction	self min = self max ifTrue:[^0].	^(self value - self min) / self range! !!CSlider methodsFor: 'accessing' stamp: 'ar 3/17/2004 15:14'!max	"This method was automatically generated"	<bewareOf: #maxChanged>	^self propertyValueAt: #max! !!CSlider methodsFor: 'accessing' stamp: 'bf 3/30/2004 14:03'!max: aValue	self propertyValueAt: #max put: aValue with: #maxChanged.	self value: (self adoptValue: self value).	^aValue! !!CSlider methodsFor: 'accessing' stamp: 'ar 3/17/2004 15:14'!min	"This method was automatically generated"	<bewareOf: #minChanged>	^self propertyValueAt: #min! !!CSlider methodsFor: 'accessing' stamp: 'bf 3/30/2004 14:04'!min: aValue	self propertyValueAt: #min put: aValue with: #minChanged.	self value: (self adoptValue: self value).	^aValue! !!CSlider methodsFor: 'accessing' stamp: 'ar 3/17/2004 15:14'!orientation	"This method was automatically generated"	<bewareOf: #orientationChanged>	^self propertyValueAt: #orientation! !!CSlider methodsFor: 'accessing' stamp: 'ar 3/11/2004 14:25'!orientation: aValue	"This method was automatically generated"	^self propertyValueAt: #orientation put: aValue with: #orientationChanged! !!CSlider methodsFor: 'accessing' stamp: 'ar 3/17/2004 15:14'!pageStep	"This method was automatically generated"	<bewareOf: #pageStepChanged>	^self propertyValueAt: #pageStep! !!CSlider methodsFor: 'accessing' stamp: 'ar 3/11/2004 14:25'!pageStep: aValue	"This method was automatically generated"	^self propertyValueAt: #pageStep put: aValue with: #pageStepChanged! !!CSlider methodsFor: 'accessing' stamp: 'ar 2/8/2004 20:22'!range	"Answer the range used for scrolling"	^(self max - self min) abs! !!CSlider methodsFor: 'accessing' stamp: 'ar 3/17/2004 15:14'!step	"This method was automatically generated"	<bewareOf: #stepChanged>	^self propertyValueAt: #step! !!CSlider methodsFor: 'accessing' stamp: 'bf 3/30/2004 14:04'!step: aValue	self propertyValueAt: #step put: aValue with: #stepChanged.	self value: (self adoptValue: self value).	^aValue! !!CSlider methodsFor: 'accessing' stamp: 'ar 3/17/2004 15:14'!visibleFraction	"This method was automatically generated"	<bewareOf: #visibleFractionChanged>	^self propertyValueAt: #visibleFraction! !!CSlider methodsFor: 'accessing' stamp: 'ar 3/11/2004 14:25'!visibleFraction: aValue	"This method was automatically generated"	^self propertyValueAt: #visibleFraction put: aValue with: #visibleFractionChanged! !!CSlider methodsFor: 'private' stamp: 'ar 2/18/2004 12:32'!adoptValue: aValue	"Take aValue and constrain it to the settings"	| newValue |	aValue ifNil:[^self value].	newValue := aValue.	self min ifNil:[		self max ifNotNil:[newValue := newValue max: self max].	] ifNotNil:[		self max ifNil:[			newValue := newValue min: self min.		] ifNotNil:[			"Allow for negative directions"			self min <= self max				ifTrue:[newValue := newValue min: self max max: self min]				ifFalse:[newValue := newValue min: self min max: self max].		].	].	"self step ifNotNil:[newValue := newValue truncateTo: self step]."	^newValue! !!CSlider methodsFor: 'streaming' stamp: 'ar 3/28/2004 22:30'!atEnd	"answer whether the receiver is at its end"	max ifNil:[^false].	^value >= max! !!CSlider methodsFor: 'streaming' stamp: 'ar 3/28/2004 22:31'!atStart	"answer whether the receiver is at its start"	min ifNil:[^false].	^value <= min! !!CSlider methodsFor: 'streaming' stamp: 'ar 3/28/2004 22:31'!next	"go to the next element in the receiver"	value := value + (step ifNil:[1])! !!CSlider methodsFor: 'streaming' stamp: 'ar 3/28/2004 22:31'!peek	"answer the element at the receiver's cursor"	^value! !!CSlider methodsFor: 'streaming' stamp: 'ar 3/28/2004 22:32'!prev	"go to the previous element in the receiver"	value := value - (step ifNil:[1]).! !!CScrollBar methodsFor: 'initialize' stamp: 'ar 3/1/2004 14:50'!defaultCostume	^CWidgetLibrary default scrollBarCostume! !!CScrollBar methodsFor: 'initialize' stamp: 'ar 2/26/2004 16:50'!initialize	super initialize.	self pageStep: 10.! !!CScrollBar methodsFor: 'accessing' stamp: 'ar 3/27/2004 19:19'!buttonHeight	<bewareOf: #buttonHeightChanged>	^(self propertyValueAt: #buttonHeight) ifNil:[CWidgetLibrary default scrollBarHeight]! !!CScrollBar methodsFor: 'accessing' stamp: 'ar 3/11/2004 14:25'!buttonHeight: aValue	"This method was automatically generated"	^self propertyValueAt: #buttonHeight put: aValue with: #buttonHeightChanged! !!CSpinner methodsFor: 'initialize' stamp: 'ar 3/7/2004 20:13'!defaultCostume	^CWidgetLibrary default spinnerCostume! !!CSpinner methodsFor: 'initialize' stamp: 'ar 3/26/2004 04:20'!initialize	super initialize.	label := self class name allButFirst.	self value: 0.	self min: 0.	self max: 100.	self step: 1.! !!CSpinner methodsFor: 'accessing' stamp: 'ar 3/24/2004 16:37'!label	"Answer the label of the receiver"	<bewareOf: #labelChanged>	^self propertyValueAt: #label! !!CSpinner methodsFor: 'accessing' stamp: 'ar 3/24/2004 16:37'!label: aValue	"Modify the receiver's label"	^self propertyValueAt: #label put: aValue with: #labelChanged! !!CSpinner methodsFor: 'accessing' stamp: 'ar 3/17/2004 15:14'!max	"This method was automatically generated"	<bewareOf: #maxChanged>	^self propertyValueAt: #max! !!CSpinner methodsFor: 'accessing' stamp: 'ar 3/11/2004 14:26'!max: aValue	"This method was automatically generated"	^self propertyValueAt: #max put: aValue with: #maxChanged! !!CSpinner methodsFor: 'accessing' stamp: 'ar 3/17/2004 15:14'!min	"This method was automatically generated"	<bewareOf: #minChanged>	^self propertyValueAt: #min! !!CSpinner methodsFor: 'accessing' stamp: 'ar 3/11/2004 14:26'!min: aValue	"This method was automatically generated"	^self propertyValueAt: #min put: aValue with: #minChanged! !!CSpinner methodsFor: 'accessing' stamp: 'ar 3/17/2004 15:14'!step	"This method was automatically generated"	<bewareOf: #stepChanged>	^self propertyValueAt: #step! !!CSpinner methodsFor: 'accessing' stamp: 'ar 3/11/2004 14:26'!step: aValue	"This method was automatically generated"	^self propertyValueAt: #step put: aValue with: #stepChanged! !!CSpinner methodsFor: 'private' stamp: 'ar 3/8/2004 15:28'!adoptValue: aValue	"Take aValue and constrain it to the settings"	| newValue |	aValue ifNil:[^self value].	newValue := aValue.	self min ifNil:[		self max ifNotNil:[newValue := newValue max: self max].	] ifNotNil:[		self max ifNil:[			newValue := newValue min: self min.		] ifNotNil:[			"Allow for negative directions"			self min <= self max				ifTrue:[newValue := newValue min: self max max: self min]				ifFalse:[newValue := newValue min: self min max: self max].		].	].	^newValue! !!CSpinnerButtons methodsFor: 'initialize' stamp: 'ar 3/13/2004 23:56'!defaultCostume	^CSpinnerButtonsCostume! !!CTabButton methodsFor: 'initialize' stamp: 'ar 3/13/2004 04:16'!defaultCostume	^CWidgetLibrary default tabButtonCostume! !!CTabButton methodsFor: 'initialize' stamp: 'ar 3/30/2004 02:53'!defaultGroup	"Answer the default group this button should use if none was explicitly assigned"	^container elements! !!CTabButton methodsFor: 'events' stamp: 'ar 3/29/2004 23:03'!onFire	<on: fire>	self select.! !!CTextEditor methodsFor: 'initialize' stamp: 'ar 3/25/2004 15:50'!defaultCostume	"^CTextEditorCostume"	^CScrollableTextEditorCostume! !!CTextEditor methodsFor: 'initialize' stamp: 'ar 6/2/2004 14:58'!defaultTarget	^(CTextEditorPane new)		editor: self;		yourself! !!CTextEditor methodsFor: 'initialize' stamp: 'ar 6/2/2004 14:17'!initialize	super initialize.	target := self defaultTarget.	self allowEditing: true.	self caseSensitiveSearch: false.! !!CTextEditor methodsFor: 'accessing' stamp: 'ar 3/12/2004 14:41'!allowEditing	"Answer the allowEditing of the receiver"	<bewareOf: #allowEditingChanged>	^self propertyValueAt: #allowEditing! !!CTextEditor methodsFor: 'accessing' stamp: 'ar 3/12/2004 14:41'!allowEditing: aValue	"Modify the receiver's allowEditing"	^self propertyValueAt: #allowEditing put: aValue with: #allowEditingChanged! !!CTextEditor methodsFor: 'accessing' stamp: 'ar 3/12/2004 14:49'!caseSensitiveSearch	"Answer the caseSensitiveSearch of the receiver"	<bewareOf: #caseSensitiveSearchChanged>	^self propertyValueAt: #caseSensitiveSearch! !!CTextEditor methodsFor: 'accessing' stamp: 'ar 3/12/2004 14:49'!caseSensitiveSearch: aValue	"Modify the receiver's caseSensitiveSearch"	^self propertyValueAt: #caseSensitiveSearch put: aValue with: #caseSensitiveSearchChanged! !!CTextEditor methodsFor: 'accessing' stamp: 'ar 3/12/2004 14:53'!contents	"Answer the text being currently edited"	^editor text! !!CTextEditor methodsFor: 'accessing' stamp: 'ar 3/12/2004 14:54'!contents: aText	"Set the text being currently edited"	^editor text: aText! !!CTextEditor methodsFor: 'accessing' stamp: 'ar 5/3/2004 14:43'!editor	^target textEditor! !!CTextEditor methodsFor: 'accessing' stamp: 'ar 3/12/2004 14:42'!emphasis	^editor emphasis! !!CTextEditor methodsFor: 'accessing' stamp: 'ar 3/12/2004 14:42'!font	^editor font! !!CTextEditor methodsFor: 'accessing' stamp: 'bf 3/30/2004 14:02'!font: aFont	| selection attr |	attr := TextFontReference toFont: aFont.	selection := self selection.	selection isEmpty ifTrue:[		self editor changeFontHere: attr.		^aFont].	selection := self selection addAttribute: attr.	self paste: selection select: true.	^aFont! !!CTextEditor methodsFor: 'accessing' stamp: 'ar 6/2/2004 16:14'!hideTypeInCursor	^true! !!CTextEditor methodsFor: 'accessing' stamp: 'ar 3/12/2004 14:42'!modified	"Answer whether the receiver has been modified"	^editor modified! !!CTextEditor methodsFor: 'accessing' stamp: 'ar 3/12/2004 14:42'!modified: aBool	"Indicate whether the receiver has been modified"	editor modified: aBool.! !!CTextEditor methodsFor: 'accessing' stamp: 'ar 3/12/2004 14:48'!searchText	"Answer the searchText of the receiver"	<bewareOf: #searchTextChanged>	^self propertyValueAt: #searchText! !!CTextEditor methodsFor: 'accessing' stamp: 'ar 3/12/2004 14:48'!searchText: aValue	"Modify the receiver's searchText"	^self propertyValueAt: #searchText put: aValue with: #searchTextChanged! !!CTextEditor methodsFor: 'accessing' stamp: 'ar 3/12/2004 14:44'!showCaret	"Answer the value of the receiver's showCaret property.	Values:		false	-	never show the caret		nil		-	show the caret if the receiver has the input focus		true	-	show the caret unless nothing is selected and not input focus"	^editor showCaret! !!CTextEditor methodsFor: 'accessing' stamp: 'ar 3/12/2004 14:44'!showCaret: aBoolOrNil	"Set the value of the receiver's showCaret property.	Values:		false	-	never show the caret		nil		-	show the caret if the receiver has the input focus		true	-	show the caret unless nothing is selected and not input focus"	editor showCaret: aBoolOrNil! !!CTextEditor methodsFor: 'accessing' stamp: 'ar 5/3/2004 14:40'!target	"Answer the target of the receiver"	<bewareOf: #targetChanged>	^self propertyValueAt: #target! !!CTextEditor methodsFor: 'accessing' stamp: 'ar 5/3/2004 14:40'!target: aValue	"Modify the receiver's target"	^self propertyValueAt: #target put: aValue with: #targetChanged! !!CTextEditor methodsFor: 'accessing' stamp: 'ar 3/18/2004 14:42'!value: newValue	value == newValue ifTrue:[^value].	super value: newValue.	contents := self printValue: newValue.	^value! !!CTextEditor methodsFor: 'moving' stamp: 'ar 3/12/2004 14:38'!moveCursorLeft	^self editor moveCursorLeft! !!CTextEditor methodsFor: 'moving' stamp: 'ar 3/12/2004 14:38'!moveCursorRight	^self editor moveCursorRight! !!CTextEditor methodsFor: 'moving' stamp: 'ar 3/12/2004 14:38'!moveLineDown	^self editor moveLineDown! !!CTextEditor methodsFor: 'moving' stamp: 'ar 3/12/2004 14:38'!moveLineEnd	^self editor moveLineEnd! !!CTextEditor methodsFor: 'moving' stamp: 'ar 3/12/2004 14:38'!moveLineStart	^self editor moveLineStart! !!CTextEditor methodsFor: 'moving' stamp: 'ar 3/12/2004 14:38'!moveLineUp	^self editor moveLineUp! !!CTextEditor methodsFor: 'moving' stamp: 'ar 3/12/2004 14:38'!moveTextEnd	^self editor moveTextEnd! !!CTextEditor methodsFor: 'moving' stamp: 'ar 3/12/2004 14:38'!moveTextStart	^self editor moveTextStart! !!CTextEditor methodsFor: 'moving' stamp: 'ar 3/12/2004 14:39'!moveWordLeft	^self editor moveWordLeft! !!CTextEditor methodsFor: 'moving' stamp: 'ar 3/12/2004 14:39'!moveWordRight	^self editor moveWordRight! !!CTextEditor methodsFor: 'moving' stamp: 'ar 3/12/2004 14:39'!selectCursorLeft	^self editor selectCursorLeft! !!CTextEditor methodsFor: 'moving' stamp: 'ar 3/12/2004 14:39'!selectCursorRight	^self editor selectCursorRight! !!CTextEditor methodsFor: 'moving' stamp: 'ar 3/12/2004 14:39'!selectLineDown	^self editor selectLineDown! !!CTextEditor methodsFor: 'moving' stamp: 'ar 3/12/2004 14:39'!selectLineEnd	^self editor selectLineEnd! !!CTextEditor methodsFor: 'moving' stamp: 'ar 3/12/2004 14:39'!selectLineStart	^self editor selectLineStart! !!CTextEditor methodsFor: 'moving' stamp: 'ar 3/12/2004 14:39'!selectLineUp	^self editor selectLineUp! !!CTextEditor methodsFor: 'moving' stamp: 'ar 3/12/2004 14:39'!selectTextEnd	^self editor selectTextEnd! !!CTextEditor methodsFor: 'moving' stamp: 'ar 3/12/2004 14:39'!selectTextStart	^self editor selectTextStart! !!CTextEditor methodsFor: 'moving' stamp: 'ar 3/12/2004 14:39'!selectWordLeft	^self editor selectWordLeft! !!CTextEditor methodsFor: 'moving' stamp: 'ar 3/12/2004 14:39'!selectWordRight	^self editor selectWordRight! !!CTextEditor methodsFor: 'selecting' stamp: 'ar 3/12/2004 14:46'!selectAll	editor selectFrom: 1 to: self editor text size+1.! !!CTextEditor methodsFor: 'selecting' stamp: 'ar 3/12/2004 14:43'!selectAt: selectionIndex	editor selectAt: selectionIndex! !!CTextEditor methodsFor: 'selecting' stamp: 'ar 3/12/2004 14:43'!selectFrom: firstIndex to: lastIndex	editor selectFrom: firstIndex to: lastIndex.! !!CTextEditor methodsFor: 'selecting' stamp: 'ar 3/12/2004 14:43'!selection	^editor selection! !!CTextEditor methodsFor: 'selecting' stamp: 'ar 3/12/2004 14:43'!selectionStart	<bewareOf: #textModified>	^editor selectionStart! !!CTextEditor methodsFor: 'selecting' stamp: 'ar 3/12/2004 14:43'!selectionStart: aNumber	^self selectFrom: aNumber to: self selectionStop! !!CTextEditor methodsFor: 'selecting' stamp: 'ar 3/12/2004 14:44'!selectionStop	<bewareOf: #textModified>	^editor selectionStop! !!CTextEditor methodsFor: 'selecting' stamp: 'ar 3/12/2004 14:44'!selectionStop: aNumber	^self selectFrom: selectionStart to: aNumber! !!CTextEditor methodsFor: 'operations' stamp: 'ar 3/12/2004 15:02'!append: aText	contents := contents, aText! !!CTextEditor methodsFor: 'operations' stamp: 'ar 3/12/2004 15:03'!enter	self editor replaceSelectionWith: String cr! !!CTextEditor methodsFor: 'operations' stamp: 'ar 3/12/2004 14:47'!paste: aText	^self paste: aText select: false! !!CTextEditor methodsFor: 'operations' stamp: 'ar 3/12/2004 14:47'!paste: aText select: aBool	editor replaceSelectionWith: aText.	aBool ifTrue:[editor selectFrom: selectionStop - aText size to: selectionStop].! !!CTextEditor methodsFor: 'operations' stamp: 'ar 3/12/2004 14:47'!redo	editor redo.! !!CTextEditor methodsFor: 'operations' stamp: 'ar 3/12/2004 14:46'!revert	self contents: self value asText copy.! !!CTextEditor methodsFor: 'operations' stamp: 'ar 3/12/2004 14:46'!save	"If a client is interested in saving text in different ways, just signal #save - otherwise take the text as is."	(self handlesEvent: #save)		ifTrue:[self signal: #save with: self text with: self value]		ifFalse:[self onAccept].! !!CTextEditor methodsFor: 'operations' stamp: 'ar 3/12/2004 14:46'!undo	editor undo.! !!CTextEditor methodsFor: 'text search' stamp: 'ar 3/12/2004 14:54'!findNext	"Find the next occurance of the current search text"	self searchText isEmptyOrNil 		ifTrue:[^self flash].	self findText: self searchText.! !!CTextEditor methodsFor: 'text search' stamp: 'ar 4/4/2004 17:17'!findText	"Find a piece of text"	| newText |	newText := CDialog 				request: 'Find what?' 				initialAnswer: self selection asString.	self searchText: newText.	self findNext.! !!CTextEditor methodsFor: 'text search' stamp: 'ar 3/12/2004 14:49'!findText: aString	"Find the next occurance of the given string and select it. 	Return true if found, false otherwise."	^self findText: aString wrapping: nil! !!CTextEditor methodsFor: 'text search' stamp: 'ar 3/12/2004 16:36'!findText: aText wrapping: aBool	^self findText: aText wrapping: aBool caseSensitive: self caseSensitiveSearch! !!CTextEditor methodsFor: 'text search' stamp: 'ar 3/12/2004 16:36'!findText: aText wrapping: aBool caseSensitive: sensitive	"Find the next occurance of the given string and select it. Return true if found, false otherwise. If aBool == nil then query for user response for wrapping, otherwise adhere to aBool."	| where aString |	aString := aText asString.	"The search starts at the selection"	where := self selectionStart.	"But not if the selection is what we search for"	(self selection asString equals: aString caseSensitive: sensitive)		ifTrue:[where := self selectionStop].	where := self text 				findString: aString				startingAt: where				caseSensitive: sensitive.	(where = 0 and:[aBool ~= false]) ifTrue:[		(aBool == true or:[self confirm:'Reached the end of text.\\Start over?' withCRs]) ifTrue:[			where := self text 						findString: aString 						startingAt: 1						caseSensitive: sensitive]].	where = 0 ifTrue:[^false].	self selectFrom: where to: where + aString size.	^true! !!CTextEditor methodsFor: 'events' stamp: 'ar 3/18/2004 14:41'!onAccept	value := self readValue: contents.! !!CTextEditor methodsFor: 'events' stamp: 'ar 6/2/2004 16:11'!onAllowEditingChanged	<on: allowEditingChanged>	allowEditing ifTrue:[		self resumeScript: #onMouseDown:.		self resumeScript: #onMouseMove:.		self resumeScript: #onMouseUp:.		self resumeScript: #onKeyboardFocusEnter.		self resumeScript: #onMouseEnter.		self resumeScript: #onMouseLeave.	] ifFalse:[		self pauseScript: #onMouseDown:.		self pauseScript: #onMouseMove:.		self pauseScript: #onMouseUp:.		self pauseScript: #onKeyboardFocusEnter.		self pauseScript: #onMouseEnter.		self pauseScript: #onMouseLeave.	].	self setTextCursor.! !!CTextEditor methodsFor: 'events' stamp: 'ar 5/19/2004 15:17'!onContextMenu	<on: yellowButtonDown in: target>	allowEditing ifTrue:[		(editor attributesAt: self cursorPoint) do:[:attr|			attr menu ifNotNil:[				attr menu openAt: hand position.				^nil]		].	].	self editMenu openAt: hand position.! !!CTextEditor methodsFor: 'events' stamp: 'ar 6/2/2004 16:08'!onKeyDown: evt	"Dispatch a keyboard shortcut"	| action |	<on: keyDown>	action := StandardEditingKeys lookupEvent: evt.	action ifNotNil:[self perform: action].! !!CTextEditor methodsFor: 'events' stamp: 'ar 6/2/2004 16:14'!onKeyStroke: evt	| keyValue |	<on: keyStroke>	"Note: all of the modifier key combinations are shortcuts and thus handled in onKeyDown. We shouldn't even have to worry about them here but the current VMs pass almost everything up as a 'character' which is plain ridiculous. We may actually loose some characters that could result from special combinations but I don't know how to fix that problem here..."	evt anyModifierKeyPressed ifTrue:[^self].	"Due to the current VM behavior, filter out more keys"	keyValue := evt keyValue.	"Left/Right"	(keyValue = 28 or:[keyValue = 29]) ifTrue:[^self].	"Up/Down"	(keyValue = 30 or:[keyValue = 31]) ifTrue:[^self].	"Home/End"	(keyValue = 1 or:[keyValue = 4]) ifTrue:[^self].	"PageUp/PageDown"	(keyValue = 11 or:[keyValue = 12]) ifTrue:[^self].	"Cr/Lf"	(keyValue = 10 or:[keyValue = 13]) ifTrue:[^self].	"Esc"	(keyValue = 30) ifTrue:[^self].	"And finally, pass it on"	editor keyStroke: evt.	self hideTypeInCursor ifTrue:[target mouseCursor := Cursor blank].! !!CTextEditor methodsFor: 'events' stamp: 'ar 6/2/2004 14:06'!onKeyboardFocusEnter	"only accept input while having the keyboard focus"	<on: keyboardFocusEnter>	self resumeScript: #onKeyStroke:.	self resumeScript: #onKeyDown:.	editor showCaret: true.! !!CTextEditor methodsFor: 'events' stamp: 'ar 6/2/2004 16:12'!onKeyboardFocusLeave	"only accept input while having the keyboard focus"	<on: keyboardFocusLeave>	self pauseScript: #onKeyStroke:.	self pauseScript: #onKeyDown:.	editor showCaret: false.! !!CTextEditor methodsFor: 'events' stamp: 'ar 6/2/2004 14:07'!onMouseDown: evt	<on: mouseDown in: target>	editor mouseDown: evt.	hand keyboardFocus: self.! !!CTextEditor methodsFor: 'events' stamp: 'ar 5/6/2004 16:31'!onMouseEnter	<on: mouseEnter>	(hand autoKeyboardFocus and:[hand keyboardFocus == nil])		ifTrue:[hand keyboardFocus: self]! !!CTextEditor methodsFor: 'events' stamp: 'ar 6/2/2004 16:12'!onMouseLeave	<on: mouseLeave>	(hand autoKeyboardFocus and:[hand keyboardFocus == self])		ifTrue:[hand releaseKeyboardFocus: self].	self setTextCursor.! !!CTextEditor methodsFor: 'events' stamp: 'ar 5/19/2004 15:17'!onMouseMove: evt	<on: redButtonMove in: target>	editor mouseMove: evt.! !!CTextEditor methodsFor: 'events' stamp: 'ar 6/2/2004 16:12'!onMouseMoved: evt	<on: mouseMove>	self setTextCursor.! !!CTextEditor methodsFor: 'events' stamp: 'ar 5/19/2004 15:17'!onMouseUp: evt	<on: mouseUp in: target>	editor mouseUp: evt.! !!CTextEditor methodsFor: 'events' stamp: 'ar 6/2/2004 16:11'!setTextCursor	target mouseCursor := (allowEditing ifTrue:[Cursor text] ifFalse:[nil]).! !!CTextEditor methodsFor: 'text menu' stamp: 'ar 3/12/2004 15:14'!copySelection	| selection |	editor selectLineIfEmpty.	selection := editor selection.	selection isEmpty ifTrue:[^self].	CClipboard clipboardText: selection.! !!CTextEditor methodsFor: 'text menu' stamp: 'ar 3/12/2004 15:15'!cutSelection	| selection |	editor selectLineIfEmpty.	selection := editor selection.	selection isEmpty ifTrue:[^self].	CClipboard clipboardText: selection.	editor replaceSelectionWith: ''.! !!CTextEditor methodsFor: 'text menu' stamp: 'ar 3/12/2004 15:15'!deleteSelection	self paste:''.! !!CTextEditor methodsFor: 'text menu' stamp: 'ar 3/17/2004 11:44'!editMenu	| menu item |	menu := CMenu new.	menu label: nil.	item := menu add: 'Undo' target: self action: #undo.	menu addSeparator.	menu add: 'Cut' target: self action: #cutSelection.	menu add: 'Copy' target: self action: #copySelection.	menu add: 'Paste' target: self action: #pasteSelection.	menu add: 'Delete' target: self action: #deleteSelection.	menu addSeparator.	menu add: 'Find' target: self action: #find.	menu add: 'Find Next' target: self action: #findNext.	menu add: 'Replace' target: self action: #replace.	menu addSeparator.	menu add: 'Select All' target: self action: #selectAll.	menu addSeparator.	item := menu add: 'Word Wrap' target: nil action: nil.	item checked: true.	^menu! !!CTextEditor methodsFor: 'text menu' stamp: 'ar 3/12/2004 15:14'!pasteSelection	| selection |	selection := CClipboard clipboardText.	selection isEmpty ifTrue:[^self].	self paste: selection.! !!CTextEditor methodsFor: 'converting' stamp: 'ar 3/18/2004 14:41'!printValue: aValue	^value displayText! !!CTextEditor methodsFor: 'converting' stamp: 'ar 3/18/2004 14:41'!readValue: aString	^aString! !!CInputField methodsFor: 'initialize' stamp: 'ar 5/19/2004 15:30'!defaultCostume	^CInputFieldCostume! !!CInputField methodsFor: 'initialize' stamp: 'ar 6/2/2004 14:18'!defaultTarget	^costume! !!CInputField methodsFor: 'initialize' stamp: 'ar 6/2/2004 14:18'!initialize	super initialize.	self onKeyDown: #(13) signal: #accept.! !!CInputField methodsFor: 'initialize' stamp: 'ar 5/19/2004 15:31'!onKeyboardFocusEnter	"Select all of the text when the user clicks in the input field"	self selectAll.	super onKeyboardFocusEnter.! !!CInputField methodsFor: 'events' stamp: 'ar 3/18/2004 15:01'!onAccept	<on: accept>	value := self readValue: contents asString.	self hand releaseKeyboardFocus.! !!CInputField methodsFor: 'accessing' stamp: 'ar 3/18/2004 14:20'!converter	"Answer the converter of the receiver"	<bewareOf: #converterChanged>	^self propertyValueAt: #converter! !!CInputField methodsFor: 'accessing' stamp: 'ar 3/18/2004 14:20'!converter: aValue	"Modify the receiver's converter"	^self propertyValueAt: #converter put: aValue with: #converterChanged! !!CInputField methodsFor: 'converting' stamp: 'ar 3/19/2004 17:25'!printValue: aValue	converter ifNil:[^super printValue: aValue].	^[converter printValue: aValue] on: Error do:[:ex| ex return: '<error>'].! !!CInputField methodsFor: 'converting' stamp: 'ar 3/19/2004 17:36'!readValue: aString	converter ifNil:[^super readValue: aString].	^[converter readValue: aString] on: Error do:[:ex| 		contents := self printValue: value.		self flash.		ex return: value].! !!CTileButton methodsFor: 'initialize' stamp: 'ar 3/14/2004 21:13'!defaultCostume	^CTileButtonCostume! !!CToolBarButton methodsFor: 'initialize' stamp: 'ar 4/4/2004 18:08'!defaultCostume	^CToolBarButtonCostume! !!CWidgetCostume methodsFor: 'accessing' stamp: 'ar 2/29/2004 22:46'!enabled	^self player enabled! !!CWidgetCostume methodsFor: 'accessing' stamp: 'ar 2/29/2004 22:46'!enabled: aBool	^self player enabled: aBool! !!CWidgetCostume methodsFor: 'accessing' stamp: 'ar 2/29/2004 22:46'!label	^self player label! !!CWidgetCostume methodsFor: 'accessing' stamp: 'ar 2/29/2004 22:47'!label: aString	self player label: aString! !!CWidgetCostume methodsFor: 'initialize' stamp: 'ar 3/7/2004 22:02'!defaultPlayer	^CWidget! !!CButtonCostume methodsFor: 'initialize' stamp: 'ar 3/7/2004 22:01'!defaultPlayer	^CButton! !!CButtonCostume methodsFor: 'initialize' stamp: 'ar 2/9/2004 23:55'!initialize	super initialize.	buttonImage := self.	buttonLabel := self.! !!CButtonCostume methodsFor: 'initialize' stamp: 'ar 4/30/2004 15:48'!setupCostume	super setupCostume.	buttonLabel textEnabled: true.	buttonImage graphicEnabled: true.! !!CButtonCostume methodsFor: 'accessing' stamp: 'ar 3/12/2004 16:31'!buttonImage	"Answer the buttonImage of the receiver"	<bewareOf: #buttonImageChanged>	^self propertyValueAt: #buttonImage! !!CButtonCostume methodsFor: 'accessing' stamp: 'ar 3/12/2004 16:31'!buttonImage: aValue	"Modify the receiver's buttonImage"	^self propertyValueAt: #buttonImage put: aValue with: #buttonImageChanged! !!CButtonCostume methodsFor: 'accessing' stamp: 'ar 3/12/2004 16:31'!buttonLabel	"Answer the buttonLabel of the receiver"	<bewareOf: #buttonLabelChanged>	^self propertyValueAt: #buttonLabel! !!CButtonCostume methodsFor: 'accessing' stamp: 'ar 3/12/2004 16:31'!buttonLabel: aValue	"Modify the receiver's buttonLabel"	^self propertyValueAt: #buttonLabel put: aValue with: #buttonLabelChanged! !!CButtonCostume methodsFor: 'accessing' stamp: 'ar 2/13/2004 21:24'!image	^self player image! !!CButtonCostume methodsFor: 'accessing' stamp: 'ar 2/13/2004 21:24'!image: aForm	self player image: aForm! !!CButtonCostume methodsFor: 'accessing' stamp: 'ar 4/28/2004 18:30'!textHolder	buttonLabel == self ifTrue:[^costume textHolder] ifFalse:[^buttonLabel textHolder]! !!CButtonCostume methodsFor: 'accessing' stamp: 'ar 4/28/2004 18:30'!textHolder: aTextHolder	buttonLabel == self ifTrue:[		costume textHolder: aTextHolder.	] ifFalse:[		buttonLabel textHolder: aTextHolder.	].! !!CButtonCostume methodsFor: 'events' stamp: 'ar 3/29/2004 22:58'!onButtonStateChanged	"Update the receiver's appearance after the button state has changed"	<on: stateChanged in: player>! !!CButtonCostume methodsFor: 'events' stamp: 'ar 2/24/2004 14:06'!onFontChanged	<on: fontChanged in: player>	self player font ifNotNil:[buttonLabel textFont: self player font].! !!CButtonCostume methodsFor: 'events' stamp: 'bf 5/5/2004 15:50'!onImageChanged	| aForm |	<on: imageChanged in: player>	aForm := self player image.	buttonImage graphicForm: aForm.	buttonImage == self ifFalse:[buttonImage visible: aForm notNil].	! !!CButtonCostume methodsFor: 'events' stamp: 'ar 3/23/2004 23:18'!onLabelChanged	| aString |	<on: labelChanged in: player>	aString := self player label.	buttonLabel text: (aString ifNil:['']).	buttonLabel == self ifFalse:[buttonLabel visible: aString notNil].! !!CButtonCostume methodsFor: 'events' stamp: 'ar 3/29/2004 22:53'!onMouseDown	<on: mouseDown>	player disabled ifTrue:[^self].	player state: #pressed.! !!CButtonCostume methodsFor: 'events' stamp: 'tk 7/14/2004 11:23'!onMouseEnter	<on: mouseEnter>	player disabled ifTrue:[^self].	hand mouseFocus == self asPrimCostume		ifTrue:[player state: #pressed]		ifFalse:[player state: #over].! !!CButtonCostume methodsFor: 'events' stamp: 'ar 3/29/2004 22:53'!onMouseLeave	<on: mouseLeave>	player disabled ifTrue:[^self].	player state: #normal.! !!CButtonCostume methodsFor: 'events' stamp: 'ar 3/29/2004 22:53'!onMouseUp	<on: mouseUp>	player disabled ifTrue:[^self].	(self containsPoint: self cursorPoint) ifTrue:[		player state: #over.		self fire.	] ifFalse:[		player state: #normal.	].! !!CButtonCostume methodsFor: 'events' stamp: 'ar 3/29/2004 22:58'!onPlayerChanged	super onPlayerChanged.	self onFontChanged.	self onImageChanged.	self onLabelChanged.	self onSelectedChanged.	self onButtonStateChanged.! !!CButtonCostume methodsFor: 'events' stamp: 'ar 3/29/2004 22:58'!onSelectedChanged	"Update the receiver's appearance after the selected state has changed"	<on: selectedChanged in: player>! !!CCheckBoxCostume methodsFor: 'initialize' stamp: 'ar 3/17/2004 03:09'!initialize	super initialize.	self define: #checkMark as: CPlayer new.	self define: #buttonLabel as: CLabel new.! !!CCheckBoxCostume methodsFor: 'initialize' stamp: 'tk 6/21/2004 09:20'!setupCostume	"Initial tweaks which really should go away before too long"	super setupCostume.	self add: checkMark.	self add: buttonLabel."	self color: Color transparent."	self fillStyle: #none.	"transparent"	self clipping: false.	buttonLabel clipping: false.	checkMark extent: 11@11.	checkMark text: 'V'.	checkMark textInset: -1.	checkMark textFont: (TextStyle named: 'WindowFont') defaultFont.	checkMark borderStyle: #simple.	checkMark borderWidth: 1.	checkMark borderColor: Color black.	checkMark color: Color white.	self layout: CTableLayout new.	self layout listDirection: #leftToRight.	self hResizing: #shrinkWrap; vResizing: #shrinkWrap.! !!CCheckBoxCostume methodsFor: 'accessing' stamp: 'ar 3/12/2004 16:31'!checkMark	"Answer the checkMark of the receiver"	<bewareOf: #checkMarkChanged>	^self propertyValueAt: #checkMark! !!CCheckBoxCostume methodsFor: 'accessing' stamp: 'ar 3/12/2004 16:31'!checkMark: aValue	"Modify the receiver's checkMark"	^self propertyValueAt: #checkMark put: aValue with: #checkMarkChanged! !!CCheckBoxCostume methodsFor: 'events' stamp: 'ar 3/30/2004 13:30'!onButtonStateChanged	"Update from my player's state"	player state == #pressed 		ifTrue:[checkMark color: Color veryLightGray].	player state == #disabled		ifTrue:[buttonLabel textColor: Color gray]		ifFalse:[buttonLabel textColor: Color black]! !!CCheckBoxCostume methodsFor: 'events' stamp: 'ar 3/16/2004 22:43'!onPlayerChanged	super onPlayerChanged.	self onValueChanged.! !!CCheckBoxCostume methodsFor: 'events' stamp: 'ar 3/25/2004 17:23'!onValueChanged	<on: valueChanged>	value == true ifTrue:[		checkMark color: Color white.		checkMark textColor: Color black.		^self].	value == false 		ifTrue:[checkMark color: Color white]		ifFalse:[checkMark color: Color veryLightGray].	checkMark textColor: Color transparent.! !!CDropDownListCostume methodsFor: 'initialize' stamp: 'ar 4/3/2004 20:10'!defaultPlayer	^CList! !!CDropDownListCostume methodsFor: 'initialize' stamp: 'ar 3/17/2004 03:11'!initialize	super initialize.	self define: #label as: CInputField new.	self define: #button as: CPlayer new.! !!CDropDownListCostume methodsFor: 'initialize' stamp: 'tk 7/12/2004 13:00'!setupCostume	"Initial tweaks - need to go away"	super setupCostume.	self borderStyle: #simple.	self borderWidth: 1.	self borderColor: CWidgetLibrary default frameColor.	self extent: 100@5.	self add: label.	label allowEditing: false.	label borderColor: Color transparent.	label clipping: false.	self add: button.	button height: 5.	button fillStyle: #verticalGradient.	button fillColors: {Color white. CWidgetLibrary default baseColor}.	button text: 'd'.	button textFont: (TextStyle named:'WindowFont') defaultFont.	button hResizing: #rigid; vResizing: #spaceFill; width: 16.	self layout: CTableLayout new.	self layout listDirection: #leftToRight.	costume hResizing: #shrinkWrap; vResizing: #shrinkWrap.! !!CDropDownListCostume methodsFor: 'events' stamp: 'ar 3/12/2004 15:37'!onAllowEditingChanged	<on: allowEditingChanged in: player>	label allowEditing: player allowEditing.! !!CDropDownListCostume methodsFor: 'events' stamp: 'ar 2/23/2004 15:09'!onCursorChanged	<on: cursorChanged in: player>	label value: self player selection.! !!CDropDownListCostume methodsFor: 'events' stamp: 'ar 3/12/2004 23:54'!onElementsChanged	<on: elementsChanged in: player>	self onCursorChanged.! !!CDropDownListCostume methodsFor: 'events' stamp: 'ar 3/12/2004 15:39'!onLabelValueChanged	<on: valueChanged in: label>	player value: label value! !!CDropDownListCostume methodsFor: 'events' stamp: 'ar 3/30/2004 17:26'!onMouseDown	| menu list |	<on: mouseDown>	menu := CMenu new.	menu label: nil.	list := self player elements.	list do:[:item| menu add: item displayText target: list action: #selection: argument: item].	menu roundCorners: false.	menu width: self width.	menu openAt: (self localToGlobal: 0@(self height - borderWidth)).! !!CDropDownListCostume methodsFor: 'events' stamp: 'ar 3/12/2004 21:02'!onPlayerChanged	super onPlayerChanged.	self onCursorChanged.	self onAllowEditingChanged.! !!CDropDownListCostume methodsFor: 'accessing' stamp: 'ar 3/12/2004 16:30'!button	"Answer the button of the receiver"	<bewareOf: #buttonChanged>	^self propertyValueAt: #button! !!CDropDownListCostume methodsFor: 'accessing' stamp: 'ar 3/12/2004 16:30'!button: aValue	"Modify the receiver's button"	^self propertyValueAt: #button put: aValue with: #buttonChanged! !!CDropDownListCostume methodsFor: 'accessing' stamp: 'ar 3/12/2004 15:39'!label	"Answer the label of the receiver"	<bewareOf: #labelChanged>	^self propertyValueAt: #label! !!CDropDownListCostume methodsFor: 'accessing' stamp: 'ar 3/12/2004 15:39'!label: aValue	"Modify the receiver's label"	^self propertyValueAt: #label put: aValue with: #labelChanged! !!CDropDownListCostume methodsFor: 'accessing' stamp: 'ar 3/30/2004 03:06'!textHolder	^label textHolder! !!CDropDownListCostume methodsFor: 'accessing' stamp: 'ar 3/30/2004 03:06'!textHolder: aTextHolder	label textHolder: aTextHolder! !!CDropDownListCostume methodsFor: 'color and fill' stamp: 'ar 4/4/2004 18:33'!windowColor: aColor	super windowColor: aColor.	button fillColors: {Color white. aColor}.! !!CLabelCostume methodsFor: 'events' stamp: 'ar 3/8/2004 22:02'!onFontChanged	<on: fontChanged in: player>	self player font ifNotNil:[self textFont: self player font].! !!CLabelCostume methodsFor: 'events' stamp: 'ar 2/16/2004 18:29'!onLabelChanged	<on: labelChanged in: player>	self text: self player label asText.! !!CLabelCostume methodsFor: 'events' stamp: 'ar 3/8/2004 22:03'!onPlayerChanged	super onPlayerChanged.	self onValueChanged.	self onFontChanged.! !!CLabelCostume methodsFor: 'events' stamp: 'ar 3/17/2004 19:29'!onValueChanged	<on: valueChanged>	self text: player value displayText asText.! !!CLabelCostume methodsFor: 'initialize' stamp: 'ar 3/7/2004 22:01'!defaultPlayer	^CLabel! !!CLabelCostume methodsFor: 'initialize' stamp: 'ar 4/30/2004 15:51'!setupCostume	super setupCostume.	self textEnabled: true.	self color: Color transparent.	self hResizing: #spaceFill.	self vResizing: #shrinkWrap.	self textAnchorPoint: #leftCenter.! !!CMenuCostume methodsFor: 'initialize' stamp: 'ar 3/13/2004 18:57'!destroy	activeParent ifNotNil:[		activeParent activeChild: nil.		activeParent sticky			ifTrue:[activeParent menuSelection: nil]			ifFalse:[activeParent destroy].		activeParent := nil.	].	activeChild ifNotNil:[		activeChild activeParent: nil.		activeChild destroy.		activeChild := nil.	].	super destroy.! !!CMenuCostume methodsFor: 'initialize' stamp: 'ar 3/24/2004 18:08'!initialize	super initialize.	self define: #menuLabel as: CLabel new.	self define: #holder as: CHolder new.	self menuCursor: 0.! !!CMenuCostume methodsFor: 'initialize' stamp: 'ar 3/24/2004 18:21'!onOpen	<on: opened>	self sticky ifFalse:[self hand mouseFocus: self].! !!CMenuCostume methodsFor: 'initialize' stamp: 'ar 5/6/2004 15:56'!setupCostume	super setupCostume.	menuLabel clipping: false.	menuLabel fillStyle: #verticalGradient.	menuLabel fillColors: CWidgetLibrary default gradientColors.	menuLabel fillAlpha: 1.0.	menuLabel textAnchorPoint: #center.	menuLabel textInset: 3.	menuLabel textEmphasis: 1.	menuLabel textColor: CWidgetLibrary default menLabelTextColor.	menuLabel roundCornerSpec: #(1 4).	self add: menuLabel.	holder hResizing: #spaceFill; vResizing: #shrinkWrap.	holder clipping: false.	holder layout: CTableLayout new.	holder hResizing: #spaceFill.	holder layout cellPositioning: #topLeft.	holder layout layoutInset: 3.	self add: holder.	self layout: CTableLayout new.	self hResizing: #spaceFill; vResizing: #shrinkWrap.	self floating: true.	self fillStyle: #verticalGradient. 	self fillColors: CWidgetLibrary default menuColors.	self dropShadowEnabled: true.	self borderStyle: #simple.	self borderWidth: 1.	self borderColor: CWidgetLibrary default frameColor.	self roundCorners: true.	self clipping: false.	self width: 100.! !!CMenuCostume methodsFor: 'accessing' stamp: 'ar 2/23/2004 20:29'!activeChild	^activeChild! !!CMenuCostume methodsFor: 'accessing' stamp: 'ar 2/23/2004 20:29'!activeChild: aMenu	activeChild := aMenu! !!CMenuCostume methodsFor: 'accessing' stamp: 'ar 2/23/2004 20:29'!activeParent	^activeParent! !!CMenuCostume methodsFor: 'accessing' stamp: 'ar 2/23/2004 20:29'!activeParent: aMenu	activeParent := aMenu! !!CMenuCostume methodsFor: 'accessing' stamp: 'ar 3/13/2004 17:32'!asMenuItemCostume: menuItem	^menuItem separator 			ifTrue:[CMenuItemSeparator on: menuItem] 			ifFalse:[CMenuItemCostume on: menuItem]! !!CMenuCostume methodsFor: 'accessing' stamp: 'ar 3/24/2004 18:07'!holder	"Answer the holder of the receiver"	<bewareOf: #holderChanged>	^self propertyValueAt: #holder! !!CMenuCostume methodsFor: 'accessing' stamp: 'ar 3/24/2004 18:07'!holder: aValue	"Modify the receiver's holder"	^self propertyValueAt: #holder put: aValue with: #holderChanged! !!CMenuCostume methodsFor: 'accessing' stamp: 'ar 3/12/2004 16:26'!menuCursor	"Answer the menuCursor of the receiver"	<bewareOf: #menuCursorChanged>	^self propertyValueAt: #menuCursor! !!CMenuCostume methodsFor: 'accessing' stamp: 'ar 3/12/2004 16:27'!menuCursor: aValue	"Modify the receiver's menuCursor"	| newCursor |	newCursor := aValue min: self menuItems size max: 0.	^self propertyValueAt: #menuCursor put: newCursor with: #menuCursorChanged! !!CMenuCostume methodsFor: 'accessing' stamp: 'ar 3/24/2004 18:08'!menuItems	^holder elements! !!CMenuCostume methodsFor: 'accessing' stamp: 'ar 3/12/2004 16:26'!menuLabel	"Answer the menuLabel of the receiver"	<bewareOf: #menuLabelChanged>	^self propertyValueAt: #menuLabel! !!CMenuCostume methodsFor: 'accessing' stamp: 'ar 3/12/2004 16:26'!menuLabel: aValue	"Modify the receiver's menuLabel"	^self propertyValueAt: #menuLabel put: aValue with: #menuLabelChanged! !!CMenuCostume methodsFor: 'accessing' stamp: 'ar 2/23/2004 22:14'!menuSelection	menuCursor = 0 ifTrue:[^nil].	^self menuItems at: menuCursor! !!CMenuCostume methodsFor: 'accessing' stamp: 'ar 2/23/2004 22:15'!menuSelection: anObject	self menuCursor: (self menuItems indexOf: anObject)! !!CMenuCostume methodsFor: 'accessing' stamp: 'ar 3/13/2004 20:11'!selectedPlayer	"Answer the selectedPlayer of the receiver"	<bewareOf: #selectedPlayerChanged>	^self propertyValueAt: #selectedPlayer! !!CMenuCostume methodsFor: 'accessing' stamp: 'ar 3/13/2004 20:11'!selectedPlayer: aValue	"Modify the receiver's selectedPlayer"	^self propertyValueAt: #selectedPlayer put: aValue with: #selectedPlayerChanged! !!CMenuCostume methodsFor: 'accessing' stamp: 'ar 2/23/2004 20:35'!sticky	^false! !!CMenuCostume methodsFor: 'events' stamp: 'ar 3/13/2004 20:08'!activeParentMenu	| menu |	(self containsPoint: self cursorPoint) ifTrue:[^nil].	menu := activeParent.	[menu == nil] whileFalse:[		(menu containsPoint: menu cursorPoint) 			ifTrue:[^menu].		menu := menu activeParent.	].	^nil! !!CMenuCostume methodsFor: 'events' stamp: 'ar 3/13/2004 18:40'!fireItem: item	"Fire the selected menu item"	item ifNil:[^self].	"see if item responds to #fire"	(item action notNil or:[item handlesEvent: #fire]) ifFalse:[^self].	"check for disabled items"	item enabled ifFalse:[^self].	"don't keep mouse focus after firing"	self hand releaseMouseFocus: self.	self sticky ifFalse:[self destroy].	item fire.! !!CMenuCostume methodsFor: 'events' stamp: 'ar 3/13/2004 20:08'!isMenuBar	^false! !!CMenuCostume methodsFor: 'events' stamp: 'ar 3/24/2004 18:40'!onLabelChanged	| aString |	<on: labelChanged in: player>	aString := player label.	menuLabel visible: aString notNil.	aString ifNotNil:[		menuLabel value: aString asText.	].! !!CMenuCostume methodsFor: 'events' stamp: 'ar 3/13/2004 22:38'!onLabelDrag	"Allow dragging this menu when we click in its label"	<on: mouseDown in: menuLabel>	self onDrag.	self sticky ifFalse:[self hand mouseFocus: self].! !!CMenuCostume methodsFor: 'events' stamp: 'ar 3/13/2004 20:25'!onMenuCursorChanged	| selected |	<on: menuCursorChanged>	self sticky ifFalse:[self hand mouseFocus: self].	selected := self selectedPlayer.	selected ifNotNil:[selected deselect].	selected := self menuSelection.	selected ifNotNil:[selected select].	self selectedPlayer: selected.	self updateSelectionSubMenu: selected.! !!CMenuCostume methodsFor: 'events' stamp: 'ar 3/24/2004 18:11'!onMenuItemsChanged	<on: menuItemsChanged in: player>	holder removeAll.	holder addAll: (player menuItems collect:[:each| self asMenuItemCostume: each]).! !!CMenuCostume methodsFor: 'events' stamp: 'ar 3/13/2004 18:41'!onMouseDown	<on: mouseDown>	"Check if the user clicked outside this menu"	(self containsPoint: self cursorPoint) ifFalse:[		self hand releaseMouseFocus: self.		self sticky ifFalse:[^self destroy]. "bump me"		^self].! !!CMenuCostume methodsFor: 'events' stamp: 'ar 3/24/2004 18:08'!onMouseMove	| item parent selected |	<on: mouseMove>	parent := self activeParentMenu.	parent ifNotNil:[		"Allow the parent to track the menu instead.		If this results in a different selection, I will be closed."		^parent onMouseMove].	item := holder findPlayerAt: holder cursorPoint.	item ifNotNil:[item isSeparator ifTrue:[item := nil]]. "ignore separators"	item ifNil:[		"Be careful before not to close open sub-menus"		selected := self menuSelection.		(selected notNil and:[selected subMenu notNil]) ifTrue:[^self].	].	self menuCursor: (holder elements indexOf: item).! !!CMenuCostume methodsFor: 'events' stamp: 'ar 3/14/2004 15:36'!onMouseUp	<on: mouseUp>	self fireItem: self menuSelection.	self sticky ifFalse:[self hand mouseFocus: self].! !!CMenuCostume methodsFor: 'events' stamp: 'ar 3/24/2004 18:11'!onPlayerChanged	super onPlayerChanged.	self onMenuItemsChanged.	self onLabelChanged.	self menuCursor: 0.	self selectedPlayer: nil.! !!CMenuCostume methodsFor: 'events' stamp: 'ar 3/14/2004 15:37'!onYellowButtonDown	"Treat yellow equivalent to red since context menus are popped up that way"	<on: yellowButtonDown>	^self onMouseDown! !!CMenuCostume methodsFor: 'events' stamp: 'ar 3/14/2004 15:37'!onYellowButtonUp	"Treat yellow equivalent to red since context menus are popped up that way"	<on: yellowButtonUp>	^self onMouseUp! !!CMenuCostume methodsFor: 'events' stamp: 'ar 4/2/2004 15:00'!showSubMenu: item	| pos |	item enabled ifFalse:[^self].	self isMenuBar		ifTrue:[pos := item costume localBounds bottomLeft - (6@0)]		ifFalse:[pos := item costume localBounds topRight + (2@0)].	activeChild := item subMenu costume.	self activeChild activeParent: self.	self activeChild menuSelection: nil.	self activeChild fill: self fill.	self activeChild costume transform: item costume localToWorld.	self activeChild position: (item costume localToWorld: pos).	self world add: self activeChild.	self activeChild beOnScreen.! !!CMenuCostume methodsFor: 'events' stamp: 'ar 3/13/2004 20:25'!updateSelectionSubMenu: menuItem	"Update any child menus after menuItem was selected"	activeChild ifNotNil:[		"Close old child"		activeChild activeParent: nil.		activeChild menuCursor: 0.		activeChild destroy.		activeChild := nil.	].	"Show new submenu if present"	(menuItem isNil or:[menuItem subMenu isNil]) ifTrue:[^self].	self showSubMenu: menuItem.! !!CMenuBarCostume methodsFor: 'initialize' stamp: 'ar 4/30/2004 15:51'!setupCostume	"We want to use this menu as a menu bar.	This implies a slightly different setup."	super setupCostume.	borderWidth := 0.	holder layout		listDirection: #leftToRight;		wrapDirection: #none;		listCentering: #topLeft.	holder		hResizing: #spaceFill;		vResizing: #shrinkWrap.	self		dropShadowEnabled: false;		borderStyle: #none;		roundCorners: false.! !!CMenuBarCostume methodsFor: 'accessing' stamp: 'ar 3/24/2004 18:39'!asMenuItemCostume: menuItem	| item |	menuItem separator ifTrue:[		item := CMenuItemSeparator on: menuItem.	] ifFalse:[		item := CMenuItemCostume on: menuItem.		item subMenuMarker visible: false.		item checkMarker visible: false.		item hResizing: #shrinkWrap.		item roundCornerSpec: #(1 4).		item layoutInset: 16@2.	].	^item! !!CMenuBarCostume methodsFor: 'accessing' stamp: 'ar 3/13/2004 17:40'!sticky	^true! !!CMenuBarCostume methodsFor: 'accessing' stamp: 'ar 4/4/2004 18:51'!windowColor: aColor	fillColors := {Color white. (Color white mixed: 0.5 with: aColor)}.	borderWidth := 1.	borderStyle := #simple.	borderColor := aColor.! !!CMenuBarCostume methodsFor: 'events' stamp: 'ar 3/13/2004 17:55'!isMenuBar	^true! !!CMenuBarCostume methodsFor: 'events' stamp: 'ar 3/13/2004 18:43'!onMouseDown	| item |	item := self menuSelection ifNil:[^self].	item subMenu ifNotNil:[^self showSubMenu: item].! !!CMenuBarCostume methodsFor: 'events' stamp: 'ar 3/13/2004 18:04'!onMouseLeave	<on: mouseLeave>	self menuCursor: 0.! !!CMenuBarCostume methodsFor: 'events' stamp: 'ar 3/13/2004 20:26'!updateSelectionSubMenu: menuItem	"Only show a new submenu if a previous one was showing"	activeChild ifNil:[^self].	super updateSelectionSubMenu: menuItem.! !!CPushButtonCostume methodsFor: 'initialize' stamp: 'ar 3/7/2004 22:01'!defaultPlayer	^CPushButton! !!CPushButtonCostume methodsFor: 'initialize' stamp: 'tk 7/14/2004 11:28'!setupCostume	super setupCostume.	self textEnabled: true.	self borderStyle: #simple.	self borderWidth: 1.	self borderColor: CWidgetLibrary default frameColor.	self fillStyle: #verticalGradient.	self fillColors: CWidgetLibrary default gradientColors.	self textEmphasis: 1.	self extent: 80@20.	self asPrimCostume localCache: CFormCache new.! !!CPushButtonCostume methodsFor: 'events' stamp: 'ar 8/18/2004 13:01'!deselect	borderStyle := #simple.! !!CPushButtonCostume methodsFor: 'events' stamp: 'ar 8/18/2004 13:05'!onButtonStateChanged	"Update from my player's state"	player selected		ifTrue:[borderStyle := #inset]		ifFalse:[borderStyle := #simple].	player state == #disabled		ifTrue:[buttonLabel textColor: Color gray]		ifFalse:[buttonLabel textColor: Color black].	player state == #pressed ifTrue:[		borderStyle := #inset.		buttonLabel textOffset: 1.		buttonImage graphicOffset: 1.	] ifFalse:[		buttonLabel textOffset: 0.		buttonImage graphicOffset: 0.	].! !!CPushButtonCostume methodsFor: 'events' stamp: 'ar 8/18/2004 13:01'!onSelectedChanged	self onButtonStateChanged! !!CPushButtonCostume methodsFor: 'events' stamp: 'ar 8/18/2004 13:05'!select	borderStyle := #inset.! !!CPushButtonCostume methodsFor: 'accessing' stamp: 'ar 3/24/2004 00:05'!windowColor: aColor	super windowColor: aColor.	self fillColors: {Color white. aColor}.! !!CRadioButtonCostume methodsFor: 'accessing' stamp: 'ar 3/12/2004 16:34'!checkMark	"Answer the checkMark of the receiver"	<bewareOf: #checkMarkChanged>	^self propertyValueAt: #checkMark! !!CRadioButtonCostume methodsFor: 'accessing' stamp: 'ar 3/12/2004 16:34'!checkMark: aValue	"Modify the receiver's checkMark"	^self propertyValueAt: #checkMark put: aValue with: #checkMarkChanged! !!CRadioButtonCostume methodsFor: 'initialize' stamp: 'ar 3/30/2004 18:01'!initialize	super initialize.	self define: #checkMark as: CPlayer new.	self define: #buttonLabel as: CLabel new.! !!CRadioButtonCostume methodsFor: 'initialize' stamp: 'ar 4/30/2004 15:53'!setupCostume	"Initial tweaks which really should go away before too long"	super setupCostume.	self add: checkMark.	self add: buttonLabel.	self color: Color transparent.	self clipping: false.	buttonLabel clipping: false.	checkMark extent: 11@11.	checkMark text: 'q'.	checkMark textInset: -1.	checkMark textFont: (TextStyle named: 'WindowFont') defaultFont.	self layout: CTableLayout new.	self layout listDirection: #leftToRight.	self hResizing: #shrinkWrap; vResizing: #shrinkWrap.! !!CRadioButtonCostume methodsFor: 'events' stamp: 'ar 3/30/2004 18:16'!onSelectedChanged	"Update the receiver's appearance after the selected state has changed"	player selected		ifTrue:[checkMark text: 'Q']		ifFalse:[checkMark text: 'q'].! !!CScrollButtonCostume methodsFor: 'initialize' stamp: 'tk 7/14/2004 11:28'!setupCostume	super setupCostume.	self textEnabled: true.	self borderStyle: #raised.	self borderWidth: 1.	self borderColor: CWidgetLibrary default frameColor.	self fillStyle: #verticalGradient.	self fillColors: CWidgetLibrary default gradientColors.	self textEmphasis: 1.	self extent: 80@20.	self asPrimCostume localCache: CFormCache new.! !!CScrollButtonCostume methodsFor: 'accessing' stamp: 'ar 3/26/2004 20:56'!windowColor: aColor	super windowColor: aColor.	self fillColors: {Color white. aColor}.! !!CScrollButtonCostume methodsFor: 'events' stamp: 'ar 3/26/2004 20:58'!deselect	borderStyle := #raised.	buttonLabel textOffset: 0.	buttonImage graphicOffset: 0.! !!CScrollButtonCostume methodsFor: 'events' stamp: 'ar 3/26/2004 20:56'!onButtonStateChanged	"Update from my player's state"	player state == #normal ifTrue:[^self deselect].	player state == #over ifTrue:[^self deselect].	player state == #pressed ifTrue:[^self select].! !!CScrollButtonCostume methodsFor: 'events' stamp: 'ar 3/26/2004 20:56'!select	borderStyle := #inset.	buttonLabel textOffset: 1.	buttonImage graphicOffset: 1.! !!CScrollableCostume methodsFor: 'initialize' stamp: 'ar 3/24/2004 23:09'!initialize	super initialize.	self define: #hScrollBar as: CScrollBar new.	self define: #vScrollBar as: CScrollBar new.	self initializeDefaultScrollTarget.! !!CScrollableCostume methodsFor: 'initialize' stamp: 'ar 3/24/2004 23:19'!initializeDefaultScrollTarget	"Initialize the default scroll target if one is needed"	self define: #scrollTarget as: CPlayer new.! !!CScrollableCostume methodsFor: 'initialize' stamp: 'ar 4/30/2004 15:53'!setupCostume	super setupCostume.	self hResizing: #spaceFill; vResizing: #spaceFill.	self add: hScrollBar.	hScrollBar orientation: #horizontal; height: hScrollBar buttonHeight asPoint y.	self add: vScrollBar.	vScrollBar orientation: #vertical; width: hScrollBar buttonHeight asPoint x.	scrollTarget ifNotNil:[		scrollTarget color: Color transparent.		self add: scrollTarget].! !!CScrollableCostume methodsFor: 'accessing' stamp: 'ar 3/24/2004 22:57'!hScrollBar	"Answer the hScrollBar of the receiver"	<bewareOf: #hScrollBarChanged>	^self propertyValueAt: #hScrollBar! !!CScrollableCostume methodsFor: 'accessing' stamp: 'ar 3/24/2004 22:57'!hScrollBar: aValue	"Modify the receiver's hScrollBar"	^self propertyValueAt: #hScrollBar put: aValue with: #hScrollBarChanged! !!CScrollableCostume methodsFor: 'accessing' stamp: 'ar 9/8/2004 22:57'!layout	^scrollTarget layout! !!CScrollableCostume methodsFor: 'accessing' stamp: 'ar 9/8/2004 22:57'!layout: aLayout	^scrollTarget layout: aLayout! !!CScrollableCostume methodsFor: 'accessing' stamp: 'ar 8/3/2004 20:07'!scrollOffset	^scrollTarget scrollOffset! !!CScrollableCostume methodsFor: 'accessing' stamp: 'ar 8/3/2004 20:07'!scrollOffset: aPoint	scrollTarget scrollOffset: aPoint.! !!CScrollableCostume methodsFor: 'accessing' stamp: 'ar 3/24/2004 22:59'!scrollTarget	"Answer the scrollTarget of the receiver"	<bewareOf: #scrollTargetChanged>	^self propertyValueAt: #scrollTarget! !!CScrollableCostume methodsFor: 'accessing' stamp: 'ar 3/24/2004 22:59'!scrollTarget: aValue	"Modify the receiver's scrollTarget"	^self propertyValueAt: #scrollTarget put: aValue with: #scrollTargetChanged! !!CScrollableCostume methodsFor: 'accessing' stamp: 'ar 3/24/2004 22:57'!vScrollBar	"Answer the vScrollBar of the receiver"	<bewareOf: #vScrollBarChanged>	^self propertyValueAt: #vScrollBar! !!CScrollableCostume methodsFor: 'accessing' stamp: 'ar 3/24/2004 22:57'!vScrollBar: aValue	"Modify the receiver's vScrollBar"	^self propertyValueAt: #vScrollBar put: aValue with: #vScrollBarChanged! !!CScrollableCostume methodsFor: 'accessing' stamp: 'ar 3/24/2004 22:57'!windowColor: aColor	super windowColor: aColor.	hScrollBar windowColor: aColor.	vScrollBar windowColor: aColor.! !!CScrollableCostume methodsFor: 'events' stamp: 'ar 3/25/2004 19:54'!onContextMenu	| aMenu |	<on: yellowButtonDown>	player ifNil:[^self].	aMenu := player menu ifNil:[^self].	aMenu openAt: hand position.! !!CScrollableCostume methodsFor: 'events' stamp: 'ar 3/24/2004 22:57'!onHScrollableChanged	<on: hScrollableChanged in: player>	player hScrollable == true		ifTrue:[hScrollBar visible: true].	player hScrollable == false		ifTrue:[hScrollBar visible: false].	self onUpdateScrollRange.	self onUpdateLayout.! !!CScrollableCostume methodsFor: 'events' stamp: 'ar 3/24/2004 23:05'!onPlayerChanged	super onPlayerChanged.	self onScrollTargetChanged.	self onHScrollableChanged.	self onVScrollableChanged.	self onUpdateScrollRange.	self onUpdateLayout.! !!CScrollableCostume methodsFor: 'events' stamp: 'ar 3/24/2004 23:02'!onScrollAbsoluteX	<on: valueChanged in: hScrollBar>	scrollTarget ifNil:[^self].	self pauseScript: #onScrollOffsetChanged.	scrollTarget scrollOffset: hScrollBar value @ scrollTarget scrollOffset y.	self resumeScript: #onScrollOffsetChanged.! !!CScrollableCostume methodsFor: 'events' stamp: 'ar 3/24/2004 23:03'!onScrollAbsoluteY	<on: valueChanged in: vScrollBar>	scrollTarget ifNil:[^self].	self pauseScript: #onScrollOffsetChanged.	scrollTarget scrollOffset: scrollTarget scrollOffset x @ vScrollBar value.	self resumeScript: #onScrollOffsetChanged.! !!CScrollableCostume methodsFor: 'events' stamp: 'ar 3/25/2004 15:56'!onScrollOffsetChanged	"Someone scrolled my target programmatically"	<on: scrollOffsetChanged in: scrollTarget>	"This is inefficient, but what the hey..."	self onUpdateScrollRange.! !!CScrollableCostume methodsFor: 'events' stamp: 'ar 3/24/2004 23:06'!onScrollTargetChanged	"If needed, subclasses can insert the appropriate update for a potential change in the scroll target."! !!CScrollableCostume methodsFor: 'events' stamp: 'ar 3/24/2004 22:57'!onVScrollableChanged	<on: vScrollableChanged in: player>	player vScrollable == true		ifTrue:[vScrollBar visible: true].	player vScrollable == false		ifTrue:[vScrollBar visible: false].	self onUpdateScrollRange.	self onUpdateLayout.! !!CScrollableCostume methodsFor: 'layout' stamp: 'ar 3/24/2004 22:57'!onUpdateLayout	"update the position of all the elements"	| inset box |	<on: layoutChanged>	box := self costume innerBounds.	inset := 0@0.	hScrollBar visible ifTrue:[inset := inset x @ hScrollBar height].	vScrollBar visible ifTrue:[inset := vScrollBar width @ inset y].	self positionTarget: inset in: box.	hScrollBar visible ifTrue:[self positionHScrollBar: inset in: box].	vScrollBar visible ifTrue:[self positionVScrollBar: inset in: box].! !!CScrollableCostume methodsFor: 'layout' stamp: 'ar 3/26/2004 00:37'!onUpdateScrollRange	"update the scroll range of my scroll bars"	| visibleArea targetArea scrollExtent visibleExtent delta leftOver visibleFraction offset showScrollBar |	<on: layoutChanged in: scrollTarget>	offset := scrollTarget scrollOffset.	delta := scrollTarget scrollDelta.	targetArea := scrollTarget scrollArea.	visibleArea := scrollTarget visibleScrollArea.	"Truncate scrollArea to scrollDelta"	scrollExtent := targetArea extent.	visibleExtent := visibleArea extent.	"make sure we don't divide by zero"	scrollExtent := scrollExtent max: 1@1.	visibleExtent := visibleExtent max: 1@1.	"compute the visible fraction"	visibleFraction := (visibleExtent / scrollExtent) asFloatPoint.	visibleFraction := visibleFraction max: 0@0.	visibleFraction := visibleFraction min: 1@1.	"compute left over area rounded up to scroll delta"	leftOver := scrollExtent - visibleExtent.	"make sure it's not negative"	leftOver := leftOver max: 0@0.	hScrollBar min: targetArea left.	hScrollBar max: leftOver x.	hScrollBar value: offset x.	hScrollBar step: delta x.	hScrollBar pageStep: visibleExtent x.	hScrollBar visibleFraction: visibleFraction x.	player hScrollable isNil ifTrue:[		showScrollBar := visibleFraction x < 1.0.		showScrollBar = hScrollBar visible ifFalse:[			hScrollBar visible: showScrollBar.			self onUpdateLayout]].	vScrollBar min: targetArea top.	vScrollBar max: leftOver y.	vScrollBar value: offset y.	vScrollBar step: delta y.	vScrollBar pageStep: visibleExtent y.	vScrollBar visibleFraction: visibleFraction y.	player vScrollable isNil ifTrue:[		showScrollBar := visibleFraction y < 1.0.		showScrollBar = vScrollBar visible ifFalse:[			vScrollBar visible: showScrollBar.			self onUpdateLayout]].! !!CScrollableCostume methodsFor: 'layout' stamp: 'ar 3/24/2004 22:57'!positionHScrollBar: inset in: box	"position my hScrollBar within the box"	hScrollBar left: box left.	hScrollBar top: box bottom - inset y.	hScrollBar width: box width - inset x.	hScrollBar height: inset y.! !!CScrollableCostume methodsFor: 'layout' stamp: 'ar 3/24/2004 23:00'!positionTarget: inset in: box	"position my target within the box"	scrollTarget ifNil:[^self].	scrollTarget left: box left.	scrollTarget top: box top.	scrollTarget extent: box extent - inset.! !!CScrollableCostume methodsFor: 'layout' stamp: 'ar 3/24/2004 22:57'!positionVScrollBar: inset in: box	"position my vScrollBar within the box"	vScrollBar left: box right - inset x.	vScrollBar top: box top.	vScrollBar width: inset x.	vScrollBar height: box height - inset y.! !!CCustomDrawListCostume methodsFor: 'initialize' stamp: 'ar 2/29/2004 22:34'!initialize	super initialize.	self selectionIndex: 0.! !!CCustomDrawListCostume methodsFor: 'initialize' stamp: 'ar 3/25/2004 11:37'!initializeDefaultScrollTarget	"Initialize the default scroll target if one is needed"	self define: #scrollTarget as: CCustomDrawListTarget new.! !!CCustomDrawListCostume methodsFor: 'initialize' stamp: 'ar 4/30/2004 15:49'!setupCostume	super setupCostume.	scrollTarget userDraw: true.	scrollTarget scrollDelta: 1@self itemHeight.	scrollTarget list: self.! !!CCustomDrawListCostume methodsFor: 'accessing' stamp: 'ar 2/18/2004 11:23'!cursor	^self player cursor! !!CCustomDrawListCostume methodsFor: 'accessing' stamp: 'ar 2/18/2004 11:31'!cursor: newCursor	^self player cursor: newCursor! !!CCustomDrawListCostume methodsFor: 'accessing' stamp: 'ar 3/24/2004 23:17'!itemHeight	^self playerFont height + 4! !!CCustomDrawListCostume methodsFor: 'accessing' stamp: 'ar 3/24/2004 23:16'!playerFont	^self player font ifNil:[TextStyle defaultFont]! !!CCustomDrawListCostume methodsFor: 'accessing' stamp: 'ar 3/19/2004 13:33'!selectionColor	"This method was automatically generated"	<bewareOf: #selectionColorChanged>	^(self propertyValueAt: #selectionColor) ifNil:[CWidgetLibrary default baseColor]! !!CCustomDrawListCostume methodsFor: 'accessing' stamp: 'ar 3/19/2004 13:33'!selectionColor: aValue	"This method was automatically generated"	^self propertyValueAt: #selectionColor put: aValue with: #selectionColorChanged! !!CCustomDrawListCostume methodsFor: 'accessing' stamp: 'ar 3/19/2004 13:33'!selectionIndex	"This method was automatically generated"	<bewareOf: #selectionIndexChanged>	^self propertyValueAt: #selectionIndex! !!CCustomDrawListCostume methodsFor: 'accessing' stamp: 'ar 3/19/2004 13:33'!selectionIndex: aValue	"This method was automatically generated"	^self propertyValueAt: #selectionIndex put: aValue with: #selectionIndexChanged! !!CCustomDrawListCostume methodsFor: 'accessing' stamp: 'ar 3/24/2004 00:05'!windowColor: aColor	super windowColor: aColor.	self selectionColor: aColor.	self invalidate.! !!CCustomDrawListCostume methodsFor: 'selecting' stamp: 'ar 2/18/2004 11:33'!cursorFromPoint: targetPoint	targetPoint y < 0 ifTrue:[^nil].	targetPoint y >= (self player size * self itemHeight) ifTrue:[^nil].	^targetPoint y // self itemHeight + 1! !!CCustomDrawListCostume methodsFor: 'selecting' stamp: 'ar 2/18/2004 12:23'!deselectIndex: index	index = 0 ifFalse:[self invalidate: (self invalidationRect: index)].! !!CCustomDrawListCostume methodsFor: 'selecting' stamp: 'ar 3/24/2004 23:12'!invalidationRect: index	"Answer the rectangle for drawing the item at index"	^(self selectionRect: index) translateBy: scrollTarget scrollOffset negated! !!CCustomDrawListCostume methodsFor: 'selecting' stamp: 'ar 3/24/2004 23:12'!scrollToSelection: idx	"Make the current selection visible"	idx = 0 ifTrue:[^self].	scrollTarget scrollToShow: ((self selectionRect: idx) translateBy: scrollTarget origin negated).! !!CCustomDrawListCostume methodsFor: 'selecting' stamp: 'ar 2/18/2004 12:22'!selectIndex: index	index = 0 ifFalse:[self invalidate: (self invalidationRect: index)]! !!CCustomDrawListCostume methodsFor: 'selecting' stamp: 'ar 3/24/2004 23:13'!selectionRect: index	"Answer the rectangle for drawing the item at index"	| box |	box := scrollTarget bounds.	^box left @ (index-1*self itemHeight + box top) extent: box width @ self itemHeight.! !!CCustomDrawListCostume methodsFor: 'drawing' stamp: 'ar 2/18/2004 11:24'!drawItem: index in: itemBox on: aCanvas	^self subclassResponsibility! !!CCustomDrawListCostume methodsFor: 'drawing' stamp: 'ar 3/27/2004 20:54'!drawListOn: aCanvas in: drawingBounds	"Draw the receiver"	| firstIndex lastIndex box localBox itemHeight visibleArea myCursor |	myCursor := self cursor.	itemHeight := self itemHeight.	box := drawingBounds.	visibleArea := (box  intersect: aCanvas clipRect).	firstIndex := (visibleArea top // itemHeight) max: 1.	lastIndex := (visibleArea bottom // itemHeight) + 1 min: self player size.	firstIndex to: lastIndex do:[:i|		localBox := box left @ (i-1*itemHeight) extent: box width @ itemHeight.		i = myCursor ifTrue:[self drawSelectionIn: localBox on: aCanvas].		self drawItem: i in: localBox on: aCanvas.	].! !!CCustomDrawListCostume methodsFor: 'drawing' stamp: 'ar 3/25/2004 12:47'!drawOn: aCanvas in: drawingBounds	^self drawListOn: aCanvas in: drawingBounds! !!CCustomDrawListCostume methodsFor: 'drawing' stamp: 'ar 3/6/2004 20:41'!drawSelectionIn: itemBox on: aCanvas	aCanvas fillRectangle: itemBox color: self selectionColor! !!CCustomDrawListCostume methodsFor: 'events' stamp: 'ar 3/7/2004 02:13'!onCursorChanged	<on: cursorChanged in: player>	self deselectIndex: self selectionIndex.	self selectionIndex: self cursor.	self selectIndex: self selectionIndex.	self scrollToSelection: self selectionIndex.! !!CCustomDrawListCostume methodsFor: 'events' stamp: 'ar 3/24/2004 23:11'!onElementsChanged: typeOfChange from: firstIndex to: lastIndex event: thisEvent	<on: changed in: player>	scrollTarget invalidate.	scrollTarget scrollOffset: 0@0.	self onUpdateScrollRange.! !!CCustomDrawListCostume methodsFor: 'events' stamp: 'ar 2/18/2004 11:31'!onKeyDown: event	"React to a key event"	| keyEvent |	<on: #keyDown>	keyEvent := event keyValue.	"Basic cursor key navigation"	keyEvent == 1 		ifTrue: [^self cursor: 1].  "home"	keyEvent == 4 		ifTrue: [^self cursor: self size].   "end"	(keyEvent == 31 and:[self cursor < self player size])		ifTrue:[self cursor: self cursor + 1]. "down"	(keyEvent == 30 and:[self cursor > 1])		ifTrue:[self cursor: self cursor - 1]. "up"! !!CCustomDrawListCostume methodsFor: 'events' stamp: 'ar 3/25/2004 12:32'!onMouseDown	"React to a mouse event"	| idx |	<on: mouseDown in: scrollTarget>	"Figure out the selection"	idx := self cursorFromPoint: scrollTarget cursorPoint.	idx ifNil:[^self].	"And set newly selected player"	player allowDeselect ifTrue:[		self cursor = idx ifTrue:[^self cursor: 0].	].	self cursor: idx.! !!CCustomDrawListCostume methodsFor: 'events' stamp: 'ar 3/6/2004 20:38'!onPlayerChanged	super onPlayerChanged.	self invalidate.! !!CCustomDrawListCostume methodsFor: 'events' stamp: 'ar 3/24/2004 23:12'!onUpdateScrollRange	scrollTarget scrollArea: (0@0 extent: scrollTarget width @ (self player size * self itemHeight)).	super onUpdateScrollRange! !!CListCostume methodsFor: 'initialize' stamp: 'ar 4/3/2004 20:10'!defaultPlayer	^CList! !!CListCostume methodsFor: 'initialize' stamp: 'ar 4/30/2004 15:51'!setupCostume	super setupCostume.	scrollTarget layout: CTableLayout new.	scrollTarget layout cellPositioning: #topLeft.! !!CListCostume methodsFor: 'accessing' stamp: 'ar 3/24/2004 23:18'!selectedPlayer	"This method was automatically generated"	<bewareOf: #selectedPlayerChanged>	^self propertyValueAt: #selectedPlayer! !!CListCostume methodsFor: 'accessing' stamp: 'ar 3/24/2004 23:18'!selectedPlayer: aValue	"This method was automatically generated"	^self propertyValueAt: #selectedPlayer put: aValue with: #selectedPlayerChanged! !!CListCostume methodsFor: 'events' stamp: 'ar 3/25/2004 00:13'!onCursorChanged	| selected |	<on: cursorChanged in: player>	selected := self selectedPlayer.	selected ifNotNil:[selected deselect].	player cursor > 0		ifTrue:[selected := scrollTarget elements at: player cursor]		ifFalse:[selected := nil].	self selectedPlayer: selected.	selected ifNotNil:[		selected select.		scrollTarget scrollToShow: selected.	].! !!CListCostume methodsFor: 'events' stamp: 'ar 3/31/2004 16:38'!onElementsChanged	| item itemMaker |	<on: changed in: player>	itemMaker := player itemMaker ifNil:[CListItem].	scrollTarget elements: (player elements collect:[:each|		item := itemMaker new.		item listItemValue: each. "see comment in listItemValue:"		item]).	self onCursorChanged.! !!CListCostume methodsFor: 'events' stamp: 'ar 3/24/2004 23:22'!onItemMakerChanged	<on: itemMakerChanged in: player>	self onElementsChanged.! !!CListCostume methodsFor: 'events' stamp: 'ar 3/25/2004 20:16'!onKeyDown: event	"React to a key event"	| keyEvent |	<on: #keyDown>	keyEvent := event keyValue.	"Basic cursor key navigation"	keyEvent == 1 		ifTrue: [^player cursor: 1].  "home"	keyEvent == 4 		ifTrue: [^player cursor: player size].   "end"	(keyEvent == 31)		ifTrue:[player next]. "down"	(keyEvent == 30)		ifTrue:[player prev]. "up"! !!CListCostume methodsFor: 'events' stamp: 'ar 3/25/2004 11:15'!onMouseDown	"React to a mouse event"	| selected idx |	<on: mouseDown>	"Figure out the selection"	selected := scrollTarget findPlayerAt: scrollTarget cursorPoint.	selected ifNil:[^self].	idx := scrollTarget elements indexOf: selected.	player allowDeselect ifTrue:[		player cursor = idx ifTrue:[^player cursor: 0].	].	"And set newly selected player"	player cursor: idx.! !!CListCostume methodsFor: 'events' stamp: 'ar 3/25/2004 00:14'!onPlayerChanged	super onPlayerChanged.	self selectedPlayer: nil.	self onElementsChanged.! !!CMultiColumnListCostume methodsFor: 'initialize' stamp: 'ar 4/2/2004 14:52'!buildHeader	"WARNING: UNFINISHED!!"	| holder button aColor action |	aColor := (Color r: 0.9 g: 0.95 b: 0.9).	holder := CPlayer new.	(holder costume) 		layout: CTableLayout new;		listDirection: #leftToRight.	holder		hResizing: #spaceFill;		vResizing: #shrinkWrap.	holder		color: aColor;		border: (CBorder inset width: 2);		extent: 2@2.	columns do:[:colSpec|		button := CButton new.		button label: colSpec label.		action := colSpec action.		action ifNotNil:[			action receiver 				startScript: action selector 				withArguments: action arguments				when: {button. #fire}.		].		(button costume)			width: colSpec width;			roundCorners: false;			color: aColor;			border: (CBorder raised width: 1).		holder costume add: button costume.	].	button := CPlayer new.	button extent: 2@2.	button		color: aColor;		border: (CBorder raised width: 1).	holder costume add: button costume.		^holder! !!CMultiColumnListCostume methodsFor: 'accessing' stamp: 'ar 3/12/2004 21:37'!columns	^player columns! !!CMultiColumnListCostume methodsFor: 'accessing' stamp: 'ar 3/12/2004 21:37'!columns: aCollection	^player columns: aCollection! !!CMultiColumnListCostume methodsFor: 'accessing' stamp: 'ar 3/12/2004 14:05'!header	"Answer the header of the receiver"	<bewareOf: #headerChanged>	^self propertyValueAt: #header! !!CMultiColumnListCostume methodsFor: 'accessing' stamp: 'ar 3/12/2004 10:54'!header: aValue	"Modify the receiver's header"	^self propertyValueAt: #header put: aValue with: #headerChanged! !!CMultiColumnListCostume methodsFor: 'drawing' stamp: 'ar 3/27/2004 20:58'!drawBackgroundStripesOn: aCanvas in: box	"Draw the background column stripes"	| leftX colWidth colColor |	leftX := 0.	columns do:[:colSpec|		colWidth := colSpec width.		colColor := colSpec color.		colColor ifNotNil:[			aCanvas 				fillRectangle: (leftX@box top extent: colWidth@box height) 				color: colColor].		leftX := leftX + colWidth.		leftX > box right ifTrue:[^self].	].! !!CMultiColumnListCostume methodsFor: 'drawing' stamp: 'ar 3/27/2004 20:56'!drawItem: index in: itemBox on: aCanvas	| item itemColor boxOrigin boxCorner itemWidth itemHeight args drawSelector drawer |	item := player at: index.	itemColor := index = selectionIndex 			ifTrue:[Color white] 			ifFalse:[Color black].	boxOrigin := itemBox origin + (5@1).	boxCorner := itemBox corner - (0@1).	itemHeight := boxCorner y - boxOrigin y.	args := Array with: item with: nil with: aCanvas with: self playerFont with: itemColor.	columns do:[:colSpec|		boxOrigin x > boxCorner x ifTrue:[^self].		itemWidth := colSpec width.		drawSelector := colSpec drawSelector.		args at: 2 put: (boxOrigin extent: itemWidth - 10 @ itemHeight).		drawer := colSpec drawer.		(drawer == nil or:[drawSelector == nil]) 			ifFalse:[drawer perform: drawSelector withArguments: args].		boxOrigin := boxOrigin + (itemWidth @ 0).	].! !!CMultiColumnListCostume methodsFor: 'drawing' stamp: 'ar 3/12/2004 21:51'!drawListOn: aCanvas in: drawingBounds	"Draw the receiver"	self drawBackgroundStripesOn: aCanvas in: drawingBounds.	super drawListOn: aCanvas in: drawingBounds.! !!CScrollPaneCostume methodsFor: 'initialize' stamp: 'ar 3/7/2004 22:01'!defaultPlayer	^CScrollPane! !!CScrollPaneCostume methodsFor: 'initialize' stamp: 'ar 3/24/2004 23:19'!initializeDefaultScrollTarget	"We don't want a default target since our player will provide the holder to use for this scrollpane"! !!CScrollPaneCostume methodsFor: 'events' stamp: 'ar 3/26/2004 04:19'!onHolderChanged	| oldHolder newHolder |	<on: holderChanged in: player>	oldHolder := scrollTarget.	newHolder := player holder ifNil:[CHolder new].	oldHolder == newHolder ifTrue:[^self].	elements replace: oldHolder with: newHolder.	scrollTarget := newHolder.! !!CScrollPaneCostume methodsFor: 'events' stamp: 'ar 3/24/2004 23:06'!onScrollTargetChanged	self onHolderChanged.! !!CScrollableTextEditorCostume methodsFor: 'initialize' stamp: 'ar 3/25/2004 16:24'!defaultColor	^Color transparent.! !!CScrollableTextEditorCostume methodsFor: 'initialize' stamp: 'ar 3/25/2004 15:51'!defaultPlayer	^CTextEditor! !!CScrollableTextEditorCostume methodsFor: 'initialize' stamp: 'ar 4/30/2004 15:53'!setupCostume	super setupCostume.	scrollTarget borderColor: Color transparent.! !!CScrollableTextEditorCostume methodsFor: 'accessing' stamp: 'ar 3/25/2004 15:50'!textHolder	^scrollTarget textHolder! !!CScrollableTextEditorCostume methodsFor: 'events' stamp: 'ar 5/19/2004 15:13'!onPlayerChanged	"scrollTarget player: player."	scrollTarget := player target.	super onPlayerChanged.! !!CSliderCostume methodsFor: 'initialize' stamp: 'ar 3/7/2004 22:01'!defaultPlayer	^CSlider! !!CSliderCostume methodsFor: 'accessing' stamp: 'ar 2/13/2004 21:23'!adoptValue: newValue	^self player adoptValue: newValue! !!CSliderCostume methodsFor: 'accessing' stamp: 'ar 2/13/2004 21:23'!fraction	^self player fraction! !!CSliderCostume methodsFor: 'accessing' stamp: 'ar 2/13/2004 21:22'!max	^self player max! !!CSliderCostume methodsFor: 'accessing' stamp: 'ar 2/13/2004 21:23'!max: aValue	self player max: aValue! !!CSliderCostume methodsFor: 'accessing' stamp: 'ar 2/13/2004 21:23'!min	^self player min! !!CSliderCostume methodsFor: 'accessing' stamp: 'ar 2/13/2004 21:23'!min: aValue	^self player min: aValue! !!CSliderCostume methodsFor: 'accessing' stamp: 'ar 2/13/2004 21:23'!orientation	^self player orientation! !!CSliderCostume methodsFor: 'accessing' stamp: 'ar 2/13/2004 21:23'!orientation: aSymbol	self player orientation: aSymbol! !!CSliderCostume methodsFor: 'accessing' stamp: 'ar 2/26/2004 16:50'!pageStep	^self player pageStep! !!CSliderCostume methodsFor: 'accessing' stamp: 'ar 2/13/2004 21:23'!pageStep: aNumber	self player pageStep: aNumber! !!CSliderCostume methodsFor: 'accessing' stamp: 'ar 2/13/2004 21:22'!range	^self player range! !!CSliderCostume methodsFor: 'accessing' stamp: 'ar 2/13/2004 21:23'!step	^self player step! !!CSliderCostume methodsFor: 'accessing' stamp: 'ar 2/13/2004 21:23'!step: aValue	^self player step: aValue! !!CSliderCostume methodsFor: 'accessing' stamp: 'ar 2/13/2004 21:22'!visibleFraction	^self player visibleFraction! !!CSliderCostume methodsFor: 'accessing' stamp: 'ar 2/13/2004 21:23'!visibleFraction: newFraction	self player visibleFraction: newFraction! !!CSliderCostume methodsFor: 'testing' stamp: 'ar 2/9/2004 18:52'!isHorizontal	self orientation ifNil:[^self width >= self height].	^self orientation == #horizontal.! !!CScrollBarCostume methodsFor: 'initialize' stamp: 'ar 3/7/2004 22:01'!defaultPlayer	^CScrollBar! !!CScrollBarCostume methodsFor: 'initialize' stamp: 'ar 3/17/2004 03:15'!initialize	super initialize.	self define: #knobShadow as: CPlayer new.	self define: #forwardButton as: CPushButton new.	self define: #backButton as: CPushButton new.	self define: #knob as: CPlayer new.! !!CScrollBarCostume methodsFor: 'initialize' stamp: 'tk 7/14/2004 11:28'!setupCostume	super setupCostume.	self asPrimCostume localCache: CFormCache new.	self add: knobShadow.	knobShadow visible: false.	knobShadow color: Color veryLightGray.	knobShadow borderStyle: #inset.	knobShadow borderWidth: 1.	self add: knob.	knob borderStyle: #raised.	knob borderWidth: 1.	knob fillStyle: #verticalGradient.	knob fillColors: CWidgetLibrary default gradientColors.	forwardButton costume: CScrollButtonCostume new.	forwardButton font: (TextStyle named:'WindowFont') defaultFont.	self add: forwardButton.	backButton costume: CScrollButtonCostume new.	backButton font: (TextStyle named:'WindowFont') defaultFont.	self add: backButton.! !!CScrollBarCostume methodsFor: 'accessing' stamp: 'ar 3/12/2004 16:29'!backButton	"Answer the backButton of the receiver"	<bewareOf: #backButtonChanged>	^self propertyValueAt: #backButton! !!CScrollBarCostume methodsFor: 'accessing' stamp: 'ar 3/12/2004 16:29'!backButton: aValue	"Modify the receiver's backButton"	^self propertyValueAt: #backButton put: aValue with: #backButtonChanged! !!CScrollBarCostume methodsFor: 'accessing' stamp: 'ar 2/13/2004 21:24'!buttonHeight	^self player buttonHeight! !!CScrollBarCostume methodsFor: 'accessing' stamp: 'ar 2/13/2004 21:24'!buttonHeight: aNumber	self player buttonHeight: aNumber! !!CScrollBarCostume methodsFor: 'accessing' stamp: 'ar 3/12/2004 16:29'!forwardButton	"Answer the forwardButton of the receiver"	<bewareOf: #forwardButtonChanged>	^self propertyValueAt: #forwardButton! !!CScrollBarCostume methodsFor: 'accessing' stamp: 'ar 3/12/2004 16:29'!forwardButton: aValue	"Modify the receiver's forwardButton"	^self propertyValueAt: #forwardButton put: aValue with: #forwardButtonChanged! !!CScrollBarCostume methodsFor: 'accessing' stamp: 'ar 2/9/2004 17:58'!innerBounds	"Answer the inner bounds for positioning the knob"	self isHorizontal		ifTrue:[^backButton topRight corner: forwardButton bottomLeft]		ifFalse:[^backButton bottomLeft corner: forwardButton topRight].! !!CScrollBarCostume methodsFor: 'accessing' stamp: 'ar 3/12/2004 16:29'!knob	"Answer the knob of the receiver"	<bewareOf: #knobChanged>	^self propertyValueAt: #knob! !!CScrollBarCostume methodsFor: 'accessing' stamp: 'ar 3/12/2004 16:29'!knob: aValue	"Modify the receiver's knob"	^self propertyValueAt: #knob put: aValue with: #knobChanged! !!CScrollBarCostume methodsFor: 'accessing' stamp: 'ar 3/12/2004 16:29'!knobShadow	"Answer the knobShadow of the receiver"	<bewareOf: #knobShadowChanged>	^self propertyValueAt: #knobShadow! !!CScrollBarCostume methodsFor: 'accessing' stamp: 'ar 3/12/2004 16:29'!knobShadow: aValue	"Modify the receiver's knobShadow"	^self propertyValueAt: #knobShadow put: aValue with: #knobShadowChanged! !!CScrollBarCostume methodsFor: 'accessing' stamp: 'ar 3/24/2004 00:06'!windowColor: aColor	super windowColor: aColor.	forwardButton windowColor: aColor.	backButton windowColor: aColor.	knob windowColor: aColor.	knob fillColors: {Color white. aColor}.! !!CScrollBarCostume methodsFor: 'testing' stamp: 'ar 2/8/2004 20:26'!isHorizontal	self orientation ifNil:[^self width >= self height].	^self orientation == #horizontal.! !!CScrollBarCostume methodsFor: 'events' stamp: 'ar 2/13/2004 21:30'!onButtonHeightChanged	<on: buttonHeightChanged in: player>	self onUpdateScrollBar.	self onExtentChanged.! !!CScrollBarCostume methodsFor: 'events' stamp: 'ar 2/9/2004 17:47'!onExtentChanged	<on: extentChanged>	self isHorizontal 		ifTrue:[self height: self buttonHeight asPoint y]		ifFalse:[self width: self buttonHeight asPoint x]! !!CScrollBarCostume methodsFor: 'events' stamp: 'ar 2/13/2004 21:30'!onMaxChanged	<on: maxChanged in: player>	self onValueChanged.	self onUpdateScrollBar.! !!CScrollBarCostume methodsFor: 'events' stamp: 'ar 2/13/2004 21:30'!onMinChanged	<on: minChanged in: player>	self onValueChanged.	self onUpdateScrollBar.! !!CScrollBarCostume methodsFor: 'events' stamp: 'ar 2/13/2004 21:30'!onOrientationChanged	<on: orientationChanged in: player>	self onUpdateScrollBar.! !!CScrollBarCostume methodsFor: 'events' stamp: 'ar 3/23/2004 23:36'!onScrollAbsolute	"Scroll to the given point (relative to the KnobHolder)"	| offset |	<on: mouseDown in: knob>	knobShadow bounds: knob bounds.	knobShadow visible: true.	offset := knob cursorPoint.	self hand forEach: #mouseMove do:[		self onScrollAbsolute: offset.	] until: #mouseUp.	knobShadow visible: false.! !!CScrollBarCostume methodsFor: 'events' stamp: 'ar 2/8/2004 20:30'!onScrollAbsolute: offset	"Scroll to the given point (relative to the KnobHolder)"	| innerRect innerPoint relativeValue absValue aPoint |	"Compute the inner rectangle for the slider"	innerRect := self innerBounds.	innerRect := innerRect insetBy: (0@0 extent: knob extent).	"Check if the knob is larger than the slider(huh!!)"	self isHorizontal		ifTrue: [innerRect width <= 0 ifTrue: [^ self]]		ifFalse: [innerRect height <= 0 ifTrue: [^ self]].	aPoint := self cursorPoint - offset.	"Make sure the point is within the inner rectangle,	and compute its offset from the top-left of the slider"	innerPoint := (aPoint adhereTo: innerRect) - innerRect topLeft.	"Compute the relative (fractional) value"	self isHorizontal		ifTrue:[relativeValue := innerPoint x / innerRect width]		ifFalse:[relativeValue := innerPoint y / innerRect height].	"Compute the absolute (rounded) value"	absValue := self min + (self range * relativeValue).	"And set my value appropriately"	self value: absValue.! !!CScrollBarCostume methodsFor: 'events' stamp: 'ar 2/8/2004 20:30'!onScrollBack	| scrollScript |	<on: mouseDown in: backButton>	scrollScript := self startScript:[self onScrollBy: self step negated].	self hand waitUntil: #mouseUp.	self stopScript: scrollScript.! !!CScrollBarCostume methodsFor: 'events' stamp: 'ar 2/8/2004 20:31'!onScrollBy: delta	| initialDelay finalDelay delayTime |	initialDelay := 400.	finalDelay := 20.	delayTime := initialDelay.	[true] whileTrue:[		self value: self value + delta.		(Delay forMilliseconds: delayTime) wait.		self waitTick.		"Decrease delay time to delay2"		delayTime := delayTime * 9 // 10 max: finalDelay.	].! !!CScrollBarCostume methodsFor: 'events' stamp: 'ar 3/26/2004 00:38'!onScrollByPage	| scrollScript delta oldFill pageDelta |	<on: mouseDown>	pageDelta := self pageStep.	pageDelta ifNil:[		self onScrollAbsolute: knob extent // 2.		self hand forEach: #mouseMove do:[			self onScrollAbsolute: knob extent // 2.		] until: #mouseUp.		^self].	"scroll by page"	self isHorizontal ifTrue:[		knob cursorPoint x < 0			ifTrue:[delta := pageDelta negated]			ifFalse:[delta := pageDelta].	] ifFalse:[		knob cursorPoint y < 0			ifTrue:[delta := pageDelta negated]			ifFalse:[delta := pageDelta].	].	oldFill := fill copy.	color := Color veryLightGray.	scrollScript := self startScript: [self onScrollByPage: delta].	hand waitUntil: #mouseUp.	self stopScript: scrollScript.	fill := oldFill.! !!CScrollBarCostume methodsFor: 'events' stamp: 'ar 3/26/2004 00:53'!onScrollByPage: delta	| initialDelay finalDelay delayTime startValue stopValue startTime stopTime nowTime fraction |	initialDelay := 400.	finalDelay := 20.	delayTime := initialDelay.	[true] whileTrue:[		startValue := self value.		stopValue := startValue + delta.		startTime := Time millisecondClockValue.		stopTime := startTime + delayTime.		[nowTime := Time millisecondClockValue.		nowTime < stopTime] whileTrue:[			fraction := (nowTime - startTime) / delayTime asFloat.			value := startValue + (delta * fraction).			self waitTick.		].		value := stopValue.		"Decrease delay time to delay2"		delayTime := delayTime * 9 // 10 max: finalDelay.	].! !!CScrollBarCostume methodsFor: 'events' stamp: 'ar 2/8/2004 20:33'!onScrollForward	| scrollScript |	<on: mouseDown in: forwardButton>	scrollScript := self startScript:[self onScrollBy: self step].	self hand waitUntil: #mouseUp.	self stopScript: scrollScript.! !!CScrollBarCostume methodsFor: 'events' stamp: 'ar 3/17/2004 17:34'!onValueChanged	<on: valueChanged>	self positionKnob.! !!CScrollBarCostume methodsFor: 'events' stamp: 'ar 2/13/2004 21:30'!onVisibleFractionChanged	<on: visibleFractionChanged in: player>	self onUpdateScrollBar.! !!CScrollBarCostume methodsFor: 'layout' stamp: 'ar 2/8/2004 20:38'!onLayoutChanged	<on: layoutChanged>	self onUpdateScrollBar.! !!CScrollBarCostume methodsFor: 'layout' stamp: 'ar 3/23/2004 23:36'!onUpdateScrollBar	"Re-arrange my contents when the layout changes"	| box buttonExtent aFraction maxExtent |	box := self costume innerBounds.	maxExtent := (box extent // 3) min: self buttonHeight asPoint.	self isHorizontal ifTrue:[		buttonExtent := maxExtent x @ box height.		backButton topLeft: box topLeft.		backButton extent: buttonExtent.		forwardButton topRight: box topRight.		forwardButton extent: buttonExtent.		knob top: box top.		knob height: box height.		(forwardButton label asString = 'r') ifFalse:[			forwardButton label:'r'.			forwardButton fillAngle: 90.			backButton label: 'l'.			backButton fillAngle: 90.			knob fillAngle: 90.		].	] ifFalse:[		buttonExtent := box width @ maxExtent y.		backButton topLeft: box topLeft.		backButton extent: buttonExtent.		forwardButton bottomLeft: box bottomLeft.		forwardButton extent: buttonExtent.		knob left: box left.		knob width: box width.		(forwardButton label asString = 'd') ifFalse:[			forwardButton label: 'd'.			forwardButton fillAngle: 0.			backButton label: 'u'.			backButton fillAngle: 0.			knob fillAngle: 0.		].	].	"Update the knob's size"	self visibleFraction ifNil:[		self isHorizontal 			ifTrue:[knob width: buttonExtent x]			ifFalse:[knob height: buttonExtent y].	] ifNotNil:[		aFraction := self visibleFraction min: 1.0 max: 0.0.		knob visible: aFraction < 1.		buttonExtent := (self innerBounds extent * aFraction) truncated.		self isHorizontal 			ifTrue:[knob width: (buttonExtent x max: maxExtent x // 2)]			ifFalse:[knob height: (buttonExtent y max: maxExtent y // 2)].	].	self positionKnob.! !!CScrollBarCostume methodsFor: 'layout' stamp: 'ar 2/8/2004 20:38'!positionKnob	"Position the knob appropriately"	| box innerRect |	box := self innerBounds.	innerRect := box insetBy: (0@0 extent: knob extent).	self isHorizontal ifTrue:[		knob left: innerRect left + (innerRect width * self fraction) truncated.	] ifFalse:[		knob top: innerRect top + (innerRect height * self fraction) truncated.	].! !!CSpinnerButtonsCostume methodsFor: 'initialize' stamp: 'ar 3/17/2004 03:15'!initialize	super initialize.	self define: #upButton as: CPushButton new.	self define: #downButton as: CPushButton new.! !!CSpinnerButtonsCostume methodsFor: 'initialize' stamp: 'tk 7/14/2004 11:28'!setupCostume	super setupCostume.	self layout: CTableLayout new.	self asPrimCostume localCache: CFormCache new.	self hResizing: #rigid; vResizing: #spaceFill.	self extent: 16@22.	upButton font: (TextStyle named:'WindowFont') defaultFont.	upButton hResizing: #spaceFill; vResizing: #spaceFill.	upButton label: 'u'.	upButton fillAngle: 0.	self add: upButton.	downButton font: (TextStyle named:'WindowFont') defaultFont.	downButton hResizing: #spaceFill; vResizing: #spaceFill.	downButton label: 'd'.	downButton fillAngle: 0.	self add: downButton.! !!CSpinnerButtonsCostume methodsFor: 'accessing' stamp: 'ar 3/12/2004 16:16'!downButton	"Answer the downButton of the receiver"	<bewareOf: #downButtonChanged>	^self propertyValueAt: #downButton! !!CSpinnerButtonsCostume methodsFor: 'accessing' stamp: 'ar 3/12/2004 16:16'!downButton: aValue	"Modify the receiver's downButton"	^self propertyValueAt: #downButton put: aValue with: #downButtonChanged! !!CSpinnerButtonsCostume methodsFor: 'accessing' stamp: 'ar 3/12/2004 16:16'!upButton	"Answer the upButton of the receiver"	<bewareOf: #upButtonChanged>	^self propertyValueAt: #upButton! !!CSpinnerButtonsCostume methodsFor: 'accessing' stamp: 'ar 3/12/2004 16:16'!upButton: aValue	"Modify the receiver's upButton"	^self propertyValueAt: #upButton put: aValue with: #upButtonChanged! !!CSpinnerButtonsCostume methodsFor: 'events' stamp: 'ar 3/25/2004 21:57'!onSpinDown	<on: mouseDown in: downButton>	self signal: #spinDown.! !!CSpinnerButtonsCostume methodsFor: 'events' stamp: 'ar 3/25/2004 22:29'!onSpinUp	<on: mouseDown in: upButton>	self signal: #spinUp.! !!CSpinnerCostume methodsFor: 'initialize' stamp: 'ar 3/13/2004 23:59'!defaultPlayer	^CSpinner! !!CSpinnerCostume methodsFor: 'initialize' stamp: 'ar 3/17/2004 03:15'!initialize	super initialize.	self define: #spinnerLabel as: CLabel new.	self define: #spinnerValue as: CInputField new.	self define: #spinnerButtons as: CSpinnerButtonsCostume new.! !!CSpinnerCostume methodsFor: 'initialize' stamp: 'ar 4/30/2004 15:54'!setupCostume	super setupCostume.	self height: 20.	self color: Color transparent.	self clipping: false.	self layout: CTableLayout new.	self layout listDirection: #leftToRight.	self vResizing: #shrinkWrap; hResizing: #spaceFill.	spinnerLabel clipping: false.	spinnerLabel textAnchorPoint: #rightCenter.	self add: spinnerLabel.	spinnerValue hResizing: #rigid.	spinnerValue vResizing: #spaceFill.	self add: spinnerValue.	self add: spinnerButtons.! !!CSpinnerCostume methodsFor: 'accessing' stamp: 'ar 3/13/2004 23:57'!spinnerButtons	"Answer the spinnerButtons of the receiver"	<bewareOf: #spinnerButtonsChanged>	^self propertyValueAt: #spinnerButtons! !!CSpinnerCostume methodsFor: 'accessing' stamp: 'ar 3/13/2004 23:57'!spinnerButtons: aValue	"Modify the receiver's spinnerButtons"	^self propertyValueAt: #spinnerButtons put: aValue with: #spinnerButtonsChanged! !!CSpinnerCostume methodsFor: 'accessing' stamp: 'ar 3/13/2004 23:57'!spinnerLabel	"Answer the spinnerLabel of the receiver"	<bewareOf: #spinnerLabelChanged>	^self propertyValueAt: #spinnerLabel! !!CSpinnerCostume methodsFor: 'accessing' stamp: 'ar 3/13/2004 23:57'!spinnerLabel: aValue	"Modify the receiver's spinnerLabel"	^self propertyValueAt: #spinnerLabel put: aValue with: #spinnerLabelChanged! !!CSpinnerCostume methodsFor: 'accessing' stamp: 'ar 3/13/2004 23:57'!spinnerValue	"Answer the spinnerValue of the receiver"	<bewareOf: #spinnerValueChanged>	^self propertyValueAt: #spinnerValue! !!CSpinnerCostume methodsFor: 'accessing' stamp: 'ar 3/13/2004 23:57'!spinnerValue: aValue	"Modify the receiver's spinnerValue"	^self propertyValueAt: #spinnerValue put: aValue with: #spinnerValueChanged! !!CSpinnerCostume methodsFor: 'events' stamp: 'ar 3/14/2004 00:45'!onInputValueChanged	| newValue |	<on: accept in: spinnerValue>	newValue := [Number readFrom: spinnerValue contents asString] on: Error do:[:ex|		spinnerValue flash.		ex return: nil].	newValue ifNotNil:[player value: newValue].	spinnerValue value: player value.! !!CSpinnerCostume methodsFor: 'events' stamp: 'ar 3/23/2004 23:17'!onLabelChanged	<on: labelChanged in: player>	spinnerLabel value: player label.	spinnerLabel visible: player label notNil.	spinnerValue hResizing: (spinnerLabel visible ifTrue:[#rigid] ifFalse:[#spaceFill]).! !!CSpinnerCostume methodsFor: 'events' stamp: 'ar 3/25/2004 21:58'!onPlayerChanged	<on: playerChanged>	super onPlayerChanged.	self onLabelChanged.	self onValueChanged.! !!CSpinnerCostume methodsFor: 'events' stamp: 'ar 3/25/2004 21:59'!onSpinDown	<on: spinDown in: spinnerButtons>	player value: player value - player step.! !!CSpinnerCostume methodsFor: 'events' stamp: 'ar 3/25/2004 22:00'!onSpinUp	<on: spinUp in: spinnerButtons>	player value: player value + player step.! !!CSpinnerCostume methodsFor: 'events' stamp: 'ar 3/14/2004 00:04'!onSpinnerValueChanged	<on: valueChanged in: player>	spinnerValue value: player value.! !!CSpinnerCostume methodsFor: 'events' stamp: 'ar 3/17/2004 17:34'!onValueChanged	<on: valueChanged>	spinnerValue value: player value.! !!CSpinnerListCostume methodsFor: 'initialize' stamp: 'ar 4/3/2004 20:10'!defaultPlayer	^CList! !!CSpinnerListCostume methodsFor: 'initialize' stamp: 'ar 3/26/2004 04:12'!initialize	super initialize.	self define: #label as: CLabel new.	self define: #spinner as: CSpinnerButtons new.! !!CSpinnerListCostume methodsFor: 'initialize' stamp: 'ar 4/30/2004 15:54'!setupCostume	super setupCostume.	self layout: CTableLayout new.	self layout listDirection: #leftToRight.	self add: label.	self add: spinner.! !!CSpinnerListCostume methodsFor: 'accessing' stamp: 'ar 3/12/2004 16:31'!label	"Answer the label of the receiver"	<bewareOf: #labelChanged>	^self propertyValueAt: #label! !!CSpinnerListCostume methodsFor: 'accessing' stamp: 'ar 3/12/2004 16:31'!label: aValue	"Modify the receiver's label"	^self propertyValueAt: #label put: aValue with: #labelChanged! !!CSpinnerListCostume methodsFor: 'accessing' stamp: 'ar 3/12/2004 16:31'!spinner	"Answer the spinner of the receiver"	<bewareOf: #spinnerChanged>	^self propertyValueAt: #spinner! !!CSpinnerListCostume methodsFor: 'accessing' stamp: 'ar 3/12/2004 16:31'!spinner: aValue	"Modify the receiver's spinner"	^self propertyValueAt: #spinner put: aValue with: #spinnerChanged! !!CSpinnerListCostume methodsFor: 'events' stamp: 'ar 3/26/2004 04:13'!onCursorChanged	<on: cursorChanged in: player>	label value: player selection.! !!CSpinnerListCostume methodsFor: 'events' stamp: 'ar 3/26/2004 04:14'!onPlayerChanged	super onPlayerChanged.	self onCursorChanged.! !!CSpinnerListCostume methodsFor: 'events' stamp: 'ar 3/26/2004 04:13'!onSpinDown	<on: spinDown in: spinner>	player prev.! !!CSpinnerListCostume methodsFor: 'events' stamp: 'ar 3/26/2004 04:13'!onSpinUp	<on: spinUp in: spinner>	player next.! !!CStringListCostume methodsFor: 'initialize' stamp: 'ar 4/3/2004 20:10'!defaultPlayer	^CList! !!CStringListCostume methodsFor: 'drawing' stamp: 'ar 3/27/2004 20:56'!drawItem: index in: itemBox on: aCanvas	| itemColor string |	itemColor := index = selectionIndex 			ifTrue:[Color white] 			ifFalse:[Color black].	string := (self player elements at: index) displayText.	aCanvas drawString: string asString			in: (itemBox insetBy: (3@1 corner: 0@1)) 			font: self playerFont 			color: itemColor.! !!CTabButtonCostume methodsFor: 'initialize' stamp: 'ar 3/13/2004 04:17'!defaultPlayer	^CTabButton! !!CTabButtonCostume methodsFor: 'initialize' stamp: 'ar 4/28/2004 18:28'!initialize	super initialize.	self define: #buttonImage as: CPlayer new.	self define: #buttonLabel as: CLabel new.! !!CTabButtonCostume methodsFor: 'initialize' stamp: 'tk 7/14/2004 11:28'!setupCostume	super setupCostume.	buttonImage graphicEnabled: true.	buttonImage graphicFit: #autoScale.	buttonImage extent: 20@20.	self addLast: buttonImage.	buttonLabel clipping: false.	buttonLabel hResizing: #shrinkWrap.	self addLast: buttonLabel.	self layout: CTableLayout new.	self layout listDirection: #leftToRight.	self layout cellInset: 2.	self borderStyle: #raised.	self hResizing: #shrinkWrap; vResizing: #rigid.	self layoutInset: 15@5.	self borderWidth: 1.	self borderColor: CWidgetLibrary default frameColor.	self deselect.	self textEmphasis: 1.	self extent: 100@30.	self roundCornerSpec: #(1 4).	self asPrimCostume localCache: CFormCache new.! !!CTabButtonCostume methodsFor: 'events' stamp: 'ar 3/30/2004 13:31'!onButtonStateChanged	player state == #disabled		ifTrue:[buttonLabel textColor: Color gray]		ifFalse:[buttonLabel textColor: Color black].	player state == #pressed ifTrue:[		borderStyle := #inset.		buttonLabel textOffset: 1.		buttonImage graphicOffset: 1.	].	(player state == #normal or:[player state == #over]) ifTrue:[		borderStyle := player selected ifTrue:[#raised] ifFalse:[#simple].		buttonLabel textOffset: 0.		buttonImage graphicOffset: 0.	].! !!CTabButtonCostume methodsFor: 'events' stamp: 'ar 4/28/2004 18:45'!onImageChanged	"Updates the receiver's image from the player without changing the size of the button image"	| aForm |	aForm := self player image.	buttonImage graphicForm: aForm.	buttonImage == self ifFalse:[buttonImage visible: aForm notNil].! !!CTabButtonCostume methodsFor: 'events' stamp: 'ar 3/29/2004 23:19'!onSelectedChanged	player selected ifTrue:[		fillStyle := #verticalGradient.		fillColors := CWidgetLibrary default gradientColors.	] ifFalse:[		color := CWidgetLibrary default paneColor.	].	self onButtonStateChanged. "to update the border"! !!CTabButtonListCostume methodsFor: 'initialize' stamp: 'ar 3/13/2004 05:50'!defaultColor	^Color transparent! !!CTabButtonListCostume methodsFor: 'initialize' stamp: 'ar 3/13/2004 22:35'!defaultPlayer	^CTabButtonList! !!CTabButtonListCostume methodsFor: 'initialize' stamp: 'ar 4/30/2004 15:54'!setupCostume	"Initial tweaks which really should go away before too long"	super setupCostume.	self layout: CTableLayout new.	self hResizing: #spaceFill; vResizing: #shrinkWrap.	self layout listDirection: #leftToRight.	self layout layoutInset: (0@0 corner: 0@-1).! !!CTabButtonListCostume methodsFor: 'accessing' stamp: 'ar 3/13/2004 04:57'!selectedPlayer	"Answer the selectedPlayer of the receiver"	<bewareOf: #selectedPlayerChanged>	^self propertyValueAt: #selectedPlayer! !!CTabButtonListCostume methodsFor: 'accessing' stamp: 'ar 3/13/2004 04:57'!selectedPlayer: aValue	"Modify the receiver's selectedPlayer"	^self propertyValueAt: #selectedPlayer put: aValue with: #selectedPlayerChanged! !!CTabButtonListCostume methodsFor: 'events' stamp: 'ar 3/30/2004 03:29'!onButtonSelected	<on: cursorChanged in: elements>	player selection: elements selection value.! !!CTabButtonListCostume methodsFor: 'events' stamp: 'ar 3/30/2004 03:25'!onCursorChanged	<on: cursorChanged in: player>	player cursor > 0 		ifTrue:[(elements at: player cursor) select].! !!CTabButtonListCostume methodsFor: 'events' stamp: 'ar 3/30/2004 03:29'!onElementsChanged	| button itemMaker |	<on: changed in: player>	itemMaker := player itemMaker.	elements := player elements collect:[:each|		button := itemMaker new.		button listItemValue: each. "see comment in listItemValue:"		button label: each displayText.		button group: elements.		button].	self onCursorChanged.! !!CTabButtonListCostume methodsFor: 'events' stamp: 'ar 3/30/2004 03:30'!onPlayerChanged	super onPlayerChanged.	self onElementsChanged.! !!CTextEditorCostume methodsFor: 'initialize' stamp: 'ar 3/25/2004 15:51'!defaultPlayer	^CTextEditor! !!CTextEditorCostume methodsFor: 'initialize' stamp: 'ar 4/30/2004 15:54'!setupCostume	super setupCostume.	self text: ''.	self mouseCursor: Cursor text.	self borderWidth: 1.	self borderColor: CWidgetLibrary default frameColor.	self borderStyle: #simple.	self textAnchorPoint: #topLeft.	self textWrap: true.! !!CTextEditorCostume methodsFor: 'events' stamp: 'ar 5/6/2004 16:38'!onKeyboardFocusEnter	"only accept input while having the keyboard focus"	<on: keyboardFocusEnter in: player>	oldBorder := border copy.	oldBorder width > 0 ifTrue:[		borderStyle := #inset.		borderWidth := 1 max: oldBorder width.		borderColor isTransparent 			ifTrue:[borderColor := Color gray: 0.5].	].! !!CTextEditorCostume methodsFor: 'events' stamp: 'ar 5/6/2004 16:38'!onKeyboardFocusLeave	"only accept input while having the keyboard focus"	<on: keyboardFocusLeave in: player>	border := oldBorder.! !!CTextEditorCostume methodsFor: 'accessing' stamp: 'ar 5/6/2004 16:37'!oldBorder	"Answer the oldBorder of the receiver"	<bewareOf: #oldBorderChanged>	^self propertyValueAt: #oldBorder! !!CTextEditorCostume methodsFor: 'accessing' stamp: 'ar 5/6/2004 16:37'!oldBorder: aValue	"Modify the receiver's oldBorder"	^self propertyValueAt: #oldBorder put: aValue with: #oldBorderChanged! !!CInputFieldCostume methodsFor: 'initialize' stamp: 'ar 3/12/2004 14:22'!defaultPlayer	^CInputField! !!CInputFieldCostume methodsFor: 'initialize' stamp: 'ar 4/30/2004 15:51'!setupCostume	super setupCostume.	self text:' '.	self hResizing: #spaceFill.	self vResizing: #shrinkWrap.	self textAnchorPoint: #topLeft.	self textWrap: false.! !!CInputFieldCostume methodsFor: 'events' stamp: 'ar 3/27/2004 19:14'!onKeyboardFocusEnter	"Select all of the text when the user clicks in the input field"	player selectAll.	super onKeyboardFocusEnter.! !!CTileButtonCostume methodsFor: 'initialize' stamp: 'ar 4/30/2004 15:54'!setupCostume	super setupCostume.	self borderColor: CWidgetLibrary default frameColor.	self borderStyle: #simple.	self borderWidth: 0.	self fillStyle: #verticalGradient.	self fillColors: {Color white. Color r: 1.0 g: 0.677 b: 0.032}.	self textEmphasis: 1.	self extent: 80@20.! !!CTileButtonCostume methodsFor: 'events' stamp: 'ar 3/27/2004 19:40'!onButtonStateChanged	player state == #pressed ifTrue:[		borderStyle := #inset.		buttonLabel textOffset: 1.		buttonImage graphicOffset: 1.	] ifFalse:[		borderStyle := #simple.		buttonLabel textOffset: 0.		buttonImage graphicOffset: 0.	].! !!CToolBarButtonCostume methodsFor: 'initialize' stamp: 'tk 7/14/2004 11:28'!setupCostume	super setupCostume.	self textEnabled: true.	self borderStyle: #simple.	self borderWidth: 1.	self borderColor: CWidgetLibrary default frameColor.	self fillStyle: #verticalGradient.	self fillColors: CWidgetLibrary default gradientColors.	self textEmphasis: 1.	self extent: 80@20.	self asPrimCostume localCache: CFormCache new.! !!CToolBarButtonCostume methodsFor: 'accessing' stamp: 'ar 4/4/2004 18:04'!windowColor: aColor	super windowColor: aColor.	self fillColors: {Color white. aColor}.! !!CToolBarButtonCostume methodsFor: 'events' stamp: 'ar 4/4/2004 18:09'!onButtonStateChanged	"Update from my player's state"	player state == #disabled		ifTrue:[buttonLabel textColor: Color gray]		ifFalse:[buttonLabel textColor: Color black].	player state == #pressed ifTrue:[		buttonLabel textOffset: 1.		buttonImage graphicOffset: 1.		borderStyle := #inset.	] ifFalse:[		buttonLabel textOffset: 0.		buttonImage graphicOffset: 0.		borderStyle := player selected ifTrue:[#inset] ifFalse:[#raised].	].! !!CToolBarButtonCostume methodsFor: 'events' stamp: 'ar 4/4/2004 18:06'!onSelectedChanged	borderStyle := player selected ifTrue:[#inset] ifFalse:[#raised].! !!CTreeWidgetCostume methodsFor: 'initialize' stamp: 'ar 3/9/2004 02:15'!defaultPlayer	^CTreeWidget! !!CTreeWidgetCostume methodsFor: 'initialize' stamp: 'ar 4/30/2004 15:56'!setupCostume	super setupCostume.	scrollTarget layout: CTableLayout new.	scrollTarget layout cellPositioning: #topLeft.! !!CTreeWidgetCostume methodsFor: 'events' stamp: 'ar 3/15/2004 12:34'!handleKey: event	"See if we have an entry which starts with the key character"	| keyChar nodes cc max item |	keyChar := event keyCharacter asLowercase.	nodes := player treeNodes.	"Search from cursor to end"	cc := self cursor + 1.	max := nodes size.	[cc <= max] whileTrue:[		item := nodes at: cc.		item label asString first asLowercase = keyChar 			ifTrue:[^self cursor: cc].		cc := cc + 1.	].	"Search from start to cursor"	cc := 1.	max := self cursor - 1.	[cc <= max] whileTrue:[		item := nodes at: cc.		item label asString first asLowercase = keyChar 			ifTrue:[^self cursor: cc].		cc := cc + 1.	].! !!CTreeWidgetCostume methodsFor: 'events' stamp: 'ar 3/24/2004 23:13'!onCursorChanged	| selected |	<on: cursorChanged in: player>	selected := self selectedPlayer.	selected ifNotNil:[selected deselect].	self cursor > 0		ifTrue:[selected := scrollTarget elements at: self cursor]		ifFalse:[selected := nil].	self selectedPlayer: selected.	selected ifNotNil:[		selected select.		scrollTarget scrollToShow: selected.	].! !!CTreeWidgetCostume methodsFor: 'events' stamp: 'ar 3/25/2004 11:18'!onElementsChanged	<on: changed in: player>	scrollTarget elements: player treeNodes.	self onCursorChanged.! !!CTreeWidgetCostume methodsFor: 'events' stamp: 'ar 4/3/2004 13:52'!onKeyDown: event	"React to a key event"	| keyEvent item |	<on: keyDown>	keyEvent := event keyValue.	"Basic cursor key navigation"	keyEvent == 1 		ifTrue: [^self cursor: 1].  "home"	keyEvent == 4 		ifTrue: [^self cursor: self size].   "end"	(keyEvent == 31 and:[self cursor < self player size])		ifTrue:[self cursor: self cursor + 1]. "down"	(keyEvent == 30 and:[self cursor > 1])		ifTrue:[self cursor: self cursor - 1]. "up"	selectedPlayer ifNil:[^self].	item := selectedPlayer.	(keyEvent == 28) ifTrue:["left"		item expanded 			ifTrue:[^item collapse]			ifFalse:[^self cursor: (player indexOfTreeNode: item parent)].	].	(keyEvent == 29) ifTrue:["right"		item expanded 			ifFalse:[^item expand].	].	^self handleKey: event! !!CTreeWidgetCostume methodsFor: 'events' stamp: 'ar 3/24/2004 23:23'!onMouseDown	"React to a mouse event"	| selected idx |	<on: mouseDown>	"Figure out the selection"	selected := scrollTarget findPlayerAt: scrollTarget cursorPoint.	selected ifNil:[^self].	idx := scrollTarget elements indexOf: selected.	player allowDeselect ifTrue:[		self cursor = idx ifTrue:[^self cursor: 0].	].	"And set newly selected player"	self cursor: idx.! !!CTreeWidgetCostume methodsFor: 'events' stamp: 'ar 3/25/2004 00:14'!onPlayerChanged	super onPlayerChanged.	self selectedPlayer: nil.	self onElementsChanged.! !!CTreeWidgetCostume methodsFor: 'accessing' stamp: 'ar 3/9/2004 02:15'!cursor	^self player cursor! !!CTreeWidgetCostume methodsFor: 'accessing' stamp: 'ar 3/9/2004 02:15'!cursor: newCursor	^self player cursor: newCursor! !!CTreeWidgetCostume methodsFor: 'accessing' stamp: 'ar 3/13/2004 00:46'!playerCopyFrom: start to: stop	^player treeNodes copyFrom: start to: stop! !!CTreeWidgetCostume methodsFor: 'accessing' stamp: 'ar 3/17/2004 15:16'!selectedPlayer	"This method was automatically generated"	<bewareOf: #selectedPlayerChanged>	^self propertyValueAt: #selectedPlayer! !!CTreeWidgetCostume methodsFor: 'accessing' stamp: 'ar 3/12/2004 18:30'!selectedPlayer: aValue	"This method was automatically generated"	^self propertyValueAt: #selectedPlayer put: aValue with: #selectedPlayerChanged! !!CWheelWidgetCostume methodsFor: 'field access' stamp: 'ar 3/17/2004 15:16'!maxAngle	"This method was automatically generated"	<bewareOf: #maxAngleChanged>	^self propertyValueAt: #maxAngle! !!CWheelWidgetCostume methodsFor: 'field access' stamp: 'ar 3/11/2004 14:28'!maxAngle: aValue	"This method was automatically generated"	^self propertyValueAt: #maxAngle put: aValue with: #maxAngleChanged! !!CWheelWidgetCostume methodsFor: 'field access' stamp: 'ar 3/17/2004 15:16'!wheelAngle	"This method was automatically generated"	<bewareOf: #wheelAngleChanged>	^self propertyValueAt: #wheelAngle! !!CWheelWidgetCostume methodsFor: 'field access' stamp: 'ar 3/11/2004 14:28'!wheelAngle: aValue	"This method was automatically generated"	^self propertyValueAt: #wheelAngle put: aValue with: #wheelAngleChanged! !!CWheelWidgetCostume methodsFor: 'initialize' stamp: 'ar 3/7/2004 22:02'!defaultPlayer	^CWheelWidget! !!CWheelWidgetCostume methodsFor: 'initialize' stamp: 'ar 3/29/2004 14:54'!initialize	super initialize.	self userDraw: true.	self maxAngle: 360.	self wheelAngle: 0.! !!CWheelWidgetCostume methodsFor: 'drawing' stamp: 'ar 3/26/2004 23:40'!drawOn: aCanvas in: box	| interval delta frame x0 x1 y0 y1 deltaX deltaY  hilitColor shadowColor |	super drawOn: aCanvas in: box.		"border & background"	hilitColor := self color lighter lighter.	shadowColor := self color darker darker.	frame := self costume innerBounds insetBy: 2.	aCanvas frameAndFillRectangle: frame fillColor: Color transparent		borderWidth: 1 topLeftColor: hilitColor bottomRightColor: shadowColor.	frame _ frame insetBy: 2.	x0 := frame origin x.	x1 := frame corner x.	y0 := frame origin y.	y1 := frame corner y.	deltaX := (x1 - x0) / 2.	deltaY := (y1 - y0) / 2.	interval := 10.	delta := self wheelAngle \\ interval.	self isHorizontal ifTrue:[delta := delta asPoint x] ifFalse:[delta := delta asPoint y].	1 to: (self maxAngle / (2 * interval)) rounded do: [ :i |		| xx yy |		self isHorizontal ifTrue: [			xx := x0 + deltaX - (((i * interval + delta) * (2 * Float pi / 360.0)) cos * deltaX).			aCanvas fillRectangle: (Rectangle origin: (xx-1)@y0 corner: xx@y1) color: hilitColor.			aCanvas fillRectangle: (Rectangle origin: xx@y0 corner: (xx+1)@y1) color: shadowColor		] ifFalse:[			yy := y0 + deltaY - (((i * interval + delta) * (2 * Float pi / 360.0)) cos * deltaY).			aCanvas fillRectangle: (Rectangle origin: x0@(yy-1) corner: x1@yy) color: hilitColor.			aCanvas fillRectangle: (Rectangle origin: x0@yy corner: x1@(yy+1)) color: shadowColor.		].	].! !!CWheelWidgetCostume methodsFor: 'events' stamp: 'ar 2/9/2004 19:07'!onMouseDown	| old new delta oldValue |	<on: mouseDown>	old := self cursorPoint.	oldValue := self value.	self hand forEach: #mouseMove do:[		new := self cursorPoint.		delta := new - old.		self isHorizontal ifTrue:[delta := delta x] ifFalse:[delta := delta y].		self wheelAngle: delta.		self value: oldValue + delta.		self invalidate.	] until: #mouseUp.! !!CWidgetLibrary methodsFor: 'lists' stamp: 'ar 3/7/2004 18:02'!dropDownListCostume	^CDropDownListCostume! !!CWidgetLibrary methodsFor: 'lists' stamp: 'ar 3/7/2004 18:04'!listCostume	^CListCostume! !!CWidgetLibrary methodsFor: 'lists' stamp: 'ar 3/7/2004 20:09'!spinnerListCostume	^CSpinnerListCostume! !!CWidgetLibrary methodsFor: 'lists' stamp: 'ar 3/7/2004 18:04'!stringListCostume	^CStringListCostume! !!CWidgetLibrary methodsFor: 'lists' stamp: 'ar 3/9/2004 02:31'!treeCostume	^CTreeWidgetCostume! !!CWidgetLibrary methodsFor: 'buttons' stamp: 'ar 3/7/2004 18:02'!buttonCostume	^CPushButtonCostume! !!CWidgetLibrary methodsFor: 'buttons' stamp: 'ar 3/7/2004 18:01'!checkBoxCostume	^CCheckBoxCostume! !!CWidgetLibrary methodsFor: 'buttons' stamp: 'ar 3/7/2004 18:02'!pushButtonCostume	^CPushButtonCostume! !!CWidgetLibrary methodsFor: 'buttons' stamp: 'ar 3/7/2004 18:02'!radioButtonCostume	^CRadioButtonCostume! !!CWidgetLibrary methodsFor: 'buttons' stamp: 'ar 3/13/2004 04:16'!tabButtonCostume	^CTabButtonCostume! !!CWidgetLibrary methodsFor: 'scrolling' stamp: 'ar 3/7/2004 18:05'!scrollBarCostume	^CScrollBarCostume! !!CWidgetLibrary methodsFor: 'scrolling' stamp: 'ar 3/27/2004 19:19'!scrollBarHeight	"Answer the default height for scrollbars"	^18! !!CWidgetLibrary methodsFor: 'scrolling' stamp: 'ar 3/7/2004 18:05'!scrollPaneCostume	^CScrollPaneCostume! !!CWidgetLibrary methodsFor: 'scrolling' stamp: 'ar 3/13/2004 23:57'!spinnerCostume	^CSpinnerCostume! !!CWidgetLibrary methodsFor: 'basic' stamp: 'ar 3/7/2004 18:00'!labelCostume	^CLabelCostume! !!CWidgetLibrary methodsFor: 'basic' stamp: 'ar 3/7/2004 18:00'!sliderCostume	^CSliderCostume! !!CWidgetLibrary methodsFor: 'menus' stamp: 'ar 3/7/2004 18:06'!menuCostume	^CMenuCostume! !!CWidgetLibrary methodsFor: 'menus' stamp: 'ar 3/7/2004 18:06'!menuItemCostume	^CMenuItemCostume! !!CWidgetLibrary methodsFor: 'windows' stamp: 'ar 3/7/2004 18:06'!windowCostume	^CWindowCostume! !!CWidgetLibrary methodsFor: 'colors' stamp: 'ar 3/22/2004 02:14'!baseColor	"The base color for this scheme"	ImparaColors ifTrue:[^Color r: 0.341 g: 0.638 b: 0.741].	^(Color r: 1.0 g: 0.677 b: 0.032)! !!CWidgetLibrary methodsFor: 'colors' stamp: 'ar 3/22/2004 02:14'!frameColor	"This is the color to be used for 1px borders (framing)"	ImparaColors ifTrue:[^(Color r: 0.341 g: 0.638 b: 0.741)].	^(Color r: 1.0 g: 0.807 b: 0.442)! !!CWidgetLibrary methodsFor: 'colors' stamp: 'ar 3/15/2004 00:00'!gradientColors	"This describes the colors to use for any gradients"	^{Color white. self baseColor}! !!CWidgetLibrary methodsFor: 'colors' stamp: 'ar 3/15/2004 00:10'!menLabelTextColor	"Answer the color of text in menu labels"	^self baseColor mixed: 0.3 with: Color black! !!CWidgetLibrary methodsFor: 'colors' stamp: 'ar 3/15/2004 00:07'!menuColors	"Answer the gradient to be used for menu backgrounds"	^{Color white. self paneColor}! !!CWidgetLibrary methodsFor: 'colors' stamp: 'ar 3/14/2004 23:57'!noColor	"noColor exists only to describe that we *mean* to use a symbolic color from the library"	^Color transparent! !!CWidgetLibrary methodsFor: 'colors' stamp: 'ar 3/22/2004 02:17'!paneColor	"This is a much lighter variant of the base color used for interior panes"	ImparaColors ifTrue:[^(Color r: 0.98 g: 0.98 b: 0.99)].	^(Color r: 1.0 g: 0.936 b: 0.827)! !!CWidgetLibrary methodsFor: 'colors' stamp: 'ar 6/2/2004 15:31'!windowColor	^self baseColor! !!CWindow methodsFor: 'initialize' stamp: 'ar 3/1/2004 14:49'!defaultCostume	^CWidgetLibrary default windowCostume! !!CWindow methodsFor: 'initialize' stamp: 'ar 6/2/2004 15:34'!initialize	super initialize.	minimizeBox := true.	maximizeBox := true.	closeBox := true.	color := CWidgetLibrary default windowColor.! !!CWindow methodsFor: 'accessing' stamp: 'ar 3/17/2004 15:16'!closeBox	"This method was automatically generated"	<bewareOf: #closeBoxChanged>	^self propertyValueAt: #closeBox! !!CWindow methodsFor: 'accessing' stamp: 'ar 3/11/2004 14:28'!closeBox: aValue	"This method was automatically generated"	^self propertyValueAt: #closeBox put: aValue with: #closeBoxChanged! !!CWindow methodsFor: 'accessing' stamp: 'ar 3/24/2004 21:15'!elements	"Answer the elements of the receiver"	^costume windowContents! !!CWindow methodsFor: 'accessing' stamp: 'ar 3/24/2004 16:58'!label	"Answer the label of the receiver"	<bewareOf: #labelChanged>	^self propertyValueAt: #label! !!CWindow methodsFor: 'accessing' stamp: 'ar 3/24/2004 16:58'!label: aValue	"Modify the receiver's label"	^self propertyValueAt: #label put: aValue with: #labelChanged! !!CWindow methodsFor: 'accessing' stamp: 'ar 3/17/2004 15:16'!maximizeBox	"This method was automatically generated"	<bewareOf: #maximizeBoxChanged>	^self propertyValueAt: #maximizeBox! !!CWindow methodsFor: 'accessing' stamp: 'ar 3/11/2004 14:28'!maximizeBox: aValue	"This method was automatically generated"	^self propertyValueAt: #maximizeBox put: aValue with: #maximizeBoxChanged! !!CWindow methodsFor: 'accessing' stamp: 'ar 4/4/2004 18:41'!menuBar	"Answer the menuBar of the receiver"	<bewareOf: #menuBarChanged>	^self propertyValueAt: #menuBar! !!CWindow methodsFor: 'accessing' stamp: 'ar 4/4/2004 18:41'!menuBar: aValue	"Modify the receiver's menuBar"	^self propertyValueAt: #menuBar put: aValue with: #menuBarChanged! !!CWindow methodsFor: 'accessing' stamp: 'ar 3/17/2004 15:16'!minimizeBox	"This method was automatically generated"	<bewareOf: #minimizeBoxChanged>	^self propertyValueAt: #minimizeBox! !!CWindow methodsFor: 'accessing' stamp: 'ar 3/11/2004 14:28'!minimizeBox: aValue	"This method was automatically generated"	^self propertyValueAt: #minimizeBox put: aValue with: #minimizeBoxChanged! !!CWindow methodsFor: 'accessing' stamp: 'ar 4/4/2004 18:41'!statusBar	"Answer the statusBar of the receiver"	<bewareOf: #statusBarChanged>	^self propertyValueAt: #statusBar! !!CWindow methodsFor: 'accessing' stamp: 'ar 4/4/2004 18:41'!statusBar: aValue	"Modify the receiver's statusBar"	^self propertyValueAt: #statusBar put: aValue with: #statusBarChanged! !!CWindow methodsFor: 'accessing' stamp: 'ar 4/4/2004 18:22'!toolBar	"Answer the toolBar of the receiver"	<bewareOf: #toolBarChanged>	^self propertyValueAt: #toolBar! !!CWindow methodsFor: 'accessing' stamp: 'ar 4/4/2004 18:22'!toolBar: aValue	"Modify the receiver's toolBar"	^self propertyValueAt: #toolBar put: aValue with: #toolBarChanged! !!CWindow methodsFor: 'color and fill' stamp: 'ar 7/29/2004 21:57'!onColorChanged	<on: fillChanged>	windowColor := color.	self onWindowColorChanged: windowColor.! !!CWindow methodsFor: 'color and fill' stamp: 'ar 7/29/2004 21:56'!onWindowColorChanged: aColor	costume windowColor: aColor.	toolBar ifNotNil:[toolBar windowColor: aColor].	menuBar ifNotNil:[menuBar windowColor: aColor].	statusBar ifNotNil:[statusBar windowColor: aColor].! !!CWindow methodsFor: 'color and fill' stamp: 'ar 7/29/2004 21:55'!windowColor	"Answer the windowColor of the receiver"	<bewareOf: #windowColorChanged>	^self propertyValueAt: #windowColor ifAbsent:[self color]! !!CWindow methodsFor: 'color and fill' stamp: 'ar 7/29/2004 21:55'!windowColor: aValue	"Modify the receiver's windowColor"	^self propertyValueAt: #windowColor put: aValue with: #windowColorChanged! !!CWindow methodsFor: 'layout' stamp: 'ar 3/25/2004 11:40'!layout	^costume windowLayout! !!CWindow methodsFor: 'layout' stamp: 'bf 3/30/2004 11:35'!layout: aLayout	^costume windowLayout: aLayout! !!CWindowButtonCostume methodsFor: 'initialize' stamp: 'ar 4/30/2004 15:57'!setupCostume	super setupCostume.	self extent: 12@12.	self hResizing: #rigid; vResizing: #rigid.	self borderStyle: #simple.	self borderWidth: 1.	self borderColor: Color black.	self color: Color white.	self textFont: (TextStyle named: 'WindowFont') defaultFont.! !!CWindowButtonCostume methodsFor: 'events' stamp: 'ar 3/27/2004 18:40'!onButtonStateChanged	player state == #normal ifTrue:[		borderColor := Color gray.		color := Color white.	].	player state == #pressed ifTrue:[		borderColor := Color black.		color := Color veryLightGray.	].	player state == #over ifTrue:[		borderColor := Color black.		color := Color white.	].! !!CWindowCostume methodsFor: 'initialize' stamp: 'ar 3/14/2004 23:56'!defaultColor	^CWidgetLibrary default paneColor! !!CWindowCostume methodsFor: 'initialize' stamp: 'ar 3/7/2004 22:02'!defaultPlayer	^CWindow! !!CWindowCostume methodsFor: 'initialize' stamp: 'ar 4/30/2004 18:27'!initialize	super initialize.	self define: #windowFrame as: CWindowCostumeFrame new.	self define: #frontPage as: CHolder new.	self define: #backPage as: CPlayer new.	"ar 4/30/2004:	Hm... this is certainly not correct but I don't quite understand how it needs to work.	Shouldn't we rather keep the resize behavior around as a component?	It would allow us for example, to enable/disable resizing merely by turning	it on or off (e.g., setting/resetting the target)."	CWindowResizeBehavior attachTo: self.! !!CWindowCostume methodsFor: 'initialize' stamp: 'tk 7/14/2004 11:28'!setupCostume	super setupCostume.	self asPrimCostume localCache: CFormCache new.	self dropShadowEnabled: true.	self extent: 200@200.	self add: windowFrame.	self add: backPage.	self borderStyle: #complexRaised.	self borderWidth: 2.	self borderColor: CWidgetLibrary default frameColor.	self roundCornerSpec: #(1 4).	self add: frontPage.	frontPage color: Color white.	frontPage hResizing: #spaceFill.	frontPage vResizing: #spaceFill.	backPage extent: 100@100.	backPage visible: false.	costume layout: CTableLayout new.	costume vResizing: #shrinkWrap.! !!CWindowCostume methodsFor: 'accessing' stamp: 'ar 3/12/2004 16:28'!backPage	"Answer the backPage of the receiver"	<bewareOf: #backPageChanged>	^self propertyValueAt: #backPage! !!CWindowCostume methodsFor: 'accessing' stamp: 'ar 3/12/2004 16:28'!backPage: aValue	"Modify the receiver's backPage"	^self propertyValueAt: #backPage put: aValue with: #backPageChanged! !!CWindowCostume methodsFor: 'accessing' stamp: 'ar 3/24/2004 18:50'!frontPage	"Answer the frontPage of the receiver"	<bewareOf: #frontPageChanged>	^self propertyValueAt: #frontPage! !!CWindowCostume methodsFor: 'accessing' stamp: 'ar 3/24/2004 18:50'!frontPage: aValue	"Modify the receiver's frontPage"	^self propertyValueAt: #frontPage put: aValue with: #frontPageChanged! !!CWindowCostume methodsFor: 'accessing' stamp: 'ar 3/24/2004 18:59'!layout	"Use my frontPage's layout"	^frontPage layout! !!CWindowCostume methodsFor: 'accessing' stamp: 'bf 3/30/2004 11:35'!layout: aLayout	"Use my frontPage's layout"	^frontPage layout: aLayout! !!CWindowCostume methodsFor: 'accessing' stamp: 'ar 7/29/2004 21:26'!windowColor: aColor	self borderColor: aColor.	self color: aColor veryMuchLighter.	windowFrame windowColor: aColor.	self frontPage windowColor: aColor.! !!CWindowCostume methodsFor: 'accessing' stamp: 'ar 3/25/2004 23:54'!windowContents	^frontPage elements! !!CWindowCostume methodsFor: 'accessing' stamp: 'ar 3/12/2004 16:28'!windowFrame	"Answer the windowFrame of the receiver"	<bewareOf: #windowFrameChanged>	^self propertyValueAt: #windowFrame! !!CWindowCostume methodsFor: 'accessing' stamp: 'ar 3/12/2004 16:28'!windowFrame: aValue	"Modify the receiver's windowFrame"	^self propertyValueAt: #windowFrame put: aValue with: #windowFrameChanged! !!CWindowCostume methodsFor: 'accessing' stamp: 'ar 3/25/2004 11:39'!windowLayout	^frontPage layout! !!CWindowCostume methodsFor: 'accessing' stamp: 'bf 3/30/2004 11:37'!windowLayout: aLayout	^frontPage layout: aLayout! !!CWindowCostume methodsFor: 'events' stamp: 'ar 2/16/2004 20:59'!onClose	<on: closeRequest in: windowFrame>	(self player handlesEvent: #closeRequest)		ifTrue:[^self player signal: #closeRequest].	self close.! !!CWindowCostume methodsFor: 'events' stamp: 'ar 2/18/2004 13:38'!onCloseBoxChanged	<on: closeBoxChanged in: player>	windowFrame closeBox: player closeBox.! !!CWindowCostume methodsFor: 'events' stamp: 'tk 7/14/2004 11:28'!onCollapse	"Delegate collapseRequest to the model if it is interested"	| thumbnail |	<on: collapseRequest in: windowFrame>	(self player handlesEvent: #collapseRequest)		ifTrue:[^self player signal: #collapseRequest].	frontPage visible: frontPage visible not.	backPage visible: frontPage visible not.	frontPage visible ifTrue:[		self layoutBounds: (self layoutBounds merge: frontPage bounds).		windowFrame layout layoutInset: 3.	] ifFalse:[		thumbnail := frontPage asPrimCostume asFormExtent: 128@100.		backPage graphicForm: thumbnail.		backPage bounds: thumbnail boundingBox.		self width: (self width min: thumbnail width + (self borderWidth * 2)).		windowFrame layout layoutInset: 3@0.	].	self dropShadowEnabled: frontPage visible.	self position: self position + (frontPage visible ifTrue:[-2] ifFalse:[2]).! !!CWindowCostume methodsFor: 'events' stamp: 'ar 3/6/2004 21:08'!onLabelChanged	<on: labelChanged in: player>	windowFrame label: player label.! !!CWindowCostume methodsFor: 'events' stamp: 'ar 2/18/2004 13:38'!onMaximizeBoxChanged	<on: maximizeBoxChanged in: player>	windowFrame maximizeBox: player maximizeBox.! !!CWindowCostume methodsFor: 'events' stamp: 'ar 4/4/2004 18:42'!onMenuBarChanged	<on: menuBarChanged in: player>	self onUpdateAll.! !!CWindowCostume methodsFor: 'events' stamp: 'ar 2/18/2004 13:38'!onMinimizeBoxChanged	<on: minimizeBoxChanged in: player>	windowFrame minimizeBox: player minimizeBox.! !!CWindowCostume methodsFor: 'events' stamp: 'ar 7/29/2004 08:11'!onMouseDown	"Raise the window on mouse down"	| focus |	<on: mouseDownListen>	container addLast: self.	focus := hand keyboardFocus.	focus ifNotNil:[		(focus asPrimCostume isIn: self asPrimCostume) 			ifFalse:[hand keyboardFocus: nil].	].! !!CWindowCostume methodsFor: 'events' stamp: 'ar 4/4/2004 18:42'!onPlayerChanged	super onPlayerChanged.	self onMinimizeBoxChanged.	self onMaximizeBoxChanged.	self onCloseBoxChanged.	self onLabelChanged.	self onUpdateAll.! !!CWindowCostume methodsFor: 'events' stamp: 'ar 4/4/2004 18:42'!onStatusBarChanged	<on: statusBarChanged in: player>	self onUpdateAll.! !!CWindowCostume methodsFor: 'events' stamp: 'ar 4/4/2004 18:42'!onToolBarChanged	<on: toolBarChanged in: player>	self onUpdateAll.! !!CWindowCostume methodsFor: 'events' stamp: 'ar 4/4/2004 18:42'!onUpdateAll	self removeAll.	self add: windowFrame.	player menuBar ifNotNil:[self add: player menuBar].	player toolBar ifNotNil:[self add: player toolBar].	self add: backPage.	self add: frontPage.	player statusBar ifNotNil:[self add: player statusBar].! !!CWindowCostume methodsFor: 'serializing' stamp: 'ar 3/25/2004 23:56'!readFieldsOn: deSerializer	super readFieldsOn: deSerializer.	frontPage elements: (deSerializer readField: #windowContents).! !!CWindowCostume methodsFor: 'serializing' stamp: 'ar 3/25/2004 23:55'!writeFieldsOn: aSerializer	super writeFieldsOn: aSerializer.	aSerializer writeField: #windowContents value: self windowContents.! !!CWindowCostumeFrame methodsFor: 'initialize' stamp: 'ar 3/22/2004 14:42'!initialize	super initialize.	self define: #closeButton as: CButton new.	self define: #windowLabel as: CLabel new.	self define: #collapseButton as: CButton new.! !!CWindowCostumeFrame methodsFor: 'initialize' stamp: 'tk 7/14/2004 11:28'!setupCostume	super setupCostume.	self asPrimCostume localCache: CFormCache new.	self roundCornerSpec: #(1 4).	self fillStyle: #verticalGradient.	self fillColors: CWidgetLibrary default gradientColors.	closeButton costume: CWindowButtonCostume new.	closeButton label: 'x'.	self add: closeButton.	windowLabel value:'Window'.	windowLabel clipping: true.	windowLabel textEmphasis: 1.	self add: windowLabel.	collapseButton costume: CWindowButtonCostume new.	collapseButton label: 'd'.	self add: collapseButton.	self layout: CTableLayout new.	self layout layoutInset: 3.	self layout listDirection: #leftToRight.	self hResizing: #spaceFill; vResizing: #shrinkWrap.! !!CWindowCostumeFrame methodsFor: 'accessing' stamp: 'ar 3/23/2004 23:36'!closeBox: aBool	closeButton visible: aBool! !!CWindowCostumeFrame methodsFor: 'accessing' stamp: 'ar 3/12/2004 16:28'!closeButton	"Answer the closeButton of the receiver"	<bewareOf: #closeButtonChanged>	^self propertyValueAt: #closeButton! !!CWindowCostumeFrame methodsFor: 'accessing' stamp: 'ar 3/12/2004 16:28'!closeButton: aValue	"Modify the receiver's closeButton"	^self propertyValueAt: #closeButton put: aValue with: #closeButtonChanged! !!CWindowCostumeFrame methodsFor: 'accessing' stamp: 'ar 3/12/2004 16:29'!collapseButton	"Answer the collapseButton of the receiver"	<bewareOf: #collapseButtonChanged>	^self propertyValueAt: #collapseButton! !!CWindowCostumeFrame methodsFor: 'accessing' stamp: 'ar 3/12/2004 16:29'!collapseButton: aValue	"Modify the receiver's collapseButton"	^self propertyValueAt: #collapseButton put: aValue with: #collapseButtonChanged! !!CWindowCostumeFrame methodsFor: 'accessing' stamp: 'ar 3/6/2004 21:08'!label	^windowLabel value! !!CWindowCostumeFrame methodsFor: 'accessing' stamp: 'ar 3/6/2004 21:07'!label: aString	windowLabel value: aString.! !!CWindowCostumeFrame methodsFor: 'accessing' stamp: 'ar 2/18/2004 13:39'!maximizeBox: aBool! !!CWindowCostumeFrame methodsFor: 'accessing' stamp: 'ar 3/23/2004 23:36'!minimizeBox: aBool	collapseButton visible: aBool.! !!CWindowCostumeFrame methodsFor: 'accessing' stamp: 'ar 3/25/2004 15:20'!windowColor: aColor	fillColors := {Color white. aColor}.! !!CWindowCostumeFrame methodsFor: 'accessing' stamp: 'ar 3/12/2004 16:29'!windowLabel	"Answer the windowLabel of the receiver"	<bewareOf: #windowLabelChanged>	^self propertyValueAt: #windowLabel! !!CWindowCostumeFrame methodsFor: 'accessing' stamp: 'ar 3/12/2004 16:29'!windowLabel: aValue	"Modify the receiver's windowLabel"	^self propertyValueAt: #windowLabel put: aValue with: #windowLabelChanged! !!CWindowCostumeFrame methodsFor: 'events' stamp: 'ar 2/16/2004 20:50'!onClose	<on: fire in: closeButton>	self signal: #closeRequest.! !!CWindowCostumeFrame methodsFor: 'events' stamp: 'ar 3/10/2004 00:03'!onCollapse	<on: fire in: collapseButton>	self signal: #collapseRequest.! !!CWindowResizeBehavior methodsFor: 'initialize' stamp: 'ar 4/30/2004 18:14'!initialize	super initialize.	automaticDragging := true.	resizeWithContents := true.! !!CWindowResizeBehavior methodsFor: 'accessing' stamp: 'ar 4/30/2004 18:10'!automaticDragging	"Answer the automaticDragging of the receiver"	<bewareOf: #automaticDraggingChanged>	^self propertyValueAt: #automaticDragging! !!CWindowResizeBehavior methodsFor: 'accessing' stamp: 'ar 4/30/2004 18:10'!automaticDragging: aValue	"Modify the receiver's automaticDragging"	^self propertyValueAt: #automaticDragging put: aValue with: #automaticDraggingChanged! !!CWindowResizeBehavior methodsFor: 'accessing' stamp: 'ar 4/30/2004 18:09'!resizeWithContents	"Answer the resizeWithContents of the receiver"	<bewareOf: #resizeWithContentsChanged>	^self propertyValueAt: #resizeWithContents! !!CWindowResizeBehavior methodsFor: 'accessing' stamp: 'ar 4/30/2004 18:09'!resizeWithContents: aValue	"Modify the receiver's resizeWithContents"	^self propertyValueAt: #resizeWithContents put: aValue with: #resizeWithContentsChanged! !!CWindowResizeBehavior methodsFor: 'events' stamp: 'ar 4/30/2004 18:17'!onResize	"Resize me"	| box newBox sideName resizeTarget |	<on: mouseDown in: target>	sideName := self resizerEdge ifNil:[		automaticDragging ifTrue:[^target onDrag].		^self].	self resizeWithContents ifTrue:[		resizeTarget := target.		self pauseScript: #onResizeTrack.		target mouseCursor := target mouseCursor asForm.	] ifFalse:[		resizeTarget := CPlayer new.		resizeTarget borderStyle: #simple.		resizeTarget borderWidth: 4.		resizeTarget borderColor: (Color white alpha: 0.5).		resizeTarget extent: target extent.		resizeTarget mouseCursor := target mouseCursor.		resizeTarget openIn: target container at: (target localToGlobal: 0@0).		target hand mouseFocus: resizeTarget.	].	target hand forEach: #mouseMove do:[		box := resizeTarget localBounds.		newBox := box perform: (sideName, ':') asSymbol with: resizeTarget cursorPoint.		resizeTarget moveBy: newBox origin.		resizeTarget width: newBox width.		resizeTarget height: newBox height.	] until: #mouseUp.	resizeTarget == target ifTrue:[		self resumeScript: #onResizeTrack.	] ifFalse:[		target position: resizeTarget position.		target extent: resizeTarget extent.		resizeTarget close.	].! !!CWindowResizeBehavior methodsFor: 'events' stamp: 'ar 4/30/2004 18:15'!onResizeTrack	| side |	<on: mouseMove in: target>	side := self resizerEdge.	side 		ifNil:[target mouseCursor := nil]		ifNotNil:[target mouseCursor := CCursorLibrary resizeForEdge: side].! !!CWindowResizeBehavior methodsFor: 'events' stamp: 'ar 4/30/2004 18:16'!resizerEdge	"Answer the edge of the receiver we wish to resize"	| pt box |	pt := target cursorPoint.	box := target localBounds.	#(topLeft topRight bottomLeft bottomRight) do:[:cc|		((box perform: cc) - pt) r < 10 ifTrue:[^cc].	].	(pt x - box left) < 4 ifTrue:[^#leftCenter].	(box right - pt x) < 4 ifTrue:[^#rightCenter].	(pt y - box top) < 4 ifTrue:[^#topCenter].	(box bottom - pt y) < 4 ifTrue:[^#bottomCenter].	^nil! !!CWorkspace methodsFor: 'accessing' stamp: 'ar 3/31/2004 15:18'!bindings	"Answer the bindings of the receiver"	<bewareOf: #bindingsChanged>	^self propertyValueAt: #bindings! !!CWorkspace methodsFor: 'accessing' stamp: 'ar 3/31/2004 15:18'!bindings: aValue	"Modify the receiver's bindings"	^self propertyValueAt: #bindings put: aValue with: #bindingsChanged! !!CWorkspace methodsFor: 'bindings' stamp: 'ar 3/31/2004 15:18'!bindingOf: aString	bindings isNil		ifTrue: [bindings _ Dictionary new].	(bindings includesKey: aString)		ifFalse: [bindings at: aString put: nil].	^bindings associationAt: aString! !!CWorldCostume methodsFor: 'accessing' stamp: 'ar 7/15/2003 16:35'!isWorld	^true! !!CWorldCostume methodsFor: 'accessing' stamp: 'ar 7/15/2003 16:16'!root	^self player! !!CWorldPlayer methodsFor: 'Morphic-support' stamp: 'bf 7/23/2004 12:37'!close	| w |	super close.	self syncScript.	w _ ownerMorph.	[(w isSystemWindow or: [w owner isPlayfieldLike])		ifTrue: [^w delete].	w isNil] whileFalse: [w _ w owner].! !!CWorldPlayer methodsFor: 'Morphic-support' stamp: 'ar 7/14/2003 11:01'!ownerMorph	^ownerMorph! !!CWorldPlayer methodsFor: 'Morphic-support' stamp: 'ar 7/14/2003 11:01'!ownerMorph: aMorph	ownerMorph := aMorph! !!CWorldPlayer methodsFor: 'Morphic-support' stamp: 'ar 7/14/2003 11:01'!runCroquetCycle	"Run a world cycle in the presence of Morphic.	The event queue is being hijacked for this..."	| event priorHand |	priorHand := ActiveHand.	^[		"Process pending events - only the primary hand here,		and we dispatch directly since the event has already been constructed."		ActiveHand := hands first.		eventQueue isEmpty ifTrue:[ActiveHand signal: #updateMouseOver].		[eventQueue isEmpty] whileFalse:[			event _ eventQueue next.			ActiveHand startScript: #dispatchEvent: withArguments:{event clone}.		].		"Run activated scripts"		scheduler runActiveScripts.		"Update layout"		self runLayoutCycle.	] on: Error do:[:ex|		ActiveHand interrupted.		ActiveHand := priorHand.		ex pass.	].! !!CWorldPlayer methodsFor: 'Morphic-support' stamp: 'ar 5/4/2004 17:46'!runMorphicCycle	"Run a world cycle in the presence of Morphic.	The event queue is being hijacked for this..."	| displaySize event priorHand |	"(eventQueue isEmpty not or:[scheduler hasActiveScripts]) ifFalse:[^#()]."	priorHand := ActiveHand.	^[		"Check if the display size has changed"		displaySize := display actualScreenSize.		displaySize = display extent ifFalse:[			display setExtent: displaySize depth: display depth.		].		self costume extent = display extent ifFalse:[			self costume extent: displaySize.			damageRecorder doFullRepaint.		].		"ActiveWorld _ self."		"Process pending events - only the primary hand here,		and we dispatch directly since the event has already been constructed."		ActiveHand := hands first.		eventQueue isEmpty ifTrue:[ActiveHand signal: #updateMouseOver].		[eventQueue isEmpty] whileFalse:[			event _ eventQueue next.			ActiveHand startScript: #dispatchEvent: withArguments:{event clone}.		].		"Run activated scripts"		scheduler runActiveScripts.		"Update layout"		self runLayoutCycle.		"Restore display - this will return the damage rectangles for the host"		self displayWorld.	] on: Error do:[:ex|		ActiveHand interrupted.		ActiveHand := priorHand.		ex pass.	].! !!CWorldPlayer methodsFor: 'running' stamp: 'ar 7/14/2003 11:40'!onDrop: aPlayer	aPlayer signal: #dropReject.! !!CWorldPlayer methodsFor: 'running' stamp: 'ar 7/14/2003 11:01'!run	"Run a world cycle"	| time |	[true] whileTrue:[		"TODO: Wait for activity. How it should work: Figure out when a) an input event comes in or b) some script gets activated (e.g., put onto the schedulers 'active' list).		@@@: This might be tricky since we are trying to prevent unneeded call chains (for process switching) in places like #waitProcessOn: Duh... how can we tell if some process just went onto that particular suspending list in order to wake us up??? Oh, well, I'll figure something out. @@@@"		time := Time millisecondsToRun:[self runWorldCycle].		(Delay forMilliseconds: (self minCycleTime - time max: 1)) wait.	].! !!CWorldPlayer methodsFor: 'running' stamp: 'ar 7/14/2003 11:01'!run: seconds	| timeOut |	timeOut := Time millisecondClockValue + (seconds*1000).	[Time millisecondClockValue <= timeOut] 		whileTrue:[self runWorldCycle].! !!CWorldPlayer methodsFor: 'running' stamp: 'ar 7/14/2003 11:01'!runLayoutCycle	"Run a layout cycle"	"NOTE: Scripts triggered by #layoutChanged may not work correctly if they don't complete before the world is displayed. In order to solve this problem, we recompute the layout changes here and do so repeatedly (!!) up to maxLayoutRounds in order to prevent infinite recursion. In addition, we randomize the number of layout rounds in order to supply visual feedback for conflicting constraints."	| layoutRepeat layoutMax |	layoutMax := maxLayoutRounds + (frameNumber bitAnd: 1).	layoutRepeat := 0.	[self costume layoutNeeded and:[		(layoutRepeat := layoutRepeat + 1) <= layoutMax]] whileTrue:[		self costume startScript: #fullBounds.		scheduler proceedActiveScripts.	].! !!CWorldPlayer methodsFor: 'running' stamp: 'ar 7/14/2003 11:28'!runWorldCycle	"Run a world cycle"	| displaySize |	"Check if the display size has changed"	displaySize := display actualScreenSize.	displaySize = display extent ifFalse:[		display setExtent: displaySize depth: display depth.	].	self extent = display extent ifFalse:[		self extent: displaySize.		damageRecorder doFullRepaint.	].	"ActiveWorld _ self."	"TODO: Wait for activity. How it should work: Figure out when a) an input event comes in or b) some script gets activated (e.g., put onto the schedulers 'active' list).	@@@: This might be tricky since we are trying to prevent unneeded call chains (for process switching) in places like #waitProcessOn: Duh... how can we tell if some process just went onto that particular suspending list in order to wake us up??? Oh, well, I'll figure something out. For now let's just go for 100% CPU usage ;-) @@@@"	"Process pending events"	hands do:[:h| h startScript: #processEvents].	"Note: Using #startScript: instead of just #signaling the occurance of an event serves the purpose of being able to debug any problems in event handling. If we would just #signal the event here any error in the hand would result in suspending that hand - meaning that there wouldn't be anyone who could potentially handle the events for the debugger (oops...).	@@@@: This needs to be changed - at least for the non-primary hands. I need to see if we can just 'restart' the primary hand's process event script each cycle. @@@@"	"Run activated scripts"	scheduler runActiveScripts.	"Update layout"	self runLayoutCycle.	"Restore display"	^self displayWorld.	"scheduler privateRunScript: #displayWorld in: self."	"@@@@: Conceptually, the above sucks since the #displayWorld script should be just like any other. However, it really cannot since other scripts *could* have been activated (e.g., released by some delay) since the last call to #proceedActiveScripts. In order to make VERY, VERY sure that this cannot happen we have this little backdoor into the scheduler. And yeah, I know it sucks but if you have a better solution then tell me.... @@@@"! !!CWorldPlayer methodsFor: 'hands' stamp: 'ar 7/14/2003 11:01'!addHand: aHand	"@@@@: Fix this. Needs to handle #outOfWorld etc. :@@@@"	aHand container ifNotNil:[aHand container removeHand: aHand].	aHand costume setContainer: self costume.	hands _ (hands copyWithout: aHand) copyWith: aHand.! !!CWorldPlayer methodsFor: 'hands' stamp: 'ar 7/14/2003 11:01'!hands	^hands! !!CWorldPlayer methodsFor: 'hands' stamp: 'ar 7/14/2003 11:01'!primaryHand	^hands first! !!CWorldPlayer methodsFor: 'hands' stamp: 'ar 7/14/2003 11:01'!removeHand: aHand	"@@@@: Fix this. Needs to handle #outOfWorld etc. :@@@@"	(hands includes: aHand) ifFalse: [^self].	aHand invalidate.	hands _ hands copyWithout: aHand.! !!CWorldPlayer methodsFor: 'accessing' stamp: 'ar 3/28/2004 23:37'!activeProject	"Answer the currently active project"	<bewareOf: #activeProjectChanged>	^activeProject! !!CWorldPlayer methodsFor: 'accessing' stamp: 'bf 3/30/2004 11:32'!activeProject: aProject	"Set the currently active project"	activeProject ifNotNil:[activeProject signal: #passivate with: self].	activeProject := aProject.	self signal: #activeProjectChanged.	activeProject ifNotNil:[activeProject signal: #activate with: self].	^activeProject! !!CWorldPlayer methodsFor: 'accessing' stamp: 'ar 7/14/2003 11:01'!display	"Answer the display this world is shown on"	^display! !!CWorldPlayer methodsFor: 'accessing' stamp: 'ar 9/8/2004 16:25'!display: aDisplayScreen	"Set my display this world is shown on"	display == aDisplayScreen ifTrue:[^self].	self signalChanged: #displayChanged from: display to: aDisplayScreen.	display := aDisplayScreen.	display ifNotNil:[self costume extent: display extent].	self costume localCache form: display.! !!CWorldPlayer methodsFor: 'accessing' stamp: 'ar 2/7/2004 21:59'!displayDepth: bpp	display setExtent: display extent depth: bpp.	self invalidate.! !!CWorldPlayer methodsFor: 'accessing' stamp: 'ar 7/15/2003 20:25'!displayExtent	^display extent! !!CWorldPlayer methodsFor: 'accessing' stamp: 'ar 7/15/2003 20:25'!displayExtent: aPoint	display setExtent: aPoint depth: display depth.	self invalidate.! !!CWorldPlayer methodsFor: 'accessing' stamp: 'ar 7/14/2003 11:01'!eventQueue	"Answer the event queue being used for retrieving input events"	^eventQueue! !!CWorldPlayer methodsFor: 'accessing' stamp: 'ar 7/14/2003 11:01'!eventQueue: aSharedQueue	"Install the event queue being used for retrieving input events"	eventQueue := aSharedQueue! !!CWorldPlayer methodsFor: 'accessing' stamp: 'ar 12/7/2003 18:14'!label	ownerMorph ifNil:[^''].	^ownerMorph label! !!CWorldPlayer methodsFor: 'accessing' stamp: 'bf 7/23/2004 12:19'!label: aString	ownerMorph ifNil:[^nil].	(ownerMorph respondsTo: #label:) ifFalse: [^nil].	^ownerMorph label: aString! !!CWorldPlayer methodsFor: 'accessing' stamp: 'ar 7/14/2003 11:01'!maxLayoutRounds	"Answer the maximum number of retries for computing layouts"	^maxLayoutRounds! !!CWorldPlayer methodsFor: 'accessing' stamp: 'ar 7/14/2003 11:01'!maxLayoutRounds: aNumber	"Set the maximum number of retries for computing layouts"	maxLayoutRounds := aNumber max: 1.! !!CWorldPlayer methodsFor: 'accessing' stamp: 'ar 7/14/2003 11:01'!minCycleTime	"Answer the minimal time one world cycle should take. If the current cycle is faster then we may give the host OS a few cycles back"	^20! !!CWorldPlayer methodsFor: 'accessing' stamp: 'ar 7/14/2003 11:01'!scheduler	"Answer this world's script scheduler"	^scheduler! !!CWorldPlayer methodsFor: 'private' stamp: 'ar 7/14/2003 11:01'!isSpecialSystemScript: scriptDescriptor	"Some scripts need to be run for debugging and cannot stopped for debugging"	^(super isSpecialSystemScript: scriptDescriptor) or:[scriptDescriptor == #displayWorld]! !!CWorldPlayer methodsFor: 'private' stamp: 'ar 7/14/2003 11:01'!setScheduler: aScriptScheduler	scheduler := aScriptScheduler.! !!CWorldPlayer methodsFor: 'geometry' stamp: 'ar 7/14/2003 11:03'!standardBounds	"Answer the standard bounds for this world - inset by the menu if present"	^self costume localBounds! !!CWorldPlayer methodsFor: 'initialize' stamp: 'bf 7/23/2004 10:52'!bootstrap: aBlock	"Bootstrap message for otherworldly senders"	| bootstrap |	bootstrap := self startScript: aBlock.	[bootstrap isDone] whileFalse:[scheduler runActiveScripts].! !!CWorldPlayer methodsFor: 'initialize' stamp: 'ar 10/4/2004 21:52'!initialize	"Bootstrap a new world"	super initialize.	scheduler ifNil:[		scheduler := ScriptScheduler new.		"set the context for any newly spawned scripts"		scheduler runActiveScripts.	].	frameNumber := 0.	self name: 'World'.	damageRecorder := CDamageRecorder new.	maxLayoutRounds := 3.	self costume: CWorldCostume new.	self costume localCache: CFormCache new.	self clipping: true.	self userDraw: true.	self color: (Color gray: 0.5).	hands _ #().	self addHand: CHandPlayer new.	"Default to Display"	self display: Display.	"Default to primary input queue"	self eventQueue: Sensor eventQueue.	self bootstrap:[self onBootstrap].! !!CWorldPlayer methodsFor: 'initialize' stamp: 'ar 4/2/2004 15:00'!onBootstrap	"Load auto load targets"	| project |	self startScript: #onDrop: when: {self. #dragDrop}.	"project := CPlayer loadPlayerFrom: #('Projects' 'ProjectBuilder.sqp')."	project := CProjectBuilder new.	project window: self.	project origin: 0@0.	project costume isWorld: true.	self add: project.	self activeProject: project.! !!CWorldPlayer methodsFor: 'drawing' stamp: 'ar 7/14/2003 11:01'!displayWorld	"@@@@: This needs to be moved into a special cache - it doesn't belong here :@@@@"	| myCanvas rectList validList rectToFill flashList recorder |	frameNumber := frameNumber + 1 bitAnd: SmallInteger maxVal.	display deferUpdates: true.	myCanvas := CTransformCanvas on: display.	recorder := self costume localCache damageRecorder.	rectList := recorder invalidRectsFullBounds: self costume bounds.	"sort by areas to draw largest portions first"	rectList := rectList asArray sort:[:r1 :r2| r1 area > r2 area].	recorder reset.	validList := OrderedCollection new: rectList size.	rectToFill := nil.	rectList do: [:dirtyRect |		dirtyRect allAreasOutsideList: validList do:[:r| 			rectToFill 				ifNil:[rectToFill := r copy]				ifNotNil:[rectToFill := rectToFill quickMerge: r].			validList add: r]].	rectToFill ifNotNil:[		myCanvas clipBy: rectToFill during:[:cc| 			self costume topDownFullDrawOn: cc damageList: validList.			hands do:[:h| h costume fullDrawOn: myCanvas].			"hands do:[:h| h costume topDownFullDrawOn: myCanvas damageList: validList]."		].		"hands do:[:h| h fullDrawOn: myCanvas damageList: validList]."	].	myCanvas finish.	flashList := validList.	bltRects ifNotNil:[		"Merge the blt rects"		validList := OrderedCollection new: flashList size + bltRects size.		validList addAll: bltRects.		flashList do:[:rect| rect allAreasOutsideList: bltRects do:[:r| validList add: r]].		bltRects := nil].	display forceDamageToScreen: validList.	false ifTrue:[self flashRects: flashList color: Color cyan].	display deferUpdates: false.	"Sender might need the damage rectangles"	^validList! !!CWorldPlayer methodsFor: 'drawing' stamp: 'ar 7/14/2003 11:01'!flashRects: rectangleList color: aColor	"For testing. Flashes the given list of rectangles on the Display so you can watch incremental redisplay at work."	"Details: Uses two reverses so that the display is restored to its original state. This is necessary when in deferred update mode."	| blt |	blt _ (BitBlt toForm: display)		fillColor: aColor;		sourceOrigin: 0@0;		combinationRule: Form reverse.	rectangleList do: [:r | blt destRect: r; copyBits].	rectangleList do:[:r| display forceToScreen: r].	display forceDisplayUpdate.	(Delay forMilliseconds: 100) wait.	rectangleList do: [:r | blt destRect: r; copyBits].	rectangleList do:[:r| display forceToScreen: r].	display forceDisplayUpdate.! !!CWorldPlayer methodsFor: 'serializing' stamp: 'ar 9/24/2003 11:34'!serializeOn: aSerializer	^aSerializer writeGlobal: #ActiveHand constructor: #world! !!Canvas methodsFor: '*Tweak' stamp: 'ar 12/8/2002 01:16'!draw: aCostume damageList: damageList	| box |	box := aCostume fullBounds.	damageList do:[:rect|		(box intersects: rect) ifTrue:[self clipBy: rect during:[:cc| cc draw: aCostume]].	].! !!Canvas methodsFor: '*Tweak' stamp: 'ar 6/5/2003 18:37'!drawLineFrom: startPoint to: endPoint using: aBrush	^self line: startPoint to: endPoint brushForm: aBrush! !!Canvas methodsFor: '*Tweak' stamp: 'ar 12/8/2002 01:18'!fillOval: aRectangle fillStyle: aFillStyle borderStyle: aBorderStyle	^self fillOval: aRectangle fillStyle: aFillStyle borderWidth: aBorderStyle width borderColor: aBorderStyle color! !!Canvas methodsFor: '*Tweak' stamp: 'ar 12/8/2002 01:18'!fillRectangle: aRectangle fill: aFill border: aBorder			 	 	 	 	 	"@@@@: Fix this. Remove the old interface. :@@@@"	^self fillRectangle: aRectangle fillStyle: aFill borderStyle: aBorder! !!Canvas methodsFor: '*Tweak' stamp: 'ar 12/8/2002 01:17'!fillRectangle: aRectangle fillStyle: aFillStyle borderStyle: aBorderStyle	"Fill the given rectangle."	aFillStyle isTransparent ifFalse:[		self fillRectangle: (aRectangle insetBy: aBorderStyle width) fillStyle: aFillStyle].	aBorderStyle ifNil:[^self].	aBorderStyle width <= 0 ifTrue:[^self].	aBorderStyle frameRectangle: aRectangle on: self! !!Canvas methodsFor: '*Tweak' stamp: 'ar 12/8/2002 01:17'!fullDraw: aCostume damageList: damageList	| box |	box := aCostume fullBounds.	damageList do:[:rect|		(box intersects: rect) ifTrue:[self clipBy: rect during:[:cc| cc fullDraw: aCostume]].	].! !!Canvas methodsFor: '*Tweak' stamp: 'ar 12/8/2002 01:58'!seesRoundedCornerOf: aRectangle	"Return true if this canvas sees any of the rounded corners of aRectangle"	| roundRect clipRect |	roundRect := aRectangle insetBy: CCornerRounder cornerSize.	clipRect := self clipRect.	"Check horizontal overlaps"	(clipRect origin x >= roundRect origin x 		and:[clipRect corner x <= roundRect corner x]) ifTrue:[^false].	"Check vertical overlaps"	(clipRect origin y >= roundRect origin y		and:[clipRect corner y <= roundRect corner y]) ifTrue:[^false].	^true! !!Canvas methodsFor: '*Tweak' stamp: 'ar 6/24/2003 15:13'!warpImage: aForm transform: aTransform at: extraOffset	"Warp the given form using aTransform.	TODO: Use transform to figure out appropriate cell size"	^self warpImage: aForm transform: aTransform at: extraOffset sourceRect: aForm boundingBox cellSize: aTransform warpCellSize! !!Canvas methodsFor: '*Tweak' stamp: 'bf 4/3/2004 02:28'!warpImage: aForm transform: aTransform sourceRect: aRectangle	"Warp the given portion of aForm using aTransform."	^self warpImage: aForm transform: aTransform at: 0@0 sourceRect: aRectangle cellSize: aTransform warpCellSize! !!ChangeSet methodsFor: '*Tweak' stamp: 'ar 5/5/2004 23:34'!fatDefForClass: class	| newDef oldDef oldStrm newStrm outStrm oldVars newVars addedVars |	(class includesBehavior: CProtoObject) ifTrue:[^class definition].	newDef _ class definition.	oldDef _ (self changeRecorderFor: class) priorDefinition.	oldDef ifNil: [^ newDef].	oldDef = newDef ifTrue: [^ newDef].	oldStrm _ ReadStream on: oldDef.	newStrm _ ReadStream on: newDef.	outStrm _ WriteStream on: (String new: newDef size * 2).	"Merge inst vars from old and new defs..."	oldStrm upToAll: 'instanceVariableNames'; upTo: $'.	outStrm 		nextPutAll: (newStrm upToAll: 'instanceVariableNames'); 		nextPutAll: 'instanceVariableNames:'.	newStrm peek = $: ifTrue: [newStrm next].	"may or may not be there, but already written"	outStrm		nextPutAll: (newStrm upTo: $'); nextPut: $'.	oldVars _ (oldStrm upTo: $') findTokens: Character separators.	newVars _ (newStrm upTo: $') findTokens: Character separators.	addedVars _ oldVars asSet addAll: newVars; removeAll: oldVars; asOrderedCollection.	oldVars , addedVars do: [:var | outStrm nextPutAll: var; space].	outStrm nextPut: $'.	class isMeta ifFalse:		["Merge class vars from old and new defs..."		oldStrm upToAll: 'classVariableNames:'; upTo: $'.		outStrm nextPutAll: (newStrm upToAll: 'classVariableNames:'); nextPutAll: 'classVariableNames:';			nextPutAll: (newStrm upTo: $'); nextPut: $'.		oldVars _ (oldStrm upTo: $') findTokens: Character separators.		newVars _ (newStrm upTo: $') findTokens: Character separators.		addedVars _ oldVars asSet addAll: newVars; removeAll: oldVars; asOrderedCollection.		oldVars , addedVars do: [:var | outStrm nextPutAll: var; space].		outStrm nextPut: $'].	outStrm nextPutAll: newStrm upToEnd.	^ outStrm contents! !!CharacterBlockScanner methodsFor: '*Tweak' stamp: 'ar 8/18/2003 21:16'!cr 	"Answer a CharacterBlock that specifies the current location of the mouse 	relative to a carriage return stop condition that has just been 	encountered. The ParagraphEditor convention is to denote selections by 	CharacterBlocks, sometimes including the carriage return (cursor is at 	the end) and sometimes not (cursor is in the middle of the text)."	((characterIndex ~= nil		and: [characterIndex > text size])			or: [(line last = text size)				and: [(destY + line lineHeight) < characterPoint y]])		ifTrue:	["When off end of string, give data for next character"				destY _ destY +  line lineHeight.				lastCharacter _ nil.				characterPoint _ (nextLeftMargin ifNil: [leftMargin]) @ destY.				lastIndex _ lastIndex + 1.				self lastCharacterExtentSetX: 0.				^ true].		lastCharacter _ CR.		characterPoint _ destX @ destY.		"ar 8/18/2003: Why would we set the character block's extent to the rest of the line here? It screws up scrolling as suddenly we will try *really* hard to show the rest of the line, so I removed it."		"self lastCharacterExtentSetX: rightMargin - destX."		^true! !!ClassDescription methodsFor: '*Tweak' stamp: 'ar 5/5/2004 23:35'!browserDefinition: style	"Answer a String that defines the receiver."	^self definitionST80! !!ClassDescription methodsFor: '*Tweak' stamp: 'ar 9/25/2003 00:15'!serializeOn: aSerializer	^aSerializer writeClass: self! !!Class methodsFor: '*Tweak' stamp: 'bf 7/22/2004 13:30'!nameForDisplay	^self name! !!Class methodsFor: '*Tweak' stamp: 'ar 9/19/2003 01:18'!sourceCode	^String streamContents:[:s| self fileOutOn: s]! !!Behavior class methodsFor: '*Tweak-Resources' stamp: 'ar 12/2/2003 23:17'!importXmlResource: xmlNode in: loader	^loader importClass: xmlNode! !!CBorder class methodsFor: 'instance creation'!borderStyleChoices	"Answer the superset of all supported borderStyle symbols"	^ #(simple inset raised complexAltFramed complexAltInset complexAltRaised complexFramed complexInset complexRaised)! !!CBorder class methodsFor: 'instance creation'!borderStyleForSymbol: sym	"Answer a border style corresponding to the given symbol"	| aSymbol |	aSymbol _ sym == #none ifTrue: [#simple] ifFalse: [sym].	^ self perform: aSymbol! !!CBorder class methodsFor: 'instance creation'!color: aColor width: aNumber	^self width: aNumber color: aColor! !!CBorder class methodsFor: 'instance creation'!complexAltFramed	^CComplexBorder style: #complexAltFramed! !!CBorder class methodsFor: 'instance creation'!complexAltInset	^CComplexBorder style: #complexAltInset! !!CBorder class methodsFor: 'instance creation'!complexAltRaised	^CComplexBorder style: #complexAltRaised! !!CBorder class methodsFor: 'instance creation'!complexFramed	^CComplexBorder style: #complexFramed! !!CBorder class methodsFor: 'instance creation'!complexInset	^CComplexBorder style: #complexInset! !!CBorder class methodsFor: 'instance creation'!complexRaised	^CComplexBorder style: #complexRaised! !!CBorder class methodsFor: 'instance creation'!default	^Default ifNil:[Default _ self new]! !!CBorder class methodsFor: 'instance creation'!inset	^CInsetBorder new! !!CBorder class methodsFor: 'instance creation'!none	^self default! !!CBorder class methodsFor: 'instance creation'!raised	^CRaisedBorder new! !!CBorder class methodsFor: 'instance creation'!simple	"Answer a simple border style"	^ CSimpleBorder new! !!CBorder class methodsFor: 'instance creation'!width: aNumber	^self width: aNumber color: Color black! !!CBorder class methodsFor: 'instance creation'!width: aNumber color: aColor	^CSimpleBorder new color: aColor; width: aNumber; yourself! !!CClipboard class methodsFor: 'accessing' stamp: 'ar 12/17/2002 15:28'!clipboardAt: formatName	^self default clipboardAt: formatName! !!CClipboard class methodsFor: 'accessing' stamp: 'ar 12/17/2002 15:29'!clipboardAt: formatName put: bytes	^self default clipboardAt: formatName put: bytes! !!CClipboard class methodsFor: 'accessing' stamp: 'ar 12/17/2002 15:15'!clipboardClear	^self default clipboardClear! !!CClipboard class methodsFor: 'accessing' stamp: 'ar 12/17/2002 15:15'!clipboardFormats	^self default clipboardFormats! !!CClipboard class methodsFor: 'accessing' stamp: 'ar 12/17/2002 15:14'!clipboardText "Clipboard clipboardText"	^self default clipboardText.! !!CClipboard class methodsFor: 'accessing'!clipboardText: aText				 	^self default clipboardText: aText! !!CClipboard class methodsFor: 'accessing'!default	^Default ifNil:[Default _ self new].! !!CClipboard class methodsFor: 'accessing'!default: aClipboard	"So that clients can switch between different default clipboards"	Default _ aClipboard.! !!CClipboard class methodsFor: 'instance creation'!new	^super new initialize.! !!CCollectionMatcher class methodsFor: 'instance creation' stamp: 'ar 3/14/2004 16:31'!on: aCollection	^(self new) privateSetCollectionTarget: aCollection! !!CCornerRounder class methodsFor: 'all' stamp: 'ar 12/8/2002 01:57'!cornerSize	"Return the size of a rounded corner"	^6@6! !!CCornerRounder class methodsFor: 'all' stamp: 'ar 12/8/2002 02:06'!initialize  "CCornerRounder initialize"	CR0 _ CR1 _ self new		masterMask:			(Form extent: 6@6				fromArray: #(2r1e26 2r111e26 2r1111e26 2r11111e26 2r11111e26 2r111111e26)				offset: 0@0)		masterOverlay:			(Form extent: 6@6				fromArray: #(2r1e26 2r110e26 2r1000e26 2r10000e26 2r10000e26 2r100000e26)				offset: 0@0).	CR2 _ self new		masterMask:			(Form extent: 6@6				fromArray: #(2r1e26 2r111e26 2r1111e26 2r11111e26 2r11111e26 2r111111e26)				offset: 0@0)		masterOverlay:			(Form extent: 6@6				fromArray: #(2r1e26 2r111e26 2r1111e26 2r11100e26 2r11000e26 2r111000e26)				offset: 0@0).! !!CCornerRounder class methodsFor: 'all' stamp: 'ar 12/8/2002 01:57'!rectWithinCornersOf: aRectangle	"Return a single sub-rectangle that lies entirely inside corners	that are made by me.	Used to identify large regions of window that do not need to be redrawn."	aRectangle height >= aRectangle width		ifTrue:[^ aRectangle insetBy: 0@6]		ifFalse:[^ aRectangle insetBy: 6@0]! !!CCornerRounder class methodsFor: 'all' stamp: 'ar 12/8/2002 01:56'!roundCornersOf: aMorph on: aCanvas in: bounds displayBlock: displayBlock borderWidth: w corners: aList	| rounder |	rounder _ CR0.	w = 1 ifTrue: [rounder _ CR1].	w = 2 ifTrue: [rounder _ CR2].	rounder _ rounder copy.	rounder saveBitsUnderCornersOf: aMorph on: aCanvas in: bounds corners: aList.	displayBlock value.	rounder tweakCornersOf: aMorph on: aCanvas in: bounds borderWidth: w corners: aList! !!CCostumePen class methodsFor: 'accessing'!defaultColor	^Color blue! !!CCostumePen class methodsFor: 'accessing'!defaultWidth	^1! !!CCostumePen class methodsFor: 'instance creation'!new	^super new initialize! !!CCursorLibrary class methodsFor: 'initialize' stamp: 'ar 3/13/2004 21:26'!initialize	"CCursorLibrary initialize"	Default := IdentityDictionary new.! !!CCursorLibrary class methodsFor: 'accessing' stamp: 'ar 3/13/2004 21:26'!default	^Default ifNil:[Default := IdentityDictionary new]! !!CCursorLibrary class methodsFor: 'accessing' stamp: 'ar 3/13/2004 21:15'!default: aDictionary	Default := aDictionary.! !!CCursorLibrary class methodsFor: 'accessing' stamp: 'ar 4/27/2004 15:10'!resizeForEdge: aSymbol	aSymbol == #top ifTrue:[^self topBottomCursor].	aSymbol == #bottom ifTrue:[^self topBottomCursor].	aSymbol == #topCenter ifTrue:[^self topBottomCursor].	aSymbol == #bottomCenter ifTrue:[^self topBottomCursor].	aSymbol == #left ifTrue:[^self leftRightCursor].	aSymbol == #right ifTrue:[^self leftRightCursor].	aSymbol == #leftCenter ifTrue:[^self leftRightCursor].	aSymbol == #rightCenter ifTrue:[^self leftRightCursor].	aSymbol == #topLeft ifTrue:[^self topLeftCursor].	aSymbol == #bottomRight ifTrue:[^self topLeftCursor].	aSymbol == #topRight ifTrue:[^self topRightCursor].	aSymbol == #bottomLeft ifTrue:[^self topRightCursor].	^self dragCursor! !!CCursorLibrary class methodsFor: 'cursors' stamp: 'ar 3/13/2004 21:27'!bottomLeftCursor	"CCursorLibrary bottomLeftCursor show"	^self topRightCursor! !!CCursorLibrary class methodsFor: 'cursors' stamp: 'ar 3/13/2004 21:26'!bottomRightCursor	"CCursorLibrary bottomRightCursor show"	^self topLeftCursor! !!CCursorLibrary class methodsFor: 'cursors' stamp: 'ar 3/13/2004 21:27'!diagonalCursor	"CCursorLibrary diagonalCursor show"	^Default at: #DiagonalCursor ifAbsentPut:[		(Cursor extent: 16@16 fromArray: #(			2r0000000000000000			2r0000000000000000			2r0000000000000000			2r0000111000111000			2r0000110000011000			2r0000101000101000			2r0000000101000000			2r0000000010000000			2r0000000101000000			2r0000101000101000			2r0000110000011000			2r0000111000111000			2r0000000000000000			2r0000000000000000			2r0000000000000000			2r0000000000000000)		offset: -7@-7) withMask	].! !!CCursorLibrary class methodsFor: 'cursors' stamp: 'ar 3/13/2004 21:27'!dragCursor	"CCursorLibrary dragCursor show"	^Default at: #DragCursor ifAbsentPut:[		(Cursor extent: 16@16 fromArray: #(			2r00000000000000000			2r00000000100000000			2r00000001110000000			2r00000011111000000			2r00000000100000000			2r00001000100010000			2r00011000100011000			2r00111111111111100			2r00011000100011000			2r00001000100010000			2r00000000100000000			2r00000011111000000			2r00000001110000000			2r00000000100000000			2r00000000000000000			2r00000000000000000 )		offset: -7@-7 ) withMask	].! !!CCursorLibrary class methodsFor: 'cursors' stamp: 'ar 3/13/2004 21:36'!fistCursor	"CCursorLibrary fistCursor show" 	^Default at:	#FistCursor ifAbsentPut:[		((CursorWithMask		extent: 16@16		depth: 1		fromArray: #( 0 0 0 0 0 229638144 306970624 269090816 134348800 402784256 537001984 537133056 268697600 134742016 67633152 67633152)		offset: -5@-9) setMaskForm: (Form		extent: 16@16		depth: 1		fromArray: #( 0 0 0 0 0 229638144 536608768 536739840 268304384 536739840 1073610752 1073479680 536608768 267911168 133693440 133693440)		offset: 0@0))	].! !!CCursorLibrary class methodsFor: 'cursors' stamp: 'ar 3/13/2004 21:36'!handCursor	"CCursorLibrary handCursor show" 	^Default at:	#HandCursor ifAbsentPut:[		((CursorWithMask		extent: 16@16		depth: 1		fromArray: #( 25165824 443547648 642252800 642383872 307036160 306774016 1745420288 2550202368 2281832448 1073872896 537001984 537133056 268697600 134742016 67633152 67633152)		offset: -5@-9) setMaskForm: (Form		extent: 16@16		depth: 1		fromArray: #( 25165824 468713472 1073217536 1073348608 536805376 536805376 1878982656 4294901760 4294836224 2147352576 1073610752 1073479680 536608768 267911168 133693440 133693440)		offset: 0@0))	].! !!CCursorLibrary class methodsFor: 'cursors' stamp: 'ar 3/13/2004 21:27'!leftRightCursor	"CCursorLibrary leftRightCursor show"	^Default at: #LeftRightCursor ifAbsentPut:[		(Cursor extent: 16@16 fromArray: #(			2r0000000000000000			2r0000000000000000			2r0000000000000000			2r0000000000000000			2r0000010000010000			2r0000110000011000			2r0001110000011100			2r0011111111111110			2r0001110000011100			2r0000110000011000			2r0000010000010000			2r0000000000000000			2r0000000000000000			2r0000000000000000			2r0000000000000000			2r0000000000000000 )		offset: -7@-7 ) withMask	].! !!CCursorLibrary class methodsFor: 'cursors' stamp: 'ar 3/13/2004 21:28'!textCursor	"CCursorLibrary textCursor show" 	^Default at:	#TextCursor ifAbsentPut:[		(Cursor extent: 16@16 fromArray: #(				2r0000000000000000				2r0000011011000000				2r0000000100000000				2r0000000100000000				2r0000000100000000				2r0000000100000000				2r0000000100000000				2r0000000100000000				2r0000000100000000				2r0000000100000000				2r0000000100000000				2r0000000100000000				2r0000000100000000				2r0000000100000000				2r0000011011000000				2r0000000000000000)		offset: -7@-7) withMask	].! !!CCursorLibrary class methodsFor: 'cursors' stamp: 'ar 3/13/2004 21:28'!topBottomCursor	"CCursorLibrary topBottomCursor show"	^Default at: #TopBottomCursor ifAbsentPut:[		(Cursor extent: 16@16 fromArray: #(			2r0000000000000000			2r0000000010000000			2r0000000111000000			2r0000001111100000			2r0000011111110000			2r0000000010000000			2r0000000010000000			2r0000000010000000			2r0000000010000000			2r0000000010000000			2r0000011111110000			2r0000001111100000			2r0000000111000000			2r0000000010000000			2r0000000000000000			2r0000000000000000 )		offset: -7@-7 ) withMask	].! !!CCursorLibrary class methodsFor: 'cursors' stamp: 'ar 3/13/2004 21:28'!topLeftCursor	"CCursorLibrary topLeftCursor show"	^Default at: #TopLeftCursor ifAbsentPut:[		(Cursor extent: 16@16 fromArray: #(			2r0000000000000000			2r0000000000000000			2r0001111100000000			2r0001111000000000			2r0001110000000000			2r0001101000000000			2r0001000100000000			2r0000000010000000			2r0000000001000100			2r0000000000101100			2r0000000000011100			2r0000000000111100			2r0000000001111100			2r0000000000000000			2r0000000000000000			2r0000000000000000)		offset: -7@-7) withMask	].! !!CCursorLibrary class methodsFor: 'cursors' stamp: 'ar 3/13/2004 21:28'!topRightCursor	"CCursorLibrary topRightCursor show"	^Default at: #TopRightCursor ifAbsentPut:[		(Cursor extent: 16@16 fromArray: #(			2r0000000000000000			2r0000000000000000			2r0000000001111100			2r0000000000111100			2r0000000000011100			2r0000000000101100			2r0000000001000100			2r0000000010000000			2r0001000100000000			2r0001101000000000			2r0001110000000000			2r0001111000000000			2r0001111100000000			2r0000000000000000			2r0000000000000000			2r0000000000000000)		offset: -7@-7) withMask.	].! !!CDamageRecorder class methodsFor: 'instance creation'!new	^ super new reset! !!CDeserializer class methodsFor: 'as yet unclassified' stamp: 'ar 9/18/2003 16:09'!deserialize: anObject	^self new deserialize: anObject! !!CDeserializer class methodsFor: 'as yet unclassified' stamp: 'ar 9/18/2003 16:09'!new	^super new initialize! !!CDisplayTransform class methodsFor: 'instance creation'!identity	^self new setIdentity! !!CFormCache class methodsFor: 'instance creation'!new	^super new initialize! !!CGraphicsFill class methodsFor: 'instance creation' stamp: 'ar 12/7/2002 21:58'!none	^Color transparent! !!CGraphicsFill class methodsFor: 'instance creation' stamp: 'ar 12/7/2002 21:58'!solid	^Color white! !!CIconLibrary class methodsFor: 'instance creation'!new	^super new initialize! !!CIconLibrary class methodsFor: 'class initialization'!initialize	"IconLibrary initialize"	self default loadDefaultIcons.! !!CIconLibrary class methodsFor: 'accessing'!at: iconName	^self default at: iconName.! !!CIconLibrary class methodsFor: 'accessing'!default	^Default ifNil:[Default := self new].! !!CIdentityTransform class methodsFor: 'instance creation'!new	"There can be only one"	^Default! !!CIdentityTransform class methodsFor: 'class initialization'!initialize	"CIdentityTransform initialize"	Default _ self basicNew.! !!CKeyboardDispatchTable class methodsFor: 'instance creation'!new	^super new initialize! !!CLayoutFrame class methodsFor: 'as yet unclassified'!classVersion	^1 "changed treatment of bottomOffset and rightOffset"! !!CLayoutFrame class methodsFor: 'as yet unclassified'!fractions: fractionsOrNil	^self fractions: fractionsOrNil offsets: nil! !!CLayoutFrame class methodsFor: 'as yet unclassified'!fractions: fractionsOrNil offsets: offsetsOrNil	| fractions offsets |	fractions _ fractionsOrNil ifNil: [0@0 extent: 0@0].	offsets _ offsetsOrNil ifNil: [0@0 extent: 0@0].	^self new		topFraction: fractions top offset: offsets top;		leftFraction: fractions left offset: offsets left;		bottomFraction: fractions bottom offset: offsets bottom;		rightFraction: fractions right offset: offsets right! !!CLayoutFrame class methodsFor: 'as yet unclassified'!offsets: offsetsOrNil	^self fractions: nil offsets: offsetsOrNil! !!CLayoutProperties class methodsFor: 'instance creation'!new	^super new initialize! !!CMD5Hasher class methodsFor: 'utilities' stamp: 'DSM 1/20/2000 18:03'!hashMessage: aStringOrByteArray	^ self new hashMessage: aStringOrByteArray! !!CMD5Hasher class methodsFor: 'utilities' stamp: 'DSM 1/20/2000 18:03'!hashStream: aPositionableStream	^ self new hashStream: aPositionableStream! !!CMD5Hasher class methodsFor: 'testing' stamp: 'ar 3/25/2004 19:27'!test	"CMD5Hasher test"	(CMD5Hasher hashMessage: 'a') = 16r0CC175B9C0F1B6A831C399E269772661		ifFalse: [ self error: 'failed'].	(CMD5Hasher hashMessage: 'abc') = 16r900150983CD24FB0D6963F7D28E17F72		ifFalse: [ self error: 'failed'].	(CMD5Hasher hashMessage: 'message digest') = 16rF96B697D7CB7938D525A2F31AAF161D0		ifFalse: [ self error: 'failed'].	(CMD5Hasher hashMessage:		'abcdefghijklmnopqrstuvwxyz') = 16rC3FCD3D76192E4007DFB496CCA67E13B		ifFalse: [ self error: 'failed'].	(CMD5Hasher hashMessage:	'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789') =		16rD174AB98D277D9F5A5611C2C9F419D9F		ifFalse: [ self error: 'failed'].	(CMD5Hasher hashMessage:	'12345678901234567890123456789012345678901234567890123456789012345678901234567890') = 		16r57EDF4A22BE3C955AC49DA2E2107B67A		ifFalse: [ self error: 'failed'].! !!CMD5Hasher class methodsFor: 'class initialization' stamp: 'ar 3/14/2004 01:35'!initialize	"MD5 initialize"	"Obscure fact: those magic hex numbers that are hard to type in correctly are	actually the result of a simple trigonometric function and are therefore	easier to compute than proofread.  Laziness is sometimes a virtue."	| c |	c _ 2 raisedTo: 32.	SinTable _ Array new: 64.	1 to: 64 do: [ :i |		SinTable			at: i			put: (ThirtyTwoBitRegister new load: (c * i sin abs) truncated)].	ShiftTable _ {		#(7 12 17 22).		#(5 9 14 20).		#(4 11 16 23).		#(6 10 15 21)		}.	IndexTable _ {		#(1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16).		#(2 7 12 1 6 11 16 5 10 15 4 9 14 3 8 13).		#(6 9 12 15 2 5 8 11 14 1 4 7 10 13 16 3).		#(1 8 15 6 13 4 11 2 9 16 7 14 5 12 3 10)		}.	ABCDTable _ {		#(1 2 3 4).		#(4 1 2 3).		#(3 4 1 2).		#(2 3 4 1)		}! !!CMatrixTransform class methodsFor: 'instance creation'!fromRemoteCanvasEncoding: encoded	"CDisplayTransform fromRemoteCanvasEncoding:  'Matrix,1065353216,0,1137541120,0,1065353216,1131610112,'"	| nums transform encodedNums |	"split the numbers up"	encodedNums _ encoded findTokens: ','.	"remove the initial 'Matrix' specification"	encodedNums _ encodedNums asOrderedCollection.	encodedNums removeFirst.	"parse the numbers"	nums _ encodedNums collect: [ :enum |		Integer readFromString: enum ].	"create an instance"	transform _ self new.	"plug in the numbers"	nums doWithIndex: [ :num :i |		transform basicAt: i put: num ].	^transform! !!CMatrixTransform class methodsFor: 'instance creation'!identity	^self new setScale: 1.0! !!CMatrixTransform class methodsFor: 'instance creation'!localRect: localBounds toGlobal: globalBounds	^self transformFromLocal: localBounds toGlobal: globalBounds! !!CMatrixTransform class methodsFor: 'instance creation'!new	^self new: 6! !!CMatrixTransform class methodsFor: 'instance creation'!newFromStream: s	"Only meant for my subclasses that are raw bits and word-like.  For quick unpack form the disk."	self isPointers | self isWords not ifTrue: [^ super newFromStream: s].		"super may cause an error, but will not be called."	^ s nextWordsInto: (self new: 6)! !!CMatrixTransform class methodsFor: 'instance creation'!transformFromLocal: localBounds toGlobal: globalBounds	^((self withOffset: (globalBounds center)) composedWithLocal:		(self withScale: (globalBounds extent / localBounds extent) asFloatPoint))			composedWithLocal: (self withOffset: localBounds center negated)"	^(self identity)		setScale: (globalBounds extent / localBounds extent) asFloatPoint;		setOffset: localBounds center negated asFloatPoint;		composedWithGlobal:(self withOffset: globalBounds center asFloatPoint)"! !!CMatrixTransform class methodsFor: 'instance creation'!withAngle: angle	^self new setAngle: angle! !!CMatrixTransform class methodsFor: 'instance creation'!withOffset: aPoint	^self identity setOffset: aPoint! !!CMatrixTransform class methodsFor: 'instance creation'!withRotation: angle	^self new setAngle: angle! !!CMatrixTransform class methodsFor: 'instance creation'!withScale: aPoint	^self new setScale: aPoint! !!CMatrixTransform class methodsFor: 'class initialization' stamp: 'bf 9/14/2004 15:03'!initialize	"register myself with DataStream"	DataStream initialize! !!CMouseOverHandler class methodsFor: 'instance creation'!new	^super new initialize! !!CObject class methodsFor: 'fields' stamp: 'ar 3/11/2004 19:54'!addField: fieldDef defaultValue: default	"Add the field defined by fieldDef to the receiver."	fieldDef isInstanceVariable ifTrue:[^self error: 'Not a field'].	"hack around the problem of not having uniclasses yet"	(fieldDef toGet == #propertyValueAt:) ifTrue:[		fieldDef toGet: fieldDef name.		fieldDef toSet: (fieldDef name,':') asSymbol.		fieldDef accessKey: nil].	self privateAddField: fieldDef.	"compile accessors"	self compileAccessorsFor: fieldDef defaultValue: default.! !!CObject class methodsFor: 'fields' stamp: 'ar 11/18/2003 13:53'!compileAccessorsFor: fieldDef defaultValue: default	| code eventName |	eventName := fieldDef name,'Changed'.	code := String streamContents:[:s|		s nextPutAll: fieldDef name.		s crtab; nextPutAll: '"This method was automatically generated"'.		s crtab; nextPutAll: '<autoGenerated: true>'.		s crtab; nextPutAll: '<get: '; store: fieldDef name asSymbol; nextPutAll:'>'.		s crtab; nextPutAll: '<signals: ', eventName,'>'.		s crtab; nextPutAll: '<serialize: #writeProperty:on:>'.		s crtab; nextPutAll: '<deserialize: #readProperty:from:>'.		s crtab; nextPutAll: '^self propertyValueAt: #', fieldDef name.		default ifNotNil:[			s nextPutAll: ' ifAbsent:['; store: default; nextPutAll:']'.		].	].	self compile: code classified: 'field access'.	code := String streamContents:[:s|		s nextPutAll: fieldDef name; nextPutAll: ': aValue'.		s crtab; nextPutAll: '"This method was automatically generated"'.		s crtab; nextPutAll: '<autoGenerated: true>'.		s crtab; nextPutAll: '<set: '; store: fieldDef name asSymbol; nextPutAll:'>'.		s crtab; nextPutAll: '^self propertyValueAt: #', fieldDef name.		s nextPutAll: ' put: aValue'.		s nextPutAll: ' with: #', eventName.	].	self compile: code classified: 'field access'.! !!CObject class methodsFor: 'fields' stamp: 'ar 9/24/2003 14:17'!compilePartAccessorFor: fieldDef	| code eventName |	eventName := fieldDef name,'Changed'.	code := String streamContents:[:s|		s nextPutAll: fieldDef name.		s crtab; nextPutAll: '"This method was automatically generated"'.		s crtab; nextPutAll: '<get: '; store: fieldDef name asSymbol; nextPutAll:'>'.		s crtab; nextPutAll: '<signals: ', eventName,'>'.		s crtab; nextPutAll: '<part: '; store: fieldDef name asSymbol; nextPutAll:'>'.		s crtab; nextPutAll: '<serialize: #writeProperty:on:>'.		s crtab; nextPutAll: '<deserialize: #readProperty:from:>'.		s crtab; nextPutAll: '<category: #parts>'.		s crtab; nextPutAll: '^self propertyValueAt: #', fieldDef name.	].	self compile: code classified: 'parts access'.	code := String streamContents:[:s|		s nextPutAll: fieldDef name; nextPutAll: ': aValue'.		s crtab; nextPutAll: '"This method was automatically generated"'.		s crtab; nextPutAll: '<set: '; store: fieldDef name asSymbol; nextPutAll:'>'.		s crtab; nextPutAll: '^self propertyValueAt: #', fieldDef name.		s nextPutAll: ' put: aValue'.		s nextPutAll: ' with: #', eventName.	].	self compile: code classified: 'parts access'.! !!CObject class methodsFor: 'fields' stamp: 'ar 3/12/2004 14:04'!compilePropertyFor: fieldName defaultValue: default	| code eventName |	eventName := fieldName,'Changed'.	code := String streamContents:[:s|		s nextPutAll: fieldName.		s crtab; nextPutAll: '"Answer the ', fieldName, ' of the receiver"'.		s crtab; nextPutAll: '<bewareOf: #', eventName,'>'.		s crtab; nextPutAll: '^self propertyValueAt: #', fieldName.		default ifNotNil:[			s nextPutAll: ' ifAbsent:['; store: default; nextPutAll:']'.		].	].	self compile: code classified: 'accessing'.	code := String streamContents:[:s|		s nextPutAll: fieldName; nextPutAll: ': aValue'.		s crtab; nextPutAll: '"Modify the receiver''s ', fieldName, '"'.		s crtab; nextPutAll: '^self propertyValueAt: #', fieldName.		s nextPutAll: ' put: aValue'.		s nextPutAll: ' with: #', eventName.	].	self compile: code classified: 'accessing'.! !!CObject class methodsFor: 'fields' stamp: 'ar 3/11/2004 19:56'!privateAddField: aFieldDefinition	"Private. Add this field definition to the receiver. No error checking is done here."	classFields ifNil:[classFields := #()].	classFields := classFields copyWith: aFieldDefinition.! !!CObject class methodsFor: 'fields' stamp: 'ar 3/11/2004 19:56'!privateRemoveField: aFieldDefinition	"Private. Remove this field definition from the receiver. No error checking is done here."	classFields ifNil:[classFields := #()].	classFields := classFields copyWithout: aFieldDefinition.! !!CObject class methodsFor: 'accessing' stamp: 'ar 1/20/2004 02:06'!compileAllFrom: oldClass	"HACK - provide interim methods for all selectors in oldClass that aren't here yet. Needed in order to make implicit self work properly with the compiler."	oldClass selectorsDo:[:sel|		(self includesSelector: sel) ifFalse:[			self addSelector: sel withMethod: CompiledMethod toReturnSelf		].	].	^super compileAllFrom: oldClass! !!CObject class methodsFor: 'accessing' stamp: 'ar 3/11/2004 19:52'!uuid	^uuid ifNil:[uuid := UUID new].! !!CObject class methodsFor: 'accessing' stamp: 'ar 3/11/2004 19:52'!uuid: aUUID	uuid ifNotNil:[^self error: 'Cannot change UUID'].	uuid := aUUID.! !!CObject class methodsFor: 'factory' stamp: 'ar 2/11/2003 15:26'!next	^self new! !!CObject class methodsFor: 'instance creation' stamp: 'ar 9/25/2003 17:20'!named: aString	^(self new) name: aString; yourself! !!CObject class methodsFor: 'instance creation' stamp: 'ar 2/29/2004 14:07'!new	^(super new)		initialize; 				"stage1: user-level initialization"		autoStartScripts;			"stage2: initiate default event responses"	yourself! !!CObject class methodsFor: 'instance creation' stamp: 'ar 3/12/2004 17:30'!on: aValue	^(self new) value: aValue; yourself! !!CObject class methodsFor: '*Tweak-Resources' stamp: 'ar 12/3/2003 18:57'!embedResourceIn: zipArchive	^self embedResourceIn: zipArchive notifying: nil! !!CObject class methodsFor: '*Tweak-Resources' stamp: 'ar 12/3/2003 01:20'!embedResourceIn: zipArchive notifying: bar	| writer |	self isUniClass ifFalse:[^self].	(zipArchive hasMemberSuchThat:[:mbr| mbr fileName beginsWith: self resourceDirectory])		ifTrue:[^self].	writer := XMLWriter on: (String new: 1000) writeStream.	self exportXmlContentsOn: writer.	zipArchive addDeflateString: writer stream contents as: self resourceDirectory, self uuid,'.class'.! !!CObject class methodsFor: '*Tweak-Resources' stamp: 'ar 5/5/2004 20:44'!exportFieldsOn: xmlWriter	| fields |	fields := self allFields.	fields isEmpty ifTrue:[^self].	xmlWriter startTag: 'fields'; endTag.	fields do:[:fieldDef|		xmlWriter startTag: 'field'.		xmlWriter attribute: 'name' value: fieldDef name printString.		xmlWriter attribute: 'flags' value: fieldDef flags printString.		xmlWriter attribute: 'toGet' value: fieldDef toGet printString.		xmlWriter attribute: 'toSet' value: fieldDef toSet printString.		xmlWriter attribute: 'accessKey' value: fieldDef accessKey printString.		xmlWriter endEmptyTag: 'field'.	].	xmlWriter endTag: 'fields'.! !!CObject class methodsFor: '*Tweak-Resources' stamp: 'ar 1/5/2004 20:46'!exportScriptsOn: xmlWriter	| meth |	self methodDict isEmpty ifTrue:[^self].	xmlWriter startTag: 'scripts'; endTag.	self organization categories do:[:cat|		(self organization listAtCategoryNamed: cat) do:[:sel|			meth := self compiledMethodAt: sel ifAbsent:[nil].			(meth == nil or:[(meth propertyValueAt: #autoGenerated) == true]) ifFalse:[				xmlWriter startTag: 'script'.				xmlWriter attribute: 'category' value: cat.				xmlWriter endTag.				xmlWriter pcData: (self sourceCodeAt: sel) asString.				xmlWriter endTag: 'script'.			].		].	].	xmlWriter endTag: 'scripts'.! !!CObject class methodsFor: '*Tweak-Resources' stamp: 'ar 12/2/2003 21:27'!exportXmlContentsOn: writer	"Save the updates on the given stream"	self isUniClass ifFalse:[^self].	writer startTag: self resourceType.	writer attribute: 'id' value: self resourceID asString.	writer attribute: 'extends' value: self superclass name.	writer endTag.	self exportFieldsOn: writer.	self exportScriptsOn: writer.	writer endTag: self resourceType.! !!CObject class methodsFor: '*Tweak-Resources' stamp: 'ar 12/2/2003 20:59'!exportXmlOn: xmlWriter	"When exporting an object that uses a shared resource, this method needs to write out an appropriate description of the receiver. This method should provide enough information for the loader to construct the resource even if it hasn't been loaded yet."	xmlWriter startTag: self resourceType.	xmlWriter attribute: 'id' value: self resourceID asString.	xmlWriter attribute: 'extends' value: self superclass resourceID asString.	xmlWriter endEmptyTag: self resourceType.! !!CObject class methodsFor: '*Tweak-Resources' stamp: 'ar 3/25/2004 16:56'!extractResourceFrom: archive in: loader	"Extract this resource from the given archive"	| mbr aStream xmlDoc root node |	mbr := archive memberNamed: self resourceDirectory, self uuid,'.class'.	aStream := mbr contentStream.	aStream ascii.	xmlDoc := XMLDOMParser parseDocumentFrom: aStream.	root := xmlDoc elements first.	root name = 'behavior' ifFalse:[^self error: 'wrong resource'].	node := root elementAt: 'fields'.	node ifNotNil:[self importFieldsFrom: node].	node := root elementAt: 'scripts'.	node ifNotNil:[self importScriptsFrom: node].! !!CObject class methodsFor: '*Tweak-Resources' stamp: 'ar 5/5/2004 20:43'!importFieldsFrom: xmlNode	| fieldDef |	xmlNode elementsDo:[:node|		fieldDef := CFieldDefinition new.		fieldDef name: (node literalAt: 'name').		fieldDef flags: (node literalAt: 'flags').		fieldDef toGet: (node literalAt: 'toGet').		fieldDef toSet: (node literalAt: 'toSet').		fieldDef accessKey: (node literalAt: 'accessKey').		self addField: fieldDef defaultValue: nil.	].! !!CObject class methodsFor: '*Tweak-Resources' stamp: 'ar 3/27/2004 20:45'!importScriptsFrom: xmlNode	| cat script scriptSelector |	xmlNode elementsDo:[:node|		cat := node attributeAt: 'category'.		"An old version still had source as attribute not pcdata;		This was only used in interim versions so the code below can be 		removed for the next release."		script := node attributeAt: 'source'.		script ifNil:[script := node characterData].		scriptSelector := self compile: script notifying: nil.		self organization classify: scriptSelector under: cat.	].! !!CObject class methodsFor: '*Tweak-Resources' stamp: 'ar 12/2/2003 23:17'!importXmlResource: xmlNode in: aLoader	^aLoader importScripted: xmlNode! !!CObject class methodsFor: '*Tweak-Resources' stamp: 'ar 12/2/2003 23:20'!resourceDirectory	"Helper to get a consistent location"	^'resources/', self resourceType,'/', self resourceID asString,'/'! !!CObject class methodsFor: '*Tweak-Resources' stamp: 'ar 12/2/2003 21:17'!resourceID	"Answer a unique ID for this resource"	^self isUniClass ifTrue:[self uuid] ifFalse:[self name]! !!CObject class methodsFor: '*Tweak-Resources' stamp: 'ar 12/2/2003 21:34'!resourceType	^self isUniClass ifTrue:[#behavior] ifFalse:[#class]! !!CCollection class methodsFor: 'accessing' stamp: 'ar 4/3/2004 20:10'!defaultCostumeMaker	^CList! !!CCostumeAspect class methodsFor: 'instance creation' stamp: 'ar 3/23/2004 16:41'!forCostume: aCostume	^self new costume: aCostume! !!CCostumeAspect class methodsFor: 'instance creation' stamp: 'ar 3/23/2004 16:41'!new	^self basicNew initialize! !!CCostumeBorder class methodsFor: 'instance creation' stamp: 'ar 9/21/2003 18:37'!style: aStyle width: aWidth color: aColor	^self basicNew style: aStyle width: aWidth color: aColor! !!CCostumeFill class methodsFor: 'instance creation' stamp: 'ar 3/12/2003 19:49'!new	^super new initialize! !!CCostumeGraphic class methodsFor: 'instance creation' stamp: 'ar 3/23/2004 19:09'!new	^super new initialize! !!CCostumeGrid class methodsFor: 'accessing' stamp: 'ar 3/26/2004 21:15'!gridCacheAt: aPoint	"Answer a form to use for caching a grid with the given extent"	| cached maxGrid gridGrid tempGrid |	GridCache ifNil:[GridCache := Dictionary new].	cached := GridCache at: aPoint ifAbsent:[nil].	cached ifNotNil:[^cached].	"We only cache up to 128x128 so no reason to do anything but that"	maxGrid := 128@128.	aPoint < maxGrid ifFalse:[^nil].	gridGrid := maxGrid grid: aPoint.	cached := ColorForm extent: gridGrid depth: 1.	cached colors: (Array with: Color transparent with: Color black).	tempGrid := self new.	tempGrid extent: aPoint.	tempGrid uncachedDrawGridOn: (CTransformCanvas on: cached) in: (0@0 extent: gridGrid).	GridCache at: aPoint put: cached.	^cached! !!CCostumeTextHolder class methodsFor: 'instance creation' stamp: 'ar 3/23/2004 19:46'!new	^super new initialize! !!CCostumeTextHolder class methodsFor: 'class initialization' stamp: 'ar 3/23/2004 19:46'!initialize	"CTextContainer initialize"	DefaultBorder := CCostumeBorder new.! !!CDialog class methodsFor: 'instance creation' stamp: 'ar 7/29/2004 13:42'!new	"See the class comment"	^self shouldNotImplement! !!CDialog class methodsFor: 'debugging' stamp: 'ar 3/13/2004 15:21'!abortRetryDebug: anException	"Raise a dialog giving the user the chance to abort, retry, or debug an exception"	^self abortRetryDebug: anException centerAt: nil! !!CDialog class methodsFor: 'debugging' stamp: 'ar 3/13/2004 15:28'!abortRetryDebug: anException centerAt: aPoint	"Raise a dialog giving the user the chance to abort, retry, or debug an exception"	^self abortRetryDebug: anException 		label:  'An problem has occurred:'		centerAt: aPoint! !!CDialog class methodsFor: 'debugging' stamp: 'ar 3/13/2004 15:22'!abortRetryDebug: anException label: labelString	"Raise a dialog giving the user the chance to abort, retry, or debug an exception"	^self abortRetryDebug: anException 		label: labelString		centerAt: nil.! !!CDialog class methodsFor: 'debugging' stamp: 'ar 3/13/2004 15:22'!abortRetryDebug: anException label: labelString centerAt: aPoint	"Raise a dialog giving the user the chance to abort, retry, or debug an exception"	^CUserDialog new abortRetryDebug: anException label: labelString centerAt: aPoint! !!CDialog class methodsFor: 'confirming' stamp: 'ar 3/13/2004 15:14'!confirm: aString	^self confirm: aString centerAt: nil! !!CDialog class methodsFor: 'confirming' stamp: 'ar 3/13/2004 15:13'!confirm: aString centerAt: aPoint	^self confirm: aString label:'Attention:' centerAt: aPoint! !!CDialog class methodsFor: 'confirming' stamp: 'ar 3/13/2004 15:14'!confirm: aString label: labelString	^self confirm: aString label: labelString centerAt: nil! !!CDialog class methodsFor: 'confirming' stamp: 'ar 3/13/2004 15:14'!confirm: aString label: labelString centerAt: aPoint	^CUserDialog new confirm: aString label: labelString centerAt: aPoint! !!CDialog class methodsFor: 'informing' stamp: 'ar 3/13/2004 15:13'!inform: aString	^self inform: aString centerAt: nil! !!CDialog class methodsFor: 'informing' stamp: 'ar 3/13/2004 15:13'!inform: aString centerAt: aPoint	^self inform: aString label: 'Note' centerAt: nil! !!CDialog class methodsFor: 'informing' stamp: 'ar 3/13/2004 15:13'!inform: aString label: labelString	^self inform: aString label: labelString centerAt: nil! !!CDialog class methodsFor: 'informing' stamp: 'ar 3/13/2004 16:45'!inform: aString label: labelString centerAt: aPoint	^CUserDialog new inform: aString label: labelString centerAt: aPoint! !!CDialog class methodsFor: 'requesting' stamp: 'ar 3/13/2004 15:11'!request: aString	^self request: aString initialAnswer: nil! !!CDialog class methodsFor: 'requesting' stamp: 'ar 3/13/2004 15:11'!request: aString centerAt: aPoint	^self request: aString initialAnswer: nil centerAt: aPoint! !!CDialog class methodsFor: 'requesting' stamp: 'ar 3/13/2004 15:11'!request: aString initialAnswer: default	^self request: aString initialAnswer: default centerAt: nil! !!CDialog class methodsFor: 'requesting' stamp: 'ar 3/13/2004 15:10'!request: aString initialAnswer: default centerAt: aPoint	^CUserDialog new request: aString initialAnswer: default centerAt: aPoint! !!CDialog class methodsFor: 'requesting' stamp: 'ar 3/13/2004 15:12'!requestPassword: queryString	^self requestPassword: queryString centerAt: nil! !!CDialog class methodsFor: 'requesting' stamp: 'ar 3/13/2004 15:16'!requestPassword: queryString centerAt: aPoint	^CUserDialog new requestPassword: queryString centerAt: aPoint! !!CDirectoryEntry class methodsFor: 'class initialization' stamp: 'ar 3/15/2004 01:46'!initialize	"CDirectoryEntry initialize"	Smalltalk addToShutDownList: self.! !!CDirectoryEntry class methodsFor: 'class initialization' stamp: 'ar 3/15/2004 01:46'!shutDown	"Flush the icon cache"	IconCache := nil.! !!CEventBehavior class methodsFor: 'instance creation' stamp: 'ar 4/30/2004 17:53'!attachTo: anObject	^self new attachTo: anObject! !!CObjectMakerDeserializer class methodsFor: 'instance creation' stamp: 'ar 10/18/2003 21:43'!on: factoryData	^self new factoryData: factoryData! !!COffsetTransform class methodsFor: 'instance creation'!offset: aPoint	^self new offset: aPoint! !!COffsetTransform class methodsFor: 'instance creation'!withOffset: aPoint	^self new offset: aPoint! !!CBitmapFill class methodsFor: 'instance creation'!form: aForm	^self new form: aForm! !!CBitmapFill class methodsFor: 'instance creation'!fromForm: aForm	| fs |	fs _ self form: aForm.	fs direction: aForm width @ 0.	fs normal: 0 @ aForm height.	fs tileFlag: true.	^fs! !!CBitmapFill class methodsFor: 'instance creation'!fromUser	| fill |	fill _ self form: Form fromUser.	fill origin: 0@0.	fill direction: fill form width @ 0.	fill normal: 0 @ fill form height.	fill tileFlag: true. "So that we can fill arbitrary objects"	^fill! !!CGradientFill class methodsFor: 'instance creation'!colors: colorArray	"Create a gradient fill style from an array of equally spaced colors"	^self ramp: (colorArray withIndexCollect:		[:color :index| (index-1 asFloat / (colorArray size - 1 max: 1)) -> color]).! !!CGradientFill class methodsFor: 'instance creation'!ramp: colorRamp	^self new colorRamp: colorRamp! !!CGradientFill class methodsFor: 'instance creation'!sample	"CGradientFill sample"	^(self ramp: { 0.0 -> Color red. 0.5 -> Color green. 1.0 -> Color blue})		origin: 300 @ 300;		direction: 400@0;		normal: 0@400;		radial: true;	yourself! !!CPlayer class methodsFor: 'opening'!open	^self new open! !!CPlayer class methodsFor: 'opening'!openInHand	^self new openInHand! !!CPlayer class methodsFor: 'opening'!openOn: aValue	^(self on: aValue) open! !!CPlayer class methodsFor: 'instance creation' stamp: 'ar 3/24/2004 15:05'!makeCostumeFor: aPlayer	^(self basicNew) 		privateChangePlayerTo: aPlayer; 		initialize;		autoStartScripts;	yourself! !!CPlayer class methodsFor: 'instance creation' stamp: 'ar 3/22/2004 14:41'!makePlayerFor: aPlayer	^(self basicNew) 		privateChangeCostumeTo: aPlayer; 		initialize;		autoStartScripts;		onPlayerChanged;	yourself! !!CChangeSorter class methodsFor: 'enumerating' stamp: 'md 4/6/2004 16:49'!allChangeSetNames	^ self allChangeSets collect: [:c | c name]! !!CChangeSorter class methodsFor: 'enumerating' stamp: 'md 4/6/2004 16:49'!allChangeSets	"Return the list of all current ChangeSets"	^ AllChangeSets! !!CChangeSorter class methodsFor: 'enumerating' stamp: 'md 4/6/2004 16:49'!allChangeSetsWithClass: class selector: selector	class ifNil: [^ #()].	^ self allChangeSets select: 		[:cs | (cs atSelector: selector class: class) ~~ #none]! !!CChangeSorter class methodsFor: 'enumerating' stamp: 'md 4/6/2004 16:49'!changeSet: aChangeSet containsClass: aClass	| theClass |	theClass _ Smalltalk classNamed: aClass.	theClass ifNil: [^ false].	^ aChangeSet containsClass: theClass! !!CChangeSorter class methodsFor: 'enumerating' stamp: 'tk 7/23/2004 10:26'!changeSetNamed: aName	"Return the change set of the given name, or nil if none found."	AllChangeSets do: [:aChangeSet | aChangeSet name = aName ifTrue: [^ aChangeSet]].	CChangeSorter gatherChangeSets.	"mismatch -- some added in normal Squeak"	^ AllChangeSets			detect: [:aChangeSet | aChangeSet name = aName]			ifNone: [nil].! !!CChangeSorter class methodsFor: 'enumerating' stamp: 'md 4/6/2004 16:49'!changeSetsNamedSuchThat: nameBlock	"(ChangeSorter changeSetsNamedSuchThat:		[:name | name first isDigit and: [name initialInteger >= 373]])		do: [:cs | AllChangeSets remove: cs wither]"	^ AllChangeSets select: [:aChangeSet | nameBlock value: aChangeSet name]! !!CChangeSorter class methodsFor: 'enumerating' stamp: 'md 4/6/2004 16:49'!existingOrNewChangeSetNamed: aName	| newSet |	^(self changeSetNamed: aName) ifNil: [		newSet _ ChangeSet basicNewNamed: aName.		AllChangeSets add: newSet.		newSet	]! !!CChangeSorter class methodsFor: 'enumerating' stamp: 'md 4/6/2004 16:50'!gatherChangeSets		"ChangeSorter gatherChangeSets"	"Collect any change sets created in other projects"	| allChangeSets obsolete |	allChangeSets _ AllChangeSets asSet.	ChangeSet allSubInstances do: [:each |		(allChangeSets includes: each) == (obsolete _ each isMoribund) ifTrue:[			obsolete				ifTrue: ["Was included and is obsolete."						AllChangeSets remove: each]				ifFalse: ["Was not included and is not obsolete."						AllChangeSets add: each]]].	^ AllChangeSets! !!CChangeSorter class methodsFor: 'enumerating' stamp: 'md 4/6/2004 16:50'!highestNumberedChangeSet	"ChangeSorter highestNumberedChangeSet"	| aList |	aList _ (self allChangeSetNames select: [:aString | aString startsWithDigit] thenCollect:		[:aString | aString initialIntegerOrNil]).	^ (aList size > 0)		ifTrue:			[aList max]		ifFalse:			[nil]! !!CChangeSorter class methodsFor: 'enumerating' stamp: 'md 4/6/2004 16:50'!mostRecentChangeSetWithChangeForClass: class selector: selector	| hits |	hits _ self allChangeSets select: 		[:cs | (cs atSelector: selector class: class) ~~ #none].	hits isEmpty ifTrue: [^ 'not in any change set'].	^ 'recent cs: ', hits last name! !!CChangeSorter class methodsFor: 'enumerating' stamp: 'md 4/25/2004 16:02'!promoteToTop: aChangeSet	"make aChangeSet the first in the list from now on"	AllChangeSets remove: aChangeSet ifAbsent: [^ self].	AllChangeSets add: aChangeSet.! !!CChangeSorter class methodsFor: 'class initialization' stamp: 'md 4/6/2004 16:50'!belongsInAdditions: aChangeSet	"Answer whether a change set belongs in the Additions category, which is fed by all change sets that are neither numbered nor in the initial release"	^ (((self belongsInProjectsInRelease: aChangeSet) or:		[self belongsInNumbered: aChangeSet])) not! !!CChangeSorter class methodsFor: 'class initialization' stamp: 'md 4/6/2004 16:50'!belongsInAll: aChangeSet	"Answer whether a change set belongs in the All category"	^ true ! !!CChangeSorter class methodsFor: 'class initialization' stamp: 'md 4/6/2004 16:50'!belongsInMyInitials: aChangeSet	"Answer whether a change set belongs in the MyInitials category. "	^ aChangeSet name endsWith: ('-', Utilities authorInitials)! !!CChangeSorter class methodsFor: 'class initialization' stamp: 'md 4/6/2004 16:50'!belongsInNumbered:  aChangeSet	"Answer whether a change set belongs in the Numbered category. "	^  aChangeSet name startsWithDigit! !!CChangeSorter class methodsFor: 'class initialization' stamp: 'md 4/6/2004 16:50'!belongsInProjectChangeSets: aChangeSet	"Answer whether a change set belongs in the MyInitials category. "	^ aChangeSet belongsToAProject! !!CChangeSorter class methodsFor: 'class initialization' stamp: 'md 4/6/2004 16:50'!belongsInProjectsInRelease:  aChangeSet	"Answer whether a change set belongs in the ProjectsInRelease category.  You can hand-tweak this to suit your working style.  This just covers the space of project names in the 2.9, 3.0, and 3.1a systems"	| aString |	^ ((aString _ aChangeSet name) beginsWith: 'Play With Me') or: [self changeSetNamesInReleaseImage includes: aString]! !!CChangeSorter class methodsFor: 'class initialization' stamp: 'md 4/6/2004 16:50'!belongsInRecentUpdates: aChangeSet	"Answer whether a change set belongs in the RecentUpdates category."	^ aChangeSet name startsWithDigit and:			[aChangeSet name asInteger >= self recentUpdateMarker]! !!CChangeSorter class methodsFor: 'class initialization' stamp: 'md 4/6/2004 16:50'!changeSetCategoryNamed: aName	"Answer the changeSetCategory of the given name, or nil if none"	^ ChangeSetCategories elementAt: aName asSymbol ! !!CChangeSorter class methodsFor: 'class initialization' stamp: 'md 4/6/2004 16:50'!changeSetNamesInReleaseImage	"Answer a list of names of project change sets that come pre-shipped in the latest sytem release.  On the brink of shipping a new release, call 'ChangeSorter noteChangeSetsInRelease'  "	^ ChangeSetNamesInRelease ifNil:		[ChangeSetNamesInRelease _ self changeSetNamesInThreeOh]! !!CChangeSorter class methodsFor: 'class initialization' stamp: 'md 4/6/2004 16:50'!changeSetNamesInThreeOh	"Hard-coded: answer a list of names of project change sets that came pre-shipped in Squeak 3.0"	^ #('The Worlds of Squeak' 'Fun with Morphic' 'Games' 'Fun With Music' 'Building with Squeak' 'Squeak and the Internet' 'Squeak in 3D' 'More About Sound' ) ! !!CChangeSorter class methodsFor: 'class initialization' stamp: 'md 5/3/2004 13:48'!initialize	"Initialize the class variables"	"CChangeSorter initialize"		CProjectBuilder registerOpenCommand:        	{ 'Change Sorter' . { self . #open }. 'A Change Sorter' }.	AllChangeSets == nil ifTrue:		[AllChangeSets _ OrderedCollection new].	self gatherChangeSets.	ChangeSetCategories ifNil:		[self initializeChangeSetCategories].	RecentUpdateMarker _ 0.! !!CChangeSorter class methodsFor: 'class initialization' stamp: 'md 4/6/2004 16:50'!initializeChangeSetCategories	"Initialize the set of change-set categories"	"ChangeSorter initializeChangeSetCategories"	| aCategory |	ChangeSetCategories _ ElementCategory new categoryName: #ChangeSetCategories.	aCategory _ ChangeSetCategory new categoryName: #All.	aCategory membershipSelector: #belongsInAll:.	aCategory documentation: 'All change sets known to the system'.	ChangeSetCategories addCategoryItem: aCategory.	aCategory _ ChangeSetCategory new categoryName: #Additions.	aCategory membershipSelector: #belongsInAdditions:.	aCategory documentation: 'All unnumbered change sets except those representing projects in the system as initially released.'.	ChangeSetCategories addCategoryItem: aCategory.	aCategory _ ChangeSetCategory new categoryName: #MyInitials.	aCategory membershipSelector: #belongsInMyInitials:.	aCategory documentation: 'All change sets whose names end with the current author''s initials.'.	ChangeSetCategories addCategoryItem: aCategory.	aCategory _ ChangeSetCategory new categoryName: #Numbered.	aCategory membershipSelector: #belongsInNumbered:.	aCategory documentation: 'All change sets whose names start with a digit -- normally these will be the official updates to the system.'.	ChangeSetCategories addCategoryItem: aCategory.	aCategory _ ChangeSetCategory new categoryName: #ProjectChangeSets.	aCategory membershipSelector: #belongsInProjectChangeSets:.	aCategory documentation: 'All change sets that are currently associated with projects present in the system right now.'.	ChangeSetCategories addCategoryItem: aCategory.	aCategory _ ChangeSetCategory new categoryName: #ProjectsInRelease.	aCategory membershipSelector: #belongsInProjectsInRelease:.	aCategory documentation: 'All change sets belonging to projects that were shipped in the initial release of this version of Squeak'.	ChangeSetCategories addCategoryItem: aCategory.	aCategory _ ChangeSetCategory new categoryName: #RecentUpdates.	aCategory membershipSelector: #belongsInRecentUpdates:.	aCategory documentation: 'Updates whose numbers are at or beyond the number I have designated as the earliest one to qualify as Recent'.	ChangeSetCategories addCategoryItem: aCategory.	ChangeSetCategories elementsInOrder do: [:anElem | anElem reconstituteList] ! !!CChangeSorter class methodsFor: 'class initialization' stamp: 'md 4/6/2004 16:50'!noteChangeSetsInRelease	"Freshly compute what the change sets in the release are; to be called manually just before a release"	ChangeSetNamesInRelease _ (Project allProjects collect: [:p | p name]) asSet asOrderedCollection."ChangeSorter noteChangeSetsInRelease"! !!CChangeSorter class methodsFor: 'class initialization' stamp: 'md 4/25/2004 16:17'!unload	"Unload the receiver from global registries"	self environment at: #FileList ifPresent: [:cl |	cl unregisterFileReader: self].! !!CChangeSorter class methodsFor: 'adding' stamp: 'md 4/22/2004 15:04'!basicNewChangeSet: newName	| newSet |	newName ifNil: [^ nil].	(self changeSetNamed: newName) ifNotNil:		[CDialog inform: 'Sorry that name is already used'.		^ nil].	newSet _ ChangeSet basicNewNamed: newName.	AllChangeSets add: newSet.	^ newSet! !!CChangeSorter class methodsFor: 'adding' stamp: 'md 4/25/2004 14:11'!newChangeSet	"Prompt the user for a name, and establish a new change set of	that name (if ok), making it the current changeset.  Return nil	of not ok, else return the actual changeset."	| newName newSet |	newName _ CDialog 		request: 'Please name the new change set:'		initialAnswer: ChangeSet defaultName.	newName isEmptyOrNil ifTrue:		[^ nil].	newSet _ self basicNewChangeSet: newName.	newSet ifNotNil:		[ChangeSet  newChanges: newSet].	^ newSet! !!CChangeSorter class methodsFor: 'adding' stamp: 'md 4/6/2004 16:50'!newChangeSet: aName	"Makes a new change set called aName, add author initials to try to	ensure a unique change set name."	| newName |	newName _ aName , FileDirectory dot , Utilities authorInitials.	^ self basicNewChangeSet: newName! !!CChangeSorter class methodsFor: 'adding' stamp: 'md 4/6/2004 16:50'!newChangesFromStream: aStream named: aName	"File in the code from the stream into a new change set whose	name is derived from aName. Leave the 'current change set'	unchanged. Return the new change set or nil on failure."	| oldChanges newName newSet |	oldChanges _ ChangeSet current.	PreviousSet _ oldChanges name. 		"so a Bumper update can find it"	newName _ aName sansPeriodSuffix.	newSet _ self basicNewChangeSet: newName.	[newSet ifNotNil:		[ChangeSet  newChanges: newSet.		aStream fileInAnnouncing: 'Loading ', newName, '...'.		Transcript cr; show: 'File ', aName, ' successfully filed in to change set ', newName].	aStream close] ensure: [			ChangeSet  newChanges: oldChanges].	^ newSet! !!CChangeSorter class methodsFor: 'removing' stamp: 'md 4/6/2004 16:50'!deleteChangeSetsNumberedLowerThan: anInteger	"Delete all changes sets whose names start with integers smaller than anInteger"	ChangeSorter removeChangeSetsNamedSuchThat:		[:aName | aName first isDigit and: [aName initialIntegerOrNil < anInteger]].	"ChangeSorter deleteChangeSetsNumberedLowerThan: (ChangeSorter highestNumberedChangeSet name initialIntegerOrNil - 500)"! !!CChangeSorter class methodsFor: 'removing' stamp: 'md 4/6/2004 16:50'!removeChangeSet: aChangeSet	"Remove the given changeSet.  Caller must assure that it's cool to do this"	AllChangeSets remove: aChangeSet ifAbsent: [].	aChangeSet wither! !!CChangeSorter class methodsFor: 'removing' stamp: 'md 4/6/2004 16:50'!removeChangeSetsNamedSuchThat: nameBlock	(ChangeSorter changeSetsNamedSuchThat: nameBlock)		do: [:cs | self removeChangeSet: cs]! !!CChangeSorter class methodsFor: 'removing' stamp: 'md 4/6/2004 16:50'!removeEmptyUnnamedChangeSets	"Remove all change sets that are empty, whose names start with Unnamed,		and which are not nailed down by belonging to a Project."	"ChangeSorter removeEmptyUnnamedChangeSets"	| toGo |	(toGo _ (self changeSetsNamedSuchThat: [:csName | csName beginsWith: 'Unnamed'])		select: [:cs | cs isEmpty and: [cs okayToRemoveInforming: false]])		do: [:cs | self removeChangeSet: cs].	self inform: toGo size printString, ' change set(s) removed.'! !!CChangeSorter class methodsFor: 'services' stamp: 'md 4/6/2004 16:50'!assuredChangeSetNamed: aName	"Answer a change set of the given name.  If one already exists, answer that, else create a new one and answer it."	| existing |	^ (existing _ self changeSetNamed: aName)		ifNotNil:			[existing]		ifNil:			[self basicNewChangeSet: aName]! !!CChangeSorter class methodsFor: 'services' stamp: 'md 4/23/2004 15:37'!browseChangeSetsWithClass: class selector: selector	"Put up a menu comprising a list of change sets that hold changes for the given class and selector.  If the user selects one, open a single change-sorter onto it"	| hits selected |	hits _ self allChangeSets select: 		[:cs | (cs atSelector: selector class: class) ~~ #none].	hits isEmpty ifTrue: [^ CDialog inform: class name, '.', selector , 'is not in any change set'].	selected _ hits size == 1		ifTrue:	[hits first]		ifFalse:	[ (CMenu new) chooseFrom:  				(hits collect: [:cs | Array with: cs name with: cs ])].	(CChangeSorter new myChangeSet: selected) open.! !!CChangeSorter class methodsFor: 'services' stamp: 'md 4/25/2004 16:15'!browseChangeSetsWithSelector: aSelector	"Put up a list of all change sets that contain an addition, deletion, or change of any method with the given selector"	| hits selected |	hits _ self allChangeSets select: 		[:cs | cs hasAnyChangeForSelector: aSelector].	hits isEmpty ifTrue: [^ CDialog inform: aSelector , '\is not in any change set' withCRs].	selected _ hits size == 1		ifTrue:	[hits first]		ifFalse:	[CMenu new 							chooseFromValues: (hits collect: [:cs | cs name]);							run].	self new cNotYet.	"(ChangeSetBrowser new myChangeSet: selected) open""ChangeSorter browseChangeSetsWithSelector: #initialize"! !!CChangeSorter class methodsFor: 'services' stamp: 'md 4/6/2004 16:50'!buildAggregateChangeSet	"Establish a change-set named Aggregate which bears the union of all the changes in all the existing change-sets in the system (other than any pre-existing Aggregate).  This can be useful when wishing to discover potential conflicts between a disk-resident change-set and an image.  Formerly very useful, now some of its unique contributions have been overtaken by new features"	| aggregateChangeSet |	aggregateChangeSet _ self existingOrNewChangeSetNamed: 'Aggregate'.	aggregateChangeSet clear.	self allChangeSets do:		[:aChangeSet | aChangeSet == aggregateChangeSet ifFalse:			[aggregateChangeSet assimilateAllChangesFoundIn: aChangeSet]]"ChangeSorter buildAggregateChangeSet"	! !!CChangeSorter class methodsFor: 'services' stamp: 'md 4/6/2004 16:50'!countOfChangeSetsWithClass: aClass andSelector: aSelector	"Answer how many change sets record a change for the given class and selector"	^ (self allChangeSetsWithClass: aClass selector: aSelector) size! !!CChangeSorter class methodsFor: 'services' stamp: 'md 4/6/2004 16:50'!doesAnyChangeSetHaveClass: aClass andSelector: aSelector	"Answer whether any known change set bears a change for the given class and selector"	^ (self countOfChangeSetsWithClass: aClass andSelector: aSelector) > 0! !!CChangeSorter class methodsFor: 'services' stamp: 'md 4/6/2004 16:50'!recentUpdateMarker	"Answer the number representing the threshold of what counts as 'recent' for an update number.  This allow you to use the RecentUpdates category in a ChangeSorter to advantage"	^ RecentUpdateMarker ifNil: [RecentUpdateMarker _ 0]! !!CChangeSorter class methodsFor: 'services' stamp: 'md 4/6/2004 16:50'!recentUpdateMarker: aNumber	"Set the recent update marker as indicated"	^ RecentUpdateMarker _ aNumber! !!CChangeSorter class methodsFor: 'services' stamp: 'md 4/25/2004 16:04'!reorderChangeSets	"Change the order of the change sets to something more convenient:		First come the project changesets that come with the release.  These are mostly empty.		Next come all numbered updates.		Next come all remaining changesets	In a ChangeSorter, they will appear in the reversed order."	"ChangeSorter reorderChangeSets"	| newHead newMid newTail |	newHead _ OrderedCollection new.	newMid _ OrderedCollection new.	newTail _ OrderedCollection new.	AllChangeSets do:		[:aChangeSet |			(self belongsInProjectsInRelease: aChangeSet)				ifTrue:					[newHead add: aChangeSet]				ifFalse:					[(self belongsInNumbered: aChangeSet)						ifTrue:							[newMid add: aChangeSet]						ifFalse:							[newTail add: aChangeSet]]].	AllChangeSets _ newHead, newMid, newTail.! !!CChangeSorter class methodsFor: 'services' stamp: 'md 4/6/2004 16:50'!secondaryChangeSet	"Answer a likely change set to use as the second initial one in a Dual Change Sorter.  "	AllChangeSets size = 1 ifTrue: [^ AllChangeSets first].	AllChangeSets last == ChangeSet current		ifTrue: 	[^ AllChangeSets at: (AllChangeSets size - 1)]		ifFalse:	[^ AllChangeSets last]! !!CChangeSorter class methodsFor: 'fileIn/Out' stamp: 'md 4/6/2004 16:50'!fileIntoNewChangeSet: fullName	"File in all of the contents of the currently selected file, if any, into a new change set." 	| fn ff |	fullName ifNil: [^ self beep].	ff _ FileStream readOnlyFileNamed: (fn _ GZipReadStream uncompressedFileName: fullName).	((FileDirectory extensionFor: fn) sameAs: 'html') ifTrue: [ff _ ff asHtml].	self newChangesFromStream: ff named: (FileDirectory localNameFor: fn)! !!CChangeSorter class methodsFor: 'fileIn/Out' stamp: 'md 4/6/2004 16:50'!fileReaderServicesForFile: fullName suffix: suffix	^(suffix = 'st') | (suffix = 'cs') | (suffix = '*')		ifTrue: [ self services]		ifFalse: [#()]! !!CChangeSorter class methodsFor: 'fileIn/Out' stamp: 'md 4/6/2004 16:50'!serviceFileIntoNewChangeSet	"Answer a service for installing a file into a new change set"	^ SimpleServiceEntry 		provider: self 		label: 'install into new change set'		selector: #fileIntoNewChangeSet:		description: 'install the file as a body of code in the image: create a new change set and file-in the selected file into it'		buttonLabel: 'install'! !!CChangeSorter class methodsFor: 'fileIn/Out' stamp: 'md 4/6/2004 16:50'!services	^ Array with: self serviceFileIntoNewChangeSet	! !!CClassBrowser class methodsFor: 'class initialization' stamp: 'ar 3/29/2004 16:53'!initialize	"CClassBrowser initialize"	CProjectBuilder registerOpenCommand:		{ 'Class Browser' . { self . #open }. 'A Class Browser' }.! !!CColorTool class methodsFor: 'class initialization' stamp: 'ar 4/4/2004 21:26'!initialize	"self initialize"	CProjectBuilder registerOpenCommand:		{ 'Color Tool' . { self . #open }. 'A Color Tool' }.! !!CCostume class methodsFor: 'private' stamp: 'ar 3/22/2004 14:41'!new	^super new onPlayerChanged! !!CCostume class methodsFor: 'private' stamp: 'ar 3/22/2004 14:41'!on: aValue	^(super new)		value: aValue;		onPlayerChanged;	yourself! !!CDebugger class methodsFor: 'class initialization' stamp: 'md 4/7/2004 16:01'!initialize	ErrorRecursion _ false.	ContextStackKeystrokes _ Dictionary new		at: $e put: #send;		at: $t put: #doStep;		at: $T put: #stepIntoBlock;		at: $p put: #proceed;		at: $r put: #restart;		at: $f put: #fullStack;		at: $w put: #where;		yourself.	"CDebugger initialize"! !!CDebugger class methodsFor: 'class initialization' stamp: 'md 4/7/2004 16:02'!openContext: aContext label: aString contents: contentsStringOrNil	| isolationHead |	"Open a notifier in response to an error, halt, or notify. A notifier view just shows a short view of the sender stack and provides a menu that lets the user open a full debugger."	<primitive: 19> "Simulation guard"	ErrorRecursion not & Preferences logDebuggerStackToFile ifTrue:		[Smalltalk logError: aString inContext: aContext to: 'SqueakDebug.log'].	ErrorRecursion ifTrue:		[ErrorRecursion _ false.		(isolationHead _ CurrentProjectRefactoring currentIsolationHead)			ifNil: [self primitiveError: aString]			ifNotNil: [isolationHead revoke]].	ErrorRecursion _ true.	self informExistingDebugger: aContext label: aString.	(CDebugger context: aContext isolationHead: isolationHead)		openNotifierContents: contentsStringOrNil		label: aString.	ErrorRecursion _ false.	Processor activeProcess suspend.! !!CDebugger class methodsFor: 'instance creation' stamp: 'md 4/6/2004 16:26'!context: aContext 	"Answer an instance of me for debugging the active process starting with the given context."	^ self context: aContext isolationHead: nil! !!CDebugger class methodsFor: 'instance creation' stamp: 'md 4/6/2004 16:56'!context: aContext isolationHead: isolationHead	"Answer an instance of me for debugging the active process starting with the given context."	^ self new		process: Processor activeProcess		controller: nil		context: aContext		isolationHead: isolationHead! !!CDebugger class methodsFor: 'instance creation' stamp: 'md 4/6/2004 16:26'!informExistingDebugger: aContext label: aString	"Walking the context chain, we try to find out if we're in a debugger stepping situation.	If we find the relevant contexts, we must rearrange them so they look just like they would	if the methods were excuted outside of the debugger."	| ctx quickStepMethod oldSender baseContext |	ctx _ thisContext.	quickStepMethod _ ContextPart compiledMethodAt: #quickSend:to:with:super:.	[ctx sender == nil or: [ctx sender method == quickStepMethod]] whileFalse: [ctx _ ctx sender].	ctx sender == nil ifTrue: [^self].	baseContext _ ctx.	"baseContext is now the context created by the #quickSend... method."	oldSender _ ctx _ ctx sender home sender.	"oldSender is the context which originally sent the #quickSend... method"	[ctx == nil or: [ctx receiver isKindOf: self]] whileFalse: [ctx _ ctx sender].	ctx == nil ifTrue: [^self].	"ctx is the context of the Debugger method #doStep"	ctx receiver labelString: aString.	ctx receiver externalInterrupt: false; proceedValue: aContext receiver.	baseContext swapSender: baseContext sender sender sender.	"remove intervening contexts"	thisContext swapSender: oldSender.	"make myself return to debugger"	ErrorRecursion _ false.	^aContext! !!CDebugger class methodsFor: 'opening' stamp: 'md 4/6/2004 16:26'!openInterrupt: aString onProcess: interruptedProcess	"Open a notifier in response to an interrupt. An interrupt occurs when the user types the interrupt key (cmd-. on Macs, ctrl-c or alt-. on other systems) or when the low-space watcher detects that memory is low."	| debugger |	<primitive: 19> "Simulation guard"	debugger _ self new.	debugger		process: interruptedProcess		controller: ((Smalltalk isMorphic not					and: [ScheduledControllers activeControllerProcess == interruptedProcess])						ifTrue: [ScheduledControllers activeController])		context: interruptedProcess suspendedContext.	debugger externalInterrupt: true.Preferences logDebuggerStackToFile ifTrue:	[(aString includesSubString: 'Space') & 		(aString includesSubString: 'low') ifTrue: [			Smalltalk logError: aString inContext: debugger interruptedContext to:'LowSpaceDebug.log']].	^ debugger		openNotifierContents: nil		label: aString! !!CDebugger class methodsFor: 'opening' stamp: 'ar 7/27/2004 00:12'!openOn: process context: context label: title contents: contentsStringOrNil fullView: bool	"Open a notifier in response to an error, halt, or notify. A notifier view just shows a short view of the sender stack and provides a menu that lets the user open a full debugger."	| controller |	"Smalltalk isMorphic		ifTrue: [errorWasInUIProcess _ CurrentProjectRefactoring newProcessIfUI: process]		ifFalse: [controller _ ScheduledControllers activeControllerProcess == process				ifTrue: [ScheduledControllers activeController]]."	self startScript:[		[	| debugger |			debugger _ self new process: process controller: controller context: context.			bool ifTrue: [debugger openFullNoSuspendLabel: title]				ifFalse: [debugger openNotifierContents: contentsStringOrNil label: title].			"debugger errorWasInUIProcess: errorWasInUIProcess."			Preferences logDebuggerStackToFile ifTrue: [				Smalltalk logError: title inContext: context to: 'SqueakDebug.log'].		] on: Error do: [:ex |			self primitiveError: 				'Orginal error: ', 				title asString, '.	Debugger error: ', 				([ex description] on: Error do: ['a ', ex class printString]), ':'		]	].	process suspend.! !!CDebugger class methodsFor: 'window color' stamp: 'md 4/6/2004 16:26'!windowColorSpecification	"Answer a WindowColorSpec object that declares my preference"	^ WindowColorSpec classSymbol: self name  wording: 'Debugger' brightColor: #lightRed pastelColor: #veryPaleRed helpMessage: 'The system debugger.'! !!CDebugger class methodsFor: 'testing' stamp: 'md 4/28/2004 17:52'!openForTest	"Just for testing...   "	CDebugger		openContext: thisContext		label: 'a Test'		contents: 'a Test'! !!CFieldReference class methodsFor: 'class initialization' stamp: 'ar 3/11/2003 19:34'!initialize	"CFieldReference initialize"	CachedFields := WeakValueDictionary new.	FailToken := Object new.! !!CFieldReference class methodsFor: 'instance creation'!compileReference: aField	"Compile a uni-class for the given field reference"	| scripted |	scripted := self new.	scripted becomeUniClass.	scripted class compileUnlogged:				('readValue\	^target ', aField toGet) withCRs			classified: nil			notifying: nil.	aField toSet ifNotNil:[		scripted class compileUnlogged:				('writeValue\	^target ', aField toSet,' value') withCRs			classified: nil			notifying: nil.	].	^scripted class! !!CFieldReference class methodsFor: 'instance creation' stamp: 'ar 3/12/2003 21:32'!forField: aField	"Answer a field reference for the given field"	| key cached |	aField accessKey ifNotNil:[^self new]. "indexed!!"	key := aField toGet.	aField toSet ifNotNil:[		key := key, ' - ', aField toSet.		key := key asSymbol.	].	cached := CachedFields at: key ifAbsent:[nil].	cached ifNil:[		cached := self compileReference: aField.		CachedFields at: key put: cached].	^cached new.! !!CFileDialog class methodsFor: 'file opening' stamp: 'ar 3/13/2004 15:55'!openFile	^self openFile: #(		('All Files' ('*'))	) label: nil! !!CFileDialog class methodsFor: 'file opening' stamp: 'ar 3/13/2004 15:55'!openFile: fileSpec	^self openFile: fileSpec label: nil! !!CFileDialog class methodsFor: 'file opening' stamp: 'ar 3/13/2004 16:24'!openFile: fileSpec label: aString	^self new openFile: fileSpec label: aString! !!CFileDialog class methodsFor: 'file opening' stamp: 'ar 3/13/2004 16:35'!openImageFile	"An example for using file specs"	"CFileDialog openImageFile"	^self openFile: self defaultImageSpec! !!CFileDialog class methodsFor: 'instance creation' stamp: 'ar 3/12/2004 23:20'!new	^super new	"| dialog |	dialog := CPlayer loadPlayerFrom: #('Tweak' 'Dialogs' 'FileDialog.sqp').	dialog gotoDirectory: FileDirectory default.	^dialog"! !!CFileDialog class methodsFor: 'defaults' stamp: 'ar 3/13/2004 16:36'!defaultImageSpec	^#(		('Images' ('*.png' '*.jpg' '*.jpeg' '*.gif' '*.bmp'))		('PNG' ('*.png'))		('JPG' ('*.jpg' '*.jpeg'))		('GIF' ('*.gif'))		('BMP' ('*.bmp'))	)! !!CFileDialog class methodsFor: 'defaults' stamp: 'ar 3/13/2004 16:37'!defaultProjectDirectories	"CFileDialog defaultProjectDirectories"	^{FileDirectory default},	(ServerDirectory serverNames collect:[ :n | ServerDirectory serverNamed: n]),		ServerDirectory localProjectDirectories.! !!CFileDialog class methodsFor: 'utilities' stamp: 'ar 3/14/2004 02:25'!iconForDirectoryEntry: dirEntry	| types mimeType |	dirEntry isDirectory ifTrue:[^nil].	types := FileDirectory default mimeTypesFor: dirEntry name.	types isEmptyOrNil ifTrue:[^nil].	mimeType := types first.	('image/gif' = mimeType) ifTrue:[^self imageIconFrom: dirEntry].	('image/bmp' = mimeType) ifTrue:[^self imageIconFrom: dirEntry].	('image/png' = mimeType) ifTrue:[^self imageIconFrom: dirEntry].	('image/jpeg' = mimeType) ifTrue:[^self imageIconFrom: dirEntry].	('image/*' match: mimeType) ifTrue:[^nil].	('audio/*' match: mimeType) ifTrue:[^nil].	('video/*' match: mimeType) ifTrue:[^nil].	('application/*' match: mimeType) ifTrue:[^nil].	('model/*' match: mimeType) ifTrue:[^nil].	('text/*' match: mimeType) ifTrue:[^nil].	^nil! !!CFileDialog class methodsFor: 'utilities' stamp: 'ar 3/14/2004 02:25'!imageIconFrom: dirEntry	"Answer the appropriate image icon for the given directory entry"! !!CInspector class methodsFor: 'as yet unclassified' stamp: 'md 4/8/2004 12:13'!inspect: anObject 	"Answer an instance of me to provide an inspector for anObject."	^self new inspect: anObject! !!CInspector class methodsFor: 'as yet unclassified' stamp: 'md 4/8/2004 12:10'!openForTest	^self openOn: self! !!CInspector class methodsFor: 'as yet unclassified' stamp: 'md 4/22/2004 13:13'!openForTest2	^self openOn: 1@2! !!CInspector class methodsFor: 'as yet unclassified' stamp: 'md 4/8/2004 12:11'!openOn: anObject	^ self openOn: anObject withLabel: anObject defaultLabelForInspector! !!CInspector class methodsFor: 'as yet unclassified' stamp: 'md 5/3/2004 13:55'!openOn: anObject withEvalPane: aBoolean	^self openOn: anObject! !!CInspector class methodsFor: 'as yet unclassified' stamp: 'md 4/8/2004 12:11'!openOn: anObject withLabel: aLabel	|  inspector |	inspector _ self inspect: anObject.	inspector open.	inspector window label: aLabel.	^ inspector		! !!CMessageSet class methodsFor: 'instance creation' stamp: 'md 4/23/2004 14:42'!openMessageList: messageList name: title 	| msgSet |	msgSet := self new.	msgSet window label: title.	msgSet messageList contents: messageList.	msgSet open.	^msgSet! !!CMessageSet class methodsFor: 'instance creation' stamp: 'ar 3/7/2004 00:05'!openMessageList: messageList name: title autoSelect: aString	| msgSet |	msgSet := self new.	msgSet window label: title.	msgSet autoSelectString: aString.	msgSet messageList contents: messageList.	msgSet open.	^msgSet! !!CChangedMessageSet class methodsFor: 'as yet unclassified' stamp: 'md 4/23/2004 17:18'!openFor: aChangeSet	"Open up a ChangedMessageSet browser on the given change set; this is a conventional message-list browser whose message-list consists of all the methods in aChangeSet.  After any method submission, the message list is refigured, making it plausibly dynamic"	| messageSet |	messageSet _ aChangeSet changedMessageListAugmented select: [ :each | each isValid].	self 		openMessageList: messageSet 		name: 'Methods in Change Set ', aChangeSet name		autoSelect: nil		changeSet: aChangeSet! !!CChangedMessageSet class methodsFor: 'as yet unclassified' stamp: 'md 4/23/2004 17:22'!openMessageList: messageList name: labelString autoSelect: autoSelectString changeSet: aChangeSet	self openMessageList: messageList name: labelString autoSelect: autoSelectString.! !!CPlayerCollection class methodsFor: 'instance creation' stamp: 'ar 3/16/2004 12:35'!costume: aCostume	^(self new) costume: aCostume; yourself! !!CPrimitiveCostume class methodsFor: 'accessing' stamp: 'ar 2/6/2003 10:35'!eventsGenerated	^#(		mouseDown mouseEnter mouseMove mouseLeave mouseUp 		dragStart dragEnter dragMove dragLeave dragDrop		redButtonDown redButtonMove redButtonUp 		yellowButtonDown yellowButtonMove yellowButtonUp 		blueButtonDown blueButtonMove blueButtonUp 		click doubleClick		layoutChanged		opened closed	)! !!CPrimitiveCostume class methodsFor: 'instance creation' stamp: 'ar 2/29/2004 18:38'!makeCostumeFor: aPlayer	"Create a new costume for the given player"	^(super new) initialize; player: aPlayer; yourself! !!CPrimitiveCostume class methodsFor: 'instance creation'!new	^super new initialize! !!CPrimitiveCostume class methodsFor: 'class initialization'!flagRegistry	^FlagRegistry ifNil:[FlagRegistry := Array new: SmallInteger maxVal highBit].! !!CPrimitiveCostume class methodsFor: 'class initialization' stamp: 'ar 3/21/2004 03:32'!initialize	"CCostume initialize"	DefaultFill := CCostumeFill new.	DefaultBorder := CCostumeBorder new.	FlagHidden := self requestFlag: #hidden.	FlagCustomDraw := self requestFlag: #customDraw.	FlagInvalidationSuppressed := self requestFlag: #invalidationSuppressed.	FlagExcessBounds := self requestFlag: #excessBounds.	FlagLocked := self requestFlag: #locked.	FlagLayoutNeeded := self requestFlag: #layoutNeeded.	FlagCached := self requestFlag: #cacheEnabled.	FlagHasScroller := self requestFlag: #hasScroller.	FlagClipEnabled := self requestFlag: #clipEnabled.	FlagHasMatrix := self requestFlag: #hasMatrix.	FlagHasHighlights := self requestFlag: #hasHighlights.	FlagRoundedCorners := self requestFlag: #hasRoundedCorners.	FlagHasGraphic := self requestFlag: #hasGraphic.	FlagHasText := self requestFlag: #hasText.	FlagHasShape := self requestFlag: #hasShape.	FlagHasOverlay := self requestFlag: #hasOverlay.	FlagHasGrid := self requestFlag: #hasGrid.	FlagInvalidated := self requestFlag: #invalidated.	"FlagHasFullBounds:		If present, it indicates that we cache the receiver's fullBounds in the #fullBounds		property. If absent, no fullBounds are cached."	FlagHasFullBounds := self requestFlag: #hasFullBounds.	"Define a mask when 'bounds' define accurate full bounds"	FlagIntrinsicFullBounds := 0.	"If there's a scroller it doesn't (due to scroll offset)"	FlagIntrinsicFullBounds := FlagIntrinsicFullBounds bitOr: FlagHasScroller.	"If children exceed the receiver it doesn't"	FlagIntrinsicFullBounds := FlagIntrinsicFullBounds bitOr: FlagExcessBounds.	"If a layout is needed, it doesn't"	FlagIntrinsicFullBounds := FlagIntrinsicFullBounds bitOr: FlagLayoutNeeded.	"If it's got a transform it doesn't"	FlagIntrinsicFullBounds := FlagIntrinsicFullBounds bitOr: FlagHasMatrix.	"If it's got highlights it doesn't (they may exceed beyound bounds)"	FlagIntrinsicFullBounds := FlagIntrinsicFullBounds bitOr: FlagHasHighlights.! !!CPrimitiveCostume class methodsFor: 'class initialization'!releaseFlag: flagName	"Release an entry in Costume's flags."	"@@@@: TODO. Clean up existing flag values in costumes. :@@@@"	| registry flag |	registry := self flagRegistry.	1 to: registry size do:[:i|		flag := registry at: i.		flag == flagName ifTrue:[registry at: i put: nil].	].! !!CPrimitiveCostume class methodsFor: 'class initialization'!requestFlag: flagName				 	"Request an entry in Costume's flags. Return the bit assigned 	for this flag or nil if no space is available"	| registry flag flagIndex |	registry := self flagRegistry.	flagIndex := nil.	1 to: registry size do:[:i|		flag := registry at: i.		flag == flagName ifTrue:[^1 bitShift: (i-1)].		flag ifNil:[flagIndex ifNil:[flagIndex := i]].	].	flagIndex ifNotNil:[registry at: flagIndex put: flagName].	^1 bitShift: (flagIndex-1)! !!CProjectBuilder class methodsFor: 'tcar' stamp: 'ar 3/28/2004 01:32'!tcarReleaseNotes^'Tweak Core Architecture Release (TCAR)        -- "Don''t do it if it hurts!!!!"About this Release:The TCAR is the release of the core parts of the Tweak architecture. It is NOT an end-user release, it is intended for early adopters and participants who wish learn the architecture early on and actively contribute. If you are looking for the end-user release, this isn''t it (yet).Mailing list:A mailing list exists at http://impara.de/mailman/listinfo/tweakWhat is in this release:This release contains the following parts:* The Tweak CompilerSince I couldn''t any longer manage the changes to the existing compiler in the form of hacks, this release simply contains a copy of the existing compiler (see category ''Tweak-Compiler''). The compiler supports method annotations (which are critical for some aspects of Tweak), positional arguments (critical for interfacing some of the scripting languages that will be supported in the future), support for "fields" (which are a carefully controlled form of implicit self) and some more.NOTE: If you are interesting in writing a decent compiler rather than this hacked-together piece of junk, please do!!!! I''d be more than happy to throw the existing crap away.* The asynchronous event architectureThis is one of the fundamental parts of Tweak, allowing us to provide multi-threading with clearly defined default-synchronization semantics (if you are curious, open a process browser, turn on auto-updating and watch what happens when you move over the menubar on top). The threading semantics is PRECISELY the same that we have in Morphic''s steps. Here is a little example (which will not work because the editor doesn''t support code evaluation yet ho hum, and I haven''t got the <doit> text attribute back to work...):    button := CPushButton new.    button label: ''Button''.    button open.    button waitUntil: #click.    Smalltalk beep.The event architecture can be found (due to historical reasons) under the ''Scripting-*'' categories.NOTE: This stuff is currently fairly inefficient. Really there isn''t any need whatsoever to throw around as many processes as I''m doing right now - it was my way to make sure this stuff absolutely works but there''s a lot of low-hanging fruit for optimization here. So if something seems to go slowly don''t optimize on the wrong end because you see "all these processes" - they will go away as soon as it "hurts enough" to become a worthwhile target for optimization (and if you complain loudly enough it will raise to the top of the priority list much faster).* The graphical object representationIn Tweak, all graphical objects are an assembly of a (pretty large) set of so-called "costume aspects". These aspects cover all of the areas that a graphical object may have such as:    * their geometry    * their fill    * their border    * their text    * their graphic    * their layout    * ... (many others omitted) ...The "aspects" are a fundamental part of Tweaks graphical object representation because they allow us to narrow down a broad set of interfaces into a very small one and allow delegation of this specific aspect (check out how the fill, border, or text attributes are implemented in CPlayer). Also, by the end of the day there is only "one kind" of graphical object which carries all of these aspects around - this is CPrimitiveCostume and this is one of the guys which is really off-limits. You can look but you cannot touch, but go ahead and study the aspects you find in the "Tweak-Costumes" categories.NOTE: Some aspects are still missing or aren''t fully formed yet. If you need something that isn''t there yet, feel free to help out.* The core Tweak architectural objectsThese are found in the "Tweak-User-Kernel" category. Only six of them? No, really there is only one ;-) Most of the guys you find there have been defined because many programmers prefer to think in terms of "types" rather than "roles" and the classes found in the kernel category are intended to help them a little along those lines. But really "The One And Only" object to look at is CPlayer. It''s the center of the architecture and everything else evolves around it.Also, there are some interim objects in the "Tweak-User-Media" category which I defined to occupy the names in the global namespace - these will be filled in as we work out the interfaces which we want to expose to these media objects.* Tweak WidgetsThere is an (almost complete) set of widgets by this time, but note that some of them are probably not structured quite right, lack some good notions so please, please, please - don''t take them for a given, I am REALLY interested in finding fundamentally good and useful notions for these widgets and if you find something that seems obscure and in the wrong place, let me know.To give an example, after some discussion with Bert I completely changed the way buttons work because it just seemed so much more useful to have them be "state-based" - the message here is that I am interested in useful notions more than anything else.Finally, keep in mind that the widgets have been built in the "second order theory" of Tweak rather than its first order theory (which is entirely reasonable to use - see the ColorTool for an example for first-order theory Tweak use). The reason for using the second-order theory for the widgets is because it is certain that we will want to have completely different widget sets (including native widgets) and the architecture allows for this easily.* Tweak TilesThe core architecture release contains the basic tile framework for Tweak. This framework has been built based on "the lessons from eToys" so that they we will be able to support various looks and feels but share the (essential) models across a wide variety of authoring environments.Because of this, the tile framework is yet another example of the second-order theory of Tweak and you should be careful to copy what you see here "for the wrong reasons". There is no need for 90% of all user-code to make use of an advanced theory if the naive approach works likewise (often better).* A first (somewhat rudimentary) run at the authoring environmentThis what ColorTool, ProjectBuilder and friends provide. There is still a lot of work to be done and if you want to build something useful and learn about the architecture, that''s a good place to start. Just find yourself a little tool which you would find useful to have for authoring and start building it.* An (extremely rudimentary) first run at programming toolsIf it weren''t for the programming tools, Tweak would put both Morphic and MVC to its final rest - there is no reason to have any of them, Tweak doesn''t need them and being able to get rid of both is one of the ultimate goals here.This would be another good place to start: Just take whatever tool you know from Morphic and make it work with Tweak. The rudimentary start I did on the workspace and the (not-quite-working) browser should give you a pretty good start here.What is NOT in this release:When I decided to ship this release for real I had to make a really hard decision between taking all of the previous stuff from alpha1 with the TCAR or not. I decided against it for a single reason: People who would look at stuff from alpha1 wouldn''t see the things they ought to see. While there were some good things in alpha1 I decided to leave them out for the single reason to make this release as concise as possible - you get only things that I have explicitly reviewed and found "good enough" to be looked at.That''s partly why this release is poor on the "end-user notions" - all of the stuff which was in alpha1 was aimed at the end-user space, but in making (and refining) the TCAR I had to change some fundamental things and looking at any of the former stuff would just get into your way of understanding what Tweak is all about. These things will come back - based on a stronger foundation than they were and in about 1/10th of the time it took to build them originally.Also, there is one major aspect that is missing in this release simply because I wanted to get it out - that''s the part of "constructing user interfaces". At this point one still has to "program" the user interface very much like in Morphic but the architectural hooks are there and one of the next steps will be to bring in the interactive construction back in. Until then, you are no better or worse off then with Morphic.Disclaimer:At this point, the TCAR comes without a license since we are still talking about the "right" license (for various reasons). If you have an urgent need for a clarification on this issue please feel free to contact us.!!]style[(38 41 19 285 13 67 24 46 20 664 37 751 561 1 37 940 132 1 38 708 15 1088 13 589 65 311 59 475 8 3 17 1415 11 220)f1FNewYork#21b,f1,f1b,f1,f1b,f1,f1b,f1,f1b,f1,f1b,f1,f1i,f1,f1b,f1,f1i,f1,f1b,f1,f1b,f1,f1b,f1,f1b,f1,f1b,f1,f1b,f1bu,f1b,f1,f1b,f1!!' readStream nextChunkText! !!CProjectBuilder class methodsFor: 'menu registry' stamp: 'ar 3/29/2004 16:47'!registerOpenCommand: anArray	"The array received should be of form {'A Label String'. {TargetObject. #command}  'A Help String'} ; the final element is optional but if present will be used to supply balloon help for the menu item in the Open menu.	If any previous registration of the same label string is already known, delete the old one."	| item target selector |	self unregisterOpenCommand: anArray first.	item := CMenuItem new.	item label: anArray first.	target := anArray second first.	selector := anArray second last.	item action: (MessageSend receiver: target selector: selector).	self toolMenuItems add: item.! !!CProjectBuilder class methodsFor: 'menu registry' stamp: 'ar 3/29/2004 16:47'!toolMenuItems	^ToolMenuItems ifNil:[ToolMenuItems := CCollection new].! !!CProjectBuilder class methodsFor: 'menu registry' stamp: 'ar 3/29/2004 16:46'!unregisterOpenCommand: label	"Remove the open command with the given label from the registry"	self toolMenuItems removeAll: 		(self toolMenuItems select:[:each| each label = label]).! !!CProjectBuilder class methodsFor: 'menu registry' stamp: 'ar 3/29/2004 16:47'!unregisterOpenCommandWithReceiver: aReceiver	"Remove the open command with the given object as receiver from the registry"	self toolMenuItems removeAll: 		(self toolMenuItems select:[:each| each action receiver = aReceiver]).! !!CProjectLoader class methodsFor: 'instance creation' stamp: 'ar 12/2/2003 19:28'!readFrom: aStream	^self new readFrom: aStream! !!CResource class methodsFor: 'class initialization' stamp: 'ar 12/2/2003 20:39'!initialize	"CResource initialize"	ResourceTypes := Dictionary new.	self initializeDefaultResources.! !!CResource class methodsFor: 'class initialization' stamp: 'ar 3/26/2004 22:15'!initializeDefaultResources	"CResource initializeDefaultResources"	| resType provider |	#(		(class		Behavior)		(maker		CObjectMaker)		(behavior	CObject)		(image		CImageResource)		(font		StrikeFont)		(library		CProjectLibrary)	) do:[:spec|		resType := spec first.		provider := Smalltalk at: spec last.		self unRegisterResource: resType.		self registerResource: resType provider: provider.	].! !!CResource class methodsFor: 'class initialization' stamp: 'ar 12/2/2003 15:02'!registerResource: resourceType provider: aProvider	| existing |	existing := ResourceTypes at: resourceType ifAbsent:[nil].	(existing == nil or:[existing == aProvider]) ifFalse:[^self error: 'duplicate resource type'].	ResourceTypes at: resourceType put: aProvider.! !!CResource class methodsFor: 'class initialization' stamp: 'ar 12/2/2003 20:38'!resourceProviderFor: resourceType	^ResourceTypes at: resourceType! !!CResource class methodsFor: 'class initialization' stamp: 'ar 12/2/2003 14:59'!unRegisterResource: resourceType	ResourceTypes removeKey: resourceType ifAbsent:[]! !!CResource class methodsFor: 'instance creation' stamp: 'ar 12/2/2003 15:01'!importResourcesFrom: zipArchive	"Extract all resources from the given zip archive"	| stream type localName provider |	^(zipArchive members select:[:mbr| mbr fileName beginsWith: 'resources/']) collect:[:mbr|		stream := mbr fileName readStream.		(stream upTo: $/) = 'resources' ifFalse:[self error: 'Fatal inconsistency'].		type := stream upTo: $/.		localName := stream upToEnd.		"We could be less drastical here but for now that seems like a good choice"		provider := ResourceTypes at: type 			ifAbsent:[self error: type,': Unknown resource'].		provider importResource: mbr name: localName.	].		! !!CMaker class methodsFor: 'interface' stamp: 'ar 11/21/2003 18:37'!newFrom: anObject	^self new newFrom: anObject! !!CMaker class methodsFor: 'interface' stamp: 'ar 12/3/2003 18:55'!withID: uid	^CResourceManager default lookup: uid ifAbsent:[nil]! !!CMediaResource class methodsFor: 'instance creation' stamp: 'ar 3/14/2004 17:23'!with: media	^self new setMedia: media! !!CImageResource class methodsFor: 'instance creation' stamp: 'ar 12/2/2003 21:48'!importXmlResource: xmlNode in: aLoader	^aLoader importForm: xmlNode! !!CImageResource class methodsFor: 'instance creation' stamp: 'ar 3/14/2004 17:45'!readFrom: file	| form imageType theForm |	('*.png' match: file localName) ifTrue:[		imageType := #png.	].	(#('*.jpg' '*.jpeg') any match: file localName) ifTrue:[		imageType := #jpeg.	].	(#('*.pcx') any match: file localName) ifTrue:[		imageType := #pcx.	].	(#('*.bmp') any match: file localName) ifTrue:[		imageType := #bmp.	].	(#('*.xbm') any match: file localName) ifTrue:[		imageType := #xbm.	].	(#('*.gif') any match: file localName) ifTrue:[		imageType := #gif.	].	theForm := [self readFrom: file type: imageType] on: Error do:[:ex| ex return: nil].	theForm ifNil:[^nil].	form := self with: theForm.	form name: file localName.	form type: imageType.	form url: file url.	^form! !!CImageResource class methodsFor: 'instance creation' stamp: 'ar 3/14/2004 17:45'!readFrom: file type: imageType	| reader |	imageType == #png ifTrue:[reader := PNGReadWriter].	imageType == #jpeg ifTrue:[reader := JPEGReadWriter2].	imageType == #pcx ifTrue:[reader := PCXReadWriter].	imageType == #bmp ifTrue:[reader := BMPReadWriter].	imageType == #xbm ifTrue:[reader := XBMReadWriter].	imageType == #gif ifTrue:[reader := GIFReadWriter].	reader ifNil:[^nil].	^(reader new on: file) nextImage! !!CMovieResource class methodsFor: 'instance creation' stamp: 'ar 3/14/2004 17:32'!importXmlResource: xmlNode in: aLoader	^aLoader importMovie: xmlNode! !!CMovieResource class methodsFor: 'instance creation' stamp: 'ar 3/14/2004 17:45'!readFrom: file	| sound movieType theMovie |	('*.jmv' match: file localName) ifTrue:[		movieType := #jmv.	].	(#('*.mpg' '*.mpeg') any match: file localName) ifTrue:[		movieType := #mpeg.	].	theMovie := [self readFrom: file type: movieType] on: Error do:[:ex| ex return: nil].	theMovie ifNil:[^nil].	sound := self with: theMovie.	sound name: file localName.	sound type: movieType.	sound url: file url.	^sound! !!CMovieResource class methodsFor: 'instance creation' stamp: 'ar 3/14/2004 17:36'!readFrom: file type: movieType	movieType == #mpeg ifTrue:[		^MPEGFile openFile: file fullName	].	movieType == #jmv ifTrue:[		^JPEGMovieFile new openFileNamed: file fullName	].	^nil! !!CObjectMaker class methodsFor: 'instance creation' stamp: 'ar 12/3/2003 00:33'!importXmlResource: xmlNode in: loader	^loader importObjectMaker: xmlNode! !!CResourceManager class methodsFor: 'instance creation' stamp: 'ar 12/1/2003 18:40'!default	^Default ifNil:[Default := self new]! !!CResourceManager class methodsFor: 'instance creation' stamp: 'ar 12/1/2003 18:40'!new	^super new initialize! !!CRootMorph class methodsFor: 'as yet unclassified' stamp: 'ar 3/27/2004 16:55'!initialize	"CRootMorph initialize."	TheWorldMenu registerOpenCommand: 		{ 'Tweak Project Window' . { CRootMorph . #open }. 'A Tweak Project' }.! !!CRootMorph class methodsFor: 'as yet unclassified' stamp: 'ar 10/4/2004 21:54'!open	| root window |	root := self new.	window := SystemWindow labelled: 'Window'.	window model: root.	window addMorph: root frame: (0@0 corner: 1@1).	window openInWorld.	root window: window.	root myWorld activeProject color: (Color gray: 0.8).	root myWorld activeProject startScript: #showReleaseNotes.	^window! !!CSerializer class methodsFor: 'as yet unclassified' stamp: 'ar 9/17/2003 17:46'!new	^super new initialize! !!CSerializer class methodsFor: 'as yet unclassified' stamp: 'ar 9/17/2003 17:47'!serialize: anObject	^self new serialize: anObject! !!CObjectMakerSerializer class methodsFor: 'as yet unclassified' stamp: 'ar 10/18/2003 21:42'!serialize: anObject on: aStream	^self new serialize: anObject on: aStream! !!CObjectMakerSerializer class methodsFor: 'as yet unclassified' stamp: 'ar 10/18/2003 21:42'!serialize: anObject onFileNamed: aString	| file |	file := FileStream forceNewFileNamed: aString.	 [self serialize: anObject on: file] ensure:[file close].	^nil! !!CComplexBorder class methodsFor: 'instance creation' stamp: 'bf 3/30/2004 14:44'!style: aSymbol	^self new style: aSymbol; yourself! !!CSimpleTextEditor class methodsFor: 'class initialization' stamp: 'ar 4/5/2004 02:11'!initialize	"self initialize"	CProjectBuilder registerOpenCommand: {'SimpleText'. {self. #open}}.! !!CSolidFill class methodsFor: 'instance creation'!color: aColor	^self new color: aColor! !!CSoundResource class methodsFor: 'instance creation' stamp: 'ar 3/14/2004 17:22'!importXmlResource: xmlNode in: aLoader	^aLoader importSound: xmlNode! !!CSoundResource class methodsFor: 'instance creation' stamp: 'ar 3/14/2004 17:46'!readFrom: file	| sound soundType theSound |	('*.wav' match: file localName) ifTrue:[		soundType := #wav.	].	(#('*.aif' '*.aiff') any match: file localName) ifTrue:[		soundType := #aiff.	].	(#('*.mp3' '*.mpg') any match: file localName) ifTrue:[		soundType := #mp3.	].	theSound := [self readFrom: file type: soundType] on: Error do:[:ex| ex return: nil].	theSound ifNil:[^nil].	sound := self with: theSound.	sound name: file localName.	sound type: soundType.	sound url: file url.	^sound! !!CSoundResource class methodsFor: 'instance creation' stamp: 'ar 3/14/2004 17:02'!readFrom: file type: soundType	(soundType = #wav) ifTrue:[		^SampledSound fromWaveStream: file.	].	(soundType = #aiff) ifTrue:[		| reader |		reader _ AIFFFileReader new.		reader readFromStream: file mergeIfStereo: true skipDataChunk: false.		^SampledSound			samples: (reader channelData at: 1)			samplingRate: reader samplingRate	].	(soundType = #mp3) ifTrue:[		^(MPEGFile openFile: file fullName) audioPlayerForChannel: 0.	].	^nil! !!CTabButtonList class methodsFor: 'example' stamp: 'ar 3/13/2004 04:43'!example1	"CTabList example1"	| list |	list := self new.	list add: 'Overview'.	list add: 'Details'.	list add: 'More stuff...'.	^list! !!CTabButtonList class methodsFor: 'example' stamp: 'ar 3/13/2004 05:39'!example2	"CTabList example1"	| list |	list := self new.	list add: 'Projects'.	list add: 'Objects'.	list add: 'Images'.	list add: 'Music'.	list add: 'Movies'.	list add: 'All'.	^list! !!CTextComposer class methodsFor: 'as yet unclassified' stamp: 'ar 1/9/2003 16:25'!characterForColumnBreak	^Character value: 12! !!CTextTool class methodsFor: 'as yet unclassified' stamp: 'ar 4/4/2004 21:26'!initialize	"self initialize"	CProjectBuilder registerOpenCommand:		{ 'Text Tool' . { self . #open }. 'A Text Tool' }.! !!CTileDefinition class methodsFor: 'reading' stamp: 'tk 7/8/2004 15:48'!defaultViewerSpec	"CTileDefinition readXmlFrom: self defaultViewerSpec readStream"^'<viewer type="CPlayer">	<category name="list" type="CList">		<slot selector="cursor" type="CNumberType"/>		<message selector="next"/>		<message selector="prev"/>	</category>	<category name="slider" type="CSlider">		<slot selector="value" type="CNumberType" help="The current value"/>		<slot selector="min" type="CIntegerType" help="The minimum value"/>		<slot selector="max" type="CIntegerType" help="The maximum value"/>		<slot selector="step" type="CIntegerType" help="The step value"/>		<message selector="next"/>		<message selector="prev"/>	</category>	<category name="button" type="CButton">		<slot selector="label" type="CStringType" help="The button label"/>		<slot selector="image" type="CImageResourceType" help="The button image"/>		<slot selector="state" type="CButtonStateType" help="The button state"/>		<slot selector="selected" type="CBooleanType" help="The selection state"/>		<slot selector="value" type="CBooleanType" help="The button label"/>		<message selector="select"/>		<message selector="deselect"/>		<message selector="fire" help="fire the button"/>		<message selector="enable"/>		<message selector="disable"/>	</category>	<category name="images" type="CImageButton">		<slot selector="normalImage" type="CImageResourceType"/>		<slot selector="overImage" type="CImageResourceType"/>		<slot selector="pressedImage" type="CImageResourceType"/>		<slot selector="disabledImage" type="CImageResourceType"/>		<slot selector="selectedImage" type="CImageResourceType"/>	</category>	<category name="basic">		<message selector="makeSound:" name="make sound:" help="Make the specified sound">			<argument name="aSound" type="CSoundNameType" default="croak"/>		</message>		<message selector="forwardBy:" name="forward by:" help="">			<argument name="delta" type="CNumberType" default="5"/>		</message>		<message selector="turnBy:" name="turn by:" help="">			<argument name="delta" type="CNumberType" default="5"/>		</message>		<slot selector="x" name="x" type="CNumberType" help="The x coordinate"/>		<slot selector="y" name="y" type="CNumberType" help="The y coordinate"/>		<slot selector="angle" name="heading" type="CNumberType" help="The heading"/>	</category>	<category id="scripts" name="scripts">		<message selector="emptyScript" name="emptyScript" help="The empty script"/>	</category>	<category name="math">		<operator selector="+" name="+" type="CNumberType" help="Add two values">			<argument name="A" type="CNumberType" default="1"/>			<argument name="B" type="CNumberType" default="1"/>		</operator>		<operator selector="-" name="-" type="CNumberType" help="Add two values">			<argument name="A" type="CNumberType" default="1"/>			<argument name="B" type="CNumberType" default="1"/>		</operator>		<operator selector="*" name="*" type="CNumberType" help="Add two values">			<argument name="A" type="CNumberType" default="1"/>			<argument name="B" type="CNumberType" default="1"/>		</operator>		<operator selector="/" name="/" type="CNumberType" help="Add two values">			<argument name="A" type="CNumberType" default="1"/>			<argument name="B" type="CNumberType" default="1"/>		</operator>	</category>	<category name="color and border">		<message selector="color:sees:" name="color:sees:" type="CBooleanType">			<argument name="myColor" type="CColorType" default="blue"/>			<argument name="aColor" type="CColorType" default="red"/>		</message>		<slot selector="color" name="color" type="CColorType"/>		<slot selector="fillStyle" name="fillStyle" type="CFillStyleType"/>		<slot selector="gradientColor" name="gradientColor" type="CColorType"/>		<slot selector="borderWidth" name="borderWidth" type="CIntegerType"/>		<slot selector="borderColor" name="borderColor" type="CColorType"/>		<slot selector="borderStyle" name="borderStyle" type="CBorderStyleType"/>		<slot selector="roundCorners" name="roundedCorners" type="CBooleanType"/>		<slot selector="dropShadowEnabled" name="shadowEnabled" type="CBooleanType"/>		<slot selector="dropShadowColor" name="shadowColor" type="CColorType"/>	</category>		<category name="geometry">		<slot selector="x" name="x" type="CNumberType" help="The x coordinate"/>		<slot selector="y" name="y" type="CNumberType" help="The y coordinate"/>		<slot selector="angle" name="heading" type="CNumberType" help="The heading"/>		<slot selector="scale" name="scale" type="CNumberType"/>		<slot selector="left" name="left" type="CNumberType"/>		<slot selector="right" name="right" type="CNumberType"/>		<slot selector="top" name="top" type="CNumberType"/>		<slot selector="bottom" name="bottom" type="CNumberType"/>		<slot selector="width" name="width" type="CNumberType"/>		<slot selector="height" name="height" type="CNumberType"/>	</category></viewer>'! !!CTileDefinition class methodsFor: 'reading' stamp: 'ar 3/21/2004 19:23'!openDefaultViewer	^(self readXmlFrom: self testViewerSpec readStream) first new open! !!CTileDefinition class methodsFor: 'reading' stamp: 'ar 3/21/2004 23:43'!openDefaultViewerOn: aPlayer	^((self readXmlFrom: self defaultViewerSpec readStream) first newFor: aPlayer) open! !!CTileDefinition class methodsFor: 'reading' stamp: 'ar 3/21/2004 16:29'!readXmlFrom: aStream	| doc |	doc := XMLDOMParser parseDocumentFrom: aStream.	^doc elements collect:[:each| self xmlFrom: each].! !!CTileDefinition class methodsFor: 'reading' stamp: 'ar 3/21/2004 20:41'!testViewerSpec	"CTileDefinition readXmlFrom: self defaultViewerSpec readStream"^'<viewer type="CPlayer">	<category name="basic">		<message selector="makeSound:" name="make sound:" help="Make the specified sound">			<argument name="aSound" type="CSoundNameType" default="croak"/>		</message>		<message selector="forwardBy:" name="forward by:" help="">			<argument name="delta" type="CNumberType" default="5"/>		</message>		<slot selector="angle" name="heading" type="CNumberType" help="The heading"/>		<slot selector="color" name="color" type="CColorType"/>		<message selector="color:sees:" name="color:sees:" type="CBooleanType">			<argument name="myColor" type="CColorType" default="blue"/>			<argument name="otherColor" type="CColorType" default="red"/>		</message>		<message selector="borderStyle:" name="borderStyle:">			<argument name="aStyle" type="CBorderStyleType" default="simple"/>		</message>		<message selector="fillStyle:" name="fillStyle:">			<argument name="aStyle" type="CFillStyleType" default="simple"/>		</message>	</category></viewer>'! !!CTileDefinition class methodsFor: 'reading' stamp: 'ar 3/22/2004 16:08'!xmlFrom: xmlNode	xmlNode name == #message 		ifTrue:[^CMessageDefinition new readXmlFrom: xmlNode].	xmlNode name == #slot		ifTrue:[^CSlotDefinition new readXmlFrom: xmlNode].	xmlNode name == #operator 		ifTrue:[^COperatorDefinition new readXmlFrom: xmlNode].	xmlNode name == #category		ifTrue:[^CCategoryDefinition new readXmlFrom: xmlNode].	xmlNode name == #viewer		ifTrue:[^CViewerDefinition new readXmlFrom: xmlNode].	self error: xmlNode name, ' - unknown tile definition'.	^nil! !!CTileLibrary class methodsFor: 'accessing' stamp: 'ar 3/7/2004 21:36'!default	^Default ifNil:[Default := self new].! !!CTileLibrary class methodsFor: 'accessing' stamp: 'ar 3/7/2004 21:36'!default: aLibrary	Default := aLibrary.! !!CTileType class methodsFor: 'converting' stamp: 'ar 3/21/2004 16:59'!print: aValue	"Print a textual representation of the given value"	^aValue printString! !!CTileType class methodsFor: 'converting' stamp: 'ar 3/21/2004 16:59'!read: aString	"Read a textual representation of some value"	^self subclassResponsibility! !!CTileType class methodsFor: 'type tests' stamp: 'ar 3/25/2004 22:39'!canCoerceType: aType	^aType includesBehavior: self! !!CColorType class methodsFor: 'accessing' stamp: 'ar 3/22/2004 18:34'!defaultValue	^Color white! !!CColorType class methodsFor: 'as yet unclassified' stamp: 'ar 3/21/2004 19:25'!print: aColor	^aColor name! !!CColorType class methodsFor: 'as yet unclassified' stamp: 'ar 3/21/2004 19:25'!read: aString	^Color perform: aString asSymbol! !!CEnumType class methodsFor: 'accessing' stamp: 'ar 3/22/2004 18:34'!defaultValue	^self enumValues first! !!CEnumType class methodsFor: 'accessing' stamp: 'ar 3/21/2004 18:51'!enumValues	^#()! !!CBooleanType class methodsFor: 'accessing' stamp: 'ar 3/21/2004 20:27'!enumValues	^{true. false}! !!CBooleanType class methodsFor: 'converting' stamp: 'ar 3/21/2004 16:57'!read: aString	"Read a textual representation of some value"	^aString = 'true'! !!CNumberType class methodsFor: 'accessing' stamp: 'ar 3/22/2004 18:34'!defaultValue	^1! !!CNumberType class methodsFor: 'converting' stamp: 'ar 3/21/2004 16:58'!read: aString	"Read a textual representation of some value"	^Number readFrom: aString! !!CIntegerType class methodsFor: 'converting' stamp: 'ar 3/21/2004 16:58'!read: aString	"Read a textual representation of some value"	^Integer readFrom: aString! !!CResourceType class methodsFor: 'accessing' stamp: 'ar 4/3/2004 14:07'!print: aValue	"Print a textual representation of the given value"	aValue ifNil:[^''].	^aValue resourceUrl! !!CImageResourceType class methodsFor: 'accessing' stamp: 'ar 4/3/2004 14:07'!read: aString	| aStream |	aString isEmpty ifTrue:[^nil].	aStream := aString asUrl contentStream.	^[CImageResource readFrom: aStream] ensure:[aStream close].! !!CSoundNameType class methodsFor: 'converting' stamp: 'ar 3/21/2004 17:27'!print: aValue	^aValue! !!CSoundNameType class methodsFor: 'converting' stamp: 'ar 3/21/2004 16:58'!read: aString	"Read a textual representation of some value"	^aString asString! !!CSoundNameType class methodsFor: 'accessing' stamp: 'ar 3/21/2004 18:51'!enumValues	^SampledSound soundNames! !!CStringType class methodsFor: 'accessing' stamp: 'ar 3/22/2004 18:35'!defaultValue	^''! !!CStringType class methodsFor: 'converting' stamp: 'ar 3/21/2004 17:26'!print: aValue	^aValue! !!CStringType class methodsFor: 'converting' stamp: 'ar 3/21/2004 16:58'!read: aString	"Read a textual representation of some value"	^aString asString! !!CSymbolType class methodsFor: 'converting' stamp: 'ar 3/21/2004 17:26'!print: aValue	^aValue! !!CSymbolType class methodsFor: 'converting' stamp: 'ar 3/27/2004 19:42'!read: aString	^self enumValues detect:[:any| any = aString] ifNone:[self defaultValue]. "@@@ should this raise an error???"! !!CBorderStyleType class methodsFor: 'accessing' stamp: 'ar 3/21/2004 20:42'!enumValues	^#(none simple inset raised 	complexAltFramed complexAltInset complexAltRaised 	complexFramed complexInset complexRaised)! !!CButtonStateType class methodsFor: 'as yet unclassified' stamp: 'ar 3/28/2004 22:40'!enumValues	^#(normal over pressed disabled)! !!CFillStyleType class methodsFor: 'accessing' stamp: 'ar 3/21/2004 20:30'!enumValues	^#(none solid horizontalGradient verticalGradient diagonalGradient linearGradient radialGradient)! !!CTreeWidget class methodsFor: 'examples' stamp: 'ar 3/13/2004 01:16'!example1	"CTreeWidget example1"	| tree |	tree := self new.	tree rootNode: (CFileDirectoryTreeItem on: FileDirectory default).	^tree! !!CTreeWidget class methodsFor: 'examples' stamp: 'ar 3/13/2004 01:16'!example2	"CTreeWidget example2"	| tree |	tree := self new.	tree rootNodes: (CFileDirectoryTreeItem on: FileDirectory root) getChildren.	^tree! !!CTreeWidget class methodsFor: 'examples' stamp: 'ar 3/13/2004 01:13'!example3	"CTreeWidget example3"	| tree roots |	tree := self new.	roots := ServerDirectory serverNames collect:[ :n | ServerDirectory serverNamed: n].	roots := roots, ServerDirectory localProjectDirectories.	tree roots: roots.	^tree! !!CMenu class methodsFor: 'as yet unclassified' stamp: 'ar 3/7/2004 04:44'!testMenu	| menu max |	menu := self new.	max := 20.	menu add: 'Item 1' target: CDialog action: #inform: argument: 'You selected the first item'.	2 to: max-1 do:[:i|		menu add: 'Item ',i			 target: CDialog 			action: #inform: 			argument: 'Item ', i,' was selected'].	menu add: 'Item ', max target: CDialog action: #inform: argument: 'The last item was selected'.	^menu! !!CMenuBar class methodsFor: 'examples' stamp: 'ar 3/13/2004 17:50'!example1	| menu |	menu := CMenuBar new.	menu addList: #(		('File' (			('New File' yourself)			('Open File' yourself)			('Save File' yourself)			-			('Print...' yourself)			-			('Quit' yourself)		))		('Edit' (			('Undo' yourself)			('Redo' yourself)			-			('Cut' yourself)			('Copy' yourself)			('Paste' yourself)		))		('Info' (			('About' yourself)		))	) target: self.	^menu! !!CTextEditor class methodsFor: 'class initialization' stamp: 'ar 3/12/2004 14:57'!initialize	"CTextEditorWidget initialize"	Smalltalk addToStartUpList: self.	self startUp.! !!CTextEditor class methodsFor: 'class initialization' stamp: 'ar 3/12/2004 14:57'!initializeStandardEditingKeys	"CTextEditorWidget initializeStandardEditingKeys"	StandardEditingKeys := CKeyboardDispatchTable new.	Smalltalk platformName = 'Win32' ifTrue:[		StandardEditingKeys addAll: self win32CursorKeys.		StandardEditingKeys addAll: self win32EditingKeys.		^self].	"Put all others here"	"Fall back to Mac by default"	StandardEditingKeys addAll: self macCursorKeys.	StandardEditingKeys addAll: self macEditingKeys.! !!CTextEditor class methodsFor: 'class initialization' stamp: 'ar 3/12/2004 14:55'!macCursorKeys	"The standard cursor keys"	^#(			((13) enter)			((28) moveCursorLeft)			((29) moveCursorRight)			((30) moveLineUp)			((31) moveLineDown)			((1) moveLineStart)			((4) moveLineEnd)			((shift 28) selectCursorLeft)			((shift 29) selectCursorRight)			((shift 30) selectLineUp)			((shift 31) selectLineDown)			((shift 1) selectLineStart)			((shift 4) selectLineEnd)			((cmd 28) moveWordLeft)			((cmd 29) moveWordRight)			"((cmd 30) scrollLineUp)			((cmd 31) scrollLineDown)"			((cmd 1) moveTextStart)			((cmd 4) moveTextEnd)			((cmd shift 28) selectWordLeft)			((cmd shift 29) selectWordRight)			"((cmd shift 30) ---)			((cmd shift 31) ---)"			((cmd shift 1) selectTextStart)			((cmd shift 4) selectTextEnd)	).! !!CTextEditor class methodsFor: 'class initialization' stamp: 'ar 3/12/2004 14:55'!macEditingKeys	"The standard editing keys"	^#(			((cmd a) selectAll)			((cmd f) findText)			((cmd g) findNext)			((cmd c) copySelection)			((cmd x) cutSelection)			((cmd v) pasteSelection)			((cmd s) save)			((cmd l) revert)			((cmd z) undo)			((cmd y) redo)	).! !!CTextEditor class methodsFor: 'class initialization' stamp: 'ar 3/12/2004 14:55'!startUp	self initializeStandardEditingKeys.! !!CTextEditor class methodsFor: 'class initialization' stamp: 'ar 3/12/2004 14:55'!win32CursorKeys	"The standard cursor keys"	^#(			((13) enter)			((28) moveCursorLeft)			((29) moveCursorRight)			((30) moveLineUp)			((31) moveLineDown)			((1) moveLineStart)			((4) moveLineEnd)			((shift 28) selectCursorLeft)			((shift 29) selectCursorRight)			((shift 30) selectLineUp)			((shift 31) selectLineDown)			((shift 1) selectLineStart)			((shift 4) selectLineEnd)			((ctrl 28) moveWordLeft)			((ctrl 29) moveWordRight)			"((ctrl 30) scrollLineUp)			((ctrl 31) scrollLineDown)"			((ctrl 1) moveTextStart)			((ctrl 4) moveTextEnd)			((ctrl shift 28) selectWordLeft)			((ctrl shift 29) selectWordRight)			"((ctrl shift 30) ---)			((ctrl shift 31) ---)"			((ctrl shift 1) selectTextStart)			((ctrl shift 4) selectTextEnd)	).! !!CTextEditor class methodsFor: 'class initialization' stamp: 'ar 3/12/2004 14:55'!win32EditingKeys	"The standard editing keys"	^#(			((ctrl A) selectAll)			((ctrl F) findText)			((ctrl G) findNext)			((ctrl H) replaceText)			((ctrl C) copySelection)			((ctrl X) cutSelection)			((ctrl V) pasteSelection)			((ctrl S) save)			((ctrl L) revert)			((ctrl Z) undo)			((ctrl Y) redo)	).! !!CTextEditor class methodsFor: 'accessing' stamp: 'ar 3/12/2004 14:56'!standardEditingKeys	^StandardEditingKeys! !!CTextEditor class methodsFor: 'accessing' stamp: 'ar 3/12/2004 14:56'!standardEditingKeys: aKeyboardDispatchTable	StandardEditingKeys := aKeyboardDispatchTable! !!CWidgetLibrary class methodsFor: 'accessing' stamp: 'ar 2/29/2004 18:33'!default	^Default ifNil:[Default := self new].! !!CWidgetLibrary class methodsFor: 'accessing' stamp: 'ar 2/29/2004 18:33'!default: aLibrary	Default := aLibrary.! !!CWidgetLibrary class methodsFor: 'accessing' stamp: 'ar 3/26/2004 22:44'!initialize	ImparaColors := false! !!CWorkspace class methodsFor: 'class initialization' stamp: 'ar 3/29/2004 16:53'!initialize	"CWorkspace initialize"	CProjectBuilder registerOpenCommand:		{ 'Workspace' . { self . #open }. 'A Programmer Workspace' }.! !!CWorldCostume class methodsFor: 'as yet unclassified' stamp: 'ar 12/8/2002 00:15'!initialize	Smalltalk addToStartUpList: self.	World ifNil:[		World := CWorldCostume new.		World runWorldCycle. "to initiate scheduler"	].! !!CWorldCostume class methodsFor: 'as yet unclassified' stamp: 'ar 3/18/2003 15:01'!startUp	World isPlayer ifTrue:[World invalidate].! !!Collection methodsFor: '*Tweak' stamp: 'ar 3/14/2004 16:25'!all	"Answer a new all matcher"	^CAllMatcher on: self! !!Collection methodsFor: '*Tweak' stamp: 'ar 3/14/2004 16:25'!any	"Answer a new any matcher"	^CAnyMatcher on: self! !!Collection methodsFor: '*Tweak' stamp: 'ar 9/17/2003 17:27'!serializeOn: aSerializer	^aSerializer writeCollection: self.! !!ContextPart methodsFor: '*Tweak' stamp: 'ar 2/8/2003 01:46'!printOn: aStream 	| selector class mclass rcvr |	self method == nil ifTrue: [^ super printOn: aStream].	rcvr := self receiver.	class := rcvr class.	selector _ class			selectorAtMethod: self method 			setClass: [:c | mclass _ c].	selector == #?		ifTrue: 			[aStream nextPut: $?; print: self method who.			^self].	class isUniClass 		ifTrue:[aStream nextPutAll: rcvr name asString]		ifFalse:[aStream nextPutAll: class name].	mclass == class 		ifFalse: 			[aStream nextPut: $(.			aStream nextPutAll: mclass name.			aStream nextPut: $)].	aStream nextPutAll: '>>'.	aStream nextPutAll: selector! !!ContextPart methodsFor: '*Tweak' stamp: 'ar 9/17/2003 17:30'!serializeOn: aSerializer	^aSerializer writeContext: self! !!Debugger methodsFor: '*Tweak' stamp: 'ar 8/13/2003 14:28'!openNotifierContents: msgString label: label	"Create and schedule a notifier view with the given label and message. A notifier view shows just the message or the first several lines of the stack, with a menu that allows the user to open a full debugger if so desired."	"NOTE: When this method returns, a new process has been scheduled to run the windows, and thus this notifier, but the previous active porcess has not been suspended.  The sender will do this."	| msg topView p |	interruptedProcess ifNotNil:[		interruptedProcess isScriptingProcess ifTrue:[			(self openTweakNotifier: label) ifTrue:[^self].		].	].	Sensor flushKeyboard.	savedCursor _ Sensor currentCursor.	Sensor currentCursor: Cursor normal.	(label beginsWith: 'Space is low')		ifTrue: [msg _ self lowSpaceChoices, (msgString ifNil: [''])]		ifFalse: [msg _ msgString].	isolationHead ifNotNil:		["We have already revoked the isolation layer -- now jump to the parent project."		msg _ self isolationRecoveryAdvice, msgString.		failedProject _ Project current.		isolationHead parent enterForEmergencyRecovery].	Smalltalk isMorphic ifTrue: [		self buildMorphicNotifierLabelled: label message: msg.		errorWasInUIProcess _ CurrentProjectRefactoring newProcessIfUI: interruptedProcess.		^self	].	Display fullScreen.	topView _ self 		buildMVCNotifierViewLabel: label 		message: thisContext sender sender shortStack 		minSize: 350@((14 * 5) + 16 + self optionalButtonHeight).	ScheduledControllers activeController		ifNil: [p _ Display boundingBox center]		ifNotNil: [p _ ScheduledControllers activeController view displayBox center].	topView controller openNoTerminateDisplayAt: (p max: (200@60)).	^ topView! !!Debugger methodsFor: '*Tweak' stamp: 'ar 3/25/2004 19:01'!openTweakNotifier: label	"See if there's a player in the receiver chain"	| ctx aPlayer |	ctx := contextStackTop.	[[ctx == nil] whileFalse:[		(ctx receiver isPlayer and:[ctx receiver world notNil]) ifTrue:[			aPlayer := ctx receiver.			ctx := nil.		] ifFalse:[ctx := ctx sender].	]] on: Error do:[:ex| ex return].	aPlayer ifNil:[^false].	^false! !!Dictionary methodsFor: '*Tweak' stamp: 'tk 7/13/2004 16:56'!atProperty: key put: newValue	"Set the value at key to be anObject.  If key is not found, create a	new entry for key and set is value to anObject. Answer the previous value."	| index assoc oldValue |	index _ self findElementOrNil: key.	assoc _ array at: index.	assoc ifNil: [		newValue == nil ifFalse: [			"If no previous value, and new one is nil, don't record"			self atNewIndex: index put: (Association key: key value: newValue)].		^nil].	oldValue := assoc value.	assoc value: newValue.	^oldValue! !!Dictionary methodsFor: '*Tweak' stamp: 'ar 3/15/2004 21:02'!removeBinding: key ifAbsent: aBlock	"Remove the binding with the given key if it exists"	| index assoc |	index _ self findElementOrNil: key.	assoc _ array at: index.	assoc == nil ifTrue: [^ aBlock value].	array at: index put: nil.	tally _ tally - 1.	self fixCollisionsFrom: index.	^assoc! !!Dictionary methodsFor: '*Tweak' stamp: 'ar 9/17/2003 17:31'!serializeOn: aSerializer	^aSerializer writeDictionary: self.! !!DisplayObject methodsFor: '*Tweak' stamp: 'ar 12/8/2003 22:50'!drawString: aString at: aPoint	^aString displayOn: self at: aPoint! !!DisplayScanner methodsFor: '*Tweak' stamp: 'ar 6/8/2003 22:14'!privatePort: aBitBlt	"Install the BitBlt to use"	bitBlt _ aBitBlt.! !!DisplayTransform methodsFor: '*Tweak' stamp: 'ar 12/8/2002 02:20'!invertPoint: aPoint	^self globalPointToLocal: aPoint! !!DisplayTransform methodsFor: '*Tweak' stamp: 'ar 12/8/2002 02:20'!invertRect: aRectangle	^self globalBoundsToLocal: aRectangle! !!DisplayTransform methodsFor: '*Tweak' stamp: 'ar 12/8/2002 02:20'!transformPoint: aPoint	^self localPointToGlobal: aPoint! !!DisplayTransform methodsFor: '*Tweak' stamp: 'ar 12/8/2002 02:20'!transformRect: aRectangle	^self localBoundsToGlobal: aRectangle! !!DisplayTransform methodsFor: '*Tweak' stamp: 'ar 12/8/2002 02:20'!transformedBy: aTransform	^self composedWithGlobal: aTransform! !!DropEvent methodsFor: '*Tweak' stamp: 'ar 12/8/2002 14:37'!transformBy: aMorphicTransform	"Transform the receiver into a local coordinate system."	position :=  position transformedBy: aMorphicTransform.! !!DropEvent methodsFor: '*Tweak' stamp: 'ar 12/8/2002 14:38'!translateBy: offset	position := position + offset.! !!DropEvent methodsFor: '*Tweak' stamp: 'ar 10/19/2003 15:27'!translatedBy: delta	"add delta to cursorPoint, and return the new event"	^self shallowCopy translateBy: delta! !!FileDirectory methodsFor: '*Tweak' stamp: 'ar 12/8/2002 03:02'!= aDirectory	^pathName equals: aDirectory pathName caseSensitive: (self isCaseSensitive | aDirectory isCaseSensitive)! !!FileDirectory methodsFor: '*Tweak' stamp: 'ar 3/13/2004 01:16'!asTreeItem	^CFileDirectoryTreeItem on: self! !!FileDirectory methodsFor: '*Tweak' stamp: 'ar 3/13/2004 02:16'!directories	^self directoryNames collect:[:each| self directoryNamed: each].! !!FileDirectory methodsFor: '*Tweak' stamp: 'ar 3/12/2004 19:26'!directoryContentsFor: fullPath do: aBlock	"Return a collection of directory entries for the files and directories in the directory with the given path. See primLookupEntryIn:index: for further details."	"FileDirectory default directoryContentsFor: ''"	| index done entryArray |	index _ 1.	done _ false.	[done] whileFalse: [		entryArray _ self primLookupEntryIn: fullPath index: index.		#badDirectoryPath = entryArray ifTrue: [			^(InvalidDirectoryError pathName: pathName) signal].		entryArray == nil			ifTrue: [done _ true]			ifFalse: [aBlock value: (DirectoryEntry fromArray: entryArray)].		index _ index + 1].! !!FileDirectory methodsFor: '*Tweak' stamp: 'ar 3/12/2004 22:12'!displayText	pathName isEmptyOrNil ifTrue:[^'[root]'].	^pathName! !!FileDirectory methodsFor: '*Tweak' stamp: 'ar 3/12/2004 19:28'!hasSubDirectories	"Answer whether this directory has any subdirectories"	self directoryContentsFor: pathName do:[:entry|		entry isDirectory ifTrue:[^true].	].	^false! !!FileDirectory methodsFor: '*Tweak' stamp: 'ar 12/8/2002 03:02'!hash	^pathName asLowercase hash! !!FileDirectory methodsFor: '*Tweak' stamp: 'ar 3/14/2004 04:33'!makeIconsInforming: bar	| ic |	bar value: pathName.	self entries do:[:each|		ic := (CDirectoryEntry new)			directory: self;			entry: each;		icon.		ic displayOn: Display at: 0@0 rule: Form over.	].	self directoryNames do:[:each|		(self directoryNamed: each) makeIconsInforming: bar.	].! !!FileDirectory methodsFor: '*Tweak' stamp: 'ar 3/27/2004 15:28'!mimeTypesFor: fileName	"Return a list of MIME types applicable to the receiver. This default implementation uses the file name extension to figure out what we're looking at but specific subclasses may use other means of figuring out what the type of some file is. Some systems like the macintosh use meta data on the file to indicate data type"	| idx ext dot |	ext _ ''.	dot _ self class extensionDelimiter.	idx _ fileName findLast: [:ch| ch = dot].	idx = 0 ifFalse:[ext _ fileName copyFrom: idx+1 to: fileName size].	^StandardMIMEMappings at: ext asLowercase ifAbsent:[nil]! !!DosFileDirectory methodsFor: '*Tweak' stamp: 'ar 3/27/2004 15:35'!fullNameFor: fileName	(self class isDrive: fileName) ifTrue:[^fileName].	^super fullNameFor: fileName! !!DosFileDirectory class methodsFor: '*Tweak' stamp: 'ar 3/27/2004 15:32'!splitName: fullName to: pathAndNameBlock	"Take the file name and convert it to the path name of a directory and a local file name within that directory. 	IMPORTANT NOTE: For 'drives', e.g., roots of the file system on Windows we treat the full name of that 'drive' as the local name rather than the path. This is because conceptually, all of these 'drives' hang off the virtual root of the entire Squeak file system, specified by FileDirectory root. In order to be consistent with, e.g., 		DosFileDirectory localNameFor: 'C:\Windows' -> 'Windows'		DosFileDirectory dirPathFor: 'C:\Windows' -> 'C:'	we expect the following to be true:		DosFileDirectory localNameFor: 'C:' -> 'C:'		DosFileDirectory dirPathFor: 'C:'. -> ''		DosFileDirectory localNameFor: '\\server' -> '\\server'.		DosFileDirectory dirPathFor: '\\server' -> ''.	so that in turn the following relations hold:		| fd |		fd := DosFileDirectory on: 'C:\Windows'.		fd containingDirectory includes: fd localName.		fd := DosFileDirectory on: 'C:'.		fd containingDirectory includes: fd localName.		fd := DosFileDirectory on: '\\server'.		fd containingDirectory includes: fd localName.	"	(self isDrive: fullName)		ifTrue: [^ pathAndNameBlock value:''  value: fullName].	^ super splitName: fullName to: pathAndNameBlock! !!FileList methodsFor: '*Tweak-Updates' stamp: 'ar 3/27/2004 21:50'!putUpdate: fullFileName	"Put this file out as an Update on the servers."	| names choice managers |	self canDiscardEdits ifFalse: [^ self changed: #flash].	managers := UpdateManager allRegisteredManagers.	managers size > 0 ifTrue:[		| servers index |		servers := ServerDirectory groupNames asSortedArray.		names := (managers collect:[:each| each packageVersion]), servers.		index := (PopUpMenu labelArray: names lines:{managers size}) startUp.		index = 0 ifTrue:[^self].		index <= managers size ifTrue:[			| file mgr |			file := directory oldFileNamed: fullFileName.			[mgr := managers at: index.			mgr publishUpdate: file] ensure:[file close].			^self volumeListIndex: volListIndex.		].		choice := names at: index.	] ifFalse:[		names _ ServerDirectory groupNames asSortedArray.		choice _ (SelectionMenu labelList: names selections: names) startUp.		choice == nil ifTrue: [^ self].	].	(ServerDirectory serverInGroupNamed: choice) putUpdate: 				(directory oldFileNamed: fullFileName).	self volumeListIndex: volListIndex.! !!FillInTheBlank class methodsFor: '*Tweak' stamp: 'ar 7/16/2003 18:35'!fillInTheBlankMorphClass	"By factoring out this class references, it becomes possible to discard 	morphic by simply removing this class.  All calls to this method needs	to be protected by 'Smalltalk isMorphic' tests."	^ActiveHand isPlayer ifTrue:[CDialog] ifFalse:[FillInTheBlankMorph]! !!Form methodsFor: '*Tweak' stamp: 'ar 12/8/2002 00:37'!actualScreenSize	"Polymorphic implementation for DisplayScreen"	^self extent! !!Form methodsFor: '*Tweak' stamp: 'ar 12/8/2002 01:55'!asForm	^self! !!Form methodsFor: '*Tweak' stamp: 'ar 3/23/2004 19:35'!asPlayer	^(CPlayer new)		graphicForm: self;		extent: self extent;		value: self; 		yourself! !!Form methodsFor: '*Tweak' stamp: 'ar 12/8/2002 00:49'!deferUpdates: aBool	"Polymorphic implementation for DisplayScreen"	^false! !!Form methodsFor: '*Tweak' stamp: 'ar 1/8/2003 19:31'!drawOn: aCanvas in: drawingBounds	drawingBounds extent = self extent ifTrue:[		self depth < 32			ifTrue:[aCanvas paintImage: self at: drawingBounds origin]			ifFalse:[aCanvas translucentImage: self at: drawingBounds origin].		^self].	^aCanvas 		warpImage: self		transform: (CMatrixTransform localRect: self boundingBox toGlobal: drawingBounds).! !!Form methodsFor: '*Tweak' stamp: 'bf 4/3/2004 00:31'!drawOn: aCanvas in: drawingBounds sourceRect: aRectangle	drawingBounds extent = aRectangle extent ifTrue:[		self depth < 32			ifTrue:[aCanvas paintImage: self at: drawingBounds origin sourceRect: aRectangle]			ifFalse:[aCanvas translucentImage: self at: drawingBounds origin sourceRect: aRectangle].		^self].	^aCanvas 		warpImage: self		transform: (CMatrixTransform localRect: aRectangle toGlobal: drawingBounds)		sourceRect: aRectangle.! !!Form methodsFor: '*Tweak' stamp: 'ar 12/12/2003 18:24'!fixAlpha	"Fix the alpha channel if the receiver is 32bit"	| bb |	self depth = 32 ifFalse:[^self].	bb := BitBlt toForm: self.	bb combinationRule: 40 "fixAlpha:with:".	bb copyBits.! !!Form methodsFor: '*Tweak' stamp: 'ar 12/8/2002 00:49'!forceDamageToScreen: rectList	"Polymorphic implementation for DisplayScreen"! !!Form methodsFor: '*Tweak' stamp: 'ar 12/8/2002 00:50'!forceDisplayUpdate	"Polymorphic implementation for DisplayScreen"! !!Form methodsFor: '*Tweak' stamp: 'ar 12/8/2002 00:50'!forceToScreen	"Polymorphic implementation for DisplayScreen"! !!Form methodsFor: '*Tweak' stamp: 'ar 12/8/2002 00:50'!forceToScreen: aRectangle	"Polymorphic implementation for DisplayScreen"! !!Form methodsFor: '*Tweak' stamp: 'ar 12/8/2002 01:31'!isCursor	^false! !!Form methodsFor: '*Tweak' stamp: 'ar 6/24/2003 14:53'!isOpaque	"Answer whether this form contains any transparent or translucent colors"	self depth < 32 ifTrue:[		"Depth < 32 means only zero pixels are mapped to transparent. Count those."		^self tallyPixelValues first = 0	].	"Depth = 32 means we need to check for alpha.	ARRRGHHH!!!!!! I knew it!! Years back I knew that aliasing BitBlt's tallyMap with its colorMap can't be a good idea. Now it's clear why - you can't count pixels *after* they've been transferred. Ho hum."	^false! !!Form methodsFor: '*Tweak' stamp: 'ar 9/23/2003 17:40'!serializeOn: aSerializer	^aSerializer writeForm: self! !!Form methodsFor: '*Tweak' stamp: 'ar 12/8/2002 18:41'!supportedDisplayDepths	"Polymorphic implementation for DisplayScreen"	^#(1 2 4 8 16 32)! !!Form methodsFor: '*Tweak' stamp: 'ar 12/8/2002 18:41'!supportsDisplayDepth: pixelDepth	"Polymorphic implementation for DisplayScreen"	^true! !!Form methodsFor: '*Tweak-Resources' stamp: 'ar 12/2/2003 23:47'!readResourceContentsFrom: aStream	"Store a resource representation of the receiver on aStream.	Must be specific to the receiver so that no code is filed out."	| bitsSize |	(aStream next: 4) asString = self resourceTag 		ifFalse:[	^self error:'wrong type'].	width = (aStream nextNumber: 4)		ifFalse:[	^self error:'wrong width'].	height = (aStream nextNumber: 4)		ifFalse:[	^self error:'wrong height'].	depth = (aStream nextNumber: 4)		ifFalse:[	^self error:'wrong depth'].	bitsSize := aStream nextNumber: 4.	bitsSize = 0 ifFalse:["hibernated bits"		bits _ aStream next: bitsSize.		^self].	self bitsSize = (aStream nextNumber: 4)		ifFalse:[	^self error:'wrong bit size'].	bits _ Bitmap new: self bitsSize.	aStream nextWordsInto: bits.! !!Form methodsFor: '*Tweak-Resources' stamp: 'ar 12/2/2003 23:46'!storeResourceContentsOn: aStream	"Store a resource representation of the receiver on aStream.	Must be specific to the receiver so that no code is filed out."	self hibernate.	aStream nextPutAll: self resourceTag asByteArray. "tag"	aStream nextNumber: 4 put: width.	aStream nextNumber: 4 put: height.	aStream nextNumber: 4 put: depth.	(bits isMemberOf: ByteArray) ifFalse:[		"must store bitmap"		aStream nextNumber: 4 put: 0. "tag"		aStream nextNumber: 4 put: bits size.		aStream nextWordsPutAll: bits.	] ifTrue:[		aStream nextNumber: 4 put: bits size.		aStream nextPutAll: bits.	].! !!ColorForm methodsFor: '*Tweak-Resources' stamp: 'ar 12/2/2003 23:44'!readResourceContentsFrom: aStream	| cc |	super readResourceContentsFrom: aStream.	cc := aStream nextNumber: 4.	colors := ColorArray new: cc.	aStream readWordsInto: colors.! !!ColorForm methodsFor: '*Tweak-Resources' stamp: 'ar 12/2/2003 23:41'!storeResourceContentsOn: aStream	super storeResourceContentsOn: aStream.	aStream nextNumber: 4 put: colors size.	aStream nextWordsPutAll: colors asColorArray.! !!ColorForm methodsFor: '*Tweak' stamp: 'ar 3/25/2004 19:33'!isOpaque	^colors allSatisfy:[:each| each isOpaque].! !!Cursor methodsFor: '*Tweak' stamp: 'ar 12/8/2002 01:54'!asForm	| form |	form := Form extent: self extent depth: 8.	form fillShape: self fillColor: Color black at: offset negated.	^ form offset: offset! !!Cursor methodsFor: '*Tweak' stamp: 'ar 12/8/2002 01:31'!isCursor	^true! !!Cursor methodsFor: '*Tweak' stamp: 'ar 9/24/2003 11:34'!serializeOn: aSerializer	| globalName |	Cursor classPool keysAndValuesDo:[:key :value|		(self == value and:[key ~~ #CurrentCursor and:[key endsWith: 'Cursor']]) ifTrue:[			globalName := (key copyFrom: 1 to: key size - 6) withFirstCharacterDownshifted.			globalName = 'xeq' ifTrue:[globalName := 'execute'].			^aSerializer writeGlobal: #Cursor constructor: globalName		].	].	^super serializeOn: aSerializer! !!Cursor class methodsFor: '*Tweak' stamp: 'ar 3/13/2004 21:30'!drag	^CCursorLibrary dragCursor! !!Cursor class methodsFor: '*Tweak' stamp: 'ar 3/13/2004 21:30'!text	"Cursor text showWhile: [Sensor waitButton]" 	^CCursorLibrary textCursor! !!CursorWithMask methodsFor: '*Tweak' stamp: 'ar 12/8/2002 01:54'!asForm	| form |	form := Form extent: self extent depth: 8.	form fillShape: maskForm fillColor: Color white.	form fillShape: self fillColor: Color black at: offset negated.	^ form offset: self offset! !!FormCanvas methodsFor: '*Tweak' stamp: 'ar 6/8/2003 23:01'!drawString: aString from: firstIndex to: lastIndex in: bounds font: fontOrNil color: c kern: kernDelta	| font portRect |	port colorMap: nil.	portRect _ port clipRect.	port clipByX1: bounds left + origin x 		y1: bounds top + origin y 		x2: bounds right + origin x 		y2: bounds bottom + origin y.	font _ fontOrNil ifNil: [TextStyle defaultFont].	port combinationRule: Form paint.	font installOn: port		foregroundColor: (self shadowColor ifNil:[c]) 		backgroundColor: Color transparent.	font displayString: aString asString on: port 		from: firstIndex to: lastIndex at: (bounds topLeft + origin) kern: kernDelta.	port clipRect: portRect.! !!FormCanvas methodsFor: '*Tweak' stamp: 'bf 4/3/2004 02:26'!privateWarp: aForm transform: aTransform at: extraOffset sourceRect: sourceRect cellSize: cellSize	"Warp the given form using the appropriate transform and offset."	| globalRect sourceQuad warp tfm |	tfm _ aTransform.	globalRect _ tfm localBoundsToGlobal: sourceRect.	sourceQuad _ tfm sourceQuadFor: globalRect.  "why not just (sourceRect innerCorners)? -bf"	extraOffset ifNotNil:[globalRect _ globalRect translateBy: extraOffset].     warp _ (WarpBlt current toForm: port destForm)                combinationRule: Form paint;                sourceQuad: sourceQuad destRect: globalRect;                clipRect: port clipRect.	warp cellSize: cellSize.	warp sourceForm: aForm.	cellSize = 1 ifTrue:[		warp colorMap: (aForm colormapIfNeededFor: warp destForm).	].	warp warpBits! !!CTransformCanvas methodsFor: 'drawing-shapes' stamp: 'ar 6/9/2003 03:36'!drawCompressedShape: aShape	^self asBalloonCanvas drawCompressedShape: aShape! !!CTransformCanvas methodsFor: 'testing' stamp: 'ar 12/8/2002 03:33'!isVisible: aRectangle	"Optimization"	(aRectangle right) < clipRect left	ifTrue: [^ false].	(aRectangle left) > clipRect right	ifTrue: [^ false].	(aRectangle bottom) < clipRect top	ifTrue: [^ false].	(aRectangle top) > clipRect bottom	ifTrue: [^ false].	^ true! !!CTransformCanvas methodsFor: 'drawing-round rects' stamp: 'ar 6/8/2003 19:07'!fillRoundRect: aRectangle radius: cornerRadius fill: fillStyle border: borderStyle	"Draw a rounded rectangle"	self shadowColor ifNotNil:[		^self fillRoundRect: aRectangle radius: cornerRadius fillStyle: shadowColor.	].	"see if the round rect is degenerate"	cornerRadius asPoint <= (0@0) 		ifTrue:[^self fillRectangle: aRectangle fill: fillStyle border: borderStyle].	cornerRadius * 2 >= aRectangle width 		ifTrue:[^self fillOval: aRectangle fill: fillStyle border: borderStyle].	"Okay it's a rounded rectangle"	fillStyle isTransparent ifFalse:["fill interior"		| innerRect radius bw |		innerRect := aRectangle.		radius := cornerRadius.		bw := borderStyle width.		bw isZero ifFalse:[			innerRect := innerRect insetBy: bw.			radius := radius - bw.		].		self fillRoundRect: innerRect radius: radius fillStyle: fillStyle.	].	borderStyle frameRoundRect: aRectangle radius: cornerRadius on: self.! !!CTransformCanvas methodsFor: 'drawing-round rects' stamp: 'ar 6/8/2003 19:07'!fillRoundRect: aRectangle radius: radius fillStyle: fillStyle	fillStyle isTransparent ifTrue:[^self].	radius asPoint <= (0@0) 		ifTrue:[^self fillRectangle: aRectangle fillStyle: fillStyle].	(radius * 2) asPoint >= aRectangle extent 		ifTrue:[^self fillOval: aRectangle fillStyle: fillStyle].	fillStyle isSolidFill 		ifFalse:[^self balloonFillRoundRect: aRectangle radius: radius fillStyle: fillStyle].	self setFillColor: (shadowColor ifNil:[fillStyle asColor]).	^port fillRoundRect: (aRectangle translateBy: origin) truncated radius: radius.! !!CTransformCanvas methodsFor: 'drawing-round rects' stamp: 'ar 6/8/2003 19:05'!frameRoundRect: aRectangle radius: radius width: borderWidth color: borderColor	"Frame a rounded rectangle with the given attributes."	| innerRect |	(borderWidth isZero or:[borderColor isTransparent])		ifTrue:[^self].	radius asPoint <= (0@0) 		ifTrue:[^self frameRectangle: aRectangle width: borderWidth color: borderColor].	(radius * 2) asPoint >= aRectangle extent 		ifTrue:[^self frameOval: aRectangle width: borderWidth color: borderColor].	"decompose inner rectangle into bezier shape"	innerRect := aRectangle insetBy: borderWidth.	innerRect area <= 0 		ifTrue:[^self fillRoundRect: aRectangle radius: radius fillStyle: borderColor].	self setFillColor: borderColor.	port 		frameRoundRect: (aRectangle translateBy: origin) truncated 		radius: radius truncated 		borderWidth: borderWidth truncated.! !!CTransformCanvas methodsFor: 'drawing-round rects' stamp: 'ar 6/8/2003 17:14'!makeRoundRectShape: aRectangle radius: radius	"decompose a rounded rectangle into bezier form"	| ovalDiameter rectExtent segments points endPoint seg idx offset rectOffset |	ovalDiameter := (radius * 2) asPoint min: aRectangle extent.	(ovalDiameter x <= 0 or:[ovalDiameter y <= 0]) ifTrue:[		"degenerates into rectangle - just hand back four lines"		| topLeft topRight bottomLeft bottomRight |		topLeft := aRectangle topLeft.		topRight := aRectangle topRight.		bottomLeft := aRectangle bottomLeft.		bottomRight := aRectangle bottomRight.		points := Array new: 4*3.		points at: 1 put: topLeft.		points at: 2 put: topLeft.		points at: 3 put: topRight.		points at: 4 put: topRight.		points at: 5 put: topRight.		points at: 6 put: bottomRight.		points at: 7 put: bottomRight.		points at: 8 put: bottomRight.		points at: 9 put: bottomLeft.		points at: 10 put: bottomLeft.		points at: 11 put: bottomLeft.		points at: 12 put: topLeft.		^points	].	rectExtent := aRectangle extent - ovalDiameter.	rectOffset := aRectangle origin.	segments := Bezier2Segment makeEllipseSegments: (0@0 extent: ovalDiameter).	"patch up the segments to include lines connecting the oval parts.	we need: 8*3 points for the oval parts + 4*3 points for the connecting lines"	points := Array new: 12*3.	idx := 0.	endPoint := segments last end + rectOffset.	1 to: 8 by: 2 do:[:i|		i = 1 ifTrue:[offset := rectOffset + (rectExtent x @ 0)].		i = 3 ifTrue:[offset := rectOffset + rectExtent].		i = 5 ifTrue:[offset := rectOffset + (0 @ rectExtent y)].		i = 7 ifTrue:[offset := rectOffset].		seg := segments at: i.		"insert a line segment for the horizontal part of the round rect"		points at: (idx := idx+1) put: endPoint.		points at: (idx := idx+1) put: endPoint.		points at: (idx := idx+1) put: seg start + offset.		"now the first half-arc"		points at: (idx := idx+1) put: seg start + offset.		points at: (idx := idx+1) put: seg via + offset.		points at: (idx := idx+1) put: seg end + offset.		"the second half-arc"		seg := segments at: i+1.		points at: (idx := idx+1) put: seg start + offset.		points at: (idx := idx+1) put: seg via + offset.		points at: (idx := idx+1) put: seg end + offset.		endPoint := seg end + offset.	].	^points! !!CTransformCanvas methodsFor: 'private-state' stamp: 'ar 6/9/2003 00:09'!flushWarp	"Warp the receiver onto aCanvas"	| aCanvas |	warpTransform ifNil:[^self].	aCanvas _ backup.	maskCanvas ifNotNil:[		"Mask out the clipping region if non-rectangular"		maskCanvas finish.		(BitBlt toForm: form)			sourceForm: maskCanvas form;			combinationRule: Form and;			copyBits].	aCanvas 		privateWarp: form 		transform: warpTransform 		at: 0@0 		sourceRect: form boundingBox 		cellSize: warpTransform warpCellSize.! !!CTransformCanvas methodsFor: 'private-state' stamp: 'ar 6/8/2003 19:43'!installWarp: localRect	| warpForm cc |	forceWarp ifFalse:[^self].	"TODO: Clip localRect against re-transformed portRect to minimize space usage"	warpForm _ Form extent: localRect extent depth: 32.	warpTransform _ transform composedWithLocal: (COffsetTransform withOffset: localRect origin).	"TODO: #setForm: needs to initialize portRect based on clipRect/transform"	cc := shadowColor.	self setForm: warpForm.	shadowColor := cc.	self translateBy: localRect origin negated.	clipRect _ localRect.! !!CTransformCanvas methodsFor: 'private-state' stamp: 'ar 6/8/2003 20:06'!resetGrafPort	"Private!! Create a new grafPort for a new copy."	port _ self portClass toForm: form.	port clipRect: (transform localBoundsToGlobal: clipRect).! !!CTransformCanvas methodsFor: 'private-state' stamp: 'ar 12/9/2003 00:31'!restoreFrom: backup	"Restore the receiver from the given canvas"	self flushWarp. "flush me so pending changes take effect"	"This should be a primitive!!"	self copyFrom: backup! !!CTransformCanvas methodsFor: 'private-state' stamp: 'ar 12/7/2002 22:15'!setOrigin: aPoint clipRect: aRectangle	origin _ aPoint.	transform isIdentity		ifTrue:[transform _ COffsetTransform withOffset: aPoint]		ifFalse:[transform offset: aPoint].	clipRect _ aRectangle translateBy: aPoint negated.	port clipRect: (transform localBoundsToGlobal: clipRect).! !!CTransformCanvas methodsFor: 'push/pop' stamp: 'ar 12/9/2003 17:53'!asBackup! !!CTransformCanvas methodsFor: 'push/pop' stamp: 'ar 12/9/2003 00:33'!newBackup	"Create a backup of the receiver"	^self copy asBackup! !!CTransformCanvas methodsFor: 'push/pop' stamp: 'ar 12/9/2003 00:31'!popState	self restoreFrom: backup.! !!CTransformCanvas methodsFor: 'push/pop' stamp: 'ar 12/9/2003 17:53'!pushState	backup _ self newBackup.	warpTransform _ nil.! !!CTransformCanvas methodsFor: 'drawing-rectangles'!fillOval: aRectangle fill: aFill border: aBorder	"@@@@: Fix this. Remove the old interface. :@@@@"	^self fillOval: aRectangle fillStyle: aFill borderStyle: aBorder! !!CTransformCanvas methodsFor: 'drawing-rectangles' stamp: 'ar 6/8/2003 20:34'!fillRectangle: r color: c	transform isPureTranslation ifTrue:[		^super fillRectangle: r color: c	].	self balloonFillRectangle: r fillStyle: (shadowColor ifNil:[c]).! !!CTransformCanvas methodsFor: 'drawing-rectangles'!fillRectangle: aRectangle fill: aFill border: aBorder	"@@@@: Fix this. Remove the old interface. :@@@@"	^self fillRectangle: aRectangle fillStyle: aFill borderStyle: aBorder! !!CTransformCanvas methodsFor: 'drawing-rectangles' stamp: 'ar 6/8/2003 20:31'!fillRectangle: aRectangle fillStyle: aFillStyle	transform isPureTranslation ifTrue:[		^super fillRectangle: aRectangle fillStyle: aFillStyle	].	self balloonFillRectangle: aRectangle fillStyle: (shadowColor ifNil:[aFillStyle]).! !!CTransformCanvas methodsFor: 'drawing-rectangles' stamp: 'ar 6/8/2003 20:49'!frameAndFillRectangle: r fillColor: fillColor borderWidth: borderWidth topLeftColor: topLeftColor bottomRightColor: bottomRightColor	| inner bc |	transform isPureTranslation ifTrue:[		^super frameAndFillRectangle: r fillColor: fillColor borderWidth: borderWidth topLeftColor: topLeftColor bottomRightColor: bottomRightColor.	].	inner := r insetBy: borderWidth.	bc := self asBalloonCanvas.	bc deferred: true.	fillColor isTransparent ifFalse:[		bc drawRectangle: inner color: fillColor borderWidth: 0 borderColor: nil.	].	(borderWidth > 0 and:[topLeftColor isTransparent not]) ifTrue:[			bc drawPolygon: {			r topLeft.			r topRight.			inner topRight.			inner topLeft.			inner bottomLeft.			r bottomLeft.		} color: topLeftColor borderWidth: 0 borderColor: nil.	].	(borderWidth > 0 and:[bottomRightColor isTransparent not]) ifTrue:[			bc drawPolygon: {			r topRight.			r bottomRight.			r bottomLeft.			inner bottomLeft.			inner bottomRight.			inner topRight.		} color: bottomRightColor borderWidth: 0 borderColor: nil.	].	bc flush.! !!CTransformCanvas methodsFor: 'drawing-images' stamp: 'ar 12/7/2002 22:20'!balloonWarp: aForm transform: aTransform at: extraOffset sourceRect: sourceRect	"Warp the given using the appropriate transform and offset."	| engine fill globalRect tfm |	"a workaround for balloon sometimes not rounding appropriately"	globalRect _ aTransform localBoundsToGlobal: sourceRect.	extraOffset ifNotNil:[globalRect _ globalRect translateBy: extraOffset].	port clipBy: globalRect.	engine _ BalloonEngine new.	engine aaLevel: 2.	engine bitBlt: port.	engine destOffset: extraOffset.	engine deferred: false.	fill := CBitmapFill form: aForm.	fill tileFlag: false.	fill origin: 0@0.	fill direction: aForm width@0.	fill normal: 0@aForm height.	"another weirdo offset problem..."	tfm := aTransform clone.	tfm a13: tfm a13 - 0.2.	tfm a23: tfm a23 - 0.2.	engine		drawRectangle: sourceRect		fill: fill		borderWidth: 0		borderColor: nil		transform: tfm.	engine flush.	port clipRect: (transform localBoundsToGlobal: clipRect).! !!CTransformCanvas methodsFor: 'drawing-images' stamp: 'ar 6/8/2003 23:51'!image: aForm at: aPoint sourceRect: sourceRect rule: rule	"Draw the portion of the given Form defined by sourceRect at the given point using the given BitBlt combination rule."	"Flood this canvas with aColor wherever stencilForm has non-zero pixels"	| fill rect |	transform isPureTranslation ifTrue:[		^super image: aForm at: aPoint sourceRect: sourceRect rule: rule	].	fill := CBitmapFill new.	fill form: aForm.	fill direction: sourceRect width @ 0.	fill normal: 0 @ sourceRect height.	fill origin: aPoint - sourceRect origin.	rect := (aPoint extent: sourceRect extent) intersect: clipRect.	(self asBalloonCanvas)		drawRectangle: rect		color: fill		borderWidth: 0		borderColor: nil.! !!CTransformCanvas methodsFor: 'drawing-images' stamp: 'ar 6/9/2003 00:11'!privateWarp: aForm transform: aTransform at: extraOffset sourceRect: sourceRect cellSize: cellSize	"Warp the given using the appropriate transform and offset."false ifTrue:[	^self balloonWarp: aForm transform: aTransform at: extraOffset sourceRect: sourceRect] ifFalse:[	^super privateWarp: aForm transform: aTransform at: extraOffset sourceRect: sourceRect cellSize: cellSize].! !!CTransformCanvas methodsFor: 'drawing-images' stamp: 'ar 6/8/2003 20:32'!stencil: aForm at: aPoint sourceRect: sourceRect color: aColor	"Flood this canvas with aColor wherever stencilForm has non-zero pixels"	| stencilForm stencilColors fill rect |	transform isPureTranslation ifTrue:[		^super stencil: aForm at: aPoint sourceRect: sourceRect color: aColor.	].	stencilForm := aForm.	stencilForm depth > 8 "ugh, oh this is going to be slowish as hell"		ifTrue:[stencilForm := stencilForm asFormOfDepth: 8].	"share bits"	stencilForm := ColorForm 		extent: stencilForm extent 		depth: stencilForm depth 		bits: stencilForm bits.	stencilColors := Array new: 1 << stencilForm depth withAll: aColor.	stencilColors at: 1 put: Color transparent.	stencilForm colors: stencilColors.	fill := CBitmapFill new.	fill form: stencilForm.	fill direction: sourceRect width @ 0.	fill normal: 0 @ sourceRect height.	fill origin: sourceRect origin negated.	rect := (aPoint extent: sourceRect extent) intersect: clipRect.	(self asBalloonCanvas)		drawRectangle: rect		color: fill		borderWidth: 0		borderColor: nil.! !!CTransformCanvas methodsFor: 'drawing-images'!warpImage: aForm transform: aTransform at: extraOffset sourceRect: sourceRect cellSize: cellSize	"Warp the given using the appropriate transform and offset."	| tfm |	tfm _ transform composedWithLocal: aTransform.	^self privateWarp: aForm transform: tfm at: extraOffset sourceRect: sourceRect cellSize: cellSize! !!CTransformCanvas methodsFor: 'transforming'!copyFrom: anObject	1 to: self class instSize do:[:i|		self instVarAt: i put: (anObject instVarAt: i).	].! !!CTransformCanvas methodsFor: 'transforming'!preserveStateDuring: aBlock	self pushState.	aBlock value: self.	self popState.! !!CTransformCanvas methodsFor: 'transforming' stamp: 'ar 1/6/2004 20:53'!transform	^transform! !!CTransformCanvas methodsFor: 'transforming' stamp: 'ar 12/8/2003 22:47'!transform: aTransform	"Transform the receiver by the given transform.	Do *NOT* establish warp."	transform _ aTransform.	origin _ transform offset.	"Update clipRect based on port's information; 	if set afterwards we may get something a little more accurate."	clipRect _ transform globalBoundsToLocal: port clipRect! !!CTransformCanvas methodsFor: 'transforming'!transformBy: aTransform	"Transform the receiver by the given transform.	Do *NOT* establish warp."	transform _ transform composedWithLocal: aTransform.	origin _ transform offset.	"Update clipRect based on port's information; 	if set afterwards we may get something a little more accurate."	clipRect _ transform globalBoundsToLocal: port clipRect! !!CTransformCanvas methodsFor: 'transforming'!transformBy: aTransform clippingTo: localRect during: aBlock	"Transform the receiver by the given transformation and apply the given clipping rectangle.	If non-trivial, the transformation will establish a new warp."	self pushState.		"Install the transformation"		self transformBy: aTransform.		"Install a new warp if the transform affects the mapping of localRect"		(transform isNoTransformWithin: localRect)			ifFalse:[self installWarp: localRect].		"Install transform and clip rect"		self clipBy: localRect.		aBlock value: self.	self popState.! !!CTransformCanvas methodsFor: 'transforming'!transformBy: aTransform during: aBlock	self pushState.	[		self transformBy: aTransform.		aBlock value: self.	] ensure:[self popState].! !!CTransformCanvas methodsFor: 'transforming' stamp: 'ar 12/7/2002 22:15'!translateBy: offset	offset isZero ifFalse:[self transformBy: (COffsetTransform withOffset: offset)].! !!CTransformCanvas methodsFor: 'transforming'!translateBy: delta during: aBlock	self pushState.	self translateBy: delta.	aBlock value: self.	self popState.! !!CTransformCanvas methodsFor: 'drawing-lines' stamp: 'ar 3/27/2003 18:45'!drawLineFrom: lastPt to: nextPt brush: lineBrush	^self line: lastPt to: nextPt brushForm: lineBrush! !!CTransformCanvas methodsFor: 'drawing-lines' stamp: 'ar 3/27/2003 18:30'!drawLineFrom: lastPt to: nextPt width: lineWidth color: lineColor	^self line: lastPt to: nextPt width: lineWidth color: lineColor! !!CTransformCanvas methodsFor: 'drawing-text' stamp: 'ar 2/12/2004 16:05'!displayString: aString from: startIndex to: stopIndex at: aPoint font: aFont kern: kernDelta	| stringWidth stringHeight box tmpForm |	transform isPureTranslation ifTrue:[		fontChanged ifTrue:[			"set paint color again in case we had intermediate drawing operations"			self setPaintColor: fontColor. 			font installOn: port foregroundColor: fontColor backgroundColor: Color transparent.			fontChanged := false.		].		font displayString: aString 			on: port 			from: startIndex 			to: stopIndex 			at: aPoint + origin			kern: kernDelta.		^self].	"draw string onto temporary form"	stringWidth := aFont widthOfString: aString from: startIndex to: stopIndex.	stringHeight := aFont height.	box := aPoint extent: (stringWidth @ stringHeight).	box := box intersect: clipRect.	tmpForm := ColorForm extent: box extent depth: 1.	tmpForm colors: (Array with: Color transparent with: fontColor).	tmpForm getCanvas 		drawString: aString 		from: startIndex 		to: stopIndex 		in: (aPoint - box origin extent: box extent) 		font: font 		color: Color black		kern: kernDelta.	"and blast out image"	^self paintImage: tmpForm at: box origin! !!CTransformCanvas methodsFor: 'drawing-text' stamp: 'ar 2/12/2004 16:06'!displayString: aString from: startIndex to: stopIndex at: aPoint strikeFont: aFont kern: kernDelta	^self displayString: aString from: startIndex to: stopIndex at: aPoint font: aFont kern: kernDelta! !!CTransformCanvas methodsFor: 'drawing-text' stamp: 'ar 2/12/2004 16:05'!displayString: aString from: startIndex to: stopIndex at: aPoint ttcFont: aFont kern: kernDelta	^self displayString: aString from: startIndex to: stopIndex at: aPoint font: aFont kern: kernDelta! !!CTransformCanvas methodsFor: 'drawing-text' stamp: 'ar 6/8/2003 23:01'!drawString: aString from: firstIndex to: lastIndex in: bounds font: fontOrNil color: c kern: kernDelta	transform isPureTranslation ifTrue:[		^super 			drawString: aString 			from: firstIndex 			to: lastIndex 			in: bounds 			font: fontOrNil 			color: c			kern: kernDelta	].	self pushState.	self clipBy: bounds.	font := fontOrNil ifNil:[TextStyle defaultFont].	font installOn: self 		foregroundColor: (shadowColor ifNil:[c]) 		backgroundColor: Color transparent.	font displayString: aString 		on: self 		from: firstIndex 		to: lastIndex 		at: bounds topLeft 		kern: kernDelta.	self popState.! !!CTransformCanvas methodsFor: 'drawing-text' stamp: 'ar 6/8/2003 22:17'!installStrikeFont: aFont foregroundColor: fgColor backgroundColor: ignored	font := aFont.	fontColor := fgColor.	fontChanged := true.! !!CTransformCanvas methodsFor: 'drawing-text' stamp: 'ar 2/12/2004 15:58'!installTTCFont: aFont foregroundColor: fgColor backgroundColor: ignored	font := aFont.	fontColor := fgColor.	fontChanged := true.! !!CTransformCanvas methodsFor: 'drawing-text' stamp: 'ar 6/8/2003 23:06'!paragraph: para bounds: bounds color: c	| scanner |	self pushState.	self clipBy: bounds.	self setPaintColor: c.	scanner := DisplayScanner new text: para text textStyle: para textStyle		foreground: (shadowColor ifNil:[c]) background: Color transparent		fillBlt: nil ignoreColorChanges: shadowColor notNil.	scanner privatePort: self.	para displayOn: self using: scanner at: bounds topLeft.	self popState.! !!CTransformCanvas methodsFor: 'clipping' stamp: 'ar 6/8/2003 20:06'!clipBy: aClipShape	clipRect _ clipRect intersect: aClipShape asRectangle.	port clipBy: (transform localBoundsToGlobal: clipRect).	(aClipShape isRectangle and:[transform isNoTransformWithin: clipRect]) ifTrue:[^self].	"Use a mask for clipping"	"TODO: Need to initialize maskCanvas if not initialized"	"TODO: Need maskCanvas to provide Form>>bitAnd!!"	"aClipShape drawOn: maskCanvas."	"TODO: Need to install a different form/warp in order to get masking right"! !!CTransformCanvas methodsFor: 'clipping'!clipBy: aClipShape during: aBlock	self pushState.	self clipBy: aClipShape.	aBlock value: self.	self popState.! !!CTransformCanvas methodsFor: 'initialize' stamp: 'ar 6/9/2003 00:01'!reset	super reset.	transform _ CIdentityTransform new.	forceWarp := true.! !!CTransformCanvas methodsFor: 'initialize' stamp: 'ar 12/7/2002 22:13'!setForm: aForm	transform ifNil:[transform _ CIdentityTransform new].	super setForm: aForm.	port clipRect: (transform localBoundsToGlobal: clipRect).! !!CTransformCanvas methodsFor: 'accessing'!asTransformCanvas	^self! !!CTransformCanvas methodsFor: 'accessing'!clipRect	^clipRect! !!CTransformCanvas methodsFor: 'rounding' stamp: 'ar 3/18/2003 23:51'!roundCornersOf: aMorph in: bounds during: aBlock	aMorph wantsRoundedCorners ifFalse:[^aBlock value].	(self seesRoundedCornerOf: bounds)		ifFalse: ["Don't bother with corner logic if the region is inside them"				^ aBlock value].	CCornerRounder roundCornersOf: aMorph on: self in: bounds		displayBlock: aBlock		borderWidth: aMorph borderWidthForRounding		corners: aMorph roundedCorners! !!CTransformCanvas methodsFor: 'converting' stamp: 'ar 6/8/2003 21:19'!asBalloonCanvas	^(BalloonCanvas on: form) 		setOrigin: 0@0 clipRect: port clipRect;		transformBy: transform asMatrixTransform2x3;		aaLevel: 4;		yourself! !!CTransformCanvas methodsFor: 'TODO-IGraphicsDevice' stamp: 'ar 12/9/2003 00:37'!asCanvas	^self! !!CTransformCanvas methodsFor: 'TODO-IGraphicsDevice' stamp: 'ar 12/9/2003 00:36'!display: anObject	"Display the given object"	anObject displayFrom: self.! !!CTransformCanvas methodsFor: 'caching' stamp: 'ar 3/18/2003 23:51'!cache: aRectangle using: aCache during: aBlock	aCache ifNil:[^aBlock value: self].	^aCache drawCached: aBlock on: self in: aRectangle! !!GrafPort methodsFor: '*Tweak' stamp: 'ar 12/1/2003 12:53'!image: aForm at: aPoint sourceRect: sourceRect rule: rule	"Draw the portion of the given Form defined by sourceRect at the given point using the given BitBlt combination rule."	self sourceForm: aForm.	combinationRule _ rule.	self sourceRect: sourceRect.	self destOrigin: aPoint.	self copyBits! !!GrafPort methodsFor: '*Tweak' stamp: 'ar 12/1/2003 12:53'!image: aForm at: aPoint sourceRect: sourceRect rule: rule alpha: sourceAlpha	"Draw the portion of the given Form defined by sourceRect at the given point using the given BitBlt combination rule."	self sourceForm: aForm.	combinationRule _ rule.	self sourceRect: sourceRect.	self destOrigin: aPoint.	self copyBitsTranslucent: (alpha _ (sourceAlpha * 255) truncated min: 255 max: 0).! !!HaloFont class methodsFor: 'class initialization' stamp: 'ar 2/9/2003 16:35'!initFont	"HaloFont initFont"	| form map font style files |	files := Dictionary new.	self glyphs do:[:spec|		files at: spec first put: spec last base64Decoded asByteArray.	].	map := Dictionary new.	#(		( 'c'	'collapse.gif')		( 'd'   'drag.gif')		( 'D'	'debug.gif')		( 'g'   'grab.gif')		( 'h'   'help.gif')		( 'm'   'menu.gif')		( 'p'   'paint.gif')		( 'P'   'pooh.gif')		( 'r'   'rotate.gif')		( 'R'   'recolor.gif')		( 's'   'scale.gif')		( 't'   'tile.gif')		( 'u'   'dup.gif')		( 'v'   'viewer.gif')		( 'x'   'dismiss.gif')		( '1'	'fontStyle.gif')		( '2'	'fontEmph.gif')		( '3'	'fontSize.gif')	) do:[:spec|		form := (Form fromBinaryStream: (ReadStream on: (files at: spec last))).		map at: spec first first put: form.	].	font := StrikeFont new initializeWithMap: map.	font name: #HaloFont.	style := TextStyle fontArray: {font}.	TextConstants at: #HaloFont put: style.! !!HaloFont class methodsFor: 'class initialization' stamp: 'ar 3/27/2004 20:36'!initialize	"HaloFont initialize"	StrikeFont initializeStandardCharacterToGlyphMap.	(TextStyle named: 'HaloFont') defaultFont familyName = 'HaloFont'		ifFalse:[self initFont].! !!HaloFont class methodsFor: 'glyphs' stamp: 'ar 12/8/2002 16:28'!glyphs	^#(		('collapse.gif' 'R0lGODlhCgAMAIAAAAAAAf///ywAAAAACgAMAAACFoyPqQYN6OJp8NEa7rQPu71FHfMtSgEAOw==')		('drag.gif' 'R0lGODlhDAAMAIAAAAAAAf///ywAAAAADAAMAAACGoyPB4sL9hKczoU4lcR3N69pFRNx38UoqZQUADs=')		('debug.gif' 'R0lGODlhDAAMAIAAAAAAAf///ywAAAAADAAMAAACFYyPGQCa7BCUstUzK8t6R+N9YcR9BQA7')		('grab.gif' 'R0lGODlhDAAMAIAAAAAAAf///ywAAAAADAAMAAACGowNcIvNoU6Ub06mYtoaempdCbZczilx5rMUADs=')		('help.gif' 'R0lGODlhDAAMAIAAAAAAAf///ywAAAAADAAMAAACF4wDCceqjNZJTRoKa5424/2B3UZyZQQVADs=')		('menu.gif' 'R0lGODlhDAAMAIAAAAAAAf///ywAAAAADAAMAAACF4yPCMurzR4EKgV6pssWG+1dnQRZ5pkUADs=')		('paint.gif' 'R0lGODlhDAAMAIAAAAAAAf///ywAAAAADAAMAAACGIyPB5C521R4EU7W8M3aIu8pXcWEnxkZBQA7')		('pooh.gif' 'R0lGODlhDAAMAIAAAAAAAf///ywAAAAADAAMAAACGoyPB4sL5qJTjzEqX9M3xQRJXqYF5GSiHwgWADs=')		('rotate.gif' 'R0lGODlhDAAMAIAAAAAAAf///ywAAAAADAAMAAACGIwNcIvsv5JUjDZFbcg53u1VkwaVIJQwBQA7')		('recolor.gif' 'R0lGODlhDAAMAIAAAAAAAf///ywAAAAADAAMAAACGYyPqaAHzxCEbUZp3nI3u9Bd3Qc2oGamRgEAOw==')		('scale.gif' 'R0lGODlhDAAMAIAAAAAAAf///ywAAAAADAAMAAACGYyPqQntAVA8cRoLM5X6cuw82AKGz4KmQQEAOw==')		('tile.gif' 'R0lGODlhDAAMAIAAAAAAAf///ywAAAAADAAMAAACFoyPqcsBD6OJFEyb3lXaVXh9WEOWSQEAOw==')		('dup.gif' 'R0lGODlhDAAMAIAAAAAAAf///ywAAAAADAAMAAACF4yPqQjtChhkLgZrsNXy1g5eUIUt5lIAADs=')		('viewer.gif' 'R0lGODlhDgAMAIAAAAAAAf///ywAAAAADgAMAAACG4yPqYvgr2B47oB5aZ5Gy41RnZVBVeIx6soyBQA7')		('dismiss.gif' 'R0lGODlhDAAMAIAAAAAAAf///ywAAAAADAAMAAACF4yPqQmA/WBoLtLK6JpaXXl0nQFy23kWADs=')		('fontStyle.gif' 'R0lGODlhDAAMAIAAAAAAAf///ywAAAAADAAMAAACGoyPqQjd4cCRsCZq8LQ6P/hlnKJ1lsiE5nIUADs=')		('fontEmph.gif' 'R0lGODlhDAAMAIAAAAAAAf///ywAAAAADAAMAAACGoyPqQjt4QCMUp6WrME3v8lFm9eRowktqlEAADs=')		('fontSize.gif' 'R0lGODlhDAAMAIAAAAAAAf///ywAAAAADAAMAAACFoyPecCg5t6SU7UQU75oPwZ9lTZSSQEAOw==')	)! !!MenuMorph methodsFor: '*Tweak' stamp: 'ar 5/5/2004 18:18'!openAt: aPoint	self position: aPoint.	self invokeModal.! !!MVCMenuMorph methodsFor: '*Tweak' stamp: 'ar 12/3/2003 00:24'!informUserAt: aPoint during: aBlock	"Add this menu to the Morphic world during the execution of the given block."	| title w |	Smalltalk isMorphic ifFalse: [^ self].	title _ self allMorphs detect: [ :ea | ea hasProperty: #titleString ].	title _ title submorphs first.	self visible: false.	w _ ActiveWorld.	^[aBlock value:[:string|		self visible ifFalse:[			w addMorph: self centeredNear: aPoint.			self visible: true].		title contents: string.		self setConstrainedPosition: Sensor cursorPoint hangOut: false.		self changed.		w displayWorld		 "show myself"	]] ensure:[		self delete.		w displayWorld	].! !!MessageSend methodsFor: '*Tweak' stamp: 'ar 9/22/2003 01:11'!readFieldsFrom: deSerializer	receiver := deSerializer readField: #receiver ifAbsent:[receiver].	selector := deSerializer readField: #selector ifAbsent:[selector].	arguments := deSerializer readField: #arguments ifAbsent:[arguments].! !!MessageSend methodsFor: '*Tweak' stamp: 'ar 2/7/2004 18:15'!writeFieldsOn: aSerializer	aSerializer writeField: #receiver value: receiver.	aSerializer writeField: #selector value: selector.	aSerializer writeField: #arguments value: arguments.! !!MessageTally methodsFor: '*Tweak'!spyEvery: millisecs onScript: aBlock				 	"Create a spy and spy on the given block at the specified rate."	| myDelay value startTime time0 |	(aBlock isMemberOf: BlockContext)		ifFalse: [self error: 'spy needs a block here'].	self class: aBlock receiver class method: aBlock method.		"set up the probe"	ObservedProcess _ Processor activeProcess.	myDelay := Delay forMilliseconds: millisecs.	time0 := Time millisecondClockValue.	gcStats _ Smalltalk getVMParameters.	Timer :=		[[true] whileTrue: 			[startTime := Time millisecondClockValue.			myDelay wait.			self tally: (ScriptScheduler activeSuspendedContext ifNil:[ScriptScheduler activeSchedulerProcess suspendedContext])				"tally can be > 1 if ran a long primitive"				by: (Time millisecondClockValue - startTime) // millisecs].		nil] newProcess.	Timer priority: Processor userInterruptPriority.		"activate the probe and evaluate the block"	Timer resume.	value := aBlock value.	"Collect gc statistics"	Smalltalk getVMParameters keysAndValuesDo:		[:idx :gcVal| gcStats at: idx put: (gcVal - gcStats at: idx)].		"cancel the probe and return the value"	Timer terminate.	time := Time millisecondClockValue - time0.	^value! !!MessageTally class methodsFor: '*Tweak' stamp: 'ar 3/14/2003 02:06'!doReport: aNode	^(Workspace new contents: (String streamContents:[:s| aNode report: s])) openLabel:'Tally results'.! !!MessageTally class methodsFor: '*Tweak' stamp: 'ar 12/8/2002 17:00'!spyOnScript: aBlock				    "MessageTally spyOn: [100 timesRepeat: [3.14159 printString]]"	| node result |	node _ self new.	result _ node spyEvery: 1 onScript: aBlock.	self doReport: node.	^ result! !!Metaclass methodsFor: '*Tweak' stamp: 'ar 5/5/2004 23:36'!browserDefinition: style	"Answer a String that defines the receiver."	^self definitionST80! !!MethodReference methodsFor: '*Tweak' stamp: 'ar 3/14/2004 15:38'!displayText	^stringVersion! !!MorphicTransform methodsFor: '*Tweak' stamp: 'ar 12/8/2002 02:19'!invertPoint: aPoint	^self invert: aPoint! !!MorphicTransform methodsFor: '*Tweak' stamp: 'ar 12/8/2002 02:19'!invertRect: aRect	^self invertBoundsRect: aRect! !!MorphicTransform methodsFor: '*Tweak' stamp: 'ar 12/8/2002 02:19'!transformPoint: aPoint	^self transform: aPoint! !!MorphicTransform methodsFor: '*Tweak' stamp: 'ar 12/8/2002 02:19'!transformRect: aRect	^self transformBoundsRect: aRect! !!NSPluggableListItemWrapper methodsFor: 'accessing' stamp: 'ar 3/27/2004 01:31'!asString	string ifNotNil:[^string].	getStringSelector ifNil:[^super asString].	^self sendToModel: getStringSelector! !!NSPluggableListItemWrapper methodsFor: 'accessing' stamp: 'ar 3/27/2004 01:32'!contents	getContentsSelector ifNil:[^#()].	^self sendToModel: getContentsSelector.! !!NSPluggableListItemWrapper methodsFor: 'accessing' stamp: 'ar 3/27/2004 01:32'!getContentsSelector	^getContentsSelector! !!NSPluggableListItemWrapper methodsFor: 'accessing' stamp: 'ar 3/27/2004 01:32'!getContentsSelector: aSymbol	self validateSelector: aSymbol.	getContentsSelector := aSymbol.! !!NSPluggableListItemWrapper methodsFor: 'accessing' stamp: 'ar 3/27/2004 01:32'!getStringSelector	^getStringSelector! !!NSPluggableListItemWrapper methodsFor: 'accessing' stamp: 'ar 3/27/2004 01:32'!getStringSelector: aSymbol	self validateSelector: aSymbol.	getStringSelector := aSymbol.! !!NSPluggableListItemWrapper methodsFor: 'accessing' stamp: 'ar 3/27/2004 01:32'!hasContents	hasContentsSelector ifNil:[^super hasContents].	^self sendToModel: hasContentsSelector! !!NSPluggableListItemWrapper methodsFor: 'accessing' stamp: 'ar 3/27/2004 01:32'!hasContentsSelector	^hasContentsSelector! !!NSPluggableListItemWrapper methodsFor: 'accessing' stamp: 'ar 3/27/2004 01:32'!hasContentsSelector: aSymbol	self validateSelector: aSymbol.	hasContentsSelector := aSymbol.! !!NSPluggableListItemWrapper methodsFor: 'accessing' stamp: 'ar 3/27/2004 01:32'!item	^item! !!NSPluggableListItemWrapper methodsFor: 'accessing' stamp: 'ar 3/27/2004 01:32'!item: newItem	item := newItem! !!NSPluggableListItemWrapper methodsFor: 'accessing' stamp: 'ar 3/27/2004 01:32'!string	^string! !!NSPluggableListItemWrapper methodsFor: 'accessing' stamp: 'ar 3/27/2004 01:32'!string: aString	string := aString! !!NSPluggableListItemWrapper methodsFor: 'printing' stamp: 'ar 3/27/2004 01:33'!printOn: aStream	super printOn: aStream.	aStream nextPut:$(; nextPutAll: self asString; nextPut:$).! !!NSPluggableListItemWrapper methodsFor: 'private' stamp: 'ar 3/27/2004 01:33'!sendToModel: aSelector	aSelector numArgs = 0 		ifTrue:[^model perform: aSelector].	aSelector numArgs = 1 		ifTrue:[^model perform: aSelector with: item].	aSelector numArgs = 2 		ifTrue:[^model perform: aSelector with: item with: self].! !!NSPluggableListItemWrapper methodsFor: 'private' stamp: 'ar 3/27/2004 01:33'!validateSelector: aSymbol	(aSymbol numArgs between: 0 and: 2) ifFalse:[^self error: 'Invalid pluggable selector'].! !!NSTweakBrowser methodsFor: 'initialize' stamp: 'ar 3/27/2004 01:34'!defaultBrowserTitle	^ 'NSBrowser'! !!NSTweakBrowser methodsFor: 'initialize' stamp: 'ar 3/27/2004 01:34'!openAsMorphEditing: editString 	"Create a pluggable version of all the views for a Browser, including 	views and controllers."	"PackagePaneBrowser openBrowser"	| listHeight window |	listHeight _ 0.4.	(window _ SystemWindow labelled: 'later') model: self.	window		addMorph: (SimpleHierarchicalListMorph				on: self				list: #envListWrappers				selected: #selectedWrapper				changeSelected: #selectedWrapper:				menu: nil				keystroke: nil)		frame: (0 @ 0 extent: 0.25 @ listHeight).	self		addClassAndSwitchesTo: window		at: (0.25 @ 0 extent: 0.25 @ listHeight)		plus: 0.	window		addMorph: self buildMorphicMessageCatList		frame: (0.5 @ 0 extent: 0.25 @ listHeight).	window		addMorph: self buildMorphicMessageList		frame: (0.75 @ 0 extent: 0.25 @ listHeight).	self		addLowerPanesTo: window		at: (0 @ listHeight corner: 1 @ 1)		with: editString.	window setUpdatablePanesFrom: #(#envList #systemCategoryList #classList #messageCategoryList #messageList ).	^ window! !!NSTweakBrowser methodsFor: 'accessing' stamp: 'ar 3/27/2004 01:25'!classList	environment ifNil:[^#()].	selectedSystemCategory ifNil:[^#()].	^environment organization listAtCategoryNamed: selectedSystemCategory.! !!NSTweakBrowser methodsFor: 'accessing' stamp: 'ar 3/27/2004 01:25'!environment	^environment! !!NSTweakBrowser methodsFor: 'accessing' stamp: 'ar 3/27/2004 01:25'!environment: env	environment := env.	self systemOrganizer: env organization! !!NSTweakBrowser methodsFor: 'accessing' stamp: 'ar 3/27/2004 13:57'!selectedSystemCategoryName	^selectedSystemCategory! !!NSTweakBrowser methodsFor: 'env list' stamp: 'ar 3/27/2004 01:29'!envList	"Answer a list of the packages in the current system organization."	^{Smalltalk}, (CNamespace allSubclasses asArray sort:[:e1 :e2| e1 name <= e2 name])! !!NSTweakBrowser methodsFor: 'env list' stamp: 'ar 3/27/2004 01:29'!envListIndex	^envListIndex ifNil:[envListIndex := 0]! !!NSTweakBrowser methodsFor: 'env list' stamp: 'ar 3/27/2004 01:30'!envListIndex: anInteger 	"Set anInteger to be the index of the current package selection."	envListIndex := anInteger.	environment := self selectedEnvironment.	messageCategoryListIndex := 0.	systemCategoryListIndex := 0.	messageListIndex := 0.	classListIndex := 0.	self setSystemOrganizer.	self setClassOrganizer.	self changed: #envListSelectionChanged.	self changed: #envListIndex.	"update my selection"	self changed: #systemCategoryList.	"update the category list"	self systemCategoryListIndex: 0.	"update category list selection"! !!NSTweakBrowser methodsFor: 'env list' stamp: 'ar 3/27/2004 01:30'!envListMenu: aMenu	"Answer a Menu of operations on class packages to be 	displayed when the operate menu button is pressed."	 ^aMenu! !!NSTweakBrowser methodsFor: 'env list' stamp: 'ar 3/27/2004 01:33'!envListWrappers	| wrapper |	^self envList collect:[:each|		wrapper := NSPluggableListItemWrapper with: each model: self.		wrapper getContentsSelector: #getOrganizerList:.		wrapper string: each name.		wrapper].! !!NSTweakBrowser methodsFor: 'env list' stamp: 'ar 3/27/2004 01:33'!envStringList	^self envList collect:[:x| x name].! !!NSTweakBrowser methodsFor: 'env list' stamp: 'ar 3/27/2004 01:33'!getClassList: assoc	| env cat binding theClass wrapper |	env := assoc key.	cat := assoc value.	^((env organization listAtCategoryNamed: cat) select:[:aKey|		binding := env bindingOf: aKey.		binding notNil and:[binding value isBehavior]	]) collect:[:clsName|		theClass := env at: clsName.		wrapper := NSPluggableListItemWrapper with: theClass model: self.		wrapper string: theClass name.		wrapper].! !!NSTweakBrowser methodsFor: 'env list' stamp: 'ar 3/27/2004 01:33'!getOrganizerList: env	| wrapper |	^env organization categories collect:[:each|		wrapper := NSPluggableListItemWrapper with: env->each model: self.		"wrapper getContentsSelector: #getClassList:."		wrapper string: each.		wrapper].! !!NSTweakBrowser methodsFor: 'env list' stamp: 'ar 3/27/2004 01:33'!openEditString: aString	^self openAsMorphEditing: aString! !!NSTweakBrowser methodsFor: 'env list' stamp: 'ar 3/27/2004 01:33'!selectedEnvironment	"Answer the receiver's 'package'."	^environment! !!NSTweakBrowser methodsFor: 'env list' stamp: 'ar 3/27/2004 01:33'!selectedWrapper	^selectedWrapper! !!NSTweakBrowser methodsFor: 'env list' stamp: 'ar 3/27/2004 13:53'!selectedWrapper: aWrapper	| editMode |	selectedWrapper := aWrapper.	self changed: #selectedWrapper.	editMode := #none.	aWrapper ifNil:[		environment := nil.		selectedSystemCategory := nil.	] ifNotNil:[		(selectedWrapper item isKindOf: Association) ifTrue:[			environment := selectedWrapper item key.			selectedSystemCategory := selectedWrapper item value.			editMode := #newClass.		] ifFalse:[			environment := selectedWrapper item.			selectedSystemCategory := nil.		].	].	self setSystemOrganizer.	self changed: #classList.	self changed: #messageCategoryList.	self changed: #messageList.	editSelection := editMode.	self changed: #contents.! !!NSTweakBrowser methodsFor: 'env list' stamp: 'ar 3/27/2004 01:34'!setSystemOrganizer	environment ifNil:[^self].	self systemOrganizer: self selectedEnvironment organization! !!NSTweakBrowser methodsFor: 'other' stamp: 'ar 3/27/2004 01:34'!browseClassRefs	| cls |	(cls _ self selectedClass) ifNotNil: [		self systemNavigation browseAllCallsOn: 			(self selectedEnvironment bindingOf: cls theNonMetaClass name)]! !!NSTweakBrowser methodsFor: 'other' stamp: 'ar 3/27/2004 01:35'!contents	"Depending on the current selection, different information is retrieved.	Answer a string description of that information. This information is the	method of the currently selected class and message."	| comment theClass latestCompiledMethod |	latestCompiledMethod _ currentCompiledMethod.	currentCompiledMethod _ nil.	editSelection == #none ifTrue: [^ ''].	editSelection == #editSystemCategories 		ifTrue: [^ systemOrganizer printString].	editSelection == #newClass 		ifTrue: [^ (theClass _ self selectedClass)			ifNil:				[self selectedEnvironment template: self selectedSystemCategoryName]			ifNotNil:				[Class templateForSubclassOf: theClass category: self selectedSystemCategoryName]].	editSelection == #editClass 		ifTrue:			[^ (theClass _ self selectedClassOrMetaClass)				ifNil:					['']				ifNotNil:			 		[theClass definitionST80: Preferences printAlternateSyntax not]].	editSelection == #editComment 		ifTrue:			[(theClass _ self selectedClass) ifNil: [^ ''].			comment _ theClass comment.			currentCompiledMethod _ theClass organization commentRemoteStr.			^ comment size = 0				ifTrue: ['This class has not yet been commented.']				ifFalse: [comment]].	editSelection == #hierarchy 		ifTrue: [^ self selectedClassOrMetaClass printHierarchy].	editSelection == #editMessageCategories 		ifTrue: [^ self classOrMetaClassOrganizer printString].	editSelection == #newMessage		ifTrue:			[^ (theClass _ self selectedClassOrMetaClass) 				ifNil: ['']				ifNotNil: [theClass sourceCodeTemplate]].	editSelection == #editMessage		ifTrue:			[self showingByteCodes ifTrue: [^ self selectedBytecodes].			currentCompiledMethod _ latestCompiledMethod.			^ self selectedMessage].	self error: 'Browser internal error: unknown edit selection.'! !!NSTweakBrowser methodsFor: 'other' stamp: 'ar 3/27/2004 06:03'!defineClass: defString notifying: aController  	"The receiver's textual content is a request to define a new class. The	source code is defString. If any errors occur in compilation, notify	aController."	| oldClass class newClassName defTokens keywdIx envt |	oldClass _ self selectedClassOrMetaClass.	defTokens _ defString findTokens: Character separators.	envt _ self selectedEnvironment.	keywdIx _ defTokens findFirst: [:x | '*subclass*' match: x].	newClassName _ (defTokens at: keywdIx+1) copyWithoutAll: '#()'.	((oldClass isNil or: [oldClass localName asString ~= newClassName])		and: [(envt bindingOf: newClassName) notNil ]) ifTrue:			["Attempting to define new class over existing one when				not looking at the original one in this browser..."			(self confirm: ((newClassName , ' is an existing class in ', envt name,'.Redefining it might cause serious problems.Is this really what you want to do?') asText makeBoldFrom: 1 to: newClassName size))				ifFalse: [^ false]].	class _ envt evaluate: defString notifying: aController logged: true.	(class isKindOf: Behavior) ifFalse:[^false].	envt defineClass: class theNonMetaClass.	self changed: #classList.	self classListIndex: (self classList indexOf: 		((class isKindOf: Metaclass)			ifTrue: [class soleInstance localName]			ifFalse: [class localName])).	self clearUserEditFlag; editClass.	^true! !!NSTweakBrowser methodsFor: 'other' stamp: 'ar 3/27/2004 05:52'!doRemoveClass	"Remove the selected class from the system, at interactive user request.  Make certain the user really wants to do this, since it is not reversible.  Answer true if removal actually happened."	| message  className classToRemove result |	self okToChange ifFalse: [^ false].	classToRemove _ self selectedClassOrMetaClass ifNil: [self beep. ^ false].	classToRemove _ classToRemove theNonMetaClass.	className _ classToRemove localName.	message _ 'Are you certain that youwant to REMOVE the class ', className, 'from the system?'.	(result _ self confirm: message)		ifTrue: 			[classToRemove subclasses size > 0				ifTrue: [(self confirm: 'class has subclasses: ' , message)					ifFalse: [^ false]].			classToRemove removeFromSystem.			self changed: #classList.			true].	^ result! !!NSTweakBrowser methodsFor: 'other' stamp: 'ar 3/27/2004 06:05'!removeClass	self doRemoveClass ifTrue:		[self classListIndex: 0]! !!NSTweakBrowser class methodsFor: 'as yet unclassified' stamp: 'ar 3/27/2004 17:09'!initialize	"NSTweakBrowser initialize"	TheWorldMenu registerOpenCommand: 		{ 'Namespace Browser' . { NSTweakBrowser . #openBrowser }. 'An experimental Namespace Browser' }.! !!NewParagraph methodsFor: '*Tweak' stamp: 'ar 5/5/2004 19:10'!attributesAt: aPoint	"Answer the attributes at the given point"	^text attributesAt: (self characterBlockAtPoint: aPoint) stringIndex forStyle: textStyle! !!Number methodsFor: '*Tweak' stamp: 'ar 9/9/2003 18:47'!atRandom	"Answer a random integer from 1 to self.  This implementation uses a	shared generator. Heavy users should their own implementation or use	Interval>atRandom: directly."	self isZero ifTrue:[^self].	self negative ifTrue:[^self negated atRandom negated].	^ self atRandom: Collection randomForPicking! !!Number methodsFor: '*Tweak' stamp: 'ar 9/9/2003 18:47'!atRandom: aGenerator	"Answer a random integer from 1 to self picked from aGenerator."	^ aGenerator next * self! !!Number methodsFor: '*Tweak' stamp: 'ar 3/19/2003 00:10'!boundedBy: aValue	^self min: aValue max: 0-aValue! !!Number methodsFor: '*Tweak' stamp: 'ar 12/1/2003 20:53'!exportXmlOn: xmlWriter key: aKey	xmlWriter startTag: aKey.	xmlWriter attribute: 'type' value: 'Number'.	xmlWriter attribute: 'value' value: self printString.	xmlWriter endEmptyTag: aKey.! !!Number methodsFor: '*Tweak' stamp: 'ar 9/17/2003 17:38'!serializeOn: aSerializer	^aSerializer writeNumber: self! !!Fraction methodsFor: '*Tweak' stamp: 'ar 11/16/2003 19:13'!serializeOn: aSerializer	^aSerializer writeObject: self! !!Number class methodsFor: '*Tweak' stamp: 'ar 3/8/2004 00:13'!defaultValue	^1! !!PackageInfo methodsFor: '*Tweak' stamp: 'ar 3/26/2004 14:53'!asChangeSet	"Create a change set from all the stuff that's in this PI"	| cs |	cs := ChangeSorter basicNewChangeSet: packageName.	Cursor wait showWhile:[		self classesAndMetaClasses do:[:each|			cs addClass: each.			cs reorganizeClass: each.			each isMeta ifFalse:[				each organization commentRemoteStr ifNotNil:[cs commentClass: each].			].			each selectorsAndMethodsDo:[:sel :meth|				cs noteNewMethod: meth forClass: each selector: sel priorMethod: nil.			].		].		self extensionMethods do:[:mref|			cs noteNewMethod: (mref actualClass compiledMethodAt: mref methodSymbol)				forClass: mref actualClass				selector: mref methodSymbol				priorMethod: nil.		].	].	^cs! !!ParagraphEditor methodsFor: '*Tweak' stamp: 'ar 10/1/2003 20:48'!saveHtmlInFile	| fileName stringToSave parentWindow labelToUse |	stringToSave _ paragraph text asHtml.	stringToSave size == 0 ifTrue: [^ self inform: 'nothing to save.'].	parentWindow _ self model dependents						detect: [:dep | dep isKindOf: SystemWindow]						ifNone: [nil].	parentWindow isNil		ifTrue: [labelToUse _ 'Untitled']		ifFalse: [labelToUse _ parentWindow label].	fileName _ FillInTheBlank request: 'File name? (".html" will be added to end)' 			initialAnswer: labelToUse.	fileName size == 0 ifTrue: [^ self beep].	(fileName asLowercase endsWith: '.text') ifFalse: [fileName _ fileName,'.html'].	(FileStream newFileNamed: fileName)		nextPutAll: stringToSave; close! !!PluggableTextMorph methodsFor: '*Tweak' stamp: 'ar 10/1/2003 20:48'!saveHtmlInFile	self handleEdit: [textMorph editor saveHtmlInFile]! !!Point methodsFor: '*Tweak' stamp: 'ar 3/19/2003 00:11'!boundedBy: radius	| length |	length := self length.	length > radius ifTrue:[^self * (radius / length)].	^self! !!Point methodsFor: '*Tweak' stamp: 'ar 6/9/2003 01:20'!ceiling	"Answer a Point whose x and y coordinates are integers. Answer the receiver if its coordinates are already integral."	(x isInteger and: [y isInteger]) ifTrue: [^ self].	^ x ceiling @ y ceiling! !!Point methodsFor: '*Tweak' stamp: 'ar 12/1/2003 20:53'!exportXmlOn: xmlWriter key: aKey	xmlWriter startTag: aKey.	xmlWriter attribute: 'type' value: 'Point'.	xmlWriter attribute: 'x' value: x printString.	xmlWriter attribute: 'y' value: y printString.	xmlWriter endEmptyTag: aKey.! !!Point methodsFor: '*Tweak' stamp: 'ar 6/5/2003 20:49'!fastRect: aPoint 	"A heavily optimized version of #rect:"	| ptX ptY rect |	rect := Rectangle new.	ptX := aPoint x.	ptY := aPoint y.	x <= ptX ifTrue:[		y <= ptY 			ifTrue:[^rect setOrigin: self corner: aPoint]			ifFalse:[^rect setOrigin: x@ptY corner: ptX@x].	] ifFalse:[		y < ptY			ifTrue:[^rect setOrigin: ptX@y corner: x@ptY]			ifFalse:[^rect setOrigin: aPoint corner: self].	].! !!Point methodsFor: '*Tweak' stamp: 'ar 1/28/2003 03:01'!isPowerOfTwo	^x isPowerOfTwo and:[y isPowerOfTwo]! !!Point methodsFor: '*Tweak' stamp: 'ar 3/19/2003 00:15'!length	^self r! !!Point methodsFor: '*Tweak' stamp: 'ar 2/7/2003 18:22'!referencePosition	^self! !!Point methodsFor: '*Tweak' stamp: 'ar 3/23/2003 19:48'!rotateBy: angle	^self rotateBy: angle about: 0@0! !!Point methodsFor: '*Tweak' stamp: 'ar 2/7/2003 18:23'!roundTo: aNumber	aNumber isNumber ifTrue:[^(x roundTo: aNumber) @ (y roundTo: aNumber)].	^(x roundTo: aNumber x) @ (y roundTo: aNumber y)! !!Point methodsFor: '*Tweak' stamp: 'ar 9/17/2003 17:38'!serializeOn: aSerializer	^aSerializer writePoint: self! !!Point methodsFor: '*Tweak'!transformedBy: aTransform	^aTransform transformPoint: self! !!PositionableStream methodsFor: '*Tweak' stamp: 'ar 8/12/2003 18:12'!next: anInteger putAll: aCollection startingAt: startIndex	"Store the next anInteger elements from the given collection."	(startIndex = 1 and:[anInteger = aCollection size]) ifTrue:[^self nextPutAll: aCollection].	^self nextPutAll: (aCollection copyFrom: startIndex to: startIndex + anInteger-1)! !!CTextStream methodsFor: 'as yet unclassified' stamp: 'ar 5/5/2004 17:59'!applyAttribute: att beginningAt: startPos	collection addAttribute: att from: startPos to: self position! !!CTextStream methodsFor: 'as yet unclassified' stamp: 'ar 5/5/2004 19:12'!growTo: anInteger	" anInteger is the required minimal new size of the collection "	| oldSize grownCollection newSize |	oldSize _ collection size.	newSize := anInteger + (oldSize // 4 max: 20).	grownCollection _ collection class new: newSize.	collection _ grownCollection replaceFrom: 1 to: oldSize with: collection startingAt: 1.	writeLimit _ collection size.! !!CTextStream methodsFor: 'as yet unclassified' stamp: 'ar 5/5/2004 17:59'!nextPutAll: aCollection 	"Optimized access to get around Text at:Put: overhead"	| n |	n _ aCollection size.	position + n > writeLimit		ifTrue:[self growTo: position + n + 10].	collection 		replaceFrom: position+1		to: position + n		with: aCollection		startingAt: 1.	position _ position + n.! !!CTextStream methodsFor: 'as yet unclassified' stamp: 'ar 5/5/2004 17:59'!withAttribute: att do: strmBlock	| pos1 val |	pos1 _ self position.	val _ strmBlock value.	collection addAttribute: att from: pos1+1 to: self position.	^ val! !!CTextStream methodsFor: 'as yet unclassified' stamp: 'ar 5/5/2004 17:59'!withAttributes: attributes do: streamBlock 	| pos1 val |	pos1 _ self position.	val _ streamBlock value.	attributes do: [:attribute |		collection			addAttribute: attribute			from: pos1 + 1			to: self position].	^ val! !!Process methodsFor: '*Tweak' stamp: 'ar 9/17/2003 17:33'!serializeOn: aSerializer	^aSerializer writeProcess: self! !!Process methodsFor: '*Tweak-Components' stamp: 'ar 3/19/2003 22:21'!hand	^ActiveHand! !!Process methodsFor: '*Tweak-Components' stamp: 'ar 3/19/2003 22:21'!hand: aHand	"ignored"! !!Process methodsFor: '*Tweak-Components' stamp: 'ar 7/14/2003 18:46'!world	^ActiveWorld! !!Process methodsFor: '*Tweak-Components' stamp: 'ar 7/14/2003 18:53'!world: aWorld	"ignored"! !!Process methodsFor: '*Tweak-override' stamp: 'bf 9/14/2004 15:59'!debug: context title: title full: bool	"Open debugger on self with context shown on top"	| topCtxt |	topCtxt _ self isActiveProcess ifTrue: [thisContext] ifFalse: [self suspendedContext].	(topCtxt hasContext: context) ifFalse: [^ self error: 'context not in process'].		"(self ifTweak: [CDebugger] ifNot: ["Debugger"])"				openOn: self context: context label: title contents: nil fullView: bool.! !!RWBinaryOrTextStream methodsFor: '*Tweak' stamp: 'ar 8/12/2003 16:41'!nextPutAll: aCollection	super nextPutAll: aCollection asString! !!Rectangle methodsFor: '*Tweak'!areasOutside: aRectangle	"Answer an Array of Rectangles comprising the parts of the receiver not 	intersecting aRectangle."	| areas yOrigin yCorner |	"Make sure the intersection is non-empty"	(self intersects: aRectangle) ifFalse: [^Array with: self].	areas _ OrderedCollection new.	aRectangle origin y > origin y		ifTrue: [areas addLast: (origin corner: corner x @ (yOrigin _ aRectangle origin y))]		ifFalse: [yOrigin _ origin y].	aRectangle corner y < corner y		ifTrue: [areas addLast: (origin x @ (yCorner _ aRectangle corner y) corner: corner)]		ifFalse: [yCorner _ corner y].	aRectangle origin x > origin x 		ifTrue: [areas addLast: (origin x @ yOrigin corner: aRectangle origin x @ yCorner)].	aRectangle corner x < corner x 		ifTrue: [areas addLast: (aRectangle corner x @ yOrigin corner: corner x @ yCorner)].	^areas! !!Rectangle methodsFor: '*Tweak' stamp: 'ar 3/6/2004 19:44'!asLayoutFrame	| frame |	frame _ CLayoutFrame new.	frame 		leftFraction: self left; 		rightFraction: self right; 		topFraction: self top; 		bottomFraction: self bottom.	^frame! !!Rectangle methodsFor: '*Tweak'!asRectangle	^self! !!Rectangle methodsFor: '*Tweak' stamp: 'ar 7/19/2003 18:04'!bottomCenter: aPoint	^origin corner: corner x @ aPoint y! !!Rectangle methodsFor: '*Tweak' stamp: 'ar 12/8/2002 16:53'!bottomLeft: aPoint	^aPoint x @ origin y corner: corner x @ aPoint y! !!Rectangle methodsFor: '*Tweak' stamp: 'ar 12/8/2002 16:53'!bottomRight: aPoint	^origin corner: aPoint! !!Rectangle methodsFor: '*Tweak' stamp: 'ar 12/8/2002 02:04'!cornerRectsOfSize: aPoint	"Answer an array of rectangles making up the receiver's corner of a given size"	(aPoint x isZero or:[aPoint y isZero]) ifTrue:[^#()].	^Array		with: (self topLeft extent: aPoint)		with: (self topRight - (aPoint x @ 0) extent: aPoint)		with: (self bottomLeft - (0 @ aPoint y) extent: aPoint)		with: (self bottomRight - aPoint extent: aPoint).! !!Rectangle methodsFor: '*Tweak'!isRectangle	^true! !!Rectangle methodsFor: '*Tweak' stamp: 'ar 7/19/2003 18:05'!leftCenter: aPoint	^aPoint x @ origin y corner: corner! !!Rectangle methodsFor: '*Tweak' stamp: 'ar 7/19/2003 18:05'!rightCenter: aPoint	^origin corner: aPoint x @ corner y! !!Rectangle methodsFor: '*Tweak' stamp: 'ar 9/17/2003 17:33'!serializeOn: aSerializer	^aSerializer writeRectangle: self! !!Rectangle methodsFor: '*Tweak' stamp: 'ar 7/19/2003 18:04'!topCenter: aPoint	^origin x @ aPoint y corner: corner! !!Rectangle methodsFor: '*Tweak' stamp: 'ar 12/8/2002 16:53'!topLeft: aPoint	^aPoint corner: corner! !!Rectangle methodsFor: '*Tweak' stamp: 'ar 12/8/2002 16:53'!topRight: aPoint	^origin x @ aPoint y corner: aPoint x @ corner y! !!Rectangle methodsFor: '*Tweak'!transformedBy: aTransform	^aTransform transformRect: self! !!Rectangle methodsFor: '*Tweak' stamp: 'ar 5/5/2004 12:38'!wrap: aPoint	"Return a point wrapped around the receiver if necessary"	^origin + (aPoint - origin \\ self extent)! !!Rectangle methodsFor: '*Tweak-Halos'!bottomCenterY	^self top + (self height * 0.75)! !!Rectangle methodsFor: '*Tweak-Halos'!centerX	^(self left + self right) * 0.5! !!Rectangle methodsFor: '*Tweak-Halos'!centerY	^(self top + self bottom) * 0.5! !!Rectangle methodsFor: '*Tweak-Halos'!leftCenterX	^self left + (self width * 0.25)! !!Rectangle methodsFor: '*Tweak-Halos'!rightCenterX	^self left + (self width * 0.75)! !!Rectangle methodsFor: '*Tweak-Halos'!topCenterY	^ self top + (self height * 0.25)! !!ScriptMessageSend methodsFor: '*Tweak' stamp: 'ar 10/19/2003 13:54'!postBuildWith: aFactory	self computeExtraArgs.	eventSpec ifNil:[^self].	1 to: eventSpec size by: 2 do:[:i|			(eventSpec at: i) on: (eventSpec at: i+1) notify: self.	].! !!ScriptMessageSend methodsFor: '*Tweak' stamp: 'ar 9/23/2003 01:19'!readFieldsFrom: deSerializer	super readFieldsFrom: deSerializer.	eventSpec := deSerializer readField: #eventSpec ifAbsent:[eventSpec].	extraArgs := deSerializer readField: #extraArgs ifAbsent:[extraArgs].	paused := deSerializer readField: #paused ifAbsent:[paused].! !!ScriptMessageSend methodsFor: '*Tweak' stamp: 'ar 9/24/2003 18:02'!writeFieldsOn: aSerializer	extraArgs ifNil:[self computeExtraArgs].	super writeFieldsOn: aSerializer.	aSerializer writeField: #eventSpec value: eventSpec.	aSerializer writeField: #extraArgs value: extraArgs.	aSerializer writeField: #paused value: paused.! !!AsyncScriptMessageSend methodsFor: '*Tweak' stamp: 'ar 11/17/2003 23:49'!postBuildWith: aMaker	super postBuildWith: aMaker.	self setDefaultScheduler.! !!AsyncScriptMessageSend methodsFor: '*Tweak' stamp: 'ar 9/22/2003 01:09'!readFieldsFrom: deSerializer	super readFieldsFrom: deSerializer.	myTrigger := deSerializer readField: #trigger ifAbsent:[myTrigger].	myScripts := deSerializer readField: #scripts ifAbsent:[myScripts].	myScheduler := ScriptScheduler activeScheduler.! !!AsyncScriptMessageSend methodsFor: '*Tweak' stamp: 'ar 9/21/2003 22:14'!writeFieldsOn: aSerializer	super writeFieldsOn: aSerializer.	aSerializer writeField: #trigger value: myTrigger.	aSerializer writeField: #scripts value: myScripts.! !!ScriptScheduler methodsFor: '*Tweak' stamp: 'ar 10/19/2003 19:56'!hasActiveScripts	"Answer whether the scheduler has any active scripts which need to be run"	activeList isEmpty ifFalse:[^true].	tickList isEmpty ifFalse:[^true].	^self handlesEvent: #tick! !!ScriptScheduler methodsFor: '*Tweak' stamp: 'ar 9/18/2003 02:19'!serializeOn: aSerializer	^aSerializer writeProhibited: self! !!SequenceableCollection methodsFor: '*Tweak' stamp: 'ar 12/8/2002 01:05'!copyWith: newElement before: index	"Answer a copy of the receiver that is 1 bigger than the receiver and has 	newElement at the last element."	| newIC |	newIC _ self species new: self size + 1.	newIC replaceFrom: 1 to: index-1 with: self startingAt: 1.	newIC at: index put: newElement.	newIC replaceFrom: index+1 to: newIC size with: self startingAt: index.	^newIC! !!SequenceableCollection methodsFor: '*Tweak' stamp: 'ar 9/17/2003 17:35'!serializeOn: aPrinter	^aPrinter writeSequence: self.! !!ArrayedCollection methodsFor: '*Tweak' stamp: 'ar 9/17/2003 17:25'!serializeOn: aSerializer	self class isPointers ifFalse:[		^aSerializer writeBitsArray: self.	].	^super serializeOn: aSerializer! !!CompiledMethod methodsFor: '*Tweak' stamp: 'ar 8/10/2003 20:09'!asTriggerBlockIn: aReceiver	"Convert me to a block.	THIS IS A BIG AND UGLY HACK WHICH MAY CRASH YOUR SYSTEM!!"	| block method |	self primitive = 0 ifFalse:[^self error: 'No primitives please'].	self numArgs = 0 ifFalse:[^self error: 'Must be zero arguments'].	method := MethodContext sender: thisContext receiver: aReceiver method: self arguments: #().	block := BlockContext newForMethod: self.	block home: method startpc: self initialPC nargs: 0.	^block! !!CompiledMethod methodsFor: '*Tweak' stamp: 'ar 5/6/2004 03:12'!autoGenerated	^self propertyValueAt: #autoGenerated ifAbsent:[false]! !!CompiledMethod methodsFor: '*Tweak' stamp: 'bf 3/30/2004 12:11'!hasProperty: propName	self valueOfProperty: propName ifAbsent: [^false].	^true! !!CompiledMethod methodsFor: '*Tweak' stamp: 'ar 3/27/2004 15:29'!methodNodeDecompileClass: aClass selector: selector	"Return the parse tree that represents self"	| source |	^ (source _ self getSourceFromFile)		ifNil: [self decompileClass: aClass selector: selector]		ifNotNil: [aClass parserClass new parse: source class: (self sourceClass ifNil: [aClass])]! !!CompiledMethod methodsFor: '*Tweak' stamp: 'ar 8/5/2003 17:45'!propertyValueAt: propName	^self valueOfProperty: propName! !!CompiledMethod methodsFor: '*Tweak' stamp: 'ar 5/6/2004 03:13'!propertyValueAt: propName ifAbsent: aBlock	^self valueOfProperty: propName ifAbsent: aBlock! !!CompiledMethod methodsFor: '*Tweak' stamp: 'ar 8/5/2003 17:45'!propertyValueAt: propName put: propValue	^self setProperty: propName toValue: propValue! !!CompiledMethod methodsFor: '*Tweak' stamp: 'ar 5/6/2004 02:20'!readsTweakField: field	"Answer whether the receiver reads the given field"	| toGet scanner byte type max offset |	toGet := field toGet ifNil:[^false].	(self hasLiteral: toGet) ifFalse:[^false].	max := self numLiterals.	"We scan the first sixteen accurately"	max > 16 ifTrue:[max := 16].	1 to: self numLiterals do:[:i|		(self literalAt: i) == toGet ifTrue:[			"scan for push: self; send: toGet"			scanner := InstructionStream on: self.			scanner scanFor: [:insn| 				(insn = 16r70 "push self") ifTrue:[					byte := self at: scanner pc+1.					type := byte // 16.					offset := byte \\ 16.					type > 12 ifTrue:[						(offset+1 = i) ifTrue:[^true].					].				].				false			].		].	].	17 to: self numLiterals do:[:i|		(self literalAt: i) == toGet ifTrue:[^true].	].	^false! !!CompiledMethod methodsFor: '*Tweak' stamp: 'ar 5/6/2004 02:05'!refersToField: field	^(self writesTweakField: field) or:[self readsTweakField: field]! !!CompiledMethod methodsFor: '*Tweak' stamp: 'ar 9/22/2003 00:45'!sends: aSelector	"Answer whether this method potentially sends the given selector"	^self hasLiteral: aSelector! !!CompiledMethod methodsFor: '*Tweak' stamp: 'ar 9/17/2003 17:30'!serializeOn: aSerializer	^aSerializer writeCompiledMethod: self! !!CompiledMethod methodsFor: '*Tweak' stamp: 'ar 8/10/2003 20:10'!triggerValueIn: aReceiver	"Evaluate me as a method trigger."	^(self asTriggerBlockIn: aReceiver) value! !!CompiledMethod methodsFor: '*Tweak' stamp: 'ar 5/6/2004 01:51'!writesTweakField: field	"Answer whether the receiver writes the given field"	| toSet |	toSet := field toSet ifNil:[^false].	(self hasLiteral: toSet) ifFalse:[^false].	^true! !!OrderedCollection methodsFor: '*Tweak' stamp: 'ar 9/17/2003 17:31'!serializeOn: aSerializer	^aSerializer writeCollection: self.! !!RunArray methodsFor: '*Tweak' stamp: 'ar 9/21/2003 21:08'!serializeOn: aSerializer	"Write RunArray as object since it doesn't fully adhere to the collection protocols."	^aSerializer writeObject: self! !!ServerDirectory methodsFor: '*Tweak' stamp: 'ar 3/13/2004 01:15'!asTreeItem	^CServerDirectoryTreeItem on: self! !!ServerDirectory methodsFor: '*Tweak' stamp: 'ar 3/27/2004 22:30'!putFile: fileStream named: fileNameOnServer	"Just FTP a local fileStream to the server.  (Later -- Use a proxy server if one has been registered.)"	| client |	client := self openFTPClient.	client isNil ifTrue: [^ self].	client binary.	[client putFileStreamContents: fileStream as: fileNameOnServer]		ensure: [client quit]! !!ServerDirectory methodsFor: '*Tweak' stamp: 'ar 3/27/2004 21:50'!serversInGroup	^group		ifNil: [Array with: self]		ifNotNil: [self class serversInGroupNamed: self groupName]! !!ShortIntegerArray methodsFor: '*Tweak' stamp: 'ar 3/25/2004 18:56'!swapEndsIn: aMaker	"I am a 16bit quantity object so only swap halves"	aMaker swapHalvesIn: self.! !!ShortRunArray methodsFor: '*Tweak' stamp: 'ar 3/25/2004 18:56'!swapEndsIn: aMaker	"I am a 16bit quantity object so only swap halves"	aMaker swapHalvesIn: self.! !!SoundBuffer methodsFor: '*Tweak' stamp: 'ar 3/25/2004 18:56'!swapEndsIn: aMaker	"I am a 16bit quantity object so only swap halves"	aMaker swapHalvesIn: self.! !!StandardFileStream methodsFor: '*Tweak' stamp: 'ar 12/8/2002 03:40'!modificationTime	^self directoryEntry modificationTime! !!StrikeFont methodsFor: '*Tweak' stamp: 'ar 3/30/2004 18:13'!initializeWithMap: charMap	"Initialize the receiver using the given charMap. The charMap is expected to be a dictionary mapping characters to forms. This method is intended to be used for special decorative fonts, like for example, window or scrollbar button decors."	| glyphExtent xStart glyph |	characterToGlyphMap := self standardCharacterToGlyphMap.	xTable := Array new: 258.	glyphExtent := charMap inject: 0@0 into:[:size :form| (size x + form width) @ (size y max: form height)].	glyphs := Form extent: glyphExtent depth: 1.	xStart := 0.	maxWidth := 0.	0 to: 255 do:[:i|		xTable at: i+1 put: xStart.		glyph := charMap at: (Character value: i) ifAbsent:[nil].		glyph ifNotNil:[			glyph displayOn: glyphs at: xStart@0 rule: Form over.			xStart := xStart + glyph width.			maxWidth := maxWidth max: glyph width.		].	].	xTable at: 257 put: xStart.	xTable at: 258 put: xStart.	minAscii := 0.	maxAscii := 255.	strikeLength := xStart.	ascent := glyphExtent y.	descent := 0.	emphasis := 0.	pointSize := glyphExtent y.! !!StrikeFont methodsFor: '*Tweak' stamp: 'ar 9/17/2003 17:35'!serializeOn: aSerializer	^aSerializer writeFont: self! !!StrikeFont methodsFor: '*Tweak' stamp: 'ar 12/8/2002 16:00'!standardCharacterToGlyphMap	"Return identity mapping"	^StandardCharacterToGlyphMap ifNil:[		StandardCharacterToGlyphMap := (0 to: 255) collect:[:i|i].	].! !!StrikeFont methodsFor: '*Tweak-Resources' stamp: 'ar 2/24/2004 15:26'!allImportsDo: aBlock	^nil! !!StrikeFont methodsFor: '*Tweak-Resources' stamp: 'ar 2/24/2004 15:26'!allImportsDo: aBlock excluding: aSet	^nil! !!StrikeFont methodsFor: '*Tweak-Resources' stamp: 'ar 12/2/2003 17:11'!embedResourceIn: zipArchive	"For now, do nothing."	^self! !!StrikeFont methodsFor: '*Tweak-Resources' stamp: 'ar 12/2/2003 17:11'!embedResourceIn: zipArchive notifying: bar	"For now, do nothing."	^self! !!StrikeFont methodsFor: '*Tweak-Resources' stamp: 'ar 12/2/2003 17:03'!emphasisString	| emph str |	emph := self emphasis.	emph = 0 ifTrue:[^'regular'].	str := ''.	(#(1 2 4 16) select:[:bit| emph anyMask: bit]) do:[:bit|		str := str, (#('bold' 'italic' 'underlined' 'narrow' 'struckout') at: bit highBit).	] separatedBy:[str := str,'-'].	^str! !!StrikeFont methodsFor: '*Tweak-Resources' stamp: 'ar 12/2/2003 18:53'!exportXmlOn: xmlWriter	"When exporting an object that uses a shared resource, this method needs to write out an appropriate description of the receiver. This method should provide enough information for the loader to construct the resource even if it hasn't been loaded yet."	xmlWriter startTag: self resourceType.	xmlWriter attribute: 'id' value: self resourceID asString.	xmlWriter attribute: 'name' value: self familyName.	xmlWriter attribute: 'size' value: self height asString.	xmlWriter attribute: 'emphasis' value: self emphasis asString.	xmlWriter endEmptyTag: self resourceType.! !!StrikeFont methodsFor: '*Tweak-Resources' stamp: 'ar 12/2/2003 16:58'!resourceID	"Answer a unique ID for this resource"	^self class name,'-', self familyName,'-', self height asString,'px-',self emphasisString! !!StrikeFont methodsFor: '*Tweak-Resources' stamp: 'ar 12/2/2003 17:04'!resourceType	^#font! !!StrikeFont class methodsFor: '*Tweak-Resources' stamp: 'ar 12/2/2003 21:49'!importXmlResource: xmlNode in: aLoader	^aLoader importFont: xmlNode! !!StrikeFont class methodsFor: '*Tweak' stamp: 'ar 3/27/2004 20:35'!initializeStandardCharacterToGlyphMap	"StrikeFont initializeStandardCharacterToGlyphMap"	(self classPool includesKey: #StandardCharacterToGlyphMap) ifFalse:[		"A quick hack for getting the installation through MC right..."		self addClassVarName: #StandardCharacterToGlyphMap.	].! !!String methodsFor: '*Tweak'!, anObject	^ self copyReplaceFrom: self size + 1		  to: self size		  with: anObject asString! !!String methodsFor: '*Tweak' stamp: 'ar 1/20/2004 03:12'!asXmlString	^self! !!String methodsFor: '*Tweak' stamp: 'ar 12/8/2002 15:48'!base64Decoded	^(Base64MimeConverter mimeDecode: self as: self class)! !!String methodsFor: '*Tweak' stamp: 'ar 12/8/2002 15:48'!base64Encoded	^(Base64MimeConverter mimeEncode: (ReadStream on: self)) contents! !!String methodsFor: '*Tweak' stamp: 'ar 12/8/2002 03:01'!beginsWith: prefix caseSensitive: aBool	"Answer whether the receiver begins with the given prefix string.	The comparison is case-sensitive."	self size < prefix size ifTrue: [^ false].	^ (self findSubstring: prefix in: self startingAt: 1			matchTable: (aBool ifTrue:[CaseSensitiveOrder] ifFalse:[CaseInsensitiveOrder])) = 1! !!String methodsFor: '*Tweak' stamp: 'ar 12/8/2003 22:51'!displayOn: gDev	"Display the receiver on the given DisplayMedium.  5/16/96 sw"	^gDev drawString: self at: 0@0! !!String methodsFor: '*Tweak' stamp: 'ar 12/8/2002 03:01'!endsWith: suffix caseSensitive: aBool	"Answer whether the tail end of the receiver is the same as suffix."	| extra |	(extra _ self size - suffix size) < 0 ifTrue: [^ false].	^ (self findSubstring: suffix in: self startingAt: extra + 1			matchTable: (aBool ifTrue:[CaseSensitiveOrder] ifFalse:[CaseInsensitiveOrder])) > 0! !!String methodsFor: '*Tweak' stamp: 'ar 12/8/2002 03:01'!equals: aString caseSensitive: aBool	^ (self compare: self with: aString collated:		(aBool ifTrue:[CaseSensitiveOrder] ifFalse:[CaseInsensitiveOrder])) = 2! !!String methodsFor: '*Tweak' stamp: 'ar 12/1/2003 20:53'!exportXmlOn: xmlWriter key: aKey	xmlWriter startTag: aKey.	xmlWriter attribute: 'type' value: self class name.	xmlWriter attribute: 'value' value: self.	xmlWriter endEmptyTag: aKey.! !!String methodsFor: '*Tweak' stamp: 'ar 12/16/2002 21:43'!isZipped	| magic1 magic2 |	magic1 _ (self at: 1) asInteger.	magic2 _ (self at: 2) asInteger.	^(magic1 = 16r1F and:[magic2 = 16r8B])! !!String methodsFor: '*Tweak' stamp: 'ar 3/23/2003 18:11'!lessEqual: aString caseSensitive: aBool	^ (self compare: self with: aString collated:		(aBool ifTrue:[CaseSensitiveOrder] ifFalse:[CaseInsensitiveOrder])) <= 2! !!String methodsFor: '*Tweak' stamp: 'ar 9/21/2003 17:28'!serializeOn: aSerializer	^aSerializer writeString: self! !!String methodsFor: '*Tweak' stamp: 'ar 12/15/2002 15:52'!zipped	| zipper |	zipper := GZipWriteStream on: (String new: 1000).	zipper nextPutAll: self.	zipper close.	^zipper encodedStream contents! !!String methodsFor: '*Tweak-Text'!indexOfNextWord: startPosition	"Return the index of the word after startPosition"	| index |	index _ startPosition.	[(index between: 1 and: self size) and: [(self at: index) isAlphaNumeric]]		whileTrue: [index _ index + 1].	[(index between: 1 and: self size) and: [(self at: index) isAlphaNumeric not]]		whileTrue: [index _ index + 1].	^ index! !!String methodsFor: '*Tweak-Text'!indexOfPreviousWord: startPosition	"Return the index of the word before startPosition"	| index |	index _ startPosition.	[(index between: 1 and: self size) and: [(self at: index) isAlphaNumeric not]]		whileTrue: [index _ index - 1].	[(index between: 1 and: self size) and: [(self at: index) isAlphaNumeric]]		whileTrue: [index _ index - 1].	^ index + 1! !!String methodsFor: '*Tweak-Text'!lineSelectionIntervalAt: textPosition	"Return the current line around textPosition"	| left right |	left _ textPosition.	right _ textPosition - 1.	[left > 1 and: [(self at: (left - 1)) ~= Character cr]] whileTrue:		[left _ left - 1].	[right < self size and: [(self at: (right + 1)) ~= Character cr]] whileTrue:		[right _ right + 1].	^left to: (right min: self size)! !!String methodsFor: '*Tweak-Text'!wordSelectionIntervalAt: textPosition	"Return the selection interval for the region at the given text position. Used for double-clicking on text."	| here leftDelimiters rightDelimiters openDelimiter match start direction closeDelimiter stop level hereChar |	here _ textPosition.	"if at beginning or end, select entire string"	(here between: 2 and: self size) ifFalse:[^1 to: self size].	leftDelimiters _ '([{<''"'.	rightDelimiters _ ')]}>''"'.	openDelimiter _ self at: here - 1.	match _ leftDelimiters indexOf: openDelimiter.	match > 0 ifTrue:[		"delimiter is on left -- match to the right"		start _ here.		direction _ 1.		here _ here - 1.		closeDelimiter _ rightDelimiters at: match	] ifFalse:[		openDelimiter _ self at: here.		match _ rightDelimiters indexOf: openDelimiter.		match > 0 ifTrue:[			"delimiter is on right -- match to the left"			stop _ here - 1.			direction _ -1.			closeDelimiter _ leftDelimiters at: match		]ifFalse: [			"no delimiters -- select a token"			direction _ -1.		]	].	level _ 1.	[level > 0 and: [direction > 0			ifTrue: [here < self size]			ifFalse: [here > 1]]] whileTrue:[		hereChar _ self at: (here _ here + direction).		match = 0 ifTrue: [			"token scan goes left, then right"			hereChar tokenish ifTrue: [				here = 1 ifTrue:[					start _ 1.					"go right if hit string start"					direction _ 1.				].			] ifFalse: [				direction < 0 ifTrue:[					start _ here + 1.					"go right if hit non-token"					direction _ 1.				]ifFalse: [level _ 0].			]		] ifFalse: [			"bracket match just counts nesting level"			hereChar = closeDelimiter 				ifTrue: [level _ level - 1"leaving nest"]				ifFalse: [hereChar = openDelimiter 						ifTrue: [level _ level + 1"entering deeper nest"]]].	].	level > 0 ifTrue: ["in case ran off string end"	here _ here + direction].	direction > 0		ifTrue: [^start to: here - 1]		ifFalse: [^here + 1 to: stop].! !!String methodsFor: '*Tweak-HTML' stamp: 'ar 10/1/2003 20:45'!asHtml	"Do the basic character conversion for HTML.  Leave all original return 	and tabs in place, so can conver back by simply removing bracked 	things. 4/4/96 tk"	| temp map |	map := Array new: 256. "all characters"	1 to: 256 do:[:i| map at: i put: (String with: (Character value: i-1))].	#(		($&	'amp')		($<	'lt')		($>	'gt')		($"	'quot')		($	'euro')		($	'auml')		($	'Auml')		($	'ouml')		($	'Ouml')		($	'uuml')		($	'Uuml')		($	'szlig')	) do:[:spec|		map at: spec first asciiValue+1 put: '&',spec last,';'.	].	temp := String streamContents:[:s|		self do:[:ch| s nextPutAll: (map at: ch asciiValue+1)]].	"tabs"	temp _ temp copyReplaceAll: '	' with: '	&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;'.	"CRs"	temp _ temp copyReplaceAll: '' with: '<BR>'.	^ temp"	'A<&>B' asHtml"! !!String class methodsFor: '*Tweak' stamp: 'ar 9/23/2003 22:56'!compare: string1 with: string2	"Compare the two strings (case-insensitive)"	^self compare: string1 with: string2 collated: AsciiOrder! !!String class methodsFor: '*Tweak' stamp: 'ar 9/23/2003 22:55'!compare: string1 with: string2 collated: order	<primitive: 'primitiveCompareString' module: 'MiscPrimitivePlugin'>	^self primitiveFailed! !!Symbol methodsFor: '*Tweak'!asBorder	^CBorder perform: self! !!SystemDictionary methodsFor: '*Tweak' stamp: 'ar 3/27/2004 00:53'!bindingOf: varName	^super bindingOf: varName asSymbol! !!SystemDictionary methodsFor: '*Tweak' stamp: 'ar 12/9/2003 11:18'!condenseChanges		"Smalltalk condenseChanges"	"Move all the changes onto a compacted sources file."	| f oldChanges classCount classes |	f _ FileStream fileNamed: 'ST80.temp'.	f header; timeStamp.	classes := Array streamContents:[:s|		Smalltalk allObjectsDo:[:o| o isBehavior ifTrue:[s nextPut: o]].	].'Condensing Changes File...'	displayProgressAt: Sensor cursorPoint	from: 0 to: classes size	during:		[:bar | classCount _ 0.		classes do:			[:class | bar value: (classCount _ classCount + 1).			class moveChangesTo: f]].	LastQuitLogPosition _ f position.	f trailer; close.	oldChanges _ SourceFiles at: 2.	oldChanges close.	FileDirectory default 		deleteFileNamed: oldChanges name , '.old';		rename: oldChanges name toBe: oldChanges name , '.old';		rename: f name toBe: oldChanges name.	self setMacFileInfoOn: oldChanges name.	SourceFiles at: 2			put: (StandardFileStream oldFileNamed: oldChanges name).! !!SystemDictionary methodsFor: '*Tweak' stamp: 'ar 9/24/2003 11:32'!serializeOn: aSerializer	self == Smalltalk 		ifTrue:[^aSerializer writeGlobal: #Smalltalk].	^super serializeOn: aSerializer! !!SystemOrganizer methodsFor: '*Tweak' stamp: 'ar 9/24/2003 11:32'!serializeOn: aSerializer	self == SystemOrganization		ifTrue:[^aSerializer writeGlobal: #SystemOrganization].	^super serializeOn: aSerializer! !!TTCFont methodsFor: '*Tweak-override' stamp: 'ar 4/4/2004 19:26'!displayString: aString on: aBitBlt from: startIndex to: stopIndex at: aPoint kern: kernDelta	^aBitBlt displayString: aString from: startIndex to: stopIndex at: aPoint ttcFont: self kern: kernDelta! !!Text methodsFor: '*Tweak-Text' stamp: 'tk 6/22/2004 17:48'!embeddedCostumesFrom: start to: stop	"return the list of costumess embedded in me"	"@@@@: Fix this. Ought to be 'embedded objects' all the way down to TextAttribute and this method should not determine whether the embedded object 'isKindOf:' something. :@@@@"	| costumes |	costumes _ IdentitySet new.	runs runsFrom: start to: stop do:[:attribs|		attribs do:[:attr|			attr anchoredObject ifNotNil:[costumes add: attr anchoredObject]]].	^costumes select: [ :m | m isPrimitiveCostume ]! !!Text methodsFor: '*Tweak-Text' stamp: 'ar 6/2/2004 15:23'!emphasis	"Answer the default emphasis set for this text or nil if none has been defined"	| firstCode lastCode |	self size = 0 ifTrue:[^0].	firstCode := 0.	(self attributesAt: 1) do:[:each| firstCode := firstCode bitOr: each emphasisCode].	lastCode := 0.	(self attributesAt: self size) do:[:each| lastCode := lastCode bitOr: each emphasisCode].	^firstCode bitAnd: lastCode! !!Text methodsFor: '*Tweak-Text' stamp: 'ar 4/6/2003 16:10'!font	"Answer the default font set for this text or nil if none has been defined"	(self attributesAt: 1) do:[:each|		each class == TextFontReference ifTrue:[^each font].	].	^nil! !!Text methodsFor: '*Tweak-Text' stamp: 'ar 3/13/2003 04:43'!removeAttributesSuchThat: aBlock	"Remove the attribute over the interval start to stop."	^self removeAttributesSuchThat: aBlock from: 1 to: self size! !!Text methodsFor: '*Tweak-Text' stamp: 'ar 3/13/2003 04:42'!removeAttributesSuchThat: aBlock from: start to: stop 	"Remove the attribute over the interval start to stop."	runs _  runs copyReplaceFrom: start to: stop			with: ((runs copyFrom: start to: stop)				mapValues:				[:attributes | attributes reject: aBlock])! !!Text methodsFor: '*Tweak-HTML' stamp: 'ar 10/1/2003 20:40'!asHtml	^'<html><head></head><body>', self asHtmlFragment,'</body></html>'.! !!Text methodsFor: '*Tweak-HTML' stamp: 'ar 10/1/2003 20:38'!asHtmlFragment	| html offset span |	html := (String new: self size) writeStream.	offset := 0.	runs runsAndValuesDo:[:length :attrs|		attrs do:[:each| each beginHtmlOn: html].		span := string copyFrom: offset+1 to: offset+length.		html nextPutAll: span asHtml.		attrs reverseDo:[:each| each endHtmlOn: html].		offset := offset + length.	].	^html contents! !!Text methodsFor: '*Tweak' stamp: 'ar 1/20/2004 03:19'!asXmlString	| html offset span |	html := (String new: self size) writeStream.	offset := 0.	runs runsAndValuesDo:[:length :attrs|		attrs do:[:each| each beginHtmlOn: html].		span := string copyFrom: offset+1 to: offset+length.		html nextPutAll: span.		attrs reverseDo:[:each| each endHtmlOn: html].		offset := offset + length.	].	^html contents! !!Text methodsFor: '*Tweak' stamp: 'ar 12/8/2003 22:18'!displayOn: gDev	"Display me on the given graphics device"	gDev drawText: self at: 0@0.! !!Text methodsFor: '*Tweak' stamp: 'ar 9/17/2003 17:36'!serializeOn: aSerializer	^aSerializer writeText: self! !!TextAttribute methodsFor: '*Tweak' stamp: 'ar 12/8/2002 12:41'!anchoredObject	^nil! !!TextAttribute methodsFor: '*Tweak' stamp: 'ar 5/5/2004 17:15'!menu	^nil! !!TextAttribute methodsFor: '*Tweak-HTML' stamp: 'ar 10/1/2003 19:39'!beginHtmlOn: aStream	"Begin an HTML fragment on the given stream."! !!TextAttribute methodsFor: '*Tweak-HTML' stamp: 'ar 10/1/2003 19:44'!endHtmlOn: aStream	"End an HTML fragment on the given stream."! !!TextAlignment methodsFor: '*Tweak-HTML' stamp: 'ar 10/1/2003 19:57'!beginHtmlOn: aStream	"Begin an HTML fragment on the given stream."	aStream nextPutAll: '<div align='.	aStream nextPutAll: (#(left right center justify) at: alignment+1).	aStream nextPutAll: '>'.! !!TextAlignment methodsFor: '*Tweak-HTML' stamp: 'ar 10/1/2003 19:58'!endHtmlOn: aStream	"End an HTML fragment on the given stream."	aStream nextPutAll: '</div>'.! !!TextAnchor methodsFor: '*Tweak' stamp: 'ar 12/8/2002 12:42'!anchoredObject	^anchoredMorph! !!TextAnchor methodsFor: '*Tweak' stamp: 'ar 12/8/2002 12:42'!anchoredObject: aCostume	anchoredMorph := aCostume! !!TextColor methodsFor: '*Tweak-HTML' stamp: 'ar 10/1/2003 20:44'!beginHtmlOn: aStream	"Begin an HTML fragment on the given stream."	aStream nextPutAll: '<font color="#'.	aStream nextPutAll: color asHtmlColorRef.	aStream nextPutAll: '">'.! !!TextColor methodsFor: '*Tweak-HTML' stamp: 'ar 10/1/2003 19:59'!endHtmlOn: aStream	"End an HTML fragment on the given stream."	aStream nextPutAll: '</font>'.! !!TextDoIt methodsFor: '*Tweak-HTML' stamp: 'ar 10/1/2003 19:40'!beginHtmlOn: aStream	"Begin an HTML fragment on the given stream."	aStream nextPutAll:'<squeakDoIt>'.! !!TextDoIt methodsFor: '*Tweak-HTML' stamp: 'ar 10/1/2003 19:40'!endHtmlOn: aStream	"End an HTML fragment on the given stream."	aStream nextPutAll:'</squeakDoIt>'.! !!TextEmphasis methodsFor: '*Tweak-HTML' stamp: 'ar 10/1/2003 20:03'!beginHtmlOn: aStream	"Begin an HTML fragment on the given stream."	1 to: 4 do:[:i|		(emphasisCode anyMask: (1 bitShift: i-1))  ifTrue:[			aStream nextPutAll: (#('<b>' '<i>' '<u>' '<s>') at: i).		].	].! !!TextEmphasis methodsFor: '*Tweak-HTML' stamp: 'ar 10/1/2003 20:03'!endHtmlOn: aStream	"End an HTML fragment on the given stream."	1 to: 4 do:[:i|		(emphasisCode anyMask: (1 bitShift: i-1))  ifTrue:[			aStream nextPutAll: (#('</b>' '</i>' '</u>' '</s>') at: i).		].	].! !!TextFontReference methodsFor: '*Tweak-HTML' stamp: 'ar 10/1/2003 20:05'!beginHtmlOn: aStream	"Begin an HTML fragment on the given stream."	aStream nextPutAll: '<font size="'.	aStream print: font height.	aStream nextPutAll: '" face="'.	aStream print: font familyName.	aStream nextPutAll: '">'.! !!TextFontReference methodsFor: '*Tweak-HTML' stamp: 'ar 10/1/2003 20:06'!endHtmlOn: aStream	"End an HTML fragment on the given stream."	aStream nextPutAll: '</font>'.! !!TextLink methodsFor: '*Tweak-HTML' stamp: 'ar 10/1/2003 19:44'!beginHtmlOn: aStream	"Begin an HTML fragment on the given stream."	aStream nextPutAll:'<a squeakRef="'.	aStream nextPutAll: classAndMethod.	aStream nextPutAll:'">'.! !!TextLink methodsFor: '*Tweak-HTML' stamp: 'ar 10/1/2003 19:44'!endHtmlOn: aStream	"End an HTML fragment on the given stream."	aStream nextPutAll:'</a>'.! !!TextMorphEditor methodsFor: '*Tweak' stamp: 'ar 5/5/2004 19:10'!yellowButtonDown: event	"Process a yellow button event. Answer true if the event was handled, false otherwise."	(paragraph attributesAt: event cursorPoint) do:[:attr|		attr menu ifNotNil:[			attr menu openAt: event cursorPoint.			^true]].	^false! !!TextMorphForEditView methodsFor: '*Tweak' stamp: 'ar 5/5/2004 19:11'!mouseDown: event	event yellowButtonPressed ifTrue: [		(editor yellowButtonDown: event) ifTrue:[^self].		^ editView yellowButtonActivity: event shiftPressed].	^ super mouseDown: event! !!TextPrintIt methodsFor: '*Tweak-HTML' stamp: 'ar 10/1/2003 19:40'!beginHtmlOn: aStream	"Begin an HTML fragment on the given stream."	aStream nextPutAll:'<squeakPrintIt>'.! !!TextPrintIt methodsFor: '*Tweak-HTML' stamp: 'ar 10/1/2003 19:41'!endHtmlOn: aStream	"End an HTML fragment on the given stream."	aStream nextPutAll:'</squeakPrintIt>'.! !!TextStyle methodsFor: '*Tweak' stamp: 'ar 6/20/2003 18:58'!fontIndexOfPointSize: desiredHeight	"Returns an index in fontArray of the font with height <= desiredHeight"	"Leading is not inluded in the comparison"	| bestMatch bestIndex d |	bestMatch _ 9999.  bestIndex _ 1.	1 to: fontArray size do:		[:i | d _ desiredHeight - (fontArray at: i) pointSize.		d = 0 ifTrue: [^ i].		(d > 0 and: [d < bestMatch]) ifTrue: [bestIndex _ i. bestMatch _ d]].	^ bestIndex! !!TextStyle methodsFor: '*Tweak' stamp: 'ar 2/3/2002 23:05'!fontOfPointSize: aHeight	"See fontIndexOfSize.	Returns the actual font.  Leading not considered."	^ fontArray at: (self fontIndexOfPointSize: aHeight)! !!TextStyle methodsFor: '*Tweak' stamp: 'ar 4/26/2003 16:27'!marginTabsArray	^marginTabsArray! !!TextStyle class methodsFor: '*Tweak' stamp: 'ar 12/8/2002 01:38'!named: familyName	^ TextConstants at: familyName asSymbol ifAbsent: [TextStyle default]! !!TextURL methodsFor: '*Tweak-HTML' stamp: 'ar 10/1/2003 19:51'!beginHtmlOn: aStream	"Begin an HTML fragment on the given stream."	aStream nextPutAll: '<a href="'.	aStream nextPutAll: url.	aStream nextPutAll: '">'.! !!TextURL methodsFor: '*Tweak-HTML' stamp: 'ar 10/1/2003 19:51'!endHtmlOn: aStream	"End an HTML fragment on the given stream."	aStream nextPutAll:'</a>'.! !!ThirtyTwoBitRegister methodsFor: '*Tweak' stamp: 'ar 3/14/2004 12:41'!asReverseInteger	"Answer the byte-swapped integer value of my current contents."	^ ((low bitAnd: 16rFF) bitShift: 24) +       ((low bitAnd: 16rFF00) bitShift: 8) +	  ((hi bitAnd: 16rFF) bitShift: 8) +       (hi bitShift: -8)! !!ThirtyTwoBitRegister methodsFor: '*Tweak' stamp: 'ar 3/14/2004 12:42'!reverseLoadFrom: aByteArray at: index	"Load my 32-bit value from the four bytes of the given ByteArraystarting at the given index. Consider the first byte to contain the mostsignificant bits of the word (i.e., use big-endian byte ordering)."	hi _ ((aByteArray at: index + 3) bitShift: 8) + ( aByteArray at: index + 2).	low _ ((aByteArray at: index + 1) bitShift: 8) + ( aByteArray at: index).! !!TickMessageSend methodsFor: '*Tweak' stamp: 'ar 9/22/2003 01:11'!readFieldsFrom: deSerializer	super readFieldsFrom: deSerializer.	myTrigger := deSerializer readField: #trigger ifAbsent:[myTrigger].	frequency := deSerializer readField: #frequency ifAbsent:[frequency].! !!TickMessageSend methodsFor: '*Tweak' stamp: 'ar 9/21/2003 22:17'!writeFieldsOn: aSerializer	super writeFieldsOn: aSerializer.	aSerializer writeField: #trigger value: myTrigger.	aSerializer writeField: #frequency value: frequency.! !!Time class methodsFor: '*Tweak' stamp: 'ar 12/2/2003 19:23'!milliseconds	"Answer the number of milliseconds since the last second"	^self millisecondClockValue \\ 1000! !!TweakTestMethodAnalyzer methodsFor: 'initialize-release' stamp: 'bf 3/30/2004 14:09'!dubiousReturnInFieldSetter: method	"A field setter must return its argument. Try to find cases where this might be violated."	| scanner end |	method isQuick ifTrue: [^true].	scanner _ InstructionStream on: method.	end _ method endPC.	dubiousReturn _ false.	[scanner pc <= end]		whileTrue: [			scanner interpretNextInstructionFor: self.			dubiousReturn ifTrue: [^true]].	^false! !!TweakTestMethodAnalyzer methodsFor: 'instruction decoding' stamp: 'bf 3/30/2004 13:53'!methodReturnConstant: value 	"Return Constant bytecode."	dubiousReturn _ true! !!TweakTestMethodAnalyzer methodsFor: 'instruction decoding' stamp: 'bf 3/30/2004 13:53'!methodReturnReceiver	"Return Self bytecode."	dubiousReturn _ true! !!TweakTestMethodAnalyzer methodsFor: 'instruction decoding' stamp: 'bf 3/30/2004 14:12'!methodReturnTop	"Return Top Of Stack bytecode."	"Returning the argument (temp 0) is always okay. All other cases would require further analysis. We don't know, so do not raise a flag here ..."! !!TweakTests methodsFor: 'field tests' stamp: 'bf 3/30/2004 15:23'!testFieldGettersBewareOfAnnotation	"Field getters should have a bewareOf annotation"	| missingAnnotations |	missingAnnotations _ Array streamContents: [:s |		self allFieldGetterMethodsDo: [:cls :sel :meth |			(meth hasProperty: #bewareOf) ifFalse: [				s nextPut: (MethodReference new					setStandardClass: cls 					methodSymbol: sel)]]].	self assert: missingAnnotations isEmpty.		"SystemNavigation default		browseMessageList: missingAnnotations		name: 'Field getters without bewareOf Annotation'		autoSelect: nil"! !!TweakTests methodsFor: 'field tests' stamp: 'bf 3/30/2004 15:24'!testFieldSettersBewareOfAnnotation	"Field setters should not have a bewareOf annotation"	| spuriousAnnotations |	spuriousAnnotations _ Array streamContents: [:s |		self allFieldSetterMethodsDo: [:cls :sel :meth |			(meth hasProperty: #bewareOf) ifTrue: [				s nextPut: (MethodReference new					setStandardClass: cls 					methodSymbol: sel)]]].	self assert: spuriousAnnotations isEmpty.		"SystemNavigation default		browseMessageList: spuriousAnnotations		name: 'Field setters with bewareOf Annotation'		autoSelect: nil"! !!TweakTests methodsFor: 'field tests' stamp: 'bf 3/30/2004 15:32'!testFieldSettersReturn	"Field setters must return their argument. This is because they can be used in an assignment like		var _ field _ aValue	which is compiled as  		var _ self field: aValue	so #field: must return its argument. 		We try to detect some obvious mistakes like [^self] here."		| analyzer dubiousReturns |	analyzer _ TweakTestMethodAnalyzer new.	dubiousReturns _ Array streamContents: [:s |		self allFieldSetterMethodsDo: [:cls :sel :meth |			(analyzer dubiousReturnInFieldSetter: meth) ifTrue: [				s nextPut: (MethodReference new					setStandardClass: cls 					methodSymbol: sel)]]].	self assert: dubiousReturns isEmpty.		"SystemNavigation default		browseMessageList: dubiousReturns		name: 'Field setters with dubious return'		autoSelect: nil"! !!TweakTests methodsFor: 'utilities' stamp: 'bf 3/30/2004 12:22'!allClassesWithFieldsDo: aBlock	CProtoObject withAllSubclassesDo: [:class |		class classFields do: [:field | aBlock value: class value: field]]! !!TweakTests methodsFor: 'utilities' stamp: 'bf 3/30/2004 12:22'!allFieldGetterMethodsDo: aBlock	self allClassesWithFieldsDo: [:class :field |		field toGet ifNotNilDo: [:selector |			class withAllSubclassesDo: [:subclass |				(subclass compiledMethodAt: selector ifAbsent: [nil])					ifNotNilDo: [:method |						aBlock							value: subclass							value: selector							value: method]]]]! !!TweakTests methodsFor: 'utilities' stamp: 'bf 3/30/2004 12:22'!allFieldSetterMethodsDo: aBlock	self allClassesWithFieldsDo: [:class :field |		field toSet ifNotNilDo: [:selector |			class withAllSubclassesDo: [:subclass |				(subclass compiledMethodAt: selector ifAbsent: [nil])					ifNotNilDo: [:method |						aBlock							value: subclass							value: selector							value: method]]]]! !!UUID methodsFor: '*Tweak' stamp: 'ar 12/1/2003 20:54'!exportXmlOn: xmlWriter key: aKey	xmlWriter startTag: aKey.	xmlWriter attribute: 'type' value: 'UUID'.	xmlWriter attribute: 'value' value: self asString.	xmlWriter endEmptyTag: aKey.! !!UUID methodsFor: '*Tweak' stamp: 'ar 9/19/2003 15:34'!serializeOn: aSerializer	^aSerializer writeUUID: self! !!UUID methodsFor: '*Tweak' stamp: 'ar 2/24/2004 16:21'!storeOn: aStream	aStream nextPutAll:'(UUID fromString: '; store: self asString; nextPutAll:')'.! !!UndefinedObject methodsFor: '*Tweak' stamp: 'ar 3/31/2003 21:10'!canUnderstand: aMessage	^false! !!UndefinedObject methodsFor: '*Tweak' stamp: 'ar 3/19/2004 17:37'!displayText	^''! !!UndefinedObject methodsFor: '*Tweak' stamp: 'ar 12/1/2003 20:54'!exportXmlOn: xmlWriter key: aKey	xmlWriter startTag: aKey.	xmlWriter attribute: 'type' value: 'UndefinedObject'.	xmlWriter attribute: 'value' value: 'nil'.	xmlWriter endEmptyTag: aKey.! !!UndefinedObject methodsFor: '*Tweak' stamp: 'ar 3/31/2003 21:04'!includesBehavior: aBehavior	^false! !!UndefinedObject methodsFor: '*Tweak' stamp: 'ar 3/12/2004 18:53'!on: eventName notify: anObserver	"ignore"! !!UndefinedObject methodsFor: '*Tweak' stamp: 'ar 3/12/2004 18:53'!on: eventName unNotify: anObserver	"ignore"! !!UndefinedObject methodsFor: '*Tweak' stamp: 'ar 9/17/2003 17:38'!serializeOn: aSerializer	^aSerializer writeNil: self! !!UpdateLoaderUI methodsFor: 'initialize' stamp: 'ar 5/15/2003 23:56'!initialize	super initialize.	managers := UpdateManager allRegisteredManagers.	managers := managers sort:[:m1 :m2| m1 packageVersion < m2 packageVersion].	managerIndex := 0.	updateInfo := IdentityDictionary new.! !!UpdateLoaderUI methodsFor: 'initialize' stamp: 'ar 5/14/2003 23:22'!managerIndex	^managerIndex! !!UpdateLoaderUI methodsFor: 'initialize' stamp: 'ar 5/14/2003 23:22'!managerIndex: index	managerIndex := index.	self changed: #managerIndex.! !!UpdateLoaderUI methodsFor: 'initialize' stamp: 'ar 5/14/2003 23:22'!openInWorld	self openInWorldExtent: 300@300.! !!UpdateLoaderUI methodsFor: 'initialize' stamp: 'ar 5/14/2003 23:22'!selectedManager	(managerIndex between: 1 and: managers size) ifFalse:[^nil].	^managers at: managerIndex! !!UpdateLoaderUI methodsFor: 'accessing' stamp: 'ar 5/14/2003 23:21'!managerNames	| newly |	^managers collect:[:each| 		String streamContents:[:s|			s nextPutAll: each name; nextPutAll:' ['.			newly := updateInfo at: each ifAbsent:[nil].			newly ifNil:[s nextPutAll: '???'] ifNotNil:[s print: newly].			s nextPutAll: ' new; '.			s print: each loadedUpdates; nextPutAll: ' loaded; #'.			s print: each highestUpdate; nextPutAll: ' highest]'.		].	].! !!UpdateLoaderUI methodsFor: 'actions' stamp: 'ar 5/14/2003 23:23'!loadUpdates	| mgr |	mgr := self selectedManager ifNil:[^self].	mgr loadUpdates.	updateInfo at: mgr put: mgr availableUpdates.	self changed: #managerNames.! !!UpdateLoaderUI methodsFor: 'actions' stamp: 'ar 5/14/2003 23:23'!newUpdateStream	| mgr |	mgr := self selectedManager ifNil:[^self].	(mgr installUpdateStream) ifFalse:[^self].	self updateManagerList! !!UpdateLoaderUI methodsFor: 'actions' stamp: 'ar 5/14/2003 23:23'!publishTestUpdate	| mgr |	mgr := self selectedManager ifNil:[^self].	mgr publishTestUpdate.	self updateManagerList.! !!UpdateLoaderUI methodsFor: 'actions' stamp: 'ar 5/15/2003 23:57'!updateManagerList	managers := UpdateManager allRegisteredManagers.	managers := managers sort:[:m1 :m2| m1 packageVersion < m2 packageVersion].	updateInfo := IdentityDictionary new.	Cursor wait showWhile:[		managers do:[:each|			updateInfo at: each put: each availableUpdates.			self changed: #managerNames.			self world displayWorldSafely.		].	].! !!UpdateLoaderUI methodsFor: 'gui' stamp: 'ar 5/14/2003 23:23'!buildManagerList	| list |	(list _ PluggableListMorph new) 			on: self list: #managerNames			selected: #managerIndex changeSelected: #managerIndex:			menu: #managerMenu: keystroke: #managerKey:from:.	^list! !!UpdateLoaderUI methodsFor: 'gui' stamp: 'ar 5/14/2003 23:23'!createWindow	self addMorph: (self buildManagerList borderWidth: 0)		frame: (0 @ 0 corner: 1 @ 1).	self setUpdatablePanesFrom: #(#managerNames).	self setLabel: 'Update Loader'! !!UpdateLoaderUI methodsFor: 'gui' stamp: 'ar 5/14/2003 23:23'!managerMenu: aMenu	aMenu addList: {		{'update list'. #updateManagerList}.		{'load updates'. #loadUpdates}.		#-.		{'create update stream'. #newUpdateStream}.		{'publish test update'. #publishTestUpdate}.	}.	^aMenu! !!UpdateLoaderUI methodsFor: 'gui' stamp: 'ar 5/14/2003 23:23'!paneColor	^Color magenta mixed: 0.2 with: Color white! !!UpdateLoaderUI methodsFor: 'gui' stamp: 'ar 5/14/2003 23:24'!perform: selector orSendTo: otherTarget 	"Selector was just chosen from a menu by a user. If can respond, then  	perform it on myself. If not, send it to otherTarget, presumably the  	editPane from which the menu was invoked."	(self respondsTo: selector)		ifTrue: [^ self perform: selector]		ifFalse: [^ super perform: selector orSendTo: otherTarget]! !!UpdateLoaderUI class methodsFor: 'initialize' stamp: 'ar 5/14/2003 23:15'!initialize	"UpdateLoaderUI initialize"
	 (TheWorldMenu respondsTo: #registerOpenCommand:)         ifTrue: [TheWorldMenu registerOpenCommand: {'Update Loader'. {self. #open}}].! !!UpdateLoaderUI class methodsFor: 'initialize' stamp: 'ar 5/14/2003 23:15'!removeFromSystem	(TheWorldMenu respondsTo: #registerOpenCommand:) ifTrue: 		[TheWorldMenu unregisterOpenCommand: 'Update Loader'].	super removeFromSystem! !!UpdateLoaderUI class methodsFor: 'opening' stamp: 'ar 5/14/2003 23:24'!open	^self new createWindow openInWorld! !!UpdateManager methodsFor: 'update api' stamp: 'ar 5/15/2003 23:57'!installUpdateStream	"Initialize this update location"	^self subclassResponsibility! !!UpdateManager methodsFor: 'update api' stamp: 'ar 5/14/2003 16:23'!loadUpdates	"Load all available updates"	^self subclassResponsibility! !!UpdateManager methodsFor: 'update api' stamp: 'ar 5/15/2003 23:58'!publishTestUpdate	"publish an update for testing"	| update |	update := FileStream newFileNamed: 'UpdateManagerTestUpdate.cs'.	update timeStamp.	update nextChunkPut: '"Change Set:		UpdateManagerTestUpdateDate:			', Date today printString,'Author:			UpdateManagerTest update posted from UpdateManager."'.	self publishUpdate: update.	update close.	FileDirectory default deleteFileNamed: update fullName.! !!UpdateManager methodsFor: 'update api' stamp: 'ar 5/14/2003 16:23'!publishUpdate: aStream	"Publish an update from the given stream"	^self subclassResponsibility! !!UpdateManager methodsFor: 'queries' stamp: 'ar 5/14/2003 21:05'!availableUpdates	"Answer the number of available, not yet installed updates. This method may query a server for the availability of updates."	^0! !!UpdateManager methodsFor: 'queries' stamp: 'ar 5/14/2003 21:06'!highestUpdate	"Answer the highest update number (patch level) currently installed."	^0! !!UpdateManager methodsFor: 'queries' stamp: 'ar 5/14/2003 21:06'!loadedUpdates	"Answer the number of updates which have been loaded"	^self highestUpdate! !!UpdateManager methodsFor: 'private' stamp: 'ar 3/27/2004 22:35'!inform: queryString	ActiveHand isPlayer ifTrue:[^CDialog inform: queryString].	^super inform: queryString! !!SqueakUpdateStreamManager methodsFor: 'update api' stamp: 'ar 5/14/2003 20:54'!availableUpdates	^self scanServerUpdates size	! !!SqueakUpdateStreamManager methodsFor: 'update api' stamp: 'ar 5/14/2003 19:42'!highestUpdate	"a workaround as we can't keep track of the highest update yet"	| prefix |	prefix := self changeSetPrefix.	^(ChangeSorter allChangeSetNames select:[:csName| csName beginsWith: prefix])		inject: 0 into:[:highest :csName| 			((csName allButFirst: prefix size) initialIntegerOrNil ifNil:[0]) max: highest]! !!SqueakUpdateStreamManager methodsFor: 'update api' stamp: 'ar 5/14/2003 19:43'!highestUpdate: updateNum	"ignore this for now - we should keep track of it somewhere outside the change sets"! !!SqueakUpdateStreamManager methodsFor: 'update api' stamp: 'ar 5/14/2003 16:24'!loadUpdates	^self updateFromServer! !!SqueakUpdateStreamManager methodsFor: 'update api' stamp: 'ar 5/14/2003 20:55'!loadedUpdates	"a workaround as we can't keep track of the highest update yet"	| prefix |	prefix := self changeSetPrefix.	^(ChangeSorter allChangeSetNames select:[:csName| csName beginsWith: prefix])		size! !!SqueakUpdateStreamManager methodsFor: 'update api' stamp: 'ar 5/14/2003 17:32'!publishUpdate: aStream	"Put this file out as an Update on the servers."	uploadUrl ifNil:[^self error: 'no upload url'].	self putUpdate: aStream		on: (ServerDirectory new fullPath: uploadUrl)! !!SqueakUpdateStreamManager methodsFor: 'accessing' stamp: 'ar 5/14/2003 20:10'!changeSetPrefix	"Argh. This needs to bump periods from the package name."	^'[', (self packageVersion copyReplaceAll: '.' with: '-'),']'.! !!SqueakUpdateStreamManager methodsFor: 'accessing' stamp: 'ar 5/14/2003 16:31'!downloadUrl	"Answer the upload URL for the update stream."	^downloadUrl! !!SqueakUpdateStreamManager methodsFor: 'accessing' stamp: 'ar 5/14/2003 16:31'!downloadUrl: aUrlString	"Set the download url for the update stream"	downloadUrl := aUrlString! !!SqueakUpdateStreamManager methodsFor: 'accessing' stamp: 'ar 5/14/2003 20:52'!name	^self packageVersion! !!SqueakUpdateStreamManager methodsFor: 'accessing' stamp: 'ar 5/15/2003 23:46'!packageVersion	"Answer the full package version"	^self subclassResponsibility! !!SqueakUpdateStreamManager methodsFor: 'accessing' stamp: 'ar 5/14/2003 16:07'!updateDownloader	"Redirect this to Utilities for now so as to share a common download process"	^Utilities updateDownloader! !!SqueakUpdateStreamManager methodsFor: 'accessing' stamp: 'ar 5/14/2003 16:07'!updateDownloader: aProcess	"Redirect this to Utilities for now so as to share a common download process"	Utilities updateDownloader: aProcess.! !!SqueakUpdateStreamManager methodsFor: 'accessing' stamp: 'ar 5/14/2003 18:40'!updateUrlLists	"Fake a collection of update urls"	downloadUrl ifNil:[^#()].	^Array with: (Array with: downloadUrl with: (Array with: downloadUrl))! !!SqueakUpdateStreamManager methodsFor: 'accessing' stamp: 'ar 5/14/2003 16:31'!uploadUrl	"Answer the upload URL for the update stream."	^uploadUrl! !!SqueakUpdateStreamManager methodsFor: 'accessing' stamp: 'ar 5/14/2003 16:31'!uploadUrl: aUrlString	"Set the upload url for the update stream"	uploadUrl := aUrlString! !!SqueakUpdateStreamManager methodsFor: 'testing' stamp: 'ar 5/14/2003 20:17'!isUpdateLoaded: updateNum	"Answer whether this update is already loaded"	^updateNum <= self highestUpdate! !!SqueakUpdateStreamManager methodsFor: 'loading updates' stamp: 'ar 5/14/2003 16:50'!chooseUpdateList	"When there is more than one set of update servers, let the user choose which we will update from. Make it so that it will be the first in the updateUrlLists and answer true to proceed, false if user aborts."	downloadUrl ifNil:[^false].	^true! !!SqueakUpdateStreamManager methodsFor: 'loading updates' stamp: 'ar 5/14/2003 16:10'!extractThisVersion: list	"Pull out the part of the list that applies to this version."	| listContents version versIndex |	listContents _ self parseListContents: list.	version _ self packageVersion.	versIndex _ (listContents collect: [:pair | pair first]) indexOf: version.	versIndex = 0 ifTrue: [^ Array new].		"abort"	^ (listContents at: versIndex) last! !!SqueakUpdateStreamManager methodsFor: 'loading updates' stamp: 'ar 5/14/2003 15:47'!lastUpdateNum: updatesFileStrm	"Look in the Updates file and see what the last sequence number is.  Warn the user if the version it is under is not this image's version."	| verIndex seqIndex char ver seqNum |	verIndex _ seqIndex _ 0.	 "last # starting a line and last digit starting a line"	seqNum _ 0.	updatesFileStrm reset; ascii.	[char _ updatesFileStrm next.	 updatesFileStrm atEnd] whileFalse: [		char == Character cr ifTrue: [			updatesFileStrm peek == $# ifTrue: [verIndex _ updatesFileStrm position +1.				seqIndex = 0 ifFalse: ["See if last num of old version if biggest so far"					updatesFileStrm position: seqIndex.					ver _ SmallInteger readFrom: updatesFileStrm.					seqNum _ seqNum max: ver.					updatesFileStrm position: verIndex-1]].			updatesFileStrm peek isDigit ifTrue: [seqIndex _ updatesFileStrm position]]].	seqIndex = 0 ifFalse: ["See if last num of old version if biggest so far"		updatesFileStrm position: seqIndex.		ver _ SmallInteger readFrom: updatesFileStrm.		seqNum _ seqNum max: ver.		updatesFileStrm setToEnd].	^ seqNum! !!SqueakUpdateStreamManager methodsFor: 'loading updates' stamp: 'ar 5/14/2003 19:39'!newChangesFromStream: nextDoc named: updateName	"for now this is a crude hack"	| csName |	csName := self changeSetPrefix, updateName sansPeriodSuffix.	^ChangeSorter newChangesFromStream: nextDoc named: csName! !!SqueakUpdateStreamManager methodsFor: 'loading updates' stamp: 'ar 5/14/2003 20:11'!newUpdatesOn: serverList special: indexPrefix throughNumber: aNumber	"Return a list of fully formed URLs of update files we do not yet have.  Go to the listed servers and look at the file 'updates.list' for the names of the last N update files.  We look backwards for the first one we have, and make the list from there.  tk 9/10/97	No updates numbered higher than aNumber (if it is not nil) are returned " 	| doc list out ff raw char maxNumber itsNumber serverUrl |	maxNumber _ aNumber ifNil: [99999].	out _ OrderedCollection new.	serverList do: [:server |		serverUrl := server.		server last = $/ ifFalse:[serverUrl := serverUrl,'/'].		doc _ HTTPClient httpGet: serverUrl,indexPrefix,'updates.list'.		"test here for server being up"		doc class == RWBinaryOrTextStream ifTrue:			[raw _ doc reset; contents.	"one file name per line"			list _ self extractThisVersion: raw.			list reverseDo: [:fileName |				ff _ (fileName findTokens: '/') last.	"allow subdirectories"				itsNumber _ ff initialIntegerOrNil. 				(self isUpdateLoaded: itsNumber)					ifFalse:[						(itsNumber == nil or: [itsNumber <= maxNumber])							ifTrue:								[out addFirst: serverUrl, fileName]]					ifTrue: [^ out]].			((out size > 0) or: [char _ doc reset; skipSeparators; next.				(char == $*) | (char == $#)]) ifTrue:					[^ out "we have our list"]].	"else got error msg instead of file"		"Server was down, try next one"].	self inform: 'The update server for ', self packageVersion,' seems to be unavailable'.	^ out! !!SqueakUpdateStreamManager methodsFor: 'loading updates' stamp: 'ar 5/14/2003 16:14'!objectStrmFromUpdates: fileName	"Go to the known servers and look for this file in the updates folder.  It is an auxillery file, like .morph or a .gif.  Return a RWBinaryOrTextStream on it.    Meant to be called from during the getting of updates from the server.  That assures that (Utilities serverUrls) returns the right group of servers."	| urls doc |	Cursor wait showWhile:		[urls _ self serverUrls collect: [:url | url, 'updates/', fileName].		urls do: [:aUrl |			doc _ HTTPSocket httpGet: aUrl accept: 'application/octet-stream'.			"test here for server being up"			doc class == RWBinaryOrTextStream ifTrue: [^ doc reset]]].	self inform: 'All update servers are unavailable, or bad file name'.	^ nil! !!SqueakUpdateStreamManager methodsFor: 'loading updates' stamp: 'ar 5/14/2003 15:48'!parseListContents: listContents	| sections vers strm line fileNames |	"Parse the contents of updates.list into {{vers. {fileNames*}}*}, and return it."	sections _ OrderedCollection new.	fileNames _ OrderedCollection new: 1000.	vers _ nil.	strm _ ReadStream on: listContents.	[strm atEnd] whileFalse:		[line _ strm upTo: Character cr.		line size > 0 ifTrue:			[line first = $#				ifTrue: [vers ifNotNil: [sections addLast: {vers. fileNames asArray}].						"Start a new section"						vers _ line allButFirst.						fileNames resetTo: 1]				ifFalse: [line first = $* ifFalse: [fileNames addLast: line]]]].	vers ifNotNil: [sections addLast: {vers. fileNames asArray}].	^ sections asArray" TEST: | list |list _ Utilities parseListContents: (FileStream oldFileNamed: 'updates.list') contentsOfEntireFile.list = (Utilities parseListContents: (String streamContents: [:s | Utilities writeList: list toStream: s]))	ifFalse: [self error: 'test failed']	ifTrue: [self inform: 'test OK']"! !!SqueakUpdateStreamManager methodsFor: 'loading updates' stamp: 'ar 5/14/2003 15:48'!position: updateStrm atVersion: version	"Set the stream to the end of the last line of updates names for this version.  Usually the end of the file.  We will add a new update name.   Return the contents of the rest of the file."	| char foundIt where data |	updateStrm reset; ascii.	foundIt _ false.	[char _ updateStrm next.	 updateStrm atEnd] whileFalse: [		(char == Character cr or: [char == Character lf]) ifTrue: [			updateStrm peek == $# ifTrue: [				foundIt ifTrue: ["Next section"					where _ updateStrm position.					data _ updateStrm upTo: (255 asCharacter).					updateStrm position: where.					^ data].	"won't be found -- copy all the way to the end"				updateStrm next.				(updateStrm nextMatchAll: version) ifTrue: [					(updateStrm atEnd or: [(updateStrm peek = Character cr) | 						(updateStrm peek = Character lf)]) ifTrue: [							foundIt _ true					]]]]].	foundIt ifTrue: [		updateStrm setToEnd.		^ ''].	self error: 'The current version does not have a section in the Updates file'.! !!SqueakUpdateStreamManager methodsFor: 'loading updates' stamp: 'ar 5/14/2003 16:14'!readNextUpdateFromServer	"Utilities readNextUpdateFromServer"	self updateFromServerThroughUpdateNumber: (self highestUpdate + 1)! !!SqueakUpdateStreamManager methodsFor: 'loading updates' stamp: 'ar 5/14/2003 16:15'!readNextUpdatesFromDisk: n	"Read the updates up through the current highest-update-number plus n.  Thus, 	Utilities readNextUpdatesFromDisk: 7will read the next seven updates from disk"	self applyUpdatesFromDiskToUpdateNumber: self highestUpdate + n		stopIfGap: false! !!SqueakUpdateStreamManager methodsFor: 'loading updates' stamp: 'ar 5/14/2003 21:42'!readServer: serverList special: indexPrefix updatesThrough: maxNumber saveLocally: saveLocally updateImage: updateImage	"Scan the update server(s) for unassimilated updates. If maxNumber is not nil, it represents the highest-numbered update to load.  This makes it possible to update only up to a particular point.   If saveLocally is true, then save local copies of the update files on disc.  If updateImage is true, then absorb the updates into the current image.""UpdateManager default readServer: Utilities serverUrls updatesThrough: 828 saveLocally: true updateImage: true"	| urls failed loaded docQueue this nextDoc docQueueSema str updateName |	Cursor wait showWhile: [	loaded _ 0.	failed _ nil.	urls _ self newUpdatesOn: serverList				special: indexPrefix				throughNumber: maxNumber.	urls isEmpty ifTrue:[^Array with: failed with: loaded].	"send downloaded documents throuh this queue"	docQueue := SharedQueue new.	"this semaphore keeps too many documents from beeing queueed up at a time"	docQueueSema := Semaphore new.	5 timesRepeat: [ docQueueSema signal ].	"fork a process to download the updates"	self retrieveUrls: urls ontoQueue: docQueue withWaitSema: docQueueSema.	"process downloaded updates in the foreground"	[ this _ docQueue next.	  nextDoc _ docQueue next.  	  nextDoc = #failed ifTrue: [ failed _ this ].	  (failed isNil and: [ nextDoc ~= #finished ])	] whileTrue: [		failed ifNil: [			nextDoc reset; text.			nextDoc size = 0 ifTrue: [ failed _ this ]. ].		failed ifNil: [			nextDoc peek asciiValue = 4	"pure object file"				ifTrue: [failed _ this]].	"Must be fileIn, not pure object file"		failed ifNil: [			"(this endsWith: '.html') ifTrue: [doc _ doc asHtml]."				"HTML source code not supported here yet"			updateImage				ifTrue: [					updateName _ (this findTokens: '/') last.					self newChangesFromStream: nextDoc named: updateName.					self registerUpdate: updateName initialIntegerOrNil].			saveLocally ifTrue:				[self saveUpdate: nextDoc onFile: (this findTokens: '/') last].	"if wanted"			loaded _ loaded + 1].		docQueueSema signal].	].	failed ~~ nil & (urls size - loaded > 0) ifTrue: [		str _ loaded printString ,' new update file(s) processed.'.		str _ str, '\Could not load ' withCRs, 			(urls size - loaded) printString ,' update file(s).',			'\Starting with "' withCRs, failed, '".'.		self inform: str].	^ Array with: failed with: loaded! !!SqueakUpdateStreamManager methodsFor: 'loading updates' stamp: 'ar 5/14/2003 15:48'!readServerUpdatesSaveLocally: saveLocally updateImage: updateImage	^ self readServerUpdatesThrough: nil saveLocally: saveLocally updateImage: updateImage! !!SqueakUpdateStreamManager methodsFor: 'loading updates' stamp: 'ar 5/14/2003 16:17'!readServerUpdatesThrough: maxNumber saveLocally: saveLocally updateImage: updateImage	"Scan the update server(s) for unassimilated updates. If maxNumber is not nil, it represents the highest-numbered update to load.  This makes it possible to update only up to a particular point.   If saveLocally is true, then save local copies of the update files on disc.  If updateImage is true, then absorb the updates into the current image.A file on the server called updates.list has the names of the last N update files.  We look backwards for the first one we do not have, and start there""* To add a new update:  Name it starting with a new two-digit code.  * Do not use %, /, *, space, or more than one period in the name of an update file.* The update name does not need to have any relation to the version name.* Figure out which versions of the system the update makes sense for.* Add the name of the file to each version's category below.* Put this file and the update file on all of the servers.** To make a new version of the system:  Pick a name for it (no restrictions)* Put # and exactly that name on a new line at the end of this file.* During the release process, fill in exactly that name in the dialog box.* Put this file on the server.""When two sets of updates need to use the same directory, one of them has a * in its serverUrls description.  When that is true, the first word of the description is put onthe front of 'updates.list', and that is the index file used.""Utilities readServerUpdatesThrough: 3922 saveLocally: true updateImage: true"	| failed loaded str res servers triple tryAgain indexPrefix |	self chooseUpdateList ifFalse: [^ self].	"ask the user which kind of updates"	servers _ self serverUrls copy.	indexPrefix _ (self updateUrlLists first first includes: $*) 		ifTrue: [(self updateUrlLists first first findTokens: ' ') first]						"special for internal updates"		ifFalse: ['']. 	"normal"	[servers isEmpty] whileFalse: [		triple _ self readServer: servers special: indexPrefix 					updatesThrough: maxNumber 					saveLocally: saveLocally updateImage: updateImage.		"report to user"		failed _ triple first.		loaded _ triple second.		tryAgain _ false.		failed ifNil: ["is OK"			loaded = 0 ifTrue: ["found no updates"				servers size > 1 ifTrue: ["not the last server"					res _ PopUpMenu withCaption: 'No new updates on the server', servers first, 'Would you like to try the next server?(Normally, all servers are identical, but sometimes aserver won''t let us store new files, and gets out of date.)' 						chooseFrom: 'Stop looking\Try next server'.					res = 2 ifFalse: [^ self]						 ifTrue: [servers _ servers allButFirst.	"try the next server"							tryAgain _ true]]]].		tryAgain ifFalse: [			str _ loaded printString ,' new update file(s) processed.'.			^ self inform: str].	].! !!SqueakUpdateStreamManager methodsFor: 'loading updates' stamp: 'ar 5/14/2003 16:47'!registerUpdate: updateNum	updateNum > self highestUpdate ifTrue:[		self highestUpdate: updateNum.	].! !!SqueakUpdateStreamManager methodsFor: 'loading updates' stamp: 'ar 5/14/2003 15:49'!retrieveUrls: urls ontoQueue: queue withWaitSema: waitSema 	"download the given list of URLs. The queue will be loaded alternately  	with url's and with the retrieved contents. If a download fails, the  	contents will be #failed. If all goes well, a special pair with an empty  	URL and the contents #finished will be put on the queue. waitSema is  	waited on every time before a new document is downloaded; this keeps 	the downloader from getting too far  ahead of the main process"	"kill the existing downloader if there is one"	| doc canPeek front |	self updateDownloader		ifNotNil: [self updateDownloader terminate].	"fork a new downloading process"	self updateDownloader: [urls				do: [:url | 					waitSema wait.					queue nextPut: url.					doc _ HTTPClient httpGet: url.					doc class == String						ifTrue: [queue nextPut: #failed.							self updateDownloader: nil.							Processor activeProcess terminate]						ifFalse: [canPeek _ 120 min: doc size.							front _ doc next: canPeek.  doc skip: -1 * canPeek.							(front beginsWith: '<!!DOCTYPE') ifTrue: [								(front includesSubString: 'Not Found') ifTrue: [									queue nextPut: #failed.									self updateDownloader: nil.									Processor activeProcess terminate]]].						self updateDownloader ifNotNil: [queue nextPut: doc]].			queue nextPut: ''.			queue nextPut: #finished.			self updateDownloader: nil] newProcess.	self updateDownloader priority: Processor userInterruptPriority.	"start the process running"	self updateDownloader resume! !!SqueakUpdateStreamManager methodsFor: 'loading updates' stamp: 'ar 5/14/2003 19:22'!saveUpdate: doc onFile: fileName	"Save the update on a local file.  With or without the update number on the front, depending on the preference #updateRemoveSequenceNum"	| file fName pos updateDirectory |	updateDirectory _ self getUpdateDirectory.	updateDirectory assureExistence.	fName _ fileName.	(Preferences valueOfFlag: #updateRemoveSequenceNum) ifTrue:		[pos _ fName findFirst: [:c | c isDigit not].		fName _ fName copyFrom: pos to: fName size].	doc reset; ascii.	(updateDirectory fileExists: fName) ifFalse:		[file _ updateDirectory newFileNamed: fName.		file nextPutAll: doc contents.		file close].! !!SqueakUpdateStreamManager methodsFor: 'loading updates' stamp: 'ar 5/14/2003 19:46'!scanServerUpdates	"Scan the update server(s) for unassimilated updates.	Answer a list of urls for updates not having been loaded."	| servers indexPrefix |	servers _ self serverUrls copy.	self updateUrlLists size = 0 ifTrue:[^#()].	indexPrefix _ (self updateUrlLists first first includes: $*) 		ifTrue: [(self updateUrlLists first first findTokens: ' ') first]						"special for internal updates"		ifFalse: ['']. 	"normal"	^self newUpdatesOn: servers				special: indexPrefix				throughNumber: SmallInteger maxVal.! !!SqueakUpdateStreamManager methodsFor: 'loading updates' stamp: 'ar 5/14/2003 16:48'!serverUrls 	"Redirect this to Utilities where the updates used to live"	self downloadUrl ifNil:[^#()].	^Array with: self downloadUrl! !!SqueakUpdateStreamManager methodsFor: 'loading updates' stamp: 'ar 5/14/2003 15:52'!updateFromServer	"Update the image by loading all pending updates from the server.  Also save local copies of the update files if the #updateSavesFile preference is set to true"	self readServerUpdatesSaveLocally: Preferences updateSavesFile updateImage: true! !!SqueakUpdateStreamManager methodsFor: 'loading updates' stamp: 'ar 5/14/2003 15:52'!updateFromServerThroughUpdateNumber: aNumber	"Update the image by loading all pending updates from the server.  Also save local copies of the update files if the #updateSavesFile preference is set to true"	self readServerUpdatesThrough: aNumber saveLocally: Preferences updateSavesFile updateImage: true! !!SqueakUpdateStreamManager methodsFor: 'storing updates' stamp: 'ar 5/14/2003 16:20'!broadcastUpdatesFrom: n1 to: n2 except: skipList"	Note:  This method takes its list of files from the directory named 'updates',	which will have been created and filled by, eg,		Utilities readServerUpdatesSaveLocally: true updateImage: true.	These can then be rebroadcast to any server using, eg,		Utilities broadcastUpdatesFrom: 1 to: 9999 except: #(223 224).	If the files are already on the server, and it is only a matter	of copying them to the index for a different version, then use...		(ServerDirectory serverInGroupNamed: 'SqC Internal Updates*')			exportUpdatesExcept: #()."	| fileNames fileNamesInOrder names choice file updateDirectory |	updateDirectory _ FileDirectory default directoryNamed: 'updates'.	fileNames _ updateDirectory fileNames select:		[:n | n first isDigit			and: [(n initialIntegerOrNil between: n1 and: n2)			and: [(skipList includes: n initialIntegerOrNil) not]]].	(file _ fileNames select: [:n | (n occurrencesOf: $.) > 1]) size > 0		ifTrue: [self halt: file first , ' has multiple periods'].	fileNamesInOrder _ fileNames asSortedCollection:		[:a :b | a initialIntegerOrNil < b initialIntegerOrNil].	names _ ServerDirectory groupNames asSortedArray.	choice _ (SelectionMenu labelList: names selections: names) startUp.	choice == nil ifTrue: [^ self].	self putUpdateMulti: fileNamesInOrder 		fromDirectory: updateDirectory		onto: (ServerDirectory serverInGroupNamed: choice)! !!SqueakUpdateStreamManager methodsFor: 'storing updates' stamp: 'ar 5/14/2003 15:53'!checkNames: list	"Look at these names for update and see if they are OK"list do: [:local |	(local count: [:char | char == $.]) > 1 ifTrue: [		self inform: 'File name ',local,'may not have more than one period'.	^ false].	local size > 26 ifTrue: ["allows for 5 digit update numbers"		self inform: 'File name ',local,'is too long.  Please rename it.'.	^ false].	(local at: 1) isDigit ifTrue: [		self inform: 'File name ',local,'may not begin with a number'.	^ false].	(local findDelimiters: '%/* ' startingAt: 1) <= local size ifTrue: [		self inform: 'File name ',local,'may not contain % / * or space'.	^ false]].^ true! !!SqueakUpdateStreamManager methodsFor: 'storing updates' stamp: 'ar 3/27/2004 22:12'!checkServers: aGroup withPrefix: prefix andParseListInto: listBlock	"Check that all servers are up and have the latest Updates.list.	Warn user when can't write to a server that can still be read.	The contents of updates.list is parsed into {{vers. {fileNames*}}*},	and returned via the listBlock."	| final fileSize this serverList listContents decided myContents abort |	serverList _ aGroup.	final _ OrderedCollection new.	fileSize _ 0.  listContents _ ''.	"list of updates"	abort _ false.	serverList do: [:aServer |		decided _ false.		this _ [aServer getFileNamed: prefix , 'updates.list'] on: Error do:[:ex|			Transcript cr; show: ex.			ex return: nil].		this ifNil:[^#()].		(this isKindOf: RWBinaryOrTextStream) ifTrue:[			this := this ascii contents.		].		decided not & (this size > fileSize) ifTrue:			["new has a longer update.list"			fileSize _ this size.			final do: [:each | abort _ self outOfDate: each].			(final _ OrderedCollection new) add: aServer.			listContents _ this.			listBlock value: (self parseListContents: listContents).			decided _ true].		decided not & (this size < fileSize) ifTrue:			[abort _ self outOfDate: aServer.  decided _ true].		decided not ifTrue:			[myContents _ this.			myContents = listContents				ifTrue: [final add: aServer]				ifFalse: [abort _ self outOfDate: aServer]].		abort ifTrue: [^ Array new].		].	^ final! !!SqueakUpdateStreamManager methodsFor: 'storing updates' stamp: 'ar 5/14/2003 23:31'!installUpdateStream	"Set up a new update stream, e.g., post an update.list with the appropriate contents."	| myServers updateStrm listContents version versIndex aServer |	aServer := ServerDirectory new fullPath: uploadUrl.	myServers _ self checkServers: aServer serversInGroup		withPrefix: ''		andParseListInto: [:x | listContents _ x].	listContents ifNil:[listContents := #()].	version _ self packageVersion.	versIndex _ (listContents collect: [:pair | pair first]) indexOf: version.	versIndex = 0 ifFalse:[		self inform: 'An update stream for ', self packageVersion,' already exists at', self uploadUrl.		^false	].	myServers size = 0 ifFalse:[		| msg |		msg := String streamContents:[:s|			s nextPutAll: 'It looks as if there is an update stream already at'; cr.			s nextPutAll: uploadUrl; cr.			s nextPutAll:' It currently contains '.			s print: (listContents collect:[:pair| pair first]); cr.		].		(PopUpMenu confirm: msg			trueChoice: 'Proceed - add an entry for ', self packageVersion			falseChoice: 'Abort - I got something wrong with the location.') ifFalse:[^false].	].	"Append new version to updates following my version"	listContents _ listContents copyWith: {self packageVersion. {}}.	updateStrm _ ReadStream on:		(String streamContents: [:s | self writeList: listContents toStream: s]).	updateStrm reset.	aServer putFile: updateStrm named: 'updates.list'.	Transcript cr; show: self packageVersion, ': updates.list written on server ', aServer moniker.	aServer closeGroup.	(self confirm: (self packageVersion,' now has its update stream at\', 					self uploadUrl,					'\Do you want me to post an initial update (for testing)?') withCRs)		ifFalse:[^true].	self publishTestUpdate.	^true! !!SqueakUpdateStreamManager methodsFor: 'storing updates' stamp: 'ar 5/14/2003 15:54'!outOfDate: aServer	"Inform the user that this server does not have a current version of 'Updates.list'  Return true if the user does not want any updates to happen."| response |response _ (PopUpMenu labels: 'Install on others\Cancel entire update' withCRs)		startUpWithCaption: 'The server ', aServer moniker, ' is not up to date.Please store the missing updates maually.'.^ response ~= 1! !!SqueakUpdateStreamManager methodsFor: 'storing updates' stamp: 'ar 5/14/2003 23:07'!putUpdate: fileStrm on: aServer	"Put this file out as an Update on the servers of my group.  Each version of the system may have its own set of update files, or they may all share the same files.  'updates.list' holds the master list.  Each update is a fileIn whose name begins with a number.  See readServerUpdatesThrough:saveLocally:updateImage:.	When two sets of updates are stored on the same directory, one of them has a * in its serverUrls description.  When that is true, the first word of the description is put onthe front of 'updates.list', and that index file is used."	| myServers updateStrm newName response localName seq indexPrefix listContents version versIndex lastNum stripped |	localName _ fileStrm localName.	fileStrm size = 0 ifTrue:		[^ self inform: 'That file has zero bytes!!  May have a new name.'].	(fileStrm contentsOfEntireFile includes: Character linefeed)		ifTrue: [self notifyWithLabel:  'That file contains linefeeds.  Proceed if...you know that this is okay (e.g. the file contains raw binary data).'].	fileStrm reset.	(self checkNames: {localName}) ifFalse: [^ nil].	"illegal characters"	response _ (PopUpMenu labels: 'Install update\Cancel update' withCRs)		startUpWithCaption: 'Do you really want to broadcast the file ', localName, 			'\for every user of ' withCRs, self packageVersion, '?'.	response = 1 ifFalse: [^ nil].	"abort"	aServer openGroup.	indexPrefix _ (aServer groupName includes: $*) 		ifTrue: [(aServer groupName findTokens: ' ') first]	"special for internal updates"		ifFalse: ['']. 	"normal"	myServers _ self checkServers: aServer serversInGroup withPrefix: indexPrefix					andParseListInto: [:x | listContents _ x].	myServers size = 0 ifTrue: [aServer closeGroup.  ^ self].	version _ self packageVersion.	versIndex _ (listContents collect: [:pair | pair first]) indexOf: version.	versIndex = 0 ifTrue:		[self inform: 'There is no section in updates.list for your version'.		aServer closeGroup.  ^ nil].	"abort"	"A few affirmations..."	versIndex < listContents size ifTrue:		[(self confirm: 'This system, ', version ,				' is not the latest version.\Make update for an older version?' withCRs)			ifFalse: [aServer closeGroup.  ^ nil]].	"abort"	(listContents at: versIndex) last isEmpty ifTrue:		[(self confirm: 'Please confirm that you mean to issue the first update for ' ,						version , '\(otherwise something is wrong).' withCRs)			ifFalse: [aServer closeGroup.  ^ nil]].	"We now determine next update number to be max of entire index"	lastNum _ listContents inject: 0 into:		[:max :pair | pair last isEmpty					ifTrue: [max]					ifFalse: [max max: (pair last last initialIntegerOrNil ifNil:[0])]].	"Save old copy of updates.list on local disk"	FileDirectory default deleteFileNamed: indexPrefix , 'updates.list.bk'.	self writeList: listContents toStream: (FileStream fileNamed: self packageVersion,'-',indexPrefix , 'updates.list.bk').	"append name to updates with new sequence number"	seq _ (lastNum + 1) printString padded: #left to: 4 with: $0.	"strip off any old seq number"	stripped _ localName copyFrom: (localName  findFirst: [:c | c isDigit not]) to: localName size.	newName _ seq , stripped.	listContents at: versIndex put:		{version. (listContents at: versIndex) last copyWith: newName}.	"Write a new copy on all servers..."	updateStrm _ ReadStream on:		(String streamContents: [:s | self writeList: listContents toStream: s]).	myServers do:		[:server |		fileStrm reset.	"reopen"		server putFile: fileStrm named: newName retry: true.		updateStrm reset.		server putFile: updateStrm named: indexPrefix , 'updates.list' retry: true.		Transcript show: 'Update succeeded on server ', server moniker; cr].	aServer closeGroup.			Transcript cr; show: 'Be sure to test your new update!!'; cr.	"rename the file locally (may fail)"	[fileStrm directory rename: localName toBe: newName] on: Error do:[:ex| ex return].! !!SqueakUpdateStreamManager methodsFor: 'storing updates' stamp: 'ar 5/14/2003 18:32'!putUpdateMulti: list fromDirectory: updateDirectory onto: aServer	"Put these files out as an Update on the servers of my group.  List is an array of local file names with or without number prefixes.  Each version of the system has its own set of update files.  'updates.list' holds the master list.  Each update is a fileIn whose name begins with a number.  See Utilities class absorbUpdatesFromServer."	| myServers updateStrm lastNum response newNames file numStr indexPrefix listContents version versIndex seq stripped |	(self checkNames: (list collect: "Check the names without their numbers"		[:each | each copyFrom: (each findFirst: [:c | c isDigit not]) to: each size]))		ifFalse: [^ nil].	response _ (PopUpMenu labels: 'Install update\Cancel update' withCRs)		startUpWithCaption: 'Do you really want to broadcast ', list size printString, ' updates',			'\to every Squeak user who updates from ' withCRs, aServer groupName, '?'.	response = 1 ifFalse: [^ nil].	"abort"	aServer openGroup.	indexPrefix _ (aServer groupName includes: $*) 		ifTrue: [(aServer groupName findTokens: ' ') first]	"special for internal updates"		ifFalse: ['']. 	"normal"	myServers _ self checkServers: aServer serversInGroup withPrefix: indexPrefix					andParseListInto: [:x | listContents _ x].	myServers size = 0 ifTrue: [aServer closeGroup.  ^ self].	version _ self packageVersion printString.	versIndex _ (listContents collect: [:pair | pair first]) indexOf: version.	versIndex = 0 ifTrue:		[self inform: 'There is no section in updates.list for your version'.		aServer closeGroup.  ^ nil].	"abort"	lastNum _ (listContents at: versIndex) last last initialIntegerOrNil.	versIndex < listContents size ifTrue:		[response _ (PopUpMenu labels: 'Make update for an older version\Cancel update' withCRs)			startUpWithCaption: 'This package, ', version,				' is not the latest version'.		response = 1 ifFalse: [aServer closeGroup.  ^ nil].		numStr _ FillInTheBlank 			request: 'Please confirm or change the starting update number' 			initialAnswer: (lastNum+1) printString.		lastNum _ numStr asNumber - 1].	"abort"	"Save old copy of updates.list on local disk"	FileDirectory default deleteFileNamed: indexPrefix , 'updates.list.bk'.	self writeList: listContents toStream: (FileStream fileNamed: indexPrefix , 'updates.list.bk').	"Append names to updates with new sequence numbers"	newNames _ list with: (lastNum+1 to: lastNum+list size) collect:		[:each :num | seq _ num printString padded: #left to: 4 with: $0.		"strip off any old seq number"		stripped _ each copyFrom: (each  findFirst: [:c | c isDigit not]) to: each size.		seq , stripped].	listContents at: versIndex put:		{version. (listContents at: versIndex) second , newNames}.	"Write a new copy on all servers..."	updateStrm _ ReadStream on:		(String streamContents: [:s | self writeList: listContents toStream: s]).	myServers do:		[:server |		list doWithIndex: [:local :ind |			file _ updateDirectory oldFileNamed: local.			server putFile: file named: (newNames at: ind) retry: true.			file close].		updateStrm reset.		server putFile: updateStrm named: indexPrefix , 'updates.list' retry: true.		Transcript show: 'Update succeeded on server ', server moniker; cr].	aServer closeGroup.	Transcript cr; show: 'Be sure to test your new update!!'; cr.	"rename the file locally"	list with: newNames do:		[:local :newName | updateDirectory rename: local toBe: newName].! !!SqueakUpdateStreamManager methodsFor: 'storing updates' stamp: 'ar 5/14/2003 18:32'!updateInstallVersion: newVersion	"For each server group, ask whether we want to put the new version marker (eg 'Squeak2.3') at the end of the file.  Current version of Squeak must be the old one when this is done.		ServerDirectory new updateInstallVersion: 'Squeak9.9test'"	| myServers updateStrm names choice indexPrefix listContents version versIndex |	[names _ ServerDirectory groupNames asSortedArray.	choice _ (SelectionMenu labelList: names selections: names) startUp.	choice == nil]		whileFalse:		[indexPrefix _ (choice endsWith: '*') 			ifTrue: [(choice findTokens: ' ') first]	"special for internal updates"			ifFalse: ['']. 	"normal"		myServers _ self checkServers: (ServerDirectory serverInGroupNamed: choice) serversInGroup						withPrefix: indexPrefix						andParseListInto: [:x | listContents _ x].		myServers size = 0 ifTrue: [^ self].		version _ self packageVersion printString.		versIndex _ (listContents collect: [:pair | pair first]) indexOf: version.		versIndex = 0 ifTrue:			[^ self inform: 'There is no section in updates.list for your version'].  "abort"		"Append new version to updates following my version"		listContents _ listContents copyReplaceFrom: versIndex+1 to: versIndex with: {{newVersion. {}}}.		updateStrm _ ReadStream on:			(String streamContents: [:s | self writeList: listContents toStream: s]).		myServers do:			[:aServer | updateStrm reset.			aServer putFile: updateStrm named: indexPrefix ,'updates.list'.			Transcript cr; show: indexPrefix ,'updates.list written on server ', aServer moniker].		self closeGroup]! !!SqueakUpdateStreamManager methodsFor: 'storing updates' stamp: 'ar 3/27/2004 22:28'!writeList: listContents toStream: strm	"Write a parsed updates.list out as text.	This is the inverse of parseListContents:"	| fileNames version |	strm reset.	listContents do:		[:pair | version _ pair first.  fileNames _ pair last.		strm nextPut: $#; nextPutAll: version; cr.		fileNames do: [:fileName | strm nextPutAll: fileName; cr]].	strm close! !!SqueakUpdateStreamManager methodsFor: 'updates from disk' stamp: 'ar 5/14/2003 19:22'!applyUpdatesFromDisk	"Utilities applyUpdatesFromDisk"	"compute highest update number"	| updateDirectory updateNumbers |	updateDirectory _ self getUpdateDirectory.	updateNumbers _ updateDirectory fileNames				collect: [:fn | fn initialIntegerOrNil]				thenSelect: [:fn | fn notNil].	self		applyUpdatesFromDiskToUpdateNumber: (updateNumbers				inject: 0				into: [:max :num | max max: num])		stopIfGap: false! !!SqueakUpdateStreamManager methodsFor: 'updates from disk' stamp: 'ar 5/14/2003 19:27'!applyUpdatesFromDiskToUpdateNumber: lastUpdateNumber stopIfGap: stopIfGapFlag 	"To use this mechanism, be sure all updates you want to have considered 	are in a folder named 'updates' which resides in the same directory as  	your image. Having done that, simply evaluate:  	 	Utilities applyUpdatesFromDiskToUpdateNumber: 1234 stopIfGap: false  	 	and all numbered updates <= lastUpdateNumber not yet in the image will 	be loaded in numerical order."	| previousHighest currentUpdateNumber done fileNames aMessage updateDirectory loaded |	updateDirectory _ self getUpdateDirectory.	previousHighest _ self highestUpdate.	currentUpdateNumber _ previousHighest.	done _ false.	loaded _ 0.	[done] whileFalse: [		currentUpdateNumber _ currentUpdateNumber + 1.		currentUpdateNumber > lastUpdateNumber			ifTrue: [done _ true]			ifFalse: [fileNames _ updateDirectory fileNamesMatching: (currentUpdateNumber printString padded: #left to: 4 with: $0) , '*'.					fileNames size > 1						ifTrue: [^ self inform: 'ambiguity -- two files both start with ' , currentUpdateNumber printString , '(at this point it is probably best to remedythe situation on disk, then try again.)'].					fileNames size == 0						ifTrue: [Transcript cr; show: 'gap in updates from disk for update number '; print: currentUpdateNumber; show: ' found...'.							done _ stopIfGapFlag]						ifFalse: [self								newChangesFromStream: (updateDirectory readOnlyFileNamed: fileNames first)								named: fileNames first.							self registerUpdate: currentUpdateNumber.							loaded _ loaded + 1]]].	aMessage _ loaded = 0				ifTrue: ['No new updates found.']				ifFalse: [loaded printString , ' update(s) loaded.'].	self inform: aMessage , 'Highest numbered update is now ' , (currentUpdateNumber - 1) printString , '.'! !!SqueakUpdateStreamManager methodsFor: 'updates from disk' stamp: 'ar 5/14/2003 15:47'!fileInFromUpdatesFolder: numberList	"File in a series of updates with the given updates numbers, from the updates folder in the default directory.  The file-ins are done in numeric order, even if numberList was not sorted upon entry.	This is useful for test-driving the retrofitting of a possibly discontinguous list of updates from an alpha version back to a stable release.	Utilities fileInFromUpdatesFolder: #(4745 4746 4747 4748 4749 4750 4751 4752 4754 4755 4761 4762 4767 4769)."	| fileNames fileNamesInOrder file updateDirectory |	updateDirectory _ FileDirectory default directoryNamed: 'updates'.	fileNames _ updateDirectory fileNames select:		[:n | n first isDigit			and: [numberList includes: n initialIntegerOrNil]].	(file _ fileNames select: [:n | (n occurrencesOf: $.) > 1]) size > 0		ifTrue: [self error: file first , ' has multiple periods'].	fileNamesInOrder _ fileNames asSortedCollection:		[:a :b | a initialIntegerOrNil < b initialIntegerOrNil].	fileNamesInOrder do:		[:aFileName | (updateDirectory readOnlyFileNamed: aFileName) fileIntoNewChangeSet]! !!SqueakUpdateStreamManager methodsFor: 'updates from disk' stamp: 'ar 5/14/2003 19:22'!getUpdateDirectory	^((FileDirectory default directoryNamed: 'updates') directoryNamed: self packageVersion)! !!SqueakUpdateStreamManager methodsFor: 'misc' stamp: 'ar 5/14/2003 15:52'!updateComment"The following used to be at the beginning of the update file.	Now it is here to simplify parsing the file...* To add a new update:  Name it starting with a new four-digit code.  * Do not use %, /, *, space, or more than one period in the name of an update file.* The update name does not need to have any relation to the version name.* Figure out which versions of the system the update makes sense for.* Add the name of the file to each version's category below.* Put this file and the update file on all of the servers.** To make a new version of the system:  Pick a name for it (no restrictions)* Put # and exactly that name on a new line at the end of this file.* During the release process, fill in exactly that name in the dialog box.* Put a copy of updates.list on the server.** Special file with a different name for Disney Internal Updates.  * No need to move or rename files to release them to external updates."! !!DefaultUpdateStreamManager methodsFor: 'initialize' stamp: 'ar 5/14/2003 19:29'!initialize	self updateUrlLists isEmpty ifFalse:[		downloadUrl := self updateUrlLists first first.	].! !!DefaultUpdateStreamManager methodsFor: 'update api' stamp: 'ar 5/14/2003 17:22'!publishUpdate: aStream	"Put this file out as an Update on the servers."	| names choice |	names _ ServerDirectory groupNames asSortedArray.	choice _ (SelectionMenu labelList: names selections: names) startUp.	choice == nil ifTrue: [^ self].	self putUpdate: aStream		on: (ServerDirectory serverInGroupNamed: choice)! !!DefaultUpdateStreamManager methodsFor: 'accessing' stamp: 'ar 5/14/2003 19:39'!changeSetPrefix	^''! !!DefaultUpdateStreamManager methodsFor: 'accessing' stamp: 'ar 5/14/2003 17:01'!downloadUrl: aUrlString	"this won't work"	self shouldNotImplement.! !!DefaultUpdateStreamManager methodsFor: 'accessing' stamp: 'ar 5/14/2003 16:36'!highestUpdate	^SystemVersion current highestUpdate! !!DefaultUpdateStreamManager methodsFor: 'accessing' stamp: 'ar 5/14/2003 16:43'!highestUpdate: updateNum	"This works differently in conjunction with SystemVersion. The highest update is computed automatically."	^self shouldNotImplement! !!DefaultUpdateStreamManager methodsFor: 'accessing' stamp: 'ar 5/14/2003 18:19'!packageVersion	^SystemVersion current version! !!DefaultUpdateStreamManager methodsFor: 'accessing' stamp: 'ar 5/14/2003 16:41'!registerUpdate: updateNum	SystemVersion current registerUpdate: updateNum! !!DefaultUpdateStreamManager methodsFor: 'accessing' stamp: 'ar 5/14/2003 19:30'!serverUrls 	"Redirect this to Utilities where the updates used to live"	^Utilities serverUrls collect:[:each| 'http://',each,'updates/']! !!DefaultUpdateStreamManager methodsFor: 'accessing' stamp: 'ar 5/14/2003 16:45'!setUpdateServer: groupName	"Utilities setUpdateServer: 'Squeakland' "	| entry index |	entry _ self updateUrlLists detect: [:each | each first = groupName] ifNone: [^self].	index _ self updateUrlLists indexOf: entry.	self updateUrlLists removeAt: index.	self updateUrlLists addFirst: entry! !!DefaultUpdateStreamManager methodsFor: 'accessing' stamp: 'ar 5/14/2003 18:42'!updateUrlLists	"Redirect this to Utilities where the updates used to live"	^Utilities updateUrlLists collect:[:nameAndList|		Array 			with: nameAndList first			with: (nameAndList last collect:[:pseudoUrl| 'http://', pseudoUrl])]! !!DefaultUpdateStreamManager methodsFor: 'testing' stamp: 'ar 5/14/2003 16:46'!isUpdateLoaded: updateNum	"Answer whether this update is already loaded"	^SystemVersion current updates includes: updateNum! !!DefaultUpdateStreamManager methodsFor: 'loading updates' stamp: 'ar 5/14/2003 16:49'!chooseUpdateList	"When there is more than one set of update servers, let the user choose which we will update from.  Put it at the front of the list. Return false if the user aborted.  If the preference #promptForUpdateServer is false, then suppress that prompt, in effect using the same server choice that was used the previous time (a convenience for those of us who always answer the same thing to the prompt.)"	| index him |	((self updateUrlLists size > 1) and: [Preferences promptForUpdateServer]) ifTrue:[		index _ (PopUpMenu labelArray: 					(self updateUrlLists collect: [:each | each first]) lines: #()) 				startUpWithCaption: 'Choose a group of serversfrom which to fetch updates.'.			index > 0 ifTrue:				[him _ self updateUrlLists at: index.				self updateUrlLists removeAt: index.				self updateUrlLists addFirst: him].			^ index > 0].	^ true! !!SMCardUpdateStreamManager methodsFor: 'accessing' stamp: 'ar 5/15/2003 23:46'!packageVersion	"Answer the full package version"	^self smCard name, '-', self smCard currentVersion asString! !!SMCardUpdateStreamManager methodsFor: 'accessing' stamp: 'ar 5/15/2003 23:46'!smCard	^smCard! !!SMCardUpdateStreamManager methodsFor: 'accessing' stamp: 'ar 5/15/2003 23:46'!smCard: aCard	smCard := aCard! !!SimpleUpdateStreamManager methodsFor: 'accessing' stamp: 'ar 5/15/2003 23:47'!packageVersion	^packageVersion! !!SimpleUpdateStreamManager methodsFor: 'accessing' stamp: 'ar 5/15/2003 23:47'!packageVersion: aString	packageVersion := aString! !!UpdateManager class methodsFor: 'utilities' stamp: 'ar 3/27/2004 22:00'!allRegisteredManagers	"UpdateManager allRegisteredManagers"	^self subclasses inject: #() into:[:list :aClass| list, aClass allRegisteredManagers]! !!SMCardUpdateStreamManager class methodsFor: 'utilities' stamp: 'ar 5/15/2003 23:55'!allRegisteredManagers	^super allRegisteredManagers, self managersForSqueakMap! !!SMCardUpdateStreamManager class methodsFor: 'utilities' stamp: 'ar 5/15/2003 23:54'!includeUnloadedCardManagers	"Answer whether we should include SMCards which haven't been installed in the list of managers. Typically we won't but in some situations we may"	^false! !!SMCardUpdateStreamManager class methodsFor: 'utilities' stamp: 'ar 5/15/2003 23:55'!managerForCard: smCard	"Scan smCard to see if it contains the update manager tags"	| uploadUrl downloadUrl mgr |	downloadUrl := self valueOfTag: '[loadUpdatesAt:' in: smCard description.	downloadUrl ifNil:[^nil].	uploadUrl := self valueOfTag: '[storeUpdatesAt:' in: smCard description.	mgr := self new.	mgr downloadUrl: downloadUrl.	mgr uploadUrl: uploadUrl.	mgr smCard: smCard.	^mgr! !!SMCardUpdateStreamManager class methodsFor: 'utilities' stamp: 'ar 5/15/2003 23:54'!managersForSqueakMap	"UpdateManager managersForSqueakMap"	"Scan SqueakMap and figure out update managers"	| all mgr |	all := Array new writeStream.	SMSqueakMap default cards do:[:smCard|		(smCard isInstalled or:[self includeUnloadedCardManagers]) ifTrue:[			mgr := self managerForCard: smCard.			mgr ifNotNil:[all nextPut: mgr].		].	].	^all contents! !!SMCardUpdateStreamManager class methodsFor: 'utilities' stamp: 'ar 5/15/2003 23:54'!valueOfTag: tag in: aString	"	self valueOfTag: '[foo-bar-baz:' in:'		This is some text with a [foo-bar-baz: http://foo.bar.baz/mumble ] thrown in		here somewhere'	"	| startIndex endIndex value |	startIndex := aString findString: tag.	startIndex = 0 ifTrue:[^nil].	startIndex := startIndex + tag size.	endIndex := aString indexOf: $] startingAt: startIndex.	endIndex = 0 ifTrue:[^nil].	value := aString copyFrom: startIndex to: endIndex-1.	^value withBlanksTrimmed! !!SimpleUpdateStreamManager class methodsFor: 'utilities' stamp: 'ar 3/27/2004 22:01'!allRegisteredManagers	self == SimpleUpdateStreamManager ifFalse:[^#()].	^self registry! !!SimpleUpdateStreamManager class methodsFor: 'utilities' stamp: 'ar 3/27/2004 22:09'!register: packageVersion uploadUrl: uploadUrl downloadUrl: downloadUrl	"register me, e.g.,	SimpleUpdateStreamManager		register: 'Test-2.3'		uploadUrl: 'ftp://raab@luxator.cs.uni-magdeburg.de/~/public_html/squeak/updates/test'		downloadUrl: 'http://isgwww.cs.uni-magdeburg.de/~raab/squeak/updates/test'	"	| mgr |	self unregister: packageVersion.	mgr := self new.	mgr packageVersion: packageVersion.	mgr uploadUrl: uploadUrl.	mgr downloadUrl: downloadUrl.	self registry add: mgr.	^mgr! !!SimpleUpdateStreamManager class methodsFor: 'utilities' stamp: 'ar 5/15/2003 23:56'!registry	^Registry ifNil:[Registry := OrderedCollection new]! !!SimpleUpdateStreamManager class methodsFor: 'utilities' stamp: 'ar 3/27/2004 22:10'!unregister: packageVersion	"register me"	Registry := self registry reject:[:any| any packageVersion = packageVersion].! !!TweakUpdateStreamManager class methodsFor: 'initialize' stamp: 'ar 8/10/2004 15:43'!default	^self registry detect:[:any| any packageVersion = TrackingVersion]! !!TweakUpdateStreamManager class methodsFor: 'initialize' stamp: 'ar 10/4/2004 21:40'!initialize	"TweakUpdateStreamManager initialize"	"Register the update stream"	self register1Point0.	self register1Point1Alpha.	TrackingVersion ifNil:[TrackingVersion := 'Tweak-1.0'].! !!TweakUpdateStreamManager class methodsFor: 'initialize' stamp: 'ar 3/27/2004 22:31'!loadUpdates	"Load updates"	self default loadUpdates! !!TweakUpdateStreamManager class methodsFor: 'initialize' stamp: 'ar 10/4/2004 21:39'!register1Point0	"Register the update stream"	SimpleUpdateStreamManager		register: 'Tweak-1.0'		uploadUrl: 'ftp://tweak@squeakalpha.org/external/updates'		downloadUrl: 'http://squeakalpha.org/tweak/external/updates'.! !!TweakUpdateStreamManager class methodsFor: 'initialize' stamp: 'ar 8/10/2004 16:06'!register1Point1Alpha	"Register the update stream"	SimpleUpdateStreamManager		register: 'Tweak-1.1-alpha'		uploadUrl: 'ftp://tweak@squeakalpha.org/external/updates'		downloadUrl: 'http://squeakalpha.org/tweak/external/updates'.! !!TweakUpdateStreamManager class methodsFor: 'initialize' stamp: 'ar 8/10/2004 15:44'!trackingVersion	^TrackingVersion! !!TweakUpdateStreamManager class methodsFor: 'initialize' stamp: 'ar 8/10/2004 15:44'!trackingVersion: aVersion	TrackingVersion := aVersion! !!UserInputEvent methodsFor: '*Tweak' stamp: 'ar 12/8/2002 02:23'!= aMorphicEvent	super = aMorphicEvent ifFalse:[^false].	position = aMorphicEvent position ifFalse: [^ false].	buttons = aMorphicEvent buttons ifFalse: [^ false].	self keyValue = aMorphicEvent keyValue ifFalse: [^ false].	^ true! !!UserInputEvent methodsFor: '*Tweak' stamp: 'ar 12/8/2002 02:21'!anyButtonPressed	"Answer true if any mouse button is being pressed."	^ buttons anyMask: 7! !!UserInputEvent methodsFor: '*Tweak' stamp: 'ar 12/8/2002 01:28'!asMouseEnter	^self clone setType: #mouseEnter! !!UserInputEvent methodsFor: '*Tweak' stamp: 'ar 12/8/2002 01:28'!asMouseLeave	^self clone setType: #mouseLeave! !!UserInputEvent methodsFor: '*Tweak' stamp: 'ar 12/8/2002 01:28'!asMouseMove	"Convert the receiver into a mouse move"	^MouseMoveEvent new setType: #mouseMove startPoint: position endPoint: position trail: {position. position} buttons: buttons hand: source stamp: Time millisecondClockValue.! !!UserInputEvent methodsFor: '*Tweak' stamp: 'ar 12/8/2002 01:29'!asMouseOver	"Convert the receiver into a mouse over event"	^MouseEvent new setType: #mouseOver position: position buttons: buttons hand: source! !!UserInputEvent methodsFor: '*Tweak' stamp: 'ar 12/8/2002 02:21'!blueButtonChanged	"Answer true if the blue mouse button has changed. This is the third mouse button or cmd+click on the Mac."	^false! !!UserInputEvent methodsFor: '*Tweak' stamp: 'ar 12/8/2002 02:21'!blueButtonPressed	"Answer true if the blue mouse button is being pressed. This is the third mouse button or cmd+click on the Mac."	^ buttons anyMask: 1! !!UserInputEvent methodsFor: '*Tweak' stamp: 'ar 12/8/2002 02:21'!cursorPoint	"Answer the location of the cursor's hotspot when this event occured."	^ position! !!UserInputEvent methodsFor: '*Tweak' stamp: 'ar 12/8/2002 02:23'!hash	^ position hash + buttons hash! !!UserInputEvent methodsFor: '*Tweak' stamp: 'ar 12/8/2002 02:23'!isDraggingEvent	source ifNil:[^false].	source hasSubmorphs ifTrue:[^true].	self anyButtonPressed ifTrue:[^true].	^false! !!UserInputEvent methodsFor: '*Tweak' stamp: 'ar 12/8/2002 02:23'!isMouseEnter	^self type == #mouseEnter! !!UserInputEvent methodsFor: '*Tweak' stamp: 'ar 12/8/2002 02:23'!isMouseLeave	^self type == #mouseLeave! !!UserInputEvent methodsFor: '*Tweak' stamp: 'ar 12/8/2002 02:21'!keyCharacter	^self keyValue asCharacter! !!UserInputEvent methodsFor: '*Tweak' stamp: 'ar 12/8/2002 02:21'!keyValue	^0! !!UserInputEvent methodsFor: '*Tweak' stamp: 'ar 12/8/2002 02:21'!metaState	"Answer the meta state for this event"	^ (self buttons bitAnd: 16r78)	"cmd | opt | ctrl | shift"		bitShift: -3! !!UserInputEvent methodsFor: '*Tweak' stamp: 'ar 12/8/2002 02:22'!printOn: aStream	aStream nextPut: $[.	aStream nextPutAll: self cursorPoint printString; space.	aStream nextPutAll: type; space.	aStream nextPutAll: self modifierString.	aStream nextPutAll: self buttonString.	aStream nextPutAll: timeStamp printString.	aStream nextPut: $].! !!UserInputEvent methodsFor: '*Tweak' stamp: 'ar 12/8/2002 02:21'!redButtonChanged	"Answer true if the red mouse button has changed. This is the first mouse button."	^false! !!UserInputEvent methodsFor: '*Tweak' stamp: 'ar 12/8/2002 02:21'!redButtonPressed	"Answer true if the red mouse button is being pressed. This is the first mouse button."	^ buttons anyMask: 4! !!UserInputEvent methodsFor: '*Tweak' stamp: 'ar 12/8/2002 02:24'!sentTo: anObject	"Dispatch the receiver into anObject"	type == #mouseOver ifTrue:[^anObject handleMouseOver: self].	type == #mouseEnter ifTrue:[^anObject handleMouseEnter: self].	type == #mouseLeave ifTrue:[^anObject handleMouseLeave: self].	^super sentTo: anObject.! !!UserInputEvent methodsFor: '*Tweak' stamp: 'ar 12/8/2002 02:22'!setType: aSymbol	"For quick conversion between event types"	type _ aSymbol.! !!UserInputEvent methodsFor: '*Tweak' stamp: 'ar 12/8/2002 02:22'!setType: evtType position: evtPos buttons: evtButtons hand: evtHand	type _ evtType.	position _ evtPos.	buttons _ evtButtons.	source _ evtHand.	wasHandled _ false.! !!UserInputEvent methodsFor: '*Tweak' stamp: 'ar 12/8/2002 02:22'!storeOn: aStream	aStream nextPutAll: type.	aStream space.	self timeStamp storeOn: aStream.	aStream space.	position x storeOn: aStream.	aStream space.	position y storeOn: aStream.	aStream space.	buttons storeOn: aStream.! !!UserInputEvent methodsFor: '*Tweak' stamp: 'ar 12/8/2002 14:38'!transformBy: aMorphicTransform	"Transform the receiver into a local coordinate system."	position :=  position transformedBy: aMorphicTransform.! !!UserInputEvent methodsFor: '*Tweak' stamp: 'ar 12/8/2002 02:22'!type: eventType readFrom: aStream	| x y |	type _ eventType.	timeStamp _ Integer readFrom: aStream.	aStream skip: 1.	x _ Integer readFrom: aStream.	aStream skip: 1.	y _ Integer readFrom: aStream.	aStream skip: 1.	buttons _ Integer readFrom: aStream.	position _ x@y.! !!UserInputEvent methodsFor: '*Tweak' stamp: 'ar 12/8/2002 02:21'!yellowButtonChanged	"Answer true if the yellow mouse button has changed. This is the second mouse button or option+click on the Mac."	^false! !!UserInputEvent methodsFor: '*Tweak' stamp: 'ar 12/8/2002 02:22'!yellowButtonPressed	"Answer true if the yellow mouse button is being pressed. This is the second mouse button or option+click on the Mac."	^ buttons anyMask: 2! !!KeyboardEvent methodsFor: '*Tweak' stamp: 'ar 11/16/2003 20:38'!printOn: aStream	aStream nextPut: $[.	aStream nextPutAll: type.	self controlKeyPressed ifTrue: [		aStream nextPutAll: ' ''^'.		aStream nextPut: (keyValue + $a asciiValue - 1) asCharacter.	] ifFalse: [		aStream nextPutAll: ' '''.		aStream nextPut: self keyCharacter.	].	aStream nextPut: $'.	aStream space; print: keyValue.	aStream nextPut: $].! !!MouseMoveEvent methodsFor: '*Tweak' stamp: 'ar 6/5/2003 20:07'!setTrail: evtTrail	trail _ evtTrail.! !!MouseMoveEvent methodsFor: '*Tweak' stamp: 'ar 12/8/2002 14:38'!transformBy: aMorphicTransform	"Transform the receiver into a local coordinate system."	position :=  position transformedBy: aMorphicTransform.	startPoint :=  startPoint transformedBy: aMorphicTransform.! !!Utilities class methodsFor: '*Tweak'!startUp	self resetAuthorInitials.! !!Utilities class methodsFor: '*Tweak' stamp: 'ar 3/27/2004 21:51'!updateDownloader	^UpdateDownloader! !!Utilities class methodsFor: '*Tweak' stamp: 'ar 3/27/2004 21:51'!updateDownloader: aProcess	UpdateDownloader := aProcess! !!WeakValueAssociation methodsFor: '*Tweak' stamp: 'ar 10/16/2003 13:02'!readFieldsFrom: aSerializer	key := aSerializer readField: #key ifAbsent:[key].	self value: (aSerializer readField: #value ifAbsent:[self value]).! !!WeakValueAssociation methodsFor: '*Tweak' stamp: 'ar 9/25/2003 14:41'!writeFieldsOn: aSerializer	aSerializer writeField: #key value: key.	aSerializer writeField: #value value: self value.! !!WindowFont class methodsFor: 'glyphs' stamp: 'ar 3/11/2003 16:56'!glyphs	^#(		('cross.gif' 'R0lGODlhCwALAIAAAAAAAP///ywAAAAACwALAAACGAyCaQanfWCSSNIJnWL65W01mBZ23LItBQA7')		('miniCross.gif' 'R0lGODlhCwALALMAAAAAAP///////////////////////////////////////////////////////////yH5BAEAAA8ALAAAAAALAAsAAAQW8MlJq50AYL115l12feMHSiS5rVfbRgA7')		('miniCross2.gif'  'R0lGODlhCwALALMAAAAAAP///////wAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAACH5BAEAAAIALAAAAAALAAsAAAQTUMhJq70YTG01v18nhFuJnSgWAQA7')		('downArrow.gif' 'R0lGODlhCwALAIAAAAAAAP///ywAAAAACwALAAACFIyPqQbbABN8kdUw8bVZdbeE4lEAADs=')		('upArrow.gif' 'R0lGODlhCwALAIAAAAAAAP///ywAAAAACwALAAACEoyPqQprABecidIXcbvHSgcqBQA7')		('leftArrow.gif' 'R0lGODlhCwALAIAAAAAAAP///ywAAAAACwALAAACFIwfgAu91tSLL7l5K61W6ox501EAADs=')		('rightArrow.gif' 'R0lGODlhCwALAIAAAAAAAP///ywAAAAACwALAAACFIxhqcDqjFyCcrYaqNTv9vhhWVUAADs=')		('underScore.gif' 'R0lGODlhCwALAIAAAAAAAP///ywAAAAACwALAAACDYyPqcvtDx+YlJqKYQEAOw==')		('plus.gif' 'R0lGODlhCwALAIAAAAAAAP///ywAAAAACwALAAACEIyPqQp77QJMoNqJMIuSe1UAOw==')		('minus.gif' 'R0lGODlhCwALAIAAAAAAAP///ywAAAAACwALAAACDIyPqcvtBqIEr9q7CgA7')		('circle.gif' 'R0lGODlhCwALAIAAAAAAAP///ywAAAAACwALAAACF4yPCLvJf1hsgU5jMdBuVytpjzeFyRkUADs=')		('bullet.gif' 'R0lGODlhCwALAIAAAAAAAP///ywAAAAACwALAAACGIyPCLsJfl5gRj7W7MSzbqp93hg5XIIaBQA7')		('checkMark.gif' 'R0lGODlhCwALAIAAAAAAAP///ywAAAAACwALAAACFIyPqWvAAdyRMCIbact6WtY9IlIAADs=')		('expand.gif' 'R0lGODlhCwALAIAAAAAAAP///ywAAAAACwALAAACGYSDaJvN0AKEalGXbt7x6sooUicdURlmRgEAOw==')		('collapse.gif' 'R0lGODlhCwALAIAAAAAAAP///ywAAAAACwALAAACGkQceQvo1lyKatZLa4RZ9btojXWMY2iG3lEAADs=')		('subMenu.gif' 'R0lGODlhCwALAIAAAAAAAP///ywAAAAACwALAAACEoyPCanLBuILUbJqEX515juFBQA7')		('target.gif' 'R0lGODlhCwALAIAAAAAAAP///ywAAAAACwALAAACF4wDeWvAm9yT6DjaUGTx8pqFnPKIE2kUADs=')		('miniUpArrow.gif''R0lGODlhCwALAIAAAAAAAP///ywAAAAACwALAAACEIyPqQprABecadp6mtu8uwIAOw==')		('miniDownArrow.gif''R0lGODlhCwALAIAAAAAAAP///ywAAAAACwALAAACEIyPqcttcCACtMpoV23X+VMAOw==')		('miniLeftArrow.gif' 'R0lGODlhCwALAIAAAAAAAP///ywAAAAACwALAAACD4yPqQprABdsbDp743W8FwA7')		('miniRightArrow.gif' 'R0lGODlhCwALAIAAAAAAAP///ywAAAAACwALAAACEYyPqQprAF2AbdGaqI0Oy58UADs=')		('miniPlayFwd.gif' 'R0lGODlhCwALAIAAAAAAAP///ywAAAAACwALAAACEoyPCanLBuILUbJqEX515juFBQA7') 		('miniPlayBack.gif' 'R0lGODlhCwALAIAAAAAAAP///ywAAAAACwALAAACE4yPaaAH3B5McroaZQt6v72ASgEAOw==') 		('miniPlayPause.gif' 'R0lGODlhCwALAIAAAAAAAP///ywAAAAACwALAAACFIyPqQfA/qIMDVVzMaSbT68t4lgAADs=')		('arrowLeft.gif' 'R0lGODlhCwALALMAAAAAAP////////////////////////////////////////////////////////i/JCH5BAEAAA8ALAAAAAALAAsAAAQZMMgJppWgXhz01VlGbeDWjZ8FhqlHuqQVAQA7')		('arrowRight.gif' 'R0lGODlhCwALALMAAAAAAP///////////////////////////////////////////////////////////yH5BAEAAA8ALAAAAAALAAsAAAQa8MkHpp2gXkxvzpIWbqJoaeYYfqrXbVR6bhEAOw==')		('arrowUp.gif' 'R0lGODlhCwALALMAAAAAAP///////////////////////////////////////////////////////////yH5BAEAAA8ALAAAAAALAAsAAAQZ8MlJ6wN2Ymz5rZ7khdoFnNo5liBLqWhmRQA7')		('arrowDown.gif' 'R0lGODlhCwALALMAAAAAAP///////////////////////////////////////////////////////////yH5BAEAAA8ALAAAAAALAAsAAAQZ8MlJKbi3PjB59VuHiRlodV8qmSh7arAUAQA7')	)! !!WindowFont class methodsFor: 'class initialization' stamp: 'ar 3/10/2003 05:33'!glyphForms	"WindowFont glyphForms"	| form data |	^self glyphs collect:[:spec|		data := spec last base64Decoded asByteArray.		form := (Form fromBinaryStream: (ReadStream on: data)).		spec first -> form	].! !!WindowFont class methodsFor: 'class initialization' stamp: 'ar 3/30/2004 18:13'!initFont	"WindowFont initFont"	| form map font style files |	files := Dictionary new.	self glyphs do:[:spec|		files at: spec first put: spec last base64Decoded asByteArray.	].	map := Dictionary new.	#(		( 'X'	'cross.gif')		( 'x'	'miniCross.gif')		( 'v'	'downArrow.gif')		( '^'	'upArrow.gif')		( '<'	'leftArrow.gif')		( '>'	'rightArrow.gif')		( '_'	'underScore.gif')		( '+'	'plus.gif')		( '-'	'minus.gif')		( 'O'	'circle.gif')		( 'o'	'bullet.gif')		( 'V'	'checkMark.gif')		( 'E'   'expand.gif')		( 'C'   'collapse.gif')		( 's'   'subMenu.gif')		( 'T'	'target.gif')		"--"		('l'	'miniLeftArrow.gif')		('r'	'miniRightArrow.gif')		('u'	'miniUpArrow.gif')		('d'	'miniDownArrow.gif')		"--"		('L' 'arrowLeft.gif')		('R' 'arrowRight.gif')		('U' 'arrowUp.gif')		('D' 'arrowDown.gif')		"--"		('f' 'miniPlayFwd.gif')		('b' 'miniPlayBack.gif')		('p' 'miniPlayPause.gif')	) do:[:spec|		form := (Form fromBinaryStream: (ReadStream on: (files at: spec last))).		map at: spec first first put: form.	].	form := Form extent: 11@11 depth: 1.	form getCanvas frameOval: (1@1 extent: 9@9) width: 1 color: Color black.	map at: $q put: form.	form := Form extent: 11@11 depth: 1.	form getCanvas frameOval: (1@1 extent: 9@9) width: 1 color: Color black.	form getCanvas fillOval: (3@3 extent: 5@5) color: Color black.	map at: $Q put: form.	font := StrikeFont new initializeWithMap: map.	font name: #WindowFont.	style := TextStyle fontArray: {font}.	TextConstants at: #WindowFont put: style.! !!WindowFont class methodsFor: 'class initialization' stamp: 'ar 3/27/2004 20:36'!initialize	"WindowFont initialize"	StrikeFont initializeStandardCharacterToGlyphMap.	(TextStyle named: 'WindowFont') defaultFont familyName = 'WindowFont'		ifFalse:[self initFont].! !!Workspace methodsFor: '*Tweak' stamp: 'ar 10/1/2003 20:49'!addModelItemsToWindowMenu: aMenu	aMenu addLine.	aMenu add: 'save as HTML...' target: self action: #saveHtmlInFile.	aMenu add: 'save contents to file...' target: self action: #saveContentsInFile.	aMenu 		addUpdating: #acceptDroppedMorphsWording		target: self		action: #toggleDroppingMorphForReference! !!Workspace methodsFor: '*Tweak' stamp: 'ar 10/1/2003 20:47'!saveHtmlInFile	"A bit of a hack to pass along this message to the controller or morph.  (Possibly this Workspace menu item could be deleted, since it's now in the text menu.)"	| textMorph |	textMorph _ self dependents detect: [:dep | dep isKindOf: PluggableTextMorph] ifNone: [nil].	textMorph notNil ifTrue: [^ textMorph saveHtmlInFile].! !!XMLWriterIndenting methodsFor: 'writing xml' stamp: 'ar 2/28/2004 20:41'!endTag	indent := indent + 1.	super endTag.! !!XMLWriterIndenting methodsFor: 'writing xml' stamp: 'ar 2/28/2004 22:36'!endTag: tagName	stream crtab: indent-1.	indent := indent - 2.	super endTag: tagName.! !!XMLWriterIndenting methodsFor: 'writing xml' stamp: 'ar 2/28/2004 20:36'!startTag: tagName	stream crtab: indent.	super startTag: tagName.! !!XMLWriterIndenting methodsFor: 'initialize' stamp: 'ar 2/28/2004 20:35'!initialize	super initialize.	indent := 0.! !!XMLWriterIndenting class reorganize!('as yet unclassified')!!XMLWriterIndenting reorganize!('writing xml' endTag endTag: startTag:)('initialize' initialize)!WindowFont initialize!!WindowFont class reorganize!('glyphs' glyphs)('class initialization' glyphForms initFont initialize)!!WindowFont reorganize!('as yet unclassified')!TweakUpdateStreamManager initialize!!TweakUpdateStreamManager class reorganize!('initialize' default initialize loadUpdates register1Point0 register1Point1Alpha trackingVersion trackingVersion:)!!SimpleUpdateStreamManager class reorganize!('utilities' allRegisteredManagers register:uploadUrl:downloadUrl: registry unregister:)!!SMCardUpdateStreamManager class reorganize!('utilities' allRegisteredManagers includeUnloadedCardManagers managerForCard: managersForSqueakMap valueOfTag:in:)!!DefaultUpdateStreamManager class reorganize!('as yet unclassified')!!SqueakUpdateStreamManager class reorganize!('as yet unclassified')!!UpdateManager class reorganize!('utilities' allRegisteredManagers)!!TweakUpdateStreamManager reorganize!('as yet unclassified')!!SimpleUpdateStreamManager reorganize!('accessing' packageVersion packageVersion:)!!SMCardUpdateStreamManager reorganize!('accessing' packageVersion smCard smCard:)!!DefaultUpdateStreamManager reorganize!('initialize' initialize)('update api' publishUpdate:)('accessing' changeSetPrefix downloadUrl: highestUpdate highestUpdate: packageVersion registerUpdate: serverUrls setUpdateServer: updateUrlLists)('testing' isUpdateLoaded:)('loading updates' chooseUpdateList)!!SqueakUpdateStreamManager reorganize!('update api' availableUpdates highestUpdate highestUpdate: loadUpdates loadedUpdates publishUpdate:)('accessing' changeSetPrefix downloadUrl downloadUrl: name packageVersion updateDownloader updateDownloader: updateUrlLists uploadUrl uploadUrl:)('testing' isUpdateLoaded:)('loading updates' chooseUpdateList extractThisVersion: lastUpdateNum: newChangesFromStream:named: newUpdatesOn:special:throughNumber: objectStrmFromUpdates: parseListContents: position:atVersion: readNextUpdateFromServer readNextUpdatesFromDisk: readServer:special:updatesThrough:saveLocally:updateImage: readServerUpdatesSaveLocally:updateImage: readServerUpdatesThrough:saveLocally:updateImage: registerUpdate: retrieveUrls:ontoQueue:withWaitSema: saveUpdate:onFile: scanServerUpdates serverUrls updateFromServer updateFromServerThroughUpdateNumber:)('storing updates' broadcastUpdatesFrom:to:except: checkNames: checkServers:withPrefix:andParseListInto: installUpdateStream outOfDate: putUpdate:on: putUpdateMulti:fromDirectory:onto: updateInstallVersion: writeList:toStream:)('updates from disk' applyUpdatesFromDisk applyUpdatesFromDiskToUpdateNumber:stopIfGap: fileInFromUpdatesFolder: getUpdateDirectory)('misc' updateComment)!!UpdateManager reorganize!('update api' installUpdateStream loadUpdates publishTestUpdate publishUpdate:)('queries' availableUpdates highestUpdate loadedUpdates)('private' inform:)!UpdateLoaderUI initialize!!UpdateLoaderUI class reorganize!('initialize' initialize removeFromSystem)('opening' open)!!UpdateLoaderUI reorganize!('initialize' initialize managerIndex managerIndex: openInWorld selectedManager)('accessing' managerNames)('actions' loadUpdates newUpdateStream publishTestUpdate updateManagerList)('gui' buildManagerList createWindow managerMenu: paneColor perform:orSendTo:)!!TweakTests class reorganize!('as yet unclassified')!!TweakTests reorganize!('field tests' testFieldGettersBewareOfAnnotation testFieldSettersBewareOfAnnotation testFieldSettersReturn)('utilities' allClassesWithFieldsDo: allFieldGetterMethodsDo: allFieldSetterMethodsDo:)!!TweakTestMethodAnalyzer class reorganize!('as yet unclassified')!!TweakTestMethodAnalyzer reorganize!('initialize-release' dubiousReturnInFieldSetter:)('instruction decoding' methodReturnConstant: methodReturnReceiver methodReturnTop)!!CTextStream class reorganize!('as yet unclassified')!!CTextStream reorganize!('as yet unclassified' applyAttribute:beginningAt: growTo: nextPutAll: withAttribute:do: withAttributes:do:)!NSTweakBrowser initialize!!NSTweakBrowser class reorganize!('as yet unclassified' initialize)!!NSTweakBrowser reorganize!('initialize' defaultBrowserTitle openAsMorphEditing:)('accessing' classList environment environment: selectedSystemCategoryName)('env list' envList envListIndex envListIndex: envListMenu: envListWrappers envStringList getClassList: getOrganizerList: openEditString: selectedEnvironment selectedWrapper selectedWrapper: setSystemOrganizer)('other' browseClassRefs contents defineClass:notifying: doRemoveClass removeClass)!!NSPluggableListItemWrapper class reorganize!('as yet unclassified')!!NSPluggableListItemWrapper reorganize!('accessing' asString contents getContentsSelector getContentsSelector: getStringSelector getStringSelector: hasContents hasContentsSelector hasContentsSelector: item item: string string:)('printing' printOn:)('private' sendToModel: validateSelector:)!HaloFont initialize!!HaloFont class reorganize!('class initialization' initFont initialize)('glyphs' glyphs)!!HaloFont reorganize!('as yet unclassified')!!CTransformCanvas class reorganize!('as yet unclassified')!!CTransformCanvas reorganize!('drawing-shapes' drawCompressedShape:)('testing' isVisible:)('drawing-round rects' fillRoundRect:radius:fill:border: fillRoundRect:radius:fillStyle: frameRoundRect:radius:width:color: makeRoundRectShape:radius:)('private-state' flushWarp installWarp: resetGrafPort restoreFrom: setOrigin:clipRect:)('push/pop' asBackup newBackup popState pushState)('drawing-rectangles' fillOval:fill:border: fillRectangle:color: fillRectangle:fill:border: fillRectangle:fillStyle: frameAndFillRectangle:fillColor:borderWidth:topLeftColor:bottomRightColor:)('drawing-images' balloonWarp:transform:at:sourceRect: image:at:sourceRect:rule: privateWarp:transform:at:sourceRect:cellSize: stencil:at:sourceRect:color: warpImage:transform:at:sourceRect:cellSize:)('transforming' copyFrom: preserveStateDuring: transform transform: transformBy: transformBy:clippingTo:during: transformBy:during: translateBy: translateBy:during:)('drawing-lines' drawLineFrom:to:brush: drawLineFrom:to:width:color:)('drawing-text' displayString:from:to:at:font:kern: displayString:from:to:at:strikeFont:kern: displayString:from:to:at:ttcFont:kern: drawString:from:to:in:font:color:kern: installStrikeFont:foregroundColor:backgroundColor: installTTCFont:foregroundColor:backgroundColor: paragraph:bounds:color:)('clipping' clipBy: clipBy:during:)('initialize' reset setForm:)('accessing' asTransformCanvas clipRect)('rounding' roundCornersOf:in:during:)('converting' asBalloonCanvas)('TODO-IGraphicsDevice' asCanvas display:)('caching' cache:using:during:)!!CWorldPlayer class reorganize!('as yet unclassified')!CWorldCostume initialize!!CWorldCostume class reorganize!('as yet unclassified' initialize startUp)!CWorkspace initialize!!CWorkspace class reorganize!('class initialization' initialize)!!CWindowResizeBehavior class reorganize!('as yet unclassified')!!CWindowCostumeFrame class reorganize!('as yet unclassified')!!CWindowCostume class reorganize!('as yet unclassified')!!CWindowButtonCostume class reorganize!('as yet unclassified')!!CWindow class reorganize!('as yet unclassified')!CWidgetLibrary initialize!!CWidgetLibrary class reorganize!('accessing' default default: initialize)!!CWheelWidgetCostume class reorganize!('as yet unclassified')!!CTreeWidgetCostume class reorganize!('as yet unclassified')!!CToolBarButtonCostume class reorganize!('as yet unclassified')!!CTileButtonCostume class reorganize!('as yet unclassified')!!CInputFieldCostume class reorganize!('as yet unclassified')!!CTextEditorCostume class reorganize!('as yet unclassified')!!CTabButtonListCostume class reorganize!('as yet unclassified')!!CTabButtonCostume class reorganize!('as yet unclassified')!!CStringListCostume class reorganize!('as yet unclassified')!!CSpinnerListCostume class reorganize!('as yet unclassified')!!CSpinnerCostume class reorganize!('as yet unclassified')!!CSpinnerButtonsCostume class reorganize!('as yet unclassified')!!CScrollBarCostume class reorganize!('as yet unclassified')!!CSliderCostume class reorganize!('as yet unclassified')!!CScrollableTextEditorCostume class reorganize!('as yet unclassified')!!CScrollPaneCostume class reorganize!('as yet unclassified')!!CMultiColumnListCostume class reorganize!('as yet unclassified')!!CListCostume class reorganize!('as yet unclassified')!!CCustomDrawListCostume class reorganize!('as yet unclassified')!!CScrollableCostume class reorganize!('as yet unclassified')!!CScrollButtonCostume class reorganize!('as yet unclassified')!!CRadioButtonCostume class reorganize!('as yet unclassified')!!CPushButtonCostume class reorganize!('as yet unclassified')!!CMenuBarCostume class reorganize!('as yet unclassified')!!CMenuCostume class reorganize!('as yet unclassified')!!CLabelCostume class reorganize!('as yet unclassified')!!CDropDownListCostume class reorganize!('as yet unclassified')!!CCheckBoxCostume class reorganize!('as yet unclassified')!!CButtonCostume class reorganize!('as yet unclassified')!!CWidgetCostume class reorganize!('as yet unclassified')!!CWheelWidget class reorganize!('as yet unclassified')!!CToolBarButton class reorganize!('as yet unclassified')!!CTileButton class reorganize!('as yet unclassified')!!CInputField class reorganize!('as yet unclassified')!CTextEditor initialize!!CTextEditor class reorganize!('class initialization' initialize initializeStandardEditingKeys macCursorKeys macEditingKeys startUp win32CursorKeys win32EditingKeys)('accessing' standardEditingKeys standardEditingKeys:)!!CTabButton class reorganize!('as yet unclassified')!!CSpinnerButtons class reorganize!('as yet unclassified')!!CSpinner class reorganize!('as yet unclassified')!!CScrollBar class reorganize!('as yet unclassified')!!CSlider class reorganize!('as yet unclassified')!!CScrollPane class reorganize!('as yet unclassified')!!CRadioButton class reorganize!('as yet unclassified')!!CPushButton class reorganize!('as yet unclassified')!!CMenuBar class reorganize!('examples' example1)!!CMenu class reorganize!('as yet unclassified' testMenu)!!CLabel class reorganize!('as yet unclassified')!!CImageButton class reorganize!('as yet unclassified')!!CConstraintValueWidget class reorganize!('as yet unclassified')!!CCheckBox class reorganize!('as yet unclassified')!!CButton class reorganize!('as yet unclassified')!!CWidget class reorganize!('private')!!CViewerRow class reorganize!('as yet unclassified')!!CViewerDefinition class reorganize!('as yet unclassified')!!CViewerCategoryHeader class reorganize!('as yet unclassified')!!CVectorShape class reorganize!('as yet unclassified')!!CVariableTileCostume class reorganize!('as yet unclassified')!!CVariableTile class reorganize!('as yet unclassified')!!CValueTileCostume class reorganize!('as yet unclassified')!!CValueTile class reorganize!('as yet unclassified')!!CMenuItemCostume class reorganize!('as yet unclassified')!!CListItem class reorganize!('as yet unclassified')!!CValuePlayer class reorganize!('as yet unclassified')!!CUserDialog class reorganize!('as yet unclassified')!!CTweakedPart class reorganize!('as yet unclassified')!!CTweakSerializer class reorganize!('as yet unclassified')!!CTweakMaker class reorganize!('as yet unclassified')!!CTweakDeserializer class reorganize!('as yet unclassified')!!CTreeWidget class reorganize!('examples' example1 example2 example3)!!CTreeItemCostume class reorganize!('as yet unclassified')!!CServerDirectoryTreeItem class reorganize!('as yet unclassified')!!CFileDirectoryTreeItem class reorganize!('as yet unclassified')!!CTreeItem class reorganize!('as yet unclassified')!!CTileViewerPage class reorganize!('as yet unclassified')!!CTileViewer class reorganize!('as yet unclassified')!!CFillStyleType class reorganize!('accessing' enumValues)!!CButtonStateType class reorganize!('as yet unclassified' enumValues)!!CBorderStyleType class reorganize!('accessing' enumValues)!!CSymbolType class reorganize!('converting' print: read:)!!CStringType class reorganize!('accessing' defaultValue)('converting' print: read:)!!CSoundNameType class reorganize!('converting' print: read:)('accessing' enumValues)!!CImageResourceType class reorganize!('accessing' read:)!!CResourceType class reorganize!('accessing' print:)!!CPlayerType class reorganize!('as yet unclassified')!!CIntegerType class reorganize!('converting' read:)!!CNumberType class reorganize!('accessing' defaultValue)('converting' read:)!!CBooleanType class reorganize!('accessing' enumValues)('converting' read:)!!CEnumType class reorganize!('accessing' defaultValue enumValues)!!CColorType class reorganize!('accessing' defaultValue)('as yet unclassified' print: read:)!!CTileType class reorganize!('converting' print: read:)('type tests' canCoerceType:)!!CTileReadout class reorganize!('as yet unclassified')!!CScriptorTile class reorganize!('as yet unclassified')!!CSequenceTile class reorganize!('as yet unclassified')!!CPropertyTile class reorganize!('as yet unclassified')!!COperatorTile class reorganize!('as yet unclassified')!!CMessageTile class reorganize!('as yet unclassified')!!CTilePlayer class reorganize!('as yet unclassified')!!CTileLibrary class reorganize!('accessing' default default:)!!CTileInspector class reorganize!('as yet unclassified')!!CSlotDefinition class reorganize!('as yet unclassified')!!COperatorDefinition class reorganize!('as yet unclassified')!!CMessageDefinition class reorganize!('as yet unclassified')!!CCategoryDefinition class reorganize!('as yet unclassified')!!CArgumentDefinition class reorganize!('as yet unclassified')!!CTileDefinition class reorganize!('reading' defaultViewerSpec openDefaultViewer openDefaultViewerOn: readXmlFrom: testViewerSpec xmlFrom:)!!CStringTileCostume class reorganize!('as yet unclassified')!!CSoundTileCostume class reorganize!('as yet unclassified')!!CScriptorTileCostume class reorganize!('as yet unclassified')!!CSequenceTileCostume class reorganize!('as yet unclassified')!!CReceiverTileCostume class reorganize!('as yet unclassified')!!CPropertyTileCostume class reorganize!('as yet unclassified')!!COperatorTileCostume class reorganize!('as yet unclassified')!!CNumberTileCostume class reorganize!('as yet unclassified')!!CMessageTileCostume class reorganize!('as yet unclassified')!!CMessagePartCostume class reorganize!('as yet unclassified')!!CMessageAndArgsCostume class reorganize!('as yet unclassified')!!CImageResourceTileCostume class reorganize!('as yet unclassified')!!CEnumTileCostume class reorganize!('as yet unclassified')!!CEnumListCostume class reorganize!('as yet unclassified')!!CColorTileCostume class reorganize!('as yet unclassified')!!CTileCostume class reorganize!('as yet unclassified')!CTextTool initialize!!CTextTool class reorganize!('as yet unclassified' initialize)!!CTextParagraphEditor class reorganize!('as yet unclassified')!!CTextParagraph class reorganize!('as yet unclassified')!!CTextEditorPane class reorganize!('as yet unclassified')!!CStringConverter class reorganize!('as yet unclassified')!!CNumberConverter class reorganize!('as yet unclassified')!!CDateConverter class reorganize!('as yet unclassified')!!CTextConverter class reorganize!('as yet unclassified')!!CTextComposer class reorganize!('as yet unclassified' characterForColumnBreak)!!CTableLayoutProperties class reorganize!('as yet unclassified')!!CTableLayout class reorganize!('as yet unclassified')!!CTabButtonList class reorganize!('example' example1 example2)!!CStyleReadoutList class reorganize!('as yet unclassified')!!CStringList class reorganize!('as yet unclassified')!!CSpinnerList class reorganize!('as yet unclassified')!!CSoundResource class reorganize!('instance creation' importXmlResource:in: readFrom: readFrom:type:)!!CSoundPlayer class reorganize!('as yet unclassified')!!CSolidFill class reorganize!('instance creation' color:)!CSimpleTextEditor initialize!!CSimpleTextEditor class reorganize!('class initialization' initialize)!!CSimpleLayout class reorganize!('as yet unclassified')!!CRaisedBorder class reorganize!('as yet unclassified')!!CInsetBorder class reorganize!('as yet unclassified')!!CComplexBorder class reorganize!('instance creation' style:)!!CSimpleBorder class reorganize!('as yet unclassified')!!CSequencePart class reorganize!('as yet unclassified')!!CResourcePart class reorganize!('as yet unclassified')!!CReferencePart class reorganize!('as yet unclassified')!!CBitsArrayPart class reorganize!('as yet unclassified')!!CObjectPart class reorganize!('as yet unclassified')!!CSharedPart class reorganize!('as yet unclassified')!!CObjectMakerSerializer class reorganize!('as yet unclassified' serialize:on: serialize:onFileNamed:)!!CSerializer class reorganize!('as yet unclassified' new serialize:)!!CScriptorHeader class reorganize!('as yet unclassified')!!CKeywordsForObject class reorganize!('as yet unclassified')!!CEnglishObjOutline class reorganize!('as yet unclassified')!!CEnglishForObject class reorganize!('as yet unclassified')!!CScriptForObject class reorganize!('as yet unclassified')!!CScriptChange class reorganize!('as yet unclassified')!CRootMorph initialize!!CRootMorph class reorganize!('as yet unclassified' initialize open)!!CResourceManager class reorganize!('instance creation' default new)!!CObjectMaker class reorganize!('instance creation' importXmlResource:in:)!!CMovieResource class reorganize!('instance creation' importXmlResource:in: readFrom: readFrom:type:)!!CImageResource class reorganize!('instance creation' importXmlResource:in: readFrom: readFrom:type:)!!CMediaResource class reorganize!('instance creation' with:)!!CMaker class reorganize!('interface' newFrom: withID:)!CResource initialize!!CResource class reorganize!('class initialization' initialize initializeDefaultResources registerResource:provider: resourceProviderFor: unRegisterResource:)('instance creation' importResourcesFrom:)!!CProportionalLayout class reorganize!('as yet unclassified')!!CPropertyChange class reorganize!('as yet unclassified')!!CProjectLoader class reorganize!('instance creation' readFrom:)!!CProjectLibrary class reorganize!('as yet unclassified')!!CProjectCostume class reorganize!('as yet unclassified')!!CProjectBuilder class reorganize!('tcar' tcarReleaseNotes)('menu registry' registerOpenCommand: toolMenuItems unregisterOpenCommand: unregisterOpenCommandWithReceiver:)!!CProject class reorganize!('as yet unclassified')!!CHandCostume class reorganize!('as yet unclassified')!CPrimitiveCostume initialize!!CPrimitiveCostume class reorganize!('accessing' eventsGenerated)('instance creation' makeCostumeFor: new)('class initialization' flagRegistry initialize releaseFlag: requestFlag:)!!CPreDebugger class reorganize!('as yet unclassified')!!CPlayerCollection class reorganize!('instance creation' costume:)!!CMultiSelectionHalo class reorganize!('as yet unclassified')!!CMultiColumnList class reorganize!('as yet unclassified')!!CMultiColorPicker class reorganize!('as yet unclassified')!!CMoviePlayer class reorganize!('as yet unclassified')!!CChangedMessageSet class reorganize!('as yet unclassified' openFor: openMessageList:name:autoSelect:changeSet:)!!CMessageSet class reorganize!('instance creation' openMessageList:name: openMessageList:name:autoSelect:)!!CMenuItemSeparator class reorganize!('as yet unclassified')!!CDropDownList class reorganize!('as yet unclassified')!!CList class reorganize!('as yet unclassified')!!CLibraryEntryCostume class reorganize!('as yet unclassified')!!CContextVariablesInspector class reorganize!('as yet unclassified')!!CInspector class reorganize!('as yet unclassified' inspect: openForTest openForTest2 openOn: openOn:withEvalPane: openOn:withLabel:)!!CImagePlayer class reorganize!('as yet unclassified')!!CHolder class reorganize!('as yet unclassified')!!CHandPlayer class reorganize!('as yet unclassified')!!CHaloResizer class reorganize!('as yet unclassified')!!CHaloButton class reorganize!('as yet unclassified')!!CHalo class reorganize!('as yet unclassified')!!CFillStyleReadout class reorganize!('as yet unclassified')!!CFileSaveDialogCostume class reorganize!('as yet unclassified')!!CFileSaveDialog class reorganize!('as yet unclassified')!!CFileOpenDialogCostume class reorganize!('as yet unclassified')!!CFileOpenDialog class reorganize!('as yet unclassified')!!CFileDialogSorter class reorganize!('as yet unclassified')!!CFileDialogPattern class reorganize!('as yet unclassified')!!CFileDialogCostume class reorganize!('as yet unclassified')!!CFileDialog class reorganize!('file opening' openFile openFile: openFile:label: openImageFile)('instance creation' new)('defaults' defaultImageSpec defaultProjectDirectories)('utilities' iconForDirectoryEntry: imageIconFrom:)!CFieldReference initialize!!CFieldReference class reorganize!('class initialization' initialize)('instance creation' compileReference: forField:)!CDebugger initialize!!CDebugger class reorganize!('class initialization' initialize openContext:label:contents:)('instance creation' context: context:isolationHead: informExistingDebugger:label:)('opening' openInterrupt:onProcess: openOn:context:label:contents:fullView:)('window color' windowColorSpecification)('testing' openForTest)!!CCustomDrawListTarget class reorganize!('as yet unclassified')!!CCostume class reorganize!('private' new on:)!!CColorToolFlagsPage class reorganize!('as yet unclassified')!!CColorToolFillPage class reorganize!('as yet unclassified')!!CColorToolBorderPage class reorganize!('as yet unclassified')!CColorTool initialize!!CColorTool class reorganize!('class initialization' initialize)!!CColorPicker class reorganize!('as yet unclassified')!CClassBrowser initialize!!CClassBrowser class reorganize!('class initialization' initialize)!CChangeSorter initialize!!CChangeSorter class reorganize!('enumerating' allChangeSetNames allChangeSets allChangeSetsWithClass:selector: changeSet:containsClass: changeSetNamed: changeSetsNamedSuchThat: existingOrNewChangeSetNamed: gatherChangeSets highestNumberedChangeSet mostRecentChangeSetWithChangeForClass:selector: promoteToTop:)('class initialization' belongsInAdditions: belongsInAll: belongsInMyInitials: belongsInNumbered: belongsInProjectChangeSets: belongsInProjectsInRelease: belongsInRecentUpdates: changeSetCategoryNamed: changeSetNamesInReleaseImage changeSetNamesInThreeOh initialize initializeChangeSetCategories noteChangeSetsInRelease unload)('adding' basicNewChangeSet: newChangeSet newChangeSet: newChangesFromStream:named:)('removing' deleteChangeSetsNumberedLowerThan: removeChangeSet: removeChangeSetsNamedSuchThat: removeEmptyUnnamedChangeSets)('services' assuredChangeSetNamed: browseChangeSetsWithClass:selector: browseChangeSetsWithSelector: buildAggregateChangeSet countOfChangeSetsWithClass:andSelector: doesAnyChangeSetHaveClass:andSelector: recentUpdateMarker recentUpdateMarker: reorderChangeSets secondaryChangeSet)('fileIn/Out' fileIntoNewChangeSet: fileReaderServicesForFile:suffix: serviceFileIntoNewChangeSet services)!!CCodeHolder class reorganize!('as yet unclassified')!!CBorderStyleReadout class reorganize!('as yet unclassified')!!CPlayer class reorganize!('opening' open openInHand openOn:)('instance creation' makeCostumeFor: makePlayerFor:)!!CPartBinding class reorganize!('as yet unclassified')!!CGradientFill class reorganize!('instance creation' colors: ramp: sample)!!CBitmapFill class reorganize!('instance creation' form: fromForm: fromUser)!!COrientedFill class reorganize!('as yet unclassified')!!COffsetTransform class reorganize!('instance creation' offset: withOffset:)!!CObjectMakerImporter class reorganize!('as yet unclassified')!!CObjectMakerDeserializer class reorganize!('instance creation' on:)!!CNoFill class reorganize!('as yet unclassified')!!CNoBorder class reorganize!('as yet unclassified')!!CMultiColumnListSpec class reorganize!('as yet unclassified')!!CMenuItem class reorganize!('as yet unclassified')!!CListLayout class reorganize!('as yet unclassified')!!CLibraryEntry class reorganize!('as yet unclassified')!!CLayoutPolicy class reorganize!('as yet unclassified')!!CFramingHighlight class reorganize!('as yet unclassified')!!CFillingHighlight class reorganize!('as yet unclassified')!!CExampleBehavior class reorganize!('as yet unclassified')!!CEventBehavior class reorganize!('instance creation' attachTo:)!!CDropShadowHighlight class reorganize!('as yet unclassified')!CDirectoryEntry initialize!!CDirectoryEntry class reorganize!('class initialization' initialize shutDown)!!CDialog class reorganize!('instance creation' new)('debugging' abortRetryDebug: abortRetryDebug:centerAt: abortRetryDebug:label: abortRetryDebug:label:centerAt:)('confirming' confirm: confirm:centerAt: confirm:label: confirm:label:centerAt:)('informing' inform: inform:centerAt: inform:label: inform:label:centerAt:)('requesting' request: request:centerAt: request:initialAnswer: request:initialAnswer:centerAt: requestPassword: requestPassword:centerAt:)!!CCursorHighlight class reorganize!('as yet unclassified')!CCostumeTextHolder initialize!!CCostumeTextHolder class reorganize!('instance creation' new)('class initialization' initialize)!!CCoronaHighlight class reorganize!('as yet unclassified')!!CBorderHighlight class reorganize!('as yet unclassified')!!CCostumeHighlight class reorganize!('as yet unclassified')!!CCostumeGrid class reorganize!('accessing' gridCacheAt:)!!CCostumeGraphic class reorganize!('instance creation' new)!!CCostumeFill class reorganize!('instance creation' new)!!CCostumeBorder class reorganize!('instance creation' style:width:color:)!!CCostumeAspect class reorganize!('instance creation' forCostume: new)!!CArrayedCollectionClient class reorganize!('as yet unclassified')!!CCollectionClient class reorganize!('as yet unclassified')!!CCollection class reorganize!('instance creation')('accessing' defaultCostumeMaker)!!CCollectionBase class reorganize!('as yet unclassified')!!CObject class reorganize!('fields' addField:defaultValue: compileAccessorsFor:defaultValue: compilePartAccessorFor: compilePropertyFor:defaultValue: privateAddField: privateRemoveField:)('accessing' compileAllFrom: uuid uuid:)('class definition')('migration')('factory' next)('instance creation' named: new on:)('*Tweak-Resources' embedResourceIn: embedResourceIn:notifying: exportFieldsOn: exportScriptsOn: exportXmlContentsOn: exportXmlOn: extractResourceFrom:in: importFieldsFrom: importScriptsFrom: importXmlResource:in: resourceDirectory resourceID resourceType)!!CMouseOverHandler class reorganize!('instance creation' new)!!CMouseClickState class reorganize!('as yet unclassified')!CMatrixTransform initialize!!CMatrixTransform class reorganize!('instance creation' fromRemoteCanvasEncoding: identity localRect:toGlobal: new newFromStream: transformFromLocal:toGlobal: withAngle: withOffset: withRotation: withScale:)('class initialization' initialize)!!CGlobalPart class reorganize!('as yet unclassified')!!CMakerPart class reorganize!('as yet unclassified')!CMD5Hasher initialize!!CMD5Hasher class reorganize!('utilities' hashMessage: hashStream:)('testing' test)('class initialization' initialize)!!CLayoutProperties class reorganize!('instance creation' new)!!CLayoutFrame class reorganize!('as yet unclassified' classVersion fractions: fractions:offsets: offsets:)!!CLayoutCell class reorganize!('as yet unclassified')!!CKeyboardDispatchTable class reorganize!('instance creation' new)!CIdentityTransform initialize!!CIdentityTransform class reorganize!('instance creation' new)('class initialization' initialize)!CIconLibrary initialize!!CIconLibrary class reorganize!('instance creation' new)('class initialization' initialize)('accessing' at: default)!!CGraphicsShape class reorganize!('as yet unclassified')!!CGraphicsFill class reorganize!('instance creation' none solid)!!CFormCache class reorganize!('instance creation' new)!!CDisplayTransform class reorganize!('instance creation' identity)!!CDeserializer class reorganize!('as yet unclassified' deserialize: new)!!CDamageRecorder class reorganize!('instance creation' new)!CCursorLibrary initialize!!CCursorLibrary class reorganize!('initialize' initialize)('accessing' default default: resizeForEdge:)('cursors' bottomLeftCursor bottomRightCursor diagonalCursor dragCursor fistCursor handCursor leftRightCursor textCursor topBottomCursor topLeftCursor topRightCursor)!!CCostumePen class reorganize!('accessing' defaultColor defaultWidth)('instance creation' new)!CCornerRounder initialize!!CCornerRounder class reorganize!('all' cornerSize initialize rectWithinCornersOf: roundCornersOf:on:in:displayBlock:borderWidth:corners:)!!CComponentBinding class reorganize!('as yet unclassified')!!CAnyMatcher class reorganize!('as yet unclassified')!!CAllMatcher class reorganize!('as yet unclassified')!!CCollectionMatcher class reorganize!('instance creation' on:)!!CClipboard class reorganize!('accessing' clipboardAt: clipboardAt:put: clipboardClear clipboardFormats clipboardText clipboardText: default default:)('instance creation' new)!!CChangeRecord class reorganize!('as yet unclassified')!!CCanvasCache class reorganize!('as yet unclassified')!!CBorder class reorganize!('instance creation' borderStyleChoices borderStyleForSymbol: color:width: complexAltFramed complexAltInset complexAltRaised complexFramed complexInset complexRaised default inset none raised simple width: width:color:)!!CWorldPlayer reorganize!('Morphic-support' close ownerMorph ownerMorph: runCroquetCycle runMorphicCycle)('running' onDrop: run run: runLayoutCycle runWorldCycle)('hands' addHand: hands primaryHand removeHand:)('accessing' activeProject activeProject: display display: displayDepth: displayExtent displayExtent: eventQueue eventQueue: label label: maxLayoutRounds maxLayoutRounds: minCycleTime scheduler)('private' isSpecialSystemScript: setScheduler:)('geometry' standardBounds)('initialize' bootstrap: initialize onBootstrap)('drawing' displayWorld flashRects:color:)('serializing' serializeOn:)!!CWorldCostume reorganize!('accessing' isWorld root)!!CWorkspace reorganize!('accessing' bindings bindings:)('bindings' bindingOf:)!!CWindowResizeBehavior reorganize!('initialize' initialize)('accessing' automaticDragging automaticDragging: resizeWithContents resizeWithContents:)('events' onResize onResizeTrack resizerEdge)!!CWindowCostumeFrame reorganize!('initialize' initialize setupCostume)('accessing' closeBox: closeButton closeButton: collapseButton collapseButton: label label: maximizeBox: minimizeBox: windowColor: windowLabel windowLabel:)('events' onClose onCollapse)!!CWindowCostume reorganize!('initialize' defaultColor defaultPlayer initialize setupCostume)('accessing' backPage backPage: frontPage frontPage: layout layout: windowColor: windowContents windowFrame windowFrame: windowLayout windowLayout:)('events' onClose onCloseBoxChanged onCollapse onLabelChanged onMaximizeBoxChanged onMenuBarChanged onMinimizeBoxChanged onMouseDown onPlayerChanged onStatusBarChanged onToolBarChanged onUpdateAll)('serializing' readFieldsOn: writeFieldsOn:)('resizing')!!CWindowButtonCostume reorganize!('initialize' setupCostume)('events' onButtonStateChanged)!!CWindow reorganize!('initialize' defaultCostume initialize)('accessing' closeBox closeBox: elements label label: maximizeBox maximizeBox: menuBar menuBar: minimizeBox minimizeBox: statusBar statusBar: toolBar toolBar:)('color and fill' onColorChanged onWindowColorChanged: windowColor windowColor:)('layout' layout layout:)!!CWidgetLibrary reorganize!('lists' dropDownListCostume listCostume spinnerListCostume stringListCostume treeCostume)('buttons' buttonCostume checkBoxCostume pushButtonCostume radioButtonCostume tabButtonCostume)('scrolling' scrollBarCostume scrollBarHeight scrollPaneCostume spinnerCostume)('basic' labelCostume sliderCostume)('menus' menuCostume menuItemCostume)('todo')('windows' windowCostume)('colors' baseColor frameColor gradientColors menLabelTextColor menuColors noColor paneColor windowColor)!!CWheelWidgetCostume reorganize!('field access' maxAngle maxAngle: wheelAngle wheelAngle:)('initialize' defaultPlayer initialize)('serializing')('drawing' drawOn:in:)('events' onMouseDown)!!CTreeWidgetCostume reorganize!('initialize' defaultPlayer setupCostume)('events' handleKey: onCursorChanged onElementsChanged onKeyDown: onMouseDown onPlayerChanged)('accessing' cursor cursor: playerCopyFrom:to: selectedPlayer selectedPlayer:)!!CToolBarButtonCostume reorganize!('initialize' setupCostume)('accessing' windowColor:)('events' onButtonStateChanged onSelectedChanged)!!CTileButtonCostume reorganize!('initialize' setupCostume)('events' onButtonStateChanged)!!CInputFieldCostume reorganize!('initialize' defaultPlayer setupCostume)('events' onKeyboardFocusEnter)!!CTextEditorCostume reorganize!('initialize' defaultPlayer setupCostume)('events' onKeyboardFocusEnter onKeyboardFocusLeave)('accessing' oldBorder oldBorder:)!!CTabButtonListCostume reorganize!('initialize' defaultColor defaultPlayer setupCostume)('accessing' selectedPlayer selectedPlayer:)('events' onButtonSelected onCursorChanged onElementsChanged onPlayerChanged)!!CTabButtonCostume reorganize!('initialize' defaultPlayer initialize setupCostume)('events' onButtonStateChanged onImageChanged onSelectedChanged)!!CStringListCostume reorganize!('initialize' defaultPlayer)('drawing' drawItem:in:on:)!!CSpinnerListCostume reorganize!('initialize' defaultPlayer initialize setupCostume)('accessing' label label: spinner spinner:)('events' onCursorChanged onPlayerChanged onSpinDown onSpinUp)!!CSpinnerCostume reorganize!('initialize' defaultPlayer initialize setupCostume)('accessing' spinnerButtons spinnerButtons: spinnerLabel spinnerLabel: spinnerValue spinnerValue:)('events' onInputValueChanged onLabelChanged onPlayerChanged onSpinDown onSpinUp onSpinnerValueChanged onValueChanged)!!CSpinnerButtonsCostume reorganize!('initialize' initialize setupCostume)('accessing' downButton downButton: upButton upButton:)('events' onSpinDown onSpinUp)!!CScrollBarCostume reorganize!('initialize' defaultPlayer initialize setupCostume)('accessing' backButton backButton: buttonHeight buttonHeight: forwardButton forwardButton: innerBounds knob knob: knobShadow knobShadow: windowColor:)('testing' isHorizontal)('events' onButtonHeightChanged onExtentChanged onMaxChanged onMinChanged onOrientationChanged onScrollAbsolute onScrollAbsolute: onScrollBack onScrollBy: onScrollByPage onScrollByPage: onScrollForward onValueChanged onVisibleFractionChanged)('layout' onLayoutChanged onUpdateScrollBar positionKnob)!!CSliderCostume reorganize!('initialize' defaultPlayer)('accessing' adoptValue: fraction max max: min min: orientation orientation: pageStep pageStep: range step step: visibleFraction visibleFraction:)('testing' isHorizontal)!!CScrollableTextEditorCostume reorganize!('initialize' defaultColor defaultPlayer setupCostume)('accessing' textHolder)('events' onPlayerChanged)!!CScrollPaneCostume reorganize!('initialize' defaultPlayer initializeDefaultScrollTarget)('events' onHolderChanged onScrollTargetChanged)!!CMultiColumnListCostume reorganize!('initialize' buildHeader)('accessing' columns columns: header header:)('drawing' drawBackgroundStripesOn:in: drawItem:in:on: drawListOn:in:)!!CListCostume reorganize!('initialize' defaultPlayer setupCostume)('accessing' selectedPlayer selectedPlayer:)('events' onCursorChanged onElementsChanged onItemMakerChanged onKeyDown: onMouseDown onPlayerChanged)!!CCustomDrawListCostume reorganize!('initialize' initialize initializeDefaultScrollTarget setupCostume)('accessing' cursor cursor: itemHeight playerFont selectionColor selectionColor: selectionIndex selectionIndex: windowColor:)('selecting' cursorFromPoint: deselectIndex: invalidationRect: scrollToSelection: selectIndex: selectionRect:)('drawing' drawItem:in:on: drawListOn:in: drawOn:in: drawSelectionIn:on:)('events' onCursorChanged onElementsChanged:from:to:event: onKeyDown: onMouseDown onPlayerChanged onUpdateScrollRange)!!CScrollableCostume reorganize!('initialize' initialize initializeDefaultScrollTarget setupCostume)('accessing' hScrollBar hScrollBar: layout layout: scrollOffset scrollOffset: scrollTarget scrollTarget: vScrollBar vScrollBar: windowColor:)('events' onContextMenu onHScrollableChanged onPlayerChanged onScrollAbsoluteX onScrollAbsoluteY onScrollOffsetChanged onScrollTargetChanged onVScrollableChanged)('layout' onUpdateLayout onUpdateScrollRange positionHScrollBar:in: positionTarget:in: positionVScrollBar:in:)!!CScrollButtonCostume reorganize!('initialize' setupCostume)('accessing' windowColor:)('events' deselect onButtonStateChanged select)!!CRadioButtonCostume reorganize!('accessing' checkMark checkMark:)('initialize' initialize setupCostume)('events' onSelectedChanged)!!CPushButtonCostume reorganize!('initialize' defaultPlayer setupCostume)('events' deselect onButtonStateChanged onSelectedChanged select)('accessing' windowColor:)!!CMenuBarCostume reorganize!('initialize' setupCostume)('accessing' asMenuItemCostume: sticky windowColor:)('events' isMenuBar onMouseDown onMouseLeave updateSelectionSubMenu:)!!CMenuCostume reorganize!('initialize' destroy initialize onOpen setupCostume)('accessing' activeChild activeChild: activeParent activeParent: asMenuItemCostume: holder holder: menuCursor menuCursor: menuItems menuLabel menuLabel: menuSelection menuSelection: selectedPlayer selectedPlayer: sticky)('events' activeParentMenu fireItem: isMenuBar onLabelChanged onLabelDrag onMenuCursorChanged onMenuItemsChanged onMouseDown onMouseMove onMouseUp onPlayerChanged onYellowButtonDown onYellowButtonUp showSubMenu: updateSelectionSubMenu:)!!CLabelCostume reorganize!('events' onFontChanged onLabelChanged onPlayerChanged onValueChanged)('initialize' defaultPlayer setupCostume)!!CDropDownListCostume reorganize!('initialize' defaultPlayer initialize setupCostume)('events' onAllowEditingChanged onCursorChanged onElementsChanged onLabelValueChanged onMouseDown onPlayerChanged)('accessing' button button: label label: textHolder textHolder:)('color and fill' windowColor:)!!CCheckBoxCostume reorganize!('initialize' initialize setupCostume)('accessing' checkMark checkMark:)('events' onButtonStateChanged onPlayerChanged onValueChanged)!!CButtonCostume reorganize!('initialize' defaultPlayer initialize setupCostume)('accessing' buttonImage buttonImage: buttonLabel buttonLabel: image image: textHolder textHolder:)('events' onButtonStateChanged onFontChanged onImageChanged onLabelChanged onMouseDown onMouseEnter onMouseLeave onMouseUp onPlayerChanged onSelectedChanged)!!CWidgetCostume reorganize!('accessing' enabled enabled: label label:)('initialize' defaultPlayer)!!CWheelWidget reorganize!('initialize')!!CToolBarButton reorganize!('initialize' defaultCostume)!!CTileButton reorganize!('initialize' defaultCostume)!!CInputField reorganize!('initialize' defaultCostume defaultTarget initialize onKeyboardFocusEnter)('events' onAccept)('accessing' converter converter:)('converting' printValue: readValue:)!!CTextEditor reorganize!('initialize' defaultCostume defaultTarget initialize)('accessing' allowEditing allowEditing: caseSensitiveSearch caseSensitiveSearch: contents contents: editor emphasis font font: hideTypeInCursor modified modified: searchText searchText: showCaret showCaret: target target: value:)('moving' moveCursorLeft moveCursorRight moveLineDown moveLineEnd moveLineStart moveLineUp moveTextEnd moveTextStart moveWordLeft moveWordRight selectCursorLeft selectCursorRight selectLineDown selectLineEnd selectLineStart selectLineUp selectTextEnd selectTextStart selectWordLeft selectWordRight)('selecting' selectAll selectAt: selectFrom:to: selection selectionStart selectionStart: selectionStop selectionStop:)('operations' append: enter paste: paste:select: redo revert save undo)('text search' findNext findText findText: findText:wrapping: findText:wrapping:caseSensitive:)('events' onAccept onAllowEditingChanged onContextMenu onKeyDown: onKeyStroke: onKeyboardFocusEnter onKeyboardFocusLeave onMouseDown: onMouseEnter onMouseLeave onMouseMove: onMouseMoved: onMouseUp: setTextCursor)('text menu' copySelection cutSelection deleteSelection editMenu pasteSelection)('converting' printValue: readValue:)!!CTabButton reorganize!('initialize' defaultCostume defaultGroup)('events' onFire)!!CSpinnerButtons reorganize!('initialize' defaultCostume)!!CSpinner reorganize!('initialize' defaultCostume initialize)('accessing' label label: max max: min min: step step:)('private' adoptValue:)!!CScrollBar reorganize!('initialize' defaultCostume initialize)('accessing' buttonHeight buttonHeight:)!!CSlider reorganize!('initialize' defaultCostume initialize)('accessing' fraction max max: min min: orientation orientation: pageStep pageStep: range step step: visibleFraction visibleFraction:)('private' adoptValue:)('streaming' atEnd atStart next peek prev)!!CScrollPane reorganize!('initialize' defaultCostume initialize)('accessing' elements holder holder:)!!CRadioButton reorganize!('initialize' defaultCostume defaultGroup)('events' onFire)!!CPushButton reorganize!('initialize' defaultCostume)!!CMenuBar reorganize!('initialize' defaultCostume initialize)!!CMenu reorganize!('initialize' defaultCostume initialize)('accessing' itemNamed: label label: menuItems menuItems:)('construction' add:action: add:subMenu: add:target:action: add:target:action:argument: add:target:action:arguments: add:target:action:checked: add:target:action:disabled: addItem: addItemSpec:target: addList:target: addSeparator)('utilities' choose: choose:from:values:default: chooseFrom: chooseFrom:in: chooseFromValues: chooseFromValues:default: run run:)!!CLabel reorganize!('initialize' defaultCostume initialize)('accessing' label label:)!!CImageButton reorganize!('accessing' disabledImage disabledImage: normalImage normalImage: overImage overImage: pressedImage pressedImage: selectedImage selectedImage:)('events' onButtonStateChanged onNormalImageChanged onSelectedChanged)('initialize' defaultCostume)!!CConstraintValueWidget reorganize!('accessing' value:)('private' adoptValue:)!!CCheckBox reorganize!('initialize' defaultCostume initialize)('events' onFire)!!CButton reorganize!('initialize' defaultCostume defaultGroup initialize)('accessing' group group: image image: label label: selected selected: state state:)('selecting' deselect disable disabled enable select)!!CWidget reorganize!('initialize')('accessing' font font:)!!CViewerRow reorganize!('initialize' initialize setupCostume)('events' onClick onDragStart onMessageTileChanged onMouseDown onMouseEnter onMouseLeave onMouseUp)('firing' fireMessage onFireButtonDown onFireButtonEnter onFireButtonLeave onFireButtonUp)('accessing' fireButton fireButton: messageTile messageTile: readout readout: spacer spacer:)!!CViewerDefinition reorganize!('initialize' initialize)('accessing' categories categories:)('creating' new newFor:)('printing' printXmlOn: readXmlFrom:)!!CViewerCategoryHeader reorganize!('intialize' initialize setupCostume)('accessing' categoryLabel categoryLabel: label label: nextArrow nextArrow: prevArrow prevArrow:)('events' onNextArrow onPrevArrow)!!CVectorShape reorganize!('accessing' bounds bounds: compressedShape compressedShape:)('drawing' drawOn:in:)!!CVariableTileCostume reorganize!('initialize' defaultPlayer initialize setupCostume)('accessing' dropEnabled dropEnabled:)('events' onExpressionChanged onPlayerChanged)('drag and drop' onDragEnter onDragStart onDropEnabledChanged runDropLoop:)!!CVariableTile reorganize!('initialize' defaultCostume initialize)('accessing' expression expression:)('testing' isArgumentTile)('evaluating' eval)!!CValueTileCostume reorganize!('initialize' defaultPlayer setupCostume)('events' onPlayerChanged onValueChanged)!!CValueTile reorganize!('initialize' defaultCostume)('accessing' valueType)('testing' isValueTile)!!CMenuItemCostume reorganize!('initialize' defaultPlayer initialize setupCostume)('accessing' action action: checkMarker checkMarker: checked checked: enabled enabled: isSeparator itemLabel itemLabel: label label: subMenu subMenu: subMenuMarker subMenuMarker:)('events' deselect onCheckedChanged onEnabledChanged onFire onLabelChanged onSubMenuChanged onValueChanged select)!!CListItem reorganize!('initialize' setupCostume)('selecting' deselect select)('events' onValueChanged)!!CValuePlayer reorganize!('as yet unclassified')!!CUserDialog reorganize!('initialize' initialize setupCostume)('events' onAccept onCancel onOpen)('requests' abortRetryDebug:label:centerAt: confirm:label:centerAt: inform:label:centerAt: request:initialAnswer:centerAt: requestPassword:centerAt:)('construction' addButton: addButton:value:)('running' endDialog: run run: run:centerAt:)('accessing' buttonRow buttonRow: dialogLabel dialogLabel: label label: message message: messageText messageText:)!!CTweakedPart reorganize!('exporting' exportPartOn:key:)('accessing' partBinding partBinding:)('*Tweak-Tweaks' tweak:in:)('creating' createPartIn:)!!CTweakSerializer reorganize!('writing' writeContentsOf: writeCostume: writeOwned:home:role: writeScripted:)!!CTweakMaker reorganize!('private-defaults' makeNewPart: makerType newDeserializer newSerializer tweakObjectPart:)('exporting' tdlPrintString xmlPrintString)!!CTweakDeserializer reorganize!('reading' readContentsOf: tweakField:value: tweakValue:from:)!!CTreeWidget reorganize!('initialize' defaultCostume initialize)('accessing' allowDeselect allowDeselect: root root: rootNode rootNode: rootNodes rootNodes: roots roots:)('events' onRootNodesChanged)('operations' expandPath:)('private-tree' addTreeNodes:at: indexOfTreeNode: isRootNode: removeTreeNodesFrom:to: replaceTreeNodesFrom:to:with: treeNodes treeNodes:)!!CTreeItemCostume reorganize!('initialize' defaultColor defaultPlayer initialize setupCostume)('accessing' label label: marker marker: markerExtent)('selecting' deselect onExpand onExpandedChanged onIndentationChanged onLabelChanged onPlayerChanged select)!!CServerDirectoryTreeItem reorganize!('templates' getChildren getLabel hasChildren)!!CFileDirectoryTreeItem reorganize!('templates' getChildren getIcon getLabel hasChildren)!!CTreeItem reorganize!('initialize' defaultCostume initialize)('templates' getChildren getIcon getLabel hasChildren)('accessing' children children: expanded expanded: icon icon: indentation indentation: label label: parent parent: tree tree: value:)('expanding' collapse expand)('events' onValueChanged)('private' anyChangedFrom:to: indexOfFirstOpenNode indexOfLastOpenNode installChildren: printOn:)!!CTileViewerPage reorganize!('initialize' setupCostume)('adding' contents:)!!CTileViewer reorganize!('initialize' initialize setupCostume)('accessing' categories categories: categoryList categoryList: header header: holder holder: pages pages:)('adding' addPage:)('events' onCursorChanged onGotoNext onGotoPrev onLabelHit)!!CFillStyleType reorganize!('as yet unclassified')!!CButtonStateType reorganize!('as yet unclassified')!!CBorderStyleType reorganize!('as yet unclassified')!!CSymbolType reorganize!('as yet unclassified')!!CStringType reorganize!('as yet unclassified')!!CSoundNameType reorganize!('as yet unclassified')!!CImageResourceType reorganize!('as yet unclassified')!!CResourceType reorganize!('as yet unclassified')!!CPlayerType reorganize!('as yet unclassified')!!CIntegerType reorganize!('as yet unclassified')!!CNumberType reorganize!('as yet unclassified')!!CBooleanType reorganize!('as yet unclassified')!!CEnumType reorganize!('as yet unclassified')!!CColorType reorganize!('as yet unclassified')!!CTileType reorganize!('as yet unclassified')!!CTileReadout reorganize!('initialize' initialize setupCostume)('accessing' editor editor: field field: fieldType fieldType: label label:)('events' onValueChanged printValue: readValue:)('private' defaultEditor editorForType: installFieldType:)!!CScriptorTile reorganize!('initialize' defaultCostume initialize)('accessing' receiver receiver: selector selector: trigger trigger:)!!CSequenceTile reorganize!('initialize' defaultCostume initialize)('accessing' statements statements:)('evaluating' eval)!!CPropertyTile reorganize!('initialize' defaultCostume)('accessing' fieldName property property: receiver receiver:)('testing' isPropertyTile)('evaluating' eval)!!COperatorTile reorganize!('initialize' defaultCostume)('testing' isComplex)('evaluating' eval)!!CMessageTile reorganize!('initialize' defaultCostume initialize make3plus4 makeAddTo makeForwardBy)('accessing' arguments arguments: receiver receiver: selector selector:)('testing' isComplex isMessageTile isStatementLike)('evaluating' eval)('private' add:to:)!!CTilePlayer reorganize!('accessing' definition definition: fieldName valueType valueType:)('testing' isArgumentTile isComplex isMessageTile isPropertyTile isStatementLike isTilePlayer isValueTile)('converting' asArgument)('evaluating' eval)!!CTileLibrary reorganize!('defaults' argumentTileCostume messageTileCostume operatorTileCostume scriptorTileCostume sequenceTileCostume tileFont)('value tiles' valueTileForType:)!!CTileInspector reorganize!('initialize' initialize setupCostume)('accessing' category category: fieldList fieldList: target target:)('events' onCategoryChanged onTargetChanged)('updating' updateFieldList)('private' messageTileFor:in: shouldShowField:)!!CSlotDefinition reorganize!('creating' new newFor:)('printing' printXmlOn: readXmlFrom:)!!COperatorDefinition reorganize!('initialize' initialize)('accessing' arguments arguments:)('creating' new newFor:)('printing' printXmlOn: readXmlFrom:)!!CMessageDefinition reorganize!('initialize' initialize)('accessing' arguments arguments:)('creating' new newFor:)('printing' printXmlOn: readXmlFrom:)!!CCategoryDefinition reorganize!('initialize' initialize)('accessing' items items:)('creating' new newFor:)('printing' printXmlOn: readXmlFrom:)!!CArgumentDefinition reorganize!('accessing' defaultValue defaultValue:)('creating' new newFor:)('printing' printXmlOn: readXmlFrom:)!!CTileDefinition reorganize!('accessing' externalName externalName: helpText helpText: selector selector: type type:)('creating' new newFor:)('printing' xmlString)('private' typeNamed:)!!CStringTileCostume reorganize!('initialize' initialize setupCostume)('accessing' editor editor:)('events' onAcceptValue onPlayerChanged onValueChanged)!!CSoundTileCostume reorganize!('accessing' label label: spinner spinner:)!!CScriptorTileCostume reorganize!('initialize' initialize setupCostume)('accessing' header header:)('events' onPlayerChanged onReceiverChanged onSelectorChanged)!!CSequenceTileCostume reorganize!('initialize' defaultPlayer initialize setupCostume)('accessing' spacer spacer: target target:)('events' onDragStart: onPlayerChanged onStatementsChanged)('drag and drop' onDragEnter onTileEnter onTileSequenceLeave trackDropZones)!!CReceiverTileCostume reorganize!('initialize' defaultPlayer initialize setupCostume)('accessing' reflexive reflexive:)('events' onNameChanged onValueChanged)!!CPropertyTileCostume reorganize!('initialize' defaultPlayer initialize setupCostume)('accessing' propertyName propertyName: receiverTile receiverTile:)('events' onPlayerChanged onPropertyChanged onReceiverChanged onTilePadDragged: onTilePadDropped:)!!COperatorTileCostume reorganize!('initialize' setupCostume)('accessing' leftHandTile leftHandTile: operatorTile operatorTile: rightHandTile rightHandTile:)('events' onPlayerChanged onTilePadDragged: onTilePadDropped: onUpdateEverything)!!CNumberTileCostume reorganize!('initialize' initialize setupCostume)('accessing' editor editor: spinner spinner:)('events' onEditorChanged onEditorFocusLost onPlayerChanged onSpinDown onSpinUp onValueChanged)!!CMessageTileCostume reorganize!('initialize' defaultPlayer initialize setupCostume)('accessing' argumentsTile argumentsTile: expandArrow expandArrow: fireButton fireButton: receiverTile receiverTile:)('events' onFireButtonPressed onPlayerChanged onReceiverChanged onTilePadDragged: onTilePadDropped: onValueTypeChanged)!!CMessagePartCostume reorganize!('initialize' defaultPlayer setupCostume)('events' onValueChanged)!!CMessageAndArgsCostume reorganize!('initialize' defaultPlayer setupCostume)('events' onArgumentsChanged onPlayerChanged onSelectorChanged onUpdateEverything)('private' tileForArgument: tileForMessagePart:)!!CImageResourceTileCostume reorganize!('initialize' initialize setupCostume)('accessing' button button: editor editor:)('events' onButtonPressed onEditorAccept onPlayerChanged onValueChanged)!!CEnumTileCostume reorganize!('initialize' initialize setupCostume)('accessing' label label: spinner spinner: valueList valueList:)('events' onContextMenu onPlayerChanged onSpinDown onSpinUp onValueChanged)!!CEnumListCostume reorganize!('initialize' initialize setupCostume)('accessing' list list:)('events' onCursorChanged onPlayerChanged onValueChanged)!!CColorTileCostume reorganize!('initialize' initialize setupCostume)('accessing' swatch swatch:)('events' onExtentChanged onMouseDown onPlayerChanged onValueChanged)!!CTileCostume reorganize!('initialize' setupCostume)('events' onTilePadDragged: onTilePadDropped: tileSignal:)!!CTextTool reorganize!('intialize' initialize setupCostume)('accessing' blockAlign blockAlign: boldButton boldButton: centerAlign centerAlign: editor editor: fontNames fontNames: fontSizes fontSizes: geometry italicButton italicButton: leftAlign leftAlign: rightAlign rightAlign: struckoutButton struckoutButton: underlineButton underlineButton: window window:)('color and fill' windowColor:)('events' onEditorChanged onFontNameChanged onFontSizeChanged onKeyboardFocusChanged onTextSelectionChanged onUpdateFont selectFont: selectedFont selectedFontSize selectedFontStyle)('emphasis' changeEmphasis: onBoldChanged onItalicChanged onStruckoutChanged onUnderlinedChanged onUpdateEmphasis)!!CTextParagraphEditor reorganize!('editor commands' addAttribute: align: changeEmpasisHere: changeFontHere: redo selectFontNamed:pointSize: undo)('cursor keys' moveCursorLeft moveCursorRight moveLineDown moveLineEnd moveLineStart moveLineUp moveTextEnd moveTextStart moveWordLeft moveWordRight selectCursorLeft selectCursorRight selectLineDown selectLineEnd selectLineStart selectLineUp selectTextEnd selectTextStart selectWordLeft selectWordRight)('private' adjustRightXBy: emphasisHere markBlock moveCaretTo:selecting: pointBlock prepareUndo:type: privateAnchor:at:type: replaceFrom:to:with: replaceSelectionWith:type: selectionRect textSelectionChanged undoCommand: updateEmphasisHere zapSelectionWith:)('selecting' replaceSelectionWith: replaceSelectionWith:allowUndo: selectAll selectAt: selectFrom:to: selectLine selectLineIfEmpty selectWordAt: selection selectionStart selectionStop)('initialize' closeUndoStack extent: paragraph:)('accessing' attributesAt: costume costume: emphasis extent font hasKeyboardFocus minimalTextExtent minimalTextWidth modified modified: paragraph showCaret showCaret: text text: textLines visibleLines visibleLinesIn:)('anchoring' adjustTextAnchor: anchor: anchor:at: anchor:at:type: removeAnchor:)('mouse input' mouseDown: mouseMove: mouseUp:)('editing keys' backspace forwardDelete keyStroke:)!!CTextParagraph reorganize!('display' caretWidth displayOn:using:at: displaySelectionInLine:from:to:on: insertionPointColor selectionColor)('private' fastFindFirstLineSuchThat: lineIndexForCharacter: lineIndexForPoint: lineIndexOfCharacterIndex: lines)('accessing' adjustRightXBy: attributesAt: bounds characterBlockAtIndex: editor editor: extent height indexOfCharacterAbove: indexOfCharacterBelow: indexOfNextWord: indexOfPreviousWord: lineSelectionIntervalAt: minimalTextExtent minimalTextWidth numberOfLines replaceFrom:to:with: setExtent: size string text textStyle textStyle: width wordSelectionIntervalAt:)('selection' characterBlockAtPoint: characterBlockForIndex: containsPoint: selectionRectsFrom:to:)('composition' compose:style:from:in: composeAll composeLinesFrom:to:delta:into:priorLines:atY: compositionRectangle recomposeFrom:to:delta:)!!CTextEditorPane reorganize!('accessing' editor editor: oldBorder oldBorder:)('events' onKeyboardFocusEnter onKeyboardFocusLeave)('initialize' setupCostume)!!CStringConverter reorganize!('converting' printValue: readValue:)!!CNumberConverter reorganize!('converting' readValue:)!!CDateConverter reorganize!('accessing' format format:)('converting' printValue: readValue:)!!CTextConverter reorganize!('converting' printValue: readValue:)!!CTextComposer reorganize!('as yet unclassified' addNullLineForIndex: addNullLineWithIndex:andRectangle: checkIfReadyToSlide composeAllLines composeAllRectangles: composeEachRectangleIn: composeLinesFrom:to:delta:into:priorLines:atY:textStyle:text:container:wantsColumnBreaks: composeOneLine fixupLastLineIfCR slideOneLineDown)!!CTableLayoutProperties reorganize!('initialize' initialize)('accessing' cellInset cellInset: cellPositioning cellPositioning: cellSpacing cellSpacing: listCentering listCentering: listDirection listDirection: listSpacing listSpacing: maxCellSize maxCellSize: minCellSize minCellSize: reverseTableCells reverseTableCells: rubberBandCells rubberBandCells: wrapCentering wrapCentering: wrapDirection wrapDirection:)('testing' includesTableProperties)!!CTableLayout reorganize!('initialize' initialize loadFrom: newListDirection:)('accessing' cellInset cellInset: cellPositioning cellPositioning: cellSpacing cellSpacing: inset listCentering listCentering: listDirection listDirection: listSpacing listSpacing: maxCellSize maxCellSize: minCellSize minCellSize: reverseTableCells reverseTableCells: rubberBandCells rubberBandCells: wrapCentering wrapCentering: wrapDirection wrapDirection:)('layout' computeCellArrangement:in:horizontal:target: computeCellSizes:in:horizontal: computeExtraSpacing:in:horizontal:target: computeGlobalCellArrangement:in:horizontal:wrap:spacing: flushLayoutCache layout:in: minExtentOf:in: placeCells:in:horizontal:target:)('copying' postCopy)('optimized' layoutLeftToRight:in: layoutTopToBottom:in: minExtentHorizontal: minExtentVertical:)('serializing')('testing' isTableLayout)('private' updateWrapDirection updateWrapDirection:)!!CTabButtonList reorganize!('initialize' defaultCostume initialize)!!CStyleReadoutList reorganize!('initialize' setupCostume)('accessing' selection selection:)('events' onCursorChanged onMouseDown onValueChanged)!!CStringList reorganize!('initialize' defaultCostume)!!CSpinnerList reorganize!('initialize' defaultCostume)!!CSoundResource reorganize!('accessing' resourceType)('Sound-support' play)('private' extractMediaFrom: rawMediaExtension setMedia: storeRawMediaContentsOn: storeXmlMediaAttributesOn:)!!CSoundPlayer reorganize!('initialize' initialize)!!CSolidFill reorganize!('testing' isSolidFill isTranslucent isTransparent)('printing' printOn:)('accessing' color: display scaledPixelValue32 style)('converting' asColor)!!CSimpleTextEditor reorganize!('initialize' initialize setupCostume)('accessing' editor editor: geometry window window:)!!CSimpleLayout reorganize!('layout' flushLayoutCache layout:in: minExtentOf:in:)('testing' isSimpleLayout)!!CRaisedBorder reorganize!('accessing' bottomRightColor colorsAtCorners style topLeftColor)('color tracking' trackColorFrom:)!!CInsetBorder reorganize!('accessing' bottomRightColor colorsAtCorners style topLeftColor)('color tracking' trackColorFrom:)!!CComplexBorder reorganize!('private' colorsForDirection: computeAltFramedColors computeAltInsetColors computeAltRaisedColors computeColors computeFramedColors computeInsetColors computeRaisedColors fillStyleForDirection: intersectFrom:with:to:with:)('drawing' drawLineFrom:to:on: drawPolyPatchFrom:to:on:usingEnds: framePolygon2:on: framePolygon:on: frameRectangle:on:)('accessing' colors colorsAtCorners style style: widthForRounding)('color tracking' trackColorFrom:)('initialize' releaseCachedState)('testing' isComplex)!!CSimpleBorder reorganize!('drawing' drawLineFrom:to:on: frameRectangle:on:)('accessing' baseColor baseColor: bottomRightColor color color: owner owner: style topLeftColor width width:)!!CSequencePart reorganize!('accessing' keysAndValuesDo: partSize partSize:)('exporting' exportPartOn:key: xmlTagName)('creating' constructPartIn: createPartIn:)('importing' remapIn: resolveIn:)('*Tweak-Tweaks' tweak:in:)!!CResourcePart reorganize!('*Tweak-Tweaks' tdlPrintPartIdOn: tweak:in:)('as yet unclassified' exportXmlOn:)!!CReferencePart reorganize!('as yet unclassified')!!CBitsArrayPart reorganize!('creating' constructPartIn: createPartIn:)('exporting' exportBitsOf: exportPartOn:key: xmlTagName)('importing' remapIn: resolveIn:)('*Tweak-Tweaks' tdlPrintContentsOn:indent: tweak:in:)('accessing' keysAndValuesDo:)!!CObjectPart reorganize!('creating' constructPartIn: createPartIn: postBuildIn:)('accessing' contents contents: keysAndValuesDo: partMaker partMaker:)('printing' printOn:)('*Tweak-Tweaks' tdlPrintContentsOn:indent: tdlPrintOn:indent: tdlPrintPartIdOn: tweak:in:)('importing' remapIn: resolveIn:)('exporting' exportPartOn:key: xmlTagName)!!CSharedPart reorganize!('exporting' exportPartOn:key: exportXmlOn: exportXmlOn:key:)('*Tweak-Tweaks' tdlPrintPartIdOn:)('accessing' partID partID:)!!CObjectMakerSerializer reorganize!('types-optional' writeBitsArray: writeColor: writeFont: writePoint: writeSequence: writeString:)('interface' imports parentField parentValue replace:by: serialize: serialize:on: writeContentsOn: writeField:value:)('private' storeContents:using:)('types-special' writeResource: writeUUID:)('references' lookupReference: registerReference:for:)('initialize' initialize)('types-required' writeGlobal:constructor:arguments: writeLiteral: writeObject: writeReference:)!!CSerializer reorganize!('types-prohibited' writeCompiledMethod: writeContext: writeProcess:)('types-optional' writeBitsArray: writeClass: writeCollection: writeColor: writeCostume: writeDictionary: writeFont: writeForm: writeOwnedPlayer: writePlayerCostume: writePoint: writeRectangle: writeScripted: writeSequence: writeString: writeText:)('types-required' writeGlobal: writeGlobal:constructor: writeGlobal:constructor:arguments: writeLiteral: writeObject: writeProhibited: writeReference: writeResource:)('types-literal' writeBoolean: writeCharacter: writeNil: writeNumber: writeUUID:)('private-writing' write: writeContentsOf:)('private-references' lookupReference: newReference: registerReference:for:)('initialize' initialize serialize:)('interface' writeField:value:)!!CScriptorHeader reorganize!('initialize' initialize setupCostume)('accessing' closeButton closeButton: collapseButton collapseButton: fireButton fireButton: rcvrLabel rcvrLabel: scriptName scriptName: ticker ticker: trigger trigger:)!!CKeywordsForObject reorganize!('generate' assign:gets:field:value: assign:new: elementPresent: elementsOf:add:at: methodHeader:for:on: returnTempVar: store:withSetter:in: testClassOf:tempName:)('accessing' keywords)!!CEnglishObjOutline reorganize!('generate' assign:gets:field:value: assign:new: bullet elementPresent: elementsOf:add:at: methodHeader:for:on: returnTempVar: store:withSetter:in: testClassOf:tempName:)!!CEnglishForObject reorganize!('generate' assign:gets:field:value: assign:new: elementPresent: elementsOf:add:at: methodHeader:for:on: returnTempVar: store:withSetter:in: testClassOf:tempName:)!!CScriptForObject reorganize!('accessing' initialize objToName objToName: sqkCodeStrm sqkCodeStrm: strm suffixCnt suffixCnt:)('work' createTime:near: tempNameAndStore: tempNameFor:)('generate' assign:gets:field:value: assign:new: elementPresent: elementsOf:add:at: methodHeader:for:on: returnTempVar: store:withSetter:in: testClassOf:tempName:)!!CScriptChange reorganize!('accessing' value value:)!!CRootMorph reorganize!('event handling' handleEvent: handlerForMouseDown: handlesMouseOver: mouseEnter:)('geometry' extent:)('drawing' areasRemainingToFill: drawOn:)('stepping' step stepAt:in: stepTime wantsSteps)('accessing' label label: myWorld window window:)('initialize' defaultBackgroundColor initialExtent initialize)!!CResourceManager reorganize!('accessing' at: at:put: lookup: lookup:ifAbsent: lookup:ifAbsentPut: uidFor: uidFor:ifAbsent:)('initialize' initialize)!!CObjectMaker reorganize!('interface' importsDo: newFrom: next saveOn: saveTo:)('importing' extractResourceFrom:in: readFrom:in:)('private-factory' constructObjectFrom: createPart: makeNewPart: makeNewPart:size: partWithID: rootClass rootField)('accessing' importXMLContentsFrom:in: imports imports: name name: nextVersion nextVersion: prevVersion prevVersion: resourceType saveFullOn: saveFullTo: saveZipTo: uuid uuid:)('exporting' embedResourceIn: embedResourceIn:notifying: exportXmlContentsOn: resourceID)('private-defaults' makerType newDeserializer newImporter newSerializer)('private')!!CMovieResource reorganize!('accessing' resourceType)('private' extractMediaFrom: rawMediaExtension setMedia: storeRawMediaContentsOn: storeXmlMediaAttributesOn:)!!CImageResource reorganize!('accessing' resourceType)('Form-support' asPlayer boundingBox colormapIfNeededFor: depth drawOn:in: drawOn:in:sourceRect: extent height isForm isOpaque offset width)('private' asSourceForm extractMediaFrom: rawMediaExtension setMedia: storeRawMediaContentsOn: storeXmlMediaAttributesOn:)!!CMediaResource reorganize!('accessing' name name: resourceUrl type type: url url:)('printing' printOn:)('serialization' embedResourceIn: exportXmlOn: extractResourceFrom:in: resourceFileStream)('private' extractMediaFrom: rawMediaExtension setMedia: storeRawMediaContentsOn: storeXmlMediaAttributesOn:)!!CMaker reorganize!('interface' allImportsDo: allImportsDo:excluding: importsDo: new next nextVersionID nextVersionID: prevVersionID prevVersionID: saveTemp)('exporting' writeZipOn: writeZipOn:as: writeZipOn:as:notifying:)('converting' asMaker)('importing' importXMLContentsFrom:including: importXMLFrom:in:)('accessing' resourceUrl)('private-factory' basicNew basicNew: rootClass)('printing' printOn:)('testing' isClassMaker)('serializing' serializeOn:)!!CResource reorganize!('serialization' allImportsDo: allImportsDo:excluding: embedResourceIn: embedResourceIn:notifying: exportXmlOn: resourceDirectory serializeOn:)('accessing' name resourceID resourceType resourceUrl)!!CProportionalLayout reorganize!('testing' isProportionalLayout)('layout' flushLayoutCache layout:in: minExtentOf:in:)!!CPropertyChange reorganize!('accessing' value value:)('as yet unclassified' printOn:)!!CProjectLoader reorganize!('import' importClass: importFont: importForm: importLibrary: importObjectMaker: importScripted: loadResource:type:xmlNode: registerResource:id:)('interface' readFrom:notifying:)!!CProjectLibrary reorganize!('saving' save: save:as:thumbnail: save:thumbnail:)('lookup' bindingOf:)('accessing' contents contents:)('initialize' initialize)('serializing')!!CProjectCostume reorganize!('events' onNameChanged onPlayerChanged onThumbnailChanged)('initialize' deselect initialize select setupCostume)('accessing' image image: label label: listItemValue:)!!CProjectBuilder reorganize!('initialize' initialize installWorldMenu quit setupCostume)('accessing' allProjects allProjects: display lastImportDirectory lastImportDirectory: project project: projectList projectList: standardBounds toolMenuItems window window: worldMenu worldMenu:)('project' closeProject newProject openFile openImageFile openProject openProjectNamed: projectExtent: saveObject saveProject saveProjectAs)('halo' halo move:by: moveDownLayer: moveUpLayer: onHaloCopy onHaloDebug: onHaloDismiss: onHaloDrag: onHaloDup: onHaloEvent: onHaloGrab: onHaloKeyDown: onHaloPaste onHaloRecolor: onHaloRename: onHaloRotate: onHaloSave onHaloSize: onHaloViewer: onPasteBorder: onPasteEmbed: onPasteFill: onPasteGeometry: onPasteLayout: onPastePlayer: resize:by: rotateHaloTarget:from:to:center: trackHaloHandle:in: turn:by: waitHaloAction:)('halo-menu' addCellLayoutMenuItems:to: addEmbeddingItems:to: addLayoutMenuItems:to: addTableLayoutMenuItems:to: embed:into: getHaloMenu: getSaveCostumeMenu: getTileForPlayer: getTileForValue: onChangeCellInset: onChangeLayoutInset: onHaloMenu: saveCostume:for: sendToBack: sendToFront:)('menu' about adjustWorldMenu chooseUpdates:tag: debugMenu displayDepth: exportImage exportObject fileMenu garbageCollect helpMenu loadUpdates memoryInfo newWorldMenu onToolMenuItemsChanged openColoredPlayer openTool: openWidget: optionMenu saveToFile: showReleaseNotes startMessageTally toolsMenu updatesMenu vmStatistics widgetsMenu)('display' onUpdateDisplayDepthMenu onUpdateDisplayDepthMenu: onUpdateDisplaySizeMenu onUpdateDisplaySizeMenu: onUpdateProjectSizeMenu onUpdateProjectSizeMenu: refreshDisplay restoreCursor)('events' dropFile: onBlueButtonDown onDrop: onDropFiles: onLayoutChanged onMouseDown onProjectChanged onViewerClosed onViewerOpened onWindowChanged onWindowResize onWindowUpdate onWorldMenuChanged onYellowButtonDown)('importing')('tools' newLibraryList newProjectList openLibraryList openProjectList)('media' importImageFrom: importMovieFrom: importObject importSoundFrom:)!!CProject reorganize!('initialize' destroy initialize)('field access' library library: thumbnail thumbnail:)('actions' makeThumbnail)('serializing')('accessing' root)('layout' okToPlace:at: positionToOpen:)!!CHandCostume reorganize!('mouse cursor' mouseCursor mouseCursor: showHardwareCursor)('initialize' initialize)!!CPrimitiveCostume reorganize!('accessing' balloonHelp balloonHelp: border border: cacheEnabled cacheEnabled: container costume dropShadow dropShadow: elements elements: fill fill: fullBounds geometry grid grid: hand hidden hidden: localCache localCache: localClipBounds mouseCursor mouseCursor: name overlay overlay: player player: root sticky sticky: textHolder textHolder: transformTo: value value: visible visible: world)('structure' allContainersDo: at: contents contents: contentsAt:behind:unlocked: do: first frameChanged isEmpty keysAndValuesDo: layoutTargets lockContents: size swap:with: withAllContainersDo:)('drawing' areasRemainingToFill: asClipMask clipping clipping: clippingBounds debugDraw displayOn: drawClipMaskOn:in: drawContentsOn: drawGrid:on:in: drawOn: drawOn:in: drawOverlay:on:in: drawOverlayOn: drawPenTrailsOn: drawShape:on:in: drawText:on:in: drawTextOn:in: drawingBounds flash fullDrawOn: hasTranslucentFill insetColor invalidate invalidate: invalidate:from: invalidationSuppressed invalidationSuppressed: localAreasRemainingToFill: localFullDrawOn: makeThumbnail: makeThumbnail:depth: raisedColor shadowForm topDownFullDrawOn:damageList: topDownFullDrawOn:damageList:dirtyRect:startingAt: userDraw userDraw:)('scrolling' privateScrollBy: scrollArea scrollBox scrollOffset scrollOffset: scrollableExtent scrollingDisabled scrollingDisabled: visibleBounds visibleScrollArea)('drag and drop' dragChildAt: floating floating: onDrag onDragMove onMove)('layout' adjustLayoutBounds assureLayoutProperties cellPositioning contentsBounds doLayoutIn: hResizing hResizing: ignoreShrinkWrapConstraints innerBounds invalidateLayout layout layout: layoutBounds layoutBounds: layoutFrame layoutFrame: layoutInBounds: layoutInset layoutInset: layoutNeeded layoutNeeded: layoutProperties layoutProperties: layoutProportionallyIn: layoutSimplyIn: minExtent minHeight minHeight: minWidth minWidth: minimalPartsExtent textBounds vResizing vResizing:)('corners' roundCornerFlags roundCornerFlags: roundCornerSpec roundCornerSpec: roundCorners roundCorners: roundedCorners wantsRoundedCorners)('geometry' angle angle: bottom bottom: bottomLeft bottomLeft: bottomRight bottomRight: bounds bounds: center center: childToParent childToParent: corner corner: costumeMoved: extent extent: globalBounds globalPosition globalPosition: globalToLocal globalToLocal: heading heading: height height: infinite infinite: left left: localBounds localExtent localExtent: localToGlobal localToGlobal: localToWorld localToWorld: origin origin: parentToChild parentToChild: position position: referencePosition referencePosition: resizable resizable: right right: rotationCenter rotationCenter: rotationDegrees rotationDegrees: scale scale: top top: topLeft topLeft: topRight topRight: transform transform: width width: worldToLocal worldToLocal: x x: y y:)('adding' add: add:after: add:at: add:atIndex: add:before: add:frame: add:frame:offsets: add:fullFrame: addAll: addAll:after: addAll:at: addFirst: addLast: indexOf: indexOf:ifAbsent: indexOf:startingAt:ifAbsent: replace:with: replaceFrom:to:with: replaceFrom:to:with:startingAt:)('text anchoring' inlineTextAnchorPosition: relativeTextAnchorPosition relativeTextAnchorPosition: textAnchorType textAnchorType:)('testing' fullContainsPoint: hasKeyboardFocus hasMouseFocus isIn: isInWorld isOrIn: isPrimitiveCostume isTextCostume isWorld isWorld: locked locked:)('event handling' containsEvent: containsPoint: dispatchEvent: eventShield eventShield: handleChildEnter:with: handleChildLeave:with: handleDrop: handleDropFiles: handleEvent: handleFocusEvent: handleMouseDown: handleMouseEnter: handleMouseLeave: handleMouseMove: handleMouseOver: handleMouseUp: handlesAnyOf: handlesDrop: handlesDropFiles: handlesEvent: handlesKeyboard: handlesMouseDown: keyboardFocusEnter keyboardFocusLeave pressedKeys rejectsEvent: signalEvent: waitForClicksOrDrag:event:)('keyboard events' handleKeyDown: handleKeyUp: handleKeystroke: keyDownMap keyDownMap: keyStrokeMap keyStrokeMap: keyUpMap keyUpMap: onKeyDown:signal: onKeyStroke:signal: onKeyUp:signal:)('graphic' aspectRatio aspectRatio: drawGraphic:on:in: drawGraphicOn:in: graphic graphic:)('highlights' addHighlight: hasHighlight: highlightBounds highlightBounds: highlightNamed: highlights highlights: removeHighlight:)('collision detection' boxCollisionPairs boxCollisionPairsDo: collisionPairs collisionPairsDo: collisionsEnabled collisionsEnabled: preciseCollisions preciseCollisions:)('serialization' postBuildWith: readFieldsFrom: serializableFields serializeOn: setFlag:value: writeContentsOn: writeFieldsOn:)('converting' asCostume asForm asFormExtent: asFormOfDepth: asFormOfDepth:extent: asPlayer asPrimCostume)('properties' hasProperty: propertyValueAt: propertyValueAt:ifAbsent: propertyValueAt:ifAbsentPut: propertyValueAt:put: removeProperty:)('initialize' close destroy initialize intoWorld: outOfWorld: resumeTickingScripts suspendTickingScripts)('removing' remove: remove:ifAbsent: removeAll removeAll: removeAt: removeFrom:to: removeLast)('pen support' assurePen hasPen indicatePenTrails indicatePenTrails: isPenDown isPenDown: pen pen: penColor penColor: penPosition penWidth penWidth:)('tweaking' readTweakedFieldsFrom: tweaked:from:to: tweaks tweaks: writeTweakedFieldsOn:)('other' align:with: colorAt:behind: comeToFront cursorPoint deselect disable enable findPlayerAt: goBehind grabMe moveDownLayer moveUpLayer select windowColor:)('move/resize/scale' forwardBy: localTransformBy: move:duration: moveBy: moveBy:duration: moveTo: moveTo:duration: moveTo:speed: resizeTo: rotateBy: scaleBy: scaleTo: transformBy: turnBy: turnBy:speed:)('primitive behaviors' abruptly: forwardBy:duration:style: gently:lowerBound:upperBound: headingFor: interpolationForStyle: move move: move:distance: move:distance:duration: move:distance:duration:style: moveBy:duration:style: turn turn: turn:turns: turn:turns:duration: turn:turns:duration:style: turnBy:duration:style: turnTo:duration:style:)('private' allocateBorder allocateFill borderWidthForRounding canBltMove:from:to: componentBinding componentBinding: confirm: getCostume inform: invalidationBounds localFullBounds myEventMap myEventMap: myScripts myScripts: newFormCache normalizeWithRotationDegrees normalizeWithRotationDegrees: onPlayerChanged outerBounds printOn: privateAdd:atIndex: privateAdd:beforeIndex: privateBltMove:from:to: privateBounds privateBounds: privateFullBounds privateRemove: privateReplaceFrom:to:with: privateTransform privateTransform: setContainer: structureChanged)('Morphic compatibility' handleDropMorph:)('tk script' asCodeOn:using:)!!CPreDebugger reorganize!('initializing' initialize setupCostume)('events' abort debug debugAt onCloseRequest proceed)('accessing' abortButton abortButton: debugButton debugButton: notifyPane notifyPane: proceedButton proceedButton:)!!CPlayerCollection reorganize!('accessing' at: at:ifAbsent: at:put: contentType costume costume: cursor cursor: size)('adding' add:at: addAll:at:)('removing' removeAll removeFrom:to:)('copying' copyFrom:to: replaceFrom:to:with:startingAt:)('searching' indexOf:startingAt:ifAbsent:)('enumerating' do: keysAndValuesDo: reverseDo:)!!CMultiSelectionHalo reorganize!('initialize' initialize)!!CMultiColumnList reorganize!('initialize' defaultCostume initialize)('accessing' addColumn:for:width:color:action:draw: addColumnSpec: columns columns:)!!CMultiColorPicker reorganize!('events' onColorsChanged onValueChanged)('private' setupPicker)!!CMoviePlayer reorganize!('initialize' initialize)!!CChangedMessageSet reorganize!('initialization' changeSet:)('acceptance' contents:notifying:)('message list' growable)('reformulation' reformulateList)!!CMessageSet reorganize!('initialize' initialize setupCostume)('field access' autoSelectString autoSelectString: selectedReference selectedReference:)('events' onMessageListCursorChanged onSelectedReferenceChanged)('menu' messageListMenu)('serializing')('accessing' messageList messageList:)!!CMenuItemSeparator reorganize!('initialize' initialize)('accessing' action deselect isSeparator select subMenu)!!CDropDownList reorganize!('initialize' defaultCostume initialize)('accessing' allowEditing allowEditing:)('events' onCursorChanged: onValueChanged)!!CList reorganize!('initialize' defaultCostume initialize)('accessing' allowDeselect allowDeselect: contents contents: elements itemMaker itemMaker: items items:)('events' onCursorChanged: onElementsChanged:from:to:event: onWrapCursorChanged:)!!CLibraryEntryCostume reorganize!('events' deselect onDragStart onValueChanged select)('initialize' initialize setupCostume)('accessing' image image: label label:)!!CContextVariablesInspector reorganize!('accessing' fieldList)('selecting' replaceSelectionValue: selection)('code' doItContext doItReceiver)!!CInspector reorganize!('field access' contentsPane contentsPane: listPane listPane:)('accessing' baseFieldList fieldList i1 i2 initialExtent object object: selectedClass selectedMessage selectionIndex selectionIndex: selectionPrintString)('events' onAcceptContentsPane onListCursorChanged)('initialize' initialize setupCostume)('menu commands' addCollectionItemsTo: browseFullProtocol chasePointers classOfSelection classVarRefs copyName defsOfSelection fieldListKeyMap fieldListMenu inspect: inspectBasic inspectElement inspectSelection objectReferencesToSelection referencesToSelection spawnFullProtocol spawnProtocol viewerForValue)('selecting' contentsIsString replaceSelectionValue: selectedSlotName selection selectionUnmodifiable)('code' doItReceiver)('updating' displayContents updateContentsPane updateFull)!!CImagePlayer reorganize!('as yet unclassified')!!CHolder reorganize!('accessing' at: at:ifAbsent: at:put: contentType contents contents: cursor cursor: defaultElement first last selection selection: selectionIndex selectionIndex: size)('testing' isEmpty)('searching' detect: detect:ifNone: findFirstElement: findFirstIndex: findLast: findLastElement: includes: indexOf: indexOf:ifAbsent: indexOf:startingAt:ifAbsent:)('replacing' replace:with: replaceFrom:to:with: replaceFrom:to:with:startingAt:)('streaming' atEnd atStart next peek prev wrapCursor wrapCursor:)('enumerating' allSatisfy: anySatisfy: collect: collect:species: do: keysAndValuesDo: select: select:species:)('copying' copyFrom:to:)('matching' all any)!!CHandPlayer reorganize!('accessing' autoKeyboardFocus lastEvent mouseCursor mouseCursor: mouseOverHandler pressedKeys)('initialize' defaultCostume initialize isSpecialSystemScript: setupCostume)('private' disableGenieFocus: interrupted releaseAllFoci setKeyboardFocus: setMouseFocus:)('private events' dispatchEvent: generateDropFilesEvent: generateKeyboardEvent: generateMouseEvent: mouseTrailFrom: moveToEvent: noticeMouseOver:event: processEvents sendEvent:focus: sendEvent:focus:clear: sendFocusEvent:to:clear: sendKeyboardEvent: sendListenEvent:to: sendMouseEvent: sendMouseOverEvent:)('input state' anyButtonPressed anyModifierKeyPressed blueButtonChanged blueButtonPressed commandKeyPressed controlKeyPressed isKeyPressed: macOptionKeyPressed redButtonChanged redButtonPressed shiftPressed yellowButtonChanged yellowButtonPressed)('drag drop' dragContents dragContents: hasDragContents)('mouse over' cursorFocus cursorFocus: isMouseOver: isOver: isOverPlayer: onUpdateMouseCursor onUpdateMouseOver playersUnder playersUnder: releaseCursorFocus releaseCursorFocus:)('mouse' forEachAndEveryMouseMoveDo: mouseFocus mouseFocus: releaseMouseFocus releaseMouseFocus:)('grabbing/dropping' attach: drop: dropContents grab: grab:from:)('balloon help' balloon: balloonTarget balloonTarget: releaseBalloon:)('serializing' serializeOn:)('keyboard' keyboardFocus keyboardFocus: releaseKeyboardFocus releaseKeyboardFocus:)('halo' halo halo: installHalo)!!CHaloResizer reorganize!('initialize' initialize)('accessing' target target:)('events' onMoveTarget onResizeTarget: onTargetChanged onUpdateGeometry)('private' bottomCenterCursor bottomLeftCursor bottomRightCursor leftCenterCursor rightCenterCursor topCenterCursor topLeftCursor topRightCursor)!!CHaloButton reorganize!('events' onButtonFocusLost onMouseDown onMouseEnter onMouseLeave onMouseUp)('initialize' initialize setupCostume)!!CHalo reorganize!('initialize' handleSpecs initialize)('accessing' label label: multiSelections multiSelections: rootContext rootContext: target target:)('testing' containsPoint:)('events' onBlueButtonDown onDragSelect: onGeometryChanged onKeyDown: onSelectTarget onTargetChanged:from: selectMultipleTargetsIn:)('printing' roleNameFor:)!!CFillStyleReadout reorganize!('initialize' initialize)('events' deselect onValueChanged select)!!CFileSaveDialogCostume reorganize!('initialize' setupCostume)!!CFileSaveDialog reorganize!('initialize' acceptFile: defaultCostume initialize)!!CFileOpenDialogCostume reorganize!('initialize' setupCostume)!!CFileOpenDialog reorganize!('initialize' acceptFile: defaultCostume initialize)!!CFileDialogSorter reorganize!('initialize' initialize)('accessing' primarySort primarySort: secondarySort secondarySort:)('sorting' sort: sortByDate sortByName sortBySize sortByType)('testing' isSortedByDate isSortedByName isSortedBySize isSortedByType)('comparing' compareDate:with: compareDateNot:with: compareName:with: compareNameNot:with: compareSize:with: compareSizeNot:with: compareType:with: compareTypeNot:with:)('private' setSorter:or: sortBy:or:)!!CFileDialogPattern reorganize!('initialize' initialize)('accessing' description description: displayText patterns patterns:)('matching' forceMatch: match:)('printing' printOn:)!!CFileDialogCostume reorganize!('initialize' defaultPlayer initialize setupFileOpenCostume setupFileSaveCostume)('accessing' cancelButton cancelButton: directoryList directoryList: fileList fileList: inputField inputField: okButton okButton: patternList patternList:)('events' expandDirectoryTo: onAccept onCancel onDirListCursorChanged onDirectoryChanged onDoubleClick onExpandDirectory onFileNameChanged onInputFieldChanged onPatternChanged onPlayerChanged onRootDirectoriesChanged)('drawing' drawDate:in:on:font:color: drawName:in:on:font:color: drawSize:in:on:font:color: drawType:in:on:font:color:)!!CFileDialog reorganize!('initialize' defaultCostume defaultLabel fileSpec: initialize)('accessing' directory directory: fileList fileList: fileName fileName: filePatternList filePatternList: fullName fullName: rootDirectories rootDirectories: rootDirectory rootDirectory: selectedPattern selectedPattern: showDirectories showDirectories: sorter sorter: window window:)('events' accept acceptFile: cancel doubleClick: onDirectoryChanged onFileListCursorChanged onOpen onPatternChanged updateFileList)('sorting' resort sortByDate sortByName sortBySize sortByType)('opening' openFile openFile: openFile:label: openLabel:)!!CFieldReference reorganize!('initialize')('accessing' fieldName fieldName: name readValue target target: value value: valueType writeValue)('testing' isFieldReference isReadOnly)('events' onTargetChanged onUpdateFromTarget)('private' fieldDefinition fieldDefinition: privateSetValueTo:)!!CDebugger reorganize!('*Tweak' openNotifierContents:label: openTweakNotifier:)('accessing' contents:notifying: interruptedContext interruptedProcess isNotifier labelString labelString: proceedValue proceedValue: receiver receiverInspector)('class list' selectedClass selectedClassOrMetaClass)('code pane' contentsSelection doItContext doItReceiver pc pcRange)('code pane menu' perform:orSendTo:)('context stack (message list)' contextStackIndex contextStackList expandStack fullyExpandStack messageListIndex selectedMessage selectedMessageName selectedMessageText toggleContextStackIndex:)('context stack menu' browseMessages browseSendersOfMessages browseVersions buildMessageBrowser buildNotifierLabelled:message: contextStackKey:from: doStep down fullStack mailOutBugReport peelToFirst proceed proceed: restart selectPC send stackListMenu stepIntoBlock up where)('events - buttons' onDoStepButton onFullStackButton onProceedButton onRestartButton onSendButton onStepIntoBlockButton onWhereButton)('events - lists' onContextVariableInspectorListChanged onListCursorChanged onReceiverInspectorListChanged)('events' onAcceptCodePane onUpdateCodePane onUpdateContextStackList onUpdateWindowLabel onWindowCloseRequest onWindowColorChanged:)('field-access' contextVariableInspectorContents contextVariableInspectorContents: contextVariableInspectorList contextVariableInspectorList: contextVariablesInspector doStepButton doStepButton: fullStackButton fullStackButton: proceedButton proceedButton: receiverInspectorContents receiverInspectorContents: receiverInspectorList receiverInspectorList: restartButton restartButton: sendButton sendButton: stackListPane stackListPane: stepIntoBlockButton stepIntoBlockButton: whereButton whereButton:)('initialize' abort debugAt: debuggerButtons errorWasInUIProcess: initialize openFullNoSuspendLabel: setupCostume)('inspectors' contextVariableInspectorUpdate receiverInspectorUpdate updateInspectors)('menu notifier' debug)('message category list' selectedMessageCategoryName)('private' checkContextSelection contextStackIndex:oldContextWas: externalInterrupt: isolationRecoveryAdvice lowSpaceChoices newStack: process:controller:context: process:controller:context:isolationHead: resetContext: resumeProcess: selectedContext)!!CCustomDrawListTarget reorganize!('accessing' list list:)('drawing' drawOn:in:)!!CCostume reorganize!('initialize' defaultColor defaultPlayer setupCostume)('events' onPlayerChanged)('serializing' postBuildWith: readFieldsFrom: writeFieldsOn:)!!CColorToolFlagsPage reorganize!('initialize' initialize setupCostume)('accessing' clippingFlag clippingFlag: floatingFlag floatingFlag: infiniteFlag infiniteFlag: lockedFlag lockedFlag: roundedFlag roundedFlag: shadowFlag shadowFlag: stickyFlag stickyFlag: target target: visibleFlag visibleFlag:)('events' onTargetChanged)!!CColorToolFillPage reorganize!('initialize' initialize setupCostume)('accessing' fillAlphaField fillAlphaField: fillAngleField fillAngleField: fillColorChooser fillColorChooser: fillStyleList fillStyleList: label label: target target:)('events' onTargetChanged)!!CColorToolBorderPage reorganize!('initialize' initialize setupCostume)('accessing' borderColorChooser borderColorChooser: borderStyleList borderStyleList: borderWidthField borderWidthField: label label: target target:)('events' onTargetChanged)!!CColorTool reorganize!('initialize' initialize setupCostume)('events' onClose onHaloChanged onNameChanged onOpen onTargetChanged)('accessing' borderPage borderPage: defaultContainer fillPage fillPage: flagsPage flagsPage: geometry target target: window window:)!!CColorPicker reorganize!('initialize' initialize setupPicker)('accessing' colorValues colorValues: colors colors: primaryPicker primaryPicker:)('events' onColorsChanged onMouseDown onValueChanged)('picking' pickColor pickColorAt: pickColorFor:)('private' colorPalette colorPaletteForDepth:extent: newPrimaryColor: newPrimaryPicker: playerForColor: positionInPalette: positionOfColor:)!!CClassBrowser reorganize!('accessing' classButton classButton: classList classList: commentButton commentButton: instanceButton instanceButton: messageCategoryList messageCategoryList: messageList messageList: selectClass: selectClass:selector: selectedClass selectedClassName selectedClassName: selectedMessage selectedMessage: selectedMessageCategory selectedMessageCategory: selectedMessageName selectedSystemCategory selectedSystemCategory: systemCategoryList systemCategoryList: systemOrganizer)('actions-class list' addField classListKeyMap classListMenu copyClass findMethod renameClass)('actions-codepane' defineClass: defineMessageFrom: notify:at:in:)('actions-message categories' addMessageCategory alphabetizeMessageCategories messageCategoryListKeyMap messageCategoryListMenu removeEmptyCategories removeMessageCategory renameMessageCategory)('actions-message list' browseAllMessages browseMethodVersions confirmRemovalOf:in: messageListKeyMap messageListMenu removeMessage)('actions-system categories' addSystemCategory browseAllClasses browseSystemCategory classNotFound editSystemCategories fileOutSystemCategory findClass potentialClassNames printOutSystemCategory recentClass removeSystemCategory renameSystemCategory systemCategoryListKeyMap systemCategoryListMenu updateSystemCategories)('comments' classComment commentIndicated defineComment:)('evaluating' doItReceiver)('events' codePaneContents onAcceptCodePane onClassButton onCommentButton onInstnaceButton onSelectedClassNameChanged onSelectedMessageCategoryChanged onSelectedMessageChanged onSelectedSystemCategoryChanged onUpdateCodePane onUpdateWindowLabel onWindowCloseRequest)('initialize' initialize setupCostume)('list events' onClassListCursorChanged onClassListKeyDown: onKeyDown:in: onMessageCategoryCursorChanged onMessageCategoryListKeyDown: onMessageListCursorChanged onMessageListKeyDown: onSystemCategoryListCursorChanged onSystemCategoryListKeyDown:)('metaclass' metaClassIndicated selectedClassOrMetaClass)!!CChangeSorter reorganize!('TODO' openAsMorphIn:rect: openView:offsetBy:)('accessing' changeSet changeSetCategory changeSetCategory: changeSetCurrentlyDisplayed label labelString myChangeSet myChangeSet: parent parent: parenthesizedCategoryName priorChangeSetList priorChangeSetList: selectedChangeSet)('annotation' addPriorVersionsCountForSelector:ofClass:to:)('changeSet menu' addPreamble addToCategoryOpposite browseChangeSet browseMethodConflicts categorySubmenu: changeSetList changeSetListKey:from: changeSetListMenu checkForAlienAuthorship checkForAnyAlienAuthorship checkForUnclassifiedMethods checkForUncommentedClasses checkForUncommentedMethods checkForUnsentMessages checkThatSidesDiffer: chooseChangeSetCategory chooseCngSet clearChangeSet copyAllToOther currentCngSet editPostscript editPreamble expungeUniclasses fileIntoNewChangeSet fileOut fileOutAllChangeSets fillAggregateChangeSet findCngSet goToChangeSetsProject inspectChangeSet lookForSlips mailOut mainButtonName makeNewCategory makeNewCategoryShowingClassChanges methodConflictsWithOppositeCategory methodConflictsWithOtherSide newCurrent newSet openChangeSetBrowser promoteToTopChangeSet remove removeCategory removeFromCategory removePostscript removePreamble removePrompting: rename renameCategory reorderChangeSets setRecentUpdatesMarker shiftedChangeSetMenu: showCategoriesOfChangeSet showChangeSetCategory: submergeIntoOtherSide subtractOtherSide trimHistory uninstallChangeSet update)('class list' classList classListKey:from: classListMenu copyClassToOther fileOutClass forgetClass messageListKey:from: moveClassToOther removeClass selectedClass selectedClassOrMetaClass)('code pane' contents:notifying: setContents toggleDiffing wantsOptionalButtons)('creation' open setDefaultChangeSetCategory showChangeSet:)('events' onAcceptCodePane onSelectedChangeSetNameChanged onSelectedClassNameChanged onSelectedMessageChanged onUpdateCodePane onUpdateWindowLabel)('events - lists' onChangeSetListCursorChanged onClassListCursorChanged onMethodListCursorChanged)('field access' changeSetListPane changeSetListPane: classListPane classListPane: methodListPane methodListPane: selectedChangeSetName selectedChangeSetName: selectedClassName selectedClassName: selectedMessage selectedMessage:)('initialize' initialize setupCostume)('message list' browseVersions copyMethodToOther forget messageList messageMenu moveMethodToOther removeFromCurrentChanges removeMessage selectedMessageName shiftedMessageMenu:)!!CCodeHolder reorganize!('initialize' defaultContainer initialize initializeStandardCodingKeys macCodingKeys setupCostume win32CodingKeys)('accessing' codePane codePane: codingKeys codingKeys: contents contents: geometry label label: selectedClassOrMetaClass window window:)('selection access' selectedClass selectedClassName selectedSelector)('events' onCodePaneKeyDown: onWindowColorChanged:)('validation' okToChange okToChangeList:from:)('evaluating' doIt doItContext doItReceiver evaluateSelection inspectIt printIt selectFrom:to: selectionInterval)('browsing' allCallsOn: browseAllAccesses:to: browseAllCallsOn: browseAllImplementorsOf: browseAllStores:into: browseClassRefs browseClassVarRefs browseClassVarRefs: browseInstVarDefs browseInstVarDefs: browseInstVarRefs browseInstVarRefs: browseMessageList:name:autoSelect: chooseClassVar:thenDo: chooseInstVar:thenDo: definitionsOfIt lineSelectAndEmptyCheck: referencesToIt)('text' textHolder)('actions - message list' allImplementorsOf: browseAllImplementorsOfList:title: browseImplementors browseMethodFull browseMethodHierarchy browseSenders fileOutMessage findMethodInChangeSets methodHierarchy openSingleMessageBrowser printOutMessage removeFromCurrentChanges revertAndForget revertToPreviousVersion selectMessage:andEvaluate:)('actions - class list' browseClassVariables browseFullProtocol browseUnusedMethods classHierarchy inspectInstances inspectSubInstances makeSampleInstance printOutClass removeClass sampleInstanceOfSelectedClass showUnreferencedClassVars showUnreferencedInstVars spawnHierarchy)('as yet unclassified' cNotYet)!!CBorderStyleReadout reorganize!('initialize' initialize)('events' deselect onValueChanged select)!!CPlayer reorganize!('initialize' defaultCostume defaultPlayer destroy initialize makeDefaultPlayer on: onPlayerChanged setupCostume wearCostume: wearDefaultCostume)('basic' balloonHelp balloonHelp: container container: costume costume: elements elements: fill fill: geometry geometry: grid grid: gridEnabled gridEnabled: hand menu menu: mouseCursor mouseCursor: player player: root textHolder textHolder: value value: windowColor windowColor: world)('queries' allContainersDo: colorAt: colorAt:behind: colorUnder cursorPoint distanceTo: findPlayerAt:)('events' attachBehavior: detachBehavior: eventBehaviors eventBehaviors: onKeyDown:signal: onKeyStroke:signal: onKeyUp:signal:)('properties' clipping clipping: floating floating: infinite infinite: locked locked: sticky sticky: userDraw userDraw: visible visible:)('geometry' angle angle: bottom bottom: bottomLeft bottomLeft: bottomRight bottomRight: bounds bounds: center center: corner corner: extent extent: fullBounds globalBounds globalBounds: globalPosition globalPosition: globalToLocal globalToLocal: heading heading: height height: left left: localBounds localExtent: localToGlobal localToGlobal: origin origin: position position: right right: scale scale: top top: topLeft topLeft: topRight topRight: transform transform: transformBy: width width: x x: y y:)('color and fill' color color: fillAlpha fillAlpha: fillAngle fillAngle: fillColor fillColor: fillColors fillColors: fillOffset fillOffset: fillStyle fillStyle:)('border' border border: borderColor borderColor: borderStyle borderStyle: borderWidth borderWidth:)('graphic' aspectRatio aspectRatio: graphic graphic: graphicAnchorPoint graphicAnchorPoint: graphicEnabled graphicEnabled: graphicFit graphicFit: graphicForm graphicForm: graphicOffset graphicOffset:)('text' font font: text text: textAnchorPoint textAnchorPoint: textAttributes textAttributes: textBorderColor textBorderColor: textBorderWidth textBorderWidth: textColor textColor: textEditor textEmphasis textEmphasis: textEnabled textEnabled: textFont textFont: textInset textInset: textOffset textOffset: textWrap textWrap:)('shadow' dropShadow dropShadow: dropShadowColor dropShadowColor: dropShadowEnabled dropShadowEnabled: dropShadowOffset dropShadowOffset:)('corners' roundCornerSpec roundCornerSpec: roundCorners roundCorners:)('highlights' addHighlight: removeHighlight:)('collisions' collisionsEnabled collisionsEnabled: preciseCollisions preciseCollisions:)('layout' hResizing hResizing: layout layout: layoutBounds layoutBounds: layoutFrame layoutFrame: layoutInset layoutInset: layoutNeeded layoutNeeded: vResizing vResizing:)('adding' add: add:after: add:at: add:before: addAll: addAll:after: addAll:at: addAll:before: addFirst: addLast:)('removing' remove: remove:ifAbsent: removeAll removeAll: removeAt: removeFirst removeFrom:to: removeLast)('animating' bounce bounce: forwardBy: makeSound: moveBy: turnBy: wrap)('selecting' deselect disable enable fire flash select)('scrolling' hScrollable hScrollable: scrollArea scrollArea: scrollDelta scrollDelta: scrollOffset scrollOffset: scrollToShow: scrollingDisabled scrollingDisabled: vScrollable vScrollable: visibleScrollArea)('testing' isIn: isKeyPressed: isPlayer isTilePlayer isUnderMouse isWorld)('converting' asCostume asForm asPlayer asPrimCostume)('drawing' containsPoint: drawOn:in: icon icon: invalidate invalidate: makeIcon makeIcon:)('opening' beOnScreen close defaultContainer isOpen open open:at: open:in: open:in:at: openAt: openAt:in: openCenteredAt: openColored openIn: openIn:at: openInHand)('tk script' adjustColorSpec: asCode asCodeCompiled asCodeOn:using: asEnglish asEnglishOutline asKeywords elementsOn:using: entireObjectOn:using: hasColorSpec propertiesOn:using: tempCode verifyObjGen)('serializing' readFixedFieldsFrom: writeFixedFieldsOn:)('private' dispatchEvent: getCostume getPlayer handlesAnyOf: handlesEvent: listItemValue: makeDefaultCostume onDrag printOn: privateChangeCostumeTo: privateChangePlayerTo: privateChangeValueTo: privateGetValue privateReleaseCostume: privateSetValueTo: signalEvent: tweakedCostume:)!!CPartBinding reorganize!('accessing' home home: name value:)('printing' printOn:)!!CGradientFill reorganize!('testing' isGradientFill isRadialFill isSolidFill isTranslucent)('accessing' alpha alpha: colorRamp colorRamp: colors colors: gradientColor gradientColor: pixelRamp pixelRamp: primaryColor primaryColor: radial radial:)('private' checkTranslucency computePixelRampOfSize: display scaledAlphaMix:of:with: updateFrame:)('*Tweak-Factory')('converting' asColor mixed:with:)!!CBitmapFill reorganize!('accessing' form form: tileFlag tileFlag:)('testing' isBitmapFill isTiled isTranslucent)('converting' asColor)!!COrientedFill reorganize!('accessing' direction direction: frame frame: normal normal: offset offset: origin origin:)('updating' updateFrame:)('testing' isOrientedFill)!!COffsetTransform reorganize!('composing' composedWithLocal:)('accessing' inverseTransformation offset offset: scale)('comparing' = hash)('testing' isIdentity isNoRotationWithin: isNoTransformWithin: isPureTranslation)('transforming' globalBoundsToLocal: globalPointToLocal: localBoundsToGlobal: localPointToGlobal: transformDirection: transformPoint:)('converting' asMatrixTransform2x3)('initialize' setIdentity)('printing' printOn:)!!CObjectMakerImporter reorganize!('import-primitives' importBits:from: importBoolean: importColor: importLiteralAttribute:from: importLiteralFrom: importNumber: importPoint: importString: importStringAttribute:from: importSymbol: importUUID: importUndefinedObject:)('importing' import: import:global: import:maker: import:ref: import:type: importBits:maker:data: importObject:maker: importSequence:maker:size:)('private' convertLiteralNumeric: convertLiteralString: convertLiteralSymbol: errorNotFound: getMaker: resolve:)('import-library' importResources:)('interface' importFrom:in: imports parts)!!CObjectMakerDeserializer reorganize!('importing' import:from: importBitsArray:from: importBitsOf: importClassAttribute:from: importIntegerAttribute:from: importLiteral:from: importObject:from: importReference:from: importSequence:from: importStringAttribute:from:)('accessing' objectMaker objectMaker:)('interface' fieldsDo: readField:ifAbsent: readObjectFrom:)('private' readContentsOf:)!!CNoFill reorganize!('accessing' alpha alpha: angle angle: color color: colors colors: gradientColor gradientColor: offset offset: primaryColor primaryColor: style style:)('testing' isBitmapFill isGradientFill isNoFill isOrientedFill isRadialFill isSolidFill isTranslucent isTransparent)('converting' asColor)('copying' copy)!!CNoBorder reorganize!('accessing' color color: style style: width width:)('testing' isNoBorder isTranslucent)('copying' copy)('private' expandBounds: insetBounds: trackColorFrom:)!!CMultiColumnListSpec reorganize!('accessing' action action: color color: drawSelector drawSelector: drawer drawer: label label: width width:)!!CMenuItem reorganize!('initialize' initialize)('accessing' action action: checked checked: disable disabled disabled: enable enabled enabled: label label: separator separator: subMenu subMenu:)!!CListLayout reorganize!('layout' flushLayoutCache layout:in: layoutHorizontal:in: layoutVertical:in: minExtentHorizontal:in: minExtentOf:in: minExtentVertical:in:)!!CLibraryEntry reorganize!('accessing' image image: label label: library library:)('maker' next)!!CLayoutPolicy reorganize!('initialize' changed invalidateLayout loadFrom: releaseCachedState)('accessing' cellPositioning hResizing hResizing: layoutInset layoutInset: vResizing vResizing:)('layout' flushLayoutCache layout:in: minExtentOf:in:)('testing' isProportionalLayout isSimpleLayout isTableLayout)('utilities')('tk script' entireObjectOn:using:)('serializing' writeFieldsOn:)!!CFramingHighlight reorganize!('accessing' border border: inset inset:)('highlighting' drawOn: highlight unhighlight)('support' expandBounds: priority)!!CFillingHighlight reorganize!('accessing' fill fill:)('highlighting' drawOn:)('support' priority)!!CExampleBehavior reorganize!('events' onMouseEnter onMouseLeave)!!CEventBehavior reorganize!('initialize' attachTo: detach)('accessing' target target:)!!CDropShadowHighlight reorganize!('initialize-release' initialize releaseCachedState)('accessing' color color: offset offset:)('highlighting' drawOn:)('support' expandBounds: noteInvalidationOf: priority)('*Tweak-Factory' readFieldsFrom: writeFieldsOn:)!!CDirectoryEntry reorganize!('accessing' creationTime directory directory: entry entry: extension fileName fileSize icon icon: isDirectory md5Hash modificationTime name)('utilities' appIcon defaultIcon defaultImageIcon directoryIcon getIcon getImageIcon imageIcon soundIcon textIcon videoIcon)!!CDialog reorganize!('as yet unclassified')!!CCursorHighlight reorganize!('accessing' cursor cursor:)('highlighting' highlight unhighlight)!!CCostumeTextHolder reorganize!('initialize' changed initialize loadFrom:)('accessing' anchorPoint anchorPoint: asText attributes attributes: borderColor borderColor: borderWidth borderWidth: bounds color color: contents contents: editor emphasis emphasis: font font: getEditor inset inset: minHeight minWidth minimalTextExtent modified: offset offset: paragraph showCaret showCaret: text text: textBounds textSelectionChanged wrapContents wrapContents:)('testing' hasKeyboardFocus wantsCaretShowingIn:)('serializing' readFieldsFrom: writeFieldsOn:)('scrolling' scrollOffset scrollToSelection)('drawing' containsPoint: drawBorderedTextOn: drawOn:in: invalidate:)('anchoring' adjustTextAnchor:)('keyboard' keyboardFocusEnter keyboardFocusLeave)('private' cursorPoint editorOffset updateParagraphExtent)!!CCoronaHighlight reorganize!('highlighting' drawOn: highlight: unhighlight:)('support' expandBounds: priority)('accessing' color color: width width:)!!CBorderHighlight reorganize!('accessing' border border:)('highlighting' highlight unhighlight)('support' priority)!!CCostumeHighlight reorganize!('initialize' changed initialize)('accessing' active active: isActive isActive: name name:)('support' expandBounds: noteInvalidationOf: priority)('highlighting' drawHighlightOn: drawOn: highlight unhighlight)('*Tweak-Factory')!!CCostumeGrid reorganize!('initialize' changed initialize loadFrom:)('accessing' color color: enabled enabled: extent extent: origin origin: visible visible:)('gridding' drawGridOn:in: drawOn:in: gridPoint: uncachedDrawGridOn:in:)!!CCostumeGraphic reorganize!('initialize' changed initialize loadFrom: minHeight minWidth)('accessing' anchorPoint anchorPoint: bounds extent fit fit: form form: height isOpaque isOpaque: offset offset: opaque opaque: sourceRect sourceRect: width)('drawing' containsPoint: drawOn:in: drawRigidOn:in:opaque: drawScaledOn:in:opaque: drawStretchedOn:in:opaque: drawTiledOn:in:opaque:)('serializing' readFieldsFrom: writeFieldsOn:)!!CCostumeFill reorganize!('initialize' changed initialize loadFrom: releaseCachedState)('accessing' alpha alpha: angle angle: color color: colors colors: frame frame: gradientColor gradientColor: offset offset: primaryColor primaryColor: scaledPixelValue32 style style: verboseStyle verboseStyle:)('testing' isBitmapFill isGradientFill isNoFill isOrientedFill isRadialFill isSolidFill isTranslucent isTransparent)('comparing' = hash)('converting' asColor mixed:with:)('copying' postCopy)('private' cachedFill computeFill computeGradientLength: computeGradientOrigin: computePixelRampOfSize: direction ensureCorrectColors normal origin pixelRamp scaledAlphaMix:of:with: updateFrame:)('*Tweak-Factory' readFieldsFrom: writeFieldsOn:)!!CCostumeBorder reorganize!('initialize' changed initialize loadFrom: releaseCachedState style:width:color:)('accessing' color color: style style: width width:)('drawing' drawLineFrom:to:on: frameOval:on: framePolygon:on: framePolyline:on: frameRectangle:on: frameRoundRect:radius:on:)('operations' expandBounds: insetBounds:)('serializing' readFieldsFrom: writeFieldsOn:)('testing' isNoBorder isTranslucent)('comparing' = hash)('color tracking' colorsAtCorners trackColorFrom:)('private' cachedBorder updateBorder)!!CCostumeAspect reorganize!('initialize' changed initialize invalidate invalidateLayout loadFrom: releaseCachedState)('accessing' costume costume:)('copying' copy postCopy)!!CArrayedCollectionClient reorganize!('initialize' initialize initialize:)('accessing' at: at:ifAbsent: at:put: contentType cursor cursor: size wrapCursor wrapCursor:)('adding' add:at: addAll:at:)('removing' copyFrom:to: removeAll removeFrom:to: replaceFrom:to:with:startingAt:)('enumerating' do: keysAndValuesDo:)!!CCollectionClient reorganize!('initialize' initialize:)('accessing' at: at:ifAbsent: at:put: contentType cursor cursor: size wrapCursor wrapCursor:)('adding' add:at: addAll:at:)('removing' removeAll removeFrom:to: replaceFrom:to:with:startingAt:)('copying' copyFrom:to:)('enumerating' do: keysAndValuesDo:)!!CCollection reorganize!('initialize' initialize)('accessing' at: at:ifAbsent: at:put: contentType contents contents: cursor cursor: defaultElement size wrapCursor wrapCursor:)('adding' add:at: addAll:at:)('removing' removeAll removeFrom:to:)('enumerating' do: keysAndValuesDo: reverseDo:)('copying' copyFrom:to: replaceFrom:to:with:startingAt:)('searching' indexOf:startingAt:ifAbsent:)('serializing' readFixedFieldsFrom: writeFixedFieldsOn:)('private' contentsChanged:with:with:)('sorting' sort:)!!CCollectionBase reorganize!('accessing' at: at:ifAbsent: at:put: contentType contents contents: cursor cursor: defaultElement elements elements: first last selection selection: selectionIndex selectionIndex: size species)('adding' add: add:after: add:at: add:before: addAll: addAll:after: addAll:at: addAll:before: addFirst: addLast:)('removing' remove: remove:ifAbsent: removeAll removeAll: removeAt: removeFirst removeFrom:to: removeLast)('testing' isEmpty)('searching' detect: detect:ifNone: findFirstElement: findFirstIndex: findLastElement: findLastIndex: includes: indexOf: indexOf:ifAbsent: indexOf:startingAt:ifAbsent:)('replacing' replace:with: replaceFrom:to:with: replaceFrom:to:with:startingAt:)('streaming' atEnd atStart next peek prev wrapCursor wrapCursor:)('enumerating' allSatisfy: anySatisfy: collect: collect:species: do: keysAndValuesDo: reverseDo: select: select:species:)('copying' copyFrom:to: reversed)('matching' all any)('printing' printElementsOn: printNameOn: printOn:)('converting' asArray)('sorting' sort sort:)!!CObject reorganize!('initialize' becomeUniClass destroy initialize)('user data' userData userData: userDataAt: userDataAt:ifAbsent: userDataAt:put:)('basic' components costume costume: define:as: name name: player player: value value: valueType)('testing' isCObject isUniClass)('copying' copy postCopy)('components' addComponent:named: addComponentBinding: componentBinding componentBinding: componentHome componentNamed: componentNamed:ifAbsent: fieldNamed: myComponents removeComponentBinding:)('tweaking' isTweaked readTweakedFieldsFrom: tweaked:from:to: tweakedCostume: tweaks tweaks: writeTweakedFieldsOn:)('serializing' postBuildWith: readFieldsFrom: readFixedFieldsFrom: readPropertiesFrom: readProperty:from: readProperty:from:with: readValueFrom: serializeOn: writeFieldsOn: writeFixedFieldsOn: writePropertiesOn: writeProperty:on: writeValueOn:)('properties' propertyValueAt: propertyValueAt:ifAbsent: propertyValueAt:ifAbsentPut: propertyValueAt:put: propertyValueAt:put:with: removePropertyNamed:)('private' confirm: get: inform: myEventMap myEventMap: myProperties myScripts myScripts: printOn: set:to:)('* tk script' equiv:)!!CMouseOverHandler reorganize!('initialize-release' initialize)('accessing' mouseOverList)('event handling' noticeMouseOver:event: processMouseOver:)!!CMouseClickState reorganize!('initialize' client:click:dblClick:dblClickTime:dblClickTimeout:drag:threshold:event:)('event handling' click doubleClick doubleClickTimeout drag: handleEvent:from:)!!CMatrixTransform reorganize!('testing' isIdentity isMatrixTransform2x3 isPureTranslation)('accessing' at: at:put: inverseTransformation offset offset: scale warpCellSize)('transforming points' globalPointToLocal: invertPoint: localPointToGlobal: transformDirection: transformPoint:)('element access' a11 a11: a12 a12: a13 a13: a21 a21: a22 a22: a23 a23:)('composing' composedWithLocal: composedWithLocal:into:)('serializing' serializeOn:)('printing' encodePostscriptOn: printOn:)('comparing' = hash)('transforming rects' globalBounds:toLocal: globalBoundsToLocal: localBounds:toGlobal: localBoundsToGlobal:)('initialize' setIdentiy)('*Tweak-Factory')('converting' asMatrixTransform2x3)('private' setAngle: setOffset: setScale:)('encoding' encodeForRemoteCanvas)('objects from disk' writeOn:)!!CGlobalPart reorganize!('creating' constructPartIn: createPartIn:)('accessing' globalArgs globalArgs: globalName globalName: globalSelector globalSelector: partMaker)('*Tweak-Tweaks' tdlPrintOn:indent:)('exporting' exportXmlOn:key: xmlTagName)!!CMakerPart reorganize!('*Tweak-Tweaks' tdlPrintOn:indent: tdlPrintString tweak:in:)('accessing' partID value value: valueInMaker:)('importing' remapIn: resolveIn:)('creating' constructPartIn: createPartIn: postBuildIn:)('testing' isMakerPart)('exporting' exportMaker:on: exportXmlOn: exportXmlOn:key: xmlString xmlTagName)!!CMD5Hasher reorganize!('initialization' initialize)('public' hashMessage: hashStream:)('private-functions' fX:Y:Z: ffA:B:C:D:M:S:T: gX:Y:Z: ggA:B:C:D:M:S:T: hX:Y:Z: hhA:B:C:D:M:S:T: iX:Y:Z: iiA:B:C:D:M:S:T: step:template:selector:)('private-buffers' finalValue processBuffer: processFinalBuffer:bitLength: storeLength:in:)('private-rounds' round:selector:round: rounds:)!!CLayoutProperties reorganize!('accessing' hResizing hResizing: layoutInset layoutInset: vResizing vResizing:)('testing')('initialize' initialize initializeFrom:)('converting')!!CLayoutFrame reorganize!('accessing' bottomFraction bottomFraction: bottomFraction:offset: bottomOffset bottomOffset: leftFraction leftFraction: leftFraction:offset: leftOffset leftOffset: rightFraction rightFraction: rightFraction:offset: rightOffset rightOffset: topFraction topFraction: topFraction:offset: topOffset topOffset:)('layout' layout:in: minExtentFrom: minExtentFromNEW: minExtentFromOLD:)('objects from disk' convertToCurrentVersion:refStream: negateBottomRightOffsets)('converting' asLayoutFrame)!!CLayoutCell reorganize!('collection' do: inject:into: size)('accessing' addExtraSpace: cellSize cellSize: extraSpace extraSpace: hSpaceFill hSpaceFill: nextCell nextCell: target target: vSpaceFill vSpaceFill:)!!CKeyboardDispatchTable reorganize!('initialize' initialize)('accessing' add:action: addAll: isEmpty lookupEvent: remove:)('private' analyze: bind:to:metaState: lookup:meta: remove:meta:)!!CIdentityTransform reorganize!('transforming points' globalPointToLocal: globalPointsToLocal: invertBoundsRect: localPointToGlobal: localPointsToGlobal:)('composing' composedWith: composedWithGlobal: composedWithLocal:)('transforming rects' globalBoundsToLocal: localBoundsToGlobal: sourceQuadFor:)('accessing' angle inverseTransformation offset)('testing' isIdentity isPureTranslation)('initialize' setIdentity)('converting' asMatrixTransform2x3)!!CIconLibrary reorganize!('accessing' at: icons)('initialize' initialize loadDefaultIcons loadIconsFrom:)!!CGraphicsShape reorganize!('testing' containsPoint:in:)('drawing' drawShapeOn:in:fill:border:)!!CGraphicsFill reorganize!('testing' isBitmapFill isGradientFill isOrientedFill isSolidFill isTranslucent isTransparent)('accessing' scaledPixelValue32)('converting' asB3DColor asColor mixed:with:)!!CFormCache reorganize!('accessing' damageRecorder form form: isValid isValid:)('*Tweak-Factory')('invalidating' invalidate:)('initialize' initialize release)('drawing' drawCached:on:in: repairDamage:using:)!!CDisplayTransform reorganize!('transforming rects' globalBoundsToLocal: localBoundsToGlobal: sourceQuadFor:)('testing' isIdentity isMatrixTransform2x3 isNoRotationWithin: isNoTransformWithin: isPureTranslation)('transforming' invertPoint: invertRect: transformPoint: transformRect: transformedBy:)('transforming points' globalPointToLocal: globalPointsToLocal: invertBoundsRect: localPointToGlobal: localPointsToGlobal:)('initialize' setIdentity)('converting' asMatrixTransform2x3)('accessing' inverseTransformation warpCellSize)('composing' composedWithGlobal: composedWithLocal:)!!CDeserializer reorganize!('interface' deserialize: fieldsDo: readField: readField:ifAbsent:)('initialize' initialize)('deprecated' undefinedToken)!!CDamageRecorder reorganize!('testing' hasDamageInRect: updateIsNeeded)('recording' areaMerged:with: doFullRepaint invalidRectsFullBounds: invalidate invalidate: recordInvalidRect2: recordInvalidRect:)('initialization' reset)!!CCursorLibrary reorganize!('as yet unclassified')!!CCostumePen reorganize!('accessing' color color: isDown isDown: moveFrom:to: width width:)('initialize' defaultColor defaultWidth initialize)('drawing' drawOn:)!!CCornerRounder reorganize!('all' masterMask:masterOverlay: saveBitsUnderCornersOf:on:in:corners: tweakCornersOf:on:in:borderWidth:corners:)!!CComponentBinding reorganize!('accessing' home home: name value:)('testing' isComponentBinding)('printing' printOn:)('*Tweak-Tweaks' tweakedComponent:)!!CClipboard reorganize!('primitives' primitiveClipboardAt: primitiveClipboardAt:put: primitiveClipboardChanged primitiveClipboardClear primitiveClipboardFormat: primitiveClipboardPresent)('initialize' clipboardClear initialize)('accessing' clipboardAt: clipboardAt:put: clipboardFormats clipboardText clipboardText:)('private' contentsAt: contentsAt:put: primitiveClipboardText primitiveClipboardText:)!!CChangeRecord reorganize!('as yet unclassified')!!CCanvasCache reorganize!('as yet unclassified')!!CBorder reorganize!('initialize' releaseCachedState)('drawing' drawLineFrom:to:on: frameOval:on: framePolygon:on: framePolyline:on: frameRectangle:on: frameRoundRect:radius:on:)('*Tweak-Factory')('accessing' baseColor baseColor: color color: colorsAtCorners dotOfSize:forDirection: style width width: widthForRounding)('testing' isBorderStyle isComplex)('comparing' = hash)('converting' asBorder)('color tracking' trackColorFrom:)!!CAnyMatcher reorganize!('private' pvtMatchSelector:arguments:)!!CAllMatcher reorganize!('private' pvtMatchSelector:arguments:)!!CCollectionMatcher reorganize!('private' doesNotUnderstand: privateSetCollectionTarget: pvtMatchSelector:arguments:)!