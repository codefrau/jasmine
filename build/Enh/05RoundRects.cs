'From Squeak3.6 of ''6 October 2003'' [latest update: #5429] on 7 February 2004 at 3:23:36 pm'!"Change Set:		RoundRectsDate:			7 February 2004Author:			Andreas RaabExamples:(Display getCanvas)	frameAndFillRoundRect: Display boundingBox radius: 100 fillStyle: Color white borderWidth: 10 borderColor: Color black.(Display getCanvas asBalloonCanvas)	aaLevel: 4;	frameAndFillRoundRect: Display boundingBox radius: 100 fillStyle: Color green borderWidth: 10 borderColor: Color blue."!!FormCanvas methodsFor: 'drawing-rectangles' stamp: 'ar 2/7/2004 15:12'!fillRoundRect: aRectangle radius: radius fillStyle: fillStyle	fillStyle isTransparent ifTrue:[^self].	radius asPoint <= (0@0) 		ifTrue:[^self fillRectangle: aRectangle fillStyle: fillStyle].	(radius * 2) asPoint >= aRectangle extent 		ifTrue:[^self fillOval: aRectangle fillStyle: fillStyle].	fillStyle isSolidFill 		ifFalse:[^self balloonFillRoundRect: aRectangle radius: radius fillStyle: fillStyle].	self setFillColor: (shadowColor ifNil:[fillStyle asColor]).	^port fillRoundRect: (aRectangle translateBy: origin) truncated radius: radius.! !!FormCanvas methodsFor: 'drawing-rectangles' stamp: 'ar 2/7/2004 15:20'!frameAndFillRoundRect: aRectangle radius: cornerRadius fillStyle: fillStyle borderWidth: bw borderColor: bc	"Draw a rounded rectangle"	self shadowColor ifNotNil:[		^self fillRoundRect: aRectangle radius: cornerRadius fillStyle: shadowColor.	].	"see if the round rect is degenerate"	cornerRadius asPoint <= (0@0) 		ifTrue:[^self frameAndFillRectangle: aRectangle fillColor: fillStyle borderWidth: bw borderColor: bc].	cornerRadius * 2 >= aRectangle width 		ifTrue:[^self fillOval: aRectangle color: fillStyle borderWidth: bw borderColor: bc].	"Okay it's a rounded rectangle"	fillStyle isTransparent ifFalse:["fill interior"		| innerRect radius |		innerRect := aRectangle.		radius := cornerRadius.		bw isZero ifFalse:[			innerRect := innerRect insetBy: bw.			radius := radius - bw.		].		self fillRoundRect: innerRect radius: radius fillStyle: fillStyle.	].	self frameRoundRect: aRectangle radius: cornerRadius width: bw color: bc! !!FormCanvas methodsFor: 'drawing-rectangles' stamp: 'ar 2/7/2004 15:13'!frameRoundRect: aRectangle radius: radius width: borderWidth color: borderColor	"Frame a rounded rectangle with the given attributes."	| innerRect |	(borderWidth isZero or:[borderColor isTransparent])		ifTrue:[^self].	radius asPoint <= (0@0) 		ifTrue:[^self frameRectangle: aRectangle width: borderWidth color: borderColor].	(radius * 2) asPoint >= aRectangle extent 		ifTrue:[^self frameOval: aRectangle width: borderWidth color: borderColor].	"decompose inner rectangle into bezier shape"	innerRect := aRectangle insetBy: borderWidth.	innerRect area <= 0 		ifTrue:[^self fillRoundRect: aRectangle radius: radius fillStyle: borderColor].	self setFillColor: borderColor.	port 		frameRoundRect: (aRectangle translateBy: origin) truncated 		radius: radius truncated 		borderWidth: borderWidth truncated.! !!BalloonCanvas methodsFor: 'private' stamp: 'ar 2/7/2004 15:02'!makeRoundRectShape: aRectangle radius: radius	"decompose a rounded rectangle into bezier form"	| ovalDiameter rectExtent segments points endPoint seg idx offset rectOffset |	ovalDiameter := (radius * 2) asPoint min: aRectangle extent.	(ovalDiameter x <= 0 or:[ovalDiameter y <= 0]) ifTrue:[		"degenerates into rectangle - just hand back four lines"		| topLeft topRight bottomLeft bottomRight |		topLeft := aRectangle topLeft.		topRight := aRectangle topRight.		bottomLeft := aRectangle bottomLeft.		bottomRight := aRectangle bottomRight.		points := Array new: 4*3.		points at: 1 put: topLeft.		points at: 2 put: topLeft.		points at: 3 put: topRight.		points at: 4 put: topRight.		points at: 5 put: topRight.		points at: 6 put: bottomRight.		points at: 7 put: bottomRight.		points at: 8 put: bottomRight.		points at: 9 put: bottomLeft.		points at: 10 put: bottomLeft.		points at: 11 put: bottomLeft.		points at: 12 put: topLeft.		^points	].	rectExtent := aRectangle extent - ovalDiameter.	rectOffset := aRectangle origin.	segments := Bezier2Segment makeEllipseSegments: (0@0 extent: ovalDiameter).	"patch up the segments to include lines connecting the oval parts.	we need: 8*3 points for the oval parts + 4*3 points for the connecting lines"	points := Array new: 12*3.	idx := 0.	endPoint := segments last end + rectOffset.	1 to: 8 by: 2 do:[:i|		i = 1 ifTrue:[offset := rectOffset + (rectExtent x @ 0)].		i = 3 ifTrue:[offset := rectOffset + rectExtent].		i = 5 ifTrue:[offset := rectOffset + (0 @ rectExtent y)].		i = 7 ifTrue:[offset := rectOffset].		seg := segments at: i.		"insert a line segment for the horizontal part of the round rect"		points at: (idx := idx+1) put: endPoint.		points at: (idx := idx+1) put: endPoint.		points at: (idx := idx+1) put: seg start + offset.		"now the first half-arc"		points at: (idx := idx+1) put: seg start + offset.		points at: (idx := idx+1) put: seg via + offset.		points at: (idx := idx+1) put: seg end + offset.		"the second half-arc"		seg := segments at: i+1.		points at: (idx := idx+1) put: seg start + offset.		points at: (idx := idx+1) put: seg via + offset.		points at: (idx := idx+1) put: seg end + offset.		endPoint := seg end + offset.	].	^points! !!BalloonCanvas methodsFor: 'drawing-rectangles' stamp: 'ar 6/8/2003 19:03'!fillRoundRect: aRectangle radius: radius fillStyle: fillStyle	| points |	radius asPoint <= (0@0) 		ifTrue:[^self fillRectangle: aRectangle fillStyle: fillStyle].	(radius * 2) asPoint >= aRectangle extent 		ifTrue:[^self fillOval: aRectangle fillStyle: fillStyle].	"decompose aRectangle into bezier form"	points := self makeRoundRectShape: aRectangle radius: radius.	"blast the bezier shape out"	self		drawBezierShape: points		color: fillStyle		borderWidth: 0		borderColor: nil.! !!BalloonCanvas methodsFor: 'drawing-rectangles' stamp: 'ar 6/8/2003 19:03'!frameRoundRect: aRectangle radius: radius width: borderWidth color: borderColor	| outerPoints innerRect innerRadius innerPoints |	(borderWidth isZero or:[borderColor isTransparent])		ifTrue:[^self].	radius asPoint <= (0@0) 		ifTrue:[^self frameRectangle: aRectangle width: borderWidth color: borderColor].	(radius * 2) asPoint >= aRectangle extent 		ifTrue:[^self frameOval: aRectangle width: borderWidth color: borderColor].	"decompose inner rectangle into bezier shape"	innerRect := aRectangle insetBy: borderWidth.	innerRect area <= 0 		ifTrue:[^self fillRoundRect: aRectangle radius: radius fillStyle: borderColor].	innerRadius := (radius - borderWidth) asPoint.	innerPoints := self makeRoundRectShape: innerRect radius: innerRadius.	"decompose outer rectangle into bezier shape"	outerPoints := self makeRoundRectShape: aRectangle radius: radius.	self		drawGeneralBezierShape: (Array with: outerPoints with: innerPoints)		color: borderColor		borderWidth: 0		borderColor: nil.! !!GrafPort methodsFor: 'drawing support' stamp: 'ar 6/8/2003 18:22'!fillRoundRect: aRectangle radius: radius	| nextY outer nextOuterX ovalDiameter rectExtent rectOffset rectX rectY rectWidth rectHeight ovalRadius ovalRect |	aRectangle area <= 0 ifTrue: [^ self].	ovalDiameter := (radius * 2) asPoint min: aRectangle extent.	(ovalDiameter x <= 0 or:[ovalDiameter y <= 0]) ifTrue:[		^self fillRect: aRectangle offset: 0@0.	].	"force diameter to be even - this simplifies lots of stuff"	ovalRadius := (ovalDiameter x // 2) @ (ovalDiameter y // 2).	(ovalRadius x <= 0 or:[ovalRadius y <= 0]) ifTrue:[		^self fillRect: aRectangle offset: 0@0.	].	ovalDiameter := ovalRadius * 2.	rectExtent := aRectangle extent - ovalDiameter.	rectWidth := rectExtent x.	rectHeight := rectExtent y.	rectOffset := aRectangle origin + ovalRadius.	rectX := rectOffset x.	rectY := rectOffset y.	ovalRect := ovalRadius negated extent: ovalDiameter.	height _ 1.	outer _ EllipseMidpointTracer new on: ovalRect.	nextY _ ovalRadius y.	"upper and lower portions of round rect"	[nextY > 0] whileTrue:[		nextOuterX _ outer stepInY.		width _ nextOuterX * 2 + rectWidth.		destX _ rectX - nextOuterX.		destY _ rectY - nextY.		self copyBits.		destY _ rectY + nextY + rectHeight - 1.		self copyBits.		nextY _ nextY - 1.	].	destX := aRectangle left.	destY := rectOffset y.	height _ rectHeight.	width _ aRectangle width.	self copyBits.! !!GrafPort methodsFor: 'drawing support' stamp: 'ar 6/8/2003 18:55'!frameRoundRect: aRectangle radius: radius borderWidth: borderWidth	| nextY outer nextOuterX ovalDiameter rectExtent rectOffset rectX rectY rectWidth rectHeight ovalRadius ovalRect innerRadius innerDiameter innerRect inner nextInnerX wp |	aRectangle area <= 0 ifTrue: [^ self].	ovalDiameter := (radius * 2) asPoint min: aRectangle extent.	(ovalDiameter x <= 0 or:[ovalDiameter y <= 0]) ifTrue:[		^self fillRect: aRectangle offset: 0@0.	].	"force diameter to be even - this simplifies lots of stuff"	ovalRadius := (ovalDiameter x // 2) @ (ovalDiameter y // 2).	(ovalRadius x <= 0 or:[ovalRadius y <= 0]) ifTrue:[		^self fillRect: aRectangle offset: 0@0.	].	wp := borderWidth asPoint.	ovalDiameter := ovalRadius * 2.	innerRadius := ovalRadius - borderWidth max: 0@0.	innerDiameter := innerRadius * 2.	rectExtent := aRectangle extent - ovalDiameter.	rectWidth := rectExtent x.	rectHeight := rectExtent y.	rectOffset := aRectangle origin + ovalRadius.	rectX := rectOffset x.	rectY := rectOffset y.	ovalRect := 0@0 extent: ovalDiameter.	innerRect := 0@0 extent: innerDiameter.	height _ 1.	outer _ EllipseMidpointTracer new on: ovalRect.	inner := EllipseMidpointTracer new on: innerRect.	nextY _ ovalRadius y.	1 to: (wp y min: nextY) do:[:i|		nextOuterX _ outer stepInY.		width _ nextOuterX * 2 + rectWidth.		destX _ rectX - nextOuterX.		destY _ rectY - nextY.		self copyBits.		destY _ rectY + nextY + rectHeight - 1.		self copyBits.		nextY _ nextY - 1.	].	[nextY > 0] whileTrue:[		nextOuterX _ outer stepInY.		nextInnerX _ inner stepInY.		destX _ rectX - nextOuterX.		destY _ rectY - nextY.		width _ nextOuterX - nextInnerX.		self copyBits.		destX _ rectX + nextInnerX + rectWidth.		self copyBits.		destX _ rectX - nextOuterX.		destY _ rectY + nextY + rectHeight-1.		self copyBits.		destX _ rectX + nextInnerX + rectWidth.		self copyBits.		nextY _ nextY - 1.	].	destX := aRectangle left.	destY := rectOffset y.	height _ rectHeight.	width _ wp x.	self copyBits.	destX := aRectangle right - width.	self copyBits.	innerRadius y = 0 ifTrue:[		destX := aRectangle left + wp x.		destY := rectY.		width := rectWidth.		height := wp y - ovalRadius y.		self copyBits.		destY := aRectangle bottom - wp y.		self copyBits.	].! !!LineSegment methodsFor: 'initialize' stamp: 'ar 6/7/2003 00:09'!initializeFrom: controlPoints	controlPoints size = 2 ifFalse:[self error:'Wrong number of control points'].	start _ controlPoints at: 1.	end _ controlPoints at: 2.! !!LineSegment methodsFor: 'vector functions' stamp: 'ar 6/7/2003 00:08'!controlPoints	^{start. end}! !!LineSegment methodsFor: 'vector functions' stamp: 'ar 6/7/2003 23:39'!controlPointsDo: aBlock	aBlock value: start; value: end! !!LineSegment methodsFor: 'vector functions' stamp: 'ar 6/7/2003 17:21'!lineSegments: steps do: aBlock	"Evaluate aBlock with the receiver's line segments"	aBlock value: start value: end! !!Bezier2Segment methodsFor: 'initialize' stamp: 'ar 6/7/2003 00:09'!initializeFrom: controlPoints	controlPoints size = 3 ifFalse:[self error:'Wrong number of control points'].	start _ controlPoints at: 1.	via _ controlPoints at: 2.	end _ controlPoints at: 3.! !!Bezier2Segment methodsFor: 'vector functions' stamp: 'ar 6/7/2003 00:08'!controlPoints	^{start. via. end}! !!Bezier2Segment methodsFor: 'vector functions' stamp: 'ar 6/7/2003 23:39'!controlPointsDo: aBlock	aBlock value: start; value: via; value: end! !!Bezier2Segment methodsFor: 'vector functions' stamp: 'ar 6/7/2003 17:21'!lineSegments: steps do: aBlock	"Evaluate aBlock with the receiver's line segments"	"Note: We could use forward differencing here."	| last deltaStep t next |	last _ start.	deltaStep _ 1.0 / steps asFloat.	t _ deltaStep.	1 to: steps do:[:i|		next _ self valueAt: t.		aBlock value: last value: next.		last _ next.		t _ t + deltaStep].! !!Bezier3Segment methodsFor: 'initialization' stamp: 'ar 6/7/2003 00:09'!initializeFrom: controlPoints	controlPoints size = 4 ifFalse:[self error:'Wrong number of control points'].	start _ controlPoints at: 1.	via1 _ controlPoints at: 2.	via2 _ controlPoints at: 3.	end _ controlPoints at: 4.! !!Bezier3Segment methodsFor: 'accessing' stamp: 'ar 6/6/2003 21:59'!length	"Answer a gross approximation of the length of the receiver"	^(start dist: via1) + (via1 dist: via2) + (via2 dist: end)! !!Bezier3Segment methodsFor: 'vector functions' stamp: 'ar 6/7/2003 00:08'!controlPoints	^{start. via1. via2. end}! !!Bezier3Segment methodsFor: 'vector functions' stamp: 'ar 6/7/2003 23:39'!controlPointsDo: aBlock	aBlock value: start; value: via1; value: via2; value: end! !!Bezier3Segment methodsFor: 'vector functions' stamp: 'ar 6/7/2003 17:21'!lineSegments: steps do: aBlock	"Evaluate aBlock with the receiver's line segments"	"Note: We could use forward differencing here."	| last deltaStep t next |	last _ start.	deltaStep _ 1.0 / steps asFloat.	t _ deltaStep.	1 to: steps do:[:i|		next _ self valueAt: t.		aBlock value: last value: next.		last _ next.		t _ t + deltaStep].! !!Bezier3Segment methodsFor: 'vector functions' stamp: 'ar 6/6/2003 21:52'!lineSegmentsDo: aBlock	"Evaluate aBlock with the receiver's line segments"	"Note: We could use forward differencing here."	| steps last deltaStep t next |	steps _ 1 max: (self length // 10). "Assume 10 pixels per step"	last _ start.	deltaStep _ 1.0 / steps asFloat.	t _ deltaStep.	1 to: steps do:[:i|		next _ self valueAt: t.		aBlock value: last value: next.		last _ next.		t _ t + deltaStep].! !!LineSegment class methodsFor: 'instance creation' stamp: 'ar 6/7/2003 00:09'!controlPoints: anArray	"Create a new instance of the receiver from the given control points"	anArray size = 2 ifTrue:[^LineSegment new initializeFrom: anArray].	anArray size = 3 ifTrue:[^Bezier2Segment new initializeFrom: anArray].	anArray size = 4 ifTrue:[^Bezier3Segment new initializeFrom: anArray].	self error:'Unsupported'.! !!Bezier2Segment class methodsFor: 'utilities' stamp: 'ar 6/7/2003 18:33'!makeEllipseSegments: aRectangle	"Answer a set of bezier segments approximating an ellipsoid fitting the given rectangle.	This method creates eight bezier segments (two for each quadrant) approximating the oval."	"EXAMPLE: 	This example draws an oval with a red border and overlays the approximating bezier segments on top of the oval (drawn in black), thus giving an impression of how closely the bezier resembles the oval. Change the rectangle to see how accurate the approximation is for various radii of the oval.		| rect |		rect := 100@100 extent: 1200@500.		Display getCanvas fillOval: rect color: Color yellow borderWidth: 1 borderColor: Color red.		(Bezier2Segment makeEllipseSegments: rect) do:[:seg|			seg lineSegmentsDo:[:last :next|				Display getCanvas line: last to: next width: 1 color: Color black]].	"	"EXAMPLE: 		| minRadius maxRadius |		maxRadius := 300.		minRadius := 20.		maxRadius to: minRadius by: -10 do:[:rad|			| rect |			rect := 400@400 - rad corner: 400@400 + rad.			Display getCanvas fillOval: rect color: Color yellow borderWidth: 1 borderColor: Color red.			(Bezier2Segment makeEllipseSegments: rect) do:[:seg|				seg lineSegmentsDo:[:last :next|					Display getCanvas line: last to: next width: 1 color: Color black]]].	"	| nrm topCenter leftCenter rightCenter bottomCenter dir scale seg1a topRight seg1b seg2a bottomRight seg2b center bottomLeft topLeft seg3a seg3b seg4a seg4b |	dir := aRectangle width * 0.5.	nrm := aRectangle height * 0.5.	"Compute the eight control points on the oval"	scale := 0.7071067811865475. "45 degreesToRadians cos = 45 degreesToRadians sin = 2 sqrt / 2"	center := aRectangle origin + aRectangle corner * 0.5.	topCenter := aRectangle topCenter.	rightCenter := aRectangle rightCenter.	leftCenter := aRectangle leftCenter.	bottomCenter := aRectangle bottomCenter.	topRight := (center x + (dir * scale)) @ (center y - (nrm * scale)).	bottomRight := (center x + (dir * scale)) @ (center y + (nrm * scale)).	bottomLeft := (center x - (dir * scale)) @ (center y + (nrm * scale)).	topLeft := (center x - (dir * scale)) @ (center y - (nrm * scale)).	scale := 0.414213562373095. "2 sqrt - 1"	dir := (dir * scale) @ 0.	nrm := 0 @ (nrm * scale).		seg1a := self from: topCenter via: topCenter + dir to: topRight.	seg1b := self from: topRight via: rightCenter - nrm to: rightCenter.	seg2a := self from: rightCenter via: rightCenter + nrm to: bottomRight.	seg2b := self from: bottomRight via: bottomCenter + dir to: bottomCenter.	seg3a := self from: bottomCenter via: bottomCenter - dir to: bottomLeft.	seg3b := self from: bottomLeft via: leftCenter + nrm to: leftCenter.	seg4a := self from: leftCenter via: leftCenter - nrm to: topLeft.	seg4b := self from: topLeft via: topCenter - dir to: topCenter.	^{seg1a. seg1b. seg2a. seg2b. seg3a. seg3b. seg4a. seg4b}! !!Bezier3Segment class methodsFor: 'utilities' stamp: 'ar 6/8/2003 03:25'!makeEllipseSegments: aRectangle	"Answer a set of bezier segments approximating an ellipsoid fitting the given rectangle.	This method creates four bezier segments (one for each quadrant) approximating the oval."	"EXAMPLE: 	This example draws an oval with a red border and overlays the approximating bezier segments on top of the oval (drawn in black), thus giving an impression of how closely the bezier resembles the oval. Change the rectangle to see how accurate the approximation is for various radii of the oval.		| rect |		rect := 100@100 extent: 500@200.		Display getCanvas fillOval: rect color: Color yellow borderWidth: 1 borderColor: Color red.		(Bezier3Segment makeEllipseSegments: rect) do:[:seg|			seg lineSegmentsDo:[:last :next|				Display getCanvas line: last to: next width: 1 color: Color black]].	"	"EXAMPLE: 		| minRadius maxRadius |		maxRadius := 300.		minRadius := 20.		maxRadius to: minRadius by: -10 do:[:rad|			| rect |			rect := 400@400 - rad corner: 400@400 + rad.			Display getCanvas fillOval: rect color: Color yellow borderWidth: 1 borderColor: Color red.			(Bezier3Segment makeEllipseSegments: rect) do:[:seg|				seg lineSegmentsDo:[:last :next|					Display getCanvas line: last to: next width: 1 color: Color black]]].	"	^self makeEllipseSegments: aRectangle count: 4! !!Bezier3Segment class methodsFor: 'utilities' stamp: 'ar 6/8/2003 03:24'!makeEllipseSegments: aRectangle count: segmentCount	"Answer a set of bezier segments approximating an ellipsoid fitting the given rectangle.	This method creates segmentCount bezier segments (one for each quadrant) approximating the oval."	| count angle seg center scale |	center := aRectangle origin + aRectangle corner * 0.5.	scale := aRectangle extent * 0.5.	count := segmentCount max: 2. "need at least two segments"	angle := 360.0 / count.	^(1 to: count) collect:[:i|		seg := self makeUnitPieSegmentFrom: i-1*angle to: i*angle.		self controlPoints: (seg controlPoints collect:[:pt| pt * scale + center])	].! !!Bezier3Segment class methodsFor: 'utilities' stamp: 'ar 6/8/2003 03:26'!makePieSegment: aRectangle from: angle1 to: angle2	"Create a single pie segment for the oval inscribed in aRectangle between angle1 and angle2. If angle1 is less than angle2 this method creates a CW pie segment, otherwise it creates a CCW pie segment."	| seg center scale |	angle1 > angle2 ifTrue:["ccw"		^(self makePieSegment: aRectangle from: angle2 to: angle1) reversed	].	"create a unit circle pie segment from angle1 to angle2"	seg := self makeUnitPieSegmentFrom: angle1 to: angle2.	"scale the segment to fit aRectangle"	center := aRectangle origin + aRectangle corner * 0.5.	scale := aRectangle extent * 0.5.	^self controlPoints: (seg controlPoints collect:[:pt| pt * scale + center])! !!Bezier3Segment class methodsFor: 'utilities' stamp: 'ar 6/8/2003 03:53'!makePieSegments: aRectangle from: angle1 to: angle2	"Create a series of cubic bezier segments for the oval inscribed in aRectangle between angle1 and angle2. The segments are oriented clockwise, to get counter-clockwise segments simply switch angle1 and angle2."	angle2 < angle1 ifTrue:[		"ccw segments"		^(self makePieSegments: aRectangle from: angle2 to: angle1) 			reversed collect:[:seg| seg reversed]	].	"Split up segments if larger than 120¡"	angle2 - angle1 > 120 ifTrue:["subdivide"		| midAngle |		midAngle := angle1 + angle2 * 0.5.		^(self makePieSegments: aRectangle from: angle1 to: midAngle),			(self makePieSegments: aRectangle from: midAngle to: angle2).	].	"Create actual pie segment"	^self makePieSegment: aRectangle from: angle1 to: angle2! !!Bezier3Segment class methodsFor: 'utilities' stamp: 'ar 6/8/2003 03:59'!makeUnitPieSegmentFrom: angle1 to: angle2	"Create a clockwise unit pie segment from angle1 to angle2, that is a pie segment for a circle centered at zero with radius one. Note: This method can be used to create at most a quarter circle."	| pt1 pt2 rad1 rad2 |	rad1 := angle1 degreesToRadians.	rad2 := angle2 degreesToRadians.	pt1 := rad1 sin @ rad1 cos negated.	pt2 := rad2 sin @ rad2 cos negated.	^self makeUnitPieSegmentWith: pt1 and: pt2! !!Bezier3Segment class methodsFor: 'utilities' stamp: 'ar 6/8/2003 04:45'!makeUnitPieSegmentWith: point1 and: point2	"Create a clockwise unit pie segment from point1 to point2, that is a pie segment for a circle centered at zero with radius one."	| pt1 pt2 dir1 dir2 mid length scale cp1 cp2 pt3 magic |	"point1 and point2 are the points on the unit circle	for accuracy (or broken input), renormalize them."	pt1 := point1 normalized.	pt2 := point2 normalized.	"compute the normal vectors - those are tangent directions for the bezier"	dir1 := pt1 y negated @ pt1 x.	dir2 := pt2 y negated @ pt2 x.	"Okay, now that we have the points and tangents on the unit circle, let's do the magic. For fitting a cubic bezier onto a circle section we know that we want the end points be on the circle and the tangents to point towards the right direction (both of which we have in the above). What we do NOT know is how to scale the tangents so that midpoint of the bezier is exactly on the circle.	The good news is that there is a linear relation between the length of the tangent vectors and the distance of the midpoint from the circle's origin. The bad news is that I don't know how to derive it analytically. So what I do here is simply sampling the bezier twice (not really - the first sample is free) and then to compute the distance from the sample."	"The first sample is just between the two points on the curve"	mid := pt1 + pt2 * 0.5.	"The second sample will be taken from the curve with coincident control points at the intersection of dir1 and dir2, which simplifies significantly with a little understanding about trigonometry, since the angle formed between mid, pt1 and the intersection is the same as between the center, pt1 and mid."	length := mid r.	"length is not only the distance from the center of the unit circle but also the sine of the angle between the circle's center, pt1 and mid (since center is at zero and pt1 has unit length). Therefore, to scale dir1 to the intersection with dir2 we can use mid's distance from pt1 and simply divide it by the sine value."	scale := (mid dist: pt1).	length > 0.0 ifTrue:[ scale := scale / length].	"now sample the cubic bezier (optimized version for coincident control points)"	cp1 := pt1 + (dir1 * (scale * 0.75)).	cp2 := pt2 - (dir2 * (scale * 0.75)).	pt3 := cp1 + cp2 * 0.5.	"compute the magic constant"	scale := (pt3 - mid) r / scale.	magic := 1.0 - length / scale.	"and finally answer the pie segment"	^self		from: pt1		via: pt1 + (dir1 * magic)		and: pt2 - (dir2 * magic)		to: pt2! !FormCanvas removeSelector: #frameAndFillRoundRect:radius:fill:borderWidth:borderColor:!